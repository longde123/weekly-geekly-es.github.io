<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 🍪 🤥 Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 3 👈🏻 🍘 🌀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425559/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 3: “Desbordamientos del búfer: exploits y protección” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 4: “Separación de privilegios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 5: “¿De dónde vienen los sistemas de seguridad?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lección 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 7: “Sandbox de cliente nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 8: "Modelo de seguridad de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 9: "Seguridad de aplicaciones web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 10: “Ejecución simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Ahora, siguiendo la rama hacia abajo, vemos la expresión t = y.  Como estamos considerando una ruta a la vez, no tenemos que introducir una nueva variable para t.  Simplemente podemos decir que dado que t = y, entonces t ya no es 0. <br><br>  Continuamos moviéndonos hacia abajo y llegamos al punto donde llegamos a otra rama.  ¿Cuál es la nueva suposición que debemos hacer para seguir por este camino?  Esta es una suposición de que t &lt;y. <br><br>  ¿Qué es t?  Si busca la rama derecha, veremos que t = y.  Y en nuestra tabla, T = y e Y = y.  Se deduce lógicamente de esto que nuestra restricción se ve como y &lt;y, que no puede ser. <br><br><img src="https://habrastorage.org/webt/tu/pe/kp/tupekplxzar-nappngbqlwuy12y.jpeg"><br><br>  Por lo tanto, teníamos todo en orden hasta llegar a este punto t &lt;y.  Hasta que lleguemos a la afirmación falsa, tenemos todas las desigualdades para ser correctas.  Pero esto no funciona, porque al realizar tareas de la rama correcta, tenemos una inconsistencia lógica. <br><br>  Tenemos lo que a menudo se llama la condición del camino.  Esta condición debe ser cierta para que el programa siga este camino.  Pero sabemos que esta condición no se puede cumplir, por lo tanto, es imposible que el programa siga este camino.  Por lo tanto, este camino ahora se ha eliminado por completo, y sabemos que este camino correcto no se puede recorrer. <br><br>  ¿Qué hay de la otra manera?  Intentemos pasar por la rama izquierda de una manera diferente.  ¿Cuáles serán las condiciones para este camino?  Nuevamente, nuestro estado simbólico comienza en t = 0, y X e Y son iguales a las variables x e y. <br><br><img src="https://habrastorage.org/webt/5a/oo/cc/5aooccskimxeaooehicyxgew8jc.jpeg"><br><br>  ¿Cómo se ve la restricción de ruta en este caso ahora?  Denotamos la rama izquierda como Verdadero, y la rama derecha como Falso y además consideramos el valor t = x.  Como resultado del procesamiento lógico de las condiciones t = x, x&gt; y y t &lt;y, obtenemos que simultáneamente tenemos lo que x&gt; y y x &lt;y. <br><br><img src="https://habrastorage.org/webt/jz/lz/9e/jzlz9e9yvnbqh7y3wwaowffufuc.jpeg"><br><br>  Está claro que esta condición del camino no es satisfactoria.  No podemos tener x que sea más grande y más pequeño que y.  No hay asignación a una variable X que satisfaga ambas restricciones.  Por lo tanto, esto nos dice que la otra forma también es insatisfactoria. <br><br>  Resulta que en este momento exploramos todos los caminos posibles en el programa que podrían llevarnos a este estado.  De hecho, podemos establecer y verificar que no hay una forma posible que nos lleve a la declaración falsa. <br>  <b>Público:</b> en este ejemplo, demostró que estudió el progreso de un programa en todas las ramas posibles.  Pero una de las ventajas de la ejecución simbólica es que no necesitamos estudiar todas las rutas exponenciales posibles.  Entonces, ¿cómo evitar esto en este ejemplo? <br><br>  <b>Profesor:</b> Esta es una muy buena pregunta.  En este caso, se compromete entre la ejecución del personaje y cuán específico quiere ser.  Entonces, en este caso, no estamos usando tanto la ejecución simbólica como la primera vez que miramos el flujo del programa en ambas ramas simultáneamente.  Pero gracias a esto, nuestras limitaciones se han vuelto muy, muy simples. <br><br>  Las restricciones individuales "de una manera tras otra" son muy simples, pero hay que hacerlo una y otra vez, estudiando todas las ramas existentes, y exponencialmente, y todas las formas posibles. <br>  Hay exponencialmente muchas rutas, pero para cada ruta en su conjunto, también hay un conjunto exponencialmente grande de datos de entrada que pueden ir por esa ruta.  Entonces, esto ya le da una gran ventaja, porque en lugar de intentar todas las entradas posibles, está intentando hacerlo de todas las formas posibles.  ¿Pero puedes hacer algo mejor? <br><br>  Esta es una de las áreas donde se ha realizado mucha experimentación con respecto a la ejecución simbólica, por ejemplo, la ejecución simultánea de varios caminos.  En los materiales de la conferencia conociste la heurística y un conjunto de estrategias que los experimentadores usaron para hacer que la búsqueda sea más solucionable. <br><br>  Por ejemplo, una de las cosas que hacen es que exploran de una manera tras otra, pero no lo hacen completamente a ciegas.  Verifican las condiciones de la ruta después de cada paso dado.  Supongamos que aquí en nuestro programa, en lugar de decir "falso", habría un árbol complejo de programas, un gráfico de flujo de control. <br><br><img src="https://habrastorage.org/webt/ly/a_/em/lya_em86ezzhqftrrv247zfdnwq.jpeg"><br><br>  No necesita esperar hasta llegar al final para verificar que este camino sea factible.  En ese momento, cuando alcanza la condición t &lt;y, ya sabe que este camino no es satisfactorio, y nunca irá en esa dirección.  Por lo tanto, cortar las ramas incorrectas al comienzo del programa reduce la cantidad de trabajo empírico.  La exploración razonable de la ruta evita la posibilidad de fallas en el programa en el futuro.  Muchas de las herramientas prácticas que se usan hoy en día comienzan principalmente con pruebas aleatorias para obtener el conjunto inicial de caminos, después de lo cual comenzarán a explorar los caminos en el vecindario.  Procesan muchas opciones para la posible ejecución del programa para cada una de las ramas, preguntándose qué sucede en estos caminos. <br><br>  Es especialmente útil si tenemos un buen conjunto de pruebas.  Ejecutas tu prueba y descubres que este código no se está ejecutando.  Por lo tanto, puede tomar la ruta más cercana a la implementación del código y preguntar si esta ruta se puede cambiar para que vaya en la dirección correcta. <br><br><img src="https://habrastorage.org/webt/ik/26/yz/ik26yz36aargvenedflizgtebnu.jpeg"><br><br>  Pero en el momento en que intentas hacer todos los caminos al mismo tiempo, comienzan las restricciones que se vuelven intratables.  Por lo tanto, lo que puede hacer es realizar una función a la vez, mientras que puede aprender todos los caminos en una función juntos.  Si intenta hacer bloques grandes, en general puede explorar todas las formas posibles. <br><br>  Lo más importante es que para cada rama verifique sus restricciones y determine si esta rama realmente puede ir en ambos sentidos.  Si ella no puede seguir ambos caminos, ahorrará tiempo y esfuerzo al no seguir en la dirección donde no puede ir.  Además, no recuerdo las estrategias específicas que utilizan para encontrar formas que tienen más probabilidades de producir muy buenos resultados.  Pero cortar las ramas incorrectas en la etapa inicial es muy importante. <br><br>  Hasta ahora, hemos estado hablando principalmente sobre "código de juguete", sobre variables enteras, sobre ramas, sobre cosas muy simples.  Pero, ¿qué sucede cuando tienes un programa más complejo?  En particular, ¿qué sucede cuando tienes un programa que incluye un montón? <br><br><img src="https://habrastorage.org/webt/jh/u9/j0/jhu9j05lzmmvolihvaaluj4tqqe.jpeg"><br><br>  Históricamente, el montón de moda ha sido la maldición de todos los análisis de software, porque las cosas limpias y elegantes de la época de Fortran explotan por completo cuando intentas ejecutarlas usando programas C en los que asignas memoria de izquierda a derecha.  Allí tiene superposiciones y todo el desorden asociado con el programa con memoria asignada y punteros aritméticos.  Esta es una de las áreas donde la ejecución simbólica tiene una capacidad sobresaliente para razonar sobre los programas. <br><br>  Entonces, ¿cómo hacemos esto?  Olvidemos las ramas y el flujo de control por un momento.  Tenemos un programa simple aquí.  Asigna algo de memoria, la anula y obtiene un nuevo puntero y del puntero x.  Luego escribe algo a y y comprueba si el valor almacenado en el puntero y es igual al valor almacenado en el puntero x? <br><br>  Con base en un conocimiento básico de C, puede ver que esta verificación no se realiza porque x se restablece yy = 25, por lo que x indica una ubicación diferente.  Hasta ahora, todo está bien con nosotros. <br>  La forma en que modelamos el montón, y la forma en que se modela el montón en la mayoría de los sistemas, utiliza la representación del montón en C, donde es solo una base de direcciones gigantesca, una matriz gigantesca en la que puede colocar sus datos. <br>  Esto significa que podemos representar nuestro programa como un conjunto de datos global muy grande, que se llamará MEM.  Esta es una matriz que esencialmente va a asignar direcciones a valores.  Una dirección es solo un valor de 64 bits.  ¿Y qué pasará después de leer algo de esta dirección?  Depende de cómo modeles la memoria. <br><br>  Si lo modelas a nivel de byte, obtienes un byte.  Si lo modelas a nivel de palabra, obtienes una palabra.  Dependiendo del tipo de errores que le interesen, y dependiendo de si le preocupa la asignación de memoria o no, la modelará de manera un poco diferente, pero generalmente la memoria es solo una matriz de dirección a valor. <br><br><img src="https://habrastorage.org/webt/ml/5h/u3/ml5hu3rxqhuwkwjute0ykkgzzru.jpeg"><br><br>  Entonces la dirección es solo un número entero.  En cierto modo, no importa lo que C piense de la dirección, es solo un número entero de 64 o 32 bits, dependiendo de su máquina.  Es simplemente un valor que está indexado en esta memoria.  Y lo que puedes poner en la memoria, puedes leerlo desde esa memoria. <br><br>  Por lo tanto, cosas como la aritmética de puntero se convierten en aritmética de enteros.  En la práctica, hay algunas dificultades, porque en C, la aritmética del puntero sabe acerca de los tipos de puntero, y aumentarán en proporción al tamaño.  Entonces, como resultado, obtenemos la siguiente línea: <br><br>  y = x + 10;   sizeof (int) <br><br><img src="https://habrastorage.org/webt/nw/kg/zi/nwkgziisznkedw-6waxmrpsdn9a.jpeg"><br><br>  Pero lo que realmente importa es lo que sucede cuando escribes y lees de memoria.  Basado en el puntero de que 25 debería escribirse en y, tomo una matriz de memoria y la indexo con y.  Y escribo 25 en esta ubicación de memoria. <br><br>  Luego paso a la declaración MEM [y] = MEM [x], leo el valor de la ubicación y en la memoria, leo el valor de la ubicación x en la memoria y los comparo entre sí.  Así que verifico si coinciden o no. <br><br>  Esta es una suposición muy simple, que le permite cambiar de un programa que usa heap a un programa que usa esta gigantesca matriz global que representa la memoria.  Esto significa que ahora, cuando se habla de programas que administran el montón, realmente no es necesario hablar de programas que administran el montón.  Lograrás hablar perfectamente sobre matrices y no sobre montones. <br><br>  Aquí hay otra pregunta simple.  ¿Qué pasa con la función malloc?  Simplemente puede tomar y usar la implementación de malloc en C, realizar un seguimiento de todas las páginas resaltadas, realizar un seguimiento de todo lo que se ha liberado, simplemente tener una lista gratuita y eso es suficiente.  Resulta que para muchos propósitos y para muchos tipos de errores no necesita malloc para ser complejo. <br><br>  De hecho, puede cambiar de malloc, que se ve así: x = malloc (sizeof (int) * 100), a malloc de este tipo: <br><br>  POS = 1 <br>  Int malloc (int n) { <br>  rv = POS <br>  POS + = n; <br>  } <br><br>  Lo que simplemente dice: "Voy a guardar el contador para el próximo espacio libre en la memoria, y cada vez que alguien solicita una dirección, le doy esta ubicación y la aumento, y luego devuelvo rv".  En este caso, lo que malloc en el sentido tradicional se ignora por completo. <br><br><img src="https://habrastorage.org/webt/pp/tl/_r/pptl_romuwu16scn3eykmzscdmm.jpeg"><br><br>  En este caso, no hay liberación de memoria.  La función simplemente continúa moviéndose más y más lejos de la memoria, y más y más, y aquí es donde termina sin ninguna liberación.  Tampoco le importa que haya áreas de memoria en las que no valga la pena escribir, porque hay direcciones especiales de especial importancia reservadas para el sistema operativo. <br><br>  No modela nada que haga que la escritura de la función malloc sea complicada, pero solo a un cierto nivel de abstracción, cuando intentas hablar sobre algún tipo de código complejo que realiza manipulaciones de puntero. <br><br>  Al mismo tiempo, no le importa liberar memoria, pero le preocupa si el programa va a escribir, por ejemplo, fuera de un búfer, en cuyo caso esta función malloc puede ser bastante buena. <br><br><img src="https://habrastorage.org/webt/kw/hy/sr/kwhysrcz5pnqvcxeuskiazouxgs.jpeg"><br><br>  Y esto realmente sucede muy, muy a menudo cuando haces una ejecución simbólica de código real.  Un paso muy importante es modelar las funciones de su biblioteca.  La forma en que modela las funciones de la biblioteca tendrá un gran impacto, por un lado, en el rendimiento y la escalabilidad del análisis, pero por otro lado, también afectará la precisión. <br><br>  Entonces, si tiene un modelo de "juguete" malloc, como este, actuará muy rápidamente, pero al mismo tiempo habrá ciertos tipos de errores que no podrá notar.  Entonces, por ejemplo, en este modelo ignoro completamente las distribuciones, por lo que puedo obtener un error si alguien tiene acceso al espacio no asignado.  Por lo tanto, en la vida real, nunca usaré este modelo malloc de Mickey Mouse. <br><br>  Por lo tanto, siempre hay un equilibrio entre la precisión del análisis y la eficiencia.  Y cuanto más complejos son los modelos de funciones estándar, como malloc, menos escalable es su análisis.  Pero para algunas clases de error necesitará estos modelos simples.  Por lo tanto, varias bibliotecas en C son de gran importancia, que son necesarias para comprender lo que realmente hace un programa de este tipo. <br><br>  Por lo tanto, redujimos el problema de razonar sobre el montón al razonar sobre el programa con matrices, pero realmente no le dije cómo razonar sobre el programa con matrices.  Resulta que la mayoría de los solucionadores SMT admiten la teoría de matrices. <br><br><img src="https://habrastorage.org/webt/p3/m3/4j/p3m34j1tdfcrmtpyngc-syfb7rs.jpeg"><br><br>  La idea es que si a es una matriz, entonces hay alguna notación que le permite tomar esta matriz y crear una nueva matriz, donde la ubicación i se actualiza al valor e.  ¿Eso está claro? <br><br>  Por lo tanto, si tengo una matriz a, y hago esta operación de actualización, y luego trato de leer el valor de k, entonces esto significa que el valor de k será igual al valor de k en la matriz a, si k es diferente de i, y será igual a e, si k es igual a i. <br><br>  Actualizar una matriz significa que necesita tomar la matriz anterior y actualizarla con una nueva matriz.  Bueno, si tiene una fórmula que incluye la teoría de las matrices, es por eso que comencé con una matriz cero, que en todas partes está representada simplemente por ceros. <br><br><img src="https://habrastorage.org/webt/ga/gt/v_/gagtv_latqjqssanfp7tqklcq5i.jpeg"><br><br>  Luego escribo 5 en la ubicación iy 7 en la ubicación j, después de lo cual leo de k y verifico si es 5 o no.  Luego se puede expandir usando la definición de algo que dice, por ejemplo: “si k es iyk es y, mientras que k es diferente de j, entonces sí será 5, de lo contrario no será 5 ". <br><br>  Y en la práctica, los solucionadores SMT no solo expanden esto a muchas fórmulas booleanas, sino que usan esta estrategia de ida y vuelta entre el solucionador SAT y el motor, que puede hablar sobre la teoría de matrices para llevar a cabo este trabajo. <br><br>  Lo importante es que confiando en esta teoría de matrices, utilizando la misma estrategia que aplicamos para generar fórmulas para enteros, en realidad puede generar fórmulas que incluyen lógica de matriz, actualizaciones de matriz, ejes de matriz, iteración de matriz.  Y siempre que corrija su camino, estas fórmulas son muy fáciles de generar. <br>  Si no corrige sus rutas, pero desea crear una fórmula que corresponda al paso del programa por todas las rutas, entonces esto también es relativamente fácil.  Lo único con lo que tiene que lidiar es con un tipo especial de bucles. <br><br>  Los diccionarios y mapas también son muy fáciles de modelar utilizando funciones indefinidas.  En realidad, la teoría de las matrices en sí es solo un caso especial de una función indefinida.  Con la ayuda de tales funciones, se pueden hacer cosas más complicadas.  En el solucionador SMT moderno, hay soporte incorporado para razonar sobre conjuntos y operaciones de conjuntos, lo que puede ser muy útil si se trata de un programa que incluye el cálculo de conjuntos. <br><br>  Al diseñar una de estas herramientas, la fase de modelado es muy importante.  Y el punto no es solo cómo modela las funciones complejas del programa hasta sus teorías, por ejemplo, cosas como reducir los montones a matrices.  El punto también es qué teorías y solucionadores usas.  Hay una gran cantidad de teorías y solucionadores con diferentes relaciones, para lo cual es necesario elegir un compromiso razonable entre eficiencia y costo. <br><br><img src="https://habrastorage.org/webt/wf/o9/2m/wfo92mcuifuz0rgcowvad6wrcxs.jpeg"><br><br>  La mayoría de las herramientas prácticas se adhieren a la teoría de los vectores de bits y, si es necesario, pueden usar la teoría de las matrices para modelar montones.  En general, las herramientas prácticas intentan evitar teorías más complejas, como la teoría de conjuntos.  Esto se debe a que generalmente son menos escalables en algunos casos, si no se trata de un programa que realmente requiere este tipo de herramienta para funcionar. <br><br>  <b>Audiencia:</b> además del estudio del rendimiento simbólico, ¿en qué se centran los desarrolladores? <br><br> <b>:</b>       —      ,      . , , ,             ,       .    ,     . <br><br>  ,       ,         .    ,       ,      ,   ,  ,    ,    ,            . <br><br> ,   —   ,     ,      . ,   ,           —     ,   JavaScript  Python,         .             ,     . <br><br><img src="https://habrastorage.org/webt/k_/hw/9f/k_hw9fclb1unjv4v4jojv1a-4bk.jpeg"><br><br>       ,             Python.  ,         ,        : «,    ,    ,     ».   . <br><br> ,         ,   ,       ,    ,     . <br>   ,  ,   ,      -  ,           ,             . <br><br>      ,     ,     ,      .  , ,         Microsoft Word,     , ,   . <br><br>       , ,     ,         ,      . <br><br>    ,          .    ,        ,   - ,   - .    ,    ,      .     ,       . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La versión completa del curso está disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps hasta diciembre de forma gratuita</b> al pagar por un período de seis meses, puede ordenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425559/">https://habr.com/ru/post/es425559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425549/index.html">Supermicro se desploma en medio de una investigación sobre el despliegue de chips espías chinos</a></li>
<li><a href="../es425551/index.html">¿Quién debería recibir dinero de la venta de una obra de arte creada por AI?</a></li>
<li><a href="../es425553/index.html">Lo que el conde de Montecristo puede decirnos sobre la ciberseguridad</a></li>
<li><a href="../es425555/index.html">Charles Nutter sobre lenguajes dinámicos en la JVM en jug.msk.ru</a></li>
<li><a href="../es425557/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 1</a></li>
<li><a href="../es425561/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 2</a></li>
<li><a href="../es425563/index.html">California prohíbe la venta de dispositivos IoT con o sin contraseñas simples</a></li>
<li><a href="../es425565/index.html">Matemáticas rápidas de punto fijo para aplicaciones financieras en Java</a></li>
<li><a href="../es425569/index.html">Pruebas funcionales de PCB</a></li>
<li><a href="../es425571/index.html">Asegurar un servidor web en Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>