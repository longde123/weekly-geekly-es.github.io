<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèª üöñ üçú Art√≠culos de la conferencia de primavera C ++ Rusia 2018 ü§µüèª üë©üèº‚Äçüíº üèóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Del 19 al 21 de abril, se celebr√≥ la conferencia C ++ Rusia 2018 en San Petersburgo. De a√±o en a√±o, la organizaci√≥n y la conducta se elevan un nivel m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Art√≠culos de la conferencia de primavera C ++ Rusia 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418645/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/m8/km/ifm8kmasjfgchispcdfdx3-2ax0.png"></div><br>  Del 19 al 21 de abril, se celebr√≥ la conferencia C ++ Rusia 2018 en San Petersburgo. De a√±o en a√±o, la organizaci√≥n y la conducta se elevan un nivel m√°s, lo cual es una buena noticia.  Gracias al organizador permanente de C ++ Rusia Sergey Platonov por su contribuci√≥n al desarrollo de esta √°rea. <br><a name="habracut"></a><br>  El 19 de abril, se planificaron clases magistrales, que desafortunadamente no pudimos asistir, y del 20 al 21 se llev√≥ a cabo el programa principal de la conferencia, en el que participamos con gran inter√©s.  Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Sermp</a> hizo un gran trabajo y atrajo a varios oradores extranjeros notables como oradores.  El primer d√≠a de la conferencia fue inaugurado por Jon Kalb, el organizador de CppCon y autor de C ++ Today: The Beast is Back.  El segundo d√≠a comenz√≥ con una presentaci√≥n de Daveed Vandevoorde, miembro del comit√© de estandarizaci√≥n, uno de los autores de C ++ Templates: The Complete Guide.  Andrei Alexandrescu estaba en el centro de atenci√≥n, quien, despu√©s de su informe sobre excepciones, en un momento reuni√≥ a toda una multitud de personas que quer√≠an obtener un aut√≥grafo y tomar una foto conjunta.  Por primera vez, se transmiti√≥ una charla de Herb Sutter en Skype sobre el operador de la nave espacial para C ++ 20. <br><br>  Aunque la conferencia tuvo lugar hace m√°s de 3 meses, el video ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de reproducci√≥n completa</a> ) se public√≥ en este momento, por lo que es hora de refrescar sus recuerdos y sumergirse en las incre√≠bles caracter√≠sticas de C ++. <br><br><h3>  Jon Kalb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ Today: The Beast is Back</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qj/4d/qxqj4duts1eygoh4trgst-2i8bw.png"></div><br>  Esta charla cubre por qu√© los ingenieros que buscan rendimiento eligen C ++.  Jon presenta una perspectiva hist√≥rica de C ++ centr√°ndose en lo que est√° sucediendo en la comunidad de C ++ en este momento y hacia d√≥nde se dirige el lenguaje y su base de usuarios.  Con un renovado inter√©s en el rendimiento tanto para los centros de datos como para los dispositivos m√≥viles, y el √©xito de las bibliotecas de software de c√≥digo abierto, C ++ ha vuelto y est√° de moda.  Esta charla explica por qu√© C ++ es el lenguaje m√°s utilizado por los ingenieros de software para el rendimiento.  Recibir√° un esbozo hist√≥rico aproximado que pone a C ++ en perspectiva y cubre sus altibajos de popularidad. <br><br><h3>  Arno Sch√∂dl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">De iteradores a rangos</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/wi/1c/g2wi1czg7ulvtypu_8xqlz1irdo.png"></div><br>  Los pares de iteradores son ubicuos en toda la biblioteca de C ++.  En general, se acepta que la combinaci√≥n de un par de este tipo en una sola entidad, generalmente denominada Rango, proporciona un c√≥digo m√°s conciso y legible.  Sin embargo, definir la sem√°ntica precisa de dicho concepto de Range resulta sorprendentemente complicado.  Las consideraciones te√≥ricas entran en conflicto con las pr√°cticas.  Algunos objetivos de dise√±o son totalmente incompatibles entre s√≠. <br><br><h3>  Jonathan Boccara.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">105 algoritmos STL en menos de una hora</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/lf/ga/jvlfga-cdxxb3furo797y5ezpfy.png"></div><br>  Todos somos conscientes de que debemos conocer los algoritmos STL.  Incluirlos en nuestros dise√±os nos permite hacer que nuestro c√≥digo sea m√°s expresivo y m√°s robusto.  Y a veces, de manera espectacular. <br><br>  ¬øPero conoces tus algoritmos STL? <br><br>  En esta charla, el autor presenta 105 algoritmos que el STL tiene actualmente, incluidos los agregados en C ++ 11 y C ++ 17.  Pero m√°s que una simple lista, el objetivo de esta charla es presentar los diferentes grupos de algoritmos, los patrones que forman en el STL y c√≥mo se relacionan los algoritmos. <br><br>  Este tipo de panorama general es la mejor manera de recordarlos a todos, y constituye una caja de herramientas repleta de maneras de hacer que nuestro c√≥digo sea m√°s expresivo y m√°s robusto. <br><br><h3>  Viktor Kirilov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilaci√≥n interactiva de C ++ (REPL): The Lean Way</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/bd/4w/zzbd4w9yrkytmf3aqgamwc6iafw.png"></div><br>  ¬øAlguna vez quisiste modificar alg√∫n valor o ejecutar alguna declaraci√≥n mientras tu programa C ++ se est√° ejecutando solo para probar algo, no es trivial o posible con un depurador?  Los lenguajes de script tienen un REPL (read-eval-print-loop).  Lo m√°s parecido a C ++ es la adherencia (desarrollada por investigadores del CERN) pero est√° construida sobre LLVM y es muy engorrosa de configurar.  RCRL (Read-Compile-Run-Loop) es un proyecto de demostraci√≥n que muestra un enfoque innovador para hacer la compilaci√≥n en tiempo de ejecuci√≥n de C ++ en una plataforma y compilador de manera agn√≥stica que se puede incrustar f√°cilmente.  En esta presentaci√≥n, se muestra c√≥mo usarlo, c√≥mo funciona y c√≥mo se puede modificar e integrar en cualquier aplicaci√≥n y flujo de trabajo. <br><br><h3>  Victor Ciura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Suficiente string_view para ahorcarnos</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/gz/sl/bmgzslbc51pb7tc4f-jeaoywee4.png"></div><br>  ¬øNo ser√≠a bueno si tuvi√©ramos un tipo C ++ est√°ndar para representar cadenas?  Oh, espera ... hacemos: std :: string.  ¬øNo ser√≠a bueno si pudi√©ramos usar ese tipo est√°ndar en toda nuestra aplicaci√≥n / proyecto?  Bueno ... no podemos!  A menos que estemos escribiendo una aplicaci√≥n de consola o un servicio.  Pero, si estamos escribiendo una aplicaci√≥n con GUI o interactuando con API modernas del sistema operativo, es probable que debamos tratar con al menos otro tipo de cadena de C ++ no est√°ndar.  Dependiendo de la plataforma y el proyecto, puede ser CString desde MFC o ATL, Platform :: String desde WinRT, QString desde Qt, wxString desde wxWidgets, etc.  Oh, no olvidemos a nuestro viejo amigo const char *, mejor a√∫n const wchar_t * para la familia C de API ... <br><br>  As√≠ que terminamos con dos tipos de cadenas en nuestra base de c√≥digo.  OK, eso es manejable: nos quedamos con std :: string para todo el c√≥digo independiente de la plataforma y convertimos de un lado a otro a XString cuando interactuamos con las API del sistema o el c√≥digo GUI.  Haremos algunas copias innecesarias al cruzar este puente y terminaremos con algunas funciones divertidas que hacen malabares con dos tipos de cadenas;  pero ese es el c√≥digo de pegamento, de todos modos ... ¬øverdad? <br><br>  Es un buen plan ... hasta que nuestro proyecto crezca y acumulemos muchas utilidades de cadena y algoritmos.  ¬øRestringimos esas ventajas algor√≠tmicas a std :: string?  ¬øRecurrimos al denominador com√∫n const char * y perdemos la seguridad de tipo / memoria de nuestro tipo C ++?  ¬øEs C ++ 17 std :: string_view la respuesta a todos nuestros problemas de cadena? <br><br>  El autor intenta explorar las opciones, junto con un estudio de caso en una aplicaci√≥n de Windows de 15 a√±os: Advanced Installer (www.advancedinstaller.com), un proyecto C ++ desarrollado activamente, modernizado a C ++ 17, gracias a clang-tidy y "Clang Power Tools" ( <a href="">www.clangpowertools.com)</a> ... <br><br><h3>  Andrei Alexandrescu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Espera lo esperado</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/76/5i/k4765i7g8pxr-u0qfvk433pbfnk.png"></div><br>  Escribir c√≥digo que sea resistente a los errores siempre ha sido un punto cr√≠tico en todos los idiomas.  Las excepciones son los medios pol√≠ticamente correctos para se√±alar errores en C ++, pero muchas aplicaciones a√∫n recurren a c√≥digos de error por razones relacionadas con la facilidad de comprensi√≥n, la facilidad para manejar errores localmente y la eficiencia del c√≥digo generado. <br><br>  Esta charla muestra c√≥mo una variedad de artefactos te√≥ricos y pr√°cticos se pueden combinar para abordar c√≥digos de error y excepciones en un paquete simple y saludable.  El tipo gen√©rico Expected se puede usar para modales locales (estilo de c√≥digo de error) y centralizados (estilo de excepci√≥n), bas√°ndose en las fortalezas de cada uno. <br><br><h3>  Borislav Stanimirov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DynaMix: una nueva versi√≥n del polimorfismo</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2r/ji/ej/2rjiej_ldue2ztihyhwrgy7lhaa.png"></div><br>  El software con una l√≥gica empresarial muy compleja, como juegos, sistemas CAD y sistemas empresariales, a menudo necesita componer y modificar objetos en tiempo de ejecuci√≥n, por ejemplo, para agregar o anular un m√©todo en un objeto existente.  El est√°ndar C ++ tiene tipos r√≠gidos que se definen en tiempo de compilaci√≥n y lo hacen dif√≠cil.  Por otro lado, los lenguajes con tipos din√°micos como lua, Python y JavaScript lo hacen muy f√°cil.  Por lo tanto, para mantener el c√≥digo legible y mantenible, y cumplir con los complejos requisitos de l√≥gica de negocios, muchos proyectos usan dichos lenguajes junto con C ++.  Algunos inconvenientes de este enfoque incluyen la complejidad adicional en una capa de enlace de lenguaje, la p√©rdida de rendimiento por usar un lenguaje interpretado y la duplicaci√≥n de c√≥digo inevitable para muchas funcionalidades de utilidad peque√±as. <br><br>  DynaMix es una biblioteca que intenta eliminar, o al menos reducir en gran medida, la necesidad de un lenguaje de script separado al permitir a los usuarios componer y modificar objetos polim√≥rficos en tiempo de ejecuci√≥n en C ++.  Esta charla desarrolla este problema e introduce la biblioteca y sus caracter√≠sticas clave a usuarios o personas potenciales que podr√≠an beneficiarse del enfoque con un ejemplo anotado y una peque√±a demostraci√≥n. <br><br><h3>  Mikhail Matrosov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vers√°til C ++ aplicado</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/ox/ha/aooxhajausoz9zfpywpbrsz8wsa.png"></div><br>  En C ++, puede resolver una sola tarea de varias maneras.  El autor elige una tarea real de la producci√≥n e investiga c√≥mo se puede resolver con una serie de herramientas que proporciona C ++: contenedores STL, boost.range, rangos C ++ 20, rutinas.  Tambi√©n compara las restricciones API y el rendimiento de diferentes soluciones, y c√≥mo se pueden convertir f√°cilmente de una a otra si el c√≥digo est√° bien estructurado.  Durante el proceso, el autor tambi√©n explora aplicaciones de algunas caracter√≠sticas √∫tiles de C ++ 17 como constexpr if, sentencias de selecci√≥n con inicializador, std :: not_fn, etc.  Se presta especial atenci√≥n al tema: algoritmos est√°ndar. <br><br><h3>  Alexander Granin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enfoque funcional de la memoria transaccional de software</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/ty/uh/d-tyuhxlhdvvelofkinuwnmpyl4.png"></div><br>  La programaci√≥n paralela es un tema muy polifac√©tico y profundo.  A lo largo de las d√©cadas de investigaci√≥n, se han desarrollado una gran cantidad de enfoques, pr√°cticas y herramientas, pero dif√≠cilmente podemos suponer que el lenguaje C ++ se mantuvo al d√≠a con estas tendencias.  Comenzando con el est√°ndar C ++ 11, se introdujeron conceptos como std :: thread, std :: atomic, std :: future, std :: mutex, y en el futuro se espera que se agreguen rutinas, un modelo de c√°lculos asincr√≥nicos.  Bueno, todas estas son cosas interesantes para estudiar, pero el informe se centrar√° en una idea completamente diferente. <br><br>  La memoria transaccional de software (STM), el concepto de un modelo de datos transaccionalmente mutable, existe desde hace mucho tiempo y tiene varias implementaciones para todos los idiomas.  Con STM, expresa su modelo de datos y comienza a cambiarlo a trav√©s de m√∫ltiples subprocesos, de manera competitiva, sin tener que preocuparse por la sincronizaci√≥n de subprocesos, el estado v√°lido de los datos o los bloqueos.  STM har√° todo por ti.  Esto suena muy bien, pero no todas las bibliotecas STM son igualmente √∫tiles.  Los STM imperativos tradicionales son muy complejos, propensos a errores multiproceso no triviales y dif√≠ciles de usar.  Por otro lado, en el mundo de la programaci√≥n funcional, el concepto de STM combinatorio ha existido durante mucho tiempo, transacciones en las que son ladrillos componibles, a partir de los cuales se construyen transacciones de un nivel superior.  El enfoque combinatorio de STM le permite expresar un modelo de datos competitivo de manera m√°s flexible, clara y confiable.  ¬°La programaci√≥n paralela tambi√©n puede ser agradable! <br><br>  En el informe, el autor hablar√° sobre las caracter√≠sticas del STM combinatorio, c√≥mo usarlo y c√≥mo se puede implementar en C ++ 17. <br><br><h3>  Vadim Vinnik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesamiento de colecciones.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esencia √∫nica, manifestaciones m√∫ltiples.</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/4-/09/xh4-09mvu7jukasuqttn0-ipifu.png"></div><br>  A lo largo de toda la historia de la programaci√≥n, el procesamiento secuencial por elementos de varios tipos de colecciones ha sido y sigue siendo una de las tareas pr√°cticas m√°s comunes.  La representaci√≥n interna de las colecciones, as√≠ como el algoritmo utilizado para recuperar elementos posteriores, pueden variar en un rango muy amplio: matriz, lista vinculada, √°rbol, tabla hash, archivo y otros.  Sin embargo, detr√°s de la variedad de expresiones idiom√°ticas, funciones de biblioteca est√°ndar, soluciones ad-hoc, uno puede revelar la esencia que permanece invariable para toda esa clase de tareas.  Esta charla tiene como objetivo mostrar una transici√≥n paso a paso de algoritmos basados ‚Äã‚Äãen la descripci√≥n expl√≠cita de acciones sobre elementos individuales hacia herramientas de procesamiento declarativo de alto nivel que tratan a una colecci√≥n como una entidad y revelan adecuadamente la l√≥gica del dominio. <br><br><h3>  Dmitry Banshchikov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bibliotecas compartidas sin dependencias externas.</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/75/rt/xn/75rtxnsxinft9v9g2bs2rtyc2sy.png"></div><br>  El autor contar√° sobre su experiencia en el desarrollo de un motor antivirus en C ++ en forma de una biblioteca compartida.  Una caracter√≠stica √∫nica es la ausencia de dependencias externas (tiempo de ejecuci√≥n C ++ o C).  Todo este grupo se basa en el uso de una cadena de herramientas personalizada en GCC para un objetivo especial, que libc newlib va ‚Äã‚Äãa usar para el mismo objetivo, adem√°s del cual se construye libstdc ++.  En consecuencia, la biblioteca compartida se ensambla a trav√©s de una cadena de herramientas personalizada con libgcc_s, libc, libcstdc ++ (cambios solo en el ensamblaje).  Toda interacci√≥n con el tiempo de ejecuci√≥n es a trav√©s de la biblioteca compartida ABI.  Por lo tanto, la biblioteca conserva la capacidad de usar C ++ moderno sin restricciones (RTTI, excepciones, iostream, etc.), que va a libstdc ++ libc (newlib) |  l ibgcc-ABI.  Se prob√≥ un enfoque similar en las cadenas de herramientas GCC / newlib / libstdc ++ para Linux y clang / newlib / libc ++ para MacOS.  El informe puede ser de inter√©s para aquellos que desean usar C ++ en bibliotecas compartidas, pero no pueden permit√≠rselo debido a dependencias externas. <br><br><h3>  Ilya Shishkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo ense√±ar el lenguaje C ++: la experiencia de crear cursos en Coursera</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/zk/e6/sjzke6dn32bnehol5pyaeg9bmpe.png"></div><br>  Durante el √∫ltimo a√±o y medio, el autor ha liderado la creaci√≥n de la especializaci√≥n Coursera en C ++ moderno.  La especializaci√≥n consistir√° en cinco cursos, dos de los cuales ya est√°n en ejecuci√≥n, y otro est√° casi listo. <br><br>  El informe dir√°: <br><br><ul><li>  qu√© problemas se pueden encontrar al trabajar en cursos (por ejemplo, despu√©s de 3 meses de trabajo, los desarrolladores tiraron todos los materiales y comenzaron de nuevo) </li><li>  c√≥mo se forma el plan de estudios y por qu√© exactamente (por ejemplo, por qu√© la palabra "puntero" no son√≥ en los primeros dos cursos ni siquiera una vez) </li></ul><br>  Adem√°s, durante el trabajo de especializaci√≥n, se ha desarrollado un conjunto de principios que son aplicables en el trabajo diario: <br><br><ul><li>  en el proceso de integrar a un nuevo empleado en el proyecto </li><li>  durante la revisi√≥n de c√≥digo </li><li>  al contratar </li></ul><br>  Por lo tanto, el autor no solo quiere decir c√≥mo hacen la especializaci√≥n, sino que tambi√©n intentar√° transferir la experiencia adquirida a las tareas cotidianas. <br><br><h3>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crash Android NDK informa</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/yx/zc/h9yxzc_vcjlymv-gzh28xsaock4.png"></div><br>  No es ning√∫n secreto que el desarrollo en C / C ++ tiene requisitos mucho m√°s altos para la calidad del c√≥digo que el desarrollo en Java.  La probabilidad de cometer un error fatal es mucho mayor.  Al mismo tiempo, recopilar informaci√≥n sobre tales errores es una tarea no trivial incluso para programadores experimentados. <br><br>  En la primera parte del informe, revisaremos brevemente los desarrollos existentes: c√≥mo funciona el depurador de Android incorporado, qu√© soluciones ya existen.  La segunda parte est√° dedicada a la historia de c√≥mo funciona "bajo el cap√≥": c√≥mo obtener el estado del procesador en el momento del error, c√≥mo desenrollar la pila de llamadas, c√≥mo encontrar los n√∫meros de l√≠nea en el c√≥digo fuente.  Se proporcionar√° una descripci√≥n general de las bibliotecas de promoci√≥n de pila, como libcorkscrew, libunwind, libunwindstack. <br><br>  El informe ser√° de inter√©s tanto para los desarrolladores de Android, cuyas aplicaciones usan NDK, como para todos los dem√°s para ampliar sus horizontes. <br><br><h3>  Fedor Corto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La memoria es la abstracci√≥n perfecta.</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/yh/ns/tcyhnsqf9zd7owu6oylohlcgkqe.png"></div><br>  int * ptr = nuevo int; <br>  * ptr = 42; <br>  eliminar ptr; <br><br>  ¬øQu√© sucede realmente cuando se ejecutan estas 3 l√≠neas de c√≥digo?  Examinaremos el asignador de memoria, el sistema operativo y el hardware moderno para dar una respuesta exhaustiva a esta pregunta. <br><br><h3>  Alexey Salmin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consejos y trucos para la gesti√≥n de la memoria</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/re/ju/yirejuytypvwzo-ldwc-jmd4ylg.png"></div><br>  En 2017, la cuesti√≥n de elegir un asignador en C ++ no pierde relevancia.  Agregaron una nueva forma al est√°ndar para elegir un asignador local para contenedores (std :: pmr), tcmalloc global y jemalloc contin√∫an evolucionando, as√≠ como las interfaces del n√∫cleo en las que conf√≠an.  Este informe est√° dedicado al "piso inferior" de este dise√±o: las caracter√≠sticas de mmap y madvise en el kernel de Linux y el impacto de estas caracter√≠sticas en el rendimiento de los asignadores. <br><br><h3>  Herb Sutter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuevo en C ++ 20: el operador de nave espacial</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ex/dw/jhexdwnxovbsvpbtftm3jmrofr0.png"></div><br>  La nueva nave espacial fue adoptada recientemente como una funci√≥n de lenguaje para C ++ 20.  En esta charla, el dise√±ador y autor de la propuesta de la nave espacial ofrece una visi√≥n general de la caracter√≠stica, discute su motivaci√≥n y dise√±o, y muestra ejemplos de c√≥mo usarla.  √âl pone un √©nfasis particular en c√≥mo la funci√≥n hace que el c√≥digo C ++ sea m√°s limpio para escribir y leer, m√°s r√°pido al evitar el trabajo redundante y m√°s robusto al evitar varias dificultades importantes pero sutiles en el c√≥digo m√°s fr√°gil que anteriormente ten√≠amos que escribir a mano sin esta funci√≥n. <br><br><h3>  Anastasia Kazakova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Depuraci√≥n de c√≥digo C ++ sin ejecutar y compilar</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/na/ve/atnaverrgqdy-zv-xexxy6oan_g.png"></div><br>  Cuando observa las plantillas, la reflexi√≥n, la generaci√≥n de c√≥digo en la etapa de compilaci√≥n, las metaclases, tiene la sensaci√≥n de que C ++ se ha propuesto la tarea de "ocultar" el c√≥digo final del desarrollador tanto como sea posible.  Un uso no trivial del preprocesador (y numerosas ramas) puede hacer que la secuencia del programa sea muy obvia.  Por supuesto, estos enfoques salvan a los desarrolladores de copiar y pegar sin fin y la repetici√≥n de partes similares de la base de c√≥digo, pero requieren un soporte m√°s avanzado en herramientas de desarrollo. <br><br>  ¬øEs posible depurar c√≥digo sin reiniciarlo continuamente, sin un depurador e incluso sin una simple compilaci√≥n de toda la base de c√≥digo?  ¬øEs posible encontrar errores en el c√≥digo que no se pueden ensamblar o ejecutar en la m√°quina local?  Hay!  Los entornos de desarrollo integrado (IDE) tienen un amplio conocimiento y comprensi√≥n del c√≥digo personalizado, y son ellos quienes pueden proporcionar las herramientas adecuadas. <br><br>  Este informe mostrar√° c√≥mo uno podr√≠a "depurar" las sustituciones de macros anidadas por typedef, comprender los tipos de variables (que en C ++ moderno a menudo est√°n "ocultas"), depurar diferentes ramas de la sobrecarga del preprocesador u operador, y mucho m√°s con la ayuda de un sistema verdaderamente inteligente IDE  Algunas de las funciones ya est√°n disponibles en CLion y ReSharper C ++, y algunas son solo ideas interesantes para el futuro, que ser√≠a interesante discutir con la audiencia. <br><br><h3>  Eugene Lukyanets.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Construir en Docker usando Conan</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kt/es/9y/ktes9yg6zny3qia9p2qd6mksxqm.png"></div><br>  El ensamblaje de un proyecto C ++ se puede mover dentro del contenedor acoplable, mientras que en lugar de instalar las bibliotecas y dependencias necesarias en el sistema host, se pueden instalar directamente en la imagen acoplable (por ejemplo, Cuda) o instalar usando el administrador C ++ de la biblioteca Conan (por ejemplo, Boost).  Esto da como resultado un entorno controlado aislado (y cada vez el mismo) para el ensamblaje, en el que puede conectar el cach√© de Conan, por lo que diferentes proyectos que usan las mismas bibliotecas usar√°n los mismos ensamblajes.  Adem√°s, la compilaci√≥n ya no depende de la distribuci√≥n de Linux donde se est√° construyendo el proyecto, lo principal es que puede ejecutar Docker en esta distribuci√≥n. <br><br><h3>  Denis Panin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Metaprogramaci√≥n pr√°ctica: escribir una tabla hash heterog√©nea</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/zf/8d/ilzf8daway7fam09ukocar1bdpw.png"></div><br>  En el curso del informe, escribiremos una peque√±a biblioteca de trabajo con std :: tuple.  Usando esta biblioteca, compilamos el tiempo de compilaci√≥n en una tabla hash heterog√©nea.  Adem√°s, sobre esta base, escribiremos un peque√±o marco RPC, utilizando el hecho de que no tenemos borrado de tipo. <br><br>  Habr√° muchos c√°lculos de constexpr, plantillas y nuevas caracter√≠sticas en C ++ 17 (espec√≠ficamente, si constexpr). <br><br><h3>  Dmitry Sokolov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generaci√≥n de c√≥digo como reflejo para los pobres</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/cy/ey/m6cyeyyxuncuuz_jzzlzzcwj8q8.png"></div><br>  A menudo se necesita reflexi√≥n para generalizar los algoritmos de serializaci√≥n.  Implementaci√≥n de varios protocolos, trabajo con bases de datos.  Para resolver estos problemas, escribimos un compilador IDL casero para generar estructuras C ++ y una biblioteca para interactuar con el resultado.  Protobuf con pedales y si vali√≥ la pena. <br><br><h3>  Daveed Vandevoorde.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Metaprograma reflexivo en C ++</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/ho/ie/5choiecmddpmcbekwyekclxdmlq.png"></div><br>  Hace alg√∫n tiempo, el comit√© de estandarizaci√≥n de C ++ cre√≥ un subgrupo "SG-7" para explorar c√≥mo agregar capacidades de reflexi√≥n al lenguaje.  M√°s recientemente, ese grupo ha agregado "metaprogramaci√≥n" a su plato y ha tomado algunas decisiones importantes con respecto a la forma de la soluci√≥n final.  En esta charla, el autor analiza el pasado que nos trajo aqu√≠ y examina un posible camino para el soporte de primera clase de C ++ de la "metaprogramaci√≥n reflexiva". <br><br><h3>  Dietmar K√ºhl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba basada en concepto</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/sa/3s/stsa3scg4ux8lm4x7avft5qzabg.png"></div><br>  Con los conceptos que se agregan a la pr√≥xima revisi√≥n de C ++, se espera que se definan nuevos conceptos.  Cada concepto define un conjunto de operaciones utilizadas por el c√≥digo gen√©rico.  Uno de estos usos podr√≠a ser una prueba gen√©rica que verifique que todas las partes de un concepto est√©n definidas y que verifique las interacciones gen√©ricas entre las operaciones de un concepto.  Idealmente, tal prueba incluso funciona con clases que solo modelan parcialmente un concepto para guiar la implementaci√≥n de las clases. <br><br>  Esta presentaci√≥n no utiliza las extensiones de concepto reales, pero muestra c√≥mo se pueden crear pruebas gen√©ricas utilizando las caracter√≠sticas de C ++ 17.  Para las pruebas gen√©ricas, el idioma de detecci√≥n y constexpr se usan para determinar la disponibilidad de las operaciones requeridas y tratar con gracia la ausencia de operaciones.  Las pruebas gen√©ricas deber√≠an poder cubrir los conceptos b√°sicos de las clases que modelan un concepto.  Obviamente, el comportamiento espec√≠fico para las clases a√∫n requerir√° las pruebas correspondientes. <br><br><h3>  Simon Brand  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paralelismo moderno de C ++ de CPU a GPU</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/qz/st/qqqzstnuzvnt3ev15p-9hngj3iy.png"></div><br>  La programaci√≥n paralela se puede utilizar para aprovechar las arquitecturas heterog√©neas y de m√∫ltiples n√∫cleos y puede aumentar significativamente el rendimiento del software.  C ++ moderno ha recorrido un largo camino para hacer que la programaci√≥n paralela sea m√°s f√°cil y m√°s accesible;  proporcionando abstracciones de alto y bajo nivel.  C ++ 17 lleva esto m√°s lejos al proporcionar algoritmos paralelos de alto nivel, y se espera mucho m√°s en C ++ 20.  Esta charla ofrece una visi√≥n general de las utilidades de paralelismo actuales disponibles, y mira hacia el futuro de c√≥mo las GPU y los sistemas heterog√©neos pueden ser soportados a trav√©s de nuevas caracter√≠sticas de biblioteca est√°ndar y otros est√°ndares como SYCL. <br><br><h3>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectivo C ++ (Maers no tiene nada que ver con eso :)</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/lp/mu/rblpmu6fzwwn7hnt3cim-pipjf0.png"></div><br>  El lenguaje C ++ y la infraestructura que lo rodea contin√∫a evolucionando, lo que hace que este lenguaje sea una de las herramientas m√°s efectivas en la actualidad.  Me gustar√≠a destacar tres factores que hacen que el lenguaje C ++ ahora sea tan atractivo. <br><br><ul><li>  Primero: innovaciones en el lenguaje est√°ndar, lo que le permite escribir c√≥digo eficiente. </li><li>  Segundo: la madurez de las herramientas de desarrollo y un aumento en la velocidad de ensamblaje de proyectos. </li><li>  Tercero: herramientas de soporte maduras que le permiten controlar la calidad del c√≥digo y otros aspectos del ciclo de vida del proyecto. </li></ul><br>  ¬°Este informe es una oda al lenguaje de programaci√≥n C ++! <br><br><h3>  Ivan Puzyrevsky.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asincron√≠a en programaci√≥n</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/vx/iw/3gvxiw02427rxts0p3nza4kburu.png"></div><br>  En el campo del desarrollo de aplicaciones multiproceso o distribuidas altamente cargadas, uno puede escuchar cada vez m√°s conversaciones sobre el c√≥digo asincr√≥nico, incluida la especulaci√≥n sobre la necesidad (falta de necesidad) de tener en cuenta la asincron√≠a en el c√≥digo, sobre la comprensibilidad (incomprensibilidad) del c√≥digo asincr√≥nico y su eficiencia (ineficiencia).  En este informe, trataremos de profundizar en el √°rea tem√°tica: analizaremos lo que es asincron√≠a;  cuando surge;  c√≥mo afecta el c√≥digo que escribimos y el lenguaje de programaci√≥n que usamos.  Trataremos de averiguar qu√© futuros y promesas tienen que ver con eso, hablemos un poco sobre las corutinas y los actores.  Afectaremos a JavaScript y a los sistemas operativos.  El prop√≥sito del informe es hacer que los compromisos que surgen con uno u otro enfoque para el desarrollo de software multiproceso o distribuido sean m√°s expl√≠citos. <br><br><h3>  Pavel Bulatov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cambiando a WebAssembly: ¬øvale la pena el juego?</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/s6/ga/vts6gamnunde4u6qzk6p_4zqc6c.png"></div><br>  El informe discutir√° el estado actual de WebAssembly en relaci√≥n con productos reales.  Hablaremos sobre nuestra experiencia de portar la aplicaci√≥n, sobre qu√© problemas surgieron y c√≥mo los resolvimos. <br><br>  Los temas cubiertos incluyen: <br><br><ul><li>  Soporte para el est√°ndar en diferentes plataformas y navegadores. </li><li>  Rendimiento y tama√±o de compilaci√≥n versus asm.js. </li><li>  Interacciones con el navegador. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea bloqueos del usuario. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracter√≠sticas de VM. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Kozhevnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMata los escollos y d√≥nde viven</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/_l/qr/zt_lqrmu-qimm8_m2z7g_zd2xsg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sistema de compilaci√≥n CMake se est√° convirtiendo gradualmente en el est√°ndar de facto para la programaci√≥n C ++ multiplataforma. </font><font style="vertical-align: inherit;">Sin embargo, a menudo se le critica de manera justa, incluso por el lenguaje de secuencias de comandos inconveniente, la documentaci√≥n obsoleta y el hecho de que las mismas tareas se pueden realizar de diferentes maneras, y puede ser bastante dif√≠cil entender cu√°l es m√°s correcto en una situaci√≥n particular . </font><font style="vertical-align: inherit;">El autor dir√°:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antipatrones populares frecuentes y por qu√© son malos, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a qu√© niveles de abstracci√≥n funciona CMake, y cu√°ndo se ‚Äúfiltran‚Äù, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øQu√© es "CMake moderno" y cu√°les son sus ventajas? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥mo localizar y depurar problemas en scripts CMake (incluidos algunos bastante ex√≥ticos). </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Shambir. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando el procedimiento C ++ es bueno</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ib/vy/kxibvyhzvf5taodgpswkywptk9y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura limpia del proyecto, las abstracciones simples en cada capa es el sue√±o de cualquier equipo. </font><font style="vertical-align: inherit;">Para realizar este sue√±o, se han inventado muchas t√©cnicas orientadas a objetos. </font><font style="vertical-align: inherit;">Llevado por OOP, los desarrolladores olvidan monitorear la limpieza del c√≥digo en la uni√≥n de C y C ++. </font><font style="vertical-align: inherit;">Es aqu√≠ donde el estilo de procedimiento ayudar√° a restaurar el orden, crear abstracciones convenientes y seguras que se ajusten f√°cilmente al c√≥digo orientado a objetos del proyecto. </font><font style="vertical-align: inherit;">Descubriremos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPor qu√© necesita aislar la API de C (como winapi, POSIX, SQLite, OpenGL, OpenSSL) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øPor qu√© OOP funciona mal en este negocio? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥mo escribir una capa de abstracci√≥n en la parte superior de la API de estilo C </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥mo lidiar con las devoluciones de llamada, el manejo de errores y la administraci√≥n de recursos para hacer que el c√≥digo tradicionalmente complejo y confuso sea comprensible incluso para un junior </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Zuev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API sem√°ntica para programas C ++</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/wb/d4/-ewbd4monfzqy8msagott8iaxzu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sus intereses profesionales son la sem√°ntica de los lenguajes de programaci√≥n, el dise√±o y la implementaci√≥n de compiladores de PL y otras herramientas orientadas al lenguaje. </font><font style="vertical-align: inherit;">Entre los logros m√°s significativos se encuentran la participaci√≥n en proyectos como la creaci√≥n de un compilador del est√°ndar completo del lenguaje C ++ (Interstron, Mosc√∫, 2000), la implementaci√≥n del compilador del lenguaje Zonnon para .NET (ETH Zurich, 2005) y la implementaci√≥n del compilador prototipo Swift para la plataforma Tizen ( Samsung Research Institute, Mosc√∫, 2015).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ivan ƒåukiƒá. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020: una odisea del vac√≠o</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/_4/qw/lz_4qwm76c6mz0aadcqwqcd8av8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ siempre ha tenido un potente sub-lenguaje de metaprogramaci√≥n que permiti√≥ a los desarrolladores de bibliotecas realizar haza√±as m√°gicas como la introspecci√≥n est√°tica para lograr la ejecuci√≥n polim√≥rfica sin herencia. </font><font style="vertical-align: inherit;">El problema era que la sintaxis era inc√≥moda e innecesariamente detallada, lo que hac√≠a que aprender metaprogramaci√≥n fuera una tarea desalentadora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con las recientes mejoras al est√°ndar, y con las caracter√≠sticas planificadas para C ++ 20, la metaprogramaci√≥n se ha vuelto mucho m√°s f√°cil, y los metaprogramas se han vuelto m√°s f√°ciles de entender y razonar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta charla, el autor presenta algunas t√©cnicas modernas de metaprogramaci√≥n, con un enfoque principal en la metafunci√≥n m√°gica void_t.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Okhotnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actores de C ++: ¬øvali√≥ la pena?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/tn/tw/9ttntwqtinuogjfwkd0jjbqn8ko.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El autor del informe ha sido responsable del desarrollo del marco SObjectizer de c√≥digo abierto durante 16 a√±os. </font><font style="vertical-align: inherit;">Este es uno de los pocos marcos de actores multiplataforma en vivo y en desarrollo para C ++. </font><font style="vertical-align: inherit;">El desarrollo de SObjectizer comenz√≥ en el a√±o 2002, cuando C ++ estaba entre los lenguajes de programaci√≥n m√°s populares y comunes. </font><font style="vertical-align: inherit;">En el pasado, C ++ ha cambiado mucho, y la actitud hacia C ++ ha cambiado a√∫n m√°s. </font><font style="vertical-align: inherit;">El informe discutir√° c√≥mo estos cambios afectaron el desarrollo de una herramienta con una historia de 16 a√±os y cu√°n simple y conveniente fue hacer una herramienta para el lenguaje C ++. </font><font style="vertical-align: inherit;">Y si era necesario hacer una herramienta para C ++ en general.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainer Grimm. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mejores pr√°cticas para la concurrencia en C ++ moderno</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/12/j2/yk12j2luup7tzp2at0vt9epwr6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la estandarizaci√≥n de C ++ 11, obtuvimos en C ++ una biblioteca de subprocesos m√∫ltiples y un modelo de memoria. </font><font style="vertical-align: inherit;">La biblioteca tiene los bloques de construcci√≥n b√°sicos, como at√≥micos, subprocesos, tareas, bloqueos y variables de condici√≥n. </font><font style="vertical-align: inherit;">El modelo de memoria proporciona garant√≠as para el uso seguro de subprocesos de estos bloques de construcci√≥n b√°sicos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siete a√±os despu√©s, tenemos muchas mejores pr√°cticas para aplicar el subprocesamiento m√∫ltiple y el modelo de memoria de manera segura. </font><font style="vertical-align: inherit;">La charla del autor es precisamente sobre estas mejores pr√°cticas para reglas generales de concurrencia, reglas especiales para la biblioteca de subprocesos m√∫ltiples y reglas especiales para el modelo de memoria. </font><font style="vertical-align: inherit;">El enfoque de estas mejores pr√°cticas va mucho m√°s all√° de C ++.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Malov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experiencia en el uso de C ++ moderno en el desarrollo de aplicaciones de escritorio</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uu/te/59/uute59evuanipkaccp6qabg1ari.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La charla tratar√° sobre las herramientas del lenguaje C ++ y las bibliotecas Boost y STL, as√≠ como sobre enfoques arquitect√≥nicos para crear aplicaciones GUI que usamos para desarrollar una herramienta para crear lecciones en video. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Practique usando el patr√≥n Modelo-Vista-Presentador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesti√≥n del ciclo de vida del documento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Almacenamiento de archivos de punteros inteligentes </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lisis est√°tico: buscando errores ... y vulnerabilidades?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/it/1h/z7it1hjlb46zf_4xp1pvsqlyqbq.png"></div><br>  Las noticias sobre la pr√≥xima vulnerabilidad encontrada aparecen regularmente aqu√≠ y all√°.  Las p√©rdidas colaterales de $, como regla, son enormes.  Por lo tanto, en lugar de corregir vulnerabilidades, no se debe permitir que aparezcan. <br><br>  Una forma de lidiar con los errores en el c√≥digo es usar an√°lisis est√°tico.  Pero, ¬øqu√© tan adecuado es buscar vulnerabilidades?  ¬øY hay realmente una gran diferencia entre errores simples y vulnerabilidades de c√≥digo? <br><br>  Discutiremos estos problemas durante el informe y, al mismo tiempo, hablaremos sobre c√≥mo usar el an√°lisis est√°tico para aprovecharlo al m√°ximo. <br><br>  <b>PS</b> <br><br>  Por mi cuenta, quiero llamar su atenci√≥n sobre la mini intriga en torno a <i>std :: string</i> relacionada con los informes de mi colega Andrei Karpov.  Entonces, en orden: <br><br><ol><li>  Un fragmento del informe de Andrei (C ++ Rusia 2016) "Historias privadas de desarrolladores de analizadores de c√≥digo" de 30:05 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> . </li><li>  Anton Polukhin (C ++ Rusia 2017), trolling f√°cil de personas como nosotros, en el informe "C√≥mo no hacerlo: construcci√≥n de bicicletas C ++ para profesionales" a partir de las 2:00 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> . </li><li>  La historia de Andrey en la conferencia C ++ Rusia 2018 de que no somos dinosaurios y estamos aprendiendo algo nuevo: "C ++ efectivo" de 12:21 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> . </li></ol><br>  Eso es todo!  Disfruta tus informes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418645/">https://habr.com/ru/post/es418645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418635/index.html">Creaci√≥n de una m√°quina arcade emulador. Parte 1</a></li>
<li><a href="../es418637/index.html">Kubernetes a las masas: Slurm comienza el 3 de agosto</a></li>
<li><a href="../es418639/index.html">Akka Streams para simples mortales</a></li>
<li><a href="../es418641/index.html">Un error que impide que un dise√±ador crezca</a></li>
<li><a href="../es418643/index.html">Sentarse frente a pie: ¬øc√≥mo trabajar mejor?</a></li>
<li><a href="../es418647/index.html">TESS lanza b√∫squeda de exoplanetas</a></li>
<li><a href="../es418649/index.html">La generaci√≥n continua de versiones alternativas de TLS resolver√° el problema de la osificaci√≥n del antiguo protocolo.</a></li>
<li><a href="../es418651/index.html">Eventos digitales en Mosc√∫ del 30 de julio al 5 de agosto</a></li>
<li><a href="../es418653/index.html">¬øWebAssembly devuelve applets de Java y Flash?</a></li>
<li><a href="../es418655/index.html">Windows Mixed Reality: una gu√≠a para desarrolladores (parte 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>