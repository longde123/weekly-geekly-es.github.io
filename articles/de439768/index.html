<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🤷🏼 ✒️ Wie funktioniert ein Barcode? 👳 😦 🥩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo zusammen! 

 Jeder Mensch benutzt heutzutage Barcodes, meistens ohne es zu merken. Wenn wir die Lebensmittel im Geschäft kaufen, werden ihre Ken...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert ein Barcode?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439768/">  Hallo zusammen! <br><br>  Jeder Mensch benutzt heutzutage Barcodes, meistens ohne es zu merken.  Wenn wir die Lebensmittel im Geschäft kaufen, werden ihre Kennungen von Barcodes abgerufen.  Das Gleiche gilt auch für Waren in den Lagern, Postpaketen und so weiter.  Aber nicht so viele Leute wissen tatsächlich, wie es funktioniert. <br><br>  Was befindet sich im Barcode und was ist auf diesem Bild codiert? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Lass es uns herausfinden und lass uns auch unseren eigenen Bardecoder schreiben. <a name="habracut"></a><br><br><h2>  Einführung </h2><br>  Die Verwendung von Barcodes hat eine lange Geschichte.  Erste Versuche zur Automatisierung wurden in den 50er Jahren unternommen, das Patent für ein Code-Lesesystem wurde erteilt.  David Collins, der bei der Pennsylvania Railroad arbeitete, beschloss, den Sortiervorgang für Autos zu vereinfachen.  Die Idee lag auf der Hand: Die Fahrzeugkennungen mit verschiedenen Farbstreifen zu codieren und mit einer Fotozelle zu lesen.  1962 wurde ein solcher Code von der Association of American Railroads zum Standard.  (das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KarTrak-</a> System).  1968 wurde die Lampe durch einen Laser ersetzt, wodurch die Genauigkeit erhöht und die Lesegröße verringert werden konnte.  1973 wurde der Universal Product Code entwickelt und 1974 das erste Lebensmittelprodukt (ein Wrigley-Kaugummi - es war offensichtlich in den USA;) verkauft.  Im Jahr 1984 hat der dritte Teil aller Geschäfte Barcodes verwendet, in anderen Ländern wurde es später populär. <br><br>  Es gibt viele verschiedene Barcode-Typen für verschiedene Anwendungen. Beispielsweise kann die Zeichenfolge "12345678" auf diese Weise codiert werden (und es sind nicht alle): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Beginnen wir mit der Analyse.  Alle folgenden Informationen beziehen sich auf den Typ "Code-128" - nur weil das Prinzip leicht zu verstehen ist.  Wer andere Modi testen möchte, kann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Barcode-Generator verwenden</a> und andere Typen selbst testen. <br><br>  Auf den ersten Blick sieht ein Barcode wie eine zufällige Reihe von Zahlen aus, aber tatsächlich ist seine Struktur gut organisiert: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Leerer Platz, der zur Bestimmung der Code-Startposition erforderlich ist. <br>  2 - Startsymbol.  Es stehen drei Arten von Code-128 zur Verfügung (A, B und C genannt), und Startsymbole können 11010000100, 11010010000 bzw. 11010011100 sein.  Bei diesen Typen unterscheiden sich die Codierungstabellen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere Informationen finden Sie in der Beschreibung von Code_128</a> ). <br>  3 - Der Code selbst, der Benutzerdaten enthält. <br>  4 - Prüfsumme. <br>  5 - Stoppsymbol für Code-128 1100011101011. <br>  6 (1) - Leerraum. <br><br>  Schauen wir uns nun an, wie die Bits codieren.  Es ist wirklich einfach - wenn wir die dünnste Linienbreite auf "1" setzen, dann ist die Linie mit doppelter Breite "11", die Linie mit dreifacher Breite ist "111" und so weiter.  Der leere Raum wird nach dem gleichen Prinzip jeweils "0", "00" oder "000" sein.  Interessenten können die Startsequenz auf dem Bild oben vergleichen, um festzustellen, ob die Regel eingehalten wird. <br><br>  Jetzt können wir mit dem Codieren beginnen. <br><br><h2>  Abrufen der Bitfolge </h2><br>  Im Allgemeinen ist es der komplizierteste Teil, und es kann auf verschiedene Arten durchgeführt werden.  Ich bin mir nicht sicher, ob mein Ansatz optimal ist, aber für unsere Aufgabe ist es definitiv genug. <br><br>  Lassen Sie uns zunächst das Bild laden, seine Breite dehnen, eine horizontale Linie von der Mitte aus zuschneiden, es in eine s / w-Farbe konvertieren und als Array speichern. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Auf dem Barcode entspricht die schwarze Linie „1“, aber in RGB ist das Schwarz im Gegensatz zu 0, sodass das Array invertiert werden muss.  Wir werden auch den Durchschnittswert berechnen. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Führen Sie das Programm aus, um zu überprüfen, ob der Barcode korrekt geladen wurde: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Jetzt müssen wir eine Breite von einem 'Bit' bestimmen.  Dazu extrahieren wir die Sequenz und speichern die Positionen der durchschnittlichen Linienkreuzung. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir speichern nur die durchschnittlichen Linienkreuzungen, daher wird der Code "1101" als "101" gespeichert, aber es reicht aus, um die Pixelbreite zu erhalten. <br><br>  Lassen Sie uns nun die Dekodierung selbst vornehmen.  Wir müssen jede durchschnittliche Linienkreuzung finden und die Anzahl der Bits im letzten gefundenen Intervall ermitteln.  Die Zahlen stimmen nicht perfekt überein (der Code kann etwas gedehnt oder gebogen werden), daher müssen wir den Wert auf eine Ganzzahl runden. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Vielleicht gibt es einen besseren Weg, dies zu tun, Leser können in Kommentaren schreiben. <br><br>  Wenn alles perfekt gemacht wurde, erhalten wir eine Sequenz wie folgt: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Dekodierung </h2><br>  Im Allgemeinen ist es ziemlich einfach.  Symbole im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-128</a> werden mit 11-Bit-Code codiert, der unterschiedliche Codierungen haben kann (gemäß dieser Codierung - A, B oder C können es Buchstaben oder Ziffern von 00 bis 99 sein). <br><br>  In unserem Fall ist der Beginn der Sequenz 11010010000, was einem "Code B" entspricht.  Ich war zu faul, um alle Codes manuell einzugeben, also habe ich sie einfach von einer Wikipedia-Seite kopiert.  Das Parsen dieser Zeilen wurde auch in Python durchgeführt (Hinweis - machen Sie solche Dinge nicht in der Produktion). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Die letzten Teile sind einfach.  Lassen Sie uns zunächst die Sequenz in 11-Bit-Blöcke aufteilen: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Lassen Sie uns abschließend die Ausgabezeichenfolge generieren und anzeigen: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Ich werde hier nicht das dekodierte Ergebnis aus dem oberen Bild zeigen, es sei die Hausaufgabe für die Leser (die Verwendung der heruntergeladenen Apps für Smartphones wird als Betrug betrachtet :). <br><br>  Die CRC-Prüfung ist in diesem Code nicht implementiert. Wer dies möchte, kann dies selbst tun. <br><br>  Sicher ist dieser Algorithmus nicht perfekt, er wurde in einer halben Stunde erstellt.  Für professionelle Aufgaben gibt es gebrauchsfertige Bibliotheken, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyzbar</a> .  Zum Dekodieren des Bildes reichen 4 Codezeilen aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (Zuerst muss die Bibliothek mit dem Befehl "pip install pyzbar" installiert werden.) <br><br>  <b>Ergänzung</b> : Der Site-Benutzer <i>vinograd19</i> hat einen interessanten Kommentar zum Berechnungsverlauf der Barcode- <i>Prüfsumme</i> gesendet. <br><br>  <i>Die Berechnung der Schecknummer ist interessant, sie entstand evolutionär.</i> <i><br></i>  <i>Eine Prüfsumme wird offensichtlich benötigt, um eine falsche Dekodierung zu vermeiden.</i>  <i>Wenn der Barcode 1234 war und als 7234 dekodiert wurde, benötigen wir eine Methode, um das Ersetzen von 1 bis 7 abzulehnen. Die Validierung kann nicht perfekt sein, aber mindestens 90% der Codes sollten korrekt überprüft werden.</i> <i><br><br></i>  <i>1. Ansatz: Nehmen wir einfach die Summe, um 0 als Rest der Division zu haben.</i>  <i>Das erste Symbol enthält Daten, und die letzte Ziffer ist so, dass die Summe aller Zahlen durch 10 geteilt wird. Wenn der Betrag nach der Decodierung nicht durch 10 teilbar ist, ist die Decodierung falsch und muss wiederholt werden.</i>  <i>Beispielsweise ist der Code 1234 gültig - 1 + 2 + 3 + 4 = 10. Code 1216 - ist ebenfalls gültig, 1218 jedoch nicht.</i> <i><br><br></i>  <i>Dies hilft, Dekodierungsprobleme zu vermeiden.</i>  <i>Die Codes können aber auch manuell über die Hardwaretastatur eingegeben werden.</i>  <i>Auf diese Weise wurde ein weiterer schlechter Fall gefunden - wenn die Reihenfolge der zwei Ziffern geändert wird, ist die Prüfsumme immer noch korrekt, es ist definitiv schlecht.</i>  <i>Wenn beispielsweise der Barcode 1234 als 2134 eingegeben wurde, ist die Prüfsumme dieselbe.</i>  <i>Es wurde festgestellt, dass eine falsche Ziffernreihenfolge häufig vorkommt, wenn eine Person versucht, Ziffern schnell einzugeben.</i> <i><br><br></i>  <i>2. Ansatz.</i>  <i>Verbessern wir den Prüfsummenalgorithmus - lassen Sie uns die ungeraden Zahlen zweimal berechnen.</i>  <i>Wenn dann die Reihenfolge geändert wird, ist die Summe falsch.</i>  <i>Beispielsweise ist der Code 2364 gültig (2 + 3 * 2 + 6 + 4 * 2 = 20), der Code 3264 jedoch nicht (3 + 2 * 2 + 6 + 4 * 2 = 19).</i>  <i>Es ist besser, aber ein anderer Fall ist aufgetreten.</i>  <i>Es gibt einige Tastaturen mit 10 Tasten in zwei Zeilen, die erste Zeile ist 12345 und die zweite ist 67890. Wenn der Benutzer anstelle von "1" "2" eingibt, schlägt die Prüfsummenprüfung fehl.</i>  <i>Wenn der Benutzer jedoch "6" anstelle von "1" eingibt, kann die Prüfsumme manchmal korrekt sein.</i>  <i>Dies liegt daran, dass 6 = 1 + 5 ist und wenn die Ziffer eine ungerade Stelle hat, 2 * 6 = 2 * 1 + 2 * 5 - die Summe hat sich um 10 erhöht. Der gleiche Fehler tritt auf, wenn der Benutzer "7" eingibt "Anstelle von" 2 "," 8 "anstelle von" 3 "und so weiter.</i> <i><br><br></i>  <i>3. Ansatz.</i>  <i>Nehmen wir die Summe noch einmal, aber lassen Sie uns ungerade Zahlen erhalten ... 3 mal.</i>  <i>Zum Beispiel ist der Code 1234565 - gültig, weil 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 + 5 = 50.</i> <i><br><br></i>  <i>Diese Methode wurde mit einigen Änderungen zum Standard für EAN13-Code: Die Anzahl der Ziffern ist fest und gleich 13, wobei die 13. Ziffer - die Prüfsumme ist.</i>  <i>Zahlen an ungeraden Stellen werden dreimal gezählt, an geraden Stellen einmal.</i> <br><br>  Übrigens wird der EAN-13-Code am häufigsten in Handels- und Einkaufszentren verwendet, sodass die Leute ihn häufiger sehen als andere Codetypen.  Die Bitcodierung ist dieselbe wie in Code-128, die Datenstruktur finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel</a> . <br><br><h2>  Fazit </h2><br>  Wie wir sehen können, kann selbst eine so einfache Sache wie ein Barcode einige coole Sachen enthalten.  Übrigens ein weiterer kleiner Lifehack für Leser, die geduldig genug waren, um bis zu diesem Ort zu lesen - der Text unter dem Barcode ist vollständig identisch mit den Barcode-Daten.  Es wurde für die Bediener erstellt, die den Code manuell eingeben können, wenn er vom Scanner nicht gelesen werden kann.  So ist es einfach, den Barcode-Inhalt zu kennen - lesen Sie einfach den folgenden Text. <br><br>  Danke fürs Lesen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439768/">https://habr.com/ru/post/de439768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439758/index.html">Auf halbem Weg "Juno"</a></li>
<li><a href="../de439760/index.html">Ingenieure "verdrehten" das Licht in der Faser - eine neue Technologie beschleunigt die Datenübertragung um das Hundertfache</a></li>
<li><a href="../de439762/index.html">Über Hochschulbildung, Programmierer und Arbeiter</a></li>
<li><a href="../de439764/index.html">Unternehmensfrüchte</a></li>
<li><a href="../de439766/index.html">Erhöhen Sie es! Moderne Auflösung steigt</a></li>
<li><a href="../de439772/index.html">Unit-Tests in Swift schreiben, um asynchrone Aufgaben zu testen</a></li>
<li><a href="../de439774/index.html">Automatisieren Sie das Testen von Redux-Selektoren in der Anwendung</a></li>
<li><a href="../de439776/index.html">Frontend Weekly Digest (4. - 10. Februar 2019)</a></li>
<li><a href="../de439778/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 351 (4. - 10. Februar 2019)</a></li>
<li><a href="../de439780/index.html">PHP Digest Nr. 149 (28. Januar - 11. Februar 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>