<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® ü§∑üèº ‚úíÔ∏è Wie funktioniert ein Barcode? üë≥ üò¶ ü•©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo zusammen! 

 Jeder Mensch benutzt heutzutage Barcodes, meistens ohne es zu merken. Wenn wir die Lebensmittel im Gesch√§ft kaufen, werden ihre Ken...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie funktioniert ein Barcode?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439768/">  Hallo zusammen! <br><br>  Jeder Mensch benutzt heutzutage Barcodes, meistens ohne es zu merken.  Wenn wir die Lebensmittel im Gesch√§ft kaufen, werden ihre Kennungen von Barcodes abgerufen.  Das Gleiche gilt auch f√ºr Waren in den Lagern, Postpaketen und so weiter.  Aber nicht so viele Leute wissen tats√§chlich, wie es funktioniert. <br><br>  Was befindet sich im Barcode und was ist auf diesem Bild codiert? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Lass es uns herausfinden und lass uns auch unseren eigenen Bardecoder schreiben. <a name="habracut"></a><br><br><h2>  Einf√ºhrung </h2><br>  Die Verwendung von Barcodes hat eine lange Geschichte.  Erste Versuche zur Automatisierung wurden in den 50er Jahren unternommen, das Patent f√ºr ein Code-Lesesystem wurde erteilt.  David Collins, der bei der Pennsylvania Railroad arbeitete, beschloss, den Sortiervorgang f√ºr Autos zu vereinfachen.  Die Idee lag auf der Hand: Die Fahrzeugkennungen mit verschiedenen Farbstreifen zu codieren und mit einer Fotozelle zu lesen.  1962 wurde ein solcher Code von der Association of American Railroads zum Standard.  (das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KarTrak-</a> System).  1968 wurde die Lampe durch einen Laser ersetzt, wodurch die Genauigkeit erh√∂ht und die Lesegr√∂√üe verringert werden konnte.  1973 wurde der Universal Product Code entwickelt und 1974 das erste Lebensmittelprodukt (ein Wrigley-Kaugummi - es war offensichtlich in den USA;) verkauft.  Im Jahr 1984 hat der dritte Teil aller Gesch√§fte Barcodes verwendet, in anderen L√§ndern wurde es sp√§ter popul√§r. <br><br>  Es gibt viele verschiedene Barcode-Typen f√ºr verschiedene Anwendungen. Beispielsweise kann die Zeichenfolge "12345678" auf diese Weise codiert werden (und es sind nicht alle): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Beginnen wir mit der Analyse.  Alle folgenden Informationen beziehen sich auf den Typ "Code-128" - nur weil das Prinzip leicht zu verstehen ist.  Wer andere Modi testen m√∂chte, kann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Barcode-Generator verwenden</a> und andere Typen selbst testen. <br><br>  Auf den ersten Blick sieht ein Barcode wie eine zuf√§llige Reihe von Zahlen aus, aber tats√§chlich ist seine Struktur gut organisiert: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Leerer Platz, der zur Bestimmung der Code-Startposition erforderlich ist. <br>  2 - Startsymbol.  Es stehen drei Arten von Code-128 zur Verf√ºgung (A, B und C genannt), und Startsymbole k√∂nnen 11010000100, 11010010000 bzw. 11010011100 sein.  Bei diesen Typen unterscheiden sich die Codierungstabellen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere Informationen finden Sie in der Beschreibung von Code_128</a> ). <br>  3 - Der Code selbst, der Benutzerdaten enth√§lt. <br>  4 - Pr√ºfsumme. <br>  5 - Stoppsymbol f√ºr Code-128 1100011101011. <br>  6 (1) - Leerraum. <br><br>  Schauen wir uns nun an, wie die Bits codieren.  Es ist wirklich einfach - wenn wir die d√ºnnste Linienbreite auf "1" setzen, dann ist die Linie mit doppelter Breite "11", die Linie mit dreifacher Breite ist "111" und so weiter.  Der leere Raum wird nach dem gleichen Prinzip jeweils "0", "00" oder "000" sein.  Interessenten k√∂nnen die Startsequenz auf dem Bild oben vergleichen, um festzustellen, ob die Regel eingehalten wird. <br><br>  Jetzt k√∂nnen wir mit dem Codieren beginnen. <br><br><h2>  Abrufen der Bitfolge </h2><br>  Im Allgemeinen ist es der komplizierteste Teil, und es kann auf verschiedene Arten durchgef√ºhrt werden.  Ich bin mir nicht sicher, ob mein Ansatz optimal ist, aber f√ºr unsere Aufgabe ist es definitiv genug. <br><br>  Lassen Sie uns zun√§chst das Bild laden, seine Breite dehnen, eine horizontale Linie von der Mitte aus zuschneiden, es in eine s / w-Farbe konvertieren und als Array speichern. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Auf dem Barcode entspricht die schwarze Linie ‚Äû1‚Äú, aber in RGB ist das Schwarz im Gegensatz zu 0, sodass das Array invertiert werden muss.  Wir werden auch den Durchschnittswert berechnen. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  F√ºhren Sie das Programm aus, um zu √ºberpr√ºfen, ob der Barcode korrekt geladen wurde: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Jetzt m√ºssen wir eine Breite von einem 'Bit' bestimmen.  Dazu extrahieren wir die Sequenz und speichern die Positionen der durchschnittlichen Linienkreuzung. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir speichern nur die durchschnittlichen Linienkreuzungen, daher wird der Code "1101" als "101" gespeichert, aber es reicht aus, um die Pixelbreite zu erhalten. <br><br>  Lassen Sie uns nun die Dekodierung selbst vornehmen.  Wir m√ºssen jede durchschnittliche Linienkreuzung finden und die Anzahl der Bits im letzten gefundenen Intervall ermitteln.  Die Zahlen stimmen nicht perfekt √ºberein (der Code kann etwas gedehnt oder gebogen werden), daher m√ºssen wir den Wert auf eine Ganzzahl runden. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Vielleicht gibt es einen besseren Weg, dies zu tun, Leser k√∂nnen in Kommentaren schreiben. <br><br>  Wenn alles perfekt gemacht wurde, erhalten wir eine Sequenz wie folgt: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Dekodierung </h2><br>  Im Allgemeinen ist es ziemlich einfach.  Symbole im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-128</a> werden mit 11-Bit-Code codiert, der unterschiedliche Codierungen haben kann (gem√§√ü dieser Codierung - A, B oder C k√∂nnen es Buchstaben oder Ziffern von 00 bis 99 sein). <br><br>  In unserem Fall ist der Beginn der Sequenz 11010010000, was einem "Code B" entspricht.  Ich war zu faul, um alle Codes manuell einzugeben, also habe ich sie einfach von einer Wikipedia-Seite kopiert.  Das Parsen dieser Zeilen wurde auch in Python durchgef√ºhrt (Hinweis - machen Sie solche Dinge nicht in der Produktion). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Die letzten Teile sind einfach.  Lassen Sie uns zun√§chst die Sequenz in 11-Bit-Bl√∂cke aufteilen: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Lassen Sie uns abschlie√üend die Ausgabezeichenfolge generieren und anzeigen: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Ich werde hier nicht das dekodierte Ergebnis aus dem oberen Bild zeigen, es sei die Hausaufgabe f√ºr die Leser (die Verwendung der heruntergeladenen Apps f√ºr Smartphones wird als Betrug betrachtet :). <br><br>  Die CRC-Pr√ºfung ist in diesem Code nicht implementiert. Wer dies m√∂chte, kann dies selbst tun. <br><br>  Sicher ist dieser Algorithmus nicht perfekt, er wurde in einer halben Stunde erstellt.  F√ºr professionelle Aufgaben gibt es gebrauchsfertige Bibliotheken, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyzbar</a> .  Zum Dekodieren des Bildes reichen 4 Codezeilen aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (Zuerst muss die Bibliothek mit dem Befehl "pip install pyzbar" installiert werden.) <br><br>  <b>Erg√§nzung</b> : Der Site-Benutzer <i>vinograd19</i> hat einen interessanten Kommentar zum Berechnungsverlauf der Barcode- <i>Pr√ºfsumme</i> gesendet. <br><br>  <i>Die Berechnung der Schecknummer ist interessant, sie entstand evolution√§r.</i> <i><br></i>  <i>Eine Pr√ºfsumme wird offensichtlich ben√∂tigt, um eine falsche Dekodierung zu vermeiden.</i>  <i>Wenn der Barcode 1234 war und als 7234 dekodiert wurde, ben√∂tigen wir eine Methode, um das Ersetzen von 1 bis 7 abzulehnen. Die Validierung kann nicht perfekt sein, aber mindestens 90% der Codes sollten korrekt √ºberpr√ºft werden.</i> <i><br><br></i>  <i>1. Ansatz: Nehmen wir einfach die Summe, um 0 als Rest der Division zu haben.</i>  <i>Das erste Symbol enth√§lt Daten, und die letzte Ziffer ist so, dass die Summe aller Zahlen durch 10 geteilt wird. Wenn der Betrag nach der Decodierung nicht durch 10 teilbar ist, ist die Decodierung falsch und muss wiederholt werden.</i>  <i>Beispielsweise ist der Code 1234 g√ºltig - 1 + 2 + 3 + 4 = 10. Code 1216 - ist ebenfalls g√ºltig, 1218 jedoch nicht.</i> <i><br><br></i>  <i>Dies hilft, Dekodierungsprobleme zu vermeiden.</i>  <i>Die Codes k√∂nnen aber auch manuell √ºber die Hardwaretastatur eingegeben werden.</i>  <i>Auf diese Weise wurde ein weiterer schlechter Fall gefunden - wenn die Reihenfolge der zwei Ziffern ge√§ndert wird, ist die Pr√ºfsumme immer noch korrekt, es ist definitiv schlecht.</i>  <i>Wenn beispielsweise der Barcode 1234 als 2134 eingegeben wurde, ist die Pr√ºfsumme dieselbe.</i>  <i>Es wurde festgestellt, dass eine falsche Ziffernreihenfolge h√§ufig vorkommt, wenn eine Person versucht, Ziffern schnell einzugeben.</i> <i><br><br></i>  <i>2. Ansatz.</i>  <i>Verbessern wir den Pr√ºfsummenalgorithmus - lassen Sie uns die ungeraden Zahlen zweimal berechnen.</i>  <i>Wenn dann die Reihenfolge ge√§ndert wird, ist die Summe falsch.</i>  <i>Beispielsweise ist der Code 2364 g√ºltig (2 + 3 * 2 + 6 + 4 * 2 = 20), der Code 3264 jedoch nicht (3 + 2 * 2 + 6 + 4 * 2 = 19).</i>  <i>Es ist besser, aber ein anderer Fall ist aufgetreten.</i>  <i>Es gibt einige Tastaturen mit 10 Tasten in zwei Zeilen, die erste Zeile ist 12345 und die zweite ist 67890. Wenn der Benutzer anstelle von "1" "2" eingibt, schl√§gt die Pr√ºfsummenpr√ºfung fehl.</i>  <i>Wenn der Benutzer jedoch "6" anstelle von "1" eingibt, kann die Pr√ºfsumme manchmal korrekt sein.</i>  <i>Dies liegt daran, dass 6 = 1 + 5 ist und wenn die Ziffer eine ungerade Stelle hat, 2 * 6 = 2 * 1 + 2 * 5 - die Summe hat sich um 10 erh√∂ht. Der gleiche Fehler tritt auf, wenn der Benutzer "7" eingibt "Anstelle von" 2 "," 8 "anstelle von" 3 "und so weiter.</i> <i><br><br></i>  <i>3. Ansatz.</i>  <i>Nehmen wir die Summe noch einmal, aber lassen Sie uns ungerade Zahlen erhalten ... 3 mal.</i>  <i>Zum Beispiel ist der Code 1234565 - g√ºltig, weil 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 + 5 = 50.</i> <i><br><br></i>  <i>Diese Methode wurde mit einigen √Ñnderungen zum Standard f√ºr EAN13-Code: Die Anzahl der Ziffern ist fest und gleich 13, wobei die 13. Ziffer - die Pr√ºfsumme ist.</i>  <i>Zahlen an ungeraden Stellen werden dreimal gez√§hlt, an geraden Stellen einmal.</i> <br><br>  √úbrigens wird der EAN-13-Code am h√§ufigsten in Handels- und Einkaufszentren verwendet, sodass die Leute ihn h√§ufiger sehen als andere Codetypen.  Die Bitcodierung ist dieselbe wie in Code-128, die Datenstruktur finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel</a> . <br><br><h2>  Fazit </h2><br>  Wie wir sehen k√∂nnen, kann selbst eine so einfache Sache wie ein Barcode einige coole Sachen enthalten.  √úbrigens ein weiterer kleiner Lifehack f√ºr Leser, die geduldig genug waren, um bis zu diesem Ort zu lesen - der Text unter dem Barcode ist vollst√§ndig identisch mit den Barcode-Daten.  Es wurde f√ºr die Bediener erstellt, die den Code manuell eingeben k√∂nnen, wenn er vom Scanner nicht gelesen werden kann.  So ist es einfach, den Barcode-Inhalt zu kennen - lesen Sie einfach den folgenden Text. <br><br>  Danke f√ºrs Lesen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439768/">https://habr.com/ru/post/de439768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439758/index.html">Auf halbem Weg "Juno"</a></li>
<li><a href="../de439760/index.html">Ingenieure "verdrehten" das Licht in der Faser - eine neue Technologie beschleunigt die Daten√ºbertragung um das Hundertfache</a></li>
<li><a href="../de439762/index.html">√úber Hochschulbildung, Programmierer und Arbeiter</a></li>
<li><a href="../de439764/index.html">Unternehmensfr√ºchte</a></li>
<li><a href="../de439766/index.html">Erh√∂hen Sie es! Moderne Aufl√∂sung steigt</a></li>
<li><a href="../de439772/index.html">Unit-Tests in Swift schreiben, um asynchrone Aufgaben zu testen</a></li>
<li><a href="../de439774/index.html">Automatisieren Sie das Testen von Redux-Selektoren in der Anwendung</a></li>
<li><a href="../de439776/index.html">Frontend Weekly Digest (4. - 10. Februar 2019)</a></li>
<li><a href="../de439778/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 351 (4. - 10. Februar 2019)</a></li>
<li><a href="../de439780/index.html">PHP Digest Nr. 149 (28. Januar - 11. Februar 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>