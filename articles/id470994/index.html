<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐆 🍼 🍰 JavaScript Pewarisan dari Sudut Pandang Seorang Nerd yang Bosan: Pabrik Konstruktor 🚒 🐊 💖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kisah tentang satu bagian JavaScript yang sangat istimewa, bahasa buatan yang paling banyak digunakan di dunia saat ini (2019). 

 Artikel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript Pewarisan dari Sudut Pandang Seorang Nerd yang Bosan: Pabrik Konstruktor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470994/"><img src="https://habrastorage.org/webt/vn/qj/01/vnqj01fce5bbthmmo8gkl-6bawe.png" alt="lampu cahaya dan apel perselisihan" align="left">  Ini adalah kisah tentang satu bagian JavaScript yang sangat istimewa, bahasa buatan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>paling banyak digunakan</u></a> di dunia saat ini (2019). <br><br>  Artikel ini menyajikan semacam pandangan filosofis tentang Warisan dalam JavaScript, dan saya hanya berani berharap bahwa itu didasarkan pada sumber pengetahuan yang paling mengesankan: hidup itu sendiri dalam semua manifestasinya.  Saya tidak tahu apakah ini inspirasi ketika membuat desain rantai prototipe dalam JavaScript. <br><br>  Tetapi jika demikian, maka itu sangat penting dan kuat sehingga ketika saya mulai memikirkannya, kadang-kadang bahkan menjadi sulit untuk bernapas ... <br><br>  <i>(semua tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>digarisbawahi</u></a> )</i> <a name="habracut"></a><br><hr><br>  Saya juga yakin bahwa tidak seorang pun dari kita akan meragukan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Brendan Ike</u></a> (Eich) - penulis bahasa pemrograman JavaScript - adalah seorang jenius yang luar biasa!  Dan bukan hanya karena dia sering mengulang: <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Selalu bertaruh pada JavaScript!</u></a> </blockquote>  <b>Ayo mulai!</b>  Dan titik awal pertama kita adalah Imajinasi, di mana kita pertama-tama mematikan semua prasangka, kelalaian dan efek samping lainnya. <br><br>  Kami sedang menuju <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Back to the Future</u></a> , era sebelum penciptaan Internet modern di awal 1990-an. <br><br>  Dari saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Peretas pertama</u></a> yang menemukan segala sesuatu yang kami ( <i>karyawan TI</i> ) sekarang <i>gunakan</i> , kami telah pindah ke sketsa yang mengesankan: tentang perang antara peramban <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Netstcape Navigator</u></a> 2 dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Internet Explorer</u></a> 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Java baru</u></a> saja keluar, dan hampir semuanya dari internet modern belum ditemukan atau tidak terbuka.  Mungkin saja, seperti saya, di "masa lalu yang indah" Anda masih muda, dan Anda bisa mengingat perasaan keterlibatan yang luar biasa dalam semua kemegahan yang diciptakan tepat di depan mata Anda. <br><br>  Jadi, Anda memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>PC</u></a> yang sangat kuat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Intell Pentium 200 MMX</u></a> paling modern dengan 32Mb RAM, Windows 3.11 atau bahkan Windows 95 dan Anda mencari masa depan dengan harapan!  Dan, tentu saja, kedua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>browser</u></a> juga terpasang.  Anda memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Dial-Up</u></a> , di mana Anda terhubung ke Jaringan untuk sampah baru, juga, untuk belajar atau hanya mengobrol, mengobrol.  Meskipun, hei, Anda masih tidak bisa mengobrol langsung di browser, kemungkinan besar Anda menggunakan sistem pengiriman pesan yang tertunda, sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>EMail</u></a> atau mungkin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>UseNet</u></a> , atau, sangat mungkin, Anda sudah menguasai pengiriman instan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>IRC</u></a> . <br><br>  Beberapa tahun berlalu dan secara harfiah SEMUA perubahan ... Tiba-tiba Anda menonton animasi kepingan salju di halaman web memberi selamat kepada Anda pada Tahun Baru dan Natal.  Tentu saja, Anda tertarik pada cara ini dilakukan, dan Anda menemukan bahasa baru - JavaScript.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>HTML</u></a> bukan hal baru bagi Anda, Anda mulai mempelajari teknologi kerajinan yang memikat ini.  Segera Anda menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>CSS</u></a> dan ternyata ini juga penting, karena semuanya sekarang dibuat dari kombinasi ketiganya: HTML, JavaSript dan CSS.  Wow <br><br>  Sekitar waktu yang sama, Anda mungkin melihat beberapa hal hebat di Windows itu sendiri, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>CScript</u></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>HTA</u></a> muncul di dalamnya, dan bahkan kemudian menjadi mungkin untuk membuat aplikasi desktop penuh secara langsung di JS (dan ini masih berfungsi). <br><br>  Jadi Anda mulai membuat Web-Server pertama Anda, mungkin di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Perl</u></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>C</u></a> ~ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>C ++</u></a> .  Mungkin bahkan Anda mulai menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>OS</u></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>mirip Unix</u></a> dan melakukannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>bash</u></a> .  Dan semuanya "berputar-berputar" berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Common Gateway Interface</u></a> (jangan bingung dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>CGI</u></a> lainnya).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>PHP</u></a> masih hampir tidak ada, tetapi mungkin Anda akan segera menyukainya. <br><br>  Era 200x.  Anda sekarang melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>ASP</u></a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>JScript</u></a> .  Ini sangat mirip dengan JavaScript yang berfungsi di dalam halaman web Anda.  Ini sangat keren!  Anda sedang mempertimbangkan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>mesin template</u></a> Anda sendiri, semacam parodi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>XML</u></a> .  Dan kemudian seseorang tiba-tiba memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>AJAX</u></a> semua cara menyenangkan ini untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>secara dinamis</u></a> memuat konten yang telah Anda gunakan selama beberapa tahun sekarang.  Dan mereka semua sekarang berpikir bahwa hanya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>XMLHTTPRequest</u></a> , tetapi Anda ingat bahwa data dapat ditransfer ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>BMP</u></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>IFrame</u></a> atau bahkan dengan memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>tag &lt;script&gt;</u></a> .  Dan kemudian seseorang tiba-tiba dengan antusias berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>JSON</u></a> dan betapa berharganya itu, ketika Anda telah mengarahkan data untuk <i>selamanya</i> dengan sesuatu seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.write(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"script src="</span></span> + path + <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>);</code> </pre> <br>  Itu tidak penting <b>sekarang</b> , tetapi Anda masih ingat <b>bagaimana</b> ... <br><br>  Ketika Anda sadar, dari waktu ke waktu Anda mulai menemukan diri Anda bermain-main dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Rhino</u></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Nashorn</u></a> dalam upaya untuk memenuhi keinginan pelanggan Java menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Alfresco</u></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Asterisk</u></a> .  Dan Anda telah mendengar tentang munculnya JavaScript di dunia microchip, dan sangat terinspirasi oleh berita ini.  Dan tentu saja, sekarang Anda memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>jQuery</u></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Backbone</u></a> . <br><br>  Menyaksikan salju yang turun tahun 2010 yang akan datang, Anda sudah tahu bahwa di dunia Anda semua aturan permainan akan segera berubah, karena "Pemain No. 1" telah memasuki bidang: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Node.js.</u></a>  Dan 10 tahun ke depan Anda akan habiskan dengan mainan baru ini, dan bahkan sekarang, pada tahun 2019, Anda masih tidak bisa mendapatkan cukup dari seberapa kerennya itu. <br><br>  Secara umum, Anda senang dengan segalanya, semuanya cocok untuk Anda, semua mainan dan permainan di dalamnya menjadi bagian besar dari minat hidup Anda. <br><br>  <b><i>Tetapi ada satu pertanyaan kecil yang Anda tanyakan pada diri Anda hari demi hari, malam demi malam selama dua dekade sekarang:</i></b> <br><br><h3>  Jika Anda harus melakukan ini, bagaimana Anda menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Empati</u></a> menggunakan JavaScript? </h3><br>  Anda tahu bahwa salah satu topik paling rumit dalam JavaScript adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Prototipe Inheritance dan Prototype Chain</u></a> .  Dan Anda menyukai topik ini, Anda dapat menjelaskan bagaimana semua ini bekerja dan bekerja, hanya karena Anda telah mempelajarinya hampir sejak awal, bahkan sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>versi standar</u></a> pertama kali lahir, dan di mana, seperti yang Anda ingat, ada <b>4.2 .1 Objek</b> : <br><blockquote>  ECMAScript mendukung pewarisan berbasis prototipe.  Setiap konstruktor memiliki prototipe terkait, dan <b>setiap objek yang dibuat oleh</b> konstruktor tersebut memiliki <b>referensi implisit</b> ke prototipe (disebut prototipe objek) yang terkait dengan konstruktornya.  Lebih jauh, sebuah prototipe mungkin memiliki referensi implisit non-nol ke prototipe-nya, <b>dan</b> seterusnya;  <b>ini disebut rantai prototipe</b> . </blockquote>  <i>Setiap objek dibuat dengan referensi implisit ke prototipe.</i>  <i>Ini disebut rantai pewarisan prototipe, yang dapat Anda teruskan selama Anda suka.</i> <br><br>  Wow ... Dan jika tiba-tiba, seperti saya, Anda mungkin berpikir bahwa ini adalah salah satu penemuan terbesar dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Compuer Science</a> , lalu bagaimana Anda akan mengungkapkan efek dari membaca pernyataan ini terhadap Anda? <br><br>  Mari kita kembali ke awal.  Di halaman 1995.  Anda adalah Brendan Ike, dan Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>perlu menciptakan</u></a> bahasa pemrograman baru.  Mungkin Anda menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Lisp</u></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Skema</u></a> , setidaknya beberapa bagian favorit mereka.  Dan Anda dihadapkan pada kebutuhan untuk menyelesaikan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Inheritance</u></a> , karena Anda harus berpura-pura bahwa bahasa tersebut memiliki implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>OOP</u></a> tertentu.  <i>Mari kita berpikir</i> : Anda perlu mencampur semua hal yang Anda suka, mungkin juga beberapa hal yang tidak Anda sukai, dan koktail yang dihasilkan harus cukup baik sehingga tidak ada yang memperhatikan trik sampai ada kebutuhan nyata untuk memahami bagaimana itu. diatur di dalam. <br><br>  Dan sekarang pertanyaannya adalah: <b>apa yang akan terjadi pada Warisan?</b> <br><br>  Mari kita kembali ke dunia nyata sejenak.  Apa yang kita ketahui tentang Warisan?  Beberapa jawaban yang jelas untuk pertanyaan ini: <br><br><ol><li>  Sebagian besar bentuk kehidupan didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Genome</u></a> .  Ini adalah tempat penyimpanan informasi tentang kemungkinan karakteristik dan perilaku yang diduga dari makhluk hidup.  Ketika Anda adalah makhluk hidup, Anda membawa bagian dari genom di dalam diri Anda, Anda dapat mendistribusikannya, tetapi Anda menerimanya dari generasi sebelumnya. </li><li>  Anda dapat membuat makhluk hidup menggunakan dua teknik: mencampur (genom) dari dua leluhur atau, mungkin, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>kloning monoecious dari</u></a> salah satu dari mereka.  Tentu saja, saat ini kami memiliki teknologi yang memungkinkan pencampuran genom lebih dari satu makhluk, tetapi ini jauh lebih jelas dan tidak begitu alami. </li><li>  Faktor waktu itu penting.  Jika tidak ada properti yang diwarisi, atau belum, maka satu-satunya jalan keluar kami adalah membuatnya dari awal.  Selain itu, ada juga Legacy, yang berpindah kepada makhluk dari leluhurnya bukan melalui genom, tetapi melalui hukum properti, dan ini juga bisa menjadi signifikan. </li></ol><br>  Kembali ke masa lalu, dan pertanyaan yang tepat yang perlu kita tanyakan pada diri kita adalah sekarang: <b>Dan, pada kenyataannya, warisan Apa yang ingin kita dapatkan?</b> <br><br>  Bagaimanapun, dalam proses penyelesaian masalah warisan, kita harus setidaknya mengisi celah antara pemrograman dan kehidupan nyata, jika tidak, secara umum, kita tidak akan memiliki hak untuk menyebutnya Warisan. <br><br>  Sekarang mari kita selesaikan sendiri: kita berada di tahun 1995-an, dan kita memiliki PC yang kuat dengan hanya 32 megabita RAM, dan kita sedang mencoba membuat bahasa yang ditafsirkan, jadi kita harus merawat memori ini dengan cermat.  Setiap bagian data, terutama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>objek String</u></a> , menghabiskan banyak memori, dan kita harus dapat mendeklarasikan bagian ini hanya sekali, dan jika memungkinkan di masa depan selalu gunakan hanya pointer ke area memori yang ditempati oleh bagian ini.  <b>Kami meringkas: pertanyaan yang sangat sulit.</b> <br><br>  Ada pendapat populer: " <i>JavaScript dibuat dari objek</i> ."  Dengan menggunakan hal-hal sepele ini, kita dapat dengan mudah menjawab pertanyaan " <b>dari apa</b> " untuk diwarisi dan " <b>apa</b> ": dari Objek ke Objek.  Demi masalah menghemat memori, ternyata semua data harus disimpan dalam objek-objek ini, dan semua tautan data ini juga harus disimpan dalam properti Warisan dari objek-objek ini.  Mungkin sekarang sudah jelas mengapa pada tahun 1995 kami benar-benar perlu membuat Desain berdasarkan rantai prototipe: ini menghemat memori selama mungkin!  Dan secara umum, saya pikir ini masih bisa menjadi aspek yang sangat penting. <br><br>  Berdasarkan desain yang ditunjukkan dan pendapat " <i>semuanya adalah Obyek</i> ", kita dapat mencoba mengkloning sesuatu seperti itu.  Tapi apa kloning di sini sekarang?  Saya pikir bahwa mengikuti persyaratan persyaratan kami, kami dapat mengasumsikan sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Structural atau Surface Copy</u></a> , dalam sesuatu yang mirip dengan pendahulu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Object.assign</u></a> modern. <br>  Mari kita laksanakan salinan struktural sederhana pada 1995 dengan <b><i>for (var i in) {}</i></b> , karena standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>sudah mengizinkan ini</u></a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// back in 1995 cloning // it is not deep clone, // though we might not need deep at all var cloneProps = function (clonedObject, destinationObject) { for (var key in clonedObject) { destinationObject[key] = clonedObject[key]; } };</span></span></code> </pre><br>  Seperti yang Anda lihat, pendekatan ini masih “berhasil”, meskipun secara umum, tentu saja, saya akan merekomendasikan melihat modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>perluasan</u></a> untuk pemahaman yang lebih terperinci tentang bagaimana membuat kloning dalam JavaScript, tetapi untuk tujuan artikel ini, aplikasi yang konsisten cukup cocok untuk kita. dijelaskan oleh <b><i>cloneProps</i></b> , karena kita bisa menggunakannya di zaman kuno: <br><br><ul><li>  Objek kloning menggunakan Konstruktor: <i>menggunakan konstruktor, buat setidaknya dua klon yang berbeda</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// cloneProps is described above var SomeConstructor = function (clonedObject) { cloneProps(clonedObject, this); }; var someExistingObjectToClone = { foo : 'bar' }; var clone1 = new SomeConstructor(someExistingObjectToClone); var clone2 = new SomeConstructor(someExistingObjectToClone); // clone1.foo == clone2.foo</span></span></code> </pre></li><li>  kloning Konstruktor dari Konstruktor: kami <i>menerapkan penggunaan perilaku satu konstruktor dari konstruktor lain</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AnotherConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Function.prototype.call // was already invented in 1st ECMA-262 SomeConstructor.call(this); };</span></span></code> </pre></li><li>  kloning Konstruktor menggunakan Objek: <i>kita akan menggunakan objek yang sama untuk mengimplementasikan kloning di setidaknya dua konstruktor</i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> existentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cloneProps(foo, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OtherConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cloneProps(foo, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre></li><li>  kloning satu Objek dari Objek lain: <i>gunakan satu objek untuk membuat beberapa klonnya</i> .  Tidak ada yang bisa dijelaskan di sini, anggap saja seperti <b><i>klonProps</i></b> kami dari contoh pertama di atas. </li></ul><br>  <i>Dengan kloning, secara umum, semuanya sederhana, seperti yang kita lihat, semuanya jelas dan secara umum, tetapi ...</i> <br><br>  Apakah begitu mudah bagi kita untuk melakukan Warisan Entitas, menggunakan kombinasi dari para pendahulunya? <br><br><ul><li>  Warisan objek menggunakan Konstruktor: <i>ini adalah tujuan utama para desainer, kami hanya akan menunjukkan bagaimana awalnya dirancang</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> existentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SomeConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; SomeConstructor.prototype = existentObject; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeConstructor(); <span class="hljs-comment"><span class="hljs-comment">// we have no instanceof yet in ECMA 262 of 1995 // therefore we are unable to rely on this window.alert(inheritedObject.foo); // bar</span></span></code> </pre></li><li>  Warisan Konstruktor dari Konstruktor lain: tidak diragukan lagi, orang pertama yang memperhatikan ini adalah Genius yang luar biasa.  <i>Secara keseluruhan, ini adalah contoh klasik lain dari mana-mana</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FirstConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foo = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InheritedConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ FirstConstructor.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; InheritedConstructor.prototype = { <span class="hljs-attr"><span class="hljs-attr">bar</span></span> : <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; InheritedConstructor.prototype.constructor = FirstConstructor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inherited = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InheritedConstructor(); <span class="hljs-comment"><span class="hljs-comment">// { foo : 'bar', bar : 'foo' }</span></span></code> </pre><br>  <i>mungkin saja menyatakan sesuatu yang canggih, tetapi mengapa</i> <br></li><li>  Warisan dari Konstruktor dari Objek: sekali lagi, kita hanya menggunakan <b><i>.prototype = objek</i></b> setiap kali kita membutuhkannya, tidak ada yang perlu dijelaskan, kita selalu perlu menetapkan <b><i>Constructor.prototype</i></b> karena seharusnya meletakkan objek di sana, dan dengan tautan implisit kita mendapatkan semua propertinya. . </li><li>  Mewarisi Objek dari Objek: hal yang sama.  Kami cukup meletakkan objek pertama di <b><i>Constructor.prototype</i></b> dan segera setelah kami mengatakan <b><i>Constructor baru</i></b> kami akan membuat salinan bawaan di mana akan ada referensi implisit ke properti dari objek pertama kami. </li></ul><br>  Dan tentu saja, dalam semua situasi ini dengan warisan, kita akan memiliki kesempatan untuk memeriksa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><i><u>instance dari</u></i></b></a> konstruktor mana kita menciptakan objek, meskipun, tentu saja, harus dicatat bahwa <b><i>instanceof</i></b> itu sendiri muncul dalam standar hampir empat tahun kemudian. <br><br>  Benar, masih ada detail kecil dari paragraf 4.2.1: <br>  dapat melakukan ini selama diperlukan, seperti dikatakan: <br><blockquote>  <b>dan sebagainya</b> </blockquote>  Baiklah, <b>mari kita coba membuat warisan benar-benar tak ada habisnya</b> , menggunakan teknologi <b>dari 1995</b> . <br><br>  Sebenarnya, mari kita bayangkan bahwa kita memiliki dua Entitas, dan <i>Bukan</i> Konstruktor, tetapi objek sederhana.  Dan kami ingin mewarisi satu dari yang lain, dan kemudian mungkin dari yang lain, dan dari yang lain, dan seterusnya ... <br><br><h3>  Tapi bagaimana caranya? </h3><br>  Lihatlah sedikit lebih jauh, lebih dalam. <br>  Jawaban yang benar di sini lagi adalah: <b>Warisan apa yang perlu kita ciptakan?</b> <br><br>  Lagi pula, kita tidak membutuhkan Entitas ini sendirian.  Kami membutuhkan properti mereka: memori yang dikonsumsi data terkait;  dan juga, kita mungkin memerlukan beberapa perilaku: metode menggunakan data ini.  Dan itu akan sama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>jujurnya</u></a> , jika kita memiliki kesempatan untuk memeriksa di mana dan di mana kita mewarisi dan menggunakan apa.  Secara umum, akan sama kerennya jika kita dapat mereproduksi desain inheren pola pewarisan di masa depan, menyiratkan bahwa jika kita mewarisi satu dari yang lain berkali-kali, kita akan selalu mendapatkan hasil yang sama, sesuai dengan apa yang kita tulis (kontrak) .  Meskipun masih, itu bisa berguna bagi kita untuk entah bagaimana memperbaiki momen penciptaan, karena entitas "sebelumnya" kita dapat berubah dari waktu ke waktu, dan "ahli waris", memberi mereka rasa hormat dalam hal ini, masih berubah dengan mereka mungkin tidak terlalu mau. <br><br>  Dan, karena semua kode kita adalah kombinasi dari data dan perilaku, apakah pada umumnya akan menggunakan metode yang sama - menggabungkan data dan presentasi - ketika merancang sistem Warisan? <br><br>  Bagi saya, semua ini menyerupai apa yang kita lihat ketika mengamati Kehidupan dalam semua bentuknya yang luar biasa.  Dari unicellular pertama, ke multiseluler dan keturunan mereka, dan lebih jauh ke Hewan, orang, humanisme dan suku, peradaban, Intelek, dan bentuk buatannya, dan lebih jauh ke Luar Angkasa, ke Galaksi, ke Bintang!  dan: <br><blockquote>  "... Yang perlu kita lakukan adalah memastikan kita terus berbicara ..." </blockquote>  <i>(semua yang perlu kita lakukan adalah melanjutkan komunikasi)</i> <br><br>  Luar biasa dalam perhatiannya, kutipan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Stephen Hawking</u></a> , yang kemudian dipopulerkan dalam karya besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Pind Floyd ini</u></a> . <br><br>  Memprogram bahasa berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>passing pesan</u></a> dan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>berbasis aliran yang</u></a> diterapkan melalui API internal yang kuat memungkinkan Anda untuk beralih dari <i>data sederhana</i> ke abstraksi yang lebih tinggi, deskripsi, dan yang lainnya.  Saya pikir ini murni Seni, dan cara kerjanya khususnya dalam struktur JavaScript yang sangat tersembunyi melalui hubungan implisit antara data dalam rantai prototipe. <br><br>  Bayangkan lagi dua leluhur, mereka berkomunikasi dan pada satu saat emosi dan perasaan mereka menciptakan anak.  Anak itu tumbuh, bertemu anak lain, mereka berkomunikasi, dan keturunan berikutnya muncul, dan lebih jauh lagi dan lagi ... Dan kita selalu membutuhkan Dua orang tua, kalau tidak itu tidak alami, itu sudah akan menjadi rekayasa genetika.  Dua, tidak lebih dan tidak kurang.  Seorang keturunan menerima hal yang sama dengan Warisan mereka, jadi itu sederhana dan dapat dimengerti. <br><br>  Saya mengerti ini akan terdengar aneh, tapi ya, kami memiliki semua yang kami butuhkan untuk membuat model Warisan ini pada tahun 1995.  Dan dasar dari semua ini adalah <b>4.2.1 Obyek</b> , referensi tersirat melalui prototipe. <br><br>  Dan itulah tepatnya, menggabungkan <i><b>ParentObject</b></i> dengan <i><b>ParentConstructor</b></i> dengan menetapkan <i><b>.prototype</b></i> dan kemudian <i><b>Constructor</b></i> mungkin akan membuat kita <i><b>ChildObject</b></i> , tentu saja, jika kita mengucapkan kata ajaib " <b><i>baru</i></b> ": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ParentObject = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span> : <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ParentConstructor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; ParentConstructor.prototype = ParentObject; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ChildObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentConstructor(); <span class="hljs-comment"><span class="hljs-comment">// starting from 1995 and then ECMA 262 // we are able to say new // each time we need a ChildObject</span></span></code> </pre> <br>  Kita bisa melihat di sini kedua leluhur kita.  Pada saat kami mengucapkan kata ajaib " <b><i>baru</i></b> ", kami meminta mereka mengobrol.  Jika mereka tidak ingin berkomunikasi, Life akan berhenti, proses akan jatuh dengan kesalahan, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>kompiler</u></a> (juru bahasa) akan memberi tahu kami tentang hal itu. <br><br>  Tentu saja, ya, tapi kami memang meminta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Pohon Warisan</u></a> atau membiarkannya menjadi jauh lebih sederhana, setidaknya untuk Pohon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Silsilah</u></a> .  Dan jawabannya masih sama ... <i><b>Obyek Anak</b></i> kita tumbuh, dan itu <i><b>menjadi Objek Induk</b></i> , kemudian bertemu <i><b>Obyek Konstruktor</b></i> baru dan segera setelah kita mengucapkan kata yang diidam-idamkan " <b><i>baru</i></b> " - sihir: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this Assignment is just to show it grew up var ChildObjectGrownToParent = ChildObject; var AnotherConstructor = function () {}; AnotherConstructor.prototype = ChildObjectGrownToParent; var SequentialChildObject = new AnotherConstructor(); // checking Life Cycle ;^) console.log(ChildObject instanceof ParentConstructor); // true console.log(SequentialChildObject instanceof ParentConstructor); // true console.log(SequentialChildObject instanceof AnotherConstructor); // true</span></span></code> </pre> <br>  Dan kita dapat terus melakukan ini tanpa batas.  Dan saya, mungkin, benar-benar percaya bahwa ini adalah ide utama ketika mengembangkan desain Rantai Prototipe, karena seperti yang kita semua tahu, pendekatan ini menciptakan beberapa masalah yang <b>sangat rapi</b> tetapi tidak kurang menyenangkan ... <br><br>  <b>1: Komunitas ...</b> Seperti yang Anda dapat dengan mudah memeriksa diri sendiri, menentukan dalam <i><b>.prototype</b></i> <i><b>ParentConstructor '</b></i> a atau <i><b>AnotherConstructor'</b></i> a adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Kontrak Sosial yang</u></a> sangat serius dan ketat di Suku kita.  Ini menciptakan referensi ke properti <b><b>ParentObject</b></b> ( <i><b>.foo</b></i> ) untuk Heirs: <i><b>ChildObject</b></i> dan <i><b>SequentialChildObject</b></i> .  Dan jika kita menghilangkan indikasi ini, maka tautan ini akan hilang.  Jika kita membuat, dan menetapkan kembali referensi ini ke beberapa objek lain, maka ahli waris kita akan langsung mewarisi properti lain.  Oleh karena itu, menggabungkan leluhur melalui. <i><b>Prototipe</b></i> , kita mungkin dapat mengatakan bahwa kita menciptakan semacam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>sel masyarakat</u></a> , karena "leluhur" ini dapat mereproduksi banyak keturunan identik setiap kali kita bertanya kepada mereka tentang hal itu menggunakan yang <i><b>baru</b></i> .  Dan dengan demikian, setelah menghancurkan "keluarga", kami merusak kualitas keturunan dari keturunannya, drama semacam itu; ^) <br><br>  Mungkin ini semua pembicaraan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Legacy</u></a> dalam kode kita, kita harus mengurus ini ketika kita akan membuat kode yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>aman</u></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>didukung</u></a> !  Tentu saja, tidak ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>SOLID</u></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Prinsip Liskov</u></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Desain oleh Kontrak</u></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>GRASP</u></a> dibahas pada tahun 1995, tetapi jelas bahwa metodologi ini tidak dibuat "dari awal", semuanya dimulai jauh lebih awal. <br><br>  <b>2: Keluarga ...</b> Kami dapat dengan mudah memverifikasi bahwa <u><b>ParentObject</b></u> kami dibiarkan sangat sembrono dengan Constructos lainnya.  Ini tidak adil, tetapi kita dapat menggunakan banyak Konstruktor seperti yang kita inginkan dalam Warisan ParentObject kita dan dengan demikian menciptakan keluarga sebanyak yang kita suka.  Di sisi lain, setiap Konstruktor sangat erat kaitannya dengan ParentObject melalui tugas .prototype, dan jika kita tidak ingin membahayakan ahli waris kita, kita harus menjaga hubungan ini selama mungkin.  Kita bisa menyebutnya seni tragedi dalam sejarah suku kita.  Meskipun, tentu saja, ini melindungi kita dari Amnesia - kelupaan dari apa yang kita warisi dan dari siapa, dan mengapa pewaris kita mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Warisan</u></a> seperti itu.  Dan, memuji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Mnemosyne yang</u></a> hebat!, Kita dapat dengan mudah menguji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Pohon</u></a> Rantai Prototipe kita dan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Artefak</u></a> dari apa yang kita lakukan salah. <br><br>  <b>3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Usia tua</u></a> ...</b> <i><b>ParentObject</b></i> dan <i><b>Constructor kami</b></i> tentu saja rentan terhadap kerusakan selama siklus hidup program kami.  Kita dapat mencoba untuk mengurus ini, tetapi tidak ada yang aman dari kesalahan.  Dan semua perubahan ini bisa membahayakan ahli waris.  Kita harus menjaga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>kebocoran memori</u></a> .  Tentu saja, kita dapat menghancurkan bagian kode yang tidak perlu dalam runtime dan dengan demikian membebaskan memori yang tidak lagi digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Siklus Hidup</u></a> kita.  Selain itu, kita harus menyingkirkan semua kemungkinan untuk menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Paradox Sementara</u></a> dalam rantai prototipe, karena sebenarnya cukup sederhana untuk mewarisi Leluhur dari Keturunannya sendiri.  Tapi ini sudah bisa sangat berbahaya, karena teknik menggoda dengan masa lalu dari masa depan dapat membuat tumpukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Heisenbag</u></a> sulit untuk direproduksi, terutama jika kita mencoba mengukur sesuatu yang dengan sendirinya dapat berubah seiring waktu. <br><br><h2>  Kronik Keputusan </h2><br>  Biarkan itu sederhana, jelas dan tidak terlalu berguna, tetapi alih-alih memikirkan tentang Konstruktor dan ParentObject kita sebagai Ibu dan Ayah, mari kita gambarkan mereka sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>telur</u></a> dan ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>serbuk sari</u></a> .  Kemudian, di masa depan, ketika kita membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Zygote</u></a> menggunakan kata berharga " <i><b>baru</b></i> ", itu tidak akan lagi membahayakan imajinasi kita! <br><br>  Saat kita melakukan ini, kita akan segera menyingkirkan ketiga masalah di atas!  Tentu saja, untuk ini kita perlu kemampuan untuk membuat zigot sendiri, yang berarti kita membutuhkan Pabrik Desainer.  Dan sekarang sebut saja apa yang Anda suka, ibu, ayah, apa bedanya, karena intinya adalah jika kita akan mengatakan " <i><b>baru</b></i> ", maka kita harus membuat kandang desainer bunga "baru", meletakkan serbuk sari di atasnya dan hanya ini yang akan memungkinkan kita untuk menumbuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Snowdrop</a> "benar" baru di 2020m yang jauh dan bersalju: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Pollen = { <span class="hljs-attr"><span class="hljs-attr">season</span></span> : <span class="hljs-string"><span class="hljs-string">'Spring'</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// factory of constructors var FlowersFactory = function (proto) { var FlowerEggCell = function (sort) { this.sort = sort; }; FlowerEggCell.prototype = proto; return FlowerEggCell; }; var FlowerZygote = FlowersFactory(Pollen); var galanthus = new FlowerZygote('Galanthus');</span></span></code> </pre> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dan ya, jangan lupa untuk memeriksa musim dengan tetesan salju ini, kalau tidak serpihan salju akan jatuh atau jatuh, dan tetesan salju akan menjadi bunga musim semi ...)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentu saja, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas Siklusik dari</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keputusan yang Anda coba buat menggunakan pendekatan ini akan sangat sebanding dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riddle Einstein</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Oleh karena itu, di sini saya "membuat" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpustakaan</font></font></b></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dapat membantu dengan penciptaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rantai</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desainer dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoisasi</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , (catatan editor: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yah, takoe, ambil kue dari rak, bla-bla-bla</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan meskipun saya tidak dapat membuktikannya, pendekatan ini telah cukup berhasil digunakan dari waktu ke waktu selama dua dekade sekarang, jika Anda perlu 146% yakin bahwa semuanya normal dengan warisan. Anda dapat dengan mudah melihat sendiri bahwa itu diuji, direproduksi, dan didukung secara elemen (Ed. Catatan: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yeah, sekarang, Anda meninggalkan segalanya dan memastikannya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, ini bukan keseluruhan cerita, kami hanya menyatakan fakta: JavaScript dirancang cukup baik untuk menggambarkan Grafik Silsilah secara langsung melalui Warisan. Tentu saja, di sini kami tidak secara </font><i><b><font style="vertical-align: inherit;">diam</font></b></i><font style="vertical-align: inherit;"> - </font><i><b><font style="vertical-align: inherit;">diam</font></b></i><font style="vertical-align: inherit;"> menyentuh topik </font><font style="vertical-align: inherit;">degradasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi saya yakin Anda sendiri dapat dengan mudah mengganti </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowerEggCell</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowerEggCellClass</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di dalam </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowersFactory</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: esensi akan tetap sama jika Anda ingin memeriksa bunga Anda melalui </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda akan melihat bahwa mereka semua adalah keturunan dari </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowerEggCell</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang Anda </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referensikan</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melalui </font><i><b><font style="vertical-align: inherit;">FlowerZygote</font></b></i><font style="vertical-align: inherit;"> . Dan tentu saja, sekarang Anda dapat mengubah properti </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowerZygote</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">, karena ini tidak akan membahayakan </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlowerFactory</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">, itu akan tetap dapat membuat konstruktor FlowerEggCell atau FlowerEggCellClass lainnya di masa mendatang sesuai dengan </font><font style="vertical-align: inherit;">desain " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referensi</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " asli yang Anda </font><font style="vertical-align: inherit;">letakkan di </font><font style="vertical-align: inherit;">sana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap artikel ini telah menghilangkan semua keraguan tentang pentingnya kata </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.protype pada</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat Anda melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></b></i></u></a>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><i><b>this</b></i></u></a> ,  <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>call</u></a> (null</b></i> , <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>apply</u></a> (null</b></i>  <i><b>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>bind</u></a> (null</b></i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u></u></a>      code style  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u> </u></a> (. .: <i>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Sorrow</u></a>   ,    ,  ,         </i> ). <br><br>   ! <br><br>   ! <br><br>   V </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470994/">https://habr.com/ru/post/id470994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470980/index.html">Tugas yang diselesaikan robot perangkat lunak (RPA) di sektor perbankan</a></li>
<li><a href="../id470982/index.html">Analisis komitmen dan tarik permintaan di Travis CI, Buddy, dan AppVeyor menggunakan PVS-Studio</a></li>
<li><a href="../id470984/index.html">Analisis komitmen dan permintaan tarik di Travis CI, Buddy dan AppVeyor menggunakan PVS-Studio</a></li>
<li><a href="../id470988/index.html">Pendaftaran terbuka untuk Slerm DevOps di Moskow</a></li>
<li><a href="../id470990/index.html">Perangkat pemasaran online: 3 Aplikasi untuk meningkatkan komunikasi visual</a></li>
<li><a href="../id470996/index.html">Bagaimana tag <img> sederhana bisa menjadi risiko tinggi untuk bisnis?</a></li>
<li><a href="../id470998/index.html">Mainan Kayu, Bagian Sepuluh - 1996</a></li>
<li><a href="../id471000/index.html">Mainan kayu, bagian terakhir - 1997</a></li>
<li><a href="../id471004/index.html">Mainan kayu - epilog yang tetap dipakukan di langit-langit</a></li>
<li><a href="../id471006/index.html">$ 500 per bulan: apa yang digunakan oleh penerima pendapatan dasar tanpa syarat?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>