<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéå ü§õüèº üë®üèΩ‚Äçüåæ Como gerenciar um rel√≥gio? An√°lise da pista front-end do segundo campeonato de programa√ß√£o üßëüèø‚Äçü§ù‚Äçüßëüèæ üï° üï£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um novo habrapost em uma s√©rie de an√°lises do recente campeonato. Os participantes da qualifica√ß√£o que escolheram a se√ß√£o de front-end tiveram que res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como gerenciar um rel√≥gio? An√°lise da pista front-end do segundo campeonato de programa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478550/"><img src="https://habrastorage.org/webt/4e/n2/ks/4en2ksorc6zfdwcwfcvsceozmxg.jpeg" width="300" align="right">  Um novo habrapost em uma s√©rie de an√°lises do recente campeonato.  Os participantes da qualifica√ß√£o que escolheram a se√ß√£o de front-end tiveram que resolver v√°rias tarefas de complexidade muito diferente: a primeira (de acordo com nossas expectativas) levou 20 minutos, a √∫ltima - cerca de uma hora.  Testamos uma ampla variedade de habilidades de desenvolvedor de interface, incluindo a capacidade de entender uma √°rea incomum. <br><br><h2>  A. Aniquil√°-lo </h2>  <sup><i>Autores: Maxim Sysoev, Konstantin Petryaev</i></sup> <br><br>  A primeira tarefa √© um aquecimento.  Cada participante obteve uma das quatro op√ß√µes para a tarefa, semelhantes entre si.  Propusemos n√£o apenas uma condi√ß√£o textual, mas tamb√©m uma solu√ß√£o recursiva "ruim".  Era necess√°rio refazer o c√≥digo (escrever um algoritmo ganancioso que produzisse a solu√ß√£o mais r√°pida), removendo a recurs√£o e v√°rias bobagens, como opera√ß√µes e c√°lculos desnecess√°rios. <br><br><h4>  Condi√ß√£o </h4><br>  Voc√™ conseguiu um emprego em um laborat√≥rio para o estudo da antimat√©ria, onde eles conduzem v√°rias experi√™ncias.  Seu departamento est√° estudando os processos que ocorrem ao combinar mat√©ria e antimat√©ria.  Voc√™ precisa realizar uma s√©rie de experimentos com um certo n√∫mero de mol√©culas. <br><a name="habracut"></a><br>  O departamento vizinho desenvolveu um aparelho que transforma a mat√©ria em antimat√©ria por um curto per√≠odo de tempo.  Ser√° √∫til para voc√™ realizar experi√™ncias nas quais o seguinte algoritmo √© usado: <br><br>  - Encontramos 2 das mol√©culas mais pesadas. <br>  - Transformamos um deles em antimat√©ria. <br>  - Combine-os.  Al√©m disso, se o peso for o mesmo, eles ser√£o aniquilados.  Se o peso for diferente, obteremos uma nova mol√©cula, cujo peso √© igual √† diferen√ßa de pesos das duas anteriores.  A pr√≥pria mol√©cula resultante √© mat√©ria. <br>  - Se sobrar uma mol√©cula, voc√™ precisar√° descobrir o seu peso.  Se houver muitas mol√©culas, retornamos √† etapa 1. <br><br>  Voc√™ precisa descobrir a mol√©cula de qual peso permanecer√° no final do experimento; esse conhecimento √© necess√°rio por cientistas de outro departamento. <br><br>  O desenvolvedor anterior esbo√ßou o c√≥digo que estava envolvido nesses c√°lculos, mas o c√≥digo n√£o pode concluir os c√°lculos quando o experimento √© realizado em um grande n√∫mero de mol√©culas.  Voc√™ precisa refinar o c√≥digo para que ele funcione em um per√≠odo de tempo razo√°vel. <br><br>  <b>C√≥digo herdado para voc√™</b> <br><br>  Como entrada, voc√™ ter√° uma matriz com pesos moleculares.  Como sa√≠da, voc√™ precisa retornar um n√∫mero que indica o peso da √∫ltima mol√©cula.  Se n√£o houver mol√©culas restantes, ser√° necess√°rio retornar 0. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights, i = weights.length - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cur = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = (weights[i] === weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i] - weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findLatestWeight(weights, i - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Exemplo e notas</b> <div class="spoiler_text"><h4>  Exemplo </h4><br>  Entrada: [2,7,4,1,8,1] <br>  Sa√≠da: 1 <br><br>  Pegamos mol√©culas com um peso de 7 e 8, transformamos 7 em uma antimol√©cula e colidimos com uma mol√©cula de peso 8. Permanece uma mol√©cula de peso 1. Os pesos das restantes mol√©culas de a√ßo [2,4,1,1,1].  Pegamos mol√©culas com um peso de 2 e 4, transformamos 2 em uma antimol√©cula e colidimos com uma mol√©cula de peso 4. Permanece uma mol√©cula de peso 2. Os pesos das restantes mol√©culas de a√ßo [2,1,1,1].  Pegamos mol√©culas com um peso de 2 e 1, transformamos 1 em uma antimol√©cula e colidimos com uma mol√©cula de peso 2. Permanece uma mol√©cula de peso 1. Os pesos das restantes mol√©culas de a√ßo [1,1,1].  Pegamos mol√©culas com o peso de 1 e 1, transformamos uma delas em antimol√©cula e colidimos com a segunda.  Eles s√£o aniquilados.  Os pesos das mol√©culas restantes [1].  Uma mol√©cula esquerda.  O resultado √© 1. <br><br><h4>  Anota√ß√µes </h4><br>  Como solu√ß√£o, forne√ßa um arquivo que exporte a vers√£o corrigida da fun√ß√£o findLatestWeight: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLatestWeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } module.exports = findLatestWeight;</span></span></code> </pre> <br>  A solu√ß√£o ser√° executada no Node.js 12. <br></div></div><br><h4>  Solu√ß√£o </h4><br>  A solu√ß√£o "ruim" fornecida tem v√°rios problemas ao mesmo tempo.  O primeiro √© a recurs√£o.  Conforme declarado na condi√ß√£o, processaremos grandes matrizes de n√∫meros, o que elimina imediatamente uma solu√ß√£o recursiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; i--; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  A expans√£o da recurs√£o aqui √© bastante simples, mas surge outro problema - h√° uma reclassifica√ß√£o constante (de menor para grande) e funciona com o final da matriz.  Como resultado, obtemos uma diminui√ß√£o no pen√∫ltimo elemento na matriz.  Mas depois disso, n√£o aparamos a matriz e, se uma matriz de um milh√£o de elementos foi passada para a fun√ß√£o, ent√£o a classificaremos novamente at√© o final. <br><br>  Uma op√ß√£o para resolver esse problema √© tentar aparar constantemente a matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> findLatestWeight = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = weights.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-number"><span class="hljs-number">0</span></span>; weights.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b); weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (weights[i]=== weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : weights[i]-weights[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; weights.length = i; <span class="hljs-comment"><span class="hljs-comment">// &lt;---   i--; } while (true); }</span></span></code> </pre> <br>  Nada mal, mas tamb√©m precisamos nos livrar da classifica√ß√£o, que por si s√≥ √© uma opera√ß√£o cara.  Em geral, a qualquer momento, estaremos interessados ‚Äã‚Äãnos 2 maiores membros da matriz.  Ou seja, √© uma busca por dois m√°ximos, o que √© feito em uma passagem de maneira bastante simples.  Por conveni√™ncia, realizamos essa pesquisa em uma fun√ß√£o separada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maximumTwo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1 = arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2 = arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max1I = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max2I = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) { max2 = arr[i]; max2I = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { max1 = arr[i]; max1I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[i] &gt; max2) { max2 = arr[i]; max2I = i; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max1 &gt; max2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max2, max1, max2I, max1I]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [max1, max2, max1I, max2I]; };</code> </pre> <br>  E alteramos a fun√ß√£o de pesquisa da seguinte maneira: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">weights</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weights.length &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weights[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [x, y, xI, yI] = maximumTwo(weights); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } weights[xI] = <span class="hljs-number"><span class="hljs-number">0</span></span>; weights[yI] = y - x; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); };</code> </pre> <br>  Assim, sempre zeramos o menor dos dois elementos e transformamos o maior na diferen√ßa entre eles.  N√≥s nos livramos da classifica√ß√£o e recebemos uma passagem linear. <br><br>  Dos erros comuns que notamos, os participantes pegaram o elemento m√°ximo, multiplicaram por -1 e o adicionaram √† segunda maior pedra.  O resultado √© um n√∫mero negativo, que foi usado no c√°lculo "como est√°".  Al√©m disso, a tarefa tem uma armadilha mental associada ao fato de que voc√™ pode tentar deixar pedras de peso √∫nico e calcular a diferen√ßa delas.  No entanto, essa abordagem n√£o fornece o resultado correto. <br><br><h2>  B. BEM </h2>  <sup><i>Autores: Eugene Mishchenko, Vladimir Grinenko <a href="https://habr.com/ru/users/tadatuta/" class="user_link">tadatuta</a></i></sup> <br><br><h4>  Condi√ß√£o </h4><br>  Layout Alexander est√° envolvido em muitos projetos usando a metodologia BEM.  Ele at√© criou um plugin √∫til para seu IDE favorito, que permite escrever nomes de classes em uma nota√ß√£o abreviada e implant√°-los ao m√°ximo.  Mas o problema √© que, para cada projeto, as pessoas definem delimitadores diferentes entre o bloco, o elemento e o modificador (block__mod__val - elem, block - mod - val ___ elem) e cada vez que ele precisa editar isso manualmente em seu plugin.  Ajude Alexander a escrever um m√≥dulo que determinar√° o separador para entidades com base na classe.  A regra para delimitadores √© um n√∫mero arbitr√°rio de caracteres (n√£o letras).  Exemplos de poss√≠veis nota√ß√µes (modificadores para um bloco nos dados de entrada podem n√£o ter valor): <br><br><pre> <code class="javascript hljs">block_mod__elem <span class="hljs-comment"><span class="hljs-comment">// ,     block_mod_mod__elem block__elem_mod_mod</span></span></code> </pre><br>  Esclarecimentos: <br>  - As aulas nos projetos s√£o escritas apenas em letras min√∫sculas. <br>  - Uma string com uma classe CSS v√°lida √© alimentada na entrada do m√≥dulo. <br><br>  O m√≥dulo deve retornar uma resposta do formul√°rio: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">mod</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    elem: "__", //    }</span></span></code> </pre> <br>  O m√≥dulo deve ser emitido como um m√≥dulo commonJS: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br><h4>  Solu√ß√£o </h4><br>  A segunda tarefa levou cerca de 20 minutos.  Com sua ajuda, quer√≠amos testar o conhecimento de express√µes regulares entre os participantes. <br><br>  A partir da condi√ß√£o, aprendemos que a entrada para a fun√ß√£o ser√° uma string que cont√©m uma classe CSS v√°lida com restri√ß√µes adicionais, na qual as seq√º√™ncias de letras s√£o separadas por sequ√™ncias arbitr√°rias de caracteres n√£o-letras.  Nossa tarefa √© encontrar separadores e entender sua sem√¢ntica. <br><br>  A primeira parte do nome da classe sempre ser√° o nome do bloco.  Esta √© uma sequ√™ncia de uma ou mais letras.  N√≥s escrevemos a express√£o regular correspondente: [az] +. <br><br>  Precisamos de express√µes semelhantes para procurar as partes restantes: o nome do modificador e seu valor, ou o nome do elemento com o modificador e valor correspondentes. <br><br>  Para procurar delimitadores, precisamos de sequ√™ncias sem letras, a express√£o: [^ az] + √© adequada. <br><br>  Junte-o e defina os grupos cujos valores usaremos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>);</code> </pre> <br>  Agora voc√™ precisa ter certeza de que definimos corretamente a sem√¢ntica dos grupos encontrados.  Voc√™ pode tirar vantagem do fato de que apenas um modificador pode atender duas vezes. <br><br>  Escreveremos uma fun√ß√£o que utilizar√° a string original e o separador encontrado para calcular o n√∫mero de ocorr√™ncias: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length;</code> </pre> <br>  Se o elem do delimitador ocorrer duas vezes e mod - uma vez, na verdade o oposto √© verdadeiro.  A decis√£o final: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [, mod, elem ] = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/[az]+(?:([^az]+)[az]+(?:\1)?[az]+)([^az]+)[az]+(?:\2)?[az]+/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> substringCount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source, substr</span></span></span><span class="hljs-function">) =&gt;</span></span> (source.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'[az]'</span></span> + substr + <span class="hljs-string"><span class="hljs-string">'[az]'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>)) || []).length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substringCount(str, elem) === <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; substringCount(str, mod) === <span class="hljs-number"><span class="hljs-number">1</span></span>) { [mod, elem] = [elem, mod]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { mod, elem }; }</code> </pre> <br><h2>  C. F√°brica de clones </h2>  <sup><i>Autores: Dmitry Andriyanov <a href="https://habr.com/ru/users/dima117/" class="user_link">dima117</a> , Alexey Gusev</i></sup> <br><br><h4>  Condi√ß√£o </h4><br>  Fora da janela √© 2319.  As empresas clonam funcion√°rios bem-sucedidos para executar tarefas complexas. <br><br>  Na produ√ß√£o de clones, eles decidiram rotular novos ‚Äúprodutos‚Äù com uma tatuagem de c√≥digo de barras no ombro - para distinguir os clones um do outro. <br><br>  Ajude a equipe da f√°brica a escrever uma fun√ß√£o que desenhe um c√≥digo de barras com informa√ß√µes sobre o clone. <br><br>  <b>Clone Information Format</b> <br><br>  As informa√ß√µes sobre o clone s√£o armazenadas da seguinte maneira: <br><br><pre> <code class="javascript hljs">type CloneInfo = { <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî  'male'  'female' */</span></span> sex: string; <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî      *    ,  10  */</span></span> id: string; <span class="hljs-comment"><span class="hljs-comment">/** *   ‚Äî      *     ( 0  26 ) */</span></span> name: string; }</code> </pre> <br>  <b>Algoritmo de renderiza√ß√£o de c√≥digo de barras</b> <br><br>  Os c√≥digos de barras usados ‚Äã‚Äãna f√°brica de clones s√£o assim: <br><br><img src="https://habrastorage.org/webt/jl/jj/dc/jljjdcawcmcsrmsgyyi9bk19oii.png" width="400"><br><br>  O c√≥digo de barras tem um tamanho fixo - 148 por 156 pixels.  Ao redor do per√≠metro do c√≥digo de barras, h√° quadros em preto e branco de 3 pixels cada.  Dentro dos quadros est√° o conte√∫do do c√≥digo de barras, composto por 18 linhas de 17 quadrados em preto ou branco por linha.  O tamanho de cada quadrado √© de 8 por 8 pixels. <br><br>  Quadrados brancos no conte√∫do codificam 0, preto - 1. <br><br>  <b>Algoritmo de gera√ß√£o de conte√∫do de c√≥digo de barras</b> <br><br>  Na interse√ß√£o da primeira linha e da primeira coluna do conte√∫do, √© desenhado um quadrado que codifica o sexo do clone.  O valor da f√™mea √© codificado por zero (branco), masculino por um (preto). <br><br>  Al√©m disso, uma linha do formul√°rio &lt;id&gt; &lt;name&gt; √© formada a partir dos campos id e name.  O campo de nome √© preenchido com espa√ßos no final de at√© 26 caracteres. <br><br>  A sequ√™ncia resultante √© convertida em uma matriz de bytes - cada caractere da sequ√™ncia recebe o c√≥digo ASCII correspondente (um n√∫mero de 0 a 255). <br><br>  Em seguida, cada elemento da matriz resultante √© convertido em nota√ß√£o bin√°ria (oito caracteres 0 ou 1) e codificado por uma sequ√™ncia de oito quadrados (0 - quartzo branco, 1 - quadrado preto).  Os quadrados s√£o desenhados no conte√∫do do c√≥digo de barras sequencialmente e linha por linha. <br><br>  A √∫ltima linha de conte√∫do cont√©m informa√ß√µes de controle. <br><br>  <b>Algoritmo de contagem de informa√ß√µes de controle</b> <br><br>  Cada quadrado na linha de informa√ß√µes de controle determina a paridade da soma dos valores de conte√∫do na coluna correspondente.  Se a soma de zeros e uns na coluna for par, um quadrado branco ser√° desenhado nas informa√ß√µes de controle, caso contr√°rio, um quadrado preto. <br><br><div class="spoiler">  <b class="spoiler_title">Formato e exemplos da solu√ß√£o</b> <div class="spoiler_text">  <b>Formato da solu√ß√£o</b> <br><br>  A solu√ß√£o que voc√™ carrega deve conter a fun√ß√£o renderBarcode: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       element * @param cloneInfo {CloneInfo} ‚Äî    * @param element {HTMLDivElement} ‚Äî div    * 148x156 ,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderBarcode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cloneInfo, element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }&lt;/source lang="javascript"&gt;      Google Chrome 77. &lt;h4&gt; 1&lt;/h4&gt;   : &lt;source lang="javascript"&gt;{ "sex": "male", "id": "c5j818dyo5", "name": "Oleg Vladimirovich" }</span></span></code> </pre> <br>  C√≥digo de barras: <br><br><img src="https://habrastorage.org/webt/zm/pi/iz/zmpiiztvwzeo77-xswxzdrfhshs.png"><br><br><h4>  Exemplo 2 </h4><br>  Informa√ß√µes do Clone: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"sex"</span></span>: <span class="hljs-string"><span class="hljs-string">"female"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"0owrgqqwfw"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Dazdraperma Petrovna"</span></span> }</code> </pre> <br>  C√≥digo de barras: <br><br><img src="https://habrastorage.org/webt/9e/yk/vo/9eykvoqjupololm76rjmle7030k.png"></div></div><br><h4>  Solu√ß√£o </h4><br>  Era necess√°rio formar corretamente a representa√ß√£o bin√°ria dos dados, calcular a soma de verifica√ß√£o e desenhar esses dados no layout.  Vamos tentar fazer o mais simples e f√°cil poss√≠vel - sem otimiza√ß√µes de c√≥digo. <br><br>  Vamos come√ßar com a representa√ß√£o bin√°ria.  Primeiro, declare fun√ß√µes auxiliares: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ASCII- function charToByte(char) { return char.charCodeAt(0); } //      0  1 (      ) function byteToString(byte) { return byte.toString(2).padStart(8, '0'); }</span></span></code> </pre> <br>  Formamos a partir dos dados de origem uma string composta por zeros e uns: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataString = (cloneInfo.sex === <span class="hljs-string"><span class="hljs-string">'female'</span></span> ? <span class="hljs-string"><span class="hljs-string">'0'</span></span> : <span class="hljs-string"><span class="hljs-string">'1'</span></span>) + cloneInfo.id.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>) + cloneInfo.name.padEnd(<span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(charToByte).map(byteToString).join(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Em seguida, escreva o layout e os estilos para o nosso c√≥digo de barras: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ¬´¬ª . //  ,      DOM API   innerHTML,     . //     ,      ,      ¬´¬ª. //         ‚Äî   ,        . const contentElId = 'content-' + Math.random(); element.style.display = 'flex'; element.innerHTML = ` &lt;style&gt; .barcode { border: 3px solid black; box-sizing: border-box; } .content { margin-top: 3px; margin-left: 3px; width: 136px; height: 144px; display: flex; flex-wrap: wrap; } .content__bit { width: 8px; height: 8px; } .content__bit_one { background: black; } &lt;/style&gt; &lt;div class="content" id="${contentElId}"&gt;&lt;/div&gt; `; const contentDiv = document.getElementById(contentElId); element.className += ' barcode';</span></span></code> </pre> <br>  Renderize dados bin√°rios no layout: <br><br><pre> <code class="javascript hljs">dataString .split(<span class="hljs-string"><span class="hljs-string">''</span></span>) .forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bit</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bitDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); bitDiv.className = <span class="hljs-string"><span class="hljs-string">'content__bit content__bit_'</span></span> + (bit === <span class="hljs-string"><span class="hljs-string">'0'</span></span> ? <span class="hljs-string"><span class="hljs-string">'zero'</span></span> : <span class="hljs-string"><span class="hljs-string">'one'</span></span>); contentDiv.appendChild(bitDiv); });</code> </pre> <br>  Resta calcular e exibir a soma de verifica√ß√£o.  Isso pode ser feito assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">17</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   let sum = 0; for (let j = i; j &lt; 17 ** 2; j += 17) { sum += parseInt(dataString[j], 2); } const check = 0; const bitDiv = document.createElement('div'); //       bitDiv.className = 'content__bit content__bit_' + (sum % 2 === 0 ? 'zero' : 'one'); contentDiv.appendChild(bitDiv); }</span></span></code> </pre> <br><h2>  D. Automatize </h2>  <sup><i>Autores: Vladimir Rusov, Dmitry Kanatnikov</i></sup> <br><br>  Em cada uma das op√ß√µes de qualifica√ß√£o, havia uma tarefa em que uma p√°gina HTML com uma tabela ou lista foi proposta como entrada.  As tarefas desta s√©rie tinham uma lenda diferente, mas todas se resumiam ao fato de que voc√™ precisava trazer a p√°gina para um formato semelhante ao Markdown.  Analisaremos a solu√ß√£o para um dos problemas. <br><br><h4>  Condi√ß√£o </h4><br>  No portal estadual de presta√ß√£o de servi√ßos, eles possibilitaram enviar um pedido de documentos de forma totalmente autom√°tica, para isso, voc√™ s√≥ precisa preencher uma tabela com dados pessoais. <br><br>  Esses dados s√£o ent√£o transferidos para verifica√ß√£o a v√°rias autoridades, incluindo o Minist√©rio da Administra√ß√£o Interna.  Ap√≥s o in√≠cio dos testes, o Minist√©rio da Administra√ß√£o Interna aceita dados no formato Markdown e os Servi√ßos de Estado usam o formato HTML.  Ajude-me a escrever um script para migrar um formato para outro, para que os caras comecem o mais r√°pido poss√≠vel. <br><br>  Voc√™ precisa escrever uma fun√ß√£o que use uma tabela HTML como entrada e a converta em marca√ß√£o semelhante ao Markdown. <br><br>  Como solu√ß√£o para esta tarefa, envie o arquivo .js no qual a fun√ß√£o da solu√ß√£o √© declarada: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Formato de entrada / sa√≠da e notas</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  A tabela HTML vem como uma sequ√™ncia: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"right"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">col</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">colgroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Command <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Description <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Is implemented <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">thead</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git status<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>List all new or modified files<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>Yes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span>git diff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">th</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>Show file differences that haven't been staged<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>No<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tbody</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">table</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  A tabela pode conter tags colgroup, thead e tbody em uma ordem fixa.  Todas essas tags s√£o opcionais, mas pelo menos thead ou tbody sempre estar√£o presentes. <br><br>  - colgroup cont√©m tags col que podem ter o atributo de alinhamento opcional com um dos tr√™s valores (left | center | right) <br>  - rosca e tbody cont√™m 1 ou mais tr <br>  - tr, por sua vez, cont√©m td e th <br>  - A tabela sempre ter√° pelo menos uma linha.  - A linha sempre ter√° pelo menos uma c√©lula.  - Pelo menos um s√≠mbolo que n√£o seja espa√ßo em branco est√° sempre presente na c√©lula. <br>  - O n√∫mero de th / td elementos nas linhas sempre coincide entre todas as linhas e com o n√∫mero de elementos col no colgroup, se houver colgroup. <br>  - Espa√ßos e quebras de linha no HTML de origem podem ocorrer em qualquer lugar que n√£o viole a validade do HTML. <br><br><h4>  Formato de sa√≠da </h4><br>  A sa√≠da deve ser uma linha com marca√ß√£o Markdown: <br><br> <code>| Command | Description | **Is implemented** | <br> | ---: | :--- | :---: | <br> | **git status** | List all new or modified files | **Yes** | <br> | **git diff** | Show file differences that haven't been staged | No |</code> <br> <br>  - A primeira linha encontrada em uma tabela sempre deve se transformar em uma linha de cabe√ßalho na marca√ß√£o Markdown. <br>  - Todas as outras linhas v√£o para o corpo da tabela. <br>  - O separador de cabe√ßalho √© sempre exibido. <br>  - O conte√∫do de td √© inserido como est√°, o conte√∫do de th como ** negrito **. <br>  - Sempre h√° um espa√ßo entre o conte√∫do da c√©lula na marca√ß√£o de remarca√ß√£o e os delimitadores da c√©lula (|). <br>  - Os espa√ßos nas bordas do conte√∫do das tags td e th devem ser removidos. <br>  - Quebras de linha no conte√∫do da c√©lula devem ser exclu√≠das. <br>  - Mais de um espa√ßo em uma linha no conte√∫do das c√©lulas deve ser substitu√≠do por um espa√ßo. <br>  - Para o alinhamento nas c√©lulas das colunas da tabela Markdown, a formata√ß√£o do separador de cabe√ßalho √© respons√°vel: <br><br>  |  : --- |  significa alinhamento esquerdo <br>  |  : ---: |  significa alinhamento central <br>  |  ---: |  significa alinhamento correto <br><br>  Se n√£o houver nenhum atributo de alinhamento especificado na tag col, o alinhamento deve ser definido √† esquerda. <br><br><h4>  Anota√ß√µes </h4><br>  - Para o feed de linha, voc√™ precisa usar o caractere \ n. <br>  - A solu√ß√£o ser√° testada em um ambiente de navegador <b>(Chrome 78)</b> com acesso a objetos de documentos e janelas. <br>  - Voc√™ pode usar sintaxe at√© <b>es2018,</b> inclusive. </div></div><br><h4>  Solu√ß√£o </h4><br>  O problema √© resolvido simplesmente atravessando a √°rvore DOM da tabela.  O suporte para a √°rvore DOM √© implementado no n√≠vel do navegador, √© parte integrante da mesma, portanto n√£o haver√° problemas.  Para resolver o problema, basta converter a √°rvore DOM do HTML para a marca√ß√£o Markdown. <br><br>  Depois de examinar os exemplos, voc√™ pode ver que a convers√£o √© bastante simples.  Abaixo est√° o c√≥digo que √© o corpo da fun√ß√£o da solu√ß√£o (entrada). <br><br>  Primeiro, precisamos converter a string de HTML para a √°rvore DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = input; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = div.firstChild;</code> </pre> <br>  Depois de receber uma √°rvore DOM, podemos apenas passar por ela e processar dados de diferentes n√≥s DOM.  Para fazer isso, basta ignorar recursivamente a sequ√™ncia de filhos de v√°rios elementos DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processors = { <span class="hljs-string"><span class="hljs-string">'colgroup'</span></span>: processColgroup, <span class="hljs-string"><span class="hljs-string">'thead'</span></span>: processThead, <span class="hljs-string"><span class="hljs-string">'tbody'</span></span>: processTbody, }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> table.children) { processors[child.tagName.toLowerCase()](child); }</code> </pre> <br>  Nas tags colgroup e col, estamos interessados ‚Äã‚Äãem conhecer o alinhamento das colunas da tabela: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignments = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultAlign = <span class="hljs-string"><span class="hljs-string">'left'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processColgroup = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colgroup</span></span></span><span class="hljs-function">) =&gt;</span></span> { alignments.push(...Array(...colgroup.children).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">col</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col.align || defaultAlign; })); };</code> </pre> <br>  Nas etiquetas thead, tbody e tr, estamos interessados ‚Äã‚Äãapenas em crian√ßas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rows = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processThead = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">thead</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...thead.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTbody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tbody</span></span></span><span class="hljs-function">) =&gt;</span></span> { rows.push(...Array(...tbody.children).map(processTr)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processTr = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tr</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...tr.children).map(processCell); };</code> </pre> <br>  √â importante n√£o esquecer que, por conven√ß√£o, td e th s√£o formatados de maneira diferente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processCell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tag = cell.tagName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = clearString(cell.innerHTML); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'td'</span></span>: content, <span class="hljs-string"><span class="hljs-string">'th'</span></span>: <span class="hljs-string"><span class="hljs-string">`**</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${content}</span></span></span><span class="hljs-string">**`</span></span>, }[tag]; };</code> </pre> <br>  Para trabalhar com o conte√∫do de teste do DOM, voc√™ deve atender aos requisitos descritos na condi√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearLineBreaks = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\r?\n|\r/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearSpaces = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clearString = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> clearSpaces(clearLineBreaks(str)).trim();</code> </pre> <br>  Depois de percorrermos a √°rvore do DOM, a maior parte da nossa tabela foi gravada na matriz de linhas: <br><br> <code>[ <br> ["Command","Description","**Is implemented**"], <br> ["**git status**","List all new or modified files","**Yes**"], <br> ["**git diff**","Show file differences that haven't been staged","No"] <br> ]</code> <br> <br>  As informa√ß√µes de alinhamento da coluna estavam na matriz de alinhamentos: <br><br> <code>["right","left","center"]</code> <br> <br>  √â importante lembrar que as informa√ß√µes de alinhamento da coluna podem n√£o estar na entrada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updateAlignments = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alignments.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; alignments.push(...rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> defaultAlign)); }; updateAlignments();</code> </pre> <br>  Converta alinhamentos na forma final: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alignmentsContents = alignments.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">align</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'left'</span></span>: <span class="hljs-string"><span class="hljs-string">' :--- '</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>: <span class="hljs-string"><span class="hljs-string">' :---: '</span></span>, <span class="hljs-string"><span class="hljs-string">'right'</span></span>: <span class="hljs-string"><span class="hljs-string">' ---: '</span></span> }[align]; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delimiter = <span class="hljs-string"><span class="hljs-string">`|</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${alignmentsContents.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">|`</span></span>;</code> </pre> <br>  Exemplo de valor delimitador: <br><br> <code>"| ---: | :--- | :---: |"</code> <br> <br>  A etapa final ser√° a forma√ß√£o de uma linha de Markdown contendo todos os dados lidos do HTML: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lineEnd = <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; rows.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) markdown += lineEnd; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mdRow = <span class="hljs-string"><span class="hljs-string">`| </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${row.join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">' | '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> |`</span></span>; markdown += mdRow; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">0</span></span>) { markdown += lineEnd; markdown += delimiter; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> markdown;</code> </pre> <br>  A constru√ß√£o de retorno significa que todo o c√≥digo acima era o corpo da fun√ß√£o de solu√ß√£o (entrada).  Como resultado dessa fun√ß√£o, obtemos o c√≥digo da tabela Markdown desejado mostrado no exemplo de sa√≠da da condi√ß√£o da tarefa. <br><br><h2>  E. V√≠rus pand√™mico </h2>  <sup><i>Autores: Andrey Mokrousov, Ivan Petukhov</i></sup> <br><br>  A Organiza√ß√£o Mundial da Sa√∫de publicou um relat√≥rio sobre sinais de uma pandemia iminente de um novo v√≠rus que amea√ßa desenvolvedores front-end.  √â sabido que o v√≠rus n√£o se manifesta at√© que o host veja o c√≥digo JS contendo alguma express√£o.  Assim que a pessoa infectada v√™ essa express√£o, ela perde sua capacidade de escrever c√≥digo em JS e come√ßa a escrever espontaneamente no Fortran. <br><br>  O relat√≥rio menciona que o v√≠rus √© ativado observando o primeiro argumento da fun√ß√£o passado pelo argumento para a chamada de fun√ß√£o Zyn, ou seja, uma pessoa infectada n√£o pode mostrar uma express√£o como Zyn (fun√ß√£o (a, b, c) {console.log (a)}). <br><br>  Para n√£o perder acidentalmente todo o front-end, a AST &amp; Co decidiu verificar se o c√≥digo cont√©m a express√£o acima.  Ajude os engenheiros da empresa a fazer esse cheque. <br><br>  Sobre o c√≥digo da AST &amp; Co, sabemos que: <br><br>  - est√° escrito em ES3, <br>  - o acesso √†s propriedades de um objeto √© poss√≠vel atrav√©s de um ponto e entre colchetes (ab e a ['b']), <br>  - parte da express√£o pode ser armazenada em uma vari√°vel, mas nunca √© passada para a fun√ß√£o pelo par√¢metro (a (x) - proibido), <br>  - n√£o h√° fun√ß√µes que retornem parte da express√£o desejada, <br> ‚Äî      ,    , <br> ‚Äî             (a[x], x ‚Äî ), <br> ‚Äî         , . .      var a = x; a = y;  var a = b = 1. <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formato da solu√ß√£o </font></font></h4><br>       CommonJS-,   ,       (ast)  . <br><br>      ast-,       callback-,    Zyn      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ ... return [...]; }</code> </pre> <br><h4>  Anota√ß√µes </h4><br>         . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ). * * @param {object} ast  ast. * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]       . * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]       . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,   . * * @param {object} astNode ast-. * @param {Scope} currentScope   . * @return {Scope}      astNode. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">astNode, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//      . return currentScope; } //      . const newScope = new Scope(ast, currentScope); ast.params.forEach(param =&gt; { //     . newScope.add(param.name); }); if (isFunctionDeclaration) { //       . currentScope.add(ast.id.name); } else { //  -    . newScope.add(ast.id.name); } return newScope; } /** *    ast. * * @param {object} astNode  ast-. * @param {Scope} scope     ast-. */ function _inner(astNode, scope) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,  . */ _inner(node, scope); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast-. return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //   . _inner(astNode[key], innerScope); }); onNodeLeave(astNode, scope); } } } /** *   . * * @class Scope (name) * @param {object} astNode ast-,    . * @param {object} parentScope   . */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Set(); } Scope.prototype = { /** *      . * * @param {string} name  . */ add(name) { this._vars.add(name); }, /** *       . * * @param {string} name  . * @return {boolean}          . */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } };</span></span></code> </pre> </div></div><br><h4>  Solu√ß√£o </h4><br>    . <br><br><blockquote> ‚Äî    ES3 </blockquote> ,          . ,       . <br><br><blockquote> ‚Äî        ,     (ab  a['b']) </blockquote>       Zyn,   Z['y'].n, Zy['n']  Z['y']['n']. <br><br><blockquote>       ,        (a(x) ‚Äî ) </blockquote>         ,         . ,     : var x = Zy; xn(...). <br><br><blockquote> ‚Äî  ,     , <br> ‚Äî      ,    , <br> ‚Äî         , ..      var a = x; a = y;  var a = b = 1. </blockquote>   (       )  ,        - . <br><br><blockquote> ‚Äî     ,        (a[x], x ‚Äî ) </blockquote>          ,    : var x = 'y'; Z[x].n(...). <br><br> C    : <br> 1.   ,     ,     . <br> 2.   ,     . <br><br> ,     ,         ‚Äî          .        2. <br><br> <b> </b> <br><br>     :   Zyn(function(a, b, c){...}),  ‚Äî     . <br><br>    FunctionExpression ‚Äî      CallExpression,   callee ‚Äî MemberExpression.   property ‚Äî n,  object (  MemberExpression  object  property   y) ‚Äî Z. <br><br>        ,      ‚Äî  ‚Äî  .     ‚Äî  Identifier    ,      MemberExpression  ObjectLiteral    (xa  var x = {a: ...} ). <br><br><pre> <code class="javascript hljs">+++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-120</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">59</span></span> @@ Scope.prototype = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.has(name) || <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.isDefined(name</span></span></span><span class="hljs-function">)); } }; + +</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args = node.arguments; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length !== <span class="hljs-number"><span class="hljs-number">1</span></span> || + args[<span class="hljs-number"><span class="hljs-number">0</span></span>].type !== <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + object = callee.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + property = object.property; + object = object.object; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || + object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + checkFunction(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); + }); + + <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArg = ast.params[<span class="hljs-number"><span class="hljs-number">0</span></span>]; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!firstArg) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + + traverse(ast.body, (node, scope) =&gt; { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.name === firstArg.name) { + result.push(node); + } + }); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; +};</code> </pre> <br>    traverse ,       ,      MemberExpression  ObjectProperty. : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">60</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> * @param {object} astNode  ast- * @param {Scope} scope     ast- *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - function _inner(astNode, scope) { + function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /</span></span></span></span><span class="hljs-function"><span class="hljs-params">*    . *  , ,   *</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ - _inner(node, scope); + _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { - onNodeEnter(astNode, scope); + onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { @@ -80,10 +80,10 @@ function traverse( keys.forEach(key =&gt; { /</span></span></span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/    - _inner(astNode[key], innerScope); + _inner(astNode[key], innerScope, astNode); }); - onNodeLeave(astNode, scope); + onNodeLeave(astNode, scope, parent); } } } @@ -164,10 +164,22 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope) =&gt; { + traverse(ast.body, (node, scope, parent) =&gt; { if (node.type !== 'Identifier') { return; } + if (!parent) { + return; + } + if (parent.type === 'MemberExpression' &amp;&amp; + parent.computed === false &amp;&amp; + parent.property === node) { + return; + } + if (parent.type === 'ObjectProperty' &amp;&amp; + parent.key === node) { + return; + } if (node.name === firstArg.name) { result.push(node); }</span></span></span></span></span></span></code> </pre> </div></div><br>         .   getPropName: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-121</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">18</span></span> @@ Scope.prototype = { } }; +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; + } + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; + } +} + <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; @@ <span class="hljs-number"><span class="hljs-number">-137</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> +<span class="hljs-number"><span class="hljs-number">149</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = callee.property, + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), object = callee.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = object.property; + property = getPropName(object); object = object.object; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property.name !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> ||</code> </pre> </div></div><br>      :        .        .     1. <br><br> <b> Scope</b> <br><br>    Scope       .  ,   ,        traverse: <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span> @@ +<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); + +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { + scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); + } + + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); +} <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *   callback- onNodeEnter (  ). @@ -13,7 +22,7 @@ function traverse( onNodeEnter = (node, scope) =&gt; {}, onNodeLeave = (node, scope) =&gt; {} ) { - const rootScope = new Scope(ast); + const rootScope = getScopeFor(ast); _inner(ast, rootScope); @@ -36,19 +45,19 @@ function traverse( } //      . - const newScope = new Scope(ast, currentScope); + const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //     . - newScope.add(param.name); + newScope.add(param.name, param); }); if (isFunctionDeclaration) { //       . - currentScope.add(ast.id.name); + currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -    . - newScope.add(ast.id.name); + newScope.add(ast.id.name, ast); } return newScope; @@ -98,7 +107,7 @@ function traverse( function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; - this._vars = new Set(); + this._vars = new Map(); } Scope.prototype = { @@ -107,8 +116,24 @@ Scope.prototype = { * * @param {string} name   */</span></span> - add(name) { - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.add(name); + add(name, value) { + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.set(name, { + value: value, + scope: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + }); + }, + resolve(node) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + } + value = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent &amp;&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._parent.resolve(node</span></span></span><span class="hljs-function">)); + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; + } }, /** *       . @@ -136,6 +161,12 @@ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> = []; + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, (node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'VariableDeclarator'</span></span>) { + scope.add(node.id.name, node.init); + } + }); + traverse(ast, (node, scope) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type !== <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> Scope</b> <br><br>      .        ,     Scope    . ,   Scope   ,        : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-146</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">146</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ Scope.prototype = { } }; -<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ +<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prop = node.property; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.computed) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.name; } + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(prop); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + prop = resolved.value; + } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.type === <span class="hljs-string"><span class="hljs-string">'StringLiteral'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prop.value; } @@ <span class="hljs-number"><span class="hljs-number">-177</span></span>,<span class="hljs-number"><span class="hljs-number">22</span></span> +<span class="hljs-number"><span class="hljs-number">181</span></span>,<span class="hljs-number"><span class="hljs-number">43</span></span> @@ <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> callee = node.callee; + + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resolved = scope.resolve(callee); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + callee = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callee.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee), + <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property = getPropName(callee, scope), object = callee.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'n'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'MemberExpression'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } - property = getPropName(object); + property = getPropName(object, scope); object = object.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (property !== <span class="hljs-string"><span class="hljs-string">'y'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } + + resolved = scope.resolve(object); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolved) { + object = resolved.value; + scope = resolved.scope; + } + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.type !== <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> || object.name !== <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </div></div><br> <b> </b> <br><br>        :       .    : <br><br> ‚Äî  ,  Z ‚Äî     ,   - . <br> ‚Äî  ,         ,        . <br> ‚Äî       ,       var a = 'x', b = a. <br><br>    ,   . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs">--- a/traverse.js +++ b/traverse.js @@ <span class="hljs-number"><span class="hljs-number">-128</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span> @@ Scope.prototype = { } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vars.get(node.name); - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent) { + value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent.resolve(node); + } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { + <span class="hljs-comment"><span class="hljs-comment">//   scope,  node ‚Äî + //   . + this.add(node.name, node); + return this.resolve(node); + } + } + if (!value) { + return; + } + if (value.value.type === 'Identifier' &amp;&amp; + value.value !== node) { + return value.scope.resolve(value.value) || value; } - value = (this._parent &amp;&amp; this._parent.resolve(node)); return value; } }, @@ -165,12 +178,15 @@ function getPropName(node, scope) { module.exports = function (ast) { var result = []; + traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); + let rootScope = getScopeFor(ast); + traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; @@ -213,9 +229,10 @@ module.exports = function (ast) { } resolved = scope.resolve(object); + let zScope; if (resolved) { object = resolved.value; - scope = resolved.scope; + zScope = resolved.scope; } if (object.type !== 'Identifier' || @@ -223,6 +240,10 @@ module.exports = function (ast) { return; } + if (zScope &amp;&amp; zScope !== rootScope) { + return; + } + checkFunction(args[0]); }); @@ -232,7 +253,10 @@ module.exports = function (ast) { return; } - traverse(ast.body, (node, scope, parent) =&gt; { + traverse(ast, (node, scope, parent) =&gt; { + if (parent === ast) { + return; + } if (node.type !== 'Identifier') { return; } @@ -248,7 +272,9 @@ module.exports = function (ast) { parent.key === node) { return; } - if (node.name === firstArg.name) { + + let resolved = scope.resolve(node); + if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } });</span></span></code> </pre> </div></div><br>   : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scopeStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScopeFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, outerScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scopeStorage.has(ast)) { scopeStorage.set(ast, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scope(ast, outerScope)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scopeStorage.get(ast); } <span class="hljs-comment"><span class="hljs-comment">/** *   .     , *  callback- onNodeEnter (  ) *  onNodeLeave (  )    *     (  Scope ) * * @param {object} ast  ast * @param {Function} [onNodeEnter=(node, scope)=&gt;{}]        * @param {Function} [onNodeLeave=(node, scope)=&gt;{}]        */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ast, onNodeEnter = (node, scope</span></span></span><span class="hljs-function">) =&gt; </span></span>{}, onNodeLeave = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, scope</span></span></span><span class="hljs-function">) =&gt;</span></span> {} ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootScope = getScopeFor(ast); _inner(ast, rootScope); <span class="hljs-comment"><span class="hljs-comment">/** *    . *     scope,    * * @param {object} ast ast- * @param {Scope} currentScope    * @return {Scope}      astNode */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ast, currentScope</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFunctionExpression = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionExpression'</span></span>, isFunctionDeclaration = ast.type === <span class="hljs-string"><span class="hljs-string">'FunctionDeclaration'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFunctionExpression &amp;&amp; !isFunctionDeclaration) { <span class="hljs-comment"><span class="hljs-comment">//       return currentScope; } //       const newScope = getScopeFor(ast, currentScope); ast.params.forEach(param =&gt; { //      newScope.add(param.name, param); }); if (isFunctionDeclaration) { //        currentScope.add(ast.id.name, ast); } else if (ast.id) { //  -     newScope.add(ast.id.name, ast); } return newScope; } /** *    ast * * @param {object} astNode  ast- * @param {Scope} scope     ast- */ function _inner(astNode, scope, parent) { if (Array.isArray(astNode)) { astNode.forEach(node =&gt; { /*    . *  , ,   */ _inner(node, scope, parent); }); } else if (astNode &amp;&amp; typeof astNode === 'object') { onNodeEnter(astNode, scope, parent); const innerScope = resolveScope(astNode, scope), keys = Object.keys(astNode).filter(key =&gt; { // loc -  ,   ast- return key !== 'loc' &amp;&amp; astNode[key] &amp;&amp; typeof astNode[key] === 'object'; }); keys.forEach(key =&gt; { //    _inner(astNode[key], innerScope, astNode); }); onNodeLeave(astNode, scope, parent); } } } /** *    * * @class Scope (name) * @param {object} astNode ast-,     * @param {object} parentScope    */ function Scope(astNode, parentScope) { this._node = astNode; this._parent = parentScope; this._vars = new Map(); } Scope.prototype = { /** *       * * @param {string} name   */ add(name, value) { this._vars.set(name, { value: value, scope: this }); }, resolve(node) { if (!node) { return node; } if (node.type === 'Identifier') { let value = this._vars.get(node.name); if (!value) { if (this._parent) { value = this._parent.resolve(node); } else { //   scope,  node - //    this.add(node.name, node); return this.resolve(node); } } if (!value) { return; } if (value.value.type === 'Identifier' &amp;&amp; value.value !== node) { return value.scope.resolve(value.value) || value; } return value; } }, /** *       . * * @param {string} name   * @return {boolean}           */ isDefined(name) { return this._vars.has(name) || (this._parent &amp;&amp; this._parent.isDefined(name)); } }; function getPropName(node, scope) { let prop = node.property; if (!node.computed) { return prop.name; } let resolved = scope.resolve(prop); if (resolved) { prop = resolved.value; } if (prop.type === 'StringLiteral') { return prop.value; } } module.exports = function (ast) { var result = []; traverse(ast, (node, scope) =&gt; { if (node.type === 'VariableDeclarator') { scope.add(node.id.name, node.init); } }); let rootScope = getScopeFor(ast); traverse(ast, (node, scope) =&gt; { if (node.type !== 'CallExpression') { return; } let args = node.arguments; if (args.length !== 1 || args[0].type !== 'FunctionExpression') { return; } let callee = node.callee; let resolved = scope.resolve(callee); if (resolved) { callee = resolved.value; scope = resolved.scope; } if (callee.type !== 'MemberExpression') { return; } let property = getPropName(callee, scope), object = callee.object; if (property !== 'n') { return; } resolved = scope.resolve(object); if (resolved) { object = resolved.value; scope = resolved.scope; } if (object.type !== 'MemberExpression') { return; } property = getPropName(object, scope); object = object.object; if (property !== 'y') { return; } resolved = scope.resolve(object); let zScope; if (resolved) { object = resolved.value; zScope = resolved.scope; } if (object.type !== 'Identifier' || object.name !== 'Z') { return; } if (zScope &amp;&amp; zScope !== rootScope) { return; } checkFunction(args[0]); }); function checkFunction(ast) { let firstArg = ast.params[0]; if (!firstArg) { return; } traverse(ast, (node, scope, parent) =&gt; { if (parent === ast) { return; } if (node.type !== 'Identifier') { return; } if (!parent) { return; } if (parent.type === 'MemberExpression' &amp;&amp; parent.computed === false &amp;&amp; parent.property === node) { return; } if (parent.type === 'ObjectProperty' &amp;&amp; parent.key === node) { return; } let resolved = scope.resolve(node); if (resolved &amp;&amp; resolved.value === firstArg) { result.push(node); } }); } return result; };</span></span></code> </pre> </div></div><br><h2> F.  Framework- </h2> <sup><i>:  ,   <a href="https://habr.com/ru/users/collapsus/" class="user_link">collapsus</a></i></sup> <br><br>                  API.          ‚Äî   ,    .         . <br><br><h4>  </h4><br>     ‚Äî        .    .       ,         .     ! <br><br>         .     ,       .    ,         ,   ,    (       ).  ,        ,         0 (0 , 0 , 0 ). <br><br> ,    ,       .      JavaScript  JS-   Framework. <br><br>     : ,   .            ( ,    ).      ()   .             (  ). <br><br>         0.       ,    ( time)     . <br><br> <b>   </b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_DEGREES = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ONE_SECOND_FACTOR = <span class="hljs-number"><span class="hljs-number">1</span></span> / Framework.SPEED * ONE_SECOND_DEGREES; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Framework</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"seconds"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"red"</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"minutes"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Arrow(<span class="hljs-string"><span class="hljs-string">"hours"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buttons.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Framework.Button(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, () =&gt; { alert(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick = <span class="hljs-number"><span class="hljs-number">0</span></span>; } onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick++; arrow.rotateFactor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick % <span class="hljs-number"><span class="hljs-number">10</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : ONE_SECOND_FACTOR; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"before: "</span></span> + arrow.pos); } onAfterTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [arrow] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"after: "</span></span> + arrow.pos); } }</code> </pre> <br>     : <br> ‚Äî  ‚Äî  ,   , <br> ‚Äî      , <br> ‚Äî  ,    ;     (100 )        ;   ,      . <br><br><h4>  Solu√ß√£o </h4><br> ,      -,   ¬´   ¬ª,      .    ,    ,      ,           . <br><br>       : ,   .       . ,       ,           . <br><br>         : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre> <br>       //      . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-comment"><span class="hljs-comment">//    const ts = Math.floor(ticks / TPS); //   const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; }</span></span></code> </pre> <br>   ,          ‚Äî     rotateFactor.      getRotateFactor,     ,       ,    .     : <br> 1.   , <br> 2.  . <br><br>         .    . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-comment"><span class="hljs-comment">//        if (forward) { //      angle &lt; 0 &amp;&amp; (angle += 360); //        0  360 ( 360   0),    } else { //         Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } return angle / Framework.SPEED; }</span></span></code> </pre> <br>     ,    MAX_SPEED    .      getRotateFactor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRotateFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, target, forward = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angle = target - pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forward) { angle &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (angle += <span class="hljs-number"><span class="hljs-number">360</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(angle) &gt; <span class="hljs-number"><span class="hljs-number">180</span></span> &amp;&amp; (angle -= <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sign(angle) * <span class="hljs-number"><span class="hljs-number">360</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factor = angle / Framework.SPEED; <span class="hljs-comment"><span class="hljs-comment">//      ,    return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; }</span></span></code> </pre> <br>       : <br><br><pre> <code class="javascript hljs">buttonAHandler() { <span class="hljs-comment"><span class="hljs-comment">//     this.pos = (this.pos + 1) % this.planets.length; //      this.forward = false; }</span></span></code> </pre> <br>  ,     : <br><br><pre> <code class="javascript hljs">onBeforeTick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [sec, min, hour] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arrows; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> time = ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ticks; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> planet = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.planets[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos]; <span class="hljs-comment"><span class="hljs-comment">//        const target = getTarget(time, planet); //      sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); //       ,       !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); }</span></span></code> </pre> <br>   : <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TPS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / Framework.INTERVAL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_FACTOR = Framework.MAX_SPEED / Framework.SPEED; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ticks, planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { h, m, s } = planet; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ts = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(ticks / TPS); <span class="hljs-comment"><span class="hljs-comment">// total seconds const ss = ts % s * 360 / s; const mm = Math.floor(ts / s) % m * 360 / m; const hh = Math.floor(ts / (s * m)) % h * 360 / h; return { hh, mm, ss }; } function getRotateFactor(pos, target, forward = true) { let angle = target - pos; if (forward) { angle &lt; 0 &amp;&amp; (angle += 360); } else { Math.abs(angle) &gt; 180 &amp;&amp; (angle -= Math.sign(angle) * 360) } const factor = angle / Framework.SPEED; return Math.abs(factor) &gt; MAX_FACTOR ? Math.sign(factor) * MAX_FACTOR : factor; } class MyClock extends Clock { // planets -   // [ { h: 4, m: 20, s: 10 }, ... ] constructor({ planets, time }) { super(); this.arrows.push(new Arrow('seconds', { color: 'red' })); this.arrows.push(new Arrow('minutes', { weight: 3, length: 80 })); this.arrows.push(new Arrow('hours', { weight: 3, length: 60 })); this.buttons.push(new Button('Switch', this.buttonAHandler.bind(this))); this.planets = planets; this.ticks = time * TPS; this.pos = 0; this.forward = false; } onBeforeTick() { const [sec, min, hour] = this.arrows; const time = ++this.ticks; const planet = this.planets[this.pos]; const target = getTarget(time, planet); sec.rotateFactor = getRotateFactor(sec.pos, target.ss, this.forward); min.rotateFactor = getRotateFactor(min.pos, target.mm, this.forward); hour.rotateFactor = getRotateFactor(hour.pos, target.hh, this.forward); !sec.rotateFactor &amp;&amp; !min.rotateFactor &amp;&amp; !hour.rotateFactor &amp;&amp; (this.forward = true); } buttonAHandler() { this.pos = (this.pos + 1) % this.planets.length; this.forward = false; } }</span></span></code> </pre> </div></div><br> <b></b> <br><br>   .              .  ,  ,     ,             . <br><br>    :   ,  ,  ,   ,      (,   ,      ). <br><br>  <b>Conclus√£o</b> <br><br>    .           .     ‚Äî ,      .         . <br><br>   ,      .      ,     (   )  18 . <br><br><hr><br> : <br><br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/477452/"> ML-  </a> <br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/460139/"> -  </a> <br> ‚Äî <a href="https://habr.com/ru/company/yandex/blog/430560/"> -    </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478550/">https://habr.com/ru/post/pt478550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478536/index.html">WebRTC atrav√©s do Kurento: Experi√™ncia de Teste e Implementa√ß√£o</a></li>
<li><a href="../pt478538/index.html">Como verificar a validade do seu passaporte</a></li>
<li><a href="../pt478540/index.html">Preparativos para o d√©cimo f√≥rum ‚ÄúDias Positivos de Hack 10: Primeiros Passos‚Äù</a></li>
<li><a href="../pt478544/index.html">Vue Storefront: Importar diret√≥rio do Magento 2</a></li>
<li><a href="../pt478546/index.html">Websockets Alguma experi√™ncia em desenvolvimento e opera√ß√£o. N√≥s modificamos o cliente</a></li>
<li><a href="../pt478552/index.html">Segundo applet, fechando-o e bot√µes transparentes no Processamento 3</a></li>
<li><a href="../pt478554/index.html">Webinar "SRE - hype ou o futuro?" 12 de dezembro √†s 11:00</a></li>
<li><a href="../pt478564/index.html">Como n√≥s do TsIAN domamos terabytes de logs</a></li>
<li><a href="../pt478566/index.html">iOS Rede quando o aplicativo n√£o est√° sendo executado</a></li>
<li><a href="../pt478572/index.html">Bot em redes neurais: como um assistente virtual funciona e aprende</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>