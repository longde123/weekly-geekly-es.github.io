<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜€ï¸ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ½ ğŸ¸ Alat Pengembang Node.js Antrian pekerjaan ğŸ‘¨ğŸ¾â€ğŸš€ ğŸ§’ ğŸ‘¨ğŸ½â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika mengimplementasikan aplikasi web dan aplikasi mobile back-end, bahkan yang paling sederhana, sudah menjadi kebiasaan untuk menggunakan alat-ala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alat Pengembang Node.js Antrian pekerjaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458608/"> Ketika mengimplementasikan aplikasi web dan aplikasi mobile back-end, bahkan yang paling sederhana, sudah menjadi kebiasaan untuk menggunakan alat-alat seperti: database, server mail (smtp), server redis.  Seperangkat alat yang digunakan terus berkembang.  Misalnya, antrian pesan, dilihat dari jumlah instalasi paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amqplib</a> (650 ribu instalasi per minggu), digunakan bersama dengan basis data relasional (paket mysql 460 ribu instalasi per minggu dan pg 800 ribu instalasi per minggu). <br><br>  Hari ini saya ingin berbicara tentang antrian pekerjaan, yang sejauh ini menggunakan urutan besarnya kurang, meskipun kebutuhan mereka muncul, di hampir semua proyek nyata <br><a name="habracut"></a><br>  Jadi, antrian pekerjaan memungkinkan Anda untuk melakukan beberapa tugas secara serempak, pada kenyataannya, menjalankan fungsi dengan parameter input yang diberikan dan pada waktu yang ditentukan. <br><br>  Bergantung pada parameter, tugas dapat dilakukan: <br><br><ul><li>  segera setelah menambahkan ke antrian pekerjaan; </li><li>  sekali pada waktu yang ditentukan; </li><li>  berkali-kali sesuai jadwal. </li></ul><br>  Antrian pekerjaan memungkinkan Anda mentransfer parameter ke pekerjaan yang sedang dijalankan, melacak dan menjalankan kembali pekerjaan yang gagal, dan menetapkan batas jumlah pekerjaan yang sedang berjalan secara bersamaan. <br><br>  Sebagian besar aplikasi di Node.js dikaitkan dengan pengembangan REST-API untuk aplikasi web dan seluler.  Mengurangi waktu eksekusi REST-API penting untuk kenyamanan pengguna dengan aplikasi tersebut.  Pada saat yang sama, panggilan ke REST-API dapat memulai operasi yang panjang dan / atau intensif sumber daya.  Misalnya, setelah melakukan pembelian, Anda harus mengirim pesan push kepada pengguna ke aplikasi seluler, atau mengirim permintaan untuk melakukan pembelian di CRM REST-API.  Pertanyaan ini dapat dilakukan secara tidak sinkron.  Bagaimana melakukannya dengan benar jika Anda tidak memiliki alat untuk bekerja dengan antrian pekerjaan?  Misalnya, Anda dapat mengirim pesan ke antrian pesan, memulai pekerja yang akan membaca pesan-pesan ini dan melakukan pekerjaan yang diperlukan berdasarkan pesan-pesan ini. <br><br>  Sebenarnya, inilah yang dilakukan oleh antrian pekerjaan.  Namun, jika Anda perhatikan lebih dekat, antrian pekerjaan memiliki beberapa perbedaan mendasar dari antrian pesan.  Pertama, pesan (statis) dimasukkan ke dalam antrian pesan, dan antrian pekerjaan melibatkan beberapa jenis pekerjaan (panggilan fungsi).  Kedua, antrian pekerjaan menyiratkan adanya beberapa prosesor (pekerja) yang akan melakukan pekerjaan yang diberikan.  Dalam hal ini, fungsionalitas tambahan diperlukan.  Jumlah prosesor prosesor harus diskalakan secara transparan jika ada peningkatan beban.  Di sisi lain, perlu untuk membatasi jumlah tugas yang berjalan secara bersamaan pada satu pekerja prosesor untuk memuluskan beban puncak dan mencegah penolakan layanan.  Ini menunjukkan bahwa ada kebutuhan untuk alat yang dapat menjalankan tugas yang tidak sinkron dengan mengatur berbagai parameter, semudah membuat permintaan menggunakan REST-API (atau lebih baik jika lebih mudah). <br><br>  Menggunakan antrian pesan, relatif mudah untuk mengimplementasikan antrian pekerjaan yang berjalan segera setelah suatu pekerjaan antri.  Namun seringkali diperlukan untuk menyelesaikan tugas sekali pada waktu yang ditentukan atau sesuai dengan jadwal.  Untuk tugas-tugas ini, sejumlah paket banyak digunakan yang mengimplementasikan logika cron di linux.  Agar tidak berdasar, saya akan mengatakan bahwa paket node-cron memiliki 480 ribu instalasi per minggu, jadwal-simpul - 170 ribu instalasi per minggu. <br><br>  Menggunakan node-cron, tentu saja, lebih nyaman daripada asket setInterval (), tetapi secara pribadi, saya telah menemui sejumlah masalah saat menggunakannya.  Jika untuk menyatakan kelemahan umum, ini adalah kurangnya kontrol atas jumlah tugas yang dijalankan secara bersamaan (ini merangsang beban puncak: meningkatkan beban memperlambat pekerjaan tugas, memperlambat pekerjaan tugas meningkatkan jumlah tugas yang dijalankan secara bersamaan, yang pada gilirannya memuat sistem lebih banyak), ketidakmampuan menjalankan simpul untuk meningkatkan produktivitas -cron pada beberapa inti (dalam hal ini, semua tugas dieksekusi secara independen pada setiap inti) dan kurangnya alat untuk melacak dan memulai kembali tugas yang telah menyelesaikan  Xia dengan kesalahan. <br><br>  Saya berharap bahwa saya telah menunjukkan bahwa kebutuhan akan alat seperti antrian pekerjaan setara dengan alat-alat seperti database.  Dan dana tersebut telah muncul, meskipun belum digunakan secara luas.  Saya akan daftar yang paling populer di antara mereka: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Nama paket </th><th>  Jumlah instalasi per minggu </th><th>  Jumlah suka </th></tr><tr><td>  kue </td><td>  29190 </td><td>  8753 </td></tr><tr><td>  antrian lebah </td><td>  tidak ada informasi </td><td>  1431 </td></tr><tr><td>  agenda </td><td>  25459 </td><td>  5488 </td></tr><tr><td>  banteng </td><td>  56232 </td><td>  5909 </td></tr></tbody></table></div><br><br>  Hari ini saya akan mempertimbangkan penggunaan paket banteng, yang saya kerjakan sendiri.  Mengapa saya memilih paket khusus ini (walaupun saya tidak memaksakan pilihan saya pada orang lain).  Pada saat itu, ketika saya mulai mencari implementasi antrian pesan yang nyaman, proyek antrian lebah sudah dihentikan.  Implementasi kue, sesuai dengan tolok ukur yang diberikan dalam repositori bee-queue, tertinggal jauh di belakang implementasi lainnya dan, di samping itu, tidak mengandung sarana untuk menjalankan tugas yang dieksekusi secara berkala.  Proyek agenda mengimplementasikan antrian dengan menyimpan dalam database mongodb.  Ini adalah nilai tambah yang besar untuk beberapa kasus, jika Anda membutuhkan keandalan super saat menempatkan tugas dalam antrian.  Namun, ini bukan saja faktor penentu.  Secara alami, saya menguji semua opsi ketahanan perpustakaan, menghasilkan banyak tugas dalam antrian, dan masih tidak bisa mendapatkan pekerjaan yang tidak terputus dari agenda.  Ketika melebihi sejumlah tugas tertentu, agenda berhenti dan berhenti menjalankan tugas. <br><br>  Oleh karena itu, saya memilih bull yang mengimplementasikan API yang nyaman, dengan kecepatan dan skalabilitas yang memadai, karena paket bull menggunakan server redis sebagai backend.  Secara khusus, Anda dapat menggunakan sekelompok server redis. <br><br>  Saat membuat antrian, sangat penting untuk memilih parameter antrian pekerjaan yang optimal.  Ada banyak parameter, dan nilai beberapa dari mereka tidak langsung menjangkau saya.  Setelah banyak percobaan, saya menetapkan parameter berikut: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bull = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultJobOptions = { <span class="hljs-attr"><span class="hljs-attr">removeOnComplete</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">removeOnFail</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limiter = { <span class="hljs-attr"><span class="hljs-attr">max</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">bounceBack</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> settings = { <span class="hljs-attr"><span class="hljs-attr">lockDuration</span></span>: <span class="hljs-number"><span class="hljs-number">600000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Key expiration time for job locks. stalledInterval: 5000, // How often check for stalled jobs (use 0 for never checking). maxStalledCount: 2, // Max amount of times a stalled job will be re-processed. guardInterval: 5000, // Poll interval for delayed jobs and added jobs. retryProcessDelay: 30000, // delay before processing next job in case of internal error. drainDelay: 5, // A timeout for when the queue is in drained state (empty waiting for jobs). }; const bull = new Bull('my_queue', { redis, defaultJobOptions, settings, limiter }); module.exports = { bull };</span></span></code> </pre> <br>  Dalam kasus sepele, tidak perlu membuat banyak antrian, karena di setiap antrian Anda dapat menentukan nama untuk tugas yang berbeda, dan mengaitkan pekerja prosesor dengan masing-masing nama: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../bull'</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-news.js`</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:status'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-status.js`</span></span>); ... bull.process(<span class="hljs-string"><span class="hljs-string">'some:job'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ ... });</code> </pre><br>  Saya menggunakan kesempatan yang masuk ke bull "out of the box" - untuk memparalelkan pekerja prosesor pada beberapa core.  Untuk melakukan ini, parameter kedua menetapkan jumlah core di mana pekerja prosesor akan diluncurkan, dan pada parameter ketiga, nama file dengan definisi fungsi pemrosesan pekerjaan.  Jika fitur seperti itu tidak diperlukan, Anda dapat dengan mudah melewatkan fungsi panggilan balik sebagai parameter kedua. <br><br>  Tugas di-antri dengan panggilan ke metode add (), di mana nama dan objek antrian diteruskan dalam parameter, yang selanjutnya akan diteruskan ke penangan tugas.  Misalnya, dalam kait ORM, setelah membuat entri dengan berita baru, saya dapat secara sinkron mengirim pesan push ke semua klien: <br><br><pre> <code class="javascript hljs"> afterCreate(instance) { bull.add(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, _.pick(instance, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>), options); }</code> </pre><br>  Event handler menerima dalam parameter objek tugas dengan parameter yang diteruskan ke metode add () dan fungsi done (), yang harus dipanggil untuk mengkonfirmasi tugas selesai atau untuk menginformasikan bahwa tugas berakhir dengan kesalahan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">firebase</span></span>: { admin } } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../firebase'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { makePayload } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./makePayload'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">job, done</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { id, title, message } = job.data; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(id), <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'news'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadRu = makePayload(title.ru, message.ru, data); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadEn = makePayload(title.en, message.en, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ admin.messaging().send({ ...payloadRu, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'ru' in topics"</span></span> }), admin.messaging().send({ ...payloadEn, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'en' in topics"</span></span> }), ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> done(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, response)) .catch(done); };</code> </pre><br>  Untuk melihat status antrian pekerjaan, Anda dapat menggunakan alat arena-bull: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arena = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull-arena'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arena = Arena({ <span class="hljs-attr"><span class="hljs-attr">queues</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'my_gueue'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hostId</span></span>: <span class="hljs-string"><span class="hljs-string">'My Queue'</span></span>, redis, }, ], }, { <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">disableListen</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { arena };</code> </pre><br>  Dan akhirnya, sedikit hack hidup.  Seperti yang saya katakan, bull menggunakan server redis sebagai backend.  Ketika server redis dihidupkan ulang, kemungkinan pekerjaan menghilang sangat kecil.  Tetapi mengetahui fakta bahwa administrator sistem kadang-kadang hanya dapat "membersihkan cache lobak", sambil menghapus semua tugas khususnya, saya terutama prihatin tentang menjalankan tugas secara berkala, yang dalam hal ini berhenti selamanya.  Dalam hal ini, saya menemukan peluang untuk melanjutkan tugas-tugas berkala seperti itu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cron = <span class="hljs-string"><span class="hljs-string">'*/10 * * * * *'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/services/bull'</span></span>); bull.getRepeatableJobs() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobs</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(_.map(jobs, (job) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, cron] = job.key.split(<span class="hljs-regexp"><span class="hljs-regexp">/:{2,}/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bull.removeRepeatable(name, { cron }); }))) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } })); setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } }), <span class="hljs-number"><span class="hljs-number">60000</span></span>);</code> </pre><br>  Artinya, tugas pertama dikecualikan dari antrian, dan kemudian diatur lagi, dan semua ini (sayangnya) oleh setInterval ().  Sebenarnya, tanpa hack seumur hidup, saya mungkin tidak akan memutuskan untuk menggunakan tugas berkala pada banteng. <br><br>  apapacy@gmail.com <br>  3 Juli 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458608/">https://habr.com/ru/post/id458608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458596/index.html">Petty little joy # 6: OpenAI Gym - mainkan game dan kendalikan robot</a></li>
<li><a href="../id458598/index.html">Pengakuan sumber cahaya pada peta lingkungan</a></li>
<li><a href="../id458602/index.html">Bagaimana kami menembus Great Chinese Firewall (Bagian 1)</a></li>
<li><a href="../id458604/index.html">Mengapa dua produsen elektronik terbesar bergabung dalam proyek GPU baru</a></li>
<li><a href="../id458606/index.html">Jalankan OpenVPN di Docker dalam 2 detik</a></li>
<li><a href="../id458612/index.html">Kosmos 7 tahun</a></li>
<li><a href="../id458614/index.html">Membuat hook UsePosition () reaktif untuk mendapatkan dan melacak koordinat browser</a></li>
<li><a href="../id458622/index.html">Otomasi Untuk Yang Terkecil. Bagian satu (yang setelah nol). Virtualisasi jaringan</a></li>
<li><a href="../id458624/index.html">Bagaimana kami belajar menggambar teks di atas kanvas</a></li>
<li><a href="../id458626/index.html">StealthWatch: konsep dasar dan persyaratan minimum. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>