<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游 游뱉游낕 Pruebas o tipos? - Versi칩n oxidada 游눢 游븸 游땰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de d칤as, 0xd34df00d public칩 una traducci칩n de un art칤culo aqu칤 que describe lo que puede aprender sobre una funci칩n en diferentes idiomas,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas o tipos? - Versi칩n oxidada</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Hace un par de d칤as, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0xd34df00d</a> public칩 una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci칩n de un</a> art칤culo aqu칤 que describe lo que puede aprender sobre una funci칩n en diferentes idiomas, si la considera como un "recuadro negro" sin usar informaci칩n sobre su implementaci칩n (pero, por supuesto, sin impedir que use el compilador).  Por supuesto, la informaci칩n recibida depende mucho del idioma: se consideraron cuatro ejemplos en el art칤culo original: </p><br><ul><li>  Python: informaci칩n m칤nima de tipo din치mico, solo las pruebas dan algunas pistas; </li><li>  C - d칠bilmente est치ticamente tipado, no mucha m치s informaci칩n; </li><li>  Haskell: fuertemente tipado est치ticamente, con funciones puras, mucha m치s informaci칩n; </li><li>  Idris es un lenguaje con tipos dependientes, hay suficiente informaci칩n para demostrar la correcci칩n de la funci칩n durante la compilaci칩n. </li></ul><br><p>  "Hay C, hay Haskell, pero 쯗칩nde est치 Rust?"  - Inmediatamente se plante칩 la pregunta.  La respuesta est치 debajo del corte. </p><a name="habracut"></a><br><p>  Recordemos la condici칩n del problema: </p><br><blockquote>  Deja que se d칠 una lista y alg칰n significado.  Es necesario devolver el 칤ndice de este valor en la lista o indicar que este valor no est치 en la lista. </blockquote><p>  Para los impacientes: todas las opciones que se analizan a continuaci칩n se pueden ver en el 치rea de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juegos de Rust</a> . <br>  Vamos! </p><br><h4 id="prostoy-poisk">  B칰squeda simple </h4><br><p>  Comenzaremos con una firma casi ingenua, que, de hecho, difiere del c칩digo C solo en algunos elementos idiom치ticos: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  쯈u칠 sabemos sobre esta caracter칤stica?  Bueno ... no tanto, en realidad.  Por supuesto, tener <code>Option&lt;usize&gt;</code> en los valores de retorno es mucho mejor que lo que C nos proporcion칩, pero a칰n no tenemos informaci칩n sobre la sem치ntica de la funci칩n.  En particular, no hay garant칤a de que no habr치 efectos secundarios, ni puede haber ninguna forma de verificar el comportamiento esperado. </p><br><p>  쯇uede una prueba escrita correctamente arreglar la situaci칩n?  Buscamos: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  En general, no obtuvimos nada nuevo: todas las mismas comprobaciones que podr칤amos hacer f치cilmente con Python (y, mirando hacia el futuro, las pruebas no dar치n pr치cticamente nada en el futuro). </p><br><h4 id="use-the-generics-luke">  춰Usa los gen칠ricos, Luke! </h4><br><p>  Pero, 쯘s realmente bueno que nos veamos obligados a usar solo n칰meros con signo de 32 bits?  El desastre  Arreglamos: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Si!  Esto ya es algo.  Ahora podemos tomar rebanadas, que consisten en cualquier elemento que podamos comparar para la igualdad.  El polimorfismo expl칤cito es casi siempre mejor que impl칤cito y casi siempre mejor que ninguno, 쯨erdad? </p><br><p>  Sin embargo, dicha funci칩n puede pasar inesperadamente la siguiente prueba para nosotros: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Esto indica inmediatamente alguna falla de nuestra parte, porque de acuerdo con la especificaci칩n original, dicha llamada tendr칤a que devolver <code>Some(0)</code> .  Por supuesto, el problema aqu칤 se debe a la especificidad de los tipos con una comparaci칩n parcialmente definida en general y flotantes en particular. <br>  Supongamos ahora que queremos deshacernos de ese problema; para esto solo ajustamos los requisitos para el tipo El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ahora exigimos no solo la posibilidad de comparaci칩n para la igualdad, sino que exigimos que esta comparaci칩n sea una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">relaci칩n de equivalencia</a> .  Esto reduce un poco el rango de posibles par치metros, pero ahora tanto los tipos como las pruebas sugieren (aunque no indiquen expl칤citamente) que el comportamiento esperado realmente deber칤a caer dentro de la especificaci칩n. </p><br><div class="spoiler">  <b class="spoiler_title">Digresi칩n: 춰queremos ser M츼S gen칠ricos!</b> <div class="spoiler_text"><p>  Esta opci칩n no est치 relacionada con la tarea original, pero, en mi opini칩n, es una buena ilustraci칩n del principio: "s칠 liberal en lo que aceptes, s칠 conservador en lo que haces".  En otras palabras: si existe una oportunidad, sin perjuicio de la ergonom칤a y el rendimiento, para hacer que el tipo de valores aceptados sea m치s general, tiene sentido hacerlo. </p><br><p>  Considera esta opci칩n: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  쯈u칠 sabemos sobre esta funci칩n ahora?  Todo es igual, solo que ahora no acepta una lista o un segmento como entrada, sino un objeto arbitrario que se puede hacer para dar alternativamente enlaces a objetos de tipo El y compararlos con el buscado: un an치logo en Java, si no recuerdo mal, era ser칤a una funci칩n que toma un <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Como antes, solo m치s estricto </h4><br><p>  Sin embargo, por ejemplo, las garant칤as ofrecidas por el compilador en etapas ya conocidas no son suficientes para nosotros.  O, digamos, no queremos (por una raz칩n u otra) entrar en un mont칩n, pero queremos trabajar en la pila, lo que significa que necesitamos una matriz en lugar de un vector, pero al mismo tiempo queremos que nuestro c칩digo se generalice a diferentes tama침os de la matriz. .  O queremos que la funci칩n se optimice tanto como sea posible para cada tama침o espec칤fico de la lista de entrada. <br><br>  En resumen, necesitamos una matriz gen칠rica, y Rust ya tiene un paquete que lo proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">textualmente</a> . </p><br><p>  Ahora tenemos a nuestra disposici칩n el siguiente c칩digo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  쯈u칠 sabemos de este c칩digo?  Que la funci칩n toma una matriz de alg칰n tama침o fijo, reflejada en su tipo (y compilada independientemente para cada tama침o).  Hasta ahora, esto no cambia mucho: al final, exactamente las mismas garant칤as, no solo en la etapa de monomorfizaci칩n, sino en tiempo de ejecuci칩n, proporcionaron un corte a la versi칩n anterior. </p><br><p>  Pero podemos ir a칰n m치s lejos. </p><br><h4 id="arifmetika-urovnya-tipov">  Nivel aritm칠tico tipo </h4><br><p>  El art칤culo original mencionaba varias garant칤as que recibimos de Idris y que nadie m치s pod칤a obtener.  Uno de ellos, y quiz치s el m치s simple, porque para ello ni siquiera necesita escribir una prueba completa o una prueba completa, sino solo para especificar un poco el tipo: dice que el valor de retorno, si existe (es decir, si no es <code>Nothing</code> ), se garantiza que no exceder치 la longitud de la lista de entrada. <br><br>  Parece que la condici칩n necesaria para tal garant칤a es la presencia de tipos dependientes, bueno, o al menos alg칰n tipo de similitud, y ser칤a extra침o esperar algo as칤 de Rust, 쯨erdad? </p><br><p>  Conoce - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">typenum</a> .  Con ella, nuestra funci칩n se puede representar as칤: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "춰쯈u칠 demonios es esta magia negra ?!"  - usted pregunta  Y ciertamente tendr치 raz칩n: typenum es esa magia negra, y los intentos de usarla al menos de alguna manera sensata son doblemente. <br><br>  Sin embargo, la firma de esta funci칩n es bastante inequ칤voca. </p><br><ul><li>  La funci칩n acepta una matriz de elementos El de longitud Tama침o y un elemento de tipo El. </li><li>  La funci칩n devuelve un valor de Opci칩n que, si es Some, <br><ul><li>  Es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de rasgo</a> basado en el tipo <code>UnsignedLessThan&lt;T&gt;</code> , que acepta el tipo Size como par치metro; </li><li>  a su vez, el <code>IsLess&lt;T&gt;</code> <code>UnsignedLessThan&lt;T&gt;</code> <code>IsLess&lt;T&gt;</code> implementa para todos los tipos que implementan <code>Unsigned</code> e <code>IsLess&lt;T&gt;</code> para los cuales <code>IsLess&lt;T&gt;</code> devuelve B1, es decir  cierto </li></ul></li></ul><br><p>  En otras palabras, de esta manera escribimos una funci칩n que <em>garantiza que</em> devolver치 un n칰mero no negativo (sin signo) <em>m치s peque침o</em> que el tama침o original de la matriz (o m치s bien, por supuesto, devuelve este mismo objeto de rasgo, del que luego debemos llamar al m칠todo <code>as_usize</code> , garantizado para devolver dicho n칰mero) . </p><br><p>  Hay exactamente dos trucos en este enfoque: </p><br><ol><li>  Podemos perder notablemente el rendimiento.  Si de repente, por alguna raz칩n, nuestra funci칩n se encuentra en la parte "activa" del programa, la necesidad constante de llamadas din치micas puede ser una de las operaciones m치s lentas.  Sin embargo, este inconveniente puede no ser tan significativo como parece, pero hay un segundo: </li><li>  Para que esta funci칩n se compile correctamente, necesitaremos escribir en su interior la prueba de la correcci칩n de su trabajo o "enga침ar" al sistema de tipos de manera <code>unsafe</code> .  El primero es demasiado complicado para el art칤culo del viernes, pero el segundo es simplemente una estafa. </li></ol><br><h4 id="zaklyuchenie">  Conclusi칩n </h4><br><p>  Por supuesto, en la pr치ctica, en tales casos, se utilizar치 la segunda implementaci칩n (que recibe una porci칩n de un tipo arbitrario) o la implementaci칩n bajo un spoiler (que recibe un objeto iterable).  Es casi seguro que todos los argumentos posteriores no tienen ning칰n inter칠s pr치ctico y sirven 칰nicamente como ejercicio para trabajar con un sistema de tipos. </p><br><p>  Sin embargo, el hecho de que en el sistema de tipo Rust pueda emular una de las caracter칤sticas del sistema de tipo Idris obviamente m치s fuerte es, en mi opini칩n, bastante indicativo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468145/">https://habr.com/ru/post/468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468127/index.html">Evolution CMS 2.0 en componentes Laravel 6.0: la evoluci칩n natural de MODX Evolution</a></li>
<li><a href="../468135/index.html">Los 10 mejores informes de JPoint 2019</a></li>
<li><a href="../468139/index.html">Auriculares de nataci칩n Aftershokz Xtrainerz con sonido conducido por los huesos - Genial</a></li>
<li><a href="../468141/index.html">Tarea: extraer expresiones clave del texto en ruso. Python NLP</a></li>
<li><a href="../468143/index.html">466 terabits: el tr치fico global de Internet contin칰a creciendo, 쯣ueden los sat칠lites competir con los cables submarinos?</a></li>
<li><a href="../468147/index.html">Invitaci칩n al espect치culo de luces "Circle of Light" 2019 en Mosc칰 y un poco de informaci칩n privilegiada de uno de los sitios</a></li>
<li><a href="../468151/index.html">Vulnerabilidades de GeekBrains: 쯇or qu칠 pagar dinero por los cursos si solo puede descargarlos?</a></li>
<li><a href="../468155/index.html">Tendencias de nuevos productos</a></li>
<li><a href="../468157/index.html">La perspectiva de EcmaScript sobre la teor칤a general de OOP</a></li>
<li><a href="../468161/index.html">La codiciosa luminaria: por qu칠 la energ칤a solar no conquist칩 el mundo y c칩mo el "mineral ruso" puede salvarlo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>