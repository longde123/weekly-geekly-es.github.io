<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏿 💿 🤛🏻 Pruebas o tipos? - Versión oxidada 💣 🧑 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de días, 0xd34df00d publicó una traducción de un artículo aquí que describe lo que puede aprender sobre una función en diferentes idiomas,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas o tipos? - Versión oxidada</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Hace un par de días, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0xd34df00d</a> publicó una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducción de un</a> artículo aquí que describe lo que puede aprender sobre una función en diferentes idiomas, si la considera como un "recuadro negro" sin usar información sobre su implementación (pero, por supuesto, sin impedir que use el compilador).  Por supuesto, la información recibida depende mucho del idioma: se consideraron cuatro ejemplos en el artículo original: </p><br><ul><li>  Python: información mínima de tipo dinámico, solo las pruebas dan algunas pistas; </li><li>  C - débilmente estáticamente tipado, no mucha más información; </li><li>  Haskell: fuertemente tipado estáticamente, con funciones puras, mucha más información; </li><li>  Idris es un lenguaje con tipos dependientes, hay suficiente información para demostrar la corrección de la función durante la compilación. </li></ul><br><p>  "Hay C, hay Haskell, pero ¿dónde está Rust?"  - Inmediatamente se planteó la pregunta.  La respuesta está debajo del corte. </p><a name="habracut"></a><br><p>  Recordemos la condición del problema: </p><br><blockquote>  Deja que se dé una lista y algún significado.  Es necesario devolver el índice de este valor en la lista o indicar que este valor no está en la lista. </blockquote><p>  Para los impacientes: todas las opciones que se analizan a continuación se pueden ver en el área de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juegos de Rust</a> . <br>  Vamos! </p><br><h4 id="prostoy-poisk">  Búsqueda simple </h4><br><p>  Comenzaremos con una firma casi ingenua, que, de hecho, difiere del código C solo en algunos elementos idiomáticos: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  ¿Qué sabemos sobre esta característica?  Bueno ... no tanto, en realidad.  Por supuesto, tener <code>Option&lt;usize&gt;</code> en los valores de retorno es mucho mejor que lo que C nos proporcionó, pero aún no tenemos información sobre la semántica de la función.  En particular, no hay garantía de que no habrá efectos secundarios, ni puede haber ninguna forma de verificar el comportamiento esperado. </p><br><p>  ¿Puede una prueba escrita correctamente arreglar la situación?  Buscamos: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  En general, no obtuvimos nada nuevo: todas las mismas comprobaciones que podríamos hacer fácilmente con Python (y, mirando hacia el futuro, las pruebas no darán prácticamente nada en el futuro). </p><br><h4 id="use-the-generics-luke">  ¡Usa los genéricos, Luke! </h4><br><p>  Pero, ¿es realmente bueno que nos veamos obligados a usar solo números con signo de 32 bits?  El desastre  Arreglamos: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Si!  Esto ya es algo.  Ahora podemos tomar rebanadas, que consisten en cualquier elemento que podamos comparar para la igualdad.  El polimorfismo explícito es casi siempre mejor que implícito y casi siempre mejor que ninguno, ¿verdad? </p><br><p>  Sin embargo, dicha función puede pasar inesperadamente la siguiente prueba para nosotros: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Esto indica inmediatamente alguna falla de nuestra parte, porque de acuerdo con la especificación original, dicha llamada tendría que devolver <code>Some(0)</code> .  Por supuesto, el problema aquí se debe a la especificidad de los tipos con una comparación parcialmente definida en general y flotantes en particular. <br>  Supongamos ahora que queremos deshacernos de ese problema; para esto solo ajustamos los requisitos para el tipo El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ahora exigimos no solo la posibilidad de comparación para la igualdad, sino que exigimos que esta comparación sea una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">relación de equivalencia</a> .  Esto reduce un poco el rango de posibles parámetros, pero ahora tanto los tipos como las pruebas sugieren (aunque no indiquen explícitamente) que el comportamiento esperado realmente debería caer dentro de la especificación. </p><br><div class="spoiler">  <b class="spoiler_title">Digresión: ¡queremos ser MÁS genéricos!</b> <div class="spoiler_text"><p>  Esta opción no está relacionada con la tarea original, pero, en mi opinión, es una buena ilustración del principio: "sé liberal en lo que aceptes, sé conservador en lo que haces".  En otras palabras: si existe una oportunidad, sin perjuicio de la ergonomía y el rendimiento, para hacer que el tipo de valores aceptados sea más general, tiene sentido hacerlo. </p><br><p>  Considera esta opción: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  ¿Qué sabemos sobre esta función ahora?  Todo es igual, solo que ahora no acepta una lista o un segmento como entrada, sino un objeto arbitrario que se puede hacer para dar alternativamente enlaces a objetos de tipo El y compararlos con el buscado: un análogo en Java, si no recuerdo mal, era sería una función que toma un <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Como antes, solo más estricto </h4><br><p>  Sin embargo, por ejemplo, las garantías ofrecidas por el compilador en etapas ya conocidas no son suficientes para nosotros.  O, digamos, no queremos (por una razón u otra) entrar en un montón, pero queremos trabajar en la pila, lo que significa que necesitamos una matriz en lugar de un vector, pero al mismo tiempo queremos que nuestro código se generalice a diferentes tamaños de la matriz. .  O queremos que la función se optimice tanto como sea posible para cada tamaño específico de la lista de entrada. <br><br>  En resumen, necesitamos una matriz genérica, y Rust ya tiene un paquete que lo proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">textualmente</a> . </p><br><p>  Ahora tenemos a nuestra disposición el siguiente código: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  ¿Qué sabemos de este código?  Que la función toma una matriz de algún tamaño fijo, reflejada en su tipo (y compilada independientemente para cada tamaño).  Hasta ahora, esto no cambia mucho: al final, exactamente las mismas garantías, no solo en la etapa de monomorfización, sino en tiempo de ejecución, proporcionaron un corte a la versión anterior. </p><br><p>  Pero podemos ir aún más lejos. </p><br><h4 id="arifmetika-urovnya-tipov">  Nivel aritmético tipo </h4><br><p>  El artículo original mencionaba varias garantías que recibimos de Idris y que nadie más podía obtener.  Uno de ellos, y quizás el más simple, porque para ello ni siquiera necesita escribir una prueba completa o una prueba completa, sino solo para especificar un poco el tipo: dice que el valor de retorno, si existe (es decir, si no es <code>Nothing</code> ), se garantiza que no excederá la longitud de la lista de entrada. <br><br>  Parece que la condición necesaria para tal garantía es la presencia de tipos dependientes, bueno, o al menos algún tipo de similitud, y sería extraño esperar algo así de Rust, ¿verdad? </p><br><p>  Conoce - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">typenum</a> .  Con ella, nuestra función se puede representar así: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "¡¿Qué demonios es esta magia negra ?!"  - usted pregunta  Y ciertamente tendrá razón: typenum es esa magia negra, y los intentos de usarla al menos de alguna manera sensata son doblemente. <br><br>  Sin embargo, la firma de esta función es bastante inequívoca. </p><br><ul><li>  La función acepta una matriz de elementos El de longitud Tamaño y un elemento de tipo El. </li><li>  La función devuelve un valor de Opción que, si es Some, <br><ul><li>  Es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de rasgo</a> basado en el tipo <code>UnsignedLessThan&lt;T&gt;</code> , que acepta el tipo Size como parámetro; </li><li>  a su vez, el <code>IsLess&lt;T&gt;</code> <code>UnsignedLessThan&lt;T&gt;</code> <code>IsLess&lt;T&gt;</code> implementa para todos los tipos que implementan <code>Unsigned</code> e <code>IsLess&lt;T&gt;</code> para los cuales <code>IsLess&lt;T&gt;</code> devuelve B1, es decir  cierto </li></ul></li></ul><br><p>  En otras palabras, de esta manera escribimos una función que <em>garantiza que</em> devolverá un número no negativo (sin signo) <em>más pequeño</em> que el tamaño original de la matriz (o más bien, por supuesto, devuelve este mismo objeto de rasgo, del que luego debemos llamar al método <code>as_usize</code> , garantizado para devolver dicho número) . </p><br><p>  Hay exactamente dos trucos en este enfoque: </p><br><ol><li>  Podemos perder notablemente el rendimiento.  Si de repente, por alguna razón, nuestra función se encuentra en la parte "activa" del programa, la necesidad constante de llamadas dinámicas puede ser una de las operaciones más lentas.  Sin embargo, este inconveniente puede no ser tan significativo como parece, pero hay un segundo: </li><li>  Para que esta función se compile correctamente, necesitaremos escribir en su interior la prueba de la corrección de su trabajo o "engañar" al sistema de tipos de manera <code>unsafe</code> .  El primero es demasiado complicado para el artículo del viernes, pero el segundo es simplemente una estafa. </li></ol><br><h4 id="zaklyuchenie">  Conclusión </h4><br><p>  Por supuesto, en la práctica, en tales casos, se utilizará la segunda implementación (que recibe una porción de un tipo arbitrario) o la implementación bajo un spoiler (que recibe un objeto iterable).  Es casi seguro que todos los argumentos posteriores no tienen ningún interés práctico y sirven únicamente como ejercicio para trabajar con un sistema de tipos. </p><br><p>  Sin embargo, el hecho de que en el sistema de tipo Rust pueda emular una de las características del sistema de tipo Idris obviamente más fuerte es, en mi opinión, bastante indicativo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468145/">https://habr.com/ru/post/468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468127/index.html">Evolution CMS 2.0 en componentes Laravel 6.0: la evolución natural de MODX Evolution</a></li>
<li><a href="../468135/index.html">Los 10 mejores informes de JPoint 2019</a></li>
<li><a href="../468139/index.html">Auriculares de natación Aftershokz Xtrainerz con sonido conducido por los huesos - Genial</a></li>
<li><a href="../468141/index.html">Tarea: extraer expresiones clave del texto en ruso. Python NLP</a></li>
<li><a href="../468143/index.html">466 terabits: el tráfico global de Internet continúa creciendo, ¿pueden los satélites competir con los cables submarinos?</a></li>
<li><a href="../468147/index.html">Invitación al espectáculo de luces "Circle of Light" 2019 en Moscú y un poco de información privilegiada de uno de los sitios</a></li>
<li><a href="../468151/index.html">Vulnerabilidades de GeekBrains: ¿Por qué pagar dinero por los cursos si solo puede descargarlos?</a></li>
<li><a href="../468155/index.html">Tendencias de nuevos productos</a></li>
<li><a href="../468157/index.html">La perspectiva de EcmaScript sobre la teoría general de OOP</a></li>
<li><a href="../468161/index.html">La codiciosa luminaria: por qué la energía solar no conquistó el mundo y cómo el "mineral ruso" puede salvarlo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>