<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õèÔ∏è üò≠ üê± MVCC dans PostgreSQL-6. Le vide üôà üè¥‚Äç‚ò†Ô∏è ‚ôâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons commenc√© par des probl√®mes li√©s √† l' isolement , fait une digression sur la structure des donn√©es de bas niveau , puis discut√© des versions...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-6. Le vide</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Nous avons commenc√© par des probl√®mes li√©s √† l' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> , fait une digression sur <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la structure des donn√©es de bas niveau</a> , puis discut√© des <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versions des lignes</a> et observ√© comment <a href="https://habr.com/ru/company/postgrespro/blog/479512/">les instantan√©s de donn√©es</a> sont obtenus √† partir des versions des lignes. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">La derni√®re fois,</a> nous avons parl√© des mises √† jour HOT et de l'aspiration sur la page, et aujourd'hui nous allons proc√©der √† un <em>vulgaris sous vide</em> bien connu.  Vraiment, tant de choses ont d√©j√† √©t√© √©crites √† ce sujet que je peux √† peine ajouter quelque chose de nouveau, mais la beaut√© d'une image compl√®te n√©cessite un sacrifice.  Alors, gardez patience. <br><br><h1>  Le vide </h1><br><h2>  Que fait le vide? </h2><br>  L'aspirateur encart fonctionne rapidement, mais ne lib√®re qu'une partie de l'espace.  Il fonctionne dans une page de table et ne touche pas aux index. <br><br>  Le vide de base "normal" se fait √† l'aide de la commande VACUUM, et nous l'appellerons simplement "vacuum" (laissant "autovacuum" pour une discussion s√©par√©e). <br><br>  Le vide traite donc toute la table.  Il √©limine non seulement les tuples morts, mais aussi les r√©f√©rences √† eux de tous les index. <br><br>  L'aspiration est concurrente avec d'autres activit√©s du syst√®me.  La table et les index peuvent √™tre utilis√©s de mani√®re r√©guli√®re √† la fois pour les lectures et les mises √† jour (cependant, l'ex√©cution simultan√©e de commandes telles que CREATE INDEX, ALTER TABLE et certaines autres est impossible). <br><br>  Seules les pages du tableau sont examin√©es √† l'endroit o√π certaines activit√©s ont eu lieu.  Pour les d√©tecter, la <em>carte de visibilit√©</em> est utilis√©e (pour vous rappeler, la carte suit les pages qui contiennent de tr√®s vieux tuples, qui sont bien s√ªr visibles dans tous les instantan√©s de donn√©es).  Seules les pages trait√©es ne sont pas suivies par la carte de visibilit√© et la carte elle-m√™me est mise √† jour. <br><br>  La <em>carte de l'espace libre est</em> √©galement mise √† jour dans le processus pour refl√©ter l'espace libre suppl√©mentaire dans les pages. <br><a name="habracut"></a><br>  Comme d'habitude, cr√©ons un tableau: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Nous utilisons le param√®tre <em>autovacuum_enabled</em> pour d√©sactiver le processus autovacuum.  Nous en discuterons la prochaine fois, et maintenant il est essentiel pour nos exp√©riences que nous contr√¥lions manuellement l'aspiration. <br><br>  La table a maintenant trois tuples, chacun √©tant r√©f√©renc√© √† partir de l'index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Apr√®s avoir aspir√©, les tuples morts sont aspir√©s et il ne reste qu'un seul tuple vivant.  Et une seule r√©f√©rence reste dans l'index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Notez que les deux premiers pointeurs ont acquis le statut ¬´inutilis√©¬ª au lieu de ¬´mort¬ª, qu'ils acquerront avec un vide sur la page. <br><br><h2>  √Ä propos de l'horizon de transaction encore une fois </h2><br>  Comment PostgreSQL d√©termine-t-il quels tuples peuvent √™tre consid√©r√©s comme morts?  Nous avons d√©j√† abord√© le concept d'horizon des transactions lors de la discussion <a href="https://habr.com/ru/company/postgrespro/blog/479512/">des instantan√©s de donn√©es</a> , mais cela ne fera pas de mal de r√©p√©ter une question aussi importante. <br><br>  Reprenons l'exp√©rience pr√©c√©dente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Mais avant de mettre √† jour la ligne une fois de plus, laissez une autre transaction commencer (mais pas se terminer).  Dans cet exemple, il utilisera le niveau de lecture valid√©e, mais il doit obtenir un vrai num√©ro de transaction (non virtuel).  Par exemple, la transaction peut changer et m√™me verrouiller certaines lignes dans n'importe quelle table, pas obligatoire <code>vac</code> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Il y a maintenant trois lignes dans le tableau et trois r√©f√©rences dans l'index.  Que se passera-t-il apr√®s avoir pass√© l'aspirateur? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Deux tuples restent dans le tableau: VACUUM a d√©cid√© que le (0,2) tuple ne peut pas encore √™tre aspir√©.  La raison en est certainement dans l'horizon des transactions de la base de donn√©es, qui dans cet exemple est d√©termin√© par la transaction non termin√©e: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Nous pouvons demander √† VACUUM de signaler ce qui se passe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Notez que: <br><br><ul><li>  <code>2 nonremovable row versions</code> - deux tuples qui ne peuvent pas √™tre supprim√©s se trouvent dans le tableau. </li><li>  <code>1 dead row versions cannot be removed yet</code> - l'une d'elles est morte. </li><li>  <code>oldest xmin</code> montre l'horizon actuel. </li></ul><br>  Reprenons la conclusion: si une base de donn√©es contient des transactions de longue dur√©e (non termin√©es ou ex√©cut√©es tr√®s longtemps), cela peut entra√Æner un ballonnement de la table, quelle que soit la fr√©quence de la mise sous vide.  Par cons√©quent, les charges de travail de type OLTP et OLAP coexistent mal dans une seule base de donn√©es PostgreSQL: les rapports qui s'ex√©cutent pendant des heures ne laisseront pas les tables mises √† jour √† vide.  La cr√©ation d'une r√©plique distincte √† des fins de g√©n√©ration de rapports peut √™tre une solution possible √† ce probl√®me. <br><br>  Apr√®s l'ach√®vement d'une transaction ouverte, l'horizon se d√©place et la situation se corrige: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  D√©sormais, seule la derni√®re version en direct de la ligne reste dans la page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  L'index n'a √©galement qu'une seule ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Que se passe-t-il √† l'int√©rieur? </h2><br>  L'aspiration doit traiter la table et les index en m√™me temps et le faire pour ne pas verrouiller les autres processus.  Comment peut-il le faire? <br><br>  Tout commence par la phase d' <strong>analyse du tas</strong> (la carte de visibilit√© prise en compte, comme d√©j√† mentionn√©).  Dans les pages lues, des tuples morts sont d√©tect√©s et leurs <code>tid</code> sont enregistr√©s dans un tableau sp√©cialis√©.  Le tableau est stock√© dans la m√©moire locale du processus de vide, o√π <em>des</em> octets de m√©moire <em>maintenance_work_mem lui</em> sont allou√©s.  La valeur par d√©faut de ce param√®tre est 64 Mo.  Notez que la quantit√© totale de m√©moire est allou√©e √† la fois, plut√¥t que lorsque le besoin s'en fait sentir.  Cependant, si la table n'est pas grande, une quantit√© de m√©moire plus petite est allou√©e. <br><br>  Ensuite, nous atteignons la fin de la table ou la m√©moire allou√©e au tableau est termin√©e.  Dans les deux cas, la phase d' <strong>indexage sous vide</strong> d√©marre.  √Ä cette fin, <em>chaque</em> index cr√©√© sur la table <em>est enti√®rement analys√©</em> √† la recherche des lignes qui font r√©f√©rence aux tuples m√©moris√©s.  Les lignes trouv√©es sont aspir√©es loin des pages d'index. <br><br>  Ici, nous sommes confront√©s √† ce qui suit: les index n'ont pas d√©j√† de r√©f√©rences √† des tuples morts, tandis que la table les a toujours.  Et cela n'est contraire √† rien: lors de l'ex√©cution d'une requ√™te, nous ne frappons pas les tuples morts (avec acc√®s √† l'index) ou les rejetons lors du contr√¥le de visibilit√© (lors de l'analyse de la table). <br><br>  Apr√®s cela, la phase de mise sous <strong>vide</strong> commence.  Le tableau est √† nouveau num√©ris√© pour lire les pages appropri√©es, les aspirer des tuples m√©moris√©s et lib√©rer les pointeurs.  Nous pouvons le faire car il n'y a plus de r√©f√©rences √† partir des index. <br><br>  Si le tableau n'a pas √©t√© enti√®rement lu pendant le premier cycle, le tableau est effac√© et tout est r√©p√©t√© d'o√π nous sommes arriv√©s. <br><br>  En r√©sum√©: <br><br><ul><li>  La table est toujours scann√©e deux fois. </li><li>  Si la suppression de l'aspirateur supprime autant de tuples qu'ils ne tiennent pas tous dans la m√©moire de taille <em>maintenance_work_mem</em> , tous les index seront analys√©s autant de fois que n√©cessaire. </li></ul><br>  Pour les grandes tables, cela peut prendre beaucoup de temps et ajouter une charge de travail syst√®me importante.  Bien s√ªr, les requ√™tes ne seront pas verrouill√©es, mais des entr√©es / sorties suppl√©mentaires sont d√©finitivement ind√©sirables. <br><br>  Pour acc√©l√©rer le processus, il est judicieux d'appeler VACUUM plus souvent (afin que trop peu de tuples soient aspir√©s √† chaque fois) ou d'allouer plus de m√©moire. <br><br>  Pour noter entre parenth√®ses, √† partir de la version 11, PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">peut ignorer les analyses d'index</a> sauf si un besoin imp√©rieux se pr√©sente.  Cela doit faciliter la vie des propri√©taires de grandes tables o√π les lignes sont uniquement ajout√©es (mais pas modifi√©es). <br><br><h2>  Suivi </h2><br>  Comment pouvons-nous comprendre que VACUUM ne peut pas faire son travail en un seul cycle? <br><br>  Nous avons d√©j√† vu la premi√®re fa√ßon: d'appeler la commande VACUUM avec l'option VERBOSE.  Dans ce cas, les informations sur les phases du processus seront transmises √† la console. <br><br>  Deuxi√®mement, √† partir de la version 9.6, la vue <code>pg_stat_progress_vacuum</code> est disponible, qui fournit √©galement toutes les informations n√©cessaires. <br><br>  (La troisi√®me m√©thode est √©galement disponible: pour afficher les informations dans le journal des messages, mais cela ne fonctionne que pour le vide automatique, qui sera discut√© la prochaine fois.) <br><br>  Ins√©rons un certain nombre de lignes dans le tableau, pour que le processus de vide dure assez longtemps, et mettons-les √† jour pour que VACUUM puisse faire quelque chose. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  R√©duisons la taille de la m√©moire allou√©e au tableau d'identifiants: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Commen√ßons VACUUM et pendant qu'il fonctionne, <code>pg_stat_progress_vacuum</code> vue <code>pg_stat_progress_vacuum</code> plusieurs fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Ici, nous pouvons voir, en particulier: <br><br><ul><li>  Le nom de la phase actuelle - nous avons discut√© de trois phases principales, mais il y en a <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">plus</a> en g√©n√©ral. </li><li>  Nombre total de pages de table ( <code>heap_blks_total</code> ). </li><li>  Nombre de pages num√©ris√©es ( <code>heap_blks_scanned</code> ). </li><li>  Le nombre de pages d√©j√† aspir√©es ( <code>heap_blks_vacuumed</code> ). </li><li>  Le nombre de cycles de vide d'index ( <code>index_vacuum_count</code> ). </li></ul><br>  La progression g√©n√©rale est d√©termin√©e par le rapport de <code>heap_blks_vacuumed</code> √† <code>heap_blks_total</code> , mais nous devons tenir compte du fait que cette valeur change par incr√©ments importants plut√¥t qu'en douceur en raison de l'analyse des index.  L'attention principale, cependant, doit √™tre accord√©e au nombre de cycles de vide: un nombre sup√©rieur √† 1 signifie que la m√©moire allou√©e n'√©tait pas suffisante pour terminer l'aspiration en un cycle. <br><br>  La sortie de la commande VACUUM VERBOSE, d√©j√† termin√©e √† ce moment, affichera l'image g√©n√©rale: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Nous pouvons voir ici que trois cycles sur les index ont √©t√© effectu√©s, et dans chaque cycle, 174480 pointeurs vers des tuples morts ont √©t√© aspir√©s.  Pourquoi exactement ce nombre?  Un <code>tid</code> occupe 6 octets et 1024 * 1024/6 = 174762, qui est le nombre que nous voyons dans <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  En r√©alit√©, un peu moins peut √™tre utilis√©: cela garantit que lors de la lecture d'une page suivante, tous les pointeurs vers des tuples morts resteront bien en m√©moire. <br><br><h2>  Analyse </h2><br>  L'analyse, ou, en d'autres termes, la collecte de statistiques pour le planificateur de requ√™tes, n'a aucun lien formel avec le nettoyage.  N√©anmoins, nous pouvons effectuer l'analyse non seulement √† l'aide de la commande ANALYSER, mais combiner l'aspiration et l'analyse dans VACUUM ANALYZE.  Ici, le vide est fait d'abord, puis l'analyse, donc cela ne donne aucun gain. <br><br>  Mais comme nous le verrons plus loin, le vide automatique et l'analyse automatique sont effectu√©s en un seul processus et sont contr√¥l√©s de mani√®re similaire. <br><br><h1>  ASPIRATEUR COMPLET </h1><br>  Comme indiqu√© ci-dessus, le vide lib√®re plus d'espace que le vide sur la page, mais il ne r√©sout toujours pas enti√®rement le probl√®me. <br><br>  Si pour certaines raisons la taille d'une table ou d'un index a beaucoup augment√©, VACUUM lib√©rera de l'espace √† l'int√©rieur des pages existantes: des "trous" y appara√Ætront, qui seront ensuite utilis√©s pour l'insertion de nouveaux tuples.  Mais le nombre de pages ne changera pas, et donc, du point de vue du syst√®me d'exploitation, les fichiers occuperont exactement le m√™me espace qu'avant le vide.  Et ce n'est pas bon car: <br><br><ul><li>  L'analyse compl√®te de la table (ou de l'index) ralentit. </li><li>  Un cache tampon plus important peut √™tre n√©cessaire (car ce sont les pages qui y sont stock√©es et la densit√© des informations utiles diminue). </li><li>  Dans l'arborescence d'index, un niveau suppl√©mentaire peut se produire, ce qui ralentira l'acc√®s √† l'index. </li><li>  Les fichiers occupent un espace suppl√©mentaire sur le disque et dans les copies de sauvegarde. </li></ul><br>  (La seule exception concerne les pages enti√®rement aspir√©es, situ√©es √† la fin du fichier. Ces pages sont supprim√©es du fichier et retourn√©es au syst√®me d'exploitation.) <br><br>  Si la part des informations utiles dans les fichiers tombe en dessous d'une limite raisonnable, l'administrateur peut faire VACUUM FULL de la table.  Dans ce cas, la table et tous ses index sont reconstruits √† partir de z√©ro et les donn√©es sont compress√©es de mani√®re g√©n√©ralement compacte (bien s√ªr, le param√®tre <code>fillfactor</code> est pris en compte).  Lors de la reconstruction, PostgreSQL reconstruit d'abord la table, puis chacun de ses index un par un.  Pour chaque objet, de nouveaux fichiers sont cr√©√©s et les anciens fichiers sont supprim√©s √† la fin de la reconstruction.  Nous devons tenir compte du fait que de l'espace disque suppl√©mentaire sera n√©cessaire dans le processus. <br><br>  Pour illustrer cela, ins√©rons √† nouveau un certain nombre de lignes dans le tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Comment estimer la densit√© de l'information?  Pour ce faire, il est pratique d'utiliser une extension sp√©cialis√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  La fonction lit l'ensemble du tableau et affiche des statistiques: quelles donn√©es occupent la place dans les fichiers.  La principale information qui nous int√©resse maintenant est le champ <code>tuple_percent</code> : le pourcentage de donn√©es utiles.  Il est inf√©rieur √† 100 en raison de l'in√©vitable surcharge d'informations √† l'int√©rieur d'une page, mais reste assez √©lev√©. <br><br>  Pour l'index, des informations diff√©rentes sont sorties, mais le champ <code>avg_leaf_density</code> a la m√™me signification: le pourcentage d'informations utiles (dans les pages feuilles). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Et ce sont les tailles de la table et des index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Supprimons maintenant 90% de toutes les lignes.  Nous faisons un choix al√©atoire de lignes √† supprimer, de sorte qu'au moins une ligne est tr√®s susceptible de rester dans chaque page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Quelle taille auront les objets apr√®s VIDE? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Nous pouvons voir que la taille n'a pas chang√©: VACUUM ne peut en aucun cas r√©duire la taille des fichiers.  Et ce, bien que la densit√© de l'information ait diminu√© d'environ 10 fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Maintenant, v√©rifions ce que nous obtenons apr√®s VACUUM FULL.  Maintenant, la table et les index utilisent les fichiers suivants: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Les fichiers sont remplac√©s par de nouveaux maintenant.  Les tailles du tableau et des index ont consid√©rablement diminu√©, tandis que la densit√© de l'information a augment√© en cons√©quence: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Notez que la densit√© de l'information dans l'index est encore plus grande que celle d'origine.  Il est plus avantageux de reconstruire un index (arbre B) √† partir des donn√©es disponibles que d'ins√©rer les donn√©es dans un index existant ligne par ligne. <br><br>  Les fonctions de l'extension <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple</a> que nous avons utilis√©es lisent l'int√©gralit√© du tableau.  Mais cela n'est pas pratique si le tableau est grand, donc l'extension a la fonction <code>pgstattuple_approx</code> , qui saute les pages marqu√©es dans la carte de visibilit√© et affiche des chiffres approximatifs. <br><br>  Une autre fa√ßon, mais encore moins pr√©cise, consiste √† utiliser le catalogue syst√®me pour estimer approximativement le rapport entre la taille des donn√©es et la taille du fichier.  Vous pouvez trouver des exemples de telles requ√™tes <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">sur wiki</a> . <br><br>  VACUUM FULL n'est pas destin√© √† un usage r√©gulier car il bloque tout travail avec la table (interrogation incluse) pendant toute la dur√©e du processus.  Il est clair que pour un syst√®me tr√®s utilis√©, cela peut sembler inacceptable.  Les verrous seront discut√©s s√©par√©ment, et maintenant nous ne mentionnerons que l'extension <a href="https://github.com/reorg/pg_repack">pg_repack</a> , qui ne verrouille la table que pendant une courte p√©riode √† la fin du travail. <br><br><h2>  Commandes similaires </h2><br>  Il existe quelques commandes qui reconstruisent √©galement enti√®rement les tables et les index et ressemblent donc √† VACUUM FULL.  Tous bloquent compl√®tement tout travail avec la table, ils suppriment tous les anciens fichiers de donn√©es et en cr√©ent de nouveaux. <br><br>  La commande CLUSTER est globalement similaire √† VACUUM FULL, mais elle ordonne √©galement physiquement les tuples selon l'un des index disponibles.  Cela permet au planificateur d'utiliser l'acc√®s √† l'index plus efficacement dans certains cas.  Mais nous devons garder √† l'esprit que le clustering n'est pas maintenu: l'ordre physique des tuples sera rompu avec les modifications ult√©rieures de la table. <br><br>  La commande REINDEX reconstruit un index distinct sur la table.  VACUUM FULL et CLUSTER utilisent r√©ellement cette commande pour reconstruire les index. <br><br>  La logique de la commande TRUNCATE est similaire √† celle de DELETE - elle supprime toutes les lignes de table.  Mais DELETE, comme cela a d√©j√† √©t√© mentionn√©, ne marque que les tuples comme supprim√©s, ce qui n√©cessite un nettoyage suppl√©mentaire.  Et TRUNCATE cr√©e simplement un nouveau fichier propre √† la place.  En r√®gle g√©n√©rale, cela fonctionne plus rapidement, mais nous devons garder √† l'esprit que TRUNCATE bloquera tout travail avec la table jusqu'√† la fin de la transaction. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484106/">https://habr.com/ru/post/fr484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484092/index.html">Princes et nobles un peu habill√©s</a></li>
<li><a href="../fr484094/index.html">Cr√©ez un jeu de tir zombie √† la troisi√®me personne avec DOTS</a></li>
<li><a href="../fr484096/index.html">La bataille des deux Yakozun, ou Cassandra vs HBase. Exp√©rience de l'√©quipe Sberbank</a></li>
<li><a href="../fr484100/index.html">Utilisation de l'interface dans le SDK Google Maps pour Android</a></li>
<li><a href="../fr484102/index.html">PHP vs Python vs Ruby on Rails: comparaison d√©taill√©e</a></li>
<li><a href="../fr484108/index.html">Encapsuleur Etherblade.net et substitution d'importation pour les composants r√©seau (deuxi√®me partie)</a></li>
<li><a href="../fr484112/index.html">Est-il possible de pirater un avion</a></li>
<li><a href="../fr484114/index.html">Une s√©lection de 143 traductions de l'essai de Paul Graham (sur 184)</a></li>
<li><a href="../fr484118/index.html">32 janvier</a></li>
<li><a href="../fr484120/index.html">Les comp√©tences les plus recherch√©es du m√©tier d'ing√©nieur informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>