<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 🙋🏼 👍🏿 Memahami partisi di PostgreSQL 9 🐬 🔬 🐞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 10 dirilis kembali pada awal Oktober 2017, hampir setahun yang lalu. 

 Salah satu "fitur" baru yang paling menarik adalah partisi deklarat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami partisi di PostgreSQL 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422753/"> PostgreSQL 10 dirilis kembali pada awal Oktober 2017, hampir setahun yang lalu. <br><br>  Salah satu "fitur" baru yang paling menarik adalah partisi deklaratif tanpa syarat.  Tetapi bagaimana jika Anda tidak terburu-buru untuk meningkatkan ke 10k?  Amazon, misalnya, tidak terburu-buru, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperkenalkan dukungan PostgreSQL</a> 10 hanya pada hari-hari terakhir Februari 2018. <br><br>  Kemudian partisi tua yang baik melalui warisan datang untuk menyelamatkan.  Saya adalah arsitek perangkat lunak departemen keuangan di perusahaan taksi, jadi semua contoh akan terkait dengan perjalanan dengan satu atau lain cara (kami akan meninggalkan masalah uang untuk waktu lain). <br><br>  Sejak kami mulai menulis ulang sistem keuangan kami pada tahun 2015, ketika saya baru saja bergabung dengan perusahaan, tidak ada pembicaraan tentang partisi deklaratif.  Jadi hingga hari ini, teknik yang dijelaskan di bawah ini telah berhasil digunakan. <br><br>  Alasan asli untuk menulis artikel ini adalah bahwa sebagian besar contoh partisi di PostgreSQL yang saya temui sangat mendasar.  Ini adalah tabel, ini adalah satu kolom yang kita lihat, dan mungkin bahkan tahu sebelumnya nilai apa yang ada di dalamnya.  Tampaknya semuanya sederhana.  Tapi kehidupan nyata membuat penyesuaiannya sendiri. <br><a name="habracut"></a><br>  Dalam kasus kami, kami mempartisi tabel dalam dua kolom, yang salah satunya berisi tanggal perjalanan.  Kasus inilah yang akan kami pertimbangkan. <br><br>  Mari kita mulai dengan seperti apa tabel kita: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rides ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> bigserial <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, tenant_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ride_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, created_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, metadata jsonb <span class="hljs-comment"><span class="hljs-comment">-- Probably more columns and indexes coming here );</span></span></code> </pre> <br>  Untuk setiap penyewa, tabel berisi jutaan baris per bulan.  Untungnya, data antara penyewa tidak pernah bersinggungan, dan permintaan yang paling sulit dibuat hanya dalam satu atau dua bulan. <br><br>  Bagi mereka yang belum mempelajari cara kerja partisi PostgreSQL (beruntung dari Oracle, halo!), Saya akan menjelaskan secara singkat prosesnya. <br><br>  PostgreSQL bergantung pada dua "fitur" untuk ini: kemampuan untuk mewarisi tabel, pewarisan tabel, dan memeriksa kondisi. <br><br>  Mari kita mulai dengan warisan.  Dengan menggunakan kata kunci INHERIT, kami menunjukkan bahwa tabel yang kami buat mewarisi semua bidang tabel yang diwarisi.  Ini juga menciptakan hubungan antara dua tabel: membuat kueri dari orang tua, kami juga mendapatkan semua data dari anak-anak. <br><br>  Kondisi yang diperiksa melengkapi gambar dengan memastikan bahwa data tidak berpotongan.  Dengan demikian, pengoptimal PostgreSQL dapat memotong bagian dari tabel anak dengan mengandalkan data dari kueri. <br><br>  Perangkap pertama dari pendekatan ini akan tampak sangat jelas: permintaan apa pun harus mengandung tenant_id.  Namun demikian, jika Anda tidak selalu mengingatkan diri sendiri tentang hal ini, cepat atau lambat Anda sendiri akan menulis custom SQL di mana Anda lupa menentukan tenant_id ini.  Akibatnya, pemindaian semua partisi dan database tidak berfungsi. <br><br>  Tetapi kembali ke apa yang ingin kita capai.  Pada tingkat aplikasi, saya ingin transparansi - kami selalu menulis ke tabel yang sama, dan database sudah memilih di mana tepatnya untuk meletakkan data ini. <br><br>  Untuk melakukan ini, kami menggunakan prosedur tersimpan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> insert_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> partition_env <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>; partition_date TIMESTAMP; partition_name TEXT; sql TEXT; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- construct partition name partition_env := lower(NEW.tenant_id); partition_date := date_trunc('month', NEW.created_at AT TIME ZONE 'UTC'); partition_name := format('%s_%s_%s', TG_TABLE_NAME, partition_env, to_char(partition_date, 'YYYY_MM')); -- create partition, if necessary IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN PERFORM create_new_partition(TG_TABLE_NAME, NEW.tenant_id, partition_date, partition_name); END IF; select format('INSERT INTO %s values ($1.*)', partition_name) into sql; -- Propagate insert EXECUTE sql USING NEW; RETURN NEW; -- RETURN NULL; if no ORM END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Hal pertama yang harus Anda perhatikan adalah penggunaan TG_TABLE_NAME.  Karena ini adalah pemicu, PostgreSQL mengisi beberapa variabel untuk kita yang dapat kita akses.  Daftar lengkapnya dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini</a> . <br><br>  Dalam kasus kami, kami ingin mendapatkan nama induk dari tabel tempat pemicunya bekerja.  Dalam kasus kami, itu akan menjadi wahana.  Kami menggunakan pendekatan serupa di beberapa layanan microser, dan bagian ini dapat ditransfer secara praktis tanpa perubahan. <br><br>  <code>PERFORM</code> berguna jika kita ingin memanggil fungsi yang tidak mengembalikan apa pun.  Biasanya, dalam contoh, mereka mencoba untuk menempatkan semua logika dalam satu fungsi, tetapi kami mencoba untuk berhati-hati. <br><br>  <code>USING NEW</code> menunjukkan bahwa dalam kueri ini kami menggunakan nilai-nilai dari string yang kami coba tambahkan. <br><br>  <code>$1.*</code> akan memperluas semua nilai baris baru.  Bahkan, ini bisa diterjemahkan ke dalam <code>NEW.*</code> .  Apa yang diterjemahkan menjadi <code>NEW.ID, NEW.TENANT_ID, …</code> <br><br>  Prosedur berikut, yang kami sebut dengan <code>PERFORM</code> , akan membuat partisi baru, jika belum ada.  Ini akan terjadi satu kali per periode untuk setiap penyewa. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> create_new_partition(parent_table_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, env <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, partition_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Notifying RAISE NOTICE 'A new % partition will be created: %', parent_table_name, partition_name; select format('CREATE TABLE IF NOT EXISTS %s (CHECK ( tenant_id = ''%s'' AND created_at AT TIME ZONE ''UTC'' &gt; ''%s'' AND created_at AT TIME ZONE ''UTC'' &lt;= ''%s'')) INHERITS (%I)', partition_name, env, partition_date, partition_date + interval '1 month', parent_table_name) into sql; -- New table, inherited from a master one EXECUTE sql; PERFORM index_partition(partition_name); END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Seperti dijelaskan sebelumnya, kami menggunakan <code>INHERITS</code> untuk membuat tabel yang mirip dengan induk, dan <code>CHECK</code> untuk menentukan data apa yang harus ada di sana. <br><br>  <code>RAISE NOTICE</code> hanya mencetak string ke konsol.  Jika sekarang kita menjalankan <code>INSERT</code> dari psql, kita dapat melihat apakah partisi telah dibuat. <br><br>  Kami memiliki masalah baru.  <code>INHERITS</code> tidak mewarisi indeks.  Untuk melakukan ini, kami memiliki dua solusi: <br><br>  Buat indeks menggunakan warisan: <br>  Gunakan <code>CREATE TABLE LIKE</code> dan kemudian <code>ALTER TABLE INHERITS</code> <br><br>  Atau buat indeks secara prosedural: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_partition(partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Ensure we have all the necessary indices in this partition; EXECUTE 'CREATE INDEX IF NOT EXISTS ' || partition_name || '_tenant_timezone_idx ON ' || partition_name || ' (tenant_id, timezone(''UTC''::text, created_at))'; -- More indexes here... END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Sangat penting untuk tidak melupakan pengindeksan tabel anak, karena bahkan setelah dipartisi, masing-masing akan memiliki jutaan baris.  Indeks pada orang tua tidak diperlukan dalam kasus kami, karena orang tua akan selalu tetap kosong. <br><br>  Terakhir, kami membuat pemicu yang akan dipanggil saat baris baru dibuat: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> before_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> insert_row();</code> </pre> <br>  Ada kehalusan lain yang jarang diperhatikan.  Partisi adalah yang terbaik di kolom di mana data tidak pernah berubah.  Dalam kasus kami, ini berfungsi: perjalanan tidak pernah mengubah tenant_id dan Created_at.  Masalah yang muncul jika tidak demikian adalah PostreSQL tidak akan mengembalikan sebagian data kepada kami.  Kami kemudian berjanji kepadanya PERIKSA bahwa semua data valid. <br><br>  Ada beberapa solusi (kecuali yang sudah jelas - jangan bermutasi data yang kami partisi): <br><br>  Alih-alih <code>UPDATE</code> kami selalu melakukan <code>DELETE+INSERT</code> di tingkat aplikasi <br>  Kami menambahkan satu lagi pemicu pada <code>UPDATE</code> yang akan mentransfer data ke partisi yang benar <br><br>  Peringatan lain yang patut dipertimbangkan adalah bagaimana cara mengindeks kolom yang berisi tanggal dengan benar.  Jika kita menggunakan AT TIME ZONE dalam kueri, kita tidak boleh lupa bahwa ini sebenarnya adalah panggilan fungsi.  Dan itu berarti indeks kami harus berbasis fungsi.  Saya lupa.  Akibatnya, pangkalan mati lagi dari beban. <br><br>  Aspek terakhir yang patut dipertimbangkan adalah bagaimana partisi berinteraksi dengan berbagai kerangka kerja ORM, baik itu ActiveRecord di Ruby atau GORM in Go. <br><br>  Partisi di PostgreSQL bergantung pada fakta bahwa tabel induk akan selalu kosong.  Jika Anda tidak menggunakan ORM, Anda dapat dengan aman kembali ke prosedur tersimpan pertama, dan mengubah KEMBALI BARU;  pada KEMBALI NULL;  Maka baris dalam tabel induk tidak akan ditambahkan, yang persis seperti yang kita inginkan. <br><br>  Tetapi kenyataannya adalah bahwa sebagian besar ORM menggunakan KEMBALI klausa dengan INSERT.  Jika kami mengembalikan NULL dari pemicu kami, ORM akan panik, meyakini bahwa baris tersebut belum ditambahkan.  Ini ditambahkan, tetapi tidak di mana ORM mencari. <br><br>  Ada beberapa cara untuk mengatasi ini: <br><br><ul><li>  Jangan gunakan ORM untuk INSERT </li><li>  Patch ORM (yang terkadang disarankan dalam kasus ActiveRecord) </li><li>  Tambahkan pemicu lain, yang akan menghapus garis dari induknya. </li></ul><br>  Opsi terakhir tidak diinginkan, karena untuk setiap operasi kami akan melakukan tiga.  Namun demikian, kadang-kadang tidak dapat dihindari, karena kami akan mempertimbangkannya secara terpisah: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> delete_parent_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = NEW.ID; RETURN null; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $BODY$ LANGUAGE plpgsql;</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> after_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> delete_parent_row();</code> </pre> <br>  Hal terakhir yang perlu kita lakukan adalah menguji solusi kita.  Untuk melakukan ini, kami membuat sejumlah baris: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $script$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> year_start_epoch <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'20170101'</span></span>::timestamptz <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>); delta bigint := extract(epoch from '20171231 23:59:59'::timestamptz at time zone 'UTC') - year_start_epoch; tenant varchar; tenants varchar[] := array['tenant_a', 'tenant_b', 'tenant_c', 'tenant_d']; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> FOREACH tenant <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span> tenants <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> rides (tenant_id, created_at, ride_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (tenant, to_timestamp(random() * delta + year_start_epoch) <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $script$;</code> </pre> <br>  Dan mari kita lihat bagaimana perilaku database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tenant_id = <span class="hljs-string"><span class="hljs-string">'tenant_a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'20171102'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &lt;= <span class="hljs-string"><span class="hljs-string">'20171103'</span></span>;</code> </pre> <br>  Jika semuanya berjalan dengan baik, kita akan melihat hasil berikut: <br><br><pre> <code class="sql hljs"> Append (cost=0.00..4803.76 rows=4 width=196) -&gt; Seq Scan on rides (cost=0.00..4795.46 rows=3 width=196) Filter: (((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone) AND ((tenant_id)::text = 'tenant_a'::text)) -&gt; Index Scan using rides_tenant_a_2017_11_tenant_timezone_idx on rides_tenant_a_2017_11 (cost=0.28..8.30 rows=1 width=196) Index Cond: (((tenant_id)::text = 'tenant_a'::text) AND ((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone)) (5 rows)</code> </pre> <br>  Terlepas dari kenyataan bahwa setiap penyewa memiliki ratusan ribu baris, kami hanya memilih dari potongan data yang diinginkan.  Sukses! <br><br>  Saya harap artikel ini menarik bagi mereka yang belum mengenal apa itu partisi dan bagaimana penerapannya di PostgreSQL.  Tetapi mereka yang topik ini tidak lagi baru, tetap belajar beberapa trik menarik. <br><br>  UPD: <br>  Seperti yang diamati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">bigtrot</a> dengan benar, semua street magic ini tidak akan berfungsi jika pengaturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CONSTRAINT_EXCLUSION</a> dimatikan. <br><br>  Anda dapat memverifikasi ini menggunakan perintah <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> CONSTRAINT_EXCLUSION</code> </pre> <br><br>  Pengaturan memiliki tiga nilai: hidup, mati dan partisi <br><br>  Konfigurasi partisi lebih optimal jika Anda tiba-tiba suka menggunakan PERIKSA KENDALA tidak hanya untuk partisi, tetapi juga untuk normalisasi data. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422753/">https://habr.com/ru/post/id422753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422739/index.html">Angin dan pembangkit listrik tenaga surya di Sahara akan membantu meningkatkan iklim di padang pasir</a></li>
<li><a href="../id422743/index.html">Bagaimana otak merasakan waktu</a></li>
<li><a href="../id422745/index.html">Bintang pengetahuan yang menawan</a></li>
<li><a href="../id422747/index.html">Posisi Dukungan Enkripsi Kuat Resmi IEEE</a></li>
<li><a href="../id422751/index.html">10 alat diagnostik SSL / TLS gratis untuk webmaster</a></li>
<li><a href="../id422755/index.html">Akankah portofolio melindungi dari penurunan muka kripto?</a></li>
<li><a href="../id422757/index.html">Tidak ada politik. Bagaimana mengubah protes jalanan secara permanen menggunakan aplikasi seluler?</a></li>
<li><a href="../id422759/index.html">Peta interaktif untuk aplikasi web dalam beberapa jam</a></li>
<li><a href="../id422761/index.html">Empat cara dari Sekolah Analisis Data Yandex</a></li>
<li><a href="../id422763/index.html">Acara digital di Moskow dari 10 hingga 16 September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>