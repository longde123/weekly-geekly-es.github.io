<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 ✡️ 👏🏻 Créer un réseau privé Ethereum Geth dans des conteneurs Docker 👩🏽‍🤝‍👨🏼 🍂 👜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous devez déployer un réseau Ethereum privé basé sur Geth, cela peut être fait, par exemple, en créant des nœuds de réseau sur des serveurs physiq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créer un réseau privé Ethereum Geth dans des conteneurs Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481052/"><img src="https://habrastorage.org/webt/bg/f3/as/bgf3asaindlkt8bxyfvzbrkwjl4.jpeg"><br><br>  Si vous devez déployer un réseau Ethereum privé basé sur Geth, cela peut être fait, par exemple, en créant des nœuds de réseau sur des serveurs physiques ou des machines virtuelles.  Cependant, il est beaucoup plus facile d'utiliser des conteneurs Geth à partir du référentiel Docker Hub.  Dans ce cas, vous pouvez installer tout un réseau de nœuds, même sur une machine virtuelle ou sur un serveur physique. <br><br>  Dans cet article, nous vous expliquerons comment installer Docker sur un serveur exécutant Debian 9 (virtuel ou physique), comment créer plusieurs conteneurs avec Geth et les combiner dans un réseau privé.  Nous donnerons un exemple de script pour Node.js qui accède aux nœuds Geth qui fonctionnent dans des conteneurs. <br><a name="habracut"></a><br><h2>  Installer Docker </h2><br>  L'installation de Docker est décrite sur le site officiel.  Pour Debian 9 et 10, vous trouverez des instructions détaillées sur <a href="https://docs.docker.com/install/linux/docker-ce/debian/" rel="nofollow">https://docs.docker.com/install/linux/docker-ce/debian/</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Installer Docker</b> <div class="spoiler_text"> Tout d'abord, mettez à jour les packages: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt-get update</span></span></code> </pre> <br>  Ensuite, installez les packages nécessaires avec la commande suivante: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span></span></code> </pre> <br>  Ajoutez la clé GPG officielle: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span></span></code> </pre> <br>  Assurez-vous d'obtenir la clé avec l'empreinte digitale 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt-key fingerprint 0EBFCD88 pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid Docker Release (CE deb) docker@docker.com sub 4096R/F273FCD8 2017-02-22</span></span></code> </pre><br>  Ajoutez un référentiel Docker stable: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable"</span></span></code> </pre><br>  Mettez à jour les packages et installez Docker: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt-get update # apt-get install docker-ce docker-ce-cli containerd.io</span></span></code> </pre> <br>  Maintenant, il ne reste plus qu'à vérifier que tout est fait correctement.  Pour ce faire, exécutez l'image (Image) hello-world: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run hello-world</span></span></code> </pre> <br>  Cette commande télécharge l'image souhaitée et l'exécute pour exécution.  Comme vous vous en doutez, vous verrez le message «Bonjour de Docker!» Sur la console. <br><br>  Comme vous pouvez le voir, rien de compliqué!  Vous pouvez maintenant commencer à créer un réseau Geth privé avec des nœuds exécutés dans des conteneurs. <br></div></div><br><h2>  Créer un utilisateur, des répertoires et des fichiers </h2><br>  Créez un livre sur le serveur de l'utilisateur et les sous-répertoires suivants dans son répertoire personnel: <br><br><pre> <code class="plaintext hljs">/home/book/dock-test /home/book/dock-test/distr</code> </pre><br>  Ensuite, dans le répertoire / home / book / dock-test, créez un Dockerfile: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 1. Fichier / home / livre / dock-test / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM ubuntu:16.04 LABEL version="1.0" LABEL maintainer="alexandre@frolov.pp.ru" ENV DEBIAN_FRONTEND=noninteractive RUN apt-get update &amp;&amp; apt-get install --yes software-properties-common RUN add-apt-repository ppa:ethereum/ethereum RUN apt-get update &amp;&amp; apt-get install --yes geth RUN adduser --disabled-login --gecos "" eth_book COPY distr /home/eth_book/distr RUN chown -R eth_book:eth_book /home/eth_book/distr USER eth_book WORKDIR /home/eth_book RUN geth --nousb init distr/genesis.json ENTRYPOINT bash</code> </pre><br></div></div><br>  Ce fichier sera utilisé lors de la création de conteneurs Docker. <br><br>  Vous devrez également créer le fichier /home/book/dock-test/distr/genesis.json, nécessaire pour initialiser les nœuds du réseau Ethereum: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 2. Fichier /home/book/dock-test/distr/genesis.json</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{ "config": { "chainId": 98760, "homesteadBlock": 0, "eip150Block": 0, "eip155Block": 0, "eip158Block": 0 }, "difficulty": "10", "gasLimit": "5100000", "alloc": {} }</code> </pre> <br></div></div><br>  Ici, nous définissons l'identifiant de notre réseau privé sur 98760. Pour faciliter l'extraction, nous avons spécifié 10 dans le paramètre de difficulté, ce qui nous permettra de travailler sur des machines virtuelles avec une quantité de mémoire relativement petite (par exemple, 4 Go). <br><br><h2>  Créer un réseau et des conteneurs </h2><br>  Afin que nos nœuds échangent des données entre eux, nous allons créer un réseau entre conteneurs: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker network create PRIVATENET</span></span></code> </pre> <br>  Ensuite, vous devez créer le répertoire actuel / home / book / dock-test, dans lequel se trouve le Dockerfile.  Créez ensuite le nombre requis de conteneurs, par exemple trois: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker build -t node01 . # docker build -t node02 . # docker build -t node03 .</span></span></code> </pre> <br>  La création du premier conteneur prend un temps relativement long, car  Vous devez télécharger les images nécessaires.  Mais les conteneurs suivants sont créés presque instantanément - comparez avec la vitesse de création de machines virtuelles, même via le clonage. <br><br>  Ouvrez maintenant les quatre fenêtres de la console.  Dans trois d'entre eux, nous travaillerons avec des conteneurs et dans le quatrième, nous recevrons les données dont nous avons besoin sur les conteneurs et le réseau. <br><br>  Dans la première fenêtre de console, exécutez la commande suivante: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run --rm -it -p 8545:8545 --net=PRIVATENET node01</span></span></code> </pre> <br>  Vous verrez une invite comme: <br><br><pre> <code class="bash hljs">eth_book@304bf4f09063:~$</code> </pre> <br>  Dans les deuxième et troisième fenêtres de console, entrez les commandes suivantes, respectivement: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker run --rm -it -p 8546:8546 --net=PRIVATENET node02 # docker run --rm -it -p 8547:8547 --net=PRIVATENET node03</span></span></code> </pre><br><h2>  Création de nœuds et de comptes de réseau privé Ethereum </h2><br>  À l'heure actuelle, nous avons trois conteneurs avec Geth.  Créons dans chacun d'eux le nœud de notre réseau et compte Ethereum privé. <br><br>  Entrez la commande dans les trois premières fenêtres de console: <br><br><pre> <code class="bash hljs">$ geth account new</code> </pre> <br>  Vous devrez saisir un mot de passe.  Pour plus de simplicité, utilisez le même mot de passe sur chaque nœud pour les tests, mais notez-le quelque part.  Si vous oubliez le mot de passe, il ne fonctionnera en aucun cas pour récupérer. <br><br>  Après avoir créé les comptes sur la console, des adresses de clés publiques similaires à celles-ci apparaîtront: <br><br><pre> <code class="plaintext hljs">Public address of the key: 0xc5Df10a76Bb559332c385F8cA789C0F37dD77A54 Public address of the key: 0x0C976006a5762779bA36AC590D1D8Ebac1Ca2981 Public address of the key: 0xaB627feab4e962222a3333F3b09182dF68bB9422</code> </pre><br>  Enregistrez les adresses (vous en aurez d'autres), comme  nous en avons besoin pour exécuter les nœuds. <br><br>  Vous devez maintenant démarrer l'initialisation des nœuds.  Cela se fait à l'aide de la commande: <br><br><pre> <code class="bash hljs">$ geth --nousb init distr/genesis.json</code> </pre> <br>  Entrez cette commande dans toutes les fenêtres de console de nos conteneurs.  L'option --nousb désactive toutes les communications avec les périphériques USB. <br><br><h2>  Exécuter des nœuds Geth </h2><br>  Ouvrez maintenant tour à tour chacune des fenêtres de la console et exécutez Geth à l'aide des commandes ci-dessous. <br><br>  Première fenêtre: <br><br><pre> <code class="bash hljs">$ geth --identity=<span class="hljs-string"><span class="hljs-string">"Node01"</span></span> --etherbase <span class="hljs-string"><span class="hljs-string">"0xc5Df10a76Bb559332c385F8cA789C0F37dD77A54"</span></span> --mine --minerthreads 1 --verbosity 3 --networkid 98760 --rpc --rpcaddr 127.0.0.1 --nousb --rpcapi=<span class="hljs-string"><span class="hljs-string">"db,eth,net,web3,personal,web3"</span></span> console</code> </pre><br>  Deuxième fenêtre: <br><br><pre> <code class="bash hljs">$ geth --identity=<span class="hljs-string"><span class="hljs-string">"Node02"</span></span> --etherbase <span class="hljs-string"><span class="hljs-string">"0x0C976006a5762779bA36AC590D1D8Ebac1Ca2981"</span></span> --mine --minerthreads 1 --verbosity 3 --networkid 98760 --rpc --rpcaddr 127.0.0.1 --rpcport=8546 --nousb --rpcapi=<span class="hljs-string"><span class="hljs-string">"db,eth,net,web3,personal,web3"</span></span> console</code> </pre><br>  Troisième fenêtre: <br><br><pre> <code class="bash hljs">$ geth --identity=<span class="hljs-string"><span class="hljs-string">"Node03"</span></span> --etherbase <span class="hljs-string"><span class="hljs-string">"0xaB627feab4e962222a3333F3b09182dF68bB9422"</span></span> --mine --minerthreads 1 --verbosity 3 --networkid 98760 --rpc --rpcaddr 127.0.0.1 --rpcport=8547 --nousb --rpcapi=<span class="hljs-string"><span class="hljs-string">"db,eth,net,web3,personal,web3"</span></span> console</code> </pre> <br>  Dans chacune des fenêtres ouvertes, des messages sur la génération du DAG apparaîtront: <br><br><pre> <code class="plaintext hljs">… INFO [12-19|17:57:44.072] Generating DAG in progress epoch=0 percentage=34 elapsed=29.740s INFO [12-19|17:57:44.898] Generating DAG in progress epoch=0 percentage=35 elapsed=30.566s INFO [12-19|17:57:45.671] Generating DAG in progress epoch=0 percentage=36 elapsed=31.339s …</code> </pre><br>  Attendez que la génération soit terminée.  Après cela, eth.hashrate et eth.blockNumber seront différents de 0: <br><br><pre> <code class="plaintext hljs">&gt; eth.hashrate 4 &gt; eth.blockNumber 2</code> </pre><br>  Vous pouvez vérifier le solde du compte courant comme suit: <br><br><pre> <code class="plaintext hljs">&gt; web3.fromWei( eth.getBalance(eth.coinbase) )</code> </pre> <br>  Pour que vous ne soyez pas dérangé par les messages sur la création de nouveaux blocs et d'autres messages dans les fenêtres de console, quittez Geth avec la commande exit et redémarrez à nouveau avec le paramètre de verbosité réglé sur 1. <br><br><h2>  Nœuds de mise en réseau </h2><br>  Pour commencer, nous allons regarder la liste des conteneurs en cours d'exécution.  Exécutez la commande suivante à partir de la quatrième fenêtre de console: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fa70a5418618 node03 "/bin/sh -c bash" 2 hours ago Up 2 hours 0.0.0.0:8547-&gt;8547/tcp gifted_curran 49a028744b4b node02 "/bin/sh -c bash" 2 hours ago Up 2 hours 0.0.0.0:8546-&gt;8546/tcp reverent_wescoff 5a9ade2947eb node01 "/bin/sh -c bash" 2 hours ago Up 2 hours 0.0.0.0:8545-&gt;8545/tcp clever_ellis</span></span></code> </pre><br>  Ici, pour chaque conteneur, son identifiant, le nom de l'image, le nom du conteneur et d'autres informations sont affichés. <br><br>  Pour joindre des conteneurs à un réseau, vous aurez besoin des adresses IP des conteneurs de notre réseau privé PRIVATENET.  Vous pouvez obtenir ces adresses par ID de conteneur, par exemple, comme suit: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker inspect 5a9ade2947eb | grep IPAddress "SecondaryIPAddresses": null, "IPAddress": "", "IPAddress": "172.21.0.2",</span></span></code> </pre> <br>  Vous pouvez également utiliser la commande docker network inspect PRIVATENET: <br><br><div class="spoiler">  <b class="spoiler_title">réseau de dockers inspecter PRIVATENET</b> <div class="spoiler_text"><pre> <code class="xml hljs">[ { "Name": "PRIVATENET", "Id": "576ec7edba5b4c228740deaf7fabb5e2ba003d310086153dd7f15e2c7de0c1b2", "Created": "2019-12-20T11:52:07.90695857+03:00", "Scope": "local", "Driver": "bridge", "EnableIPv6": false, "IPAM": { "Driver": "default", "Options": {}, "Config": [ { "Subnet": "172.21.0.0/16", "Gateway": "172.21.0.1" } ] }, "Internal": false, "Attachable": false, "Ingress": false, "ConfigFrom": { "Network": "" }, "ConfigOnly": false, "Containers": { "49a028744b4b6073f6dbca23e78625bc58fc0cdacadec7cded4bb0e888c7e37b": { "Name": "reverent_wescoff", "EndpointID": "11006b596b5a46df9bf9f95a9456784795d333a3e6901b15bd2db746fd4b5513", "MacAddress": "02:42:ac:15:00:03", "IPv4Address": "172.21.0.3/16", "IPv6Address": "" }, "5a9ade2947ebd8e55594ede9763aac71f5e6529c03e762ef723adb2c592c5ccd": { "Name": "clever_ellis", "EndpointID": "41ef69a0a93b5b1de495836028bac1742c303de92ffe42a0855ed32c93c28953", "MacAddress": "02:42:ac:15:00:02", "IPv4Address": "172.21.0.2/16", "IPv6Address": "" }, "fa70a54186185de01db3647e7333bf6c71250162fafefb78dbe9998e5ac93f34": { "Name": "gifted_curran", "EndpointID": "d368c032bc0886c27ad4895d1856e4f00cf1b25ce040f3b42393dbff778c18e5", "MacAddress": "02:42:ac:15:00:04", "IPv4Address": "172.21.0.4/16", "IPv6Address": "" } }, "Options": {}, "Labels": {} } ]</code> </pre></div></div><br>  En comparant les données reçues par ces commandes, nous allons faire une liste d'adresses IP pour nos conteneurs: <br><br><pre> <code class="plaintext hljs">node01 - 172.21.0.2 node02 - 172.21.0.3 node03 - 172.21.0.4</code> </pre><br>  Bien sûr, vous aurez une liste différente, et lorsque vous redémarrez les conteneurs, ces adresses peuvent changer. <br><br>  Après avoir reçu la liste des adresses, redémarrez geth dans tous les conteneurs, en spécifiant l'adresse de votre conteneur dans le paramètre --rpcaddr.  Vous pouvez bien sûr définir l'adresse 0.0.0.0, mais c'est mauvais du point de vue de la sécurité - n'importe qui ou n'importe quoi peut se connecter au nœud.  Par exemple, il peut s'agir de robots qui tentent de "retirer" tous les fonds de ces nœuds, en attendant que le nœud soit déverrouillé. <br><br>  Pour fusionner les nœuds, vous devrez utiliser la commande admin.addPeer.  En tant que paramètre de cette commande, vous devez transmettre l'URL au format enode.  Obtenez cette URL pour chaque conteneur à l'aide de la commande admin.nodeInfo.enode: <br><br><pre> <code class="plaintext hljs">&gt; admin.nodeInfo.enode "enode://0a84e562c9b22e43269b7dca215cf2ed8c20bbf35da67bae8d5ee81b36d8bbb69e3ec704b9b6f7501059fe861843a836b2fbab641f36616cdd77365b1a522d5b@62.152.63.28:30303?discport=1350" "enode://ee49f69e25c068e006fec4a8d74370370b1d2be9715b86eddd99f97a3a5a9c692a265ab7d01fb36410d59c3f6e2b253a22f652ecbf1941eef0b3f1d30b19a535@62.152.63.28:30303?discport=1345" "enode://156d43648b47078439c7481e54f697bbf1c6b6e762029ba2969f1556ceb94e51ad03f8bd2bed35f466073165810600f52925d155f0fceef832ae86fc39a8c135@62.152.63.28:30303?discport=1348"</code> </pre><br>  Les adresses reçues sont enregistrées. <br><br>  Afin de connecter un nœud à un autre, ouvrez la fenêtre de console du premier nœud et entrez la commande suivante: <br><br><pre> <code class="plaintext hljs">&gt; admin.addPeer( "enode://0a84e562c9b22e43269b7dca215cf2ed8c20bbf35da67bae8d5ee81b36d8bbb69e3ec704b9b6f7501059fe861843a836b2fbab641f36616cdd77365b1a522d5b@172.21.0.3:30303")</code> </pre><br>  Ici, nous avons passé l'adresse URL, en y indiquant l'adresse IP de l'hôte connecté.  Suivez la même procédure sur les autres nœuds du réseau. <br><br>  Pour vérifier que la connexion est établie, utilisez la commande admin.peers.  S'il n'y a pas de connexions, la commande retournera un résultat vide: <br><br><pre> <code class="xml hljs">&gt; admin.peers []</code> </pre><br>  Dans notre cas, la commande montre que le premier nœud avec l'adresse 172.21.0.2 est connecté aux nœuds avec les adresses 172.21.0.3 et 172.21.0.4: <br><br><div class="spoiler">  <b class="spoiler_title">Voir le résultat quand il y a des connexions</b> <div class="spoiler_text"><pre> <code class="xml hljs">&gt; admin.peers [{ caps: ["eth/63", "eth/64"], enode: "enode://156d43648b47078439c7481e54f697bbf1c6b6e762029ba2969f1556ceb94e51ad03f8bd2bed35f466073165810600f52925d155f0fceef832ae86fc39a8c135@172.21.0.4:30303", id: "4dac1d10cb6ae8bfc1fdebd3f5334b24ee62ec38a50bc92c89104cfc3251b5fc", name: "Geth/Node03/v1.9.9-stable-01744997/linux-amd64/go1.13.4", network: { inbound: false, localAddress: "172.21.0.2:40652", remoteAddress: "172.21.0.4:30303", static: true, trusted: false }, protocols: { eth: { difficulty: 98414119, head: "0x6b31a5bb9cde06fab5a8cc1ae9b18bada30de0d1b76cb3286c1081e76dbf5b83", version: 64 } } }, { caps: ["eth/63", "eth/64"], enode: "enode://ee49f69e25c068e006fec4a8d74370370b1d2be9715b86eddd99f97a3a5a9c692a265ab7d01fb36410d59c3f6e2b253a22f652ecbf1941eef0b3f1d30b19a535@172.21.0.3:30303", id: "b74277d278c15317fa7f7fa492daca60492ea22053bfc53281dd0071eba1c16b", name: "Geth/Node02/v1.9.9-stable-01744997/linux-amd64/go1.13.4", network: { inbound: false, localAddress: "172.21.0.2:42576", remoteAddress: "172.21.0.3:30303", static: true, trusted: false }, protocols: { eth: { difficulty: 99041423, head: "0x0ec44735bbb425cb8db96103f52300dfaae1147ba0e03aa4892d041250ce4408", version: 64 } } }]</code> </pre></div></div><br>  Veuillez noter qu'après la combinaison et la synchronisation réussies des nœuds, la commande eth.blockNumber retournera la même valeur lorsqu'elle sera lancée dans l'un de nos trois conteneurs. <br><br>  La commande web3.fromWei (eth.getBalance (eth.coinbase)), au contraire, affichera un équilibre différent sur différents nœuds, car  chaque nœud a son propre compte. <br><br><h2>  Travailler avec des hôtes à l'aide de Node.js </h2><br>  Dans le Listing 3, nous avons présenté un script simple exécutant Node.js qui affiche sur la console une liste de comptes pour le nœud spécifié et le solde de chacun d'eux: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Fichier / home / book / list_accounts.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Web3 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'web3'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> web3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Web3(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Web3.providers.HttpProvider(<span class="hljs-string"><span class="hljs-string">"http://172.21.0.2:8545"</span></span>)); web3.eth.getAccounts() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accList</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accList; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> balancePromeses = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; accounts.length; i++) { balancePromeses[i] = web3.eth.getBalance(accounts[i]); } <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(balancePromeses).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; values.length; i++) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Account: '</span></span>, accounts[i], <span class="hljs-string"><span class="hljs-string">'balance: '</span></span>, values[i], <span class="hljs-string"><span class="hljs-string">'wei, '</span></span>, web3.utils.fromWei(values[i], <span class="hljs-string"><span class="hljs-string">'ether'</span></span>), <span class="hljs-string"><span class="hljs-string">'ether'</span></span>); } }); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); });</code> </pre> <br></div></div><br>  Vous pouvez exécuter ce script dans une fenêtre distincte, par exemple, dans la quatrième fenêtre de console: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># node list_accounts.js Account: 0x0C976006a5762779bA36AC590D1D8Ebac1Ca2981 balance: 3350000000000000000000 wei, 3350 ether</span></span></code> </pre><br><h2>  Et ensuite </h2><br>  Le sujet du développement de logiciels pour les crypto-monnaies en général et pour Ethereum en particulier est assez fascinant.  Si après avoir lu cet article, vous avez des questions et souhaitez en savoir plus, lisez mon livre <a href="https://habr.com/ru/post/467347/">«Création de contrats intelligents Solidity pour la blockchain Ethereum.</a>  <a href="https://habr.com/ru/post/467347/">Guide pratique »</a> , qui a été publié par <a href="https://www.litres.ru/aleksandr-frolov-198/sozdanie-smart-kontraktov-solidity-dlya-blokcheyna-et/" rel="nofollow">Liters</a> Publishing House. <br><br>  Vous pourriez également avoir besoin d'une bonne <a href="https://habr.com/ru/company/flant/blog/336654/">feuille de triche Docker</a> . <br><br>  Je serais reconnaissant pour tout commentaire et ajouts à l'article et au livre! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481052/">https://habr.com/ru/post/fr481052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481036/index.html">30 utilitaires pour les outils de développement Firefox</a></li>
<li><a href="../fr481038/index.html">Confession d'un accro au design. Comment nous avons fait le jeu "IT Alchemy" en un mois</a></li>
<li><a href="../fr481042/index.html">Le goût de Django nous excite et attire</a></li>
<li><a href="../fr481044/index.html">Que présenter pour 2020: le guide du Nouvel An Madrobots</a></li>
<li><a href="../fr481048/index.html">Reconnaissance des circuits numériques. Élément C généralisé</a></li>
<li><a href="../fr481054/index.html">YouTrack 2019.3: liste des tâches mise à jour et bien plus</a></li>
<li><a href="../fr481056/index.html">Les principales technologies de la décennie selon Habr</a></li>
<li><a href="../fr481058/index.html">A la question de l'étrange (encore) et du choix des transistors</a></li>
<li><a href="../fr481066/index.html">Utilisation de l'oeil de poisson sur le Raspberry Pi 3: lancement de modèles DL pré-formés pour la vision par ordinateur</a></li>
<li><a href="../fr481070/index.html">Version Rust 1.40.0: # [non_exhaustive], améliorations de macro et autres améliorations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>