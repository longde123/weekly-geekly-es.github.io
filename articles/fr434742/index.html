<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèø ‚ôíÔ∏è üèø Partie 2: Utilisation des contr√¥leurs UDB PSoC de Cypress pour r√©duire le nombre d'interruptions dans une imprimante 3D üåç ü§∂ üå±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La derni√®re fois, nous avons envisag√© la possibilit√© de g√©n√©rer des impulsions pour les moteurs pas √† pas, partiellement supprim√©es du logiciel au niv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partie 2: Utilisation des contr√¥leurs UDB PSoC de Cypress pour r√©duire le nombre d'interruptions dans une imprimante 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434742/"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons envisag√© la possibilit√© de g√©n√©rer des impulsions pour les moteurs pas √† pas, partiellement supprim√©es du logiciel au niveau du firmware.  En cas de succ√®s complet, cela promet l'absence de la n√©cessit√© de traiter les interruptions arrivant avec une fr√©quence allant jusqu'√† 40 KHz.  Mais cette option pr√©sente un certain nombre de d√©fauts √©vidents.  Premi√®rement, les acc√©l√©rations n'y sont pas prises en charge.  Deuxi√®mement, la granularit√© des fr√©quences de pas admissibles dans cette solution est de centaines de hertz (par exemple, il est possible de g√©n√©rer des fr√©quences de 40000 Hz et 39966 Hz, mais il est impossible de g√©n√©rer des fr√©quences d'une amplitude comprise entre ces deux valeurs). <br><a name="habracut"></a><br><h2>  Mise en ≈ìuvre de l'acc√©l√©ration </h2><br>  Est-il possible d'√©liminer les inconv√©nients indiqu√©s en utilisant les m√™mes outils UDB sans compliquer le syst√®me?  Faisons les choses correctement.  Commen√ßons par les plus difficiles - avec les acc√©l√©rations.  Des acc√©l√©rations sont ajout√©es au d√©but et √† la fin du chemin.  Premi√®rement, si des impulsions haute fr√©quence sont appliqu√©es imm√©diatement au moteur pas √† pas, il faudra un courant plus important pour d√©marrer le fonctionnement.  Le courant admissible √©lev√© est le chauffage et le bruit, il est donc pr√©f√©rable de le limiter.  Mais alors le moteur peut sauter des √©tapes au d√©marrage.  Il vaut donc mieux acc√©l√©rer le moteur en douceur.  Deuxi√®mement, si une t√™te lourde s'arr√™te brusquement, elle subit des transitoires associ√©s √† l'inertie.  Les vagues sont visibles sur du plastique.  Par cons√©quent, il est n√©cessaire non seulement de se disperser, mais √©galement d'arr√™ter la t√™te.  Classiquement, un graphique du r√©gime moteur est pr√©sent√© sous la forme d'un trap√®ze.  Voici un fragment du code source du firmware Marlin: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png"><br><br>  Je n'essaierai m√™me pas de comprendre s'il est possible de l'impl√©menter en utilisant UDB.  Cela est d√ª au fait qu'un autre type d'acc√©l√©ration est d√©sormais √† la mode: non pas trap√©zo√Ødal, mais S-Curve.  Leur calendrier ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  Ce n'est certainement pas pour UDB.  Abandonner?  Pas du tout!  J'ai d√©j√† not√© que UDB n'impl√©mente pas d'interface mat√©rielle, mais vous permet simplement de transf√©rer une partie du code du logiciel au niveau du firmware.  Laissez le profil calculer le processeur central, et la formation d'impulsions de pas effectue toujours l'UDB.  Le processeur central a beaucoup de temps pour les calculs.  La t√¢che d'√©liminer les interruptions fr√©quentes continuera d'√™tre r√©solue avec √©l√©gance, et personne ne pr√©voyait d'amener compl√®tement le processus au niveau du micrologiciel. <br><br>  Bien s√ªr, le profil devra √™tre pr√©par√© en m√©moire et UDB r√©cup√©rera les donn√©es √† partir de l√† en utilisant DMA.  Mais combien de m√©moire est requise?  Un millim√®tre n√©cessite 200 pas.  D√©sormais, avec un codage 24 bits, cela repr√©sente 600 octets par 1 mm de mouvement de t√™te!  Encore une fois, rappelez-vous des interruptions pas si fr√©quentes, mais toujours constantes pour tout transmettre en fragments?  Pas vraiment!  Le fait est que le m√©canisme DMA de PSoC est bas√© sur des descripteurs.  Apr√®s avoir ex√©cut√© la t√¢che √† partir d'un descripteur, le contr√¥leur DMA passe au suivant.  Et donc, le long de la cha√Æne, vous pouvez utiliser beaucoup de descripteurs.  Nous illustrons cela avec quelques dessins de la documentation officielle: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  En fait, ce m√©canisme peut √©galement √™tre utilis√© en construisant une cha√Æne de trois descripteurs: <br><br><table><tbody><tr><th>  Non. </th><th>  Explication </th></tr><tr><td>  1 </td><td>  De la m√©moire au FIFO avec incr√©ment d'adresse.  Indique une section avec un profil d'acc√©l√©ration. </td></tr><tr><td>  2 </td><td>  De la m√©moire au FIFO sans incr√©ment d'adresse.  Envoie tout le temps au m√™me mot en m√©moire pour une vitesse constante. </td></tr><tr><td>  3 </td><td>  De la m√©moire au FIFO avec incr√©ment d'adresse.  Indique une section avec un profil de freinage. <br></td></tr></tbody></table><br>  Il s'av√®re que le chemin principal est d√©crit √† l'√©tape 2 et que le m√™me mot est physiquement utilis√©, ce qui d√©finit la vitesse constante.  La consommation de m√©moire n'est pas importante.  En r√©alit√©, le deuxi√®me descripteur peut √™tre physiquement repr√©sent√© par deux ou trois descripteurs.  Cela est d√ª au fait que la longueur maximale de pompage, selon TRM, peut √™tre de 64 kilo-octets (la modification sera plus faible).  Soit 32 767 mots.  Celui √† 200 pas par millim√®tre correspondra √† un trajet de 163 millim√®tres.  Vous devrez peut-√™tre faire un segment de deux ou trois parties, selon la distance maximale que le moteur peut parcourir √† la fois. <br><br>  N√©anmoins, pour √©conomiser de la m√©moire (et aux d√©pens des blocs UDB), je propose d'abandonner les blocs DatapPath 24 bits pour passer √† des blocs 16 bits plus √©conomiques. <br><br>  <b>Alors.</b>  <b>La premi√®re proposition de r√©vision.</b> <b><br><br></b>  <b>Les tableaux sont pr√©par√©s en m√©moire qui codent la dur√©e des √©tapes.</b>  <b>De plus, ces informations sont transmises √† l'UDB via DMA.</b>  <b>La section rectiligne est cod√©e par un tableau d'un √©l√©ment, le bloc DMA n'augmente pas l'adresse, choisissant le m√™me √©l√©ment tout le temps.</b>  <b>Les sections d'acc√©l√©ration, rectilignes et de freinage sont connect√©es par les moyens disponibles dans le contr√¥leur DMA.</b> <br><br><h2>  R√©glage fin des m√©diums </h2><br>  Nous allons maintenant examiner comment surmonter le probl√®me de la granularit√© de fr√©quence.  Bien s√ªr, il ne sera pas possible de le d√©finir exactement.  Mais, en fait, le "firmware" d'origine ne peut pas non plus le faire.  Au lieu de cela, ils utilisent l'algorithme de Bresenham.  Un d√©lai d'une mesure est ajout√© √† certaines √©tapes.  En cons√©quence, la fr√©quence moyenne devient interm√©diaire, entre une valeur plus petite et une valeur plus grande.  En ajustant le rapport des p√©riodes r√©guli√®res et prolong√©es, vous pouvez modifier en douceur la fr√©quence moyenne.  Si notre vitesse n'est plus d√©finie via le registre de donn√©es, mais transmise via FIFO, et que le nombre d'impulsions est g√©n√©ralement d√©fini par le nombre de mots transmis via DMA, les deux registres de donn√©es dans UDB sont lib√©r√©s.  De plus, l'une des batteries, qui compte le nombre d'impulsions, est √©galement lib√©r√©e.  Ici, nous allons construire un certain PWM sur eux. <br><br>  En r√®gle g√©n√©rale, les ALU comparent et affectent des registres avec le m√™me index.  Lorsqu'un registre a un index de 0 et l'autre un 1, toutes les versions de l'op√©ration ne peuvent pas √™tre impl√©ment√©es.  Mais j'ai r√©ussi √† rassembler le solitaire √† partir des registres sous lesquels PWM peut √™tre fait.  Il s'est av√©r√© comme indiqu√© sur la figure. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  Lorsque la condition A0 &lt;D1 est remplie, nous ajouterons un battement suppl√©mentaire √† la longueur d'impulsion donn√©e.  Lorsque la condition n'est pas remplie, nous ne le faisons pas. <br><br><h2>  Cheval sph√©rique dans des conditions normales </h2><br>  Nous commen√ßons donc √† modifier le bloc d√©velopp√© pour UDB, en tenant compte de la nouvelle architecture.  Remplacez la profondeur de bits de Datapath: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  Nous aurons besoin de beaucoup plus de sorties de Datapath que la derni√®re fois. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  En double-cliquant dessus, nous voyons les d√©tails: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  Il y a plus de chiffres pour la variable <b>State</b> , n'oubliez pas de connecter la plus ancienne !!!  Dans l'ancienne version, il y avait un 0 constant. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  Le graphe de transition de l'automate que j'ai obtenu comme ceci: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  Nous sommes en √©tat de veille alors que FIFO1 est vide.  Soit dit en passant, travailler avec FIFO1 et non FIFO0 est le r√©sultat de la formation m√™me du solitaire.  Le registre A0 est utilis√© pour impl√©menter PWM, donc la largeur d'impulsion est d√©termin√©e par le registre A1.  Et je ne peux le t√©l√©charger qu'√† partir de FIFO1 (il existe peut-√™tre d'autres m√©thodes secr√®tes, mais elles ne me sont pas connues).  Par cons√©quent, DMA t√©l√©charge exactement les donn√©es sur FIFO1, et c'est pr√©cis√©ment l'√©tat <b>¬´Non vide¬ª</b> pour FIFO1 qui quitte l'√©tat <b>inactif</b> . <br><br>  ALU √† l'√©tat <b>IDLE</b> annule le registre A0: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  Ceci est n√©cessaire pour qu'au d√©but du fonctionnement PWM, il d√©marre toujours le travail depuis le d√©but. <br>  Mais les donn√©es sont entr√©es dans le FIFO.  La machine passe √† l'√©tat <b>LoadData</b> : <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  Dans cet √©tat, l'ALU charge le mot suivant de la FIFO dans le registre A1.  En cours de route, afin de ne pas cr√©er d'√©tats inutiles, la valeur du compteur A0, utilis√© pour travailler avec PWM, est augment√©e: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  Si le compteur A0 n'a pas encore atteint la valeur D0 (c'est-√†-dire que la condition A0 &lt;D0 est d√©clench√©e, armant le drapeau <b>NoNeedReloadA0</b> ), on passe √† l'√©tat <b>One</b> .  Sinon, l'√©tat est <b>ClearA0</b> . <br><br>  Dans l'√©tat <b>ClearA0, l'</b> ALU <b>remet</b> simplement √† z√©ro la valeur de A0, en commen√ßant un nouveau cycle PWM: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  apr√®s quoi la machine passe √©galement dans <b>un</b> √©tat, juste un temps plus tard. <br><br>  <b>L'une nous</b> est famili√®re de l'ancienne version de la machine.  ALU n'y remplit aucune fonction. <br><br>  Et donc - dans cet √©tat, une unit√© est g√©n√©r√©e √† la sortie de <b>Out_Step</b> (ici l'optimiseur fonctionnait mieux lorsque l'unit√© est produite par la condition, cela a √©t√© d√©tect√© empiriquement). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  Nous sommes dans cet √©tat jusqu'√† ce que le compteur √† sept bits que nous connaissons d√©j√† soit remis √† z√©ro.  Mais si auparavant nous sortions de cet √©tat le long d'un chemin, il peut maintenant y avoir deux chemins: direct et retard√© au rythme. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  Nous entrerons dans l'√©tat ExtraTick si l'indicateur <b>AddCycle</b> est <b>d√©fini</b> , qui est affect√© pour remplir la condition A0 &lt;D1.  Dans cet √©tat, l'ALU n'effectue aucune action b√©n√©fique.  C'est juste que le cycle prend 1 temps de plus.  De plus, tous les chemins convergent en √©tat de <b>retard</b> . <br><br>  Cette condition mesure la dur√©e de l'impulsion.  Le registre A1 (charg√© alors qu'il est encore √† l'√©tat <b>Load</b> ) est r√©duit jusqu'√† ce qu'il atteigne z√©ro. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  De plus, selon qu'il existe ou non des donn√©es suppl√©mentaires dans FIFO, la machine ira au prochain lot √† <b>charger</b> ou au <b>ralenti</b> .  Voyons cela non pas dans la figure (il y a de longues fl√®ches, tout sera petit), mais sous la forme d'un tableau, double-cliquez sur l'√©tat <b>Delay</b> : <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Quitte maintenant UDB.  J'ai converti le drapeau de l'√©tat <b>inactif</b> en comparaison asynchrone (dans la version pr√©c√©dente, il y avait un d√©clencheur qui s'armait et se r√©initialisait dans divers √©tats), car pour lui, l'optimiseur montrait le meilleur r√©sultat.  De plus, le drapeau <b>Hungry</b> a √©t√© ajout√©, signalant √† l'unit√© DMA qu'elle √©tait pr√™te √† recevoir des donn√©es.  Il est enroul√© sur le drapeau <b>¬´FIFO1 n'est pas bond√©¬ª</b> .  Puisqu'il n'est pas encombr√©, DMA peut y charger un autre mot de donn√©es. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  Sur la partie automatique - c'est tout. <br><br>  Ajoutez des blocs DMA au diagramme de projet principal.  Pour l'instant, j'ai commenc√© √† interrompre les drapeaux de terminaison DMA, mais pas le fait que ce soit correct.  Lorsque le processus d'acc√®s direct √† la m√©moire est termin√©, vous pouvez d√©marrer un nouveau processus li√© au m√™me segment, mais vous ne pouvez pas commencer √† remplir des informations sur le nouveau segment.  Le FIFO comporte encore trois √† quatre √©l√©ments.  A ce moment, il est encore impossible de reprogrammer les registres D0 et D1 du bloc sur la base de l'UDB, ils sont encore n√©cessaires au fonctionnement.  Par cons√©quent, il est possible que des interruptions bas√©es sur les sorties <b>Out_Idle</b> soient ajout√©es <b>ult√©rieurement</b> .  Mais cette cuisine ne sera plus li√©e √† la programmation de blocs UDB, nous ne le mentionnerons donc qu'en passant. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Exp√©riences logicielles </h2><br>  Puisque maintenant tout n'est pas connu, nous n'√©crirons aucune fonction sp√©ciale.  Tous les contr√¥les seront effectu√©s "sur le front".  Ensuite, sur la base d'exp√©riences r√©ussies, des fonctions API peuvent √™tre √©crites.  Alors.  Nous rendons la fonction <b>main ()</b> minimale.  Il configure simplement le syst√®me et appelle le test s√©lectionn√©. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Essayons d'envoyer un paquet d'impulsions en appelant une fonction, v√©rifiant le fait d'ins√©rer une impulsion suppl√©mentaire.  L'appel de fonction est simple: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  Mais le corps a besoin d'explications. <div class="spoiler">  <b class="spoiler_title">Je vais d'abord donner toute la fonction</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Consid√©rons maintenant ses parties importantes. <br><br>  Si la longueur de la partie positive de l'impulsion est √©gale √† 92 cycles d'horloge, l'oscilloscope ne pourra pas discerner s'il y a ou non un insert √† cycle unique dans la partie n√©gative.  L'√©chelle ne sera pas la m√™me.  Il est n√©cessaire de rendre la partie positive aussi courte que possible afin que l'impulsion totale soit comparable en √©chelle avec le battement ins√©r√©.  Par cons√©quent, je change avec force la p√©riode du compteur qui d√©finit la dur√©e de la partie positive de l'impulsion: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  Mais pourquoi six mesures enti√®res?  Pourquoi pas trois?  Pourquoi pas deux?  Pourquoi, apr√®s tout, pas un seul?  C'est une triste histoire.  Si l'impulsion positive est inf√©rieure √† 6 cycles, le syst√®me ne fonctionne pas.  Un long d√©bogage sur un oscilloscope avec la sortie de lignes de test vers l'ext√©rieur a montr√© que le DMA n'est pas une chose rapide.  Si la machine fonctionne pendant moins d'une certaine dur√©e, alors au moment o√π elle <b>quitte l'</b> √©tat <b>Retard</b> , FIFO est le plus souvent encore vide.  Il ne peut pas encore √™tre plac√© un seul nouveau mot de donn√©es!  Et seulement lorsque la partie positive de l'impulsion a une dur√©e de 6 cycles, FIFO est garanti d'avoir le temps de se charger ... <br><br><h2>  Digression de latence </h2><br>  Une autre id√©e fixe qui me vient √† l'esprit est l'acc√©l√©ration mat√©rielle de certaines fonctions du noyau de notre RTOS MAX.  Mais h√©las, toutes mes meilleures id√©es sont bris√©es sur ces m√™mes latences. <br><br>  Il y avait un cas, j'ai √©tudi√© le d√©veloppement d'applications Bare Metal pour Cyclone V SoC.  Mais il s'est av√©r√© que travailler avec des registres FPGA uniques (en alternant en y √©crivant, puis en les lisant) r√©duit les op√©rations de base des centaines (!!!) fois.  Vous avez bien entendu.  C'est en centaines.  De plus, tout cela est mal document√©, mais au d√©but, j'ai ressenti int√©rieurement, puis j'ai prouv√© √† partir de fragments de phrases de la documentation que les latences √©taient coupables lors du passage des demandes √† travers un tas de ponts.  Si vous devez chasser une grande baie, il y aura √©galement une latence, mais en termes d'un mot pomp√©, ce ne sera pas significatif.  Lorsque les demandes sont uniques (et que l'acc√©l√©ration mat√©rielle du noyau du syst√®me d'exploitation les implique uniquement), le ralentissement se produit exactement des centaines de fois.  Il sera beaucoup plus rapide de tout faire de mani√®re purement programmatique, lorsque le programme travaillera avec la m√©moire principale via le cache √† une vitesse effr√©n√©e. <br><br>  Sur PSoC, j'avais √©galement certains plans.  En apparence, vous pouvez merveilleusement rechercher des donn√©es dans un tableau √† l'aide de DMA et UDB.  Qu'est-ce qui est vraiment l√†!  En raison de la structure des descripteurs DMA, ces contr√¥leurs pourraient effectuer une recherche enti√®rement mat√©rielle dans les listes cha√Æn√©es!  Mais apr√®s avoir re√ßu le plug d√©crit ci-dessus, je me suis rendu compte qu'il est √©galement associ√© √† la latence.  Ici, cette latence est magnifiquement d√©crite dans la documentation.  √Ä la fois dans la famille TRM et dans un document distinct <b>AN84810 - PSoC 3 et PSoC 5LP Advanced DMA Topics</b> .  La section 3.2 y est consacr√©e.  La prochaine acc√©l√©ration mat√©rielle est donc annul√©e.  Dommage.  Mais, comme l'a dit Semyon Semyonovich Gorbunkov: "Nous allons chercher." <br><br><h2>  Exp√©riences logicielles continues </h2><br>  Ensuite, j'ai d√©fini les param√®tres de l'algorithme de Bresenham: <br><br><pre> <code class="plaintext hljs"> //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Eh bien, vient ensuite le code r√©gulier qui transf√®re un tableau de mots via DMA vers FIFO1 de l'unit√© de commande du moteur X. <br><br>  Le r√©sultat n√©cessite quelques explications.  Le voici: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  La valeur du compteur A0 est indiqu√©e en rouge lorsque la machine est √† l'√©tat <b>Un</b> .  L'ast√©risque vert montre les cas o√π le retard est ins√©r√© en raison de la machine en √©tat <b>ExtraTick</b> .  Il y a aussi des barres o√π le retard est d√ª √† l'√©tat <b>ClearA0</b> , elles sont marqu√©es d'une grille bleue. <br><br>  Comme vous pouvez le voir, lorsque vous entrez pour la premi√®re fois, le tout premier d√©lai est perdu.  Cela est d√ª au fait que A0 est r√©initialis√© lorsqu'il est en <b>veille</b> , mais augmente lorsqu'il entre dans <b>LoadData</b> .  Par cons√©quent, au point d'analyse (sortie de l'√©tat de <b>Un</b> ), elle est d√©j√† √©gale √† l'unit√©.  Le compte commence avec elle.  Mais en g√©n√©ral, cela n'affectera pas la fr√©quence moyenne.  Il faut juste garder cela √† l'esprit.  Comme il faut garder √† l'esprit que lors de la r√©initialisation de A0, l'horloge sera √©galement ins√©r√©e.  Il doit √™tre pris en compte lors du calcul de la fr√©quence moyenne. <br><br>  Mais en g√©n√©ral, le nombre d'impulsions est correct.  Leur dur√©e est √©galement cr√©dible. <br>  Essayons de programmer une cha√Æne de descripteurs plus r√©elle, <br><br><div class="spoiler">  <b class="spoiler_title">consistant en une phase d'acc√©l√©ration, de mouvement lin√©aire et de freinage.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Tout d'abord, appelez pour les m√™mes dix √©tapes (dans DMA, 20 octets vont r√©ellement): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  Le r√©sultat est comme pr√©vu.  Au d√©but, l'acc√©l√©ration est visible.  Et la sortie vers <b>IDLE</b> (rayon bleu) se produit avec un grand retard par rapport √† la derni√®re impulsion, c'est alors que la derni√®re √©tape a √©t√© compl√®tement termin√©e, sa valeur est approximativement √©gale √† la valeur de la premi√®re. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Vrai cheval dans des conditions normales </h2><br>  Lors du remodelage de l'√©quipement, je suis en quelque sorte pass√© d'une largeur d'impulsion de 24 bits √† une t√¢che de 16 bits.  Mais nous avons d√©couvert que cela ne peut pas √™tre fait: la fr√©quence d'impulsion minimale sera trop √©lev√©e.  Je l'ai fait intentionnellement.  Le fait est que la technique pour augmenter la capacit√© en bits d'un compteur 16 bits s'est av√©r√©e si compliqu√©e que si j'avais commenc√© √† la d√©crire avec la machine principale, elle aurait d√©tourn√© toute l'attention.  Par cons√©quent, nous le consid√©rons s√©par√©ment. <br><br>  Nous avons une batterie 16 bits.  J'ai d√©cid√© d'ajouter l'entit√© standard de compteur √† sept bits aux bits √©lev√©s.  Qu'est-ce que ce compteur √† sept bits?  C'est la conception qui est disponible dans chaque bloc UDB (le bloc UDB de base a une largeur de bits de tous les registres 8 bits, l'augmentation de la profondeur de bits est d√©termin√©e par la combinaison de blocs en groupes).  Des m√™mes ressources, <b>des</b> registres de <b>contr√¥le / √©tat</b> peuvent √™tre impl√©ment√©s.  Nous avons maintenant un compteur et non une seule paire <b>Contr√¥le / √âtat</b> pour 16 bits de donn√©es.  Donc, en ajoutant un autre compteur au syst√®me, nous ne retarderons pas les ressources suppl√©mentaires.  Nous prenons simplement ce qui nous est d√©j√† attribu√©.  C'est bien!  Nous faisons l'octet haut du compteur de largeur d'impulsion gr√¢ce √† ce m√©canisme et obtenons la largeur totale du compteur de largeur d'impulsion √©gale √† 23 bits. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  Je vais d'abord dire ce que je pensais.  Je pensais qu'apr√®s avoir quitt√© l'√©tat <b>Delay</b> , je v√©rifierais l'ach√®vement du comptage de ce compteur suppl√©mentaire.  S'il n'a pas fini de compter, je vais r√©duire sa valeur et passer √† nouveau √† l'√©tat de <b>retard</b> .  Si vous avez compt√©, la logique restera la m√™me, sans ajouter de cycles suppl√©mentaires. <br><br>  De plus, la documentation de ce compteur indique que j'ai raison.  Il dit litt√©ralement: <br><blockquote>  P√©riode <br>  D√©finit la valeur initiale du registre de p√©riode.  Pour une p√©riode de N horloges, la valeur de p√©riode doit √™tre r√©gl√©e sur la valeur de N-1.  Le compteur comptera de N-1 √† 0, ce qui se traduira par une p√©riode de cycle d'horloge N.  <b><i>Une valeur de registre de p√©riode de 0 n'est pas prise en charge et entra√Ænera le maintien de la sortie de comptage des bornes √† un √©tat √©lev√© constant.</i></b> </blockquote>  La vie a montr√© que tout est diff√©rent.  J'ai d√©duit l'√©tat de la ligne de <b>comptage</b> du <b>terminal</b> sur l'oscilloscope et j'ai observ√© sa valeur √† un z√©ro pr√©charg√© pendant la <b>p√©riode</b> et pendant le chargement du programme.  H√©las et ah.  Il n'y avait pas d' <b>√©tat haut constant</b> ! <br><br>  Par essais et erreurs, j'ai r√©ussi √† faire fonctionner le syst√®me correctement, mais pour que cela se produise, au moins une soustraction du compteur doit se produire!  Le nouvel √©tat de <b>"soustraction" n'est</b> pas de c√¥t√©.  Il devait √™tre coinc√© dans le chemin requis.  Il est situ√© en face de l'√©tat <b>Delay</b> et s'appelle <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  ALU dans cet √©tat n'effectue aucune action utile.  En fait, seul un nouveau compteur r√©agit au fait d'√™tre dans cet √©tat.  Le voici dans le sch√©ma: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Voici ses propri√©t√©s plus en d√©tail: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  En g√©n√©ral, compte tenu des articles pr√©c√©dents, l'essence de ce compteur est claire.  Seule la ligne <b>Enable</b> souffre.  Encore une fois, je ne comprends pas bien pourquoi il doit √™tre allum√© lorsque la machine est dans l'√©tat <b>LoadData</b> (puis le compteur recharge la valeur de p√©riode).  J'ai emprunt√© cette astuce aux propri√©t√©s du compteur qui contr√¥le les LED, prises par l'auteur anglais de l'unit√© de contr√¥le de ces LED.  Sans cela, la valeur z√©ro de la p√©riode ne fonctionne pas.  Elle travaille avec elle. <br><br>  Dans le code API, nous ajoutons l'initialisation d'un nouveau compteur.  Maintenant, la fonction de d√©marrage ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Voyons le nouveau syst√®me.  Voici le code de fonction pour tester <br><br><div class="spoiler">  <b class="spoiler_title">(en elle, seule la premi√®re ligne diff√®re de la d√©j√† connue):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Nous l'appelons comme ceci: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  Sur l'oscilloscope, nous voyons ce qui suit (faisceau jaune - sortie STEP, bleu - valeur de la sortie du compteur TC pour le contr√¥le du processus).  La dur√©e d'impulsion est d√©finie par un tableau d' <b>√©tapes</b> .  A chaque √©tape, la dur√©e est de 0x1000 mesures. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Basculez vers un autre scan pour qu'il y ait compatibilit√© entre les diff√©rents r√©sultats: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  Remplacez l'appel de fonction par ceci: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  Le r√©sultat est comme pr√©vu.  Tout d'abord, la sortie TC est nulle pour les cycles 0x1000, puis - une unit√© pour les cycles 0x10000 (65536d).  La fr√©quence est approximativement √©gale √† 700 hertz, nous l'avons d√©couvert dans la derni√®re partie de l'article, donc tout va bien. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Eh bien, essayons un diable: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  Nous obtenons: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  C'est vrai.  La sortie TC est invers√©e √† une sur les derniers 65536 cycles d'horloge.  Avant cela, il √©tait √† z√©ro pour les cycles 0x1000 + 0x10000. <br><br>  Bien s√ªr, avec cette approche, toutes les impulsions doivent aller avec la m√™me valeur du nouveau compteur.  Il est impossible de faire une impulsion avec l'octet le plus √©lev√© pendant l'acc√©l√©ration, disons 3, puis 1, puis 0. Mais en fait, √† des fr√©quences aussi basses (moins de sept cents hertz), les acc√©l√©rations n'ont pas de signification physique, donc ce probl√®me peut √™tre n√©glig√©.  √Ä cette fr√©quence, vous pouvez travailler avec le moteur de fa√ßon lin√©aire. <br><br><h2>  Voler dans la pommade </h2><br>  Le document TRM pour la famille PSoC5LP indique: <br><blockquote>  Chaque transaction peut aller de 1 √† 64 Ko </blockquote>  Mais dans l'AN84810 d√©j√† mentionn√©, il y a une telle phrase: <br><blockquote>  1. Comment pouvez-vous mettre en m√©moire tampon plus de 4095 octets en utilisant DMA? <br>  Le nombre maximal de transferts d'un TD est limit√© √† 4095 octets.  Si vous devez transf√©rer plus de 4095 octets √† l'aide d'un seul canal DMA, utilisez plusieurs TD et cha√Ænez-les comme indiqu√© dans l'exemple 5. </blockquote>  Qui a raison?  Si vous menez des exp√©riences, les r√©sultats pencheront en faveur du pire des √©nonc√©s, mais le comportement sera compl√®tement incompr√©hensible.  Toute la faute est cette v√©rification dans l'API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">M√™me texte.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  Si une transaction de plus de 4095 octets est sp√©cifi√©e, le param√®tre pr√©c√©dent sera utilis√©.  Oui, je n'ai pas pens√© √† v√©rifier les codes d'erreur ... <br><br>  Les exp√©riences ont montr√© que si vous supprimez cette v√©rification, la longueur r√©elle sera coup√©e √† l'aide du masque 0xfff (4096 = 0x1000).  H√©las et ah.  Tous les espoirs d'un travail agr√©able se sont effondr√©s.  Vous pouvez bien s√ªr cr√©er des cha√Ænes de descripteurs associ√©s en 4K.  Mais disons que 64K, c'est 16 cha√Ænes.  Trois moteurs actifs (les extrudeuses auront moins d'√©tapes) - 48 cha√Ænes.  Exactement autant devrait √™tre rempli dans le pire des cas, avant chaque segment.  C'est peut-√™tre acceptable √† temps.  Au minimum, 127 descripteurs sont disponibles, donc il y aura certainement assez de m√©moire. <br><br>  Vous pouvez envoyer les donn√©es manquantes au besoin.  Une interruption est survenue lorsque la cha√Æne DMA a termin√© ses travaux, nous y transf√©rons un autre segment.  Dans ce cas, aucun calcul n'est requis, le segment est d√©j√† form√©, tout sera rapide.  Et il n'y a aucune exigence de performances: lorsqu'une demande d'interruption est √©mise, il y aura 4 autres √©l√©ments dans FIFO qui seront desservis chacun pendant plusieurs centaines, voire des milliers de cycles d'horloge.  Autrement dit, tout est r√©el.  Une strat√©gie sp√©cifique sera plus facile √† choisir lors de travaux r√©els.  Mais une erreur dans la documentation (TRM) a g√¢ch√© toute l'ambiance.  Si cela avait √©t√© connu √† l'avance, je n'aurais peut-√™tre pas v√©rifi√© la m√©thodologie. <br><br><h2>  Conclusion </h2><br>  En apparence, l'outil de micrologiciel auxiliaire d√©velopp√© est devenu acceptable, de sorte qu'il serait possible, sur sa base, de cr√©er une version du ¬´micrologiciel¬ª, disons Marlin, qui n'est pas constamment dans le gestionnaire d'interruption pour les moteurs pas √† pas.  √Ä ma connaissance, cela est particuli√®rement vrai pour les imprimantes Delta, o√π la demande de ressources informatiques est assez √©lev√©e.  Peut-√™tre que cela √©liminera l'afflux qui se produit sur mon Delta aux endroits o√π la t√™te s'arr√™te.  Sur le MZ3D √† ces m√™mes endroits, aucun afflux n'est observ√©.  Que ce soit vrai ou non, le temps nous le dira, et le rapport √† ce sujet devra √™tre publi√© dans une branche compl√®tement diff√©rente. <br><br>  En attendant, nous avons vu que sur le bloc UDB, pour toute sa simplicit√©, il est tout √† fait possible d'impl√©menter un coprocesseur fonctionnant en tandem avec le processeur principal et permettant son d√©chargement.  Et quand il y a beaucoup de ces unit√©s, les coprocesseurs peuvent fonctionner en parall√®le. <br><br>  Une erreur dans la documentation du contr√¥leur DMA a brouill√© le r√©sultat.  Des interruptions sont n√©anmoins n√©cessaires, mais pas √† la m√™me fr√©quence et pas avec la criticit√© dans le temps qui √©tait dans la version originale.  L'ambiance est donc g√¢t√©e, mais l'utilisation d'un ¬´coprocesseur¬ª bas√© sur UDB donne encore un gain consid√©rable par rapport au travail purement logiciel. <br><br>  En cours de route, il a √©t√© r√©v√©l√© que le DMA fonctionne √† une vitesse assez faible.  √Ä la suite de cela, certaines mesures ont √©t√© effectu√©es √† la fois sur le PSoC5LP et sur le STM32.  Les r√©sultats tirent un autre article.  Peut-√™tre que je le ferai un jour si le sujet s'av√®re int√©ressant. <br><br>  √Ä la suite des exp√©riences, deux projets de test ont √©t√© obtenus √† la fois.  Le premier est plus facile √† comprendre.  Vous pouvez le prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Le second est h√©rit√© du premier, mais confus lors de l'ajout d'un compteur √† sept bits et de la logique associ√©e.  Vous pouvez le prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Bien s√ªr, ces exemples ne sont que des tests.  Il n'y a pas encore de temps libre pour l'int√©gration dans le v√©ritable ¬´firmware¬ª.  Mais dans le cadre de ces articles, il est plus important de s'entra√Æner √† travailler avec UDB. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434742/">https://habr.com/ru/post/fr434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434732/index.html">La vie √† 6200 DPI. Examen du noyau HyperX Pulsefire</a></li>
<li><a href="../fr434734/index.html">Transformation de Fourier. Le rapide et le furieux</a></li>
<li><a href="../fr434736/index.html">Utilisation de la base de donn√©es des journaux Mikrotik pour supprimer la force brute</a></li>
<li><a href="../fr434738/index.html">Apprentissage par renforcement en Python</a></li>
<li><a href="../fr434740/index.html">Un r√©seau de neurones a appris √† d√©tecter les panneaux solaires dans les images satellites et √† pr√©dire le niveau de leur distribution</a></li>
<li><a href="../fr434744/index.html">Samsung SSD 860 QVO 1 TB et 4 TB: le premier consommateur SATA QLC (2 parties)</a></li>
<li><a href="../fr434746/index.html">BLE sous microscope 4</a></li>
<li><a href="../fr434750/index.html">Comment prendre le contr√¥le de votre infrastructure r√©seau. Chapitre deux Nettoyage et documentation</a></li>
<li><a href="../fr434752/index.html">Robomoroz: l'avenir du personnage principal de la nouvelle ann√©e</a></li>
<li><a href="../fr434756/index.html">L'avenir de Kubernetes est avec les machines virtuelles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>