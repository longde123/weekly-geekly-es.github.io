<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 🏿 🥁 Flightradar24-如何运作？ 第2部分，ADS-B协议 🍷 👩🏻‍🔧 🌠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我要说的是，每个朋友或家人曾经乘坐飞机的人都使用Flightradar24-一种免费，便捷的实时跟踪航班的服务。 



 在第一部分中，描述了操作的基本思想。 现在，让我们进一步了解一下，飞机和地面站之间正在正确发送和接收哪些数据。 我们还将使用Python解码此数据。 

 历史沿革 
 很明显...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flightradar24-如何运作？ 第2部分，ADS-B协议</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447078/"> 我要说的是，每个朋友或家人曾经乘坐飞机的人都使用Flightradar24-一种免费，便捷的实时跟踪航班的服务。 <br><br><img src="https://habrastorage.org/webt/xg/eo/t-/xgeot-h18b94ucc-fiuc46iotvm.jpeg" alt="图片"><br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a>中，描述了操作的基本思想。 现在，让我们进一步了解一下，飞机和地面站之间正在正确发送和接收哪些数据。 我们还将使用Python解码此数据。 <br><a name="habracut"></a><br><h2> 历史沿革 </h2><br> 很明显，飞机数据不仅适用于想要在智能手机上查看数据的用户。 该系统称为ADS – B（自动相关监视-广播），旨在将飞机信息数据自动传输到控制中心-发送不同的参数，例如坐标，速度，航向，高度等。 以前，调度员只能在雷达屏幕上看到一点。 当飞机数量急剧增加时，这绝对是不够的。 <br><br> 从技术上讲，ADS-B由飞机内部的发射器组成，它以1090 MHz的相对较高的频率定期发送信息数据帧（还有其他一些模式，但是它们对我们而言并不那么有趣，因为坐标仅在此处传输） 当然，在机场某处也有一个接收器，但是对于我们和用户来说，我们自己的接收器更有趣。 <br><br> 为了进行比较，第一个为普通用户设计的系统Airnav Radarbox于2007年问世，价格约为900美元，每年约250美元的用户订购网络服务费用（该系统的主要思想是收集和共享来自<i>许多接收器的</i>数据，独立接收器则相对没有用）。 <br><br><img src="https://habrastorage.org/webt/74/dt/np/74dtnpj6jdit1zlt_cr37rq4mju.png"><br><br> 现在，当RTL-SDR接收器变得越来越可用时，只需30美元就可以制造出类似的设备。 可以在本文的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中</a>找到它，我们将进一步介绍该协议本身-让我们看看它是如何工作的。 <br><br><h2> 接收信号 </h2><br> 首先，我们需要记录一个信号样本。 整个信号只有120微秒的长度，要以良好的“分辨率”查看其细节，最好具有至少5 MHz采样率的SDR无线电。 <br><br><img src="https://habrastorage.org/webt/mu/ig/uj/muigujxudctclwalfdxl5tzzdam.png" alt="图片"><br><br> 记录后，我们将获得一个具有5,000,000个样本/秒采样率的WAV文件，这种记录的30秒大小约为500MB。 当然，用您喜欢的媒体播放器收听它毫无用处-文件不包含声音，而是直接数字化的无线电信号本身-这正是软件无线电的工作原理。 <br><br> 我们可以使用Python打开和处理此文件。 那些希望自己进行实验的人可以从此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>下载示例。 <br><br> 让我们打开一个文件，看看里面是什么。 <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"adsb_20190311_191728Z_1090000kHz_RF.wav"</span></span>) data = data.astype(float) I, Q = data[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], data[:, <span class="hljs-number"><span class="hljs-number">1</span></span>] A = np.sqrt(I*I + Q*Q) plt.plot(A) plt.show()</code> </pre> <br> 结果：我们在噪声上看到了一些“冲动”。 <br><br><img src="https://habrastorage.org/webt/ko/v5/ra/kov5rakmt1sysd7yncso6372l70.png"><br><br> 每个“脉冲”都是一个信号，如果我们提高图形的分辨率，则其结构清晰可见。 <br><br><img src="https://habrastorage.org/webt/7l/oa/y-/7loay-b4xf16kyy--ik_j4rhh4q.png"><br><br> 我们可以看到，图片与上面的描述完全一致。 现在，我们可以处理这些数据。 <br><br><h2> 解码方式 </h2><br> 首先，我们需要一点点流。 信号本身使用曼彻斯特编码进行编码： <br><br><img src="https://habrastorage.org/webt/rh/k3/is/rhk3iskt0btt5s9okaekkaox3w8.png"><br><br> 从半咬合的差异中，我们可以轻松获得真实的“ 0”和“ 1”。 <br><br><pre> <code class="python hljs"> bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>], A[pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg1 &lt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> avg1 &gt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span></code> </pre><br> 信号本身的结构如下所示： <br><br><img src="https://habrastorage.org/webt/cl/_7/ng/cl_7ngs5clpg97zrplnolcajpcq.png"><br><br> 让我们更详细地查看字段。 <br><br>  <b>DF</b> （下行格式，5位）-定义消息的类型。 它们有几种类型： <br><br><img src="https://habrastorage.org/webt/li/no/dt/linodtcxx6jtskav1aqar14odew.png"><br>  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面来源</a> ） <br><br> 我们只对DF17类型感兴趣，因为只有其中一个包含飞机坐标。 <br><br>  <b>ICAO</b> （24位）-是唯一的国际飞机代码。 我们可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该网站上</a>的代码检查飞机（不幸的是，作者已停止更新数据库，但仍然有用）。 例如，对于3c5ee2代码，我们可以具有以下信息： <br><br><img src="https://habrastorage.org/webt/i6/gt/8s/i6gt8sgm9n7zv1u7nspnzsitpk4.png"><br><br>  <b>DATA</b> （56或112位）-是数据本身，我们将对其进行解码。 数据的前5位是“ <b>类型代码”</b>字段，其中包含要存储的数据的子类型（不要与<i>DF</i>字段混合）。 有很多这样的类型： <br><br><img src="https://habrastorage.org/webt/5v/h1/3h/5vh13htes6_pyungnbzkucvqlji.png"><br>  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表来源</a> ） <br><br> 让我们看一些例子。 <br><br>  <b>飞机识别</b> <br><br> 二进制形式的示例： <br><br>  00100 011 000101 010111 000111 110111 110001 111000 <br><br> 资料栏位： <br><br><pre> <code class="python hljs">+------+------+------+------+------+------+------+------+------+------+ | TC,<span class="hljs-number"><span class="hljs-number">5</span></span> | EC,<span class="hljs-number"><span class="hljs-number">3</span></span> | C1,<span class="hljs-number"><span class="hljs-number">6</span></span> | C2,<span class="hljs-number"><span class="hljs-number">6</span></span> | C3,<span class="hljs-number"><span class="hljs-number">6</span></span> | C4,<span class="hljs-number"><span class="hljs-number">6</span></span> | C5,<span class="hljs-number"><span class="hljs-number">6</span></span> | C6,<span class="hljs-number"><span class="hljs-number">6</span></span> | C7,<span class="hljs-number"><span class="hljs-number">6</span></span> | C8,<span class="hljs-number"><span class="hljs-number">6</span></span> | +------+------+------+------+------+------+------+------+------+------+</code> </pre><br>  TC = 00100b = 4，并且每个符号C1-C8包含代码，应与该字符串中的索引匹配： <br>  #ABCDEFGHIJKLMNOPQRSTUVWXYZ ##### _ ################ 0123456789 ###### <br><br> 解码后容易得到飞机的名称：EWG7184 <br><br><pre> <code class="python hljs">symbols = <span class="hljs-string"><span class="hljs-string">"#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######"</span></span> code_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): c = int(bits_str[<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*p:<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*(p + <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-number"><span class="hljs-number">2</span></span>) code_str += symbols[c] print(<span class="hljs-string"><span class="hljs-string">"Aircraft Identification:"</span></span>, code_str.replace(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))</code> </pre><br>  <b>空降位置</b> <br><br> 名称解码很简单，但是坐标更复杂。 它们以2帧的形式发送，偶数和奇数。 域代码TC = 01011b = 11。 <br><br><img src="https://habrastorage.org/webt/3i/8h/oj/3i8hojmkecmc0xlnfhkwvf7svk8.png"><br><br> 偶数和奇数数据帧的示例： <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000101110110</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10111000111001000</span></span> <span class="hljs-number"><span class="hljs-number">10000110101111001</span></span> <span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000110010000</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">10010011110000110</span></span> <span class="hljs-number"><span class="hljs-number">10000011110001000</span></span></code> </pre><br> 坐标本身的计算使用一些棘手的公式： <br><br><img src="https://habrastorage.org/webt/3i/uf/m0/3iufm0e0758rzbjmxmkazgifsqq.png"><br>  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> ） <br><br> 我不是GIS专家，所以我不知道它来自哪里。 谁知道的更好，请在评论中写。 <br><br> 高度计算更简单-根据特定的位，它可以表示为25或100英尺的倍数。 <br><br>  <b>空降速度</b> <br><br>  TC = 19的数据帧。有趣的是，速度可以相对于地面（更精确，称为地面速度），而相对速度则由飞机的空气传感器测量（由于风而可能不那么精确）。 还传输许多其他不同的字段： <br><br><img src="https://habrastorage.org/webt/hh/yr/bn/hhyrbnk8nh7qauorxuohetys5fi.png"><br>  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> ） <br><br><h2> 结论 </h2><br> 正如我们所看到的，当一个标准不仅对专业人士而且对于普通用户广泛使用时，ADS-B技术已经成为一种有趣的共生方式。 但是肯定的是，其中的关键作用是通过降低数字SDR接收器技术的价格来实现的，该技术允许在非常便宜的设备上接收频率高于千兆赫的信号。 <br><br> 当然，该标准本身具有更多数据。 有兴趣的人可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ICAO</a>页面上查看PDF或访问上面已经提到的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mode-s.org网站</a> 。 这篇文章不太可能真正被大多数读者使用，但是我希望，至少对于它的工作原理有一个大致的了解。 <br><br> 顺便说一下，ADS-B Python解码器已经存在，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github上进行研究</a> 。  SDR接收器所有者还可以<a href="">从此页面</a>构建并运行即用型ADS-B解码器，并且（我将再次重复）在本文<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的第一部分中</a> ，我们还将详细介绍一些细节。 <br><br> 上面描述的解析器源代码在扰流器下提供。 这只是一个测试示例，它并不假冒生产质量，但总的来说，它可以工作，并且可以解析上面记录的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WAV文件</a> 。 <br><br><div class="spoiler">  <b class="spoiler_title">源代码（Python）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, start, bit_len)</span></span></span><span class="hljs-function">:</span></span> max_len = bit_len*<span class="hljs-number"><span class="hljs-number">128</span></span> A = data[start:start + max_len] A = signal.resample(A, <span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bits = np.zeros(<span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bit_len *= <span class="hljs-number"><span class="hljs-number">10</span></span> start_data = bit_len*<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment"># Parse first 8 bits bits_str = "" for p in range(8): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" df = int(bits_str[0:5], 2) # Aircraft address (db - https://junzis.com/adb/?q=3b1c5c ) bits_str = "" for p in range(8, 32): pos = start_data + bit_len * p p1, p2 = A[pos: pos + bit_len / 2], A[pos + bit_len / 2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" # print "Aircraft address:", bits_str, hex(int(bits_str, 2)) address = hex(int(bits_str, 2)) # Filter specific aircraft (optional) # if address != "0x3c5ee2": # return if df == 16 or df == 17 or df == 18 or df == 19 or df == 20 or df == 21: # print "Pos:", start, "DF:", msg_type # Data (56bit) bits_str = "" for p in range(32, 88): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" # bits[pos + bit_len / 2] = 50 elif avg1 &gt; avg2: bits_str += "1" # http://www.lll.lu/~edward/edward/adsb/DecodingADSBposition.html # print "Data:" # print bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17] # Type Code: tc, ec = int(bits_str[:5], 2), int(bits_str[5:8], 2) # print("DF:", df, "TC:", tc) # 1 - 4 Aircraft identification # 5 - 8 Surface position # 9 - 18 Airborne position (w/ Baro Altitude) # 19 Airborne velocities if tc &gt;= 1 and tc &lt;= 4: # and (df == 17 or df == 18): print("Aircraft address:", address) print("Data:") print(bits_str[:8], bits_str[8:14], bits_str[14:20], bits_str[20:26], bits_str[26:32], bits_str[32:38], bits_str[38:44]) symbols = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######" code_str = "" for p in range(8): c = int(bits_str[8 + 6*p:8 + 6*(p + 1)], 2) code_str += symbols[c] print("Aircraft Identification:", code_str.replace('#', '')) print() if tc == 11: print("Aircraft address:", address) print("Data: (11)") print(bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17]) # Bit 22 contains the F flag which indicates which CPR format is used (odd or even) # First frame has F flag = 0 so is even and the second frame has F flag = 1 so odd # f = bits_str[21:22] # print("F:", int(f, 2)) # Altitude alt1b = bits_str[8:20] if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) # lat_dec = int(bits_str[22:22+17], 2) # lon_dec = int(bits_str[39:39+17], 2) # print("Lat/Lon:", lat_dec, lon_dec) # http://airmetar.main.jp/radio/ADS-B%20Decoding%20Guide.pdf print() if tc == 19: print("Aircraft address:", address) print("Data:") # print(bits_str) print(bits_str[:5], bits_str[5:8], bits_str[8:10], bits_str[10:13], bits_str[13] ,bits_str[14:24], bits_str[24], bits_str[25:35], bits_str[35:36], bits_str[36:65]) subtype = int(bits_str[5:8], 2) # https://mode-s.org/decode/adsb/airborne-velocity.html spd, hdg, rocd = -1, -1, -1 if subtype == 1 or subtype == 2: print("Velocity Subtype 1: Ground speed") v_ew_sign = int(bits_str[13], 2) v_ew = int(bits_str[14:24], 2) - 1 # east-west velocity v_ns_sign = int(bits_str[24], 2) v_ns = int(bits_str[25:35], 2) - 1 # north-south velocity v_we = -1*v_ew if v_ew_sign else v_ew v_sn = -1*v_ns if v_ns_sign else v_ns spd = math.sqrt(v_sn*v_sn + v_we*v_we) # unit in kts hdg = math.atan2(v_we, v_sn) hdg = math.degrees(hdg) # convert to degrees hdg = hdg if hdg &gt;= 0 else hdg + 360 # no negative val if subtype == 3: print("Subtype Subtype 3: Airspeed") hdg = int(bits_str[14:24], 2)/1024.0*360.0 spd = int(bits_str[25:35], 2) vr_sign = int(bits_str[36], 2) vr = int(bits_str[36:45], 2) rocd = -1*vr if vr_sign else vr # rate of climb/descend print("Speed (kts):", spd, "Rate:", rocd, "Heading:", hdg) print() # print() def calc_coordinates(): def _cprN(lat, is_odd): nl = _cprNL(lat) - is_odd return nl if nl &gt; 1 else 1 def _cprNL(lat): try: nz = 15 a = 1 - math.cos(math.pi / (2 * nz)) b = math.cos(math.pi / 180.0 * abs(lat)) ** 2 nl = 2 * math.pi / (math.acos(1 - a/b)) return int(math.floor(nl)) except: # happens when latitude is +/-90 degree return 1 def floor_(x): return int(math.floor(x)) lat1b, lon1b, alt1b = "10111000111010011", "10000110111111000", "000101111001" lat2b, lon2b, alt2b = "10010011101011100", "10000011000011011", "000101110111" lat1, lon1, alt1 = int(lat1b, 2), int(lon1b, 2), int(alt1b, 2) lat2, lon2, alt2 = int(lat2b, 2), int(lon2b, 2), int(alt2b, 2) # 131072 is 2^17, since CPR lat and lon are 17 bits each cprlat_even, cprlon_even = lat1/131072.0, lon1/131072.0 cprlat_odd, cprlon_odd = lat2/131072.0, lon2/131072.0 print(cprlat_even, cprlon_even) j = floor_(59*cprlat_even - 60*cprlat_odd) print(j) air_d_lat_even = 360.0 / 60 air_d_lat_odd = 360.0 / 59 # Lat lat_even = float(air_d_lat_even * (j % 60 + cprlat_even)) lat_odd = float(air_d_lat_odd * (j % 59 + cprlat_odd)) if lat_even &gt;= 270: lat_even = lat_even - 360 if lat_odd &gt;= 270: lat_odd = lat_odd - 360 # Lon ni = _cprN(lat_even, 0) m = floor_(cprlon_even * (_cprNL(lat_even)-1) - cprlon_odd * _cprNL(lat_even) + 0.5) lon = (360.0 / ni) * (m % ni + cprlon_even) print("Lat", lat_even, "Lon", lon) # Altitude # Q-bit (bit 48) indicates whether the altitude is encoded in multiples of 25 or 100 ft (0: 100 ft, 1: 25 ft) # The value can represent altitudes from -1000 to +50175 ft. if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) fs, data = wavfile.read("adsb_20190311_191728Z_1090000kHz_RF.wav") T = 1/fs print("Sample rate %f MS/s" % (fs / 1e6)) print("Cnt samples %d" % len(data)) print("Duration: %fs" % (T * len(data))) data = data.astype(float) cnt = data.shape[0] # Processing only part on file (faster): # cnt = 10000000 # data = data[:cnt] print("Processing I/Q...") I, Q = data[:, 0], data[:, 1] A = np.sqrt(I*I + Q*Q) bits = np.zeros(cnt) # To see scope without any processing, uncomment # plt.plot(A) # plt.show() # sys.exit(0) print("Extracting signals...") pos = 0 avg = 200 msg_start = 0 # Find beginning of each signal while pos &lt; cnt - 16*1024: # P1 - message start while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg and pos - msg_start &gt; 1000: msg_start = pos bits[pos] = 100 pos += 4 break pos += 1 start1, start2, start3, start4 = msg_start, 0, 0, 0 # P2 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start2 = pos bits[pos] = 90 pos += 1 break pos += 1 # P3 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start3 = pos bits[pos] = 80 pos += 1 break pos += 1 # P4 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start4 = pos bits[pos] = 70 pos += 1 break pos += 1 sig_diff = start4 - start1 if 20 &lt; sig_diff &lt; 25: bits[msg_start] = 500 bit_len = int((start4 - start1) / 4.5) # print(pos, start1, start4, ' - ', bit_len) # start = start1 + 8*bit_len parse_message(A, msg_start, bit_len) pos += 450 # For debugging: check signal start # plt.plot(A) # plt.plot(bits) # plt.show()</span></span></code> </pre><br></div></div><br> 我希望它有用，感谢您的阅读。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447078/">https://habr.com/ru/post/zh-CN447078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447068/index.html">比较相似的字符串</a></li>
<li><a href="../zh-CN447070/index.html">AERODISK ENGINE N2储存碰撞测试，强度测试</a></li>
<li><a href="../zh-CN447072/index.html">“我做了一切-这是一个有趣的故事”：关于内容营销和IT媒体职业的播客</a></li>
<li><a href="../zh-CN447074/index.html">我们正在Node.js上编写第一个微服务，并通过RabbitMQ进行通信</a></li>
<li><a href="../zh-CN447076/index.html">OWASP俄罗斯聚会-录制表演</a></li>
<li><a href="../zh-CN447080/index.html">网络最小。 哦，就是这样</a></li>
<li><a href="../zh-CN447088/index.html">“ Cell”面包板</a></li>
<li><a href="../zh-CN447090/index.html">背景：持续集成过程如何工作</a></li>
<li><a href="../zh-CN447092/index.html">这根天线是什么范围？ 使用OSA103 Mini测量天线性能</a></li>
<li><a href="../zh-CN447094/index.html">经理人的机器学习：分离的圣礼</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>