<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÑÔ∏è ü•ù üç¨ Wer stiehlt die virtuelle CPU-Zeit? ü§¢ ‚úã üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! In diesem Artikel m√∂chte ich Laien erkl√§ren, wie Steal in VMs auftritt, und Ihnen einige der weniger offensichtlichen Artefakte erl√§utern, die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wer stiehlt die virtuelle CPU-Zeit?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453140/"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/ede/bb8/9d4edebb8a0253cb1b973bd5df46a9a9.jpg"><br><br>  Hallo!  In diesem Artikel m√∂chte ich Laien erkl√§ren, wie <i>Steal</i> in VMs auftritt, und Ihnen einige der weniger offensichtlichen Artefakte erl√§utern, die wir bei der Recherche zu dem Thema gefunden haben, an dem ich als CTO der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mail beteiligt war. com Cloud Solutions-</a> Plattform.  Auf der Plattform wird KVM ausgef√ºhrt. <br><a name="habracut"></a><br>  Die CPU-Diebstahlzeit ist die Zeit, in der eine VM nicht die f√ºr den Betrieb erforderlichen Ressourcen erh√§lt.  Diese Zeit kann nur in einem Gastbetriebssystem in Virtualisierungsumgebungen berechnet werden.  Es ist √§u√üerst unklar, wo die zugewiesenen Ressourcen verloren gehen, genau wie in realen Situationen.  Wir haben uns jedoch entschlossen, es herauszufinden, und wir haben sogar eine Reihe von Tests durchgef√ºhrt, um dies zu tun.  Das hei√üt nicht, dass wir alles √ºber <i>Stehlen</i> wissen <i>,</i> aber es gibt einige faszinierende Dinge, die wir gerne mit Ihnen teilen m√∂chten. <br><br><h2>  1. Was ist <i>stehlen</i> ? </h2><br>  <i>Steal</i> ist eine Metrik, die auf einen Mangel an CPU-Zeit f√ºr VM-Prozesse hinweist.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KVM-Kernel-Patch beschrieben</a> , ist <i>Steal</i> die Zeit, die ein Hypervisor damit verbringt, andere Prozesse in einem Host-Betriebssystem auszuf√ºhren, w√§hrend sich der VM-Prozess in einer Ausf√ºhrungswarteschlange befindet.  Mit anderen Worten, <i>stehlen</i> wird als Differenz zwischen dem Moment, in dem ein Prozess zur Ausf√ºhrung bereit ist, und dem Moment, in dem dem Prozess CPU-Zeit zugewiesen wird, berechnet. <br><br>  Der VM-Kernel erh√§lt die <i>Steal-</i> Metrik vom Hypervisor.  Der Hypervisor gibt nicht an, welche Prozesse ausgef√ºhrt werden.  Es hei√üt nur: "Ich bin besch√§ftigt und kann Ihnen keine Zeit zuweisen."  In einer KVM wird die <i>Diebstahlberechnung</i> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches unterst√ºtzt</a> .  Hierzu gibt es zwei Hauptpunkte: <br><br><ul><li>  Eine VM lernt vom Hypervisor, wie man <i>stiehlt</i> .  Dies bedeutet, dass <i>Steal</i> in Bezug auf Verluste eine indirekte Messung ist, die auf verschiedene Weise verzerrt werden kann. <br></li><li>  Der Hypervisor teilt den VM-Informationen nicht mit, womit er besch√§ftigt ist.  Der wichtigste Punkt ist, dass ihm keine Zeit zugewiesen wird.  Die VM selbst kann daher keine Verzerrungen in der <i>Steal-</i> Metrik erkennen <i>,</i> die durch die Art der konkurrierenden Prozesse gesch√§tzt werden k√∂nnten. <br></li></ul><br><h2>  2. Was beeinflusst <i>stehlen</i> ? </h2><br><h4>  2.1.  <i>Steal</i> berechnen </h4><br>  Im Wesentlichen wird <i>Steal</i> mehr oder weniger auf die gleiche Weise berechnet wie die CPU-Auslastungszeit.  Es gibt nicht viele Informationen dar√ºber, wie die Auslastung berechnet wird.  Das liegt wahrscheinlich daran, dass die meisten Profis denken, dass es offensichtlich ist.  Es gibt jedoch einige Fallstricke.  Der Prozess wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Artikel von Brendann Gregg beschrieben</a> .  Er diskutiert eine ganze Reihe von Nuancen in Bezug auf die Berechnung der Auslastung und Szenarien, in denen die Berechnung falsch sein wird: <br><br><ul><li>  CPU √ºberhitzt und drosselt. <br></li><li>  Ein- und Ausschalten des Turbo Boost f√ºhrt zu einer √Ñnderung der CPU-Taktrate. </li><li> Die Zeitscheiben√§nderung, die auftritt, wenn CPU-Energiespartechnologien, z. B. SpeedStep, verwendet werden. <br></li><li>  Probleme bei der Berechnung von Durchschnittswerten: Die Messung der Auslastung f√ºr eine Minute bei 80% Leistung k√∂nnte einen kurzfristigen Anstieg um 100% verbergen. <br></li><li>  Ein Spinlock, der zu einem Szenario f√ºhrt, in dem der Prozessor verwendet wird, der Benutzerprozess jedoch nicht fortschreitet.  Infolgedessen betr√§gt die berechnete CPU-Auslastung 100%, der Prozess verbraucht jedoch keine CPU-Zeit. <br></li></ul><br>  Ich habe keine Artikel gefunden, die solche Berechnungen von <i>Diebstahl beschreiben</i> (wenn Sie welche kennen, teilen Sie sie bitte im Kommentarbereich mit).  Wie Sie dem Quellcode entnehmen k√∂nnen, ist der Berechnungsmechanismus der gleiche wie f√ºr die Verwendung.  Der einzige Unterschied besteht darin, dass ein weiterer Z√§hler speziell f√ºr den KVM-Prozess (VM-Prozess) hinzugef√ºgt wird, der berechnet, wie lange der KVM-Prozess auf die CPU-Zeit gewartet hat.  Der Z√§hler entnimmt Daten zur CPU aus seiner Spezifikation und pr√ºft, ob alle seine Ticks vom VM-Prozess verwendet werden.  Wenn alle Ticks verwendet werden, war die CPU nur mit dem VM-Prozess besch√§ftigt.  Ansonsten wissen wir, dass die CPU etwas anderes getan hat und <i>stehlen</i> erscheint. <br><br>  Der Prozess, mit dem der <i>Diebstahl</i> berechnet wird, unterliegt denselben Problemen wie die regul√§re Berechnung der Auslastung.  Diese Probleme sind nicht so h√§ufig, aber sie k√∂nnen ziemlich verwirrend erscheinen. <br><br><h4>  2.2.  Arten der KVM-Virtualisierung </h4><br>  Im Allgemeinen gibt es drei Arten der Virtualisierung, die alle von einer KVM unterst√ºtzt werden.  Der Mechanismus, mit dem <i>gestohlen wird,</i> kann von der Art der Virtualisierung abh√§ngen. <br><br>  √úbersetzung  In diesem Fall funktioniert das VM-Betriebssystem auf folgende Weise mit physischen Hypervisor-Ger√§ten: <br><br><ol><li>  Das Gastbetriebssystem sendet einen Befehl an sein Gastger√§t. <br></li><li>  Der Gastger√§tetreiber akzeptiert den Befehl, erstellt eine BIOS-Ger√§teanforderung und sendet den Befehl an den Hypervisor. <br></li><li>  Der Hypervisor-Prozess √ºbersetzt den Befehl in einen Befehl f√ºr ein physisches Ger√§t, wodurch er unter anderem sicherer wird. <br></li><li>  Der physische Ger√§tetreiber akzeptiert den ge√§nderten Befehl und leitet ihn an das physische Ger√§t selbst weiter. <br></li><li>  Die Ausf√ºhrungsergebnisse des Befehls kehren auf demselben Pfad zur√ºck. <br></li></ol><br>  Der Vorteil der √úbersetzung besteht darin, dass wir jedes Ger√§t emulieren k√∂nnen und keine spezielle Vorbereitung des Betriebssystemkerns erforderlich ist.  Dies geht jedoch zu Lasten der Leistung. <br><br>  Hardware-Virtualisierung.  In diesem Fall empf√§ngt ein Ger√§t Befehle vom Betriebssystem auf Hardwareebene.  Dies ist die schnellste und insgesamt beste Methode.  Leider unterst√ºtzen dies nicht alle physischen Ger√§te, Hypervisoren und Gastbetriebssysteme.  Derzeit sind die Hauptger√§te, die die Hardwarevirtualisierung unterst√ºtzen, CPUs. <br><br>  Paravirtualisierung.  Die h√§ufigste Option f√ºr die Ger√§tevirtualisierung auf einer KVM und die am weitesten verbreitete Art der Virtualisierung f√ºr Gastbetriebssysteme.  Das Hauptmerkmal besteht darin, dass es mit einigen Hypervisor-Subsystemen (z. B. Netzwerk- oder Laufwerksstapel) funktioniert und Speicherseiten mithilfe einer Hypervisor-API zuweist, ohne Befehle auf niedriger Ebene zu √ºbersetzen.  Der Nachteil dieser Virtualisierungsmethode ist die Notwendigkeit, den Kernel des Gastbetriebssystems zu √§ndern, um die Interaktion mit dem Hypervisor unter Verwendung derselben API zu erm√∂glichen.  Die h√§ufigste L√∂sung f√ºr dieses Problem besteht darin, spezielle Treiber im Gastbetriebssystem zu installieren.  In einer KVM wird diese API als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virtio-API bezeichnet</a> . <br><br>  Bei Verwendung der Paravirtualisierung ist der Pfad zum physischen Ger√§t viel k√ºrzer als in F√§llen, in denen die √úbersetzung verwendet wird, da Befehle direkt von der VM an den Hypervisor-Prozess auf dem Host gesendet werden.  Dies beschleunigt die Ausf√ºhrung aller Anweisungen innerhalb der VM.  In einer KVM ist daf√ºr eine virtio-API verantwortlich.  Es funktioniert nur f√ºr einige Ger√§te wie Netzwerk- und Laufwerksadapter.  Aus diesem Grund werden virtio-Treiber auf VMs installiert. <br><br>  Die Kehrseite einer solchen Beschleunigung ist, dass nicht alle in einer VM ausgef√ºhrten Prozesse innerhalb der VM bleiben.  Dies f√ºhrt zu einer Reihe von Effekten, die zu Diebstahl f√ºhren k√∂nnen.  Wenn Sie mehr erfahren m√∂chten, beginnen Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer API f√ºr virtuelle E / A: virtio</a> . <br><br><h4>  2.3.  Faire Planung </h4><br>  Eine VM auf einem Hypervisor ist in der Tat ein regul√§rer Prozess, der in einem Linux-Kernel Planungsgesetzen (Ressourcenverteilung zwischen Prozessen) unterliegt.  Schauen wir uns das genauer an. <br><br>  Linux verwendet den sogenannten CFS (Completely Fair Scheduler), der mit Kernel 2.6.23 zum Standard wurde.  Lesen Sie die Linux-Kernel-Architektur oder den Quellcode, um einen √úberblick √ºber diesen Algorithmus zu erhalten.  Die Essenz von CFS liegt in der Verteilung der CPU-Zeit zwischen Prozessen, abh√§ngig von ihrer Laufzeit.  Je mehr CPU-Zeit ein Prozess ben√∂tigt, desto weniger CPU-Zeit wird ben√∂tigt.  Dies garantiert die "faire" Ausf√ºhrung aller Prozesse und hilft zu vermeiden, dass ein Prozess st√§ndig alle Prozessoren beansprucht, und erm√∂glicht auch die Ausf√ºhrung anderer Prozesse. <br><br>  Manchmal f√ºhrt dieses Paradigma zu interessanten Artefakten.  Langj√§hrige Linux-Benutzer werden sich zweifellos daran erinnern, wie ein normaler Texteditor auf dem Desktop einfrieren w√ºrde, wenn ressourcenintensive Anwendungen wie ein Compiler ausgef√ºhrt werden.  Dies geschah, weil ressourcenarme Aufgaben wie Desktopanwendungen mit Aufgaben konkurrierten, die viele Ressourcen verwendeten, wie z. B. ein Compiler.  CFS h√§lt dies f√ºr unfair und stoppt daher von Zeit zu Zeit den Texteditor und l√§sst die CPU die Compiler-Aufgaben verarbeiten.  Dies wurde mit dem Mechanismus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sched_autogroup behoben</a> .  Es gibt jedoch viele andere Besonderheiten der CPU-Zeitverteilung.  In diesem Artikel geht es nicht wirklich darum, wie schlecht CFS ist.  Es ist eher ein Versuch, die Aufmerksamkeit auf die Tatsache zu lenken, dass eine "faire" Verteilung der CPU-Zeit nicht die trivialste Aufgabe ist. <br><br>  Ein weiterer wichtiger Aspekt eines Schedulers ist die Vorauszahlung.  Dies ist erforderlich, um die CPU von √ºberlasteten Prozessen zu befreien und anderen die Arbeit zu erm√∂glichen.  Dies wird als <i>Kontextumschaltung bezeichnet</i> .  Der gesamte Aufgabenkontext bleibt erhalten: Stapelstatus, Register usw. Danach muss der Prozess warten und wird durch einen anderen Prozess ersetzt.  Dies ist eine teure Operation f√ºr ein Betriebssystem.  Es wird selten benutzt, aber es ist √ºberhaupt nicht schlecht.  H√§ufiges Wechseln des Kontexts kann ein Indikator f√ºr ein Betriebssystemproblem sein, tritt jedoch normalerweise kontinuierlich auf und ist kein Anzeichen f√ºr ein bestimmtes Problem. <br><br>  Dieser lange Diskurs war notwendig, um eine Tatsache zu erkl√§ren: In einem fairen Linux-Scheduler wird der Prozess umso schneller gestoppt, je mehr CPU-Ressourcen der Prozess verbraucht, damit andere Prozesse funktionieren k√∂nnen.  Ob dies richtig ist oder nicht, ist eine komplexe Frage, und die L√∂sung ist je nach Belastung unterschiedlich.  Bis vor kurzem priorisierte Windows Scheduler Desktop-Anwendungen, was zu langsameren Hintergrundprozessen f√ºhrte.  In Sun Solaris gab es f√ºnf verschiedene Scheduler-Klassen.  Bei der Einf√ºhrung der Virtualisierung wurde ein weiterer hinzugef√ºgt, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fair Share Scheduler</a> , da die anderen mit der Solaris Zones-Virtualisierung nicht ordnungsgem√§√ü ausgef√ºhrt wurden.  Um dies n√§her zu untersuchen, empfehle ich, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solaris Internals: Solaris 10 und OpenSolaris Kernel Architecture zu beginnen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Linux-Kernel zu verstehen</a> . <br><br><h4>  2.4.  Wie k√∂nnen wir den <i>Diebstahl</i> √ºberwachen? </h4><br>  Wie bei jeder anderen CPU-Metrik ist es einfach, den <i>Diebstahl</i> innerhalb einer VM zu √ºberwachen.  Sie k√∂nnen jedes CPU-Metrik-Messwerkzeug verwenden.  Die Hauptsache ist, dass die VM unter Linux sein muss.  Aus irgendeinem Grund stellt Windows dem Benutzer solche Informationen nicht zur Verf√ºgung.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/9f8/5b1/fff9f85b10523ddaecfc176f1fa18f33.png"><br>  <i>Top-Ausgabe: Angabe der CPU-Auslastung mit Steal in der rechten Spalte</i> <br><br>  Beim Versuch, diese Informationen von einem Hypervisor abzurufen, werden die Dinge kompliziert.  Sie k√∂nnen versuchen, <i>Steal</i> auf einem Host-Computer vorherzusagen, z. B. mit Load Average (LA).  Dies ist der Durchschnittswert der Anzahl der Prozesse in der Ausf√ºhrungswarteschlange.  Die Berechnungsmethode f√ºr diesen Parameter ist nicht einfach. Wenn jedoch eine LA, die gem√§√ü der Anzahl der CPU-Threads standardisiert wurde, gr√∂√üer als 1 ist, bedeutet dies, dass der Linux-Server √ºberlastet ist. <br><br>  Worauf warten all diese Prozesse?  Offensichtlich die CPU.  Diese Antwort ist jedoch nicht ganz richtig, da manchmal die CPU frei und die LA viel zu hoch ist.  Denken Sie daran, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dass NFS f√§llt und LA gleichzeitig steigt</a> .  Eine √§hnliche Situation kann beim Laufwerk und anderen Ein- / Ausgabeger√§ten auftreten.  Tats√§chlich warten die Prozesse m√∂glicherweise auf das Ende einer Sperre: physisch (bezogen auf Eingabe- / Ausgabeger√§te) oder logisch (z. B. ein Mutex-Objekt).  Gleiches gilt f√ºr Sperren auf Hardwareebene (z. B. Festplattenantwort) oder Sperren auf Logikebene (sogenannte "Sperrprimitive"), zu denen eine Reihe von Entit√§ten, Mutex Adaptive und Spin, Semaphoren, Bedingungsvariablen, RW-Sperren, geh√∂ren. IPC-Sperren ...). <br><br>  Ein weiteres Merkmal von LA ist, dass es als Durchschnittswert innerhalb des Betriebssystems berechnet wird.  Wenn beispielsweise 100 Prozesse um eine Datei konkurrieren, betr√§gt die LA 50. Diese gro√üe Anzahl l√§sst den Eindruck entstehen, dass dies f√ºr das Betriebssystem schlecht ist.  Bei schlecht geschriebenem Code kann dies jedoch normal sein.  Nur dieser spezifische Code w√§re schlecht, und der Rest des Betriebssystems k√∂nnte in Ordnung sein. <br><br>  Aufgrund dieser Mittelung (f√ºr weniger als eine Minute) ist es nicht die beste Idee, mithilfe eines LA etwas zu bestimmen, da dies in einigen F√§llen zu √§u√üerst mehrdeutigen Ergebnissen f√ºhren kann.  Wenn Sie versuchen, mehr dar√ºber herauszufinden, werden Sie feststellen, dass Wikipedia und andere verf√ºgbare Ressourcen nur den einfachsten Fall beschreiben und der Prozess nicht im Detail beschrieben wird.  Wenn Sie daran interessiert sind, besuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> erneut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brendann Gregg</a> und folgen Sie den Links. <br><br><h2>  3. Spezialeffekte </h2><br>  Kommen wir nun zu den Hauptf√§llen von <i>Diebstahl</i> , auf die wir gesto√üen sind.  Lassen Sie mich erkl√§ren, wie sie sich aus den oben genannten Ergebnissen ergeben und wie sie mit Hypervisor-Metriken korrelieren. <br><br>  √úberlastung.  Der einfachste und h√§ufigste Fall: Der Hypervisor wird √ºberlastet.  In der Tat ist bei vielen VMs, die viele CPU-Ressourcen ausf√ºhren und verbrauchen, die Konkurrenz hoch und die Auslastung gem√§√ü LA gr√∂√üer als 1 (standardisiert gem√§√ü CPU-Threads).  Alles bleibt in allen VMs zur√ºck.  <i>Der</i> vom Hypervisor gesendete Diebstahl w√§chst ebenfalls.  Sie m√ºssen die Last neu verteilen oder etwas ausschalten.  Im Gro√üen und Ganzen ist das alles logisch und unkompliziert. <br><br>  Paravirtualisierung gegen einzelne Instanzen.  Es gibt nur eine VM auf einem Hypervisor.  Die VM verbraucht einen kleinen Teil davon, bietet jedoch eine hohe Eingabe- / Ausgabelast, z. B. f√ºr ein Laufwerk.  Unerwarteterweise tritt ein kleiner <i>Diebstahl</i> von weniger als 10% auf (wie einige der von uns durchgef√ºhrten Tests zeigen). <br><br>  Dies ist ein merkw√ºrdiger Fall.  Hier wird <i>Steal</i> aufgrund von Sperren auf der Ebene der paravirtualisierten Ger√§te angezeigt.  Innerhalb der VM wird ein Haltepunkt erstellt.  Dies wird vom Treiber verarbeitet und geht an den Hypervisor.  Aufgrund der Haltepunktverarbeitung auf dem Hypervisor sieht die VM dies als gesendete Anforderung.  Es ist betriebsbereit und wartet auf die CPU, erh√§lt jedoch keine CPU-Zeit.  Die VM glaubt, dass die Zeit gestohlen wurde. <br><br>  Dies geschieht, wenn der Puffer gesendet wird.  Es geht in den Kernelbereich des Hypervisors und wir warten darauf.  Aus Sicht der VM sollte sie sofort zur√ºckkehren.  Daher wird diese Zeit gem√§√ü unserem <i>Diebstahlberechnungsalgorithmus</i> als gestohlen betrachtet.  Es ist wahrscheinlich, dass andere Mechanismen daran beteiligt sind (z. B. die Verarbeitung anderer <i>Systemaufrufe</i> ), sie sollten sich jedoch nicht wesentlich unterscheiden. <br><br>  Scheduler gegen hoch geladene VMs.  Wenn eine VM mehr als die anderen <i>stiehlt</i> , ist dies direkt mit dem Scheduler verbunden.  Je h√∂her die Last ist, die ein Prozess auf eine CPU aus√ºbt, desto schneller wird sie von einem Scheduler verworfen, damit andere Prozesse funktionieren k√∂nnen.  Wenn die VM wenig verbraucht, wird sie fast nicht <i>gestohlen.</i>  Sein Prozess hat nur gesessen und gewartet, und es muss mehr Zeit gegeben werden.  Wenn die VM alle Kerne maximal belastet, wird der Prozess h√§ufiger weggeworfen und der VM wird weniger Zeit einger√§umt. <br><br>  Es ist noch schlimmer, wenn Prozesse innerhalb der VM versuchen, mehr CPU zu erhalten, weil sie die Daten nicht verarbeiten k√∂nnen.  Dann bietet das Betriebssystem auf dem Hypervisor aufgrund der fairen Optimierung weniger CPU-Zeit.  Dieser Prozess verarbeitet Schneeb√§lle und <i>stiehlt</i> Wellen in die H√∂he, w√§hrend andere VMs dies m√∂glicherweise nicht einmal bemerken.  Je mehr Kerne vorhanden sind, desto schlimmer ist es f√ºr die ungl√ºckliche VM.  Kurz gesagt, hoch ausgelastete VMs mit vielen Kernen leiden am meisten. <br><br>  Low LA aber <i>stehlen</i> ist vorhanden.  Wenn der LA ungef√§hr 0,7 betr√§gt (was bedeutet, dass der Hypervisor unterlastet zu sein scheint), aber einige VMs <i>stehlen</i> : <br><br><ul><li>  Es gilt das oben genannte Paravirtualisierungsbeispiel.  Die VM empf√§ngt m√∂glicherweise Metriken, die auf <i>Diebstahl</i> hinweisen, w√§hrend der Hypervisor keine Probleme hat.  Nach den Ergebnissen unserer Tests √ºberschreitet ein solcher <i>Diebstahl in der</i> Regel nicht 10% und hat keinen wesentlichen Einfluss auf die Anwendungsleistung innerhalb der VM. <br></li><li>  Der LA-Parameter wurde falsch berechnet.  Genauer gesagt wurde es zu einem bestimmten Zeitpunkt korrekt berechnet, aber bei der Mittelwertbildung ist es niedriger als es f√ºr eine Minute sein sollte.  Wenn beispielsweise eine VM (ein Drittel des Hypervisors) 30 Sekunden lang alle CPUs verbraucht, betr√§gt die LA f√ºr eine Minute 0,15.  Vier solcher VMs, die gleichzeitig arbeiten, ergeben einen Wert von 0,6.  Basierend auf der LA k√∂nnten Sie nicht ableiten, dass der Diebstahl f√ºr 30 Sekunden f√ºr jeden von ihnen fast 25% betrug. <br></li><li>  Dies geschah wiederum aufgrund des Planers, der entschied, dass jemand zu viel "a√ü" und ihn warten lie√ü.  In der Zwischenzeit wird der Kontext gewechselt, Haltepunkte verarbeitet und andere wichtige Systemangelegenheiten behandelt.  Infolgedessen treten bei einigen VMs keine Probleme auf, bei anderen treten erhebliche Leistungsverluste auf. <br></li></ul><br><h2>  4. Andere Verzerrungen </h2><br>  Es gibt eine Million m√∂gliche Gr√ºnde f√ºr eine Verzerrung der fairen CPU-Zeitzuweisung auf einer VM.  Zum Beispiel erh√∂hen Hyperthreading und NUMA die Komplexit√§t der Berechnungen.  Sie erschweren die Auswahl des Kerns, der zum Ausf√ºhren eines Prozesses verwendet wird, da ein Scheduler Koeffizienten verwendet.  das hei√üt Gewichte, die die Berechnungen beim Kontextwechsel noch komplizierter machen. <br><br>  Es gibt Verzerrungen, die durch Technologien wie Turbo Boost oder den entgegengesetzten Energiesparmodus entstehen und die CPU-Kerngeschwindigkeit und sogar die Zeitscheibe k√ºnstlich erh√∂hen oder verringern k√∂nnen.  Wenn Sie Turbo Boost aktivieren, wird die Produktivit√§t eines CPU-Threads aufgrund einer Leistungssteigerung in einem anderen verringert.  In diesem Moment werden keine Informationen zur aktuellen CPU-Taktrate an die VM gesendet, die denkt, dass jemand seine Zeit stiehlt (z. B. 2 GHz angefordert und halb so viel erhalten). <br><br>  In der Tat kann es viele Gr√ºnde f√ºr Verzerrungen geben.  M√∂glicherweise finden Sie in einem bestimmten System etwas ganz anderes.  Ich empfehle, mit den oben verlinkten B√ºchern zu beginnen und Statistiken vom Hypervisor mit Tools wie perf, sysdig, systemtap und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dutzenden anderen zu erhalten</a> . <br><br><h2>  5. Schlussfolgerungen </h2><br><ol><li>  Einige <i>Steals</i> k√∂nnen aufgrund von Paravirtualisierung auftreten und dies kann als normal angesehen werden.  Online-Quellen sagen, dass dieser Wert 5-10% betragen kann.  Dies h√§ngt von der Anwendung in einer VM und der Belastung der physischen Ger√§te durch die VM ab.  Es ist wichtig zu beachten, wie sich Anwendungen in einer VM anf√ºhlen. <br></li><li>  Die Korrelation zwischen der Belastung des Hypervisors und dem <i>Diebstahl</i> innerhalb einer VM ist nicht immer sicher.  Beide <i>Diebstahlberechnungen</i> k√∂nnen in einigen F√§llen und mit unterschiedlichen Belastungen falsch sein. <br></li><li>  Scheduler bevorzugt keine Prozesse, die viele Ressourcen erfordern.  Es versucht, denen, die mehr verlangen, weniger zu geben.  Gro√üe Instanzen sind gemein. <br></li><li>  Ein kleiner <i>Diebstahl</i> kann auch ohne Paravirtualisierung normal sein (unter Ber√ºcksichtigung der Last innerhalb der VM, der Besonderheiten der Last der Nachbarn, der Verteilung der Last zwischen den Threads und anderer Faktoren). <br></li><li>  Wenn Sie den <i>Diebstahl</i> in einem bestimmten System berechnen m√∂chten, untersuchen Sie die verschiedenen M√∂glichkeiten, sammeln Sie Metriken, analysieren Sie sie gr√ºndlich und √ºberlegen Sie, wie Sie die Last fair verteilen k√∂nnen.  Unabh√§ngig davon kann es zu Abweichungen kommen, die mithilfe von Tests √ºberpr√ºft oder in einem Kernel-Debugger angezeigt werden m√ºssen. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453140/">https://habr.com/ru/post/de453140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453126/index.html">UIAppearance war nicht so einfach</a></li>
<li><a href="../de453128/index.html">Telecom Digest: 15 Expertenmaterialien zu IPv6, IS, Standards und Gesetzen in der IT</a></li>
<li><a href="../de453130/index.html">Systematische Korrekturcodes. Linearer Gruppencode</a></li>
<li><a href="../de453136/index.html">Schrieb API - brach XML (zwei)</a></li>
<li><a href="../de453138/index.html">Kunst und Wissenschaft: VITAE-Projekt - viele Palmendrucke auf einer Mondblume</a></li>
<li><a href="../de453146/index.html">So holen Sie das Beste aus einer Konferenz heraus</a></li>
<li><a href="../de453148/index.html">AirBnb vernachl√§ssigt seine Konten</a></li>
<li><a href="../de453154/index.html">Internet-Verlauf: Verbesserung der Interaktivit√§t</a></li>
<li><a href="../de453156/index.html">General Motors wird all seinen neuen Autos eine Seele geben (digitale H√ºlle)</a></li>
<li><a href="../de453158/index.html">Ich wusste nicht, wie Prozessoren funktionieren, also schrieb ich einen Software-Simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>