<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👖 👨‍❤️‍👨 🤰🏻 MVCC dans PostgreSQL-4. Instantanés 👩🏽‍🤝‍👨🏼 👩🏾‍🌾 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après avoir discuté des problèmes d' isolement et avoir fait une digression concernant la structure des données de bas niveau , la dernière fois nous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-4. Instantanés</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Après avoir discuté <a href="https://habr.com/ru/company/postgrespro/blog/467437/">des</a> problèmes d' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> et avoir fait une digression concernant la <a href="https://habr.com/ru/company/postgrespro/blog/469087/">structure des données de bas niveau</a> , la dernière fois nous avons exploré les <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versions des lignes</a> et observé comment différentes opérations ont changé les champs d'en-tête de tuple. <br><br>  Nous allons maintenant voir comment des instantanés de données cohérents sont obtenus à partir de tuples. <br><br><h1>  Qu'est-ce qu'un instantané de données? </h1><br>  Les pages de données peuvent contenir physiquement plusieurs versions de la même ligne.  Mais chaque transaction ne doit voir qu'une (ou aucune) version de chaque ligne, de sorte que toutes constituent une image cohérente des données (au sens d'ACID) à partir d'un certain moment. <br><br>  L'isolement dans PosgreSQL est basé sur des instantanés: chaque transaction fonctionne avec son propre instantané de données, qui "contient" les données qui ont été validées avant le moment où l'instantané a été créé et ne "contient" pas de données qui n'ont pas encore été validées à ce moment-là.  Nous avons <a href="https://habr.com/ru/company/postgrespro/blog/467437/">déjà vu</a> que, bien que l'isolement résultant semble plus strict que requis par la norme, il présente toujours des anomalies. <br><a name="habracut"></a><br>  Au niveau d'isolement de lecture validée, un instantané est créé au début de chaque instruction de transaction.  Cet instantané est actif pendant l'exécution de l'instruction.  Sur la figure, le moment où l'instantané a été créé (qui, comme nous le rappelons, est déterminé par l'ID de transaction) est affiché en bleu. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  Aux niveaux de lecture répétable et de sérialisation, l'instantané est créé une fois, au début de la première instruction de transaction.  Un tel instantané reste actif jusqu'à la fin de la transaction. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilité des tuples dans un instantané </h1><br><h2>  Règles de visibilité </h2><br>  Un instantané n'est certainement pas une copie physique de tous les tuples nécessaires.  Un instantané est en fait spécifié par plusieurs nombres, et la visibilité des tuples dans un instantané est déterminée par des règles. <br><br>  Le fait qu'un tuple soit visible ou non dans un instantané dépend de deux champs dans l'en-tête, à savoir <code>xmin</code> et <code>xmax</code> , c'est-à-dire les ID des transactions qui ont créé et supprimé le tuple.  Des intervalles comme celui-ci ne se chevauchent pas et, par conséquent, pas plus d'une version représente une ligne dans chaque instantané. <br><br>  Les règles de visibilité exactes sont assez compliquées et prennent en compte de nombreux cas et extrêmes différents. <br><blockquote>  Vous pouvez facilement vous en assurer en consultant src / backend / utils / time / tqual.c (dans la version 12, la vérification a été déplacée vers src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Pour simplifier, nous pouvons dire qu'un tuple est visible lorsque dans l'instantané, les modifications apportées par la transaction <code>xmin</code> sont visibles, tandis que celles apportées par la transaction <code>xmax</code> ne le sont pas (en d'autres termes, il est déjà clair que le tuple a été créé, mais on ne sait pas encore s'il a été supprimé). <br><br>  En ce qui concerne une transaction, ses modifications sont visibles dans l'instantané, que ce soit cette transaction qui a créé l'instantané (il voit ses propres modifications non encore validées) ou la transaction a été validée avant la création de l'instantané. <br><br>  Nous pouvons représenter graphiquement les transactions par segments (de l'heure de début à l'heure de validation): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Ici: <br><br><ul><li>  Les modifications de la transaction 2 seront visibles car elles ont été effectuées avant la création de l'instantané. </li><li>  Les modifications de la transaction 1 ne seront pas visibles car elle était active au moment de la création de l'instantané. </li><li>  Les modifications de la transaction 3 ne seront pas visibles car elles ont démarré après la création de l'instantané (qu'elle soit terminée ou non). </li></ul><br>  Malheureusement, le système ignore le temps de validation des transactions.  Seule son heure de début est connue (qui est déterminée par l'ID de la transaction et marquée d'un trait pointillé dans les figures ci-dessus), mais l'événement d'achèvement n'est écrit nulle part. <br><br>  Tout ce que nous pouvons faire est de connaître l'état <em>actuel</em> des transactions lors de la création de l'instantané.  Ces informations sont disponibles dans la mémoire partagée du serveur, dans la structure ProcArray, qui contient la liste de toutes les sessions actives et de leurs transactions. <br><br>  Mais nous ne pourrons pas déterminer a posteriori si une certaine transaction était active au moment de la création de l'instantané.  Par conséquent, un instantané doit stocker une liste de toutes les transactions actives en cours. <br><br>  De ce qui précède, il s'ensuit que dans PostgreSQL, il n'est pas possible de créer un instantané qui montre des données cohérentes à partir d'un certain temps en arrière, <em>même si</em> tous les tuples nécessaires sont disponibles dans les pages de table.  La question se pose souvent de savoir pourquoi PostgreSQL manque de requêtes rétrospectives (ou temporelles; ou flashback, comme Oracle les appelle) - et c'est l'une des raisons. <br><blockquote>  Ce qui est amusant, c'est que cette fonctionnalité a d'abord été disponible, puis supprimée du SGBD.  Vous pouvez lire à ce sujet dans l' <a href="https://arxiv.org/pdf/1901.01973.pdf">article de Joseph M. Hellerstein</a> . <br></blockquote><br>  Ainsi, l'instantané est déterminé par plusieurs paramètres: <br><br><ul><li>  Au moment où l'instantané a été créé, plus exactement, l'ID de la transaction suivante, mais non disponible dans le système ( <code>snapshot.xmax</code> ). </li><li>  La liste des transactions actives (en cours) au moment de la création de l' <code>snapshot.xip</code> ( <code>snapshot.xip</code> ). </li></ul><br>  Pour plus de commodité et d'optimisation, l'ID de la première transaction active est également stocké ( <code>snapshot.xmin</code> ).  Cette valeur a un sens important, qui sera discuté ci-dessous. <br><br>  L'instantané stocke également quelques paramètres supplémentaires, qui ne sont toutefois pas importants pour nous. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Exemple </h2><br>  Pour comprendre comment l'instantané détermine la visibilité, reproduisons l'exemple ci-dessus avec trois transactions.  Le tableau comportera trois lignes, où: <br><br><ul><li>  Le premier a été ajouté par une transaction qui a commencé avant la création de l'instantané mais s'est terminée après celle-ci. </li><li>  Le second a été ajouté par une transaction qui a commencé et s'est terminée avant la création de l'instantané. </li><li>  Le troisième a été ajouté après la création de l'instantané. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  La première transaction (pas encore terminée): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  La deuxième transaction (terminée avant la création de l'instantané): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Création d'un instantané dans une transaction dans une autre session. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Validation de la première transaction après la création de l'instantané: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et la troisième transaction (apparue après la création de l'instantané): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  De toute évidence, une seule ligne est encore visible dans notre instantané: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  La question est de savoir comment Postgres comprend cela. <br><br>  Tout est déterminé par l'instantané.  Regardons ça: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Ici <code>snapshot.xmin</code> , <code>snapshot.xmax</code> et <code>snapshot.xip</code> sont répertoriés, délimités par deux points ( <code>snapshot.xip</code> est un nombre dans ce cas, mais en général c'est une liste). <br><br>  Selon les règles ci-dessus, dans l'instantané, ces modifications doivent être visibles et effectuées par des transactions avec des ID <code>xid</code> tels que <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> sauf celles qui figurent sur la liste <code>snapshot.xip</code> .  Regardons toutes les lignes du tableau (dans le nouvel instantané): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  La première ligne n'est pas visible: elle a été créée par une transaction qui figure sur la liste des transactions actives ( <code>xip</code> ). <br>  La deuxième ligne est visible: elle a été créée par une transaction qui se trouve dans la plage des instantanés. <br>  La troisième ligne n'est pas visible: elle a été créée par une transaction hors de la plage des instantanés. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Modifications propres à la transaction </h1><br>  La détermination de la visibilité des changements de la transaction complique quelque peu la situation.  Dans ce cas, il peut être nécessaire de ne voir qu'une partie de ces modifications.  Par exemple: à n'importe quel niveau d'isolement, un curseur ouvert à un certain moment ne doit pas voir les modifications effectuées plus tard. <br><br>  À cette fin, un en-tête de tuple a un champ spécial (représenté dans les pseudo-colonnes <code>cmin</code> et <code>cmax</code> ), qui indique le numéro de commande à l'intérieur de la transaction.  <code>cmin</code> est le nombre pour l'insertion et <code>cmax</code> - pour la suppression, mais pour économiser de l'espace dans l'en-tête du tuple, il s'agit en fait d'un champ plutôt que de deux champs différents.  Il est supposé qu'une transaction insère et supprime rarement la même ligne. <br><br>  Mais si cela se produit, un identifiant de commande combo spécial ( <code>combocid</code> ) est inséré dans le même champ et le processus d'arrière-plan se souvient des <code>cmin</code> et <code>cmax</code> pour ce <code>combocid</code> .  Mais c'est totalement exotique. <br><br>  Voici un exemple simple.  Commençons une transaction et ajoutons une ligne au tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Sortons le contenu de la table, ainsi que le champ <code>cmin</code> (mais uniquement pour les lignes ajoutées par la transaction - pour d'autres, cela n'a aucun sens): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Maintenant, nous ouvrons un curseur pour une requête qui renvoie le nombre de lignes dans la table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Et après cela, nous ajoutons une autre ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  La requête renvoie 4 - la ligne ajoutée après l'ouverture du curseur n'entre pas dans l'instantané des données: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Pourquoi?  Parce que l'instantané ne prend en compte que les tuples avec <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizon de l'événement </h1><br>  L'ID de la première transaction active ( <code>snapshot.xmin</code> ) a un sens important: il détermine «l'horizon des événements» de la transaction.  Autrement dit, au-delà de son horizon, la transaction ne voit toujours que des versions de ligne à jour. <br><br>  En réalité, une version de ligne obsolète (morte) ne doit être visible que lorsque la version à jour a été créée par une transaction non encore terminée et n'est donc pas encore visible.  Mais toutes les transactions "au-delà de l'horizon" sont définitivement réalisées. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Vous pouvez voir l'horizon de transaction dans le catalogue système: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Nous pouvons également définir l'horizon au niveau de la base de données.  Pour ce faire, nous devons prendre tous les instantanés actifs et trouver le plus ancien <code>xmin</code> parmi eux.  Et il définira l'horizon, au-delà duquel les tuples morts dans la base de données ne seront jamais visibles pour aucune transaction.  <em>De tels tuples peuvent être aspirés</em> - et c'est exactement pourquoi le concept d'horizon est si important d'un point de vue pratique. <br><br>  Si une certaine transaction contient un instantané pendant une longue période, elle tiendra également l'horizon de la base de données.  De plus, la simple existence d'une transaction inachevée tiendra l'horizon même si la transaction elle-même ne contient pas l'instantané. <br><br>  Et cela signifie que les tuples morts dans la base de données ne peuvent pas être aspirés.  De plus, il est possible qu'une transaction "longue durée" ne se croise pas du tout avec des données avec d'autres transactions, mais cela n'a pas vraiment d'importance car tous partagent un horizon de base de données. <br><br>  Si nous faisons maintenant un segment représenter des instantanés (de <code>snapshot.xmin</code> à <code>snapshot.xmax</code> ) plutôt que des transactions, nous pouvons visualiser la situation comme suit: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  Dans cette figure, l'instantané le plus bas se rapporte à une transaction non terminée et dans les autres instantanés, <code>snapshot.xmin</code> ne peut pas être supérieur à l'ID de transaction. <br><br>  Dans notre exemple, la transaction a été lancée avec le niveau d'isolement Read Committed.  Même s'il n'a aucun instantané de données actif, il continue de tenir l'horizon: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Et ce n'est qu'après la finalisation de la transaction que l'horizon avance, ce qui permet d'aspirer les tuples morts: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Dans le cas où la situation décrite cause vraiment des problèmes et qu'il n'y a aucun moyen de la contourner au niveau de l'application, deux paramètres sont disponibles à partir de la version 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> détermine la durée de vie maximale de l'instantané.  Une fois ce temps écoulé, le serveur pourra aspirer les tuples morts, et si une transaction "longue durée" en a encore besoin, il obtiendra une erreur "instantané trop ancien". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> détermine la durée de vie maximale d'une transaction inactive.  Une fois ce délai écoulé, la transaction s'interrompt. </li></ul><br><h1>  Exportation d'instantanés </h1><br>  Parfois, des situations surviennent où plusieurs transactions simultanées doivent être garanties pour voir les mêmes données.  Un exemple est un utilitaire <code>pg_dump</code> , qui peut fonctionner en mode parallèle: tous les processus de travail doivent voir la base de données dans le même état pour que la copie de sauvegarde soit cohérente. <br><br>  Bien sûr, nous ne pouvons pas nous fier à la conviction que les transactions verront les mêmes données simplement parce qu'elles ont été démarrées "simultanément".  À cette fin, l'exportation et l'importation d'un instantané sont disponibles. <br><br>  La fonction <code>pg_export_snapshot</code> renvoie l'ID d'instantané, qui peut être transmis à une autre transaction (à l'aide d'outils en dehors du SGBD). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  L'autre transaction peut importer l'instantané à l'aide de la commande SET TRANSACTION SNAPSHOT avant d'effectuer sa première requête.  Le niveau d'isolement Lecture répétable ou Sérialisable doit également être spécifié avant car au niveau Lecture validée, les instructions utiliseront leurs propres instantanés. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  La deuxième transaction fonctionnera désormais avec l'instantané de la première et, par conséquent, affichera trois lignes (plutôt que zéro): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  La durée de vie d'un instantané exporté est identique à la durée de vie de la transaction d'exportation. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Continuez à lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479512/">https://habr.com/ru/post/fr479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479498/index.html">Comment le temps linéaire se transforme en Windows en O (n²)</a></li>
<li><a href="../fr479502/index.html">Comment survivre à la période glaciaire la plus sévère de l'histoire de la Terre?</a></li>
<li><a href="../fr479504/index.html">Créer un client léger RDP basé sur Raspberry Pi</a></li>
<li><a href="../fr479508/index.html">PostgreSQL Antipatterns: JOIN et OR nuisibles</a></li>
<li><a href="../fr479510/index.html">PocketBook X Review - un énorme lecteur de 10,3 pouces avec un écran E Ink Carta Mobius et un boîtier métallique</a></li>
<li><a href="../fr479514/index.html">Confidentialité par conception et confidentialité par défaut (protection des données conçue et confidentialité par défaut par GDPR)</a></li>
<li><a href="../fr479516/index.html">Qu'est-ce que l'entropie dans un logiciel et comment le gérer?</a></li>
<li><a href="../fr479518/index.html">La communication au sein d'une équipe à distance est notre expérience</a></li>
<li><a href="../fr479522/index.html">Editeur Peter. Soldes d'hiver</a></li>
<li><a href="../fr479524/index.html">Service pour Active Restore ou l'histoire d'un projet industriel à Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>