<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëñ üë®‚Äç‚ù§Ô∏è‚Äçüë® ü§∞üèª MVCC dans PostgreSQL-4. Instantan√©s üë©üèΩ‚Äçü§ù‚Äçüë®üèº üë©üèæ‚Äçüåæ üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apr√®s avoir discut√© des probl√®mes d' isolement et avoir fait une digression concernant la structure des donn√©es de bas niveau , la derni√®re fois nous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-4. Instantan√©s</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Apr√®s avoir discut√© <a href="https://habr.com/ru/company/postgrespro/blog/467437/">des</a> probl√®mes d' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> et avoir fait une digression concernant la <a href="https://habr.com/ru/company/postgrespro/blog/469087/">structure des donn√©es de bas niveau</a> , la derni√®re fois nous avons explor√© les <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versions des lignes</a> et observ√© comment diff√©rentes op√©rations ont chang√© les champs d'en-t√™te de tuple. <br><br>  Nous allons maintenant voir comment des instantan√©s de donn√©es coh√©rents sont obtenus √† partir de tuples. <br><br><h1>  Qu'est-ce qu'un instantan√© de donn√©es? </h1><br>  Les pages de donn√©es peuvent contenir physiquement plusieurs versions de la m√™me ligne.  Mais chaque transaction ne doit voir qu'une (ou aucune) version de chaque ligne, de sorte que toutes constituent une image coh√©rente des donn√©es (au sens d'ACID) √† partir d'un certain moment. <br><br>  L'isolement dans PosgreSQL est bas√© sur des instantan√©s: chaque transaction fonctionne avec son propre instantan√© de donn√©es, qui "contient" les donn√©es qui ont √©t√© valid√©es avant le moment o√π l'instantan√© a √©t√© cr√©√© et ne "contient" pas de donn√©es qui n'ont pas encore √©t√© valid√©es √† ce moment-l√†.  Nous avons <a href="https://habr.com/ru/company/postgrespro/blog/467437/">d√©j√† vu</a> que, bien que l'isolement r√©sultant semble plus strict que requis par la norme, il pr√©sente toujours des anomalies. <br><a name="habracut"></a><br>  Au niveau d'isolement de lecture valid√©e, un instantan√© est cr√©√© au d√©but de chaque instruction de transaction.  Cet instantan√© est actif pendant l'ex√©cution de l'instruction.  Sur la figure, le moment o√π l'instantan√© a √©t√© cr√©√© (qui, comme nous le rappelons, est d√©termin√© par l'ID de transaction) est affich√© en bleu. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  Aux niveaux de lecture r√©p√©table et de s√©rialisation, l'instantan√© est cr√©√© une fois, au d√©but de la premi√®re instruction de transaction.  Un tel instantan√© reste actif jusqu'√† la fin de la transaction. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilit√© des tuples dans un instantan√© </h1><br><h2>  R√®gles de visibilit√© </h2><br>  Un instantan√© n'est certainement pas une copie physique de tous les tuples n√©cessaires.  Un instantan√© est en fait sp√©cifi√© par plusieurs nombres, et la visibilit√© des tuples dans un instantan√© est d√©termin√©e par des r√®gles. <br><br>  Le fait qu'un tuple soit visible ou non dans un instantan√© d√©pend de deux champs dans l'en-t√™te, √† savoir <code>xmin</code> et <code>xmax</code> , c'est-√†-dire les ID des transactions qui ont cr√©√© et supprim√© le tuple.  Des intervalles comme celui-ci ne se chevauchent pas et, par cons√©quent, pas plus d'une version repr√©sente une ligne dans chaque instantan√©. <br><br>  Les r√®gles de visibilit√© exactes sont assez compliqu√©es et prennent en compte de nombreux cas et extr√™mes diff√©rents. <br><blockquote>  Vous pouvez facilement vous en assurer en consultant src / backend / utils / time / tqual.c (dans la version 12, la v√©rification a √©t√© d√©plac√©e vers src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Pour simplifier, nous pouvons dire qu'un tuple est visible lorsque dans l'instantan√©, les modifications apport√©es par la transaction <code>xmin</code> sont visibles, tandis que celles apport√©es par la transaction <code>xmax</code> ne le sont pas (en d'autres termes, il est d√©j√† clair que le tuple a √©t√© cr√©√©, mais on ne sait pas encore s'il a √©t√© supprim√©). <br><br>  En ce qui concerne une transaction, ses modifications sont visibles dans l'instantan√©, que ce soit cette transaction qui a cr√©√© l'instantan√© (il voit ses propres modifications non encore valid√©es) ou la transaction a √©t√© valid√©e avant la cr√©ation de l'instantan√©. <br><br>  Nous pouvons repr√©senter graphiquement les transactions par segments (de l'heure de d√©but √† l'heure de validation): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Ici: <br><br><ul><li>  Les modifications de la transaction 2 seront visibles car elles ont √©t√© effectu√©es avant la cr√©ation de l'instantan√©. </li><li>  Les modifications de la transaction 1 ne seront pas visibles car elle √©tait active au moment de la cr√©ation de l'instantan√©. </li><li>  Les modifications de la transaction 3 ne seront pas visibles car elles ont d√©marr√© apr√®s la cr√©ation de l'instantan√© (qu'elle soit termin√©e ou non). </li></ul><br>  Malheureusement, le syst√®me ignore le temps de validation des transactions.  Seule son heure de d√©but est connue (qui est d√©termin√©e par l'ID de la transaction et marqu√©e d'un trait pointill√© dans les figures ci-dessus), mais l'√©v√©nement d'ach√®vement n'est √©crit nulle part. <br><br>  Tout ce que nous pouvons faire est de conna√Ætre l'√©tat <em>actuel</em> des transactions lors de la cr√©ation de l'instantan√©.  Ces informations sont disponibles dans la m√©moire partag√©e du serveur, dans la structure ProcArray, qui contient la liste de toutes les sessions actives et de leurs transactions. <br><br>  Mais nous ne pourrons pas d√©terminer a posteriori si une certaine transaction √©tait active au moment de la cr√©ation de l'instantan√©.  Par cons√©quent, un instantan√© doit stocker une liste de toutes les transactions actives en cours. <br><br>  De ce qui pr√©c√®de, il s'ensuit que dans PostgreSQL, il n'est pas possible de cr√©er un instantan√© qui montre des donn√©es coh√©rentes √† partir d'un certain temps en arri√®re, <em>m√™me si</em> tous les tuples n√©cessaires sont disponibles dans les pages de table.  La question se pose souvent de savoir pourquoi PostgreSQL manque de requ√™tes r√©trospectives (ou temporelles; ou flashback, comme Oracle les appelle) - et c'est l'une des raisons. <br><blockquote>  Ce qui est amusant, c'est que cette fonctionnalit√© a d'abord √©t√© disponible, puis supprim√©e du SGBD.  Vous pouvez lire √† ce sujet dans l' <a href="https://arxiv.org/pdf/1901.01973.pdf">article de Joseph M. Hellerstein</a> . <br></blockquote><br>  Ainsi, l'instantan√© est d√©termin√© par plusieurs param√®tres: <br><br><ul><li>  Au moment o√π l'instantan√© a √©t√© cr√©√©, plus exactement, l'ID de la transaction suivante, mais non disponible dans le syst√®me ( <code>snapshot.xmax</code> ). </li><li>  La liste des transactions actives (en cours) au moment de la cr√©ation de l' <code>snapshot.xip</code> ( <code>snapshot.xip</code> ). </li></ul><br>  Pour plus de commodit√© et d'optimisation, l'ID de la premi√®re transaction active est √©galement stock√© ( <code>snapshot.xmin</code> ).  Cette valeur a un sens important, qui sera discut√© ci-dessous. <br><br>  L'instantan√© stocke √©galement quelques param√®tres suppl√©mentaires, qui ne sont toutefois pas importants pour nous. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Exemple </h2><br>  Pour comprendre comment l'instantan√© d√©termine la visibilit√©, reproduisons l'exemple ci-dessus avec trois transactions.  Le tableau comportera trois lignes, o√π: <br><br><ul><li>  Le premier a √©t√© ajout√© par une transaction qui a commenc√© avant la cr√©ation de l'instantan√© mais s'est termin√©e apr√®s celle-ci. </li><li>  Le second a √©t√© ajout√© par une transaction qui a commenc√© et s'est termin√©e avant la cr√©ation de l'instantan√©. </li><li>  Le troisi√®me a √©t√© ajout√© apr√®s la cr√©ation de l'instantan√©. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  La premi√®re transaction (pas encore termin√©e): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  La deuxi√®me transaction (termin√©e avant la cr√©ation de l'instantan√©): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Cr√©ation d'un instantan√© dans une transaction dans une autre session. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Validation de la premi√®re transaction apr√®s la cr√©ation de l'instantan√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et la troisi√®me transaction (apparue apr√®s la cr√©ation de l'instantan√©): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  De toute √©vidence, une seule ligne est encore visible dans notre instantan√©: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  La question est de savoir comment Postgres comprend cela. <br><br>  Tout est d√©termin√© par l'instantan√©.  Regardons √ßa: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Ici <code>snapshot.xmin</code> , <code>snapshot.xmax</code> et <code>snapshot.xip</code> sont r√©pertori√©s, d√©limit√©s par deux points ( <code>snapshot.xip</code> est un nombre dans ce cas, mais en g√©n√©ral c'est une liste). <br><br>  Selon les r√®gles ci-dessus, dans l'instantan√©, ces modifications doivent √™tre visibles et effectu√©es par des transactions avec des ID <code>xid</code> tels que <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> sauf celles qui figurent sur la liste <code>snapshot.xip</code> .  Regardons toutes les lignes du tableau (dans le nouvel instantan√©): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  La premi√®re ligne n'est pas visible: elle a √©t√© cr√©√©e par une transaction qui figure sur la liste des transactions actives ( <code>xip</code> ). <br>  La deuxi√®me ligne est visible: elle a √©t√© cr√©√©e par une transaction qui se trouve dans la plage des instantan√©s. <br>  La troisi√®me ligne n'est pas visible: elle a √©t√© cr√©√©e par une transaction hors de la plage des instantan√©s. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Modifications propres √† la transaction </h1><br>  La d√©termination de la visibilit√© des changements de la transaction complique quelque peu la situation.  Dans ce cas, il peut √™tre n√©cessaire de ne voir qu'une partie de ces modifications.  Par exemple: √† n'importe quel niveau d'isolement, un curseur ouvert √† un certain moment ne doit pas voir les modifications effectu√©es plus tard. <br><br>  √Ä cette fin, un en-t√™te de tuple a un champ sp√©cial (repr√©sent√© dans les pseudo-colonnes <code>cmin</code> et <code>cmax</code> ), qui indique le num√©ro de commande √† l'int√©rieur de la transaction.  <code>cmin</code> est le nombre pour l'insertion et <code>cmax</code> - pour la suppression, mais pour √©conomiser de l'espace dans l'en-t√™te du tuple, il s'agit en fait d'un champ plut√¥t que de deux champs diff√©rents.  Il est suppos√© qu'une transaction ins√®re et supprime rarement la m√™me ligne. <br><br>  Mais si cela se produit, un identifiant de commande combo sp√©cial ( <code>combocid</code> ) est ins√©r√© dans le m√™me champ et le processus d'arri√®re-plan se souvient des <code>cmin</code> et <code>cmax</code> pour ce <code>combocid</code> .  Mais c'est totalement exotique. <br><br>  Voici un exemple simple.  Commen√ßons une transaction et ajoutons une ligne au tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Sortons le contenu de la table, ainsi que le champ <code>cmin</code> (mais uniquement pour les lignes ajout√©es par la transaction - pour d'autres, cela n'a aucun sens): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Maintenant, nous ouvrons un curseur pour une requ√™te qui renvoie le nombre de lignes dans la table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Et apr√®s cela, nous ajoutons une autre ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  La requ√™te renvoie 4 - la ligne ajout√©e apr√®s l'ouverture du curseur n'entre pas dans l'instantan√© des donn√©es: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Pourquoi?  Parce que l'instantan√© ne prend en compte que les tuples avec <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizon de l'√©v√©nement </h1><br>  L'ID de la premi√®re transaction active ( <code>snapshot.xmin</code> ) a un sens important: il d√©termine ¬´l'horizon des √©v√©nements¬ª de la transaction.  Autrement dit, au-del√† de son horizon, la transaction ne voit toujours que des versions de ligne √† jour. <br><br>  En r√©alit√©, une version de ligne obsol√®te (morte) ne doit √™tre visible que lorsque la version √† jour a √©t√© cr√©√©e par une transaction non encore termin√©e et n'est donc pas encore visible.  Mais toutes les transactions "au-del√† de l'horizon" sont d√©finitivement r√©alis√©es. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Vous pouvez voir l'horizon de transaction dans le catalogue syst√®me: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Nous pouvons √©galement d√©finir l'horizon au niveau de la base de donn√©es.  Pour ce faire, nous devons prendre tous les instantan√©s actifs et trouver le plus ancien <code>xmin</code> parmi eux.  Et il d√©finira l'horizon, au-del√† duquel les tuples morts dans la base de donn√©es ne seront jamais visibles pour aucune transaction.  <em>De tels tuples peuvent √™tre aspir√©s</em> - et c'est exactement pourquoi le concept d'horizon est si important d'un point de vue pratique. <br><br>  Si une certaine transaction contient un instantan√© pendant une longue p√©riode, elle tiendra √©galement l'horizon de la base de donn√©es.  De plus, la simple existence d'une transaction inachev√©e tiendra l'horizon m√™me si la transaction elle-m√™me ne contient pas l'instantan√©. <br><br>  Et cela signifie que les tuples morts dans la base de donn√©es ne peuvent pas √™tre aspir√©s.  De plus, il est possible qu'une transaction "longue dur√©e" ne se croise pas du tout avec des donn√©es avec d'autres transactions, mais cela n'a pas vraiment d'importance car tous partagent un horizon de base de donn√©es. <br><br>  Si nous faisons maintenant un segment repr√©senter des instantan√©s (de <code>snapshot.xmin</code> √† <code>snapshot.xmax</code> ) plut√¥t que des transactions, nous pouvons visualiser la situation comme suit: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  Dans cette figure, l'instantan√© le plus bas se rapporte √† une transaction non termin√©e et dans les autres instantan√©s, <code>snapshot.xmin</code> ne peut pas √™tre sup√©rieur √† l'ID de transaction. <br><br>  Dans notre exemple, la transaction a √©t√© lanc√©e avec le niveau d'isolement Read Committed.  M√™me s'il n'a aucun instantan√© de donn√©es actif, il continue de tenir l'horizon: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Et ce n'est qu'apr√®s la finalisation de la transaction que l'horizon avance, ce qui permet d'aspirer les tuples morts: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Dans le cas o√π la situation d√©crite cause vraiment des probl√®mes et qu'il n'y a aucun moyen de la contourner au niveau de l'application, deux param√®tres sont disponibles √† partir de la version 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> d√©termine la dur√©e de vie maximale de l'instantan√©.  Une fois ce temps √©coul√©, le serveur pourra aspirer les tuples morts, et si une transaction "longue dur√©e" en a encore besoin, il obtiendra une erreur "instantan√© trop ancien". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> d√©termine la dur√©e de vie maximale d'une transaction inactive.  Une fois ce d√©lai √©coul√©, la transaction s'interrompt. </li></ul><br><h1>  Exportation d'instantan√©s </h1><br>  Parfois, des situations surviennent o√π plusieurs transactions simultan√©es doivent √™tre garanties pour voir les m√™mes donn√©es.  Un exemple est un utilitaire <code>pg_dump</code> , qui peut fonctionner en mode parall√®le: tous les processus de travail doivent voir la base de donn√©es dans le m√™me √©tat pour que la copie de sauvegarde soit coh√©rente. <br><br>  Bien s√ªr, nous ne pouvons pas nous fier √† la conviction que les transactions verront les m√™mes donn√©es simplement parce qu'elles ont √©t√© d√©marr√©es "simultan√©ment".  √Ä cette fin, l'exportation et l'importation d'un instantan√© sont disponibles. <br><br>  La fonction <code>pg_export_snapshot</code> renvoie l'ID d'instantan√©, qui peut √™tre transmis √† une autre transaction (√† l'aide d'outils en dehors du SGBD). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  L'autre transaction peut importer l'instantan√© √† l'aide de la commande SET TRANSACTION SNAPSHOT avant d'effectuer sa premi√®re requ√™te.  Le niveau d'isolement Lecture r√©p√©table ou S√©rialisable doit √©galement √™tre sp√©cifi√© avant car au niveau Lecture valid√©e, les instructions utiliseront leurs propres instantan√©s. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  La deuxi√®me transaction fonctionnera d√©sormais avec l'instantan√© de la premi√®re et, par cons√©quent, affichera trois lignes (plut√¥t que z√©ro): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  La dur√©e de vie d'un instantan√© export√© est identique √† la dur√©e de vie de la transaction d'exportation. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479512/">https://habr.com/ru/post/fr479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479498/index.html">Comment le temps lin√©aire se transforme en Windows en O (n¬≤)</a></li>
<li><a href="../fr479502/index.html">Comment survivre √† la p√©riode glaciaire la plus s√©v√®re de l'histoire de la Terre?</a></li>
<li><a href="../fr479504/index.html">Cr√©er un client l√©ger RDP bas√© sur Raspberry Pi</a></li>
<li><a href="../fr479508/index.html">PostgreSQL Antipatterns: JOIN et OR nuisibles</a></li>
<li><a href="../fr479510/index.html">PocketBook X Review - un √©norme lecteur de 10,3 pouces avec un √©cran E Ink Carta Mobius et un bo√Ætier m√©tallique</a></li>
<li><a href="../fr479514/index.html">Confidentialit√© par conception et confidentialit√© par d√©faut (protection des donn√©es con√ßue et confidentialit√© par d√©faut par GDPR)</a></li>
<li><a href="../fr479516/index.html">Qu'est-ce que l'entropie dans un logiciel et comment le g√©rer?</a></li>
<li><a href="../fr479518/index.html">La communication au sein d'une √©quipe √† distance est notre exp√©rience</a></li>
<li><a href="../fr479522/index.html">Editeur Peter. Soldes d'hiver</a></li>
<li><a href="../fr479524/index.html">Service pour Active Restore ou l'histoire d'un projet industriel √† Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>