<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí® üë©üèº‚Äçüé§ üéê Warum ist JavaScript im strikten Modus erforderlich? üë®üèø‚Äçüéì üåü üë©üèΩ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der strikte Modus ist ein wichtiger Bestandteil des modernen JavaScript. In diesem Modus k√∂nnen Entwickler eine eingeschr√§nktere Syntax als die Standa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum ist JavaScript im strikten Modus erforderlich?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477284/">  Der strikte Modus ist ein wichtiger Bestandteil des modernen JavaScript.  In diesem Modus k√∂nnen Entwickler eine eingeschr√§nktere Syntax als die Standardsyntax verwenden. <br><br>  Die Semantik des strikten Modus unterscheidet sich vom traditionellen nicht-strikten Modus, der manchmal als "schlampiger Modus" bezeichnet wird.  In diesem Modus sind die Syntaxregeln der Sprache nicht so streng, und wenn einige Fehler auftreten, benachrichtigt das System den Benutzer nicht dar√ºber.  Das hei√üt, Fehler k√∂nnen ignoriert und der Code, in dem sie gemacht werden, kann weiter ausgef√ºhrt werden.  Dies kann zu unerwarteten Ergebnissen bei der Codeausf√ºhrung f√ºhren. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/477284/"><img src="https://habrastorage.org/webt/cm/tk/0u/cmtk0u9w_n1ifbiykbgvswupxcm.jpeg"></a> <br><br>  Im strengen Modus werden einige √Ñnderungen an der Semantik von JavaScript vorgenommen.  Es verhindert, dass das System die Augen vor Fehlern verschlie√üt, indem es entsprechende Ausnahmen ausl√∂st.  Dadurch wird die Programmausf√ºhrung gestoppt. <br><br>  Dar√ºber hinaus hilft der Strict-Modus beim Schreiben von Programmen, bei denen es keine M√§ngel gibt, die JS-Engines daran hindern, den Code zu optimieren.  Au√üerdem ist es in diesem Modus verboten, Syntaxelemente zu verwenden, die in zuk√ºnftigen Versionen der Sprache m√∂glicherweise eine besondere Bedeutung haben. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Funktionen zur Verwendung des Strict-Modus</font> </h2><br>  Der Strict-Modus kann auf einzelne Funktionen oder auf ein gesamtes Skript angewendet werden.  Es kann nicht nur auf einzelne Anweisungen oder in geschweiften Klammern gesetzte Codebl√∂cke angewendet werden.  Um den strikten Modus auf der Ebene des gesamten Skripts zu verwenden, m√ºssen Sie am Anfang der Datei vor allen anderen Befehlen den Befehl <code>"use strict"</code> oder <code>'use strict'</code> construct setzen. <br><br>  Wenn das Projekt √ºber einige Skripte verf√ºgt, die den strikten Modus nicht verwenden, und √ºber andere, die diesen Modus verwenden, kann es vorkommen, dass diese Skripte zusammengef√ºhrt werden. <br><br>  Dies f√ºhrt dazu, dass sich Code, der nicht im strikten Modus ausgef√ºhrt werden soll, in einem solchen Zustand befindet, wenn das System versucht, ihn im strikten Modus auszuf√ºhren.  Das Gegenteil ist auch m√∂glich - Code, der f√ºr den strengen Modus geschrieben wurde, f√§llt in den nicht-strengen Modus.  Daher ist es am besten, ‚Äûstrenge‚Äú und ‚Äûnicht strenge‚Äú Skripte nicht zu mischen. <br><br>  Wie bereits erw√§hnt, kann der strikte Modus auf einzelne Funktionen angewendet werden.  Zu diesem Zweck muss die Konstruktion <code>"use strict"</code> oder <code>'use strict'</code> vor allen anderen Befehlen am Anfang des Funktionsk√∂rpers platziert werden.  Der strikte Modus bei diesem Ansatz gilt f√ºr alles, was sich im Hauptteil der Funktion befindet, einschlie√ülich verschachtelter Funktionen. <br><br>  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strictFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nestedFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{    <span class="hljs-comment"><span class="hljs-comment">//        } }</span></span></code> </pre> <br>  In JavaScript-Modulen, die im ES2015-Standard enthalten waren, ist der strikte Modus standardm√§√üig aktiviert.  Wenn Sie mit ihnen arbeiten, m√ºssen Sie sie daher nicht explizit einschlie√üen. <br><br><h2>  <font color="#3AC1EF">√Ñnderungen, die im strikten Modus am JS-Code vorgenommen wurden</font> </h2><br>  Der strenge Modus wirkt sich sowohl auf die Syntax des Codes als auch auf das Verhalten des Codes w√§hrend der Programmausf√ºhrung aus.  Fehler im Code werden in Ausnahmen umgewandelt.  Die Tatsache, dass im stillen Modus still im strengen Modus abst√ºrzt, verursacht eine Fehlermeldung.  Dies √§hnelt dem Verhalten des Systems bei Syntaxfehlern im Lax-Modus.  Im strikten Modus wird die Arbeit mit Variablen vereinfacht, die Verwendung der <code>eval</code> Funktion und des <code>arguments</code> Objekts streng geregelt und die Arbeit mit Konstrukten, die in zuk√ºnftigen Versionen der Sprache implementiert werden k√∂nnen, optimiert. <br><br><h3>  <font color="#3AC1EF">‚ñç Konvertieren Sie stille Fehler in Ausnahmen</font> </h3><br>  Stille Fehler werden im strengen Modus in Ausnahmen umgewandelt.  Im laxen Modus reagiert das System nicht explizit auf solche Fehler.  Im strikten Modus f√ºhrt das Vorhandensein solcher Fehler zur Inoperabilit√§t des Codes. <br><br>  Aus diesem Grund ist es schwierig, den Fehler zu machen, eine globale Variable versehentlich zu deklarieren, da Variablen und Konstanten im strikten Modus nicht ohne die Anweisungen <code>var</code> , <code>let</code> oder <code>const</code> deklariert werden k√∂nnen.  Infolgedessen f√ºhrt das Erstellen von Variablen ohne diese Anweisungen zur Funktionsunf√§higkeit des Programms.  Wenn Sie beispielsweise versuchen, den folgenden Code auszuf√ºhren, wird eine <code>ReferenceError</code> Ausnahme <code>ReferenceError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; badVariable = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Solcher Code kann nicht im strikten Modus ausgef√ºhrt werden, da bei <code>badVariable</code> strikten Modus die globale Variable <code>badVariable</code> .  Der strikte Modus sch√ºtzt den Programmierer vor dem versehentlichen Erstellen globaler Variablen. <br><br>  Der Versuch, Code auszuf√ºhren, der im normalen Modus einfach nicht funktioniert, l√∂st jetzt eine Ausnahme aus.  Als Fehler gelten alle falschen syntaktischen Konstruktionen, die im lax-Modus einfach ignoriert wurden. <br><br>  So k√∂nnen Sie beispielsweise im strikten Modus keine Wertzuweisungsoperationen f√ºr schreibgesch√ºtzte Entit√§ten wie <code>arguments</code> , <code>NaN</code> oder <code>eval</code> ausf√ºhren. <br><br>  Im strikten Modus wird beispielsweise in folgenden F√§llen eine Ausnahme ausgel√∂st: <br><br><ul><li>  ein Versuch, einer schreibgesch√ºtzten Eigenschaft einen Wert zuzuweisen, beispielsweise einer Art wiederbeschreibbarer globaler Eigenschaft; </li><li>  ein Versuch, einen Wert in eine Eigenschaft zu schreiben, die nur einen Getter enth√§lt; </li><li>  Ein Versuch, etwas in eine Eigenschaft eines nicht erweiterbaren Objekts zu schreiben. </li></ul><br>  Hier sind Beispiele f√ºr Syntaxkonstrukte, die zu strengen Modusausnahmen f√ºhren: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); obj.foo = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj2 = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>; } }; obj2.foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fixedObj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(fixedObj); fixed.bar= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Der Versuch, solche Codefragmente im strengen Modus auszuf√ºhren, <code>TypeError</code> eine <code>TypeError</code> Ausnahme aus.  Beispielsweise sind <code>undefined</code> und <code>Infinity</code> globale Entit√§ten, deren Werte nicht √ºberschrieben werden k√∂nnen, und die Eigenschaft <code>foo</code> des Objekts <code>obj</code> unterst√ºtzt kein erneutes <code>obj</code> .  Die <code>foo</code> Eigenschaft von <code>obj2</code> hat nur einen Getter.  Das <code>fixedObj</code> Objekt <code>fixedObj</code> mit der <code>Object.preventExtensions</code> Methode nicht erweiterbar <code>Object.preventExtensions</code> . <br><br>  Ein Versuch, eine nicht <code>TypeError</code> zu l√∂schen, f√ºhrt ebenfalls zu <code>TypeError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype</code> </pre> <br>  Im strengen Modus ist es nicht m√∂glich, einem Objekt Eigenschaften mit demselben Namen zuzuweisen.  Daher f√ºhrt der Versuch, den folgenden Code auszuf√ºhren, zu einem Syntaxfehler: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Im strengen Modus m√ºssen Funktionsparameternamen eindeutig sein.  Wenn beispielsweise im nicht strengen Modus zwei Funktionsparameter den gleichen Namen haben, ist der Parameterwert beim √úbergeben der Argumentfunktion der Wert, der in das zuletzt deklarierte Argument f√§llt. <br><br>  Im Strict-Modus sind Parameter von Funktionen mit demselben Namen nicht zul√§ssig.  Daher f√ºhrt der Versuch, den folgenden Code auszuf√ºhren, zu einem Syntaxfehler: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multiply = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x*x*y;</code> </pre> <br>  Im strengen Modus k√∂nnen Sie die Oktalnotation von Zahlen vor der Zahl mit Null nicht verwenden.  Dies ist nicht in der Spezifikation enthalten, diese Funktion wird jedoch von Browsern unterst√ºtzt. <br><br>  Dieser Zustand verwirrt die Entwickler und zwingt sie zu der Annahme, dass die 0 vor der Zahl ohne gro√üen Sinn einfach ignoriert wird.  Wenn Sie im strengen Modus versuchen, eine Zahl zu verwenden, deren Anfang 0 ist, wird ein Syntaxfehler verursacht. <br><br>  Der strikte Modus verbietet auch die Verwendung von Konstrukten, die die Optimierung behindern.  Bevor der Interpreter eine Codeoptimierung durchf√ºhrt, muss er wissen, dass die Variable genau dort gespeichert ist, wo sie laut Interpreter gespeichert ist.  Im strengen Modus sind Dinge, die die Optimierung beeintr√§chtigen, verboten. <br><br>  Ein Beispiel f√ºr ein solches Verbot ist die <code>with</code> Anweisung.  Wenn Sie diese Anweisung verwenden, verhindert dies, dass der JS-Interpreter herausfindet, auf welche Variable oder welche Eigenschaft wir verweisen, da m√∂glicherweise eine Entit√§t mit demselben Namen sowohl au√üerhalb als auch innerhalb des Blocks der <code>with</code> Anweisung vorhanden ist. <br><br>  Angenommen, es gibt einen Code wie diesen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  Der Interpreter kann nicht feststellen, ob die Variable <code>x</code> im <code>with</code> Block auf die externe Variable <code>x</code> oder auf die <code>obj.x</code> Eigenschaft des <code>obj</code> Objekts <code>obj</code> . <br><br>  Infolgedessen ist nicht klar, wo genau sich der <code>x</code> Wert im Speicher befindet.  Um solche Unklarheiten zu beseitigen, ist die Verwendung der <code>with</code> Anweisung im strikten Modus verboten.  Mal sehen, was passiert, wenn Sie versuchen, den folgenden Code im strikten Modus auszuf√ºhren: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  Das Ergebnis dieses Versuchs ist ein Syntaxfehler. <br><br>  Auch im strikten Modus ist es verboten, Variablen im Code zu deklarieren, der an die <code>eval</code> Methode √ºbergeben wird. <br><br>  Im normalen Modus f√ºhrt beispielsweise ein Befehl der Form <code>eval('let x')</code> zur Deklaration der Variablen <code>x</code> .  Dadurch k√∂nnen Programmierer Variablendeklarationen in Zeichenfolgen ausblenden, was dazu f√ºhren kann, dass die Definitionen derselben Variablen au√üerhalb von <code>eval</code> √ºberschrieben werden. <br><br>  Um dies zu verhindern, ist es im strikten Modus verboten, Variablen im Code zu deklarieren, die als Zeichenfolge an die <code>eval</code> Methode √ºbergeben werden. <br><br>  Der strikte Modus verbietet auch das L√∂schen regul√§rer Variablen.  Daher f√ºhrt der Versuch, den folgenden Code auszuf√ºhren, zu einem Syntaxfehler: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x;</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Verbot falscher Syntaxkonstrukte</font> </h3><br>  Im strengen Modus ist die falsche Verwendung von <code>eval</code> und <code>arguments</code> verboten.  Dies ist ein Verbot aller Arten von Manipulationen mit ihnen.  Dies ist beispielsweise so etwas wie das Zuweisen neuer Werte, wobei deren Namen als Variablennamen, Funktionen und Funktionsparameter verwendet werden. <br><br>  Hier sind Beispiele f√ºr den Missbrauch von <code>eval</code> und <code>arguments</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>++; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>--; ++<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { set p(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eval</span></span></span><span class="hljs-function">) </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'arguments'</span></span>, <span class="hljs-string"><span class="hljs-string">"'use strict'; return 1;"</span></span>);</code> </pre> <br>  Im strikten Modus k√∂nnen Sie keine Aliase f√ºr das <code>arguments</code> Objekt erstellen und √ºber diese Aliase neue <code>arguments</code> festlegen. <br><br>  Wenn im normalen Modus der erste Parameter der Funktion a ist, f√ºhrt das Festlegen des Werts von <code>a</code> im Funktionscode auch zu einer √Ñnderung des Werts in <code>arguments[0]</code> .  Im strikten Modus enthalten <code>arguments</code> immer die Liste der Argumente, mit denen die Funktion aufgerufen wurde. <br><br>  Angenommen, Sie haben den folgenden Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  a = <span class="hljs-number"><span class="hljs-number">2</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br>  Die Konsole wird <code>[2,1]</code> .  Dies liegt daran, dass beim Schreiben eines Werts von 2 in <code>a</code> kein Wert von 2 in <code>arguments[0]</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçPerformance optimieren</font> </h3><br>  Im strengen Modus wird die Eigenschaft <code>arguments.callee</code> nicht unterst√ºtzt.  Im normalen Modus wird der Name der √ºbergeordneten Funktion der Funktion zur√ºckgegeben, deren Eigenschaft <code>callee</code> des <code>arguments</code> untersucht wird. <br><br>  Die Unterst√ºtzung dieser Eigenschaft beeintr√§chtigt Optimierungen, z. B. Inlining-Funktionen, da f√ºr die Verwendung von <code>arguments.callee</code> die Verf√ºgbarkeit eines Verweises auf eine nicht eingebettete Funktion erforderlich ist, wenn auf diese Eigenschaft zugegriffen wird.  Im strengen Modus l√∂st die Verwendung von <code>arguments.callee</code> eine <code>TypeError</code> Ausnahme aus. <br><br>  Im strikten Modus muss das <code>this</code> nicht immer ein Objekt sein.  Wenn <code>this</code> Funktion unter normalen Bedingungen mit <code>call</code> , <code>apply</code> oder <code>bind</code> an etwas gebunden ist, das kein Objekt ist, an einen Wert eines primitiven Typs wie <code>undefined</code> , <code>null</code> , <code>number</code> oder <code>boolean</code> , sollte ein solcher Wert ein Objekt sein. <br><br>  Wenn sich der Kontext in etwas √§ndert, das kein Objekt ist, tritt an seine Stelle ein globales Objekt.  Zum Beispiel <code>window</code> .  Dies bedeutet, dass, wenn Sie eine Funktion aufrufen, indem Sie <code>this</code> auf einen Wert setzen, der kein Objekt ist, statt auf diesen Wert, ein Verweis auf das globale Objekt in <code>this</code> Wert f√§llt. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn() === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-number"><span class="hljs-number">2</span></span>) === <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.bind(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)() === <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Alle <code>console.log</code> Befehle geben " <code>true</code> , da der Wert <code>this</code> <code>console.log</code> in der Funktion im strikten Modus nicht automatisch durch einen Verweis auf das globale Objekt ersetzt wird, wenn <code>this</code> auf einen Wert festgelegt ist, der kein Objekt ist. <br><br><h3>  <font color="#3AC1EF">‚ñç Sicherheitsrelevante √Ñnderungen</font> </h3><br>  Im strengen Modus k√∂nnen Sie die Funktionseigenschaften <code>caller</code> und <code>arguments</code> √∂ffentlich machen.  Fakt ist, dass der <code>caller</code> beispielsweise Zugriff auf die Funktion gew√§hren kann, die die Funktion aufgerufen hat, auf deren <code>caller</code> wir zugreifen. <br><br>  Das <code>arguments</code> Objekt speichert die Argumente, die beim Aufruf an die Funktion √ºbergeben wurden.  Wenn wir zum Beispiel eine Funktion <code>fn</code> , bedeutet dies, dass Sie √ºber <code>fn.caller</code> auf die Funktion zugreifen k√∂nnen, die die Funktion aufgerufen hat, und mit <code>fn.arguments</code> k√∂nnen Sie die Argumente <code>fn.arguments</code> , die beim <code>fn.arguments</code> an <code>fn</code> . <br><br>  Diese Funktionen stellen ein potenzielles Sicherheitsrisiko dar.  Infolgedessen ist der Zugriff auf diese Eigenschaften im strengen Modus verboten. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secretFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  secretFunction.caller;  secretFunction.arguments; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restrictedRunner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretFunction(); } restrictedRunner();</code> </pre> <br>  Im vorherigen Beispiel k√∂nnen wir im strikten Modus nicht auf die <code>secretFunction.caller</code> und <code>secretFunction.arguments</code> .  Tatsache ist, dass diese Eigenschaften verwendet werden k√∂nnen, um einen Stapel von Funktionsaufrufen abzurufen.  Wenn Sie versuchen, diesen Code auszuf√ºhren, wird eine <code>TypeError</code> Ausnahme <code>TypeError</code> . <br><br>  Im strengen Modus k√∂nnen Bezeichner, die m√∂glicherweise in zuk√ºnftigen Versionen von JavaScript verwendet werden, nicht zum Benennen von Variablen oder Eigenschaften von Objekten verwendet werden.  Zum Beispiel sprechen wir √ºber die folgenden Bezeichner: <code>implements</code> , <code>interface</code> , <code>let</code> , <code>package</code> , <code>private</code> , <code>protected</code> , <code>public</code> , <code>static</code> und <code>yield</code> . <br><br>  In ES2015 und sp√§teren Versionen des Standards wurden diese Bezeichner zu reservierten W√∂rtern.  Und sie k√∂nnen nicht verwendet werden, um Variablen oder Eigenschaften im strengen Modus zu benennen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Strenger Modus ist ein Standard, der seit vielen Jahren existiert.  Es genie√üt eine extrem breite Browserunterst√ºtzung.  Probleme mit Strict-Mode-Code k√∂nnen nur in √§lteren Browsern wie dem Internet Explorer auftreten. <br><br>  Moderne Browser sollten keine Schwierigkeiten mit dem strengen JavaScript-Modus haben.  Wir k√∂nnen daher sagen, dass dieser Modus verwendet werden sollte, um "stille" Fehler zu vermeiden und die Anwendungssicherheit zu erh√∂hen.  Stille Fehler werden in Ausnahmen umgewandelt, die die Ausf√ºhrung von Programmen behindern. Um die Sicherheit zu verbessern, k√∂nnen beispielsweise Strict-Mode-Mechanismen festgestellt werden, die die <code>eval</code> einschr√§nken und den Zugriff auf den Funktionsaufrufstapel verhindern.  Dar√ºber hinaus erleichtert die Verwendung des strikten Modus die Codeoptimierung f√ºr die JS-Engine und zwingt den Programmierer zum sorgf√§ltigen Umgang mit reservierten W√∂rtern, die m√∂glicherweise in zuk√ºnftigen Versionen von JavaScript Verwendung finden. <br><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie den strikten Modus, wenn Sie JS-Code f√ºr Ihre Projekte schreiben? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477284/">https://habr.com/ru/post/de477284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477272/index.html">Erste Einf√ºhrung in AssemblyScript</a></li>
<li><a href="../de477274/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 1</a></li>
<li><a href="../de477276/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 2</a></li>
<li><a href="../de477278/index.html">Frontend-Test</a></li>
<li><a href="../de477282/index.html">Profiling Go-Projektcode und Beheben von Speicherzuordnungsproblemen</a></li>
<li><a href="../de477286/index.html">Axios oder Fetch: Was im Jahr 2019 verwenden?</a></li>
<li><a href="../de477288/index.html">John Lewis auf der Undoing Aging Conference 2018</a></li>
<li><a href="../de477290/index.html">Digitale Veranstaltungen in Moskau vom 25. November bis 1. Dezember</a></li>
<li><a href="../de477292/index.html">Digitale Veranstaltungen in St. Petersburg vom 25. November bis 1. Dezember</a></li>
<li><a href="../de477294/index.html">Python f√ºr KI: Ein Match, das im Himmel gemacht wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>