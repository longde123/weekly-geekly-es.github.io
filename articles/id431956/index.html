<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸ‘†ğŸ» ğŸ”‹ Logika, kemampuan menjelaskan dan pemahaman masa depan ğŸ¤µğŸ½ â¤µï¸ ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penemuan terkait dengan logika 
 Logika adalah dasar dari banyak hal. Tapi apa dasar dari logika itu sendiri? 

 Dalam logika simbolik, simbol seperti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logika, kemampuan menjelaskan dan pemahaman masa depan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431956/"><h3>  Penemuan terkait dengan logika </h3><br>  Logika adalah dasar dari banyak hal.  Tapi apa dasar dari logika itu sendiri? <br><br>  Dalam logika simbolik, simbol seperti p dan q diperkenalkan untuk menunjukkan pernyataan (atau "proposisi") dari tipe "ini adalah esai yang menarik".  Masih ada aturan logika tertentu, misalnya, untuk sembarang p dan sembarang ekspresi TIDAK (p DAN q) mirip dengan (TIDAK p) ATAU (TIDAK q). <br><br>  Tapi dari mana "aturan logika" ini berasal?  Logika adalah sistem formal.  Seperti geometri Euclidean, itu dapat dibangun di atas aksioma.  Tapi apakah aksioma itu?  Anda bisa mulai dengan pernyataan seperti p AND q = q AND p, atau NOT NOT p = p.  Tetapi berapa banyak aksioma yang dibutuhkan?  Seberapa sederhana mereka? <br><br>  Pertanyaan ini sudah lama menyakitkan.  Tetapi pada 20:31 pada hari Minggu, 29 Januari 2000, satu-satunya aksioma muncul di layar komputer saya.  Saya telah menunjukkan bahwa tidak ada yang lebih sederhana, tetapi saya segera menetapkan bahwa aksioma kecil ini cukup untuk membuat semua logika: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/426/b76/8a5426b76ec6ff73e4b9f521f1e66764.png"></div><a name="habracut"></a><br>  Bagaimana saya tahu bahwa dia benar?  Karena saya membuat komputer membuktikannya.  Dan di sini adalah bukti yang saya cetak dalam buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A New Type of Science</a> " (sudah tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori Wolfram Data</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/d9f/11e/9c7d9f11e1cb651d7bfbe6b4edad66dd.png"></div><br>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi terbaru</a> Bahasa Wolfram, siapa pun dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat</a> bukti ini dalam waktu tidak lebih dari satu menit.  Dan setiap langkahnya mudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diverifikasi</a> .  Tetapi mengapa hasilnya benar?  Bagaimana cara menjelaskannya? <br><br>  Pertanyaan serupa semakin banyak ditanyakan tentang semua jenis sistem komputasi dan aplikasi yang terkait dengan pembelajaran mesin dan AI.  Ya, kami melihat apa yang terjadi.  Tetapi bisakah kita memahami hal ini? <br><br>  Saya berpikir bahwa masalah ini sangat inheren - dan sangat penting untuk masa depan sains dan teknologi, dan untuk masa depan semua perkembangan intelektual. <br><br>  Tetapi sebelum kita berbicara tentang ini, mari kita bahas aksioma yang saya temukan. <br><br><h2>  Ceritanya </h2><br>  Logika sebagai disiplin formal berasal dari Aristoteles, yang hidup pada abad ke-4 SM.  Sebagai bagian dari pekerjaan hidupnya dalam membuat katalog hal-hal (hewan, sebab, dll.), Aristoteles menyusun katalog bentuk-bentuk argumen yang diizinkan dan membuat template simbolik untuk mereka, yang, pada dasarnya, menyediakan konten utama logika selama dua ribu tahun ke depan. <br><br>  Namun, pada abad ke-15, aljabar ditemukan, dan dengan itu gambar yang lebih jelas tentang hal-hal muncul.  Tetapi baru pada tahun 1847 George Bull akhirnya merumuskan logika dengan cara yang sama seperti aljabar, dengan operasi logis seperti AND dan OR yang bekerja sesuai dengan aturan yang mirip dengan aturan aljabar. <br><br>  Setelah beberapa tahun, orang sudah menulis sistem aksiomatik untuk logika.  Contoh khas adalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/f83/b05/1b7f83b053013cbb17e8a3e3f9734097.png"></div><br>  Tetapi apakah DAN, ATAU dan TIDAK benar-benar diperlukan untuk logika?  Setelah dekade pertama abad ke-20, beberapa orang menemukan bahwa satu-satunya operasi yang sekarang kita sebut NAND akan mencukupi, dan, misalnya, p OR q dapat dihitung sebagai (p NAND p) NAND (q NAND q).  "Kelengkapan fungsional" NAND selamanya bisa tetap aneh jika bukan karena pengembangan teknologi semikonduktor - ini mengimplementasikan semua milyaran operasi logis dalam mikroprosesor modern menggunakan kombinasi transistor yang hanya menjalankan fungsi NAND atau NOR yang terkait. <br><br>  Nah, jadi seperti apa aksioma logika dalam istilah NAND?  Ini adalah versi pertama yang diketahui, direkam oleh Henry Schaeffer pada tahun 1913 (di sini titik menunjukkan NAND): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fd/af7/5d1/2fdaf75d1c346bb2d8c3c4d470ffcd68.png"></div><br>  Pada tahun 1910, Principia Mathematica, sebuah karya tiga jilid tentang logika dan filosofi matematika oleh Alfred North Whitehead dan Bertrand Russell, mempopulerkan gagasan bahwa mungkin semua matematika dapat disimpulkan dari logika.  Mengingat hal ini, cukup menarik untuk mempelajari pertanyaan tentang betapa sederhananya aksioma logika.  Pekerjaan paling signifikan di bidang ini dilakukan di Lviv dan Warsawa (saat itu kota-kota ini adalah bagian dari Polandia), khususnya, Jan Lukasevich (sebagai efek samping dari karyanya pada tahun 1920, ia menciptakan catatan "Polandia" yang tidak memerlukan tanda kurung).  Pada 1944, pada usia 66, Lukasevich melarikan diri dari tentara Soviet yang maju dan pada 1947 berakhir di Irlandia. <br><br>  Sementara itu, orang Irlandia, Carew Meredith, yang belajar di Winchester dan Cambridge, dan menjadi guru matematika di Cambridge, terpaksa kembali ke Irlandia pada tahun 1939 karena pasifisme.  Pada tahun 1947, Meredith menghadiri kuliah Lukasevich di Dublin, yang menginspirasinya untuk mencari aksioma sederhana, yang dia lakukan, sebagian besar, untuk sisa hidupnya. <br><br>  Pada 1949, Meredith menemukan sistem dua aksioma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/237/0cf/7a8/2370cf7a8b94b221152f17f905223919.png"></div><br>  Hampir 20 tahun kemudian, pada tahun 1967 ia dapat menyederhanakan ini menjadi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/ba1/89c/245ba189c20baf7290fde8e6164b1050.png"></div><br>  Apakah mungkin untuk menyederhanakan ini lebih lanjut?  Meredith telah bermain-main dengan ini selama bertahun-tahun, mencari tahu di mana lagi Anda dapat menghapus NAND tambahan.  Tetapi setelah 1967, ia tidak maju lebih jauh (dan meninggal pada tahun 1976), meskipun pada tahun 1969 ia menemukan sistem tiga aksioma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/552/dcd/650552dcd498bb69a243af9ca9373091.png"></div><br>  Ketika saya mulai mempelajari sistem aksioma logika, saya tidak tahu apa-apa tentang karya Meredith.  Saya menjadi tertarik pada topik ini sebagai bagian dari upaya untuk memahami perilaku apa yang mungkin tumbuh dari aturan sederhana.  Pada 1980-an, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penemuan tak terduga</a> bahwa bahkan automata seluler dengan aturan sesederhana mungkin - seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan 30</a> favorit saya - dapat menyebabkan perilaku yang sangat kompleks. <br><br>  Setelah menghabiskan tahun 1990-an dalam upaya untuk memahami sifat umum dari fenomena ini, saya akhirnya ingin melihat bagaimana hal itu dapat diterapkan pada matematika.  Dalam matematika, kami, pada kenyataannya, mulai bekerja dengan aksioma (misalnya, dalam aritmatika, dalam geometri, dalam logika), dan kemudian atas dasar mereka kami mencoba untuk membuktikan seluruh rangkaian teorema kompleks. <br><br>  Namun, seberapa sederhana aksioma dapat terjadi?  Itulah yang ingin saya bangun pada tahun 1999.  Sebagai contoh pertama, saya memutuskan untuk mempelajari logika (atau, aljabar Boolean).  Menyangkal semua harapan saya, pengalaman saya dengan automata seluler, mesin Turing, dan sistem lainnya - termasuk bahkan persamaan diferensial parsial - menunjukkan bahwa Anda dapat mulai membuat daftar kasus yang paling sederhana dan pada titik tertentu melihat sesuatu menarik <br><br>  Tetapi apakah mungkin untuk "membuka logika" dengan cara ini?  Hanya ada satu cara untuk mengatakan ini.  Dan pada akhir tahun 1999, saya mengatur segalanya untuk mulai menjelajahi ruang semua sistem aksioma yang mungkin, mulai dengan yang paling sederhana. <br><br>  Dalam arti tertentu, sistem aksioma apa pun mendefinisikan serangkaian kendala, misalnya, pada p Â· q.  Dia tidak mengatakan apa itu p Â· q, dia hanya memberikan sifat yang harus dipenuhi p Â· q (misalnya, dia bisa mengatakan bahwa q Â· p = p Â· q).  Maka pertanyaannya adalah apakah mungkin untuk mendapatkan dari semua properti ini semua teorema logika yang berlaku ketika p Â· q adalah Nand [p, q]: tidak lebih dan tidak kurang. <br><br>  Sesuatu dapat diverifikasi secara langsung.  Kita dapat mengambil sistem aksioma dan melihat bentuk mana p Â· q memenuhi aksioma, jika p dan q adalah, katakanlah, benar dan salah.  Jika sistem aksioma adalah bahwa q Â· p = p Â· q, maka ya, p Â· q dapat berupa Nand [p, q] - tetapi tidak harus demikian.  Itu juga bisa dan [p, q] atau sama dengan [p, q], atau banyak lagi opsi lain yang tidak memenuhi level yang sama dengan fungsi NAND dalam logika.  Tetapi pada saat kita sampai pada sistem aksioma {((p Â· p) Â· q) Â· (q Â· p) = q}, kita sampai pada keadaan di mana Nand [p, q] (dan setara dengan Nor [p , q]) tetap menjadi satu-satunya model p Â· q yang berfungsi - setidaknya jika kita mengasumsikan bahwa q dan p hanya memiliki dua nilai yang mungkin. <br><br>  Apakah ini kemudian sistem aksioma untuk logika?  Tidak.  Karena itu menyiratkan, misalnya, keberadaan varian di mana p dan q memiliki tiga nilai, tetapi ini tidak dalam logika.  Namun, fakta bahwa sistem aksioma dari satu aksioma ini dekat dengan apa yang kita butuhkan menunjukkan bahwa perlu mencari aksioma tunggal dari mana logika direproduksi.  Ini persis apa yang saya lakukan pada Januari 2000 (di zaman kami tugas ini telah difasilitasi berkat fungsi Wolfram Language, Groupings yang cukup baru dan sangat nyaman). <br><br>  Cukup mudah untuk memverifikasi bahwa aksioma di mana terdapat 3 atau lebih sedikit NAND (atau "operator titik") tidak berfungsi.  Pada jam 5 pagi pada hari Minggu, 29 Januari (ya, saat itu saya masih burung hantu), saya menemukan bahwa aksioma yang mengandung 4 NANDs tidak akan berhasil.  Ketika saya berhenti bekerja sekitar pukul 6 pagi, saya memiliki 14 kandidat di tangan saya dengan lima NAND.  Tetapi terus bekerja pada hari Minggu malam dan melakukan tes tambahan, saya harus membatalkan semuanya. <br><br>  Tak perlu dikatakan, langkah selanjutnya adalah memeriksa aksioma dengan 6 NAND.  Ada 288.684 di antaranya, tetapi kode saya bekerja secara efisien, dan tidak banyak waktu berlalu sebelum yang berikut muncul di layar (ya, dari Mathematica Versi 4): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/eb6/b59/cb1eb6b59aa53f1cc55cc91c2ec76271.png"></div><br>  Awalnya saya tidak mengerti apa yang saya lakukan.  Saya hanya tahu bahwa saya memiliki 25 aksioma nonquivalent dengan 6 NAND yang mampu maju lebih jauh dari aksioma dengan 5 NAND.  Tetapi apakah ada aksioma di antara mereka yang menghasilkan logika?  Saya memiliki metode empiris yang mampu membuang aksioma yang tidak perlu.  Tetapi satu-satunya cara untuk mengetahui dengan pasti kebenaran dari aksioma tertentu adalah membuktikan bahwa ia berhasil mereproduksi, misalnya, aksioma Schaeffer untuk logika. <br><br>  Butuh sedikit permainan dengan program, tetapi setelah beberapa hari saya menemukan bahwa sebagian besar dari 25 aksioma yang diterima tidak berhasil.  Akibatnya, dua selamat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f1/a4a/5e0/6f1a4a5e040e1acbd2e14406b8a05eff.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/20f/394/31120f394c33c0d1c95c0d22ee9caf45.png"></div><br>  Dan yang sangat menggembirakan, saya bisa membuktikan menggunakan komputer yang keduanya merupakan aksioma untuk logika.  Teknik yang digunakan menjamin tidak adanya aksioma sederhana untuk logika.  Oleh karena itu, saya tahu bahwa saya telah mencapai tujuan: setelah satu abad (atau mungkin beberapa milenium) pencarian, kita akhirnya dapat mengatakan bahwa kita telah menemukan aksioma paling sederhana untuk logika. <br><br>  Segera setelah itu, saya menemukan sistem dua aksioma dengan 6 NAND secara umum, yang, seperti yang saya buktikan, mampu mereproduksi logika: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/311/d22/7b9311d22392f15be81d05b43df9861c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/920/f41/3e1/920f413e173d5e9c859b580d27eb3819.png"></div><br>  Dan jika kita menganggap komutatifitas p Â· q = q Â· p begitu saja, maka logika dapat diperoleh dari aksioma yang hanya mengandung 4 NAND. <br><br><h2>  Mengapa ini penting? </h2><br>  Baiklah, katakanlah sangat keren untuk dapat mengatakan bahwa seseorang "menyelesaikan pekerjaan yang dimulai oleh Aristoteles" (atau setidaknya Boole) dan menemukan sistem aksioma yang paling sederhana untuk logika.  Apakah itu hanya tipuan, atau apakah fakta ini memiliki konsekuensi penting? <br><br>  Sebelum platform yang saya kembangkan dalam A New Kind of Science, saya pikir akan sulit untuk mempertimbangkan fakta ini sebagai sesuatu yang lebih dari sekadar rasa ingin tahu.  Tetapi sekarang harus jelas bahwa itu terhubung dengan segala macam pertanyaan dasar, seperti apakah matematika harus dianggap sebagai penemuan atau penemuan. <br><br>  Matematika yang dilakukan orang didasarkan pada beberapa sistem aksioma tertentu - yang masing-masing mendefinisikan bidang matematika tertentu (logika, teori kelompok, geometri, teori himpunan).  Tetapi berbicara secara abstrak, ada sejumlah sistem aksioma - yang masing-masing mendefinisikan bidang matematika yang dapat dipelajari bahkan jika orang belum melakukannya. <br><br>  Sebelum buku A New Kind of Science, saya tampaknya bermaksud bahwa segala sesuatu yang ada â€œdi suatu tempat di luar sanaâ€ di dunia komputasi harus â€œkurang menarikâ€ daripada apa yang telah dibuat dan dipelajari orang.  Tetapi penemuan saya mengenai program-program sederhana menunjukkan bahwa sistem yang hanya "di suatu tempat di luar sana" memiliki kemungkinan yang tidak kalah kaya daripada sistem yang dipilih dengan cermat oleh orang-orang. <br><br>  Lalu bagaimana dengan sistem aksioma untuk matematika?  Untuk membandingkan "suatu tempat di luar sana" yang ada dengan apa yang dipelajari orang, Anda perlu tahu apakah sistem aksioma terletak pada area matematika yang ada yang telah kita pelajari.  Dan, berdasarkan sistem tradisional yang dibuat oleh orang-orang, kita dapat menyimpulkan bahwa mereka pasti berada di suatu tempat yang sangat, sangat jauh - dan secara umum mereka dapat ditemukan hanya jika Anda sudah tahu di mana Anda berada. <br><br>  Tetapi penemuan saya tentang sistem aksioma menjawab pertanyaan "Seberapa jauhkah logika?"  Untuk hal-hal seperti otomat seluler, cukup mudah untuk memberi nomor (seperti yang saya lakukan pada 1980-an) semua automata seluler yang mungkin.  Agak sulit untuk melakukan ini dengan sistem aksioma - tetapi tidak banyak.  Dalam satu pendekatan, aksioma saya dapat dilambangkan sebagai 411; 3; 7; 118 - atau, dalam Bahasa Wolfram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/315/5d5/ef0/3155d5ef0d85da9df2a25e407c617625.png"></div><br>  Dan, setidaknya dalam ruang kemungkinan bentuk fungsional (tidak memperhitungkan markup variabel) ada representasi visual dari lokasi aksioma ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/e6c/eb2/bb2e6ceb2b5a36d51e32d16727e89ef9.png"></div><br>  Mengingat pentingnya logika secara mendasar untuk sejumlah besar sistem formal yang dipelajari orang, orang akan berpikir bahwa dalam representasi yang masuk akal, logika sesuai dengan salah satu sistem aksioma yang paling sederhana.  Tapi, setidaknya dalam presentasi menggunakan NAND, ini tidak begitu.  Baginya, masih ada sistem aksioma yang sangat sederhana, tetapi mungkin akan berubah menjadi seratus ribu sistem aksioma dari semua yang mungkin yang dapat ditemukan jika Anda baru saja mulai menghitung sistem aksioma, dimulai dengan yang paling sederhana. <br><br>  Dengan ini, pertanyaan selanjutnya yang jelas adalah: bagaimana dengan semua sistem aksioma lainnya?  Bagaimana mereka berperilaku?  Ini adalah masalah yang dieksplorasi buku A New Kind of Science.  Dan di dalamnya saya menegaskan bahwa hal-hal seperti sistem yang diamati di alam paling sering digambarkan dengan sangat "aturan lain" yang dapat kita temukan dengan menomori kemungkinan. <br><br>  Adapun sistem aksioma, saya membuat gambar yang mewakili apa yang terjadi di "bidang matematika" sesuai dengan berbagai sistem aksioma.  Serial ini menunjukkan konsekuensi dari sistem aksioma tertentu, dan kotak-kotak menunjukkan kebenaran teorema tertentu dalam sistem aksioma tertentu (ya, pada beberapa titik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teorema GÃ¶del</a> mulai berlaku, setelah itu menjadi sangat sulit untuk membuktikan atau menyangkal teorema tertentu dalam sistem aksioma tertentu; dalam praktiknya, dengan dengan metode saya, ini terjadi sedikit di sebelah kanan dari apa yang ditunjukkan pada gambar). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/56f/8e5/62756f8e5e47459b575ad148feacee99.png"></div><br>  Apakah ada sesuatu yang secara fundamental spesial dalam bidang matematika yang â€œditeliti oleh orang-orangâ€?  Menilai dengan ini dan gambar-gambar lain, tidak ada yang jelas terlintas dalam pikiran.  Saya menduga bahwa hanya ada satu fitur di area ini - fakta sejarah yang mereka pelajari.  (Anda dapat membuat pernyataan seperti "mereka menggambarkan dunia nyata" atau "terkait dengan cara kerja otak," tetapi hasil yang dijelaskan dalam buku ini menunjukkan yang sebaliknya). <br><br>  Nah, apa pentingnya sistem aksioma saya untuk logika?  Ukurannya membuat Anda merasakan konten informasi akhir dari logika sebagai sistem aksiomatik.  Dan itu membuat kita percaya - setidaknya untuk saat ini - bahwa kita perlu mempertimbangkan logika lebih sebagai "konstruksi yang diciptakan oleh manusia" daripada sebagai "penemuan" yang terjadi karena "alasan alami". <br><br>  Jika ceritanya berjalan berbeda, dan kami akan terus mencari (seperti yang dilakukan dalam buku ini) untuk banyak sistem aksioma yang paling sederhana, maka kami mungkin akan "membuka" sistem aksioma untuk logika, seperti sistem yang sifatnya kami temukan menarik.  Tetapi karena kita telah mempelajari sejumlah kecil dari semua sistem aksioma yang mungkin, saya pikir akan masuk akal untuk mempertimbangkan logika sebagai "penemuan" - konstruksi yang dibuat khusus. <br><br>  Dalam arti tertentu, pada Abad Pertengahan, logika tampak seperti itu - ketika silogisme yang memungkinkan (jenis argumen yang dapat diterima) diwakili dalam bentuk mnemonik Latin seperti bArbArA dan cElErAnt.  Oleh karena itu, sekarang menarik untuk menemukan representasi mnemonik dari apa yang kita kenal sekarang sebagai sistem aksioma paling sederhana untuk logika. <br><br>  Mulai dari ((p Â· q) Â· r) Â· (p Â· ((p Â· r) Â· p)) = r, masing-masing p Â· q dapat direpresentasikan sebagai awalan atau entri Polandia (terbalik dengan â€œentri Polandia terbalikâ€ dari kalkulator HP ) dalam bentuk Dpq - karena itu, seluruh aksioma dapat dituliskan sebagai = DDDpqrDpDDprpr.  Ada juga mnemonik bahasa Inggris tentang hal ini - FIGure OuT Queue, di mana peran p, q, r dimainkan oleh u, r, e.  Atau Anda dapat melihat huruf pertama dari kata-kata dalam kalimat berikut (di mana B adalah operator, dan p, q, r adalah a, p, c): "Sedikit demi sedikit, sebuah program menghitung aksioma biner aljabar terbaik aljabar Boolean yang mencakup semua kasus" [ aksioma biner terbaik dari aljabar Boolean yang dihitung melalui program secara bertahap menggambarkan semua kasus]. <br><br><h2>  Mekanika Bukti </h2><br>  Oke, jadi bagaimana Anda membuktikan kebenaran sistem aksioma saya?  Hal pertama yang terlintas dalam pikiran adalah untuk menunjukkan bahwa adalah mungkin untuk menyimpulkan dari itu sistem aksioma yang terkenal untuk logika - misalnya, sistem aksioma Schaeffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/54a/161/b5f54a161b3ff941c7459003cd9dffd9.png"></div><br>  Ada tiga aksioma di sini, dan kita perlu menurunkan masing-masing.  Inilah yang dapat Anda lakukan untuk menampilkan yang pertama, menggunakan versi terbaru Bahasa Wolfram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47b/f3e/10c/47bf3e10c7a79db3328816c3ff931a68.png"></div><br>  Patut dicatat bahwa sekarang menjadi mungkin untuk melakukan ini.  Dalam "objek bukti" tertulis bahwa 54 langkah digunakan untuk pembuktian.  Berdasarkan objek ini, kita dapat membuat "buku catatan" yang menjelaskan setiap langkah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/b12/0f3/b2db120f3a2bd50432ed16525ca72342.png"></div><br>  Secara umum, seluruh rangkaian lemma perantara terbukti di sini, yang memungkinkan kita untuk menyimpulkan hasil akhirnya.  Di antara lemma ada seluruh jaringan saling ketergantungan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc1/272/d6f/dc1272d6fd14710be4e2a49ec684efa8.png"></div><br>  Tetapi jaringan yang terlibat dalam derivasi ketiga aksioma dalam sistem aksioma Scheffer - untuk yang terakhir, 504 langkah luar biasa digunakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/0e5/d15/c330e5d159782e0d4cff4931f2b9f605.png"></div><br>  Ya, jelas bahwa jaringan ini sangat membingungkan.  Tetapi sebelum membahas apa arti kompleksitas ini, mari kita bicara tentang apa yang terjadi pada setiap langkah bukti ini. <br><br>  Gagasan utamanya sederhana.  Bayangkan kita memiliki aksioma yang ditulis sebagai p Â· q = q Â· p (secara matematis ini berarti operator komutatif).  Lebih tepatnya, aksioma mengatakan bahwa untuk setiap ekspresi p dan q, p Â· q setara dengan q Â· p. <br><br>  Baiklah, katakanlah kita ingin menyimpulkan dari aksioma ini bahwa (a Â· b) Â· (c Â· d) = (d Â· c) Â· (b Â· a).  Ini dapat dilakukan dengan menggunakan aksioma untuk mengkonversi d Â· c ke c Â· d, b Â· a ke a Â· b, dan akhirnya (c Â· d) Â· (a Â· b) ke (a Â· b) Â· (c Â· d ) <br><br>  FindEquationalProof pada dasarnya melakukan hal yang sama, meskipun tidak mengikuti langkah-langkah ini dalam urutan yang persis sama, dan mengubah sisi kiri persamaan dan kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f4/f43/f6b/9f4f43f6b97bb816052eeb50ec01dcb2.png"></div><br>  Setelah menerima bukti seperti itu, Anda cukup melacak setiap langkah dan memverifikasi bahwa mereka memberikan hasil yang dinyatakan.  Tetapi bagaimana cara menemukan bukti?  Ada banyak kemungkinan urutan permutasi dan transformasi.  Bagaimana menemukan urutan yang berhasil membawa hasil akhir? <br><br>  Orang dapat memutuskan: mengapa tidak mencoba semua urutan yang mungkin, dan jika ada urutan yang berfungsi di antara mereka, maka pada akhirnya harus ditemukan?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya adalah bahwa Anda dapat dengan cepat sampai pada sejumlah sekuens astronomi. </font><font style="vertical-align: inherit;">Sebagian besar seni teorema pembuktian otomatis terdiri dari menemukan cara untuk mengurangi jumlah urutan untuk memverifikasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dengan cepat masuk ke rincian teknis, tetapi ide dasarnya mudah untuk didiskusikan jika Anda mengetahui dasar-dasar aljabar. </font><font style="vertical-align: inherit;">Misalkan kita mencoba untuk membuktikan hasil aljabar seperti</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/402/9b6/fc04029b6fa134be318b5b9999d0beeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada cara yang dijamin untuk melakukan ini: cukup dengan menerapkan aturan aljabar untuk mengungkapkan setiap sisi, Anda dapat langsung melihat kesamaannya: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c93/6e3/5b0/c936e35b0bf0addb94eece9e2379f15f.png"></div><br>  Mengapa ini berhasil?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ada cara untuk bekerja dengan ekspresi seperti itu, secara sistematis menguranginya sampai mereka mengambil bentuk standar. Apakah mungkin untuk melakukan operasi yang sama dalam sistem aksioma yang sewenang-wenang? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak segera. Dalam aljabar, ini berfungsi karena memiliki properti khusus yang memastikan bahwa Anda selalu dapat "bergerak" di sepanjang jalur penyederhanaan ekspresi. Tetapi pada tahun 1970-an, ilmuwan yang berbeda beberapa kali secara independen menemukan (dengan nama seperti algoritma Knuth-Bendix atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basis GrÃ¶bner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) bahwa bahkan jika sistem aksioma tidak memiliki properti internal yang diperlukan, dimungkinkan untuk menemukan "penambahan" ke sistem ini di mana ia ada</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inilah yang terjadi dalam bukti khas yang disediakan FindEquationalProof (berdasarkan sistem Valdmeister, "master of trees"). </font><font style="vertical-align: inherit;">Ada yang disebut </font><font style="vertical-align: inherit;">"Pasangan kritis lemma," yang tidak langsung memajukan buktinya, tetapi memungkinkan munculnya jalur yang mampu melakukan ini. </font><font style="vertical-align: inherit;">Semuanya rumit karena fakta bahwa, meskipun ekspresi akhir yang ingin kita dapatkan cukup singkat, dalam perjalanan ke sana, Anda mungkin harus melalui ekspresi perantara yang jauh lebih lama. </font><font style="vertical-align: inherit;">Oleh karena itu, misalnya, bukti aksioma Schaeffer pertama memiliki langkah-langkah perantara seperti:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/c98/287/b0fc98287cfb9bb8968eea6664aaa0ec.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam hal ini, langkah terbesar adalah 4 kali lebih besar dari aksioma asli: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdd/885/774/cdd885774255091503fdb07d55fd8b0b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekspresi seperti itu dapat direpresentasikan sebagai pohon. </font><font style="vertical-align: inherit;">Ini pohonnya, dibandingkan dengan pohon aksioma asli:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/465/f16/a7f465f1661555adf78695f71ea4fb8c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan ini adalah bagaimana ukuran langkah-langkah menengah berkembang dalam perjalanan pembuktian dari masing-masing aksioma Schaeffer: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/ba7/c59/5d2ba7c5933f2d3d77b0b8acfb594020.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengapa begitu sulit? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mengherankan bahwa bukti ini sangat kompleks? </font><font style="vertical-align: inherit;">Tidak juga. </font><font style="vertical-align: inherit;">Bagaimanapun, kami sangat sadar bahwa matematika bisa rumit. </font><font style="vertical-align: inherit;">Pada prinsipnya, bisa jadi semua kebenaran dalam matematika akan mudah dibuktikan. </font><font style="vertical-align: inherit;">Tetapi salah satu efek samping dari teorema GÃ¶del tahun 1931 adalah bahwa bahkan hal-hal yang memiliki bukti, jalan menuju mereka dapat panjang secara sewenang-wenang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah gejala dari fenomena yang jauh lebih umum, yang saya sebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreducibilitas komputasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pertimbangkan sebuah sistem yang dikendalikan oleh aturan sederhana otomat seluler (tentu saja, dalam esai saya akan selalu ada automata seluler). </font><font style="vertical-align: inherit;">Jalankan sistem ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/f6e/5b2/511f6e5b21afb7a21c62622cab036fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat diputuskan bahwa jika sistem didasarkan pada aturan sederhana, maka harus ada cara cepat untuk memahami apa yang dilakukan sistem.</font></font> Tapi ini tidak benar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prinsip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">tentang kesetaraan komputasi</font></a><font style="vertical-align: inherit;"> , pengoperasian sistem sering kali berhubungan dengan perhitungan, kompleksitasnya bertepatan dengan perhitungan apa pun yang dapat kami lakukan untuk memahami perilaku sistem. Ini berarti bahwa perilaku aktual dari sistem, pada kenyataannya, sesuai dengan jumlah pekerjaan komputasi seperti itu, yang pada prinsipnya tidak dapat dikurangi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengenai gambar di atas: katakanlah kita ingin mengetahui apakah polanya mati pada akhirnya. Kita dapat terus memenuhinya, dan jika kita beruntung, pada akhirnya akan berubah menjadi sesuatu, nasibnya akan menjadi jelas. Namun, secara umum, tidak ada batas atas berapa banyak waktu yang harus kita habiskan, pada kenyataannya, pada buktinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sesuatu seperti ini terjadi dengan bukti logis, itu terjadi sedikit berbeda. Alih-alih memulai sesuatu yang bekerja sesuai dengan aturan tertentu, kami bertanya apakah ada cara untuk mencapai hasil tertentu dengan melalui beberapa langkah, yang masing-masing mematuhi aturan tertentu. Dan tugas ini, sebagai tugas komputasi praktis, jauh lebih rumit. Tetapi esensi kompleksitas adalah fenomena irreducibilitas komputasi yang sama, dan fenomena ini menunjukkan bahwa tidak ada cara umum untuk secara singkat berkeliling proses mempelajari apa yang akan dilakukan sistem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tak perlu dikatakan, ada banyak hal di dunia - terutama dalam teknologi dan pemodelan ilmiah, serta di daerah di mana ada berbagai bentuk aturan - yang secara tradisional dirancang untuk menghindari irreducibilitas komputasi, dan untuk bekerja sehingga hasil pekerjaan mereka segera terlihat, tanpa perlu melakukan perhitungan yang tak tereduksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi salah satu konsekuensi dari prinsip saya tentang kesetaraan komputasi adalah bahwa kasus-kasus ini tunggal dan tidak alami - ia berpendapat bahwa irreducibilitas komputasi ada di semua sistem alam semesta komputasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan matematika? </font><font style="vertical-align: inherit;">Mungkin aturan matematika dipilih secara khusus untuk mendemonstrasikan reducibilitas komputasi. </font><font style="vertical-align: inherit;">Dan dalam beberapa kasus ini adalah kasusnya (dan dalam beberapa hal, ini juga terjadi dalam logika). </font><font style="vertical-align: inherit;">Tetapi sebagian besar, tampaknya sistem aksioma matematika tidak atipikal untuk ruang semua sistem aksioma yang mungkin - di mana irreducibilitas komputasi merajalela.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengapa kita membutuhkan bukti? </font></font></h2><br>  Dalam arti tertentu, bukti diperlukan untuk mengetahui kebenaran sesuatu.  Tentu saja, terutama di zaman kita, bukti telah memudar ke latar belakang, memberi jalan kepada perhitungan murni.  Dalam praktiknya, keinginan untuk menghasilkan sesuatu dengan perhitungan jauh lebih umum daripada keinginan untuk "mundur" dan membangun bukti kebenaran sesuatu. <br><br>  Dalam matematika murni, bagaimanapun, kita sering harus berurusan dengan konsep yang mencakup, setidaknya secara nominal, jumlah kasus yang tak terbatas ("true for all primes", dll.) Yang perhitungan dahi tidak akan bekerja .  Dan ketika pertanyaan muncul konfirmasi ("dapatkah program ini diakhiri dengan kesalahan?" Atau "bisakah saya menghabiskan cryptocurrency ini dua kali?") Lebih masuk akal untuk mencoba membuktikannya daripada menghitung semua kemungkinan kasus. <br><br>  Namun dalam praktik matematika nyata, bukti lebih dari sekadar menegakkan kebenaran.  Ketika Euclid menulis " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Awal</a> ", ia hanya menunjukkan hasilnya, dan "menyerahkannya kepada pembaca".  Tapi, satu atau lain cara, terutama selama abad terakhir, bukti telah berubah menjadi sesuatu yang tidak hanya terjadi di belakang layar, tetapi merupakan media utama yang melaluinya perlu untuk menyiarkan konsep. <br><br>  Tampak bagi saya bahwa sebagai akibat dari beberapa kekhasan sejarah, bukti ditawarkan hari ini sebagai objek yang harus dipahami orang, dan program dianggap hanya sesuatu yang harus dijalankan oleh komputer.  Mengapa ini terjadi?  Ya, setidaknya di masa lalu, bukti dapat disajikan dalam bentuk teks - karena itu, jika ada yang menggunakannya, maka hanya orang.  Dan program hampir selalu direkam dalam bentuk bahasa komputer.  Dan untuk waktu yang sangat lama, bahasa-bahasa ini diciptakan sehingga mereka dapat secara kurang lebih langsung menerjemahkannya ke dalam operasi komputer tingkat rendah - yaitu, komputer segera memahaminya, tetapi orang tidak harus melakukannya. <br><br>  Tetapi salah satu tujuan utama pekerjaan saya selama beberapa dekade terakhir adalah mengubah keadaan ini, dan untuk mengembangkan bahasa Wolfram menjadi "bahasa komunikasi komputasi" yang nyata di mana ide-ide komputasi dapat ditransmisikan sehingga mereka dapat dipahami oleh komputer dan orang-orang. <br><br>  Bahasa seperti itu memiliki banyak konsekuensi.  Salah satunya adalah mengubah peran bukti.  Misalkan kita melihat beberapa hasil matematika.  Di masa lalu, satu-satunya cara yang masuk akal untuk membawanya ke pemahaman adalah dengan memberikan bukti bahwa orang membaca.  Tetapi sekarang hal lain mungkin: Anda dapat memberikan program untuk Bahasa Wolfram yang menghitung hasilnya.  Dan ini dalam banyak hal merupakan cara yang lebih kaya untuk menyampaikan kebenaran hasilnya.  Setiap bagian dari program adalah sesuatu yang tepat dan tidak ambigu - setiap orang dapat memulainya.  Tidak ada masalah seperti upaya untuk memahami beberapa bagian dari teks, membutuhkan mengisi beberapa celah.  Semuanya ditunjukkan dalam teks dengan jelas. <br><br>  Bagaimana dengan buktinya?  Adakah cara yang jelas dan tepat untuk menulis bukti?  Berpotensi ya, meskipun ini tidak mudah.  Dan meskipun fondasi Bahasa Wolfram telah ada selama 30 tahun, hanya hari ini cara yang masuk akal muncul untuk menyajikan bukti langsung secara struktural dengannya, seperti salah satu aksioma saya di atas. <br><br>  Anda dapat membayangkan membuat bukti dalam Bahasa Wolfram dengan cara yang sama seperti ketika orang membuat program - dan kami bekerja untuk menyediakan versi tingkat tinggi dari fungsi ini yang â€œmembantu dengan buktiâ€.  Namun, tidak ada yang membuat bukti sistem aksioma saya - komputer menemukannya.  Dan ini lebih seperti output dari program daripada program itu sendiri.  Namun, seperti program, dalam arti tertentu, buktinya juga dapat "dijalankan" untuk memverifikasi hasilnya. <br><br><h2>  Menciptakan kejelasan </h2><br>  Sebagian besar waktu, orang yang menggunakan Bahasa Wolfram, atau Wolfram | Alpha, ingin menghitung sesuatu.  Mereka perlu mendapatkan hasilnya, tidak mengerti mengapa mereka mendapatkan hasil seperti itu.  Namun dalam Wolfram | Alpha, terutama di bidang-bidang seperti matematika dan kimia, fitur yang populer di kalangan siswa adalah konstruksi solusi "langkah-demi-langkah". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/a19/015/77da190153b5c78394653c8bdee8bb98.png"></div><br>  Ketika sistem Wolfram | Alpha menghitung, misalnya, integral, ia menggunakan segala macam teknik algoritme yang kuat yang dioptimalkan untuk menerima jawaban.  Tetapi ketika dia diminta untuk menunjukkan tahapan perhitungan, dia melakukan sesuatu yang lain: dia perlu menjelaskan dalam langkah-langkah mengapa ini adalah hasil yang diperoleh. <br><br>  Tidak ada manfaatnya menjelaskan bagaimana hasil sebenarnya diperoleh;  Ini adalah proses yang sangat tidak pantas bagi manusia.  Dia perlu memahami operasi apa yang dipelajari oleh orang-orang yang dapat digunakan untuk mendapatkan hasil.  Seringkali dia menemukan beberapa trik yang berguna.  Ya, dia memiliki cara sistematis untuk melakukan ini, yang selalu berhasil.  Tetapi ada terlalu banyak tahapan "mekanis" di dalamnya.  "Trik" (substitusi, integrasi parsial, dll.) Tidak akan berfungsi dalam kasus umum, tetapi dalam hal khusus ini akan memberikan cara yang lebih cepat untuk jawabannya. <br><br>  Bagaimana dengan mendapatkan versi yang jelas dari hal-hal lain?  Misalnya, pekerjaan program dalam kasus umum.  Atau bukti sistem aksioma saya. <br><br>  Mari kita mulai dengan programnya.  Misalkan kita menulis sebuah program dan ingin menjelaskan cara kerjanya.  Salah satu pendekatan tradisional adalah memasukkan komentar dalam kode.  Jika kita menulis dalam bahasa tradisional tingkat rendah, ini mungkin jalan keluar terbaik.  Tetapi seluruh esensi dari Bahasa Wolfram sebagai bahasa komunikasi komputasi adalah bahwa bahasa itu sendiri harus memungkinkan transmisi ide, tanpa perlu memasukkan potongan teks tambahan. <br><br>  Upaya harus dilakukan untuk membuat program Bahasa Wolfram deskripsi yang baik dari proses, serta membuat teks bahasa Inggris yang sederhana deskripsi yang baik dari proses.  Namun, Anda bisa mendapatkan sepotong kode Bahasa Wolfram yang menjelaskan dengan sangat jelas bagaimana semuanya berjalan sendiri. <br><br>  Tentu saja, sering terjadi bahwa eksekusi kode yang sebenarnya mengarah ke hal-hal yang tidak mengikuti jelas dari program.  Saya akan segera menyebutkan kasus ekstrim seperti automata seluler.  Tetapi untuk sekarang, mari kita bayangkan bahwa kita telah menciptakan sebuah program yang dengannya kita dapat membayangkan apa yang secara umum dilakukannya. <br><br>  Dalam hal itu, saya menemukan bahwa esai komputasi yang disajikan sebagai Notebook Wolfram adalah alat yang hebat untuk menjelaskan apa yang terjadi.  Penting bagi Wolfram Language, ini memungkinkan Anda untuk menjalankan bahkan bagian terkecil dari program secara terpisah (dengan ekspresi simbolik yang sesuai sebagai data input dan output).  Setelah itu, Anda bisa membayangkan urutan langkah-langkah program sebagai urutan elemen dialog yang membentuk dasar notebook komputasi. <br><br>  Dalam praktiknya, seringkali perlu untuk membuat visualisasi data input dan output.  Ya, semuanya dapat diekspresikan sebagai representasi simbol yang tidak ambigu.  Tetapi jauh lebih mudah bagi orang untuk memahami representasi visual dari hal-hal daripada garis seperti bahasa satu dimensi. <br><br>  Tentu saja, menciptakan visualisasi yang baik mirip dengan seni.  Tetapi di Wolfram Language, kami melakukan banyak pekerjaan untuk mengotomatisasi seni ini - seringkali dengan bantuan pembelajaran mesin yang cukup canggih dan algoritma lain yang melakukan hal-hal seperti tata letak jaringan atau elemen grafis. <br><br>  Bagaimana dengan memulai dengan pelacakan program sederhana?  Ini sulit dilakukan.  Saya telah bereksperimen dengan ini selama beberapa dekade, dan tidak pernah sepenuhnya puas dengan hasilnya.  Ya, Anda dapat memperbesar dan melihat banyak detail tentang apa yang terjadi.  Tetapi saya tidak menemukan teknik yang cukup baik untuk memahami keseluruhan gambar, dan secara otomatis memberikan beberapa hal yang sangat berguna. <br><br>  Pada tingkat tertentu, tugas ini mirip dengan rekayasa terbalik.  Anda ditunjukkan kode mesin, sirkuit chip, apa pun.  Dan Anda perlu mengambil langkah mundur dan menciptakan kembali deskripsi tingkat tinggi dari mana orang tersebut menolak, yang entah bagaimana "menyusun" ke dalam apa yang Anda lihat. <br><br>  Dalam pendekatan teknik tradisional, ketika orang menciptakan produk dalam langkah-langkah, selalu memiliki kemampuan untuk mengantisipasi konsekuensi dari apa yang mereka buat, pendekatan ini dapat bekerja secara prinsip.  Tetapi jika Anda hanya berkeliling dunia komputasi untuk mencari program yang optimal (karena saya sedang mencari kemungkinan sistem aksioma untuk menemukan sistem logika), maka tidak ada jaminan bahwa akan ada "sejarah manusia" atau penjelasan di balik program ini. <br><br>  Masalah serupa juga ditemukan dalam ilmu alam.  Anda melihat bagaimana serangkaian proses yang kompleks berkembang dalam sistem biologis.  Apakah mungkin untuk membuat mereka â€œmelakukan rekayasa balikâ€ untuk menemukan â€œpenjelasanâ€?  Terkadang dapat dikatakan bahwa evolusi dengan seleksi alam akan mengarah pada ini.  Atau bahwa itu sering ditemukan di alam semesta komputasi, sehingga kemungkinan kejadiannya tinggi.  Tetapi tidak ada jaminan bahwa dunia alami perlu dirancang sehingga orang dapat menjelaskannya. <br><br>  Secara alami, ketika membuat model berbagai hal, kita pasti hanya mempertimbangkan aspek-aspek yang menarik bagi kita, dan mengidealkan segala sesuatu yang lain.  Dan terutama di bidang-bidang seperti kedokteran, Anda sering harus bekerja dengan model perkiraan dengan pohon keputusan yang dangkal, yang mudah dijelaskan. <br><br><h2>  Sifat penjelasan </h2><br>  Apa arti ungkapan "sesuatu yang bisa dijelaskan"?  Intinya, ini artinya orang bisa memahaminya. <br><br>  Apa yang diperlukan orang untuk memahami sesuatu?  Kita perlu menyadari ini entah bagaimana.  Ambil otomat seluler khas dengan perilaku kompleks.  Komputer tidak memiliki masalah untuk melewati setiap langkah dalam evolusinya.  Dengan upaya dan tenaga yang luar biasa, seseorang dapat mereproduksi karya komputer. <br><br>  Tetapi tidak dapat dikatakan bahwa dalam kasus ini seseorang akan "memahami" apa yang dilakukan oleh sebuah otomat seluler.  Untuk ini, seseorang harus dengan mudah berbicara tentang perilaku otomat seluler pada tingkat tinggi.  Atau, dengan kata lain, seseorang harus bisa "menceritakan sebuah kisah" tentang perilaku robot yang bisa dipahami orang lain. <br><br>  Apakah ada cara universal untuk melakukan ini?  Tidak, karena irreducibilitas komputasi.  Namun, dapat terjadi bahwa fitur tertentu yang penting bagi orang dapat dijelaskan pada tingkat tinggi dengan batasan tertentu. <br><br>  Bagaimana cara kerjanya?  Untuk melakukan ini, Anda perlu membuat bahasa tingkat tinggi tertentu yang dapat menggambarkan fitur yang menarik bagi kami.  Mempelajari gambar khas dari automaton seluler, seseorang dapat mencoba untuk berbicara bukan dalam hal warna dari sejumlah besar sel individu, tetapi dalam hal struktur tingkat yang lebih tinggi yang dapat dideteksi.  Hal utama adalah bahwa Anda dapat mengkompilasi setidaknya sebagian katalog struktur seperti itu: walaupun akan ada banyak detail yang tidak sesuai dengan klasifikasi, struktur tertentu adalah umum. <br><br>  Dan jika kita ingin mulai "menjelaskan" perilaku otomat seluler, kita akan mulai dengan memberi nama struktur, dan kemudian kita akan berbicara tentang apa yang terjadi dari sudut pandang struktur ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b79/395/b3b/b79395b3bad1a1a63252ad645d54cc4b.png"></div><br>  Kasus otomat seluler memiliki satu fitur penyederhanaan: karena beroperasi atas dasar aturan deterministik sederhana, ia memiliki struktur yang sama berulang.  Di alam, misalnya, kita biasanya tidak mengalami pengulangan yang identik.  Hanya ada satu, misalnya, seekor harimau, sangat mirip dengan yang lain, oleh karena itu kami menyebut mereka berdua "harimau", meskipun susunan atom mereka tidak identik. <br><br>  Apa arti umum dari semua ini?  Ini terdiri dalam menggunakan ide representasi simbolik.  Kami mengatakan bahwa kami dapat menetapkan simbol tertentu - sering kali kata ini - yang dapat digunakan untuk menggambarkan secara simbolis seluruh kelas benda, tanpa harus mendaftar secara detail setiap detail dari semua komponen hal-hal ini. <br><br>  Ini mirip dengan kompresi informasi: kami menggunakan konstruksi simbolis untuk menemukan cara yang lebih singkat untuk menggambarkan hal-hal yang menarik bagi kami. <br><br>  Misalkan kita menghasilkan struktur raksasa, misalnya, yang matematika: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/923/5ac/27d9235ac9fd46bd22ef8c526e0afbc6.png"></div><br>  Langkah pertama adalah membuat semacam representasi internal tingkat tinggi.  Sebagai contoh, kita dapat mendeteksi struktur yang dapat digunakan kembali.  Dan kita bisa memberi mereka nama.  Dan kemudian tunjukkan "kerangka" dari seluruh struktur dengan bantuan mereka: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/102/c89/ba2102c898a14c573ddd207694fd5696.png"></div><br>  Ya, skema ini, mirip dengan "kompresi kamus", berguna untuk mencapai tingkat penjelasan yang pertama. <br><br>  Tapi mari kita kembali ke bukti sistem aksioma saya.  Lemma yang dibuat dalam bukti ini dipilih secara khusus sebagai elemen yang dapat digunakan kembali.  Namun, mengecualikan mereka, kita masih punya bukti bahwa orang tidak bisa segera mengerti. <br><br>  Apa lagi yang bisa kamu lakukan?  Kita perlu membuat semacam deskripsi dari level yang bahkan lebih tinggi.  Apa itu? <br><br><h2>  Konsep konsep </h2><br>  Jika Anda mencoba menjelaskan sesuatu kepada seseorang, maka akan jauh lebih mudah untuk melakukan ini jika Anda menemukan sesuatu yang lain, tetapi serupa dengan seseorang yang sudah dapat mengerti.  Bayangkan bagaimana Anda akan menjelaskan konsep drone modern kepada seseorang dari Zaman Batu.  Ini akan sulit dilakukan.  Tetapi akan lebih mudah untuk menjelaskan hal ini kepada seseorang yang hidup 50 tahun yang lalu, dan sudah melihat helikopter dan model pesawat terbang. <br><br>  Dan pada akhirnya, intinya adalah bahwa ketika kita menjelaskan sesuatu, kita melakukannya dalam bahasa yang kita kenal dan juga kepada siapa kita menjelaskannya.  Dan semakin kaya bahasanya, semakin sedikit elemen baru yang harus kita perkenalkan untuk menyampaikan apa yang ingin kita jelaskan. <br><br>  Ada pola yang berulang sepanjang sejarah pikiran.  Serangkaian hal diperhatikan beberapa kali.  Secara bertahap, mereka mulai memahami bahwa hal-hal ini entah bagaimana mirip secara abstrak, dan semuanya dapat dijelaskan dalam konsep baru, yang dijelaskan dalam beberapa kata atau frasa baru. <br><br>  Misalkan kita memperhatikan hal-hal seperti air, darah, dan minyak.  Pada titik tertentu, kami memahami bahwa ada konsep umum "cair", dan semuanya dapat digambarkan sebagai cair.  Dan ketika kita memiliki konsep seperti itu, kita dapat mulai berpikir dalam istilah-istilahnya, menemukan lebih banyak konsep - katakanlah viskositas, berdasarkan padanya. <br><br>  Kapan masuk akal untuk menggabungkan hal-hal menjadi konsep?  Sebuah pertanyaan sulit yang tidak dapat dijawab tanpa meramalkan segala sesuatu yang dapat dilakukan dengan konsep ini.  Dalam praktiknya, dalam proses evolusi bahasa dan ide-ide seseorang, suatu proses tertentu dari pendekatan yang berurutan diamati. <br><br>  Dalam sistem pembelajaran mesin modern, penjumlahan informasi yang jauh lebih cepat terjadi.  Bayangkan kita mengambil segala macam objek di seluruh dunia, dan memberi mereka fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FeatureSpacePlot</a> untuk melihat apa yang terjadi.  Jika kita mendapatkan kluster tertentu dalam ruang fitur, maka kita dapat menyimpulkan bahwa masing-masing dapat didefinisikan sesuai dengan "konsep" tertentu, yang, misalnya, dapat ditandai dengan kata. <br><br>  Jujur saja, apa yang terjadi pada FeatureSpacePlot - seperti dalam proses pengembangan intelektual manusia - dalam arti tertentu, merupakan proses langkah demi langkah.  Untuk mendistribusikan objek berdasarkan ruang fitur, FeatureSpacePlot menggunakan fitur yang dipelajari untuk mengekstrak dari upaya sebelumnya untuk mengkategorikan. <br><br>  Nah, jika kita menerima dunia apa adanya, apa kategori terbaik - atau konsep - yang dapat digunakan untuk menggambarkan sesuatu?  Pertanyaan ini terus berkembang.  Secara umum, semua terobosan - baik itu sains, teknologi, atau sesuatu yang lain - sering dikaitkan dengan realisasi kemungkinan mengidentifikasi kategori atau konsep baru dengan cara yang bermanfaat. <br><br>  Tetapi dalam proses evolusi peradaban kita ada spiral tertentu.  Pertama, konsep tertentu yang pasti didefinisikan - katakanlah, ide program.  Setelah itu, orang mulai menggunakannya dan merefleksikan istilah-istilahnya.  Segera, banyak konsep berbeda dibangun berdasarkan konsep ini.  Dan kemudian tingkat abstraksi ditentukan, konsep baru berdasarkan yang sebelumnya dibuat. <br><br>  Sejarah adalah karakteristik dari seperangkat pengetahuan teknologi peradaban modern, dan seperangkat pengetahuan intelektualnya.  Baik di sana maupun di sana ada menara konsep dan tingkat abstraksi yang terjadi satu demi satu. <br><br><h2>  Masalah belajar </h2><br>  Agar orang dapat berkomunikasi menggunakan konsep tertentu, mereka perlu mengetahuinya.  Dan, ya, beberapa konsep (seperti keteguhan objek) secara otomatis dikenali oleh orang-orang hanya dengan mengamati alam.  Tetapi anggaplah, jika Anda melihat daftar kata-kata umum dari bahasa Inggris modern, akan menjadi jelas bahwa sebagian besar konsep yang digunakan oleh peradaban modern kita tidak berlaku untuk mereka yang orang sadari ketika mengamati alam. <br><br>  Sebaliknya - yang sangat mengingatkan pada pembelajaran mesin modern - mereka membutuhkan pengetahuan khusus tentang dunia "di bawah pengawasan", yang diselenggarakan untuk menekankan pentingnya konsep-konsep tertentu.  Dan di area yang lebih abstrak (seperti matematika), mereka mungkin perlu mengalami konsep dalam bentuk abstrak langsung mereka. <br><br>  Baiklah, tetapi apakah kita perlu belajar lebih banyak dan lebih lagi setiap saat dengan meningkatnya jumlah akumulasi pengetahuan intelektual peradaban?  Mungkin ada kekhawatiran bahwa pada titik tertentu otak kita tidak akan dapat mengikuti perkembangan, dan kita harus menambahkan beberapa bantuan tambahan.  Tetapi bagi saya tampaknya ini, untungnya, adalah salah satu kasus di mana masalahnya dapat diselesaikan "di tingkat perangkat lunak." <br><br>  Masalahnya adalah ini: setiap saat dalam sejarah ada serangkaian konsep yang penting bagi kehidupan di dunia pada periode ini.  Dan, ya, dengan perkembangan peradaban, konsep-konsep baru terungkap dan konsep-konsep baru diperkenalkan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada proses lain: konsep baru memperkenalkan tingkat abstraksi baru, biasanya termasuk sejumlah besar konsep sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita sering dapat mengamati ini dalam teknologi. Ada saat ketika Anda perlu tahu banyak detail tingkat rendah untuk bekerja di komputer. Namun seiring waktu, detail-detail ini disarikan, jadi sekarang Anda hanya perlu konsep umum. Anda mengklik ikon dan proses dimulai - Anda tidak perlu memahami seluk-beluk operasi sistem operasi, interrupt handler, penjadwal, dan semua detail lainnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan tentu saja, Bahasa Wolfram memberikan contoh yang bagus tentang hal ini. Ini menempatkan banyak upaya dalam mengotomatisasi banyak detail tingkat rendah (misalnya, algoritma mana yang harus digunakan) dan memungkinkan pengguna untuk berpikir dalam konsep tingkat tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, orang masih diperlukan yang memahami detail yang mendasari abstraksi (walaupun saya tidak yakin berapa banyak pemotong batu yang dibutuhkan masyarakat modern). Tetapi sebagian besar, pendidikan dapat berkonsentrasi pada tingkat pengetahuan yang tinggi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sering diasumsikan bahwa untuk mencapai konsep tingkat tinggi dalam proses pembelajaran, seseorang pertama-tama harus merangkum sejarah bagaimana konsep-konsep ini muncul secara historis. Tetapi biasanya - dan, mungkin, selalu - tampaknya tidak demikian. Anda dapat memberikan contoh ekstrem: bayangkan bahwa untuk mempelajari cara menggunakan komputer, Anda harus terlebih dahulu melewati seluruh sejarah logika matematika. Namun, sebenarnya diketahui bahwa orang segera beralih ke konsep komputasi modern, tanpa perlu mempelajari semacam sejarah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi, bagaimana kejelasan jaringan konsep itu? Adakah konsep yang hanya bisa dipahami dengan memahami konsep lain? Mengingat pelatihan orang berdasarkan interaksi dengan lingkungan (atau pelatihan jaringan saraf), tatanan mereka mungkin ada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagi saya tampaknya suatu prinsip tertentu, mirip dengan universalitas komputasi, menunjukkan bahwa dengan "otak murni" di tangan, Anda dapat mulai dari mana saja. </font><font style="vertical-align: inherit;">Jadi, jika beberapa alien akan belajar tentang teori kategori dan hampir tidak ada yang lain, mereka akan, tanpa ragu, membangun jaringan konsep di mana teori ini adalah akar, dan apa yang kita ketahui sebagai dasar-dasar aritmatika akan dipelajari dari mereka suatu tempat dalam analog dari lembaga kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, alien semacam itu dapat membangun serangkaian teknologi dan lingkungan mereka dengan cara yang sangat berbeda dari kita - sama seperti kisah kita bisa menjadi sangat berbeda jika komputer dapat berhasil dikembangkan pada abad ke-19, dan tidak di pertengahan abad ke-20.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemajuan matematika </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sering merefleksikan sejauh mana lintasan sejarah matematika tunduk pada peran kebetulan, dan sejauh mana itu tidak bisa dihindari. Seperti yang telah saya sebutkan, pada tingkat sistem formal, ada banyak sistem aksioma yang memungkinkan Anda membangun sesuatu yang secara formal menyerupai matematika. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sejarah nyata matematika tidak dimulai dengan sistem aksioma yang sewenang-wenang. Itu dimulai pada zaman Babilonia dengan upaya untuk menggunakan aritmatika untuk perdagangan, dan untuk geometri untuk tujuan pengembangan tanah. Dan dari akar-akar praktis ini, tingkat abstraksi selanjutnya mulai ditambahkan, yang akhirnya mengarah ke matematika modern - misalnya, angka secara bertahap digeneralisasikan dari bilangan bulat positif ke rasional, lalu ke akar, lalu ke semua bilangan bulat, ke pecahan desimal, ke bilangan kompleks, ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aljabar angka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka empat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan seterusnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ada jalan perkembangan abstraksi yang tak terhindarkan? </font><font style="vertical-align: inherit;">Saya curiga, sampai batas tertentu, ya. </font><font style="vertical-align: inherit;">Mungkin demikian halnya dengan jenis-jenis pembentukan konsep lainnya. </font><font style="vertical-align: inherit;">Setelah mencapai tingkat tertentu, Anda mendapat kesempatan untuk mempelajari berbagai hal, dan seiring waktu, kelompok-kelompok ini menjadi contoh konstruksi yang lebih umum dan abstrak - yang pada gilirannya menentukan tingkat baru, dari mana, seseorang dapat belajar sesuatu yang baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ada cara untuk keluar dari siklus ini? </font><font style="vertical-align: inherit;">Satu kemungkinan mungkin terkait dengan eksperimen matematika. </font><font style="vertical-align: inherit;">Seseorang dapat secara sistematis membuktikan hal-hal yang berkaitan dengan sistem matematika tertentu. </font><font style="vertical-align: inherit;">Tetapi orang dapat secara empiris hanya memperhatikan fakta matematika - seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ramanujan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pernah memperhatikan itu </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.092ex" height="2.78ex" viewBox="0 -1091.4 2623.1 1197.1" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,362)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMATHI-3C0" x="0" y="0"></use><g transform="translate(405,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMAIN-221A" x="0" y="26"></use><rect stroke="none" width="1061" height="42" x="589" y="543"></rect><g transform="translate(589,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMAIN-36" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhi7bXhvZKYLAF7o9IeOiCU2Fk1dEw#MJMAIN-33" x="1001" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mi>Ï€</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">e^{\pi \sqrt{163}}</script><br><br><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara yang sama bahwa seseorang dapat nomor sistem aksioma, orang dapat membayangkan penomoran pertanyaan yang mungkin dalam matematika. Tapi ini segera memunculkan masalah. Teorema GÃ¶del menyatakan bahwa dalam sistem aksioma seperti yang terkait dengan aritmatika, ada teorema â€œyang secara formal tidak dapat diselesaikanâ€ yang tidak dapat dibuktikan atau dibantah dalam kerangka kerja sistem aksioma ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, contoh spesifik yang dibuat oleh GÃ¶del tampak sangat jauh dari apa yang sebenarnya bisa muncul di kelas matematika. Dan untuk waktu yang lama diyakini bahwa dalam beberapa hal, fenomena ketidakmampuan memecahkan masalah adalah sesuatu yang, pada prinsipnya, ada, tetapi tidak akan terkait dengan "matematika nyata".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, sesuai dengan prinsip saya tentang kesetaraan komputasi dan pengalaman saya di alam semesta komputasi, saya cukup yakin bahwa ini tidak benar - dan bahwa pada kenyataannya tidak dapat dipecahkan sangat dekat bahkan dalam matematika tipikal. Saya tidak akan terkejut jika bagian nyata dari masalah matematika yang belum terpecahkan untuk hari ini ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hipotesis Riemann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P = NP, dll.) Tidak dapat diselesaikan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika ada banyak masalah yang tidak dapat diatasi, bagaimana bisa begitu banyak hal dalam matematika berhasil diselesaikan? Saya pikir ini karena masalah yang berhasil diselesaikan dipilih secara khusus untuk menghindari ketidakmampuan memecahkan, hanya karena bagaimana perkembangan matematika dibangun. Karena, jika kita, pada kenyataannya, membentuk tingkat abstraksi yang berurutan berdasarkan konsep yang telah kita buktikan, maka kita membuka jalan yang dapat bergerak maju tanpa berubah menjadi tidak dapat dipecahkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, matematika eksperimental atau "pertanyaan acak" dapat dengan segera membawa kita ke area yang penuh dengan ketidakmampuan memecahkan masalah. Tapi, setidaknya untuk saat ini, disiplin dasar matematika belum berkembang dengan cara ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bagaimana dengan "fakta acak matematika" ini? Ya, sama dengan bidang penelitian intelektual lainnya. "Fakta acak" tidak termasuk dalam jalur perkembangan intelektual sampai beberapa struktur - biasanya beberapa konsep abstrak - dibangun di sekitar mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang baik adalah penemuan favorit saya tentang asal kompleksitas dalam sistem seperti itu, biasanya 30 automata seluler. Ya, fenomena serupa sudah diamati bahkan ribuan tahun yang lalu (misalnya, keacakan dalam urutan bilangan prima). Tetapi tanpa platform konseptual yang lebih luas, hanya sedikit orang yang memperhatikannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh lain adalah urutan bersarang (fraktal). Ada beberapa contoh bagaimana mereka bertemu dalam mosaik abad XIII, tetapi tidak ada yang memperhatikan mereka sampai pada 1980-an seluruh platform muncul di sekitar fraktal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kisah yang sama berulang berulang: sampai konsep abstrak didefinisikan, sulit untuk membahas konsep baru, bahkan ketika dihadapkan dengan fenomena yang menunjukkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menduga bahwa ini adalah kasus dalam matematika: ada pelapisan tertentu dari beberapa konsep abstrak di atas yang lain, yang menentukan jalur matematika. Apakah cara ini unik? Tidak diragukan lagi, tidak. Dalam ruang yang luas dari fakta-fakta matematika yang mungkin, ada arah tertentu yang dipilih untuk konstruksi lebih lanjut. Tapi Anda bisa memilih yang lain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ini berarti bahwa topik-topik dalam matematika tidak terhindarkan didorong oleh kecelakaan historis? </font><font style="vertical-align: inherit;">Tidak sebanyak yang Anda pikirkan. </font><font style="vertical-align: inherit;">Memang, ketika matematika ditemukan berulang kali, dimulai dengan hal-hal seperti aljabar dan geometri, ada kecenderungan yang luar biasa di mana arah yang berbeda dan pendekatan yang berbeda mengarah pada hasil yang setara atau sesuai satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin, sampai batas tertentu, ini adalah konsekuensi dari prinsip kesetaraan komputasi, dan fenomena universalitas komputasi: meskipun aturan dasar (atau "bahasa") yang digunakan dalam berbagai bidang matematika berbeda, hasilnya adalah cara untuk menerjemahkan di antara mereka - dan pada tingkat abstraksi berikutnya jalan yang dipilih tidak akan lagi begitu kritis.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bukti logis dan otomatisasi abstraksi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kembali ke bukti logis. Bagaimana mereka terkait dengan tipikal matematika? Sejauh ini, tidak mungkin. Ya, buktinya memiliki bentuk nominal yang sama dengan bukti matematika standar. Tetapi itu tidak "ramah untuk orang matematika." Ini hanya bagian mekanis. Ini tidak terkait dengan konsep abstrak tingkat tinggi yang akan dimengerti oleh matematika manusia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan banyak membantu kita jika kita menemukan bahwa lemmas non-sepele pembuktian sudah muncul dalam literatur matematika (saya tidak berpikir bahwa ini benar, tetapi kemungkinan pencarian kami oleh teorema belum mencapai tingkat yang dapat kami yakini). Tetapi jika mereka muncul, itu mungkin akan memberi kita cara untuk menghubungkan lemma ini dengan hal-hal lain dalam matematika, dan mendefinisikan lingkaran konsep abstrak mereka.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagaimana bukti dapat dijelaskan tanpa ini? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ada beberapa cara lain untuk melakukan pembuktian, secara fundamental lebih kuat terkait dengan matematika yang ada. Tetapi bahkan dengan bukti yang kita miliki sekarang, orang dapat membayangkan "mengutak-atik" konsep-konsep baru yang akan mendefinisikan tingkat abstraksi yang lebih tinggi dan menempatkan bukti ini dalam konteks yang lebih umum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak yakin bagaimana melakukan ini. Saya sedang mempertimbangkan untuk menominasikan hadiah (sesuatu seperti </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Penghargaan Turing 2007</font></a><font style="vertical-align: inherit;"> saya</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) untuk "mengubah bukti menjadi bentuk yang dapat dimengerti." Namun, benar-benar tidak dapat dipahami bagaimana seseorang dapat mengevaluasi "kemampuan menjelaskan". Seseorang mungkin diminta untuk merekam video berdurasi satu jam di mana penjelasan bukti yang berhasil akan diberikan, cocok untuk ahli matematika tipikal - tetapi itu akan sangat subyektif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi dengan cara yang sama mungkin untuk mengotomatiskan pencarian tata letak jaringan yang indah, mungkin kita dapat mengotomatiskan proses mengubah bukti menjadi dapat dijelaskan. Bukti saat ini, pada kenyataannya, tanpa penjelasan, menyarankan untuk mempertimbangkan beberapa ratus lemma. Tapi anggaplah kita bisa mendefinisikan sejumlah kecil lemma "menarik". Mungkin kita bisa menambahkannya ke kanon matematika terkenal kita, dan kemudian kita bisa menggunakannya untuk memahami buktinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada analogi dengan perkembangan bahasa. Dengan menciptakan Bahasa Wolfram, saya mencoba mengidentifikasi "karya komputasi" yang sering dibutuhkan orang. Kami membuat fungsi yang dibangun ke dalam bahasa dari mereka, dengan nama-nama spesifik yang dapat digunakan orang untuk merujuk mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses serupa sedang berlangsung - meskipun sama sekali tidak terorganisir - dalam evolusi bahasa alami. "Potongan makna" yang ternyata berguna akhirnya mendapatkan kata-kata mereka dalam bahasa. Terkadang mereka mulai dengan frasa yang terdiri dari beberapa kata yang ada. Tetapi yang paling berpengaruh biasanya ternyata sangat jauh dari kata-kata yang ada sehingga muncul dalam bentuk kata-kata baru, yang berpotensi cukup sulit untuk didefinisikan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam mengembangkan Bahasa Wolfram, yang fungsinya disebut menggunakan kata-kata bahasa Inggris, saya mengandalkan pemahaman umum seseorang tentang bahasa Inggris (dan kadang-kadang pada pemahaman kata-kata yang digunakan dalam aplikasi komputer umum). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang harus melakukan sesuatu yang serupa dalam menentukan lemmas mana yang akan ditambahkan ke kanon matematika. Akan diperlukan tidak hanya untuk memastikan bahwa setiap lemma entah bagaimana akan "pada dasarnya menarik", tetapi juga untuk memilih lemma yang "mudah untuk disimpulkan" dari konsep dan hasil matematika yang ada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi apa yang membuat lemma â€œpada dasarnya menarikâ€? Harus dikatakan bahwa sebelum saya mengerjakan buku saya, saya menyalahkan pilihan lemma (atau menara) dalam bidang matematika apa pun yang dijelaskan dan dinamai dalam buku teks, kesewenang-wenangan besar dan kecelakaan historis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi, setelah menganalisis teorema dari logika dasar secara terperinci, saya terkejut menemukan sesuatu yang sama sekali berbeda. Misalkan kita telah membangun semua teorema logika yang benar sesuai dengan ukurannya </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(misalnya, p = p akan menjadi yang pertama, p DAN p = p - sedikit kemudian, dll.). Daftar ini memiliki banyak redundansi. Sebagian besar teorema ternyata merupakan perpanjangan sepele dari teorema yang sudah muncul dalam daftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi kadang-kadang muncul sebuah teorema yang menghasilkan informasi baru yang tidak dapat dibuktikan berdasarkan teorema yang sudah muncul dalam daftar. Fakta yang luar biasa: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada 14 teorema seperti itu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan mereka, pada intinya, persis sesuai dengan teorema yang biasanya diberikan nama dalam buku teks pada logika (di sini DAN adalah âˆ§, ATAU adalah âˆ¨, ATAU adalah âˆ¨, dan BUKAN adalah Â¬.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/078/057/a0007805787992eee313fa748deba866.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan kata lain, dalam hal ini teorema yang dinamai atau "menarik" adalah teorema yang membuat pernyataan tentang informasi baru dengan ukuran minimum. Ya, menurut definisi ini, setelah beberapa waktu, informasi baru tidak akan ada lagi, karena kami akan mendapatkan semua aksioma yang diperlukan untuk membuktikan segala sesuatu yang mungkin - walaupun Anda dapat melangkah lebih jauh dengan mulai membatasi kerumitan bukti yang dapat diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan teorema NAND, misalnya, yang ditemukan dalam buktinya? Sekali lagi, Anda dapat membangun semua teorema yang benar secara berurutan, dan menemukan mana yang tidak dapat dibuktikan berdasarkan teorema sebelumnya dari daftar:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/4b3/022/3a84b3022c9b5408ce524671b006c814.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NAND tidak memiliki tradisi historis seperti AND, OR dan NOT. Dan, tampaknya, tidak ada bahasa manusia di mana NAND dilambangkan dengan satu kata. Namun dalam daftar teorema NAND, yang pertama di atas mudah dikenali sebagai komutatifitas NAND. Setelah itu, hanya beberapa terjemahan yang diperlukan untuk memberi mereka nama: a = (a Â· a) Â· (a Â· a) seperti negasi ganda, a = (a Â· a) Â· (a Â· b) seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hukum penyerapan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , (a Â· A) Â· b = (a Â· b) Â· b mirip dengan "melemah", dan sebagainya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, jika kita akan belajar beberapa "teorema kunci" dari logika NAND, seperti apa teorema ini? Mungkin ini harus menjadi "lemmas populer" dalam buktinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, teorema apa pun mungkin memiliki banyak bukti yang mungkin. Tetapi misalkan kita hanya akan menggunakan bukti yang dihasilkan FindEquationalProof. Kemudian ternyata dalam bukti dari ribuan teorema NAND pertama lemma yang paling populer adalah a Â· a = a Â· ((a Â· a) Â· a), diikuti oleh lemma dari jenis (a Â· ((a Â· a) Â· a)) Â· ( a (a ((a) a)))) = a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu lemma? Mereka berguna untuk metode yang digunakan oleh FindEquationalProof. Tetapi bagi orang-orang, mereka tampaknya tidak terlalu cocok. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan lemma yang ternyata pendek? a Â· b = b Â· a jelas bukan yang paling populer, tetapi yang terpendek. (a Â· a) Â· (a Â· a) = a lebih populer, tetapi lebih lama. Dan kemudian ada lemma seperti (a Â· a) Â· (b Â· a) = a.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seberapa berguna lemma ini? Ini salah satu cara untuk memverifikasi ini. Mari kita lihat ribuan teorema NAND pertama dan mengevaluasi bagaimana penambahan lemma mempersingkat bukti teorema ini (setidaknya yang ditemukan oleh FindEquationalProof):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/2f6/5d5/5492f65d5a0b28d9b2ad56e910d4a673.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a Â· b = b Â· a sangat sukses, dan sering kali memangkas buktinya dengan hampir 100 langkah. </font><font style="vertical-align: inherit;">(a Â· a) Â· (a Â· a) = a jauh kurang berhasil; </font><font style="vertical-align: inherit;">kadang-kadang bahkan "membingungkan" FindEquationalProof, memaksa Anda untuk mengambil lebih banyak langkah daripada yang diperlukan (nilai negatif pada grafik). </font><font style="vertical-align: inherit;">(a Â· a) Â· (b Â· a) = a berupaya dengan baik dengan kontraksi, tetapi tidak sebagus a Â· b = b Â· a. </font><font style="vertical-align: inherit;">Meskipun, jika Anda menggabungkannya dengan a Â· b = b Â· a, sebagai akibatnya, reduksi lebih sering terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis dapat dilanjutkan, misalnya, dengan memasukkan perbandingan seberapa banyak lemma tertentu mempersingkat panjang bukti sehubungan dengan panjang aslinya. </font><font style="vertical-align: inherit;">Tetapi masalahnya adalah jika Anda menambahkan beberapa â€œlemma bergunaâ€ seperti a Â· b = b Â· a dan (a Â· a) Â· (b Â· a) = a, masih ada banyak bukti panjang - yaitu, banyak dari apa yang dibutuhkan Untuk mengerti.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/410/c0e/5c5410c0e4690236d76c45f5e32e53f3.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang bisa kita pahami? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada berbagai cara untuk memodelkan berbagai hal. Selama beberapa ratus tahun, ilmu pasti didominasi oleh gagasan menemukan persamaan matematika yang dapat dipecahkan untuk menunjukkan bagaimana sistem akan berperilaku. Tetapi sejak munculnya buku saya, telah ada perubahan aktif menuju pembuatan program yang dapat Anda jalankan untuk melihat bagaimana sistem akan berperilaku. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkadang program semacam itu ditulis untuk tugas tertentu; terkadang mereka dicari untuk waktu yang lama. Dan di zaman kita, setidaknya satu kelas program semacam itu diturunkan menggunakan pembelajaran mesin, dengan metode gerakan terbalik dari contoh perilaku sistem yang diketahui.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan betapa mudahnya untuk "memahami apa yang terjadi" dengan berbagai jenis pemodelan ini? Menemukan "solusi tepat" dari persamaan matematika adalah nilai tambah yang besar - maka perilaku sistem dapat dijelaskan oleh rumus matematika yang tepat. Tetapi bahkan ketika ini tidak, sering kali mungkin untuk menuliskan beberapa pernyataan matematika yang cukup abstrak untuk dihubungkan dengan sistem dan perilaku lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang saya tulis di atas, dengan program - seperti otomat seluler - semuanya bisa berbeda. Cukup sering terjadi bahwa kita segera menghadapi irreducibilitas komputasi, yang membatasi kemampuan kita untuk mengambil jalan pendek dan "menjelaskan" apa yang terjadi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan pembelajaran mesin dan jaringan saraf? Dalam arti tertentu, pelatihan jaringan saraf seperti ringkasan singkat dari pencarian induktif yang terjadi dalam ilmu alam. Kami mencoba, mulai dengan contoh, untuk menyimpulkan model perilaku sistem. Tetapi apakah akan mungkin untuk memahami model? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan lagi, ada masalah dengan irreducibilitas komputasi. Tetapi mari kita bahas sebuah kasus di mana kita dapat membayangkan seperti apa situasi di mana kita dapat memahami apa yang sedang terjadi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daripada menggunakan jaringan saraf untuk mensimulasikan perilaku sistem, mari kita lihat membuat jaringan saraf yang mengklasifikasikan beberapa aspek dunia: misalnya, mengambil gambar dan mendistribusikannya sesuai dengan isinya ("kapal", "jerapah", dll.). Ketika kita melatih jaringan saraf, ia belajar untuk menghasilkan output yang benar. Tetapi Anda dapat membayangkan proses ini sebagai konstruksi internal dari serangkaian perbedaan (seperti permainan " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua puluh pertanyaan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "), yang pada akhirnya menentukan kesimpulan yang benar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi apa perbedaan-perbedaan ini? Terkadang kita bisa mengenalinya. Misalnya, "Apakah ada banyak warna biru di gambar?" Tetapi sebagian besar waktu ini adalah beberapa sifat dunia yang orang tidak perhatikan. Mungkin ada sejarah alternatif ilmu pengetahuan alam di mana beberapa dari mereka akan terbukti. Tetapi mereka bukan bagian dari kanon persepsi atau analisis saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami ingin menambahkannya, maka mungkin kami akan datang dengan nama untuk mereka. Tetapi situasi ini mirip dengan situasi dengan bukti logis. Sistem otomatis telah menciptakan beberapa hal yang digunakan sebagai tonggak untuk menghasilkan hasilnya. Tapi kami tidak mengenali tonggak sejarah ini, itu tidak berarti bagi kami.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali lagi, jika kami menemukan bahwa perbedaan spesifik tertentu sering ditemukan dalam jaringan saraf, kami dapat memutuskan bahwa mereka layak untuk dipelajari untuk diri kita sendiri dan menambahkannya ke kanon standar cara untuk menggambarkan dunia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah kita mengharapkan sejumlah kecil perbedaan seperti itu untuk memungkinkan kita menciptakan sesuatu yang bermakna? Ini sepertinya pertanyaannya adalah apakah sejumlah kecil teorema akan membantu kita memahami hal semacam itu sebagai bukti logis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya kira jawabannya tidak jelas. Jika Anda belajar, misalnya, satu set besar karya ilmiah dalam matematika, Anda dapat mengajukan pertanyaan tentang frekuensi penggunaan berbagai teorema. Ternyata frekuensi teorema hampir sempurna sesuai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan hukum Zipf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dan di tempat pertama akan ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teorema batas pusat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teorema </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">fungsi implisit</font></a><font style="vertical-align: inherit;"> dan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">teorema Tonelli-Fubini</font></a><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Hal yang sama mungkin terjadi dengan perbedaan yang "layak diketahui", atau dengan teorema baru yang "patut diketahui". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengetahuan tentang beberapa teorema akan memberi kita kesempatan untuk maju cukup jauh, tetapi akan selalu ada ekor eksponensial yang tak terbatas, dan kita tidak akan sampai pada akhirnya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masa depan pengetahuan </font></font></h2><br>  Mempelajari matematika, sains atau teknologi, Anda dapat melihat jalur dasar serupa dari pengembangan kualitatif, yang terdiri dari membangun serangkaian abstraksi yang terus meningkat.  Akan menyenangkan untuk mengukur proses ini.  Mungkin dimungkinkan untuk menghitung bagaimana istilah atau deskripsi tertentu yang sering ditemukan pada saat yang sama dimasukkan dalam tingkat abstraksi yang lebih tinggi, di mana istilah atau deskripsi baru pada gilirannya muncul sehubungan dengan mereka. <br><br>  Dimungkinkan untuk membuat model ideal dari proses ini menggunakan model perhitungan formal seperti mesin Turing.  Bayangkan pada level terendah ada mesin Turing dasar tanpa abstraksi.  Sekarang bayangkan kita memilih program untuk mesin Turing ini menurut beberapa proses acak tertentu.  Kemudian kami menjalankan program-program ini dan menganalisisnya untuk melihat model komputasi "lebih tinggi" mana yang berhasil mereproduksi perilaku bersama dari program-program ini tanpa harus melakukan setiap langkah di masing-masingnya. <br><br>  Dapat diputuskan bahwa irreducibilitas komputasi akan mengarah pada fakta bahwa pembuatan model komputasi tingkat tinggi ini pasti akan lebih rumit.  Tetapi intinya adalah bahwa kita hanya mencoba mereproduksi perilaku bersama dari program, dan bukan perilaku yang terpisah. <br><br>  Tetapi apa yang terjadi jika proses ini berulang berulang, mereproduksi sejarah intelektual manusia yang ideal dan menciptakan menara abstraksi yang semakin tinggi? <br><br>  Agaknya, di sini kita dapat menggambar analogi dengan fenomena kritis dalam fisika dan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelompok renormalisasi</a> .  Jika demikian, kita dapat membayangkan bahwa kita dapat menentukan lintasan di ruang platform untuk mewakili konsep.  Apa yang akan dilakukan lintasan ini? <br><br>  Mungkin itu akan memiliki nilai tetap ketika setiap saat dalam sejarah ada sekitar jumlah yang sama dari studi konsep - konsep baru terbuka perlahan, dan yang lama diserap. <br><br>  Apa artinya ini bagi matematika?  Sebagai contoh, bahwa â€œfakta matematika acakâ€ apa pun yang ditemukan secara empiris pada akhirnya akan dipertimbangkan setelah mencapai tingkat abstraksi tertentu.  Tidak ada pemahaman yang jelas tentang bagaimana proses ini akan bekerja.  Memang, pada tingkat abstraksi apa pun, selalu ada fakta empiris baru yang harus "dilompati".  Mungkin juga terjadi bahwa "meningkatkan level abstraksi" akan bergerak lebih lambat dari yang diperlukan untuk "lompatan" ini. <br><br><h2>  Masa depan pemahaman </h2><br>  Apa arti semua ini bagi pemahaman di masa depan? <br><br>  Di masa lalu, ketika orang mempelajari alam, mereka memiliki sejumlah kecil alasan untuk memahaminya.  Kadang-kadang mereka mempersonifikasikan aspek-aspek tertentu dalam bentuk roh atau dewa.  Tetapi mereka menerimanya apa adanya, tidak memikirkan kemungkinan untuk memahami semua perincian dari penyebab proses tersebut. <br><br>  Dengan munculnya sains modern - dan terutama ketika semakin banyak kehidupan kita dihabiskan di lingkungan buatan yang didominasi oleh teknologi yang dikembangkan oleh kita - harapan ini telah berubah.  Dan ketika kita mempelajari perhitungan yang dilakukan oleh AI, kita tidak suka bahwa kita mungkin tidak memahaminya. <br><br>  Namun, akan selalu ada persaingan antara apa yang dilakukan sistem dunia kita dan apa yang otak kita dapat hitung dari perilaku mereka.  Jika kita memutuskan untuk berinteraksi hanya dengan sistem yang jauh lebih sederhana daripada otak dalam kekuatan komputasi, maka kita dapat berharap bahwa kita dapat secara sistematis memahami apa yang mereka lakukan. <br><br>  Tetapi jika kita ingin menggunakan semua kemampuan komputasi yang tersedia di alam semesta, maka mau tidak mau sistem yang kita berinteraksi akan mencapai kekuatan pemrosesan otak kita.  Dan ini berarti bahwa, sesuai dengan prinsip irreducibilitas komputasi, kita tidak pernah dapat secara sistematis "menyalip" atau "memahami" pengoperasian sistem ini. <br><br>  Tetapi bagaimana kita dapat menggunakannya?  Yah, sama seperti manusia selalu menggunakan sistem alam.  Tentu saja, kita tidak tahu semua detail pekerjaan atau kemampuan mereka.  Tetapi pada tingkat abstraksi tertentu, kita cukup tahu untuk memahami bagaimana mencapai tujuan kita dengan bantuan mereka. <br><br>  Bagaimana dengan bidang-bidang seperti matematika?  Dalam matematika, kita terbiasa membangun set pengetahuan kita sehingga kita bisa memahami setiap langkah.  Tetapi matematika eksperimental - serta fitur-fitur seperti pembuktian teorema otomatis - memperjelas keberadaan area di mana metode semacam itu tidak akan tersedia bagi kita. <br><br>  Akankah kita menyebut mereka "matematika"?  Saya pikir mereka harus melakukannya.  Tetapi tradisi ini berbeda dari yang biasa kita gunakan di milenium terakhir.  Kami masih dapat membuat abstraksi di sana, dan membangun tingkat pemahaman baru. <br><br>  Tetapi di suatu tempat dalam basisnya akan ada segala macam versi yang berbeda dari irreducabilitas komputasi, yang kita tidak pernah bisa transfer ke bidang pemahaman manusia.  Ini kira-kira yang terjadi dalam pembuktian aksioma logika kecil saya.  Ini adalah contoh awal dari apa yang saya pikir akan menjadi salah satu aspek utama matematika - dan banyak lagi - di masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431956/">https://habr.com/ru/post/id431956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431944/index.html">Yealink Meeting Server 2.0 - Fitur Konferensi Video Baru</a></li>
<li><a href="../id431946/index.html">Pekan Keamanan 49: meretas Dell dan Marriott</a></li>
<li><a href="../id431948/index.html">Deep Mind mengajarkan AI-nya untuk memprediksi struktur protein</a></li>
<li><a href="../id431950/index.html">Cara memperkirakan permintaan dan mengotomatiskan pembelian menggunakan pembelajaran mesin: Kasing Ozon</a></li>
<li><a href="../id431954/index.html">Mantan wakil presiden Sun dan DEC menjadi presiden MIPS / Wave, berbicara tentang Rusia dan RISC / V</a></li>
<li><a href="../id431958/index.html">Stasiun Daya Baterai Virtual Tesla Diperluas ke 1.000 Rumah di Australia</a></li>
<li><a href="../id431960/index.html">Nvidia menjadi gila dan membuka PhysX di bawah BSD-3</a></li>
<li><a href="../id431964/index.html">Gabungkan Urusan</a></li>
<li><a href="../id431968/index.html">FAQ yang bagus tentang kereta jarak jauh dan aturan yang tidak jelas</a></li>
<li><a href="../id431970/index.html">Departemen Dukungan: Ekspektasi vs Realitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>