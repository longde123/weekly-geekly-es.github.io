<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèø ü§¶üèª üìÇ Unidade: uma cidade sem fim gerada proceduralmente, obtida usando o algoritmo WFC (colapso da fun√ß√£o de onda) üë®üèª‚Äçüç≥ üëãüèø ü§õüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Como legisladores da Unity no mercado russo, oferecemos a voc√™ um estudo interessante sobre o uso pr√°tico do algoritmo WFC (Wave Function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unidade: uma cidade sem fim gerada proceduralmente, obtida usando o algoritmo WFC (colapso da fun√ß√£o de onda)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/455004/">  Ol√° Habr! <br><br>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">legisladores</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Unity</a> no mercado russo, oferecemos a voc√™ um estudo interessante sobre o uso pr√°tico do algoritmo WFC (Wave Function Collapse), constru√≠do √† imagem e semelhan√ßa do conhecido princ√≠pio da mec√¢nica qu√¢ntica e muito conveniente para a gera√ß√£o processual de n√≠veis nos jogos.  Anteriormente, em Habr√©, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hist√≥ria detalhada</a> sobre esse algoritmo j√° havia sido publicada.  A autora do artigo de hoje, Marian Kleineberg, considera o algoritmo no contexto de gr√°ficos tridimensionais e a gera√ß√£o de uma cidade sem fim.  Boa leitura! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/e7/af/4be7afzttmmd9g8y2snj_pnxpns.jpeg"></div><a name="habracut"></a><br>  Falaremos sobre um jogo em que voc√™ percorre uma cidade sem fim gerada processualmente √† medida que se move.  Uma cidade √© constru√≠da a partir de um conjunto de blocos usando o algoritmo WFC (colapso da fun√ß√£o de onda). <br><br>  A montagem reproduz√≠vel est√° dispon√≠vel para download no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">itch.io.</a>  Voc√™ tamb√©m pode pegar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo fonte no github</a> .  Por fim, proponho um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> no qual ando pela cidade assim gerada. <br><br><h3>  Algoritmo </h3><br>  Chamarei a palavra "c√©lula" de um elemento de malha de voxel 3D que pode conter um bloco ou estar vazio.  A palavra "m√≥dulo" chamarei um bloco que pode ocupar essa c√©lula. <br><br>  O algoritmo decide quais m√≥dulos selecionar em cada c√©lula do mundo do jogo.  Uma matriz de c√©lulas √© considerada uma fun√ß√£o de onda em uma forma n√£o observ√°vel.  Assim, cada c√©lula corresponde a muitos m√≥dulos que podem aparecer nela.  Em termos de mec√¢nica qu√¢ntica, pode-se dizer: "a c√©lula est√° em uma superposi√ß√£o de todos os m√≥dulos".  A exist√™ncia do mundo come√ßa de uma forma completamente inobserv√°vel, onde qualquer m√≥dulo pode estar em cada c√©lula.  Al√©m disso, todas as c√©lulas entram em colapso, uma ap√≥s a outra.  Isso significa que, para cada c√©lula, um m√≥dulo √© selecionado aleatoriamente entre todos os poss√≠veis. <br><br>  O pr√≥ximo passo √© a propaga√ß√£o de restri√ß√µes.  Para cada m√≥dulo, √© selecionado um subconjunto de m√≥dulos que podem ser adjacentes a ele.  Cada vez que um m√≥dulo entra em colapso, subconjuntos de outros m√≥dulos s√£o atualizados, que ainda s√£o permitidos como adjacentes a ele.  O est√°gio de propaga√ß√£o de restri√ß√µes √© a parte do algoritmo que consome mais recursos em termos de poder de computa√ß√£o. <br><br>  Um aspecto importante do algoritmo √© determinar qual c√©lula recolher.  O algoritmo sempre recolhe a c√©lula com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">menor entropia</a> .  Essa √© uma c√©lula que permite um n√∫mero m√≠nimo de op√ß√µes (ou seja, uma c√©lula com o m√≠nimo de aleatoriedade).  Se a probabilidade de colapso for a mesma para todos os m√≥dulos, a c√©lula com o n√∫mero m√≠nimo de m√≥dulos poss√≠veis ter√° a menor entropia.  Como regra, as probabilidades de serem selecionadas s√£o diferentes para os v√°rios m√≥dulos dispon√≠veis.  Uma c√©lula com dois m√≥dulos poss√≠veis com a mesma probabilidade fornece uma escolha mais ampla (maior entropia) do que aquela em que existem dois m√≥dulos, e para um deles a probabilidade de cair sob a escolha √© muito alta e, para o outro, √© muito pequena. <br><br><img src="https://habrastorage.org/webt/dp/kw/z-/dpkwz-w1fr5-xxrw_flqyt_mtou.gif"><br><br>  (Gif postado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ExUtumno</a> no Github) <br><br>  Informa√ß√µes mais detalhadas sobre o algoritmo de colapso da fun√ß√£o de onda, bem como v√°rios exemplos bonitos, podem ser encontradas aqui.  Inicialmente, este algoritmo foi proposto para gerar texturas 2D com base em uma √∫nica amostra.  Nesse caso, os indicadores probabil√≠sticos dos m√≥dulos e regras de adjac√™ncia s√£o determinados dependendo da ocorr√™ncia no exemplo.  Este artigo fornece essas informa√ß√µes manualmente. <br><br>  Aqui est√° um <a href="">v√≠deo</a> demonstrando esse algoritmo em a√ß√£o. <br><br><h3>  Sobre blocos, prot√≥tipos e m√≥dulos </h3><br>  O mundo √© gerado a partir de um conjunto em que cerca de 100 blocos.  Eu os criei usando o Blender.  No come√ßo, eu tinha muito poucos blocos e os adicionei pouco a pouco quando considerou necess√°rio. <br><br><img src="https://habrastorage.org/webt/yj/26/sn/yj26snwykmonhpvoy9mvv_bnsq8.png"><br><br>  O algoritmo precisa saber quais m√≥dulos podem ser localizados pr√≥ximos um do outro.  Para cada m√≥dulo, existem 6 listas de poss√≠veis vizinhos, um em cada uma das dire√ß√µes.  No entanto, eu queria evitar ter que criar essa lista manualmente.  Al√©m disso, eu queria gerar automaticamente op√ß√µes giradas para cada um dos meus blocos. <br><br>  Ambas as tarefas s√£o resolvidas usando os chamados m√≥dulos de prot√≥tipo.  Em ess√™ncia, esse √© o <code>MonoBehaviour</code> , que √© conveniente trabalhar no editor do Unity.  M√≥dulos, juntamente com listas de elementos vizinhos v√°lidos e op√ß√µes rotadas, s√£o criados automaticamente com base nesses prot√≥tipos. <br><br>  Um problema complexo surgiu com a modelagem de informa√ß√µes de adjac√™ncia, para que esse processo autom√°tico funcionasse.  Aqui est√° o que eu tenho: <br><br><img src="https://habrastorage.org/webt/ym/cj/ke/ymcjkeehpahvovwxbpl7kma28bs.png"><br><br>  Cada bloco possui 6 contatos, um para cada face.  O contato tem um n√∫mero.  Al√©m disso, os contatos horizontais podem ser invertidos, n√£o invertidos ou sim√©tricos.  Os contatos verticais t√™m um √≠ndice de rota√ß√£o no intervalo de 0 a 3 ou s√£o marcados como <i>invari√°veis ‚Äã‚Äãrotativamente</i> . <br><br>  Com base nisso, posso verificar automaticamente quais m√≥dulos podem se encaixar.  Os m√≥dulos adjacentes devem ter os mesmos n√∫meros de pinos.  Sua simetria tamb√©m deve coincidir (o mesmo √≠ndice de rota√ß√£o vertical, um par de contatos horizontais invertidos e n√£o invertidos) ou os m√≥dulos devem ser sim√©tricos / invariantes. <br><br><img src="https://habrastorage.org/webt/zk/-3/lo/zk-3looqprzz5upxpuavvmkccbu.png"><br><br>  Existem regras de exclus√£o pelas quais posso proibir op√ß√µes de bairro que seriam permitidas por padr√£o.  Alguns blocos com contatos correspondentes simplesmente parecem feios nas proximidades.  Aqui est√° um exemplo de um mapa gerado sem aplicar regras de exce√ß√£o: <br><br><img src="https://habrastorage.org/webt/md/od/0f/mdod0f_xkotiz9sc7tigjres6ia.jpeg"><br><br><h3>  Caminho para o infinito </h3><br>  O algoritmo original de colapso da fun√ß√£o de onda gera mapas de tamanho finito.  Eu queria construir um mundo que se expandisse e se expandisse √† medida que voc√™ se movesse. <br><br>  No come√ßo, tentei gerar fragmentos de tamanho finito e usar os contatos de fragmentos adjacentes como restri√ß√µes.  Se um fragmento √© gerado, e um fragmento adjacente a ele tamb√©m √© gerado, somente esses m√≥dulos s√£o permitidos que se ajustem ao lado dos m√≥dulos existentes.  Com essa abordagem, surge o seguinte problema: sempre que uma c√©lula entra em colapso, a propaga√ß√£o de restri√ß√µes reduz as oportunidades, mesmo √† dist√¢ncia de v√°rias c√©lulas.  A imagem a seguir mostra os efeitos do recolhimento de uma √∫nica c√©lula: <br><br><img src="https://habrastorage.org/webt/ex/yj/rv/exyjrvgb7tciaf1skkzgndnvpd0.png"><br><br>  Se em cada etapa do algoritmo apenas um fragmento for gerado, as restri√ß√µes n√£o se aplicar√£o aos fragmentos adjacentes.  Nesse caso, esses m√≥dulos foram selecionados dentro do fragmento que seriam inaceit√°veis ‚Äã‚Äãse outros fragmentos fossem levados em considera√ß√£o.  Como resultado, quando o algoritmo tentou gerar o pr√≥ximo fragmento, n√£o conseguiu encontrar uma √∫nica solu√ß√£o. <br><br>  Agora n√£o uso mais fragmentos, mas armazeno o mapa em um dicion√°rio que exibe a posi√ß√£o de uma c√©lula em uma c√©lula.  A c√©lula √© preenchida apenas se necess√°rio.  Alguns elementos do algoritmo devem ser ajustados com isso em mente.  Ao escolher uma c√©lula que deve entrar em colapso, √© imposs√≠vel levar em considera√ß√£o todas as c√©lulas se o n√∫mero delas for infinito.  Em vez disso, geramos apenas uma pequena parte do mapa de cada vez, quando o jogador o alcan√ßa.  Fora desta √°rea, as restri√ß√µes continuam a se espalhar. <br><br>  Em alguns casos, essa abordagem n√£o funciona.  Considere um conjunto de m√≥dulos para uma se√ß√£o reta de um t√∫nel da figura acima - n√£o h√° entrada para o t√∫nel.  Se o algoritmo escolher um m√≥dulo de t√∫nel, o t√∫nel ser√° infinito por defini√ß√£o.  No est√°gio de distribui√ß√£o de restri√ß√µes, o programa tentar√° alocar um n√∫mero infinito de c√©lulas.  Eu desenvolvi um conjunto especial de m√≥dulos para contornar esse problema. <br><br><h3>  Condi√ß√µes de contorno </h3><br>  Existem duas condi√ß√µes importantes de contorno.  Todas as faces no n√≠vel superior do mapa devem ter contatos "a√©reos".  Todas as faces na base do mapa devem ter contatos "s√≥lidos".  Se essas condi√ß√µes n√£o forem atendidas, no mapa haver√° buracos no solo e alguns edif√≠cios ficar√£o sem teto. <br><br>  Em um mapa de tamanho finito, esse problema seria facilmente resolvido.  Para todas as c√©lulas nos n√≠veis mais alto e mais baixo, seria necess√°rio remover todos os m√≥dulos com contatos inadequados.  Em seguida, inicie a distribui√ß√£o de restri√ß√µes e remova os m√≥dulos restantes que n√£o s√£o mais adequados para n√≥s. <br><br>  Em um mapa de tamanho infinito, isso n√£o funcionar√°, porque, tanto no n√≠vel mais alto quanto no mais baixo, temos um n√∫mero infinito de c√©lulas.  A solu√ß√£o mais ing√™nua √© excluir todas as c√©lulas inadequadas imediatamente √† medida que elas surgirem.  No entanto, quando um m√≥dulo √© removido no n√≠vel superior, as restri√ß√µes se aplicam √†s c√©lulas adjacentes a ele.  H√° um efeito de avalanche, novamente levando a uma sele√ß√£o infinita de c√©lulas. <br><br>  Resolvi esse problema criando um mapa 1 √ó n √ó 1, onde n √© a altura.  Este mapa usa quebra-cabe√ßas para espalhar restri√ß√µes.  O mecanismo funciona como no jogo Pacman: indo al√©m da borda direita do mapa, o personagem volta a ele por causa da borda esquerda.  Agora posso aplicar quaisquer restri√ß√µes ao meu mapa.  Cada vez que voc√™ cria uma nova c√©lula em um mapa infinito, essa c√©lula √© inicializada com um conjunto de m√≥dulos correspondentes a uma posi√ß√£o espec√≠fica no mapa. <br><br><h3>  Condi√ß√µes de erro e pesquisa de retorno </h3><br>  √Äs vezes, o algoritmo WFC atinge um estado em que a c√©lula n√£o corresponde a nenhum m√≥dulo poss√≠vel.  Nas aplica√ß√µes em que lidamos com um mundo de tamanho finito, voc√™ pode simplesmente redefinir o resultado e come√ßar tudo de novo.  Em um mundo infinito, isso n√£o funcionar√°, pois parte do mundo j√° √© mostrada ao jogador.  Primeiro, decidi por uma solu√ß√£o em que os locais onde os erros ocorriam eram preenchidos com blocos brancos. <br><br>  Atualmente, estou usando a pesquisa de retorno.  A ordem do colapso das c√©lulas e algumas informa√ß√µes sobre a distribui√ß√£o de restri√ß√µes s√£o armazenadas na forma de hist√≥rico.  Se o algoritmo WFC falhar, parte do hist√≥rico ser√° cancelada.  Como regra, isso funciona, mas √†s vezes os erros podem ser reconhecidos tarde demais, e uma pesquisa de retorno abrange muitas etapas.  Em casos raros, a c√©lula em que o jogador est√° localizado √© regenerada. <br><br>  Na minha opini√£o, devido a essa limita√ß√£o, a aplica√ß√£o do algoritmo WFC com mundos infinitos n√£o √© adequada para jogos comerciais. <br><br><h3>  Antecedentes </h3><br>  Comecei a trabalhar nessa tarefa depois de assistir a uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palestra de Oscar Stelberg</a> dizendo como ele usa o algoritmo para gerar n√≠veis no jogo Bad North.  Em geral, meu algoritmo foi implementado durante a semana do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">procjam</a> . <br><br>  Tenho algumas id√©ias para aperfei√ßoar ainda mais esse algoritmo, mas n√£o tenho certeza de que algum dia adicionarei jogabilidade a ele.  E se eu me reunir - com certeza n√£o ser√° uma estrat√©gia t√£o √©pica que voc√™ j√° imaginou.  No entanto, se voc√™ quiser verificar como sua mec√¢nica de jogo favorita funciona com esse algoritmo - tente voc√™ mesmo!  No final, o c√≥digo fonte est√° dispon√≠vel ao p√∫blico e licenciado pelo MIT. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455004/">https://habr.com/ru/post/pt455004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454990/index.html">‚Äú√â aconselh√°vel que voc√™ tenha um gato‚Äù - como uma startup pode atirar no Product Hunt</a></li>
<li><a href="../pt454994/index.html">Quais s√£o as vantagens do carregamento sem fio e por que o futuro est√° por tr√°s disso? Experi√™ncia pessoal para 2019</a></li>
<li><a href="../pt454996/index.html">Cosmonaut Training Center com o nome de Yu.A. Gagarin e Roscosmos come√ßaram o recrutamento aberto para a equipe de cosmonautas</a></li>
<li><a href="../pt454998/index.html">Julia e computa√ß√£o paralela</a></li>
<li><a href="../pt455000/index.html">Mudan√ßa cuidadosa para a Holanda com sua esposa. Parte 3: trabalho, colegas e outras formas de vida</a></li>
<li><a href="../pt455006/index.html">Controle remoto de tr√™s comandos com um programa de 290 palavras de 16 bits</a></li>
<li><a href="../pt455008/index.html">Web sem√¢ntica e dados vinculados. Corre√ß√µes e adi√ß√µes</a></li>
<li><a href="../pt455010/index.html">Scripts de usu√°rio ass√≠ncronos em Rust puro, sem estruturas e SMS</a></li>
<li><a href="../pt455012/index.html">Perguntas frequentes sobre intercepta√ß√£o celular: O que s√£o interceptores IMSI / SCATs e posso proteg√™-los?</a></li>
<li><a href="../pt455016/index.html">Criamos o site mais inacess√≠vel com uma classifica√ß√£o ideal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>