<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 🤴🏿 🚶🏻 Erste Bekanntschaft mit Home Assistant 🔺 👨🏻‍✈️ 👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Home Assistant ist eine beliebte Open Source-Anwendung zum Organisieren eines Smart Homes. Die ersten Erfahrungen des Autors mit dem Home Assistant ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erste Bekanntschaft mit Home Assistant</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471822/"><img width="25%" align="right" src="https://habrastorage.org/webt/sj/wt/mu/sjwtmujve5xdbroiyxjiebxbc5o.png"><br>  Home Assistant ist eine beliebte Open Source-Anwendung zum Organisieren eines Smart Homes.  Die ersten Erfahrungen des Autors mit dem Home Assistant basieren auf dem Versuch, einen intelligenten Reiskocher in ihn zu integrieren.  Der Autor wird versuchen, die Hauptkomponenten und Merkmale dieser Anwendung zu beschreiben, die er Schritt für Schritt kennenlernen durfte.  Der Artikel ist in gewisser Weise eine Rezension, in gewisser Weise ein Leitfaden für diejenigen, die ihre Bekanntschaft mit Home Assistant beginnen möchten. <br><a name="habracut"></a><br>  Für diejenigen, die wenig Freizeit haben, empfehle ich Ihnen, das Sprichwort - das erste Kapitel - zu überspringen und direkt zum zweiten zu gehen.  Sie müssen nur wissen, dass wir mit einem intelligenten chinesischen Reiskocher von Xiaomi zusammenarbeiten werden. <br><br><h3>  Intelligenter Reiskocher </h3> Ein Reiskocher ist offensichtlich ein Reiskocher.  Das Wiki zeigt uns Reisdampfer aus Keramik aus dem British Museum aus dem Jahr 1250 v  1945 wurde Mitsubishi Japans erste hausgemachte Firma für elektrischen Reiskocher.  Unser Modell - Rice Cooker von Xiaomi - kann nicht nur Reis kochen.  „Dies ist ein großartiges Gerät, um nicht nur Reis, sondern auch andere Arten von Gerichten zuzubereiten.  Es kann Suppen, Gebäck und vieles mehr kochen “, heißt es in der Werbung.  Das Wichtigste ist jedoch das Vorhandensein eines Wi-Fi-Moduls, einer Software mit Automatisierungsfunktionen und mehr als 200 von der Software installierten Rezepten.  "Der Weg zu einem Smart Home durch den Magen ist richtig", dachte der Autor und entschied. <br><br>  Xiaomi Rice Cooker ist, wie es sich für ein digitales Gerät gehört, äußerlich sehr attraktiv und erfreut sich durch seine runde Form und den allgemeinen Minimalismus.  Zur Konfiguration und Verwendung bietet der Hersteller die Mi Home-Anwendung an.  Nach der Registrierung des Mi-Kontos findet das Programm leicht ein neues Gerät und Sie registrieren es in Ihrem lokalen Netzwerk.  Die Anwendungsschnittstelle ist nicht die schlechteste, bietet grundlegende Automatisierungstools und kann Benachrichtigungen von Geräten empfangen.  Es gibt jedoch erhebliche Nachteile.  Nicht jeder kann glücklich sein, dem Entwickler Informationen über jeden Benutzerklick zu senden.  Und ein unangenehmer Ausdruck findet sich heute oft in der Nationalfarbe.  Anstelle von mehr als 200 Rezepten werden nur vier übersetzt und sind in Fremdsprachen verfügbar.  Der Rest ist ausschließlich für das chinesische Volk.  Wenn Ihr „intelligenter“ Reiskocher nicht in der Lage ist, alle versprochenen kulinarischen Pflichten zu erfüllen, wird es traurig.  Nachdem er einige Zeit im Internet gewandert war, stieß ein trauriger Autor auf das nächste interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> (ewige Vorteile für den Autor).  Es stellte sich heraus, dass dies der Entwicklung eines Moduls für einen bestimmten Heimassistenten gewidmet war. <br><br><h3>  Heimassistent </h3>  Zunächst einige allgemeine Informationen.  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der HA-Homepage</a> heißt es: „Dies ist eine Open-Source-Software für die Smart-Home-Automatisierung, die sich auf lokales Management und Datenschutz konzentriert.  Es wurde von einer offenen Community von Enthusiasten entwickelt und eignet sich hervorragend für die Arbeit an einem Raspberry Pi oder einem lokalen Server. “  Das Projekt ist mehr als fünf Jahre alt und verwendet Python und eine Apache 2.0-Lizenz.  Die Release-Version zum Zeitpunkt des Schreibens dieser Zeilen ist 0.99.3. <br><br>  HA verwendet separate Module (Integrationen oder Komponenten), um Geräte zu verwalten.  Eine zu erstellen ist ziemlich einfach.  Auf der Website finden Sie einen Katalog der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wichtigsten</a> (von der Community genehmigten und unterstützten) Module.  Unter ihrer Gesamtzahl (1485 Stück) gibt es völlig unterschiedliche, die Namen amazon, google, xiaomi und sogar einmal yandex sind im Katalog aufgeführt. <br>  Versuchen wir, HA in einer virtuellen Umgebung auf dem Linux-Desktop zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  Wir benötigen Python3 und Pip Package Manager. <br><pre><code class="bash hljs">python3 -m venv homeassistant <span class="hljs-comment"><span class="hljs-comment">#    cd homeassistant source bin/activate #    python3 -m pip install homeassistant #  Home Assistant hass --open-ui #  Home Assistant</span></span></code> </pre> <br>  Danach wird die HA- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GUI</a> unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 8123 verfügbar</a> .  Wenn Sie sich zum ersten Mal anmelden, müssen Sie ein Benutzerkonto erstellen.  Das HA-Webinterface ist ziemlich umfangreich.  Einige wichtige Elemente, die am Anfang erwähnenswert sind, sind die Registerkarte Konfiguration → Allgemein, auf der Sie die Konfigurationsdateien oder den Server selbst problemlos neu laden können.  Sowie die Info-Seite in der Liste der Entwicklertools, auf der Sie die Fehlerprotokolle sehen können. <br><br>  HA speichert bei Linux alle erforderlichen Benutzerdaten im Einstellungsordner „~ / .homeassistant“.  Die Konfigurationsdateien sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YAML-</a> Format geschrieben, und die Hauptdatei ist "configuration.yaml".  Es kombiniert die Daten von Modulen, Automatisierung usw.  Mit der Importfunktion können Sie die Einstellungen in separate logisch organisierte Dateien aufteilen.  Module werden in den Unterordnern "Komponenten" (integriert) und "Benutzerdefinierte_Komponenten" gespeichert. <br><br>  Dieses Wissen sollte ausreichen, um ein neues Modul zu installieren.  Kopieren Sie den Ordner "xiaomi_cooker" aus unserem Repository in unsere "~ / .homeassistant / custom_components".  Fügen Sie gemäß der Beschreibung die Moduleinstellungen zur Datei "configuration.yaml" hinzu: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">xiaomi_cooker: <span class="hljs-comment"><span class="hljs-comment">#   name: 'Akari' #   host: 192.168.1.10 # IP   token: '4921def609273302248d040a24243a25' #   Xiaomi model: chunmi.cooker.normal2 #  </span></span></code> </pre> <br></div></div><br>  Fertig.  Nach dem HA-Neustart wird im Abschnitt Allgemein → Integrationen der Weboberfläche ein neuer Moduleintrag angezeigt. <br><br>  Jedes Modul ist eine bestimmte Menge von Objekten (Entitäten) und Diensten (Dienste im Wesentlichen - Funktionen).  Objekte speichern verschiedene von Geräten empfangene Daten.  Zum Beispiel ist sensor.xiaomi_cooker_temperature die Temperatur des Reiskochers, sun.sun ist der Sonnenstand.  Die Daten eines Objekts werden durch einen Grundwert ausgedrückt - Status (Status) und einen beliebigen Satz zusätzlicher Attribute (Attribute).  Dienste werden verwendet, um Befehle und Werte auf Geräte zu übertragen.  Beispiel: xiaomi_cooker.start - der Befehl zum Starten des Reiskochers oder homeassistant.check_config - die Initialisierung der Suche nach Fehlern in den HA-Einstellungsdateien.  Die Liste der Entwicklertools der Weboberfläche enthält den Abschnitt Dienste, in dem Sie die Liste der verfügbaren Dienste anzeigen und mit ihren Anrufen spielen können.  In der Nähe befindet sich der Abschnitt Status, in dem Sie die Werte von Objekten anzeigen und ändern können.  Es ist zu beachten, dass Änderungen der Werte von Objekten im Abschnitt "Zustände" einseitig sind.  Das heißt,  Wenn Sie beispielsweise den Status des Lights.state-Objekts hier von Aus auf Ein ändern, hat dies keine Auswirkungen auf den tatsächlichen Status des Geräts. Wenn die Daten vom Gerät das nächste Mal aktualisiert werden, wird der Wert des Objekts in Real überschrieben. <br><br><h3>  Automatisierung </h3>  Das Hauptverwaltungstool für ein Smart Home ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatisierung</a> .  Sie können sie über die grafische Oberfläche im Abschnitt Allgemein → Automatisierung oder direkt in der Datei „automations.yaml“ hinzufügen und bearbeiten.  Die Hauptfunktion der Automatisierung besteht darin, Dienste aufzurufen, wenn bestimmte Bedingungen erfüllt sind.  Grundlegende Werkzeuge zum Festlegen der Bedingungen für das Aufrufen des Werts von Objekten, inkl.  Zeitdaten.  Es gibt etwas spezifischere Lösungen, wie z. B. Ereignisse.  Als einfaches Automatisierungsbeispiel geben wir einen Code an, der die Plus-Daten des Autors innerhalb von 15 Minuten aktualisiert: <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1565889970818'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: Umpiro decharging #  trigger: #   - platform: time_pattern #   -  minutes: /15 #   (   –    15 ) condition: [] #    action: #    - data: # ,     entity_id: sensor.umpiro_charge #  (: ) service: homeassistant.update_entity #   </span></span></code> </pre> <br></div></div><br>  Es sollte beachtet werden, dass bisher nicht alle verfügbaren Automatisierungsfunktionen (z. B. die oben genannten) konfiguriert werden können, ohne den Yaml-Code über die grafische Oberfläche zu bearbeiten. Die Entwickler geben jedoch an, dass sie aktiv daran arbeiten, diesen Nachteil zu beseitigen. <br><br><h3>  Vorlagen </h3>  Nach der Automatisierung ist es Zeit, über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagen</a> (Template) zu sprechen.  Verschiedene Einstellungselemente in yaml-Dateien ermöglichen die Verwendung von Einfügungen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Skriptsprache jinja2</a> .  Viele dieser Elemente werden durch den allgemeinen Namen 'Templates' vereint, z. B. service_template oder trigger_template.  Mithilfe von Vorlagen erhalten wir Zugriff auf die Werte von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekten in HA</a> und die Möglichkeit, diese Daten in komplexen mathematischen und logischen Ausdrücken zu verwenden, was unser Potenzial erheblich erweitert.  Nehmen wir als Beispiel einen etwas komplizierteren Code von sensor.umpiro_charge, der in "configuration.yaml" geschrieben ist.  Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">template_sensor</a> , dh "ein Sensor, der Daten basierend auf den Werten anderer Objekte bildet".  Unser Sensor wird ein Analogon einer allmählich entladenen Batterie sein: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">sensor: <span class="hljs-comment"><span class="hljs-comment">#   platform: template #   -  sensors: #   #   – sensor.umpiro_charge umpiro_charge: #      UI () unit_of_measurement: '%' # ,    value_template: &gt;- #    –   'int' # +     {% if states('sensor.umpiro_charge')|int('unknown') is number %} #       #         {% set value = (states('sensor.umpiro_charge')|int - (as_timestamp(now()) - as_timestamp(states.sensor.umpiro_charge.last_updated))/60/15)|round %} #       {{ [[0, value]|max, 100]|min }} {% else %} # ,  HA   #      {{ 'unknown' }} {% endif %} # ID  ,     #      entity_id: [] friendly_name: 'Charge' #   #      UI () device_class: battery</span></span></code> </pre><br></div></div><br>  Wir haben entity_id leer gelassen, da wir bereits eine Automatisierung hinzugefügt haben, die unabhängig die Aktualisierung der Objektdaten bewirkt. <br><br><h3>  Python-Skripte </h3>  Python-Skripte sind wiederum ein einfaches Werkzeug zum Erstellen neuer Dienste.  Nach dem Hinzufügen der Zeile "python script:" zu "configuration.yaml" werden alle Dateien mit der Erweiterung ".py", die wir in den Ordner "~ / .homeassistant / python_scripts" gestellt haben, als Dienste mit den Namen "python_scripts" verfügbar Dateiname&gt; ”.  Ihr Code wird in einer vordefinierten Umgebung ausgeführt, in der die Daten- und Hassvariablen uns Zugriff auf die Argumente für den Serviceaufruf sowie auf HA-Objekte und -Dienste geben.  Als Beispiel geben wir den Code der Datei "charge_set.py "für den Dienst" python_scripts.charge_set "an.  Seine Funktion wird darin bestehen, die Ladung unserer Batterie einzustellen: <br><div class="spoiler">  <b class="spoiler_title">python_scripts / fee_set.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     name = data.get('name', 'sensor.umpiro_charge') #     new_state = data.get('charge', '100') #    attributes = hass.states.get(name).attributes #    hass.states.set(name, new_state, attributes)</span></span></code> </pre> <br></div></div><br><br><h3>  Integration schaffen </h3>  Alles, was wir mit Hilfe von Vorlagen und Python-Skripten gemacht haben, wäre vielleicht einfacher, dies zu tun, indem wir ein separates Modul schreiben.  Wie bereits erwähnt, werden inoffizielle Module im Ordner "custom_components" gespeichert.  In Zukunft benötigen wir ein Objekt, in dem Informationen zum aktuellen Rezept für unseren Reiskocher gespeichert sind, und einen Dienst, mit dem Sie diese Daten ändern können.  Anhand eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiels aus der Dokumentation</a> erstellen wir hierfür ein neues Modul, "overmind".  Der erste Schritt ist die Datei custom_components / overmind / __ init__.py: <br><div class="spoiler">  <b class="spoiler_title">custom_components / overmind / __ init__.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     DOMAIN = 'overmind' #       () DEFAULT_RECIPE = { "title": "Habr post", "description": "Post an article on habr.com", "profile": "471822" } #    def setup(hass, config): #    hass.states.set('overmind.current_recipe', 'on', DEFAULT_RECIPE) #       def handle_set(call): #    recipe = call.data.get('recipe', DEFAULT_RECIPE) #   -    hass.states.set('overmind.current_recipe', 'set', recipe) #   hass.services.register(DOMAIN, 'recipe_set', handle_set) return True</span></span></code> </pre> <br></div></div><br>  Danach melden wir das neue Modul in der Konfigurationsdatei "configuration.yaml" und fügen eine Zeile mit dem Modulnamen "overmind:" hinzu.  Das Problem ist gelöst. <br><br><h3>  Lovelace ui </h3>  Dies ist der Name des verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Front-End-</a> HA.  Diese grafische Oberfläche, über die ein normaler Benutzer aufgefordert wird, ein Smart Home zu steuern, ist die Startseite der HA-Weboberfläche.  Die LUI-Schnittstelle besteht aus Karten verschiedener Typen, die die Werte von Objekten widerspiegeln können und zum Aufrufen von Funktionen und anderen Aufgaben dienen.  Karten können analog zu Browser-Lesezeichen auf Seiten (Ansicht) verteilt werden.  Das Setup ist bequem über dieselbe grafische Oberfläche organisiert, kann aber auch über den Yaml-Code aufgerufen werden, für den auch ein integrierter Texteditor vorhanden ist.  Ich empfehle, dass Sie sich die Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://demo.home-assistant.io/</a> ansehen, auf der es verschiedene Beispiele für LUI-Einstellungen gibt und auf denen Sie sie leicht sehen, klicken und ändern können. <br><br><img src="https://habrastorage.org/webt/64/bd/zf/64bdzfwclc_3sqnoek13735wgqq.png"><br>  <i><font color="grey">GUI-Setup-Beispiel</font></i> <br><br>  In Bezug auf die Mängel der Benutzeroberfläche geben die Entwickler leider selbst zu, dass das Projekt versucht, gleichzeitig auf den Stühlen des Desktops und des Smartphones zu sitzen.  Standardmäßig bestimmt LUI die Position und Größe von Karten unabhängig voneinander, wodurch eine Seite, die auf dem Monitor normal aussieht, manchmal auf dem Smartphone-Bildschirm in Unordnung gerät und umgekehrt.  Es gibt einige einfache Tools, um die Benutzeroberfläche zu optimieren, aber meiner Erfahrung nach sind sie nicht immer effektiv. <br><br>  Ich denke, es ist nicht sehr sinnvoll, die Erstellung der Benutzeroberfläche mit grafischen Werkzeugen zu beschreiben. Daher werde ich einige Beispiele in Form des von mir verwendeten Yaml-Codes geben.  Nachdem wir eine separate Seite (Ansicht) für unseren Reiskocher erstellt haben, werden wir versuchen, diese mit den wichtigsten Elementen zu füllen, damit sie bei Verwendung des Smartphone-Bildschirms nicht abgelehnt werden. <br><br>  Hier werden wir diese sehr einfachen Schnittstellen-Bestellwerkzeuge ausprobieren, die horizontal und vertikal gestapelt sind.  Erstellen Sie zunächst einen vertikalen Stapel aus Karten vom Typ Entity-Button und Sensor.  Der erste dient zum Starten unseres Reiskochers, der zweite zum Anzeigen der Temperatur: <br><div class="spoiler">  <b class="spoiler_title">Vertikalstapel</b> <div class="spoiler_text"><pre> <code class="bash hljs">cards: <span class="hljs-comment"><span class="hljs-comment">#    - type: entity-button #      entity: sensor.xiaomi_cooker_state # ,     icon: 'mdi:selection' #     icon_height: 100px #   name: Offline #    show_icon: true # show_name: true # tap_action: #    action: call-service #  –   service: script.turn_on #  –   service_data: #    entity_id: script.order_cooker_start #  –   hold_action: #    action: none # - type: sensor #      entity: sensor.xiaomi_cooker_temperature # ,     name: Temper #   type: vertical-stack #   –  </span></span></code> </pre> <br></div></div><br>  Der Home Assistant enthält ein Archiv von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material Design Icons</a> , das über entsprechende Namen (z. B. mdi: selection) in Einstellungselementen verwendet werden kann.  Das Skript (in diesem Fall nicht Python-, sondern Yaml-), mit dem wir den Dienst aufgerufen haben, ist ein weiteres praktisches HA-Tool. <br><br>  Kombinieren Sie nun den obigen vertikalen Stapel mit unserer Porträtkarte im jetzt horizontalen Stapel.  Alles wird genauso einfach sein: <br><div class="spoiler">  <b class="spoiler_title">horizontaler Stapel</b> <div class="spoiler_text"><pre> <code class="bash hljs">ards: <span class="hljs-comment"><span class="hljs-comment">#    - type: picture #   image: /local/akari_r.jpg #    - #         type: horizontal-stack #   –  </span></span></code> </pre> <br></div></div><br>  Hier müssen Sie die Zeile 'Bild:' markieren.  Alle Dateien, die wir in den Ordner '~ / .homeassistant / www' legen, werden unter dem Link <a href="">http: // localhost / local /</a> filename verfügbar. <br><br>  Der nächste Schritt besteht darin, ein wenig an der von uns erstellten Schaltfläche für Serviceanrufe zu arbeiten.  Es wäre für uns praktisch, wenn es als Kippschalter funktionieren würde, d.h.  Ein / Aus und nicht so, wie es jetzt gemacht wird.  Dies kann durch die Verwendung einer bedingten Karte erreicht werden, deren Anzeige auf dem Bildschirm durch Einstellen bestimmter Bedingungen angepasst werden kann.  Unten finden Sie den Code für die Karte, mit der der Reiskocher ausgeschaltet wird und der nur sichtbar ist, wenn der Reiskocher gerade das Gericht zubereitet: <br><div class="spoiler">  <b class="spoiler_title">bedingt</b> <div class="spoiler_text"><pre> <code class="bash hljs">card: <span class="hljs-comment"><span class="hljs-comment">#    entity: sensor.xiaomi_cooker_state # icon: 'mdi:star-box-outline' # icon_height: 100px # name: Running # tap_action: # action: call-service # service: xiaomi_cooker.stop # type: entity-button # conditions: #   # ,    entity: sensor.xiaomi_cooker_mode #  ,     state: Running type: conditional #  </span></span></code> </pre> <br></div></div><br>  Wenn Sie den zuvor erstellten Power-Button-Code auf ähnliche Weise umschreiben und damit kombinieren, erhalten Sie eine Taste, die sowohl ein- als auch ausgeschaltet ist. <br><br>  Wir ergänzen unser Interesse mit einer weiteren Karte - mit der Zeit bis zum Ende des Garvorgangs (ähnlich der Temperaturkarte) und einer weiteren mit den Details des Rezepts (benutzerdefiniert: Rezeptkarte).  Als Ergebnis erhalten wir ungefähr Folgendes: <br><div style="text-align:center;"><img width="50%" src="https://habrastorage.org/webt/k6/kv/zq/k6kvzqqugn8sizjtsemxyufquo8.jpeg"></div><br><h3>  Benutzerdefinierte Karten </h3>  Home Assistant bietet neben der Fülle der integrierten Kartentypen natürlich auch die Möglichkeit, eigene Karten zu erstellen.  Solche Karten werden als benutzerdefinierte Karten bezeichnet und mit Javascript erstellt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> sind zwei einfache Codebeispiele.  Es ist einfach, vorgefertigte Karten zu finden, die von verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Enthusiasten im</a> Netzwerk erstellt wurden. Wenn Sie selbst experimentieren möchten, sollten Sie herausfinden, dass spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">js-Module</a> erstellt wurden, um das Schreiben neuer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karten</a> zu vereinfachen.  Meine Erfahrung mit Javascript will immer weniger, daher werde ich als Beispiel nur einen kleinen Teil des Kartencodes angeben, der zur Auswahl und Anzeige des aktuellen Rezepts verwendet wird. <br><div class="spoiler">  <b class="spoiler_title">www / prescription-card.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     lit-element LitElement, html, css } from "https://unpkg.com/lit-element@latest/lit-element.js?module"; //      class RecipeCard extends LitElement { //     HA static get properties() { return { hass: {}, config: {} }; } //    callServiceEx() { this.hass.callService('persistent_notification', 'create', {message: 'example'}); } //  html-  render() { //    ,     const entityId = this.config.entity; //    const state = this.hass.states[entityId]; //    const titleStr = state ? state.attributes.title : 'unavailable'; const descrStr = state ? state.attributes.description : 'unavailable'; //    return html` &lt;ha-card&gt; &lt;div class="flex" style="margin-top:16px;"&gt; &lt;div class="icon"&gt; &lt;ha-icon icon="mdi:bowl"&gt;&lt;/ha-icon&gt; &lt;/div&gt; &lt;div class="header"&gt; &lt;span class="name"&gt;Recipe&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="flex info" style="margin-bottom:16px;"&gt; &lt;span class="recipe-title"&gt;${titleStr}&lt;/span&gt; &lt;span class="recipe-descr"&gt;${descrStr}&lt;/span&gt; &lt;/div&gt; &lt;/ha-card&gt; `; } //     customElements.define('recipe-card', RecipeCard);</span></span></code> </pre> <br></div></div><br><br>  Um die neue Karte zu verwenden, müssen Sie am Anfang der LUI-Einstellungsdatei den folgenden Code hinzufügen: <br><div class="spoiler">  <b class="spoiler_title">Rezeptkarte</b> <div class="spoiler_text"><pre> <code class="bash hljs">resources: <span class="hljs-comment"><span class="hljs-comment">#    - type: module #   –  url: /local/recipe-card.js #  </span></span></code> </pre><br>  und unter der Liste der Karten: <br><pre> <code class="bash hljs"> - <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: <span class="hljs-string"><span class="hljs-string">'custom:recipe-card'</span></span> <span class="hljs-comment"><span class="hljs-comment">#   entity: overmind.current_recipe # ,    </span></span></code> </pre><br><br></div></div><br><h3>  Benachrichtigungen </h3>  Ein notwendiger Bestandteil eines Smart Homes ist das Senden von Nachrichten an den Benutzer.  In HA werden diese Nachrichten als Benachrichtigungen bezeichnet, und es gibt zwei grundlegende Arten von Benachrichtigungen.  Das erste sind dauerhafte Benachrichtigungen.  Zum Senden wird der integrierte Dienst "persistent_notification.create" verwendet.  Eine Liste solcher Nachrichten ist über das Glockensymbol in der grafischen Oberfläche verfügbar. Sie verwenden Markdown-Markups und sind im Wesentlichen recht einfach. <br><br>  Ein weiteres, interessanteres Tool ist das integrierte Benachrichtigungsmodul, mit dem Sie durch die Installation zusätzlicher Module Nachrichten über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattformen</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbietern</a> senden können.  Betrachten Sie als Beispiel ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul für ein Telegramm</a> . <br><br>  Um das Modul nutzen zu können, müssen wir zunächst einen Tel im Telegramm selbst erstellen.  Beim Einrichten benötigen wir die chat_id unseres Benutzers und die Token-Bot-API.  Wie Sie diese Daten erhalten - ausführlich beschrieben unter dem obigen Link, gehen wir davon aus, dass wir bereit sind.  Um direkt mit der Installation des Moduls fortzufahren, kopieren Sie zunächst wie bereits zuvor den Quellcode in den Komponentenordner und fügen Sie dann die Einstellungen zur Datei "configuration.yaml" hinzu: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">telegram_bot: <span class="hljs-comment"><span class="hljs-comment">#   telegram platform: polling #   api_key: XXXXXXXXXXXXX # API Token   allowed_chat_ids: XXXXXXX # chat_id   proxy_url: socks5://XXXXXXXXXXXXX #     proxy_params: username: umpiro password: umpiro_password</span></span></code> </pre> <br>  Plus-Einstellungen für das Benachrichtigungsmodul: <br><pre> <code class="bash hljs">notify: <span class="hljs-comment"><span class="hljs-comment">#   notify name: notify_send #   (   –  notify.notify_send) platform: telegram #   chat_id: XXXXXXX # chat_id  </span></span></code> </pre> <br></div></div><br><br>  Mit dem Telegrammmodul können wir Nachrichten, Bilder oder Videos senden.  Als Beispiel erstellen wir eine Automatisierung, um eine Nachricht mit einem Bild zu senden und uns über das Ende des Kochvorgangs zu informieren. <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1571074941908'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: EOC #   trigger: #    # ,   - entity_id: sensor.xiaomi_cooker_mode from: Running #    #   –    platform: state to: Waiting #    condition: [] #   action: #    - service: notify.notify_send #  –   data: # ,     title: End of Cooking #  message: "EOC" #  data: #    photo: #   -  #   - file: /home/umpiro/.homeassistant/www/cat.jpg #   caption: “EOC”</span></span></code> </pre> <br></div></div><br><br><h3>  Nachwort </h3>  Home Assistant kann für diejenigen von Interesse sein, die versuchen möchten, die lokale Verwaltung eines Smart Homes zu organisieren.  Dies ist ein breites, interessantes, offen und aktiv entwickeltes Projekt, das sich aufgrund der Bemühungen der Community entwickelt.  Die Vielfalt der Home Assistant-Tools kann sich nur freuen (ich hatte keine Zeit, einige wichtige zu erwähnen).  Als Minus kann man die relative Komplexität und Unvollständigkeit der Dokumentation erwähnen. <br>  PS <br>  Vor kurzem, am 10. Oktober, gab es, ich weiß nicht, ob dies als Release bezeichnet werden kann, den Übergang des Projekts von Version 0.99 auf Version 0.100. <br>  Zitat aus den Versionshinweisen: <br><blockquote>  Willkommen zu den Versionshinweisen einer weiteren wundervollen Veröffentlichung!  Nein, wir wollen nicht 1.0, wir machen 0.100!  Wir haben das Gefühl, dass wir mit unseren Zielen für 1.0 noch nicht fertig sind, aber wir machen jeden Tag Fortschritte.  In unserem Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simple Mode in Home Assistant 1.0 finden</a> Sie einen kurzen Überblick über unsere Überlegungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471822/">https://habr.com/ru/post/de471822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471810/index.html">Vergleichen Sie die Tools zum Überwachen von Änderungen in Active Directory: Quest Change Auditor und Netwrix Auditor</a></li>
<li><a href="../de471812/index.html">Kostenlose Wolfram Engine Library für Softwareentwickler</a></li>
<li><a href="../de471814/index.html">WolframClientForPython | Neue Wolfram Language Client Library für Python</a></li>
<li><a href="../de471816/index.html">So signieren Sie Apps für macOS Catalina 10.15</a></li>
<li><a href="../de471820/index.html">Telefonbetrüger. Schritt drei, in dem ich die Dokumentation erhalte, dass meine Bankzelle erstellt wurde</a></li>
<li><a href="../de471824/index.html">Diskettenkamera: 8 interessante Fakten über Sony Mavica MVC-FD85 (viele Bilder)</a></li>
<li><a href="../de471836/index.html">Automatisierte Python-Code-Visualisierung. Vierter Teil: Dokumentationsunterstützung</a></li>
<li><a href="../de471838/index.html">Mathe Liebe</a></li>
<li><a href="../de471840/index.html">Warum zu Interviews gehen?</a></li>
<li><a href="../de471844/index.html">5 Gründe, EPAM INSIDER in Kasachstan zu besuchen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>