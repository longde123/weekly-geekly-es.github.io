<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß£ ‚óªÔ∏è üëáüèº D√©veloppement inverse de la minuterie VL-76-S üë©‚Äçüé® üëÜ üôÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il √©tait une fois, je suis tomb√© sur l'interrupteur horaire num√©rique √©lectronique VL-76-S, neuf, dans son emballage, mais dans un √©tat d√©fectueux. Au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement inverse de la minuterie VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/">  Il √©tait une fois, je suis tomb√© sur l'interrupteur horaire num√©rique √©lectronique VL-76-S, neuf, dans son emballage, mais dans un √©tat d√©fectueux.  Aucun d√©faut n'a √©t√© trouv√© sur les cartes de circuits imprim√©s √† l'int√©rieur.  Par cons√©quent, mariage d'usine, firmware cass√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>Vue g√©n√©rale du relais.</i> <br><a name="habracut"></a><br>  Ce qui nous a surpris, c'est l'utilisation du microcontr√¥leur populaire et simple ATTiny2313.  Ext√©rieurement, cette conception se compose d'un ma√Ætre sous la forme de trois d√©cennies de commutateurs et d'une borne √† laquelle l'alimentation 220 V et les contacts d'un relais EM sont connect√©s.  La plage de la t√¢che est de 0,1 ... 99,9 minutes.  par incr√©ments de 0,1 min  (6 secondes).  Il n'y a pas de circuits et de firmware sur cette conception sur Internet, ce qui n'est pas surprenant.  Sans r√©fl√©chir √† deux fois, j'ai d√©cid√© de dessiner le circuit √† partir des cartes de circuits imprim√©s et √† l'avenir, j'√©crirais moi-m√™me le programme sur le MK. <br><br>  La conception se compose de trois cartes de circuits imprim√©s interconnect√©es.  Sur la premi√®re carte, un bloc d'alimentation et un relais d'ex√©cution TRA3 sont r√©alis√©s.  L'alimentation se fait selon un circuit sans transformateur: des condensateurs d'extinction sont utilis√©s pour r√©duire la tension.  Sur la deuxi√®me carte se trouve l'ATTiny2313 MK et d'autres √©l√©ments auxiliaires.  Sur la troisi√®me carte se trouvent des interrupteurs (points de consigne) et une LED de contr√¥le. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>Photo de la troisi√®me planche de dos.</i> <br><br>  Je vais commencer la description avec le troisi√®me tableau.  Les commutateurs sont des commutateurs √† 10 positions.  Il n'y a aucun marquage dessus, chacun d'eux a 5 contacts.  Par cons√©quent, selon la position, certains contacts sont ferm√©s dans diverses combinaisons.  Appelant des contacts, j'ai tout de suite saisi le sch√©ma: une sortie fixe (g√©n√©rale) est ferm√©e avec les quatre autres sorties (informations) selon la repr√©sentation binaire du nombre correspondant au num√©ro de la position s√©lectionn√©e.  Par exemple, si la position ¬´3¬ª est s√©lectionn√©e, la sortie g√©n√©rale (cinqui√®me cons√©cutive) se ferme avec la sortie des troisi√®me et quatri√®me, puisque le nombre ¬´3¬ª en repr√©sentation binaire est ¬´0011¬ª.  Voici un tel interrupteur d√©licat.  Et il y en a trois.  Ils sont connect√©s via des connecteurs XP1 et XP2 √† la deuxi√®me carte avec MK.  Un connecteur XP3 connecte une LED et quelques autres conneries inutiles non soud√©es, pour lesquelles il y a une place sur la carte.  Il s'agit tr√®s probablement d'un commutateur DPDT √† six broches commun (tel qu'un carr√©, PB22E06 par exemple).  Peut-√™tre que la carte est universelle, mais elle n'est pas utilis√©e dans ce mod√®le particulier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>Photo de la deuxi√®me carte (principale).</i> <br><br>  Appelant les contacts des commutateurs, je n'ai pas tout de suite compris le principe de leur connexion aux ports MK.  Sur la carte principale, 8 transistors SMD sont imm√©diatement √©vidents.  Il a d√©couvert plus tard que ces transistors sont utilis√©s comme paires de diodes avec une anode commune.  Leurs bases vont aux ports MK, et les collecteurs et les √©metteurs vont commuter les contacts.  Puis ils m'ont expliqu√© que dans de tels cas, il y a des paires de diodes, elles sonnent comme des transistors, mais ce ne sont pas des transistors.  Au total, nous avons 16 conducteurs laissant les paires de diodes sur la troisi√®me carte.  Les trois quarts d'entre eux (12 pi√®ces) viennent aux contacts d'information des interrupteurs (trois √† quatre), et 4 restent libres.  Il est facile de deviner qu'ils sont th√©oriquement fournis pour le quatri√®me commutateur, qui n'est pas absent, car il n'y a pas du tout d'espace sur la carte.  N√©anmoins, afin de ne pas violer la logique du raisonnement, je mentionnerai ce quatri√®me interrupteur imaginaire.  Les extr√©mit√©s communes des deuxi√®me et troisi√®me, ainsi que les premier et quatri√®me commutateurs (mais le quatri√®me ne pr√©voit pas la carte) sont connect√©es ensemble par paires par des pistes dans la carte principale sur les connecteurs homologues XS1 et XS2.  Ces deux paires sont connect√©es aux sorties des groupes de transistors.  Ces deux groupes identiques sont r√©alis√©s sur les transistors BC857 et BC847 (structures diff√©rentes).  Leurs entr√©es sont connect√©es au MK.  Lors de l'application d'un "0" logique √† l'entr√©e de ce groupe, la sortie sera √©galement un "0" logique.  De plus, sur la carte il y a un connecteur XP2 pour le firmware MK, connect√© aux bornes SPI de l'interface MK, un connecteur XS3 pour une LED et un connecteur XP1 connect√© par un c√¢ble √† la premi√®re carte.  Il convient de rappeler que certains des ports MK peuvent √™tre utilis√©s √† la fois pour SPI (pour le firmware) et pour les entr√©es-sorties ordinaires (fonctionnent dans le circuit). <br><br>  Tout ce qui pr√©c√®de se refl√®te dans les diagrammes que j'ai dessin√©s d'abord dans le projet, puis dans SPlan.  Les valeurs nominales des √©l√©ments radio non marqu√©s (par exemple, les condensateurs CMS) sont absentes dans les diagrammes, elles ne sont pas si importantes.  Tout d'abord, je vais donner un sch√©ma de la carte principale et de la carte avec les setters (signatures des photos ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>Sch√©ma de la carte principale.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>Sch√©ma de la troisi√®me planche avec setters</i> <br><br>  Consid√©rez comment l'interrogation de chaque setter.  Les signaux des ports PB4 et PB5 MK logique "0" ouvrent les transistors VT2 et VT1, suivis de VT4 et VT3, se connectant aux contacts communs du bus z√©ro des commutateurs n ¬∞ 1 et n ¬∞ 2-n ¬∞ 3, respectivement.  Cela se produit √† son tour.  Premi√®rement, le ¬´0¬ª logique provient de PB4 (PB5 a jusqu'√† pr√©sent √©t√© r√©gl√© sur ¬´1¬ª logique), connectant les deuxi√®me et troisi√®me commutateurs.  Dans cet √©tat, les valeurs des signaux sont enregistr√©es tour √† tour par le contr√¥leur √† partir des ports d'entr√©e PB3, PB2, PB1, PB0 via les groupes de diodes 2VD1 ... 2VD4 √† partir du deuxi√®me et du quatri√®me commutateur manquant.  Imm√©diatement, les valeurs des signaux des broches PD6, PD5, PD4, PD3 MK sont fix√©es, auxquelles les signaux des premier et troisi√®me commutateurs passent par les groupes de diodes 2VD5 ... 2VD8.  Mais, puisque seuls les deuxi√®me et troisi√®me commutateurs sont connect√©s par un contact commun, les signaux du deuxi√®me commutateur parviendront aux premiers ports sp√©cifi√©s du MK et le quatri√®me sera ignor√©.  De m√™me, les signaux du troisi√®me commutateur parviendront √† la seconde moiti√© du MK et le premier sera ignor√©.  √Ä ce stade, le contr√¥leur sait dans quelles positions les deuxi√®me et troisi√®me commutateurs sont install√©s.  Apr√®s cela, PB4 est r√©gl√© sur ¬´unit√©¬ª, d√©sactivant les deuxi√®me et troisi√®me commutateurs, et PB5 est r√©gl√© sur ¬´z√©ro¬ª.  Dans ce cas, le premier et le quatri√®me interrupteurs manquants sont connect√©s par une extr√©mit√© commune au ¬´bo√Ætier¬ª.  Leur interrogation se produit exactement de la m√™me mani√®re que dans le cas pr√©c√©dent, mais maintenant les signaux de ces commutateurs qui ont √©t√© ignor√©s la derni√®re fois seront enregistr√©s.  Ainsi, le contr√¥leur conna√Æt les informations de position de tous les commutateurs.  Ce processus est similaire √† l'interrogation d'un clavier matriciel, mais dans ce cas, une matrice √† 4 couches avec des dimensions de 2 par 2 avec un √©l√©ment manquant. <br><br>  R√©sistances R8 ... R15 - tractions.  Cependant, il √©tait possible de "tirer vers le haut" dans le MK lui-m√™me.  La fr√©quence d'horloge pr√©cise MK fournit du quartz √† 10 MHz.  Circuit de r√©initialisation R1 et C4 - MK.  Il n'y a rien de plus int√©ressant sur ce forum. <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>Photo de la premi√®re carte (d'alimentation) du c√¥t√© des √©l√©ments.</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>Photo de la premi√®re carte (d'alimentation) de l'arri√®re.</i> <br><br>  Passons au sch√©ma de la premi√®re planche (Fig. Ci-dessus).  Le sch√©ma semblait tr√®s int√©ressant et √† certains endroits incompr√©hensible. <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>Sch√©ma de la premi√®re carte (d'alimentation).</i> <br><br>  C1C2 - pour r√©duire la tension.  R1 - pour d√©charger ce qui pr√©c√®de.  Apr√®s le pont de diodes DB1 se trouvent deux √©lectrolytes.  Pour compliquer le circuit (ou pour la fiabilit√©) - sch√©ma de stabilisation en cascade VT3R6VD3 - VT7R12VD5.  Le VD5 est similaire √† un transistor SMD √† √©metteur non utilis√©.  Cela fournit une tension continue stabilis√©e de 12V.  Ensuite, le r√©gulateur lin√©aire VR1 √† 5V.  Dans le m√™me temps, la tension est supprim√©e du pont de diodes DB1 √† travers la diode VD2 vers un autre stabilisateur 24 V VT1R3VD1.  Cette tension est fournie √† la bobine du relais EM Rel1 et √† R17.  Ce dernier ne sait pas pourquoi.  √Ä l'autre extr√©mit√© de R17 vient le signal du groupe de transistors VT9VT10.  Le circuit de ce groupe est similaire au circuit de la carte principale.  Un signal provenant d'un port MK PB6 s√©par√© arrive √† l'entr√©e de ce groupe de transistors via le connecteur.  Pourquoi est-il n√©cessaire?  Pourquoi connecter une r√©sistance R17 √† 24V?  Tr√®s probablement, il y avait une id√©e qu'au lieu d'une r√©sistance, vous pouvez mettre autre chose, par exemple, une LED de contr√¥le interne, en programmant le port PB6 MK d'une certaine mani√®re.  Ou un n≈ìud de commutation suppl√©mentaire.  Mais, tout de m√™me, c'est un non-sens, comme l'ont dit mes connaissances des ing√©nieurs radio, apr√®s avoir examin√© le tableau de conception.  La deuxi√®me extr√©mit√© du relais EM Rel1 est connect√©e √† un groupe de transistors similaire VT2VT5, et elle est connect√©e au port MK PD0.  Le signal "0" de ce port active le relais EM en cours d'ex√©cution.  La chose la plus int√©ressante est que la LED externe est connect√©e non pas parall√®lement au relais EM, mais √† l'espace de l'√©metteur du transistor VT2, en outre, via deux connecteurs (passant la carte principale).  Sur le terminal, les broches 1 et 2, √† en juger par l'autocollant sur le relais, restent vides.  Mais dans le circuit, le contact n ¬∞ 2 est connect√© √† un fil commun, et le contact n ¬∞ 1 est aliment√© √† l'entr√©e du groupe de transistors VT6VT8.  La sortie de ce groupe est envoy√©e au port PD2 MK.  Plus tard, j'ai lu dans les sp√©cifications de ce mod√®le de relais que ces contacts sont utilis√©s pour contr√¥ler d'autres mod√®les de relais, assembl√©s dans le m√™me bo√Ætier.  Le mod√®le que j'envisage n'implique pas de contr√¥le, mais il peut √™tre impl√©ment√© lors de l'√©criture d'un programme sur MK, car le sch√©ma offre cette possibilit√©.  Sous le contr√¥le peut signifier un d√©marrage, une r√©initialisation (√† la fois en ¬´d√©clencheur¬ª et en mode normal), et tout ce qui vous vient √† l'esprit.  Les sp√©cifications des autres relais pr√©sentent des chronogrammes qui montrent le comportement des relais en fonction d'un signal de commande donn√©.  Il est √©galement indiqu√© ci-dessous: √† la demande du client, nous pouvons mettre en ≈ìuvre tout sch√©ma possible.  Et le dernier moment du sch√©ma.  Ce signal de commande de la borne n ¬∞ 1 vient √©galement du transistor VT4 inutile, aliment√© par une tension de 12V.  C'est l√† encore une complication du sch√©ma.  Ou peut-√™tre y a-t-il encore une id√©e pos√©e?  Je n'ai pas fouill√© profond√©ment.  Je serai heureux de tout commentaire. <br><br>  Les marquages ‚Äã‚Äãdes bornes des connecteurs sont sign√©s par le point apr√®s le nom du connecteur lui-m√™me.  Les chiffres romains apr√®s le symbole ¬´~¬ª indiquent des conclusions inutiles et manquantes.  Ces derniers ne sont pas rares dans le sch√©ma, mais je ne m'attarderai pas sur eux.  Ci-dessous, je donne des croquis de chaque carte avec les d√©signations des connecteurs, les conclusions et les √©l√©ments de base. <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>Croquis du tableau.</i> <br><br>  Consid√©rez la description du code source du programme MK.  Le programme lui-m√™me est simple et a √©t√© √©crit par moi dans CVAVR pendant 20 minutes.  Je vais discuter de l'algorithme par lequel le programme sera ex√©cut√©.  Ces informations peuvent sembler assez banales pour certains, mais elles ne seront pas superflues pour les d√©butants.  Dans ma version de l'algorithme, les temporisateurs du relais temporel seront interrog√©s non pas une fois, mais en continu.  De plus, l'interrogation continuera m√™me apr√®s le d√©clenchement du relais.  Cela vous permettra de faire des ajustements lors de vos d√©placements.  Peut-√™tre que cet algorithme ne co√Øncide pas avec l'algorithme d'origine pour le fonctionnement de ce relais, mais je ne connais pas l'algorithme d'origine.  C'est sur l'exemple de l'algorithme pr√©cit√© que la description du programme sera consid√©r√©e. <br><br><div class="spoiler">  <b class="spoiler_title">Code source du programme C avec description.</b> <div class="spoiler_text">  Nous connectons la biblioth√®que pour travailler avec l'ATTiny2313 MK, ainsi que la biblioth√®que des fonctions de retard. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br>  Ensuite, nous faisons la macro substitution n√©cessaire, en fonction des affectations de circuit des ports MK.  Ces substitutions sont pratiques car dans le texte du programme au lieu, par exemple, de PORTB.5, vous pouvez √©crire getAD, ce qui est plus pratique.  La compilation getAD sera interpr√©t√©e comme PORTB.5.  Ainsi, la premi√®re substitution est les sorties pour connecter les premier (A) et quatri√®me (D) commutateurs de consigne.  Le second est pour le deuxi√®me (B) et le troisi√®me (C).  Vient ensuite la substitution pour activer le relais.  Et enfin, la substitution ¬´Ctrl¬ª qui n'est pas utilis√©e dans le programme et dans le mod√®le consid√©r√©.  Vous ne pouvez pas l'√©crire. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br>  Les variables A, B, C sont utilis√©es pour stocker le num√©ro de position des trois commutateurs correspondants et prendre des valeurs de 0 √† 9. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br>  Variable i - la valeur actuelle du nombre du dixi√®me de minute (6 secondes), c'est-√†-dire le num√©ro du ¬´tick¬ª minimum du relais.  La variable t est le nombre de dixi√®mes de minute (ticks) re√ßus du ma√Ætre. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br>  La fonction principale du programme est pr√©sent√©e ci-dessous.  Dans les 6 premi√®res lignes, je n'ai pas compris.  Ils sont form√©s √† l'aide de l'utilitaire auxiliaire CodeWizadAVR et sont associ√©s √† la pr√©sence de quartz externe √† 10 MHz. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Les deux lignes suivantes configurent le port B de notre MK.  Selon le sch√©ma, nous mettons les 4 bits inf√©rieurs √† l'entr√©e et les plus importants √† la sortie (PB7 n'est pas utilis√© et PB6 est inutile, mais, en th√©orie, la sortie).  Par cons√©quent, selon les principes de configuration MK, que je ne d√©crirai pas, nous √©crivons le nombre 240 dans le registre DDRB (F0 en notation hexad√©cimale).  Le niveau de sortie initial est ¬´1¬ª, √† l'exception du PB7 inutile.  Et juste au cas o√π, connectons les ¬´r√©sistances de pull-up¬ª de MK aux entr√©es, m√™me si elles sont d√©j√† install√©es dans le circuit.  Pour ce faire, d√©finissons le registre PORTB sur 7F en notation hexad√©cimale. <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br>  Le port D est configur√© de la m√™me mani√®re. Toutes les broches de l'entr√©e, √† l'exception des deux inf√©rieures.  Les ¬´r√©sistances de rappel¬ª √† l'entr√©e et le niveau de sortie initial ¬´1¬ª √† la sortie sont similaires. <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br>  Les cinq lignes suivantes concernent la configuration de l'un des minuteurs MK.  Cette minuterie est √† seize chiffres, c'est-√†-dire qu'elle fournit un score allant jusqu'√† 2 ^ 16 = 65536.  La fr√©quence de comptage est d√©termin√©e par la fr√©quence d'horloge MK et le coefficient de division (l'un des cinq pr√©d√©finis).  Dans le programme d√©crit, il a √©t√© d√©cid√© de garder un compte pendant 6 secondes (√©tape de t√¢che minimale), puis d'augmenter la variable i de 1 et de r√©initialiser la minuterie au d√©but du comptage.  Pour garantir ce qui pr√©c√®de, vous devez prendre le rapport de division maximum de 1024 et compter jusqu'√† 58594. Ce dernier est facile √† calculer.  Fr√©quence MK - 10 000 000 Hz.  En utilisant un rapport de division de 1024, la fr√©quence de la minuterie sera de 10 000 000/1 024 = 9 765,625 Hz et la p√©riode sera de 1 024 000/10 000 000 = 0,0001024 s.  Dans les 6 secondes, 6 / 0,0001024 = 58593,75 de ces p√©riodes seront empil√©es.  Ce nombre se trouve dans le temporisateur 16 bits, mais ce n'est pas un entier, vous devez donc arrondir √† 58594. Dans ce cas, l'erreur de notre relais temporel sera insignifiante: 58594-58593,75 = 0,25;  0,25 * 0,0001024 = 0,0000256;  0,0000256 * 999 = 0,0255744.  Autrement dit, pour la p√©riode de temps maximale possible (99,9 minutes), l'inexactitude de ce relais temporel sera d'environ 25,6 millisecondes, ce qui est tout √† fait acceptable dans la pratique.  Soit dit en passant, le fabricant stipule √©galement l'erreur de l'appareil, et notre erreur ne sera pas pire.  Dans le registre de configuration du temporisateur TCCR1B, √©crivez la valeur 5. Sans entrer dans les d√©tails, cela signifie que le temporisateur d√©marre et que le coefficient de division est 1024. Dans le registre TCNT1, nous √©crivons la valeur 0. Ce registre est de 16 bits et est divis√© en deux moiti√©s de 8 bits: le plus jeune (L ) et senior (H).  La valeur y est √©crite, d'o√π la minuterie continuera de compter.  Nous devons compter √† partir de z√©ro.  La valeur OCR1A s'enregistre avant laquelle le temporisateur lira, apr√®s quoi il appellera la fonction d'interruption.  √Ä ce moment, la fonction principale du programme est interrompue et les actions sp√©cifi√©es dans la fonction de cette interruption sont ex√©cut√©es.  Apr√®s avoir pratiqu√© l'interruption, la fonction principale continuera de s'ex√©cuter.  Cette valeur, comme cela a √©t√© dit ci-dessus, est √©gale √† 58594 (E4E2 en notation hexad√©cimale).  √âtant donn√© que le registre OCR1A est √©galement divis√© en deux moiti√©s, nous √©crivons la valeur ci-dessus en parties. <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br>  Les deux lignes suivantes configurent correctement la r√©solution des interruptions (n'entrez pas dans les d√©tails). <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br>  Dans le cycle principal, les commutateurs de r√©glage sont constamment interrog√©s (selon l'algorithme dans la description du circuit) en utilisant des retards de 30 ms pour un fonctionnement correct et stable.  En d√©finissant la valeur ¬´0¬ª sur PORTB.5 (getAD = 0), nous pr√©parons le premier commutateur.  Ses conclusions sont connect√©es au port D du MK aux broches 6, 5, 4, 3. La direction va du plus jeune au plus ancien.  C'est-√†-dire que le bit de poids faible du commutateur est connect√© au bit de poids faible (bit 3) du port MK.  Par cons√©quent, afin de recevoir des informations du port D du MK sur la position du premier commutateur, il est n√©cessaire de faire un d√©calage au niveau du bit vers la droite de trois positions (PIND &gt;&gt; 3), inverser les bits re√ßus avec l'op√©ration "~" (puisque les informations viendront en "0", selon le sch√©ma) et r√©initialiser les quatre bits sup√©rieurs inutiles de la valeur de 8 bits re√ßue.  La derni√®re op√©ration se fait par multiplication logique au niveau du bit du r√©sultat par le nombre 15 (00001111 en repr√©sentation binaire).  Apr√®s cette op√©ration, la variable A se verra attribuer la valeur de position du premier interrupteur.  Ensuite, le premier interrupteur est d√©sactiv√© et les deuxi√®me et troisi√®me sont pr√©par√©s.  La valeur du deuxi√®me commutateur √† la variable B est prise du port B du MK de la m√™me mani√®re, mais sans op√©ration de d√©calage, car les bornes de ce commutateur sont connect√©es aux broches les plus basses du port B du MK et √©galement de mani√®re co-directionnelle.  Les informations du troisi√®me commutateur vers la variable C sont supprim√©es de la m√™me mani√®re que le premier.  Apr√®s cela, les deuxi√®me et troisi√®me commutateurs (getBC = 1) sont ¬´ferm√©s¬ª et la valeur d√©finie (le nombre de dixi√®mes de minute) des trois commutateurs est calcul√©e dans la variable t. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br>  La comparaison de cette variable et d'une variable en temps r√©el similaire i se produit dans la fonction d'interruption. <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br>  Si la derni√®re variable d√©passe la valeur d√©finie, le ¬´relais d'ex√©cution¬ª (RL = 0) s'allume de ¬´0¬ª.  De plus, il s'√©teindra si, en m√™me temps, les commutateurs sont r√©gl√©s sur une valeur sup√©rieure √† celle qui a fonctionn√© dans la variable i.  Dans la m√™me fonction d'interruption, la variable i est augment√©e de 1 et le temporisateur est remis √† 0. <br><br>  Les bits FUSE ont √©t√© radi√©s de MK et sont rest√©s inchang√©s.  Je les ai analys√©s, tout va bien l√†-bas. <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br>  Ainsi, non seulement le sch√©ma de l'appareil a √©t√© copi√©, mais √©galement un programme MK a √©t√© d√©velopp√©, qui ne diff√®re pas en fonctionnalit√©s de celui propri√©taire.  De plus, il est devenu possible au niveau logiciel de modifier de mani√®re assez flexible (et surtout, gratuite) les param√®tres de temps de l'appareil et d'utiliser la sortie de contr√¥le (n ¬∞ 1 sur le terminal) dans diverses fonctionnalit√©s.  Le programme est si simple qu'il peut (encore mieux) √™tre √©crit en assembleur, mais je ne le fais pas encore. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414345/">https://habr.com/ru/post/fr414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414335/index.html">Contexte. Roskomnadzor, qu'est-ce que tu es?</a></li>
<li><a href="../fr414337/index.html">Pens√©e de style Ramda: immuabilit√© et objets</a></li>
<li><a href="../fr414339/index.html">Grande visite photo du nouveau site de coworking √† Moscou #tceh</a></li>
<li><a href="../fr414341/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 256 (du 3 au 12 juin)</a></li>
<li><a href="../fr414343/index.html">Traduction automatique de neurones de Google</a></li>
<li><a href="../fr414347/index.html">Agression passive: comment elle d√©truit notre vie professionnelle et comment y faire face</a></li>
<li><a href="../fr414349/index.html">Obtenez les statistiques de co√ªts du MCC: Tinkoff et Rocketbank</a></li>
<li><a href="../fr414351/index.html">Instruments de musique les plus insolites: orgue Hammond, orchestre Vako et Synclavier</a></li>
<li><a href="../fr414353/index.html">Kivy. De la cr√©ation √† la production est une √©tape. 2e partie</a></li>
<li><a href="../fr414355/index.html">La vie apr√®s l'explosion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>