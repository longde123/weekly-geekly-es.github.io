<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 ✍🏻 👨🏿‍🤝‍👨🏽 Angulaire: ngx-translate. Amélioration de l'infrastructure avec Webpack 🧝🏾 🛠️ 👩🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour. 


 Il est temps pour les hacks de vie ngx-translate. Au départ, j'avais prévu 3 parties, mais parce que la deuxième partie n'est en fait pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angulaire: ngx-translate. Amélioration de l'infrastructure avec Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Bonjour. </p><br><p>  Il est temps pour les hacks de vie ngx-translate.  Au départ, j'avais prévu 3 parties, mais parce que la deuxième partie n'est en fait pas très informative - j'essaierai de résumer la 2ème partie aussi brièvement que possible. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> </p><br><p> Envisagez <code>AppTranslateLoader</code> pour remplacer <code>TranslateHttpLoader</code> .  Notre <code>AppTranslateLoader</code> fera tout d'abord attention à la langue du navigateur et contiendra la logique de secours, importera les localisations MomentJs et chargera via APP_INITIALIZER.  En outre, à la suite de la combinaison de 2 parties de hacks de vie, nous nous plongerons en cours de route dans la création d'une infrastructure de localisation pratique et flexible dans le projet. </p><br><p>  L'objectif principal n'est pas <code>AppTranslateLoader</code> (car il est assez simple et pas difficile à réaliser), mais la création d'infrastructures. </p><br><p>  J'ai essayé d'écrire aussi accessible que possible, mais parce que l'article contient beaucoup de choses qui peuvent être décrites plus en détail - cela prendra beaucoup de temps et ne sera pas intéressant pour ceux qui savent déjà comment)  Par conséquent, l'article n'était pas très convivial pour les débutants.  D'un autre côté, à la fin, il y a un lien pour donner un exemple de prodg. </p><a name="habracut"></a><br><p>  Avant de commencer, je veux attirer l'attention sur le fait qu'en plus de télécharger des langues via http, il est possible d'écrire un chargeur de telle manière qu'il charge les langues nécessaires dans notre bundle au stade de l'assemblage.  Ainsi, vous n'avez pas besoin d'ajouter de chargeurs via http, mais d'un autre côté, avec cette approche, vous devrez reconstruire l'application chaque fois que nous modifions nos fichiers avec des localisations, et cela peut également augmenter considérablement la taille du bundle .js. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Si l'IDE ne jure que sur le <code>System</code> vous devez l'ajouter à typings.d.ts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Maintenant, nous pouvons utiliser <code>WebpackTranslateLoader</code> dans app.module: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Commençons donc à écrire notre <code>AppTranslateLoader</code> .  Pour commencer, je veux identifier plusieurs problèmes qui devront être rencontrés en utilisant le <code>TranslateHttpLoader</code> standard: </p><br><ul><li><p>  <strong>Traduisez le scintillement.</strong>  <code>TranslateHttpLoader</code> ne sait pas comment s'exécuter dans le cadre du processus d'initialisation de l'application et nous pouvons nous retrouver dans une situation où, après l'initialisation, nous voyons que nous avons la place pour les étiquettes correctes dans l'application - les clés (MY_BUTTON_KEY est l'emplacement de mon bouton), qui après un moment changer pour le texte correct. </p><br></li><li><p>  <strong>Les dates</strong>  Ce serait bien d'avoir un service qui permute la localisation des dates.  En ce qui concerne la localisation du texte, vous devrez probablement vous occuper de la localisation des dates, des heures, etc.  Vous pouvez utiliser momentJs ou la solution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">i18n</a> intégrée à Angular.  Les deux solutions sont bonnes et disposent de canaux Angular 2+ pour le formatage dans les vues. </p><br></li><li>  <strong>Mise en cache.</strong>  à l'aide de <code>TranslateHttpLoader</code> , vous devez configurer votre serveur FE pour mettre correctement en cache vos bundles json.  Sinon, les utilisateurs verront les anciennes versions de localisation, pire ils verront les clés de localisation (si de nouvelles ont été ajoutées après la mise en cache par l'utilisateur).  Je ne veux pas déranger chaque fois que je déploie sur un nouveau serveur au moment de la mise en cache.  Nous allons donc faire en sorte que Webpack fasse tout pour nous comme il le fait pour les bundles .js. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brouillon AppTranslateLoader</a> </p><cut></cut><br><h5 id="resheniya-problem">  Solutions aux problèmes: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. traduire le problème de scintillement - utilisez <code>AppTranslateLoader</code> dans le cadre de <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER a également été activement impliqué dans un article sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeton d'actualisation</a> , sinon de bon goût sur l'initialiseur - je vous conseille de lire l'article malgré le fait qu'il s'agit d'un jeton d'actualisation.  En fait, la décision d'utiliser l'initialiseur est très évidente (pour ceux qui ont un initialiseur), mais j'espère quand même qu'il y a des gens qui sont utiles: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. Le problème des dates.  Nous allons simplement changer la langue de momentJs avec ngx-tranlate. </h6><br><p>  Tout est simple ici - après le chargement de json avec localisation, nous basculons simplement la localisation sur momentJs (ou i18n). </p><br><p>  Il convient également de noter que momentJs, comme i18n, peut importer des localisations séparément, momentJs peut également importer un ensemble, mais l'ensemble complet de localisations prend ~ 260 Ko, et vous n'avez besoin que de 2 d'entre elles. </p><br><p>  Dans ce cas, vous ne pouvez en importer que 2 directement dans le fichier où <code>AppTranslateLoader</code> déclaré. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Les localisations en-gb et ru seront désormais dans le bundle d'application js.  Dans <code>AppTranslateLoader</code> vous pouvez ajouter un gestionnaire de langue fraîchement chargé: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  ce gestionnaire a un inconvénient: si dans notre projet seule la localisation en est fournie pour ngx-translate, mais par exemple moment ou besoin d'utiliser en ou en-gb, la logique du gestionnaire devra être développée, ou la localisation de en-gb devra également être fournie dans ngx-translate. </p><br><p>  !!!  pour le moment avec // TODO: nous pouvons écrire un plugin webpack, nous considérerons quelques plugins plus tard, mais je ne l'ai pas encore. </p><br><p>  Vous vous demandez pourquoi il est impossible de charger des localisations de dates et d'heures ainsi que des localisations de texte dans l'interface (dynamiquement, via HTTP)?  En effet, les localisations de date contiennent leur propre logique et sont donc présentées sous forme de code <a href="">javascript</a> . </p><br><p>  Mais malgré cela, il existe un moyen de charger de telles localisations en écrivant un peu de code «sale».  Je n'utilise pas ce code en production, mais la 2ème localisation à l'intérieur de mon bundle ne me dérange pas.  Mais si vous avez de nombreuses localisations, vous voulez les charger dynamiquement et pas de manière très sécurisée, gardez à l'esprit: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  La dernière fois que j'ai testé cette méthode dans Angular 4. Il est fort probable qu'elle fonctionne maintenant. </p><br><p>  Malheureusement, un tel hack de vie sale ne fonctionnera pas dans le cas de c momentJs (uniquement la localisation angulaire).  Au moins, je n'ai pas trouvé de moyen de le faire, mais si vous êtes un programmeur de hackers très barbu, je serai heureux de voir la solution dans les commentaires. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Mise en cache.  Comme pour la création d'un bundle .js, vous pouvez ajouter un hachage au nom du bundle .json. </h6><br><p>  Tout dépend de la façon dont vous collectez exactement tous les fichiers json dans un seul fichier, peut-être que vous avez tout dans un seul fichier.  Sur Internet, vous pouvez trouver un certain nombre de modules npm qui peuvent collecter de petits fichiers json dans un seul fichier.  Je n'ai pas trouvé ceux qui peuvent s'attacher à un hachage et rassembler tout dans un seul fichier.  Webpack lui-même ne peut pas non plus gérer json comme requis par les spécificités de ngx-translate.  Par conséquent, nous allons écrire notre plugin webpack. </p><br><p>  En bref: nous devons collecter tous les fichiers json du projet selon un modèle spécifique, tandis que nous devons les regrouper par nom (en, ru, de, etc.) car, par exemple, en.json peut se trouver dans différents dossiers.  Ensuite, pour chaque fichier collecté, vous devez joindre un hachage. </p><br><p>  Il y a un problème ici.  Comment <code>AppTranslateLoader</code> reconnaît-il les noms de fichiers si chaque localisation a son propre nom?  Par exemple, en incluant le bundle dans index.html, nous pouvons inclure le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HtmlWebpackPlugin</a> et lui demander d'ajouter lui-même une balise de script avec le nom du bundle. </p><br><p>  Pour résoudre ce problème pour les localisations .json, notre plugin webpack créera config.json, qui contiendra l'association du code de langue avec le nom du fichier de hachage: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  config.json sera également mis en cache par le navigateur, mais cela prendra un peu de temps et nous pouvons simplement spécifier un paramètre queryString aléatoire lorsque GET envahit ce fichier (donc le charge constamment à nouveau).  Ou attribuez un ID aléatoire à config.json (je décrirai cette méthode, la première peut être trouvée dans Google). </p><br><p>  Je veux également simplifier un peu l'infrastructure et l'atomicité des localisations.  json avec localisation se trouvera dans le dossier avec son composant.  Et afin d'éviter les clés en double, la structure du bundle json sera construite en fonction du chemin d'accès à un fichier json spécifique.  Par exemple, nous avons deux en.json, l'un se trouve sur le chemin <code>src/app/article-component</code> , et l'autre <code>src/app/comment-component</code> .  Je veux obtenir le json suivant dans la sortie: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Nous pouvons supprimer la partie du chemin dont nous n'avons pas besoin, afin que les clés soient aussi courtes que possible dans les vues. </p><br><p>  !!!  Il y a un inconvénient: lorsque vous placez le composant dans un autre dossier, la clé de localisation change. </p><br><p>  Plus tard, nous envisagerons un autre hack de vie qui nous permettra d'indiquer dans le composant uniquement le dernier champ clé, indépendamment de l'endroit et de la profondeur de notre projet dans le projet, et en conséquence, nous pouvons le transférer comme vous le souhaitez et le renommer comme vous le souhaitez. </p><br><p>  Fondamentalement, je veux réaliser l'encapsulation et même un soupçon de polymorphisme des localisations ngx-translate.  J'aime le concept d'encapsuler des vues dans Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angular View Encapsulation</a> , ou plutôt le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadow DOM</a> .  Oui, cela augmente la taille de l'application dans son ensemble, mais je dirai à l'avance qu'après que ngx-translate est devenu plus encapsulé, travailler avec des fichiers de localisation est devenu beaucoup plus agréable.  Les composants ont commencé à se soucier uniquement de leurs localisations, en outre, il sera possible de redéfinir les localisations dans le composant enfant en fonction des localisations dans le composant parent.  De plus, vous pouvez désormais transférer des composants d'un projet à l'autre et ils seront déjà localisés.  Mais comme ailleurs, il y a des nuances, plus à ce sujet plus tard. </p><br><p>  Passons donc à notre plugin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que c'est et comment</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fusionner le plugin de localisation</a> . <br>  Le code source du chargeur et du plugin se trouve sur le lien exemple au bas de l'article (dossier ./build-utils). </p><br><p>  Le plugin fait tout ce qui est écrit ci-dessus et accepte les options suivantes: </p><br><ul><li>  omettre.  noms dans le chemin de localisation qui doivent être ignorés (c'est exactement le moment où je veux supprimer les parties supplémentaires du chemin d'accès au fichier) </li><li>  fileInput.  régulier pour récupérer les fichiers de localisation dans prodge (comme test dans le webpack) </li><li>  rootDir.  où commencer la recherche de fichiers par le modèle fileInput </li><li>  outputDir.  où le fichier de configuration et les localisations seront créés dans le dossier dist </li><li>  configName.  sous quel nom le fichier de configuration sera-t-il créé. </li></ul><br><p>  Dans mon projet, le plugin est connecté de cette façon: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  À l'intérieur des composants qui ont besoin de localisation, il y a un dossier <code>@translations</code> , il contient en.json, ru, etc. </p><br><p>  Par conséquent, lors du retournement, tout sera collecté dans un fichier, en tenant compte du chemin d'accès au dossier <code>@translations</code> .  Le bundle de localisation sera dans dist / langs /, et la configuration sera nommée config. $ {Some-random} .json. </p><br><p>  Ensuite, nous nous assurerons que le bundle de localisation souhaité est chargé dans l'application.  Il y a un point fragile - seul le webpack connaît le chemin d'accès aux localisations et le nom du fichier de configuration, prenons cela en compte pour que les dernières données arrivent dans AppTranslateLoader et il n'est pas nécessaire de changer les noms à deux endroits. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> ne fonctionnera tout simplement pas, nous devons déclarer un autre plugin dans webpack (DefinePlugin ou EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Maintenant, nous pouvons changer le chemin d'accès aux localisations et le nom de la configuration en un seul endroit. <br>  Par défaut, à partir de la vente angulaire par défaut générée dans l'assembly du webpack ( <code>ng eject</code> ), vous ne pouvez pas spécifier <code>process.env.someValue</code> partir du code (même si vous utilisez DefinePlugin), le compilateur peut jurer.  Pour que cela fonctionne, vous devez remplir les conditions 2a: </p><br><ul><li>  dans main.ts ajoutez la 1ère ligne <code>/// &lt;reference types="node"/&gt;</code> </li><li>  package.json doit avoir <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Nous passons directement au processus de démarrage. <br>  Si vous avez l'intention d'utiliser APP_INITIALIZER, assurez-vous de renvoyer Promise, not Observable.  Notre tâche consiste à écrire une chaîne de requête: </p><br><ul><li>  Vous devez d'abord télécharger config.json (uniquement s'il n'est pas chargé). </li><li>  essayez de charger la langue, qui est la langue du navigateur de l'utilisateur </li><li>  Fournissez une logique de secours avec la langue de téléchargement par défaut. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  C'est fait. </p><br><p>  Revenons maintenant au problème du déplacement des composants vers d'autres dossiers, de l'encapsulation et de la ressemblance du polymorphisme. </p><br><p>  En fait, nous avons déjà une sorte d'encapsulation.  Les localisations sont poussées dans des dossiers à côté des composants, tous les chemins de clé sont uniques, mais nous pouvons toujours localiser les clés du composant some-component1 à l'intérieur de some-component2 et il sera difficile de garder une trace de tout, nous le découvrirons plus tard. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  Concernant le mouvement des composants: <br>  Maintenant, la clé que nous utiliserons dans la vue est liée de manière rigide au chemin relatif vers le fichier de localisation et dépend de l'infrastructure spécifique du projet. </p><br><p>  Je vais donner un cas assez triste de cette situation: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Mais que se passe-t-il si je change le nom du dossier de composants en post-composant? <br>  Il sera assez difficile de saisir cette clé à tous les endroits nécessaires.  Bien sûr, personne n'a annulé le copier-coller et la recherche-remplacement, mais écrire cela sans les invites de l'IDE est également stressant. </p><br><p>  Pour résoudre ces problèmes, prêtons attention à ce que le webpack fait à ce sujet?  Webpack a une telle chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeur</a> , il existe de nombreux chargeurs disponibles qui fonctionnent sur les chemins de fichiers: par exemple, les chemins de ressources dans css - grâce à webpack, nous pouvons spécifier les chemins relatifs de l'image d'arrière-plan: url (../ relative.png), etc. le reste des chemins de fichiers dans le projet sont partout! </p><br><p>  Celui qui a construit son webpack sait que le chargeur reçoit à l'entrée un fichier qui correspond à un certain modèle.  La tâche du chargeur lui-même est de transformer en quelque sorte ce fichier d'entrée et de le renvoyer, pour d'autres modifications par d'autres chargeurs. </p><br><p>  Par conséquent, nous devons écrire notre chargeur.  La question est de savoir quel type de fichiers allons-nous changer: vues ou composants?  D'un côté, les vues peuvent être directement dans le composant et séparément.  Les vues peuvent être suffisamment grandes et difficiles à analyser, imaginez si nous avons une vue où 100 directives de traduction (pas dans une boucle): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  grâce au chargeur, nous pouvons remplacer le chemin d'accès clé aux localisations de composants à proximité de chaque tuyau ou directive. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  nous pouvons ajouter un champ à un composant qui fournit la localisation: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  C'est aussi mauvais - vous devez composer une clé de localisation partout. </p><br><p>  Étant donné que les options les plus évidentes semblent mauvaises, essayez d'utiliser un décorateur et enregistrez des métadonnées dans le prototype du composant (comme le fait Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="image"></p><br><p>  <strong>annotations</strong> - métadonnées pour les décorateurs angulaires <br>  __app_annotations__ - métadonnées que nous allons stocker pour nous-mêmes </p><br><p>  Le chemin d'accès au dossier de localisation relatif au composant peut être écrit dans le décorateur, le même décorateur peut être développé avec d'autres options à l'exception du chemin d'accès. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    — Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="image"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413787/">https://habr.com/ru/post/fr413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413775/index.html">Attaques contradictoires contre Machines Can See 2018</a></li>
<li><a href="../fr413777/index.html">Lecture du week-end: matériel d'introduction à l'IaaS, sécurité de l'information et événements liés à la réglementation informatique</a></li>
<li><a href="../fr413779/index.html">Minuteries et multitâche sur Arduino</a></li>
<li><a href="../fr413781/index.html">Comment les Bloodhounds publicitaires suivent votre trace sur Internet</a></li>
<li><a href="../fr413783/index.html">Comment meurent les étoiles les plus massives: supernova, hypernova ou effondrement direct?</a></li>
<li><a href="../fr413789/index.html">En Floride, ils n'ont pas vérifié les acheteurs d'armes à la base du FBI pendant un an parce qu'ils avaient oublié le mot de passe</a></li>
<li><a href="../fr413791/index.html">Mécanique quantique des calculs en JS</a></li>
<li><a href="../fr413793/index.html">Cassettes audio dans la culture pop: pourquoi le format d'enregistrement sonore obsolète est à nouveau considéré comme à la mode</a></li>
<li><a href="../fr413795/index.html">Pourquoi l'industrie du divertissement passe à l'IaaS: étude de cas</a></li>
<li><a href="../fr413797/index.html">EA a présenté la nouvelle partie de C&C à l'E3. Et c'est physiquement douloureux de le regarder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>