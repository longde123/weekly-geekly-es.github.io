<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèæ ‚úçüèª üë®üèø‚Äçü§ù‚Äçüë®üèΩ Angulaire: ngx-translate. Am√©lioration de l'infrastructure avec Webpack üßùüèæ üõ†Ô∏è üë©üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour. 


 Il est temps pour les hacks de vie ngx-translate. Au d√©part, j'avais pr√©vu 3 parties, mais parce que la deuxi√®me partie n'est en fait pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angulaire: ngx-translate. Am√©lioration de l'infrastructure avec Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Bonjour. </p><br><p>  Il est temps pour les hacks de vie ngx-translate.  Au d√©part, j'avais pr√©vu 3 parties, mais parce que la deuxi√®me partie n'est en fait pas tr√®s informative - j'essaierai de r√©sumer la 2√®me partie aussi bri√®vement que possible. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> </p><br><p> Envisagez <code>AppTranslateLoader</code> pour remplacer <code>TranslateHttpLoader</code> .  Notre <code>AppTranslateLoader</code> fera tout d'abord attention √† la langue du navigateur et contiendra la logique de secours, importera les localisations MomentJs et chargera via APP_INITIALIZER.  En outre, √† la suite de la combinaison de 2 parties de hacks de vie, nous nous plongerons en cours de route dans la cr√©ation d'une infrastructure de localisation pratique et flexible dans le projet. </p><br><p>  L'objectif principal n'est pas <code>AppTranslateLoader</code> (car il est assez simple et pas difficile √† r√©aliser), mais la cr√©ation d'infrastructures. </p><br><p>  J'ai essay√© d'√©crire aussi accessible que possible, mais parce que l'article contient beaucoup de choses qui peuvent √™tre d√©crites plus en d√©tail - cela prendra beaucoup de temps et ne sera pas int√©ressant pour ceux qui savent d√©j√† comment)  Par cons√©quent, l'article n'√©tait pas tr√®s convivial pour les d√©butants.  D'un autre c√¥t√©, √† la fin, il y a un lien pour donner un exemple de prodg. </p><a name="habracut"></a><br><p>  Avant de commencer, je veux attirer l'attention sur le fait qu'en plus de t√©l√©charger des langues via http, il est possible d'√©crire un chargeur de telle mani√®re qu'il charge les langues n√©cessaires dans notre bundle au stade de l'assemblage.  Ainsi, vous n'avez pas besoin d'ajouter de chargeurs via http, mais d'un autre c√¥t√©, avec cette approche, vous devrez reconstruire l'application chaque fois que nous modifions nos fichiers avec des localisations, et cela peut √©galement augmenter consid√©rablement la taille du bundle .js. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Si l'IDE ne jure que sur le <code>System</code> vous devez l'ajouter √† typings.d.ts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Maintenant, nous pouvons utiliser <code>WebpackTranslateLoader</code> dans app.module: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Commen√ßons donc √† √©crire notre <code>AppTranslateLoader</code> .  Pour commencer, je veux identifier plusieurs probl√®mes qui devront √™tre rencontr√©s en utilisant le <code>TranslateHttpLoader</code> standard: </p><br><ul><li><p>  <strong>Traduisez le scintillement.</strong>  <code>TranslateHttpLoader</code> ne sait pas comment s'ex√©cuter dans le cadre du processus d'initialisation de l'application et nous pouvons nous retrouver dans une situation o√π, apr√®s l'initialisation, nous voyons que nous avons la place pour les √©tiquettes correctes dans l'application - les cl√©s (MY_BUTTON_KEY est l'emplacement de mon bouton), qui apr√®s un moment changer pour le texte correct. </p><br></li><li><p>  <strong>Les dates</strong>  Ce serait bien d'avoir un service qui permute la localisation des dates.  En ce qui concerne la localisation du texte, vous devrez probablement vous occuper de la localisation des dates, des heures, etc.  Vous pouvez utiliser momentJs ou la solution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">i18n</a> int√©gr√©e √† Angular.  Les deux solutions sont bonnes et disposent de canaux Angular 2+ pour le formatage dans les vues. </p><br></li><li>  <strong>Mise en cache.</strong>  √† l'aide de <code>TranslateHttpLoader</code> , vous devez configurer votre serveur FE pour mettre correctement en cache vos bundles json.  Sinon, les utilisateurs verront les anciennes versions de localisation, pire ils verront les cl√©s de localisation (si de nouvelles ont √©t√© ajout√©es apr√®s la mise en cache par l'utilisateur).  Je ne veux pas d√©ranger chaque fois que je d√©ploie sur un nouveau serveur au moment de la mise en cache.  Nous allons donc faire en sorte que Webpack fasse tout pour nous comme il le fait pour les bundles .js. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brouillon AppTranslateLoader</a> </p><cut></cut><br><h5 id="resheniya-problem">  Solutions aux probl√®mes: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. traduire le probl√®me de scintillement - utilisez <code>AppTranslateLoader</code> dans le cadre de <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER a √©galement √©t√© activement impliqu√© dans un article sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeton d'actualisation</a> , sinon de bon go√ªt sur l'initialiseur - je vous conseille de lire l'article malgr√© le fait qu'il s'agit d'un jeton d'actualisation.  En fait, la d√©cision d'utiliser l'initialiseur est tr√®s √©vidente (pour ceux qui ont un initialiseur), mais j'esp√®re quand m√™me qu'il y a des gens qui sont utiles: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. Le probl√®me des dates.  Nous allons simplement changer la langue de momentJs avec ngx-tranlate. </h6><br><p>  Tout est simple ici - apr√®s le chargement de json avec localisation, nous basculons simplement la localisation sur momentJs (ou i18n). </p><br><p>  Il convient √©galement de noter que momentJs, comme i18n, peut importer des localisations s√©par√©ment, momentJs peut √©galement importer un ensemble, mais l'ensemble complet de localisations prend ~ 260 Ko, et vous n'avez besoin que de 2 d'entre elles. </p><br><p>  Dans ce cas, vous ne pouvez en importer que 2 directement dans le fichier o√π <code>AppTranslateLoader</code> d√©clar√©. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Les localisations en-gb et ru seront d√©sormais dans le bundle d'application js.  Dans <code>AppTranslateLoader</code> vous pouvez ajouter un gestionnaire de langue fra√Æchement charg√©: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  ce gestionnaire a un inconv√©nient: si dans notre projet seule la localisation en est fournie pour ngx-translate, mais par exemple moment ou besoin d'utiliser en ou en-gb, la logique du gestionnaire devra √™tre d√©velopp√©e, ou la localisation de en-gb devra √©galement √™tre fournie dans ngx-translate. </p><br><p>  !!!  pour le moment avec // TODO: nous pouvons √©crire un plugin webpack, nous consid√©rerons quelques plugins plus tard, mais je ne l'ai pas encore. </p><br><p>  Vous vous demandez pourquoi il est impossible de charger des localisations de dates et d'heures ainsi que des localisations de texte dans l'interface (dynamiquement, via HTTP)?  En effet, les localisations de date contiennent leur propre logique et sont donc pr√©sent√©es sous forme de code <a href="">javascript</a> . </p><br><p>  Mais malgr√© cela, il existe un moyen de charger de telles localisations en √©crivant un peu de code ¬´sale¬ª.  Je n'utilise pas ce code en production, mais la 2√®me localisation √† l'int√©rieur de mon bundle ne me d√©range pas.  Mais si vous avez de nombreuses localisations, vous voulez les charger dynamiquement et pas de mani√®re tr√®s s√©curis√©e, gardez √† l'esprit: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  La derni√®re fois que j'ai test√© cette m√©thode dans Angular 4. Il est fort probable qu'elle fonctionne maintenant. </p><br><p>  Malheureusement, un tel hack de vie sale ne fonctionnera pas dans le cas de c momentJs (uniquement la localisation angulaire).  Au moins, je n'ai pas trouv√© de moyen de le faire, mais si vous √™tes un programmeur de hackers tr√®s barbu, je serai heureux de voir la solution dans les commentaires. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Mise en cache.  Comme pour la cr√©ation d'un bundle .js, vous pouvez ajouter un hachage au nom du bundle .json. </h6><br><p>  Tout d√©pend de la fa√ßon dont vous collectez exactement tous les fichiers json dans un seul fichier, peut-√™tre que vous avez tout dans un seul fichier.  Sur Internet, vous pouvez trouver un certain nombre de modules npm qui peuvent collecter de petits fichiers json dans un seul fichier.  Je n'ai pas trouv√© ceux qui peuvent s'attacher √† un hachage et rassembler tout dans un seul fichier.  Webpack lui-m√™me ne peut pas non plus g√©rer json comme requis par les sp√©cificit√©s de ngx-translate.  Par cons√©quent, nous allons √©crire notre plugin webpack. </p><br><p>  En bref: nous devons collecter tous les fichiers json du projet selon un mod√®le sp√©cifique, tandis que nous devons les regrouper par nom (en, ru, de, etc.) car, par exemple, en.json peut se trouver dans diff√©rents dossiers.  Ensuite, pour chaque fichier collect√©, vous devez joindre un hachage. </p><br><p>  Il y a un probl√®me ici.  Comment <code>AppTranslateLoader</code> reconna√Æt-il les noms de fichiers si chaque localisation a son propre nom?  Par exemple, en incluant le bundle dans index.html, nous pouvons inclure le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HtmlWebpackPlugin</a> et lui demander d'ajouter lui-m√™me une balise de script avec le nom du bundle. </p><br><p>  Pour r√©soudre ce probl√®me pour les localisations .json, notre plugin webpack cr√©era config.json, qui contiendra l'association du code de langue avec le nom du fichier de hachage: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  config.json sera √©galement mis en cache par le navigateur, mais cela prendra un peu de temps et nous pouvons simplement sp√©cifier un param√®tre queryString al√©atoire lorsque GET envahit ce fichier (donc le charge constamment √† nouveau).  Ou attribuez un ID al√©atoire √† config.json (je d√©crirai cette m√©thode, la premi√®re peut √™tre trouv√©e dans Google). </p><br><p>  Je veux √©galement simplifier un peu l'infrastructure et l'atomicit√© des localisations.  json avec localisation se trouvera dans le dossier avec son composant.  Et afin d'√©viter les cl√©s en double, la structure du bundle json sera construite en fonction du chemin d'acc√®s √† un fichier json sp√©cifique.  Par exemple, nous avons deux en.json, l'un se trouve sur le chemin <code>src/app/article-component</code> , et l'autre <code>src/app/comment-component</code> .  Je veux obtenir le json suivant dans la sortie: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Nous pouvons supprimer la partie du chemin dont nous n'avons pas besoin, afin que les cl√©s soient aussi courtes que possible dans les vues. </p><br><p>  !!!  Il y a un inconv√©nient: lorsque vous placez le composant dans un autre dossier, la cl√© de localisation change. </p><br><p>  Plus tard, nous envisagerons un autre hack de vie qui nous permettra d'indiquer dans le composant uniquement le dernier champ cl√©, ind√©pendamment de l'endroit et de la profondeur de notre projet dans le projet, et en cons√©quence, nous pouvons le transf√©rer comme vous le souhaitez et le renommer comme vous le souhaitez. </p><br><p>  Fondamentalement, je veux r√©aliser l'encapsulation et m√™me un soup√ßon de polymorphisme des localisations ngx-translate.  J'aime le concept d'encapsuler des vues dans Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angular View Encapsulation</a> , ou plut√¥t le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadow DOM</a> .  Oui, cela augmente la taille de l'application dans son ensemble, mais je dirai √† l'avance qu'apr√®s que ngx-translate est devenu plus encapsul√©, travailler avec des fichiers de localisation est devenu beaucoup plus agr√©able.  Les composants ont commenc√© √† se soucier uniquement de leurs localisations, en outre, il sera possible de red√©finir les localisations dans le composant enfant en fonction des localisations dans le composant parent.  De plus, vous pouvez d√©sormais transf√©rer des composants d'un projet √† l'autre et ils seront d√©j√† localis√©s.  Mais comme ailleurs, il y a des nuances, plus √† ce sujet plus tard. </p><br><p>  Passons donc √† notre plugin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que c'est et comment</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fusionner le plugin de localisation</a> . <br>  Le code source du chargeur et du plugin se trouve sur le lien exemple au bas de l'article (dossier ./build-utils). </p><br><p>  Le plugin fait tout ce qui est √©crit ci-dessus et accepte les options suivantes: </p><br><ul><li>  omettre.  noms dans le chemin de localisation qui doivent √™tre ignor√©s (c'est exactement le moment o√π je veux supprimer les parties suppl√©mentaires du chemin d'acc√®s au fichier) </li><li>  fileInput.  r√©gulier pour r√©cup√©rer les fichiers de localisation dans prodge (comme test dans le webpack) </li><li>  rootDir.  o√π commencer la recherche de fichiers par le mod√®le fileInput </li><li>  outputDir.  o√π le fichier de configuration et les localisations seront cr√©√©s dans le dossier dist </li><li>  configName.  sous quel nom le fichier de configuration sera-t-il cr√©√©. </li></ul><br><p>  Dans mon projet, le plugin est connect√© de cette fa√ßon: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  √Ä l'int√©rieur des composants qui ont besoin de localisation, il y a un dossier <code>@translations</code> , il contient en.json, ru, etc. </p><br><p>  Par cons√©quent, lors du retournement, tout sera collect√© dans un fichier, en tenant compte du chemin d'acc√®s au dossier <code>@translations</code> .  Le bundle de localisation sera dans dist / langs /, et la configuration sera nomm√©e config. $ {Some-random} .json. </p><br><p>  Ensuite, nous nous assurerons que le bundle de localisation souhait√© est charg√© dans l'application.  Il y a un point fragile - seul le webpack conna√Æt le chemin d'acc√®s aux localisations et le nom du fichier de configuration, prenons cela en compte pour que les derni√®res donn√©es arrivent dans AppTranslateLoader et il n'est pas n√©cessaire de changer les noms √† deux endroits. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> ne fonctionnera tout simplement pas, nous devons d√©clarer un autre plugin dans webpack (DefinePlugin ou EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Maintenant, nous pouvons changer le chemin d'acc√®s aux localisations et le nom de la configuration en un seul endroit. <br>  Par d√©faut, √† partir de la vente angulaire par d√©faut g√©n√©r√©e dans l'assembly du webpack ( <code>ng eject</code> ), vous ne pouvez pas sp√©cifier <code>process.env.someValue</code> partir du code (m√™me si vous utilisez DefinePlugin), le compilateur peut jurer.  Pour que cela fonctionne, vous devez remplir les conditions 2a: </p><br><ul><li>  dans main.ts ajoutez la 1√®re ligne <code>/// &lt;reference types="node"/&gt;</code> </li><li>  package.json doit avoir <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Nous passons directement au processus de d√©marrage. <br>  Si vous avez l'intention d'utiliser APP_INITIALIZER, assurez-vous de renvoyer Promise, not Observable.  Notre t√¢che consiste √† √©crire une cha√Æne de requ√™te: </p><br><ul><li>  Vous devez d'abord t√©l√©charger config.json (uniquement s'il n'est pas charg√©). </li><li>  essayez de charger la langue, qui est la langue du navigateur de l'utilisateur </li><li>  Fournissez une logique de secours avec la langue de t√©l√©chargement par d√©faut. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  C'est fait. </p><br><p>  Revenons maintenant au probl√®me du d√©placement des composants vers d'autres dossiers, de l'encapsulation et de la ressemblance du polymorphisme. </p><br><p>  En fait, nous avons d√©j√† une sorte d'encapsulation.  Les localisations sont pouss√©es dans des dossiers √† c√¥t√© des composants, tous les chemins de cl√© sont uniques, mais nous pouvons toujours localiser les cl√©s du composant some-component1 √† l'int√©rieur de some-component2 et il sera difficile de garder une trace de tout, nous le d√©couvrirons plus tard. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  Concernant le mouvement des composants: <br>  Maintenant, la cl√© que nous utiliserons dans la vue est li√©e de mani√®re rigide au chemin relatif vers le fichier de localisation et d√©pend de l'infrastructure sp√©cifique du projet. </p><br><p>  Je vais donner un cas assez triste de cette situation: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Mais que se passe-t-il si je change le nom du dossier de composants en post-composant? <br>  Il sera assez difficile de saisir cette cl√© √† tous les endroits n√©cessaires.  Bien s√ªr, personne n'a annul√© le copier-coller et la recherche-remplacement, mais √©crire cela sans les invites de l'IDE est √©galement stressant. </p><br><p>  Pour r√©soudre ces probl√®mes, pr√™tons attention √† ce que le webpack fait √† ce sujet?  Webpack a une telle chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeur</a> , il existe de nombreux chargeurs disponibles qui fonctionnent sur les chemins de fichiers: par exemple, les chemins de ressources dans css - gr√¢ce √† webpack, nous pouvons sp√©cifier les chemins relatifs de l'image d'arri√®re-plan: url (../ relative.png), etc. le reste des chemins de fichiers dans le projet sont partout! </p><br><p>  Celui qui a construit son webpack sait que le chargeur re√ßoit √† l'entr√©e un fichier qui correspond √† un certain mod√®le.  La t√¢che du chargeur lui-m√™me est de transformer en quelque sorte ce fichier d'entr√©e et de le renvoyer, pour d'autres modifications par d'autres chargeurs. </p><br><p>  Par cons√©quent, nous devons √©crire notre chargeur.  La question est de savoir quel type de fichiers allons-nous changer: vues ou composants?  D'un c√¥t√©, les vues peuvent √™tre directement dans le composant et s√©par√©ment.  Les vues peuvent √™tre suffisamment grandes et difficiles √† analyser, imaginez si nous avons une vue o√π 100 directives de traduction (pas dans une boucle): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  gr√¢ce au chargeur, nous pouvons remplacer le chemin d'acc√®s cl√© aux localisations de composants √† proximit√© de chaque tuyau ou directive. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  nous pouvons ajouter un champ √† un composant qui fournit la localisation: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  C'est aussi mauvais - vous devez composer une cl√© de localisation partout. </p><br><p>  √âtant donn√© que les options les plus √©videntes semblent mauvaises, essayez d'utiliser un d√©corateur et enregistrez des m√©tadonn√©es dans le prototype du composant (comme le fait Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="image"></p><br><p>  <strong>annotations</strong> - m√©tadonn√©es pour les d√©corateurs angulaires <br>  __app_annotations__ - m√©tadonn√©es que nous allons stocker pour nous-m√™mes </p><br><p>  Le chemin d'acc√®s au dossier de localisation relatif au composant peut √™tre √©crit dans le d√©corateur, le m√™me d√©corateur peut √™tre d√©velopp√© avec d'autres options √† l'exception du chemin d'acc√®s. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    ‚Äî Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="image"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413787/">https://habr.com/ru/post/fr413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413775/index.html">Attaques contradictoires contre Machines Can See 2018</a></li>
<li><a href="../fr413777/index.html">Lecture du week-end: mat√©riel d'introduction √† l'IaaS, s√©curit√© de l'information et √©v√©nements li√©s √† la r√©glementation informatique</a></li>
<li><a href="../fr413779/index.html">Minuteries et multit√¢che sur Arduino</a></li>
<li><a href="../fr413781/index.html">Comment les Bloodhounds publicitaires suivent votre trace sur Internet</a></li>
<li><a href="../fr413783/index.html">Comment meurent les √©toiles les plus massives: supernova, hypernova ou effondrement direct?</a></li>
<li><a href="../fr413789/index.html">En Floride, ils n'ont pas v√©rifi√© les acheteurs d'armes √† la base du FBI pendant un an parce qu'ils avaient oubli√© le mot de passe</a></li>
<li><a href="../fr413791/index.html">M√©canique quantique des calculs en JS</a></li>
<li><a href="../fr413793/index.html">Cassettes audio dans la culture pop: pourquoi le format d'enregistrement sonore obsol√®te est √† nouveau consid√©r√© comme √† la mode</a></li>
<li><a href="../fr413795/index.html">Pourquoi l'industrie du divertissement passe √† l'IaaS: √©tude de cas</a></li>
<li><a href="../fr413797/index.html">EA a pr√©sent√© la nouvelle partie de C&C √† l'E3. Et c'est physiquement douloureux de le regarder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>