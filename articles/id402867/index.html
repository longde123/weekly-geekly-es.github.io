<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏼 🆎 🤜 Kotak hitam perokok 🚲 🐝 🥉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak orang merokok terlalu banyak, terutama ketika mereka kecanduan sesuatu dan tidak memperhatikan bagaimana mereka merokok satu demi satu. Kotak h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotak hitam perokok</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402867/">  Banyak orang merokok terlalu banyak, terutama ketika mereka kecanduan sesuatu dan tidak memperhatikan bagaimana mereka merokok satu demi satu.  Kotak hitam perokok (CJK) tidak memungkinkan Anda untuk mengambil rokok berikutnya sampai periode waktu tertentu berlalu.  Pada artikel ini, saya akan memperhatikan beberapa detail yang mungkin berguna untuk perkembangan lainnya, terutama pengendali Teensy LC yang tidak begitu terkenal (keluarga Arduino). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mRDSiEAsiAI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <b>Mekaniknya</b> <br><br>  Rincian ChYAK dicetak pada printer 3D dan setelah perakitan bagian bawah, tengah dan atas direkatkan bersama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/353/eb5/369/353eb5369a304723be064ac6e07722e9.jpg"></div><br><br>  Mekanisme penguncian dibuat elektromekanis, sementara fungsi penguncian dasar diwujudkan sepenuhnya secara mekanis, ini membuatnya sulit untuk memecahkan NJC dengan memanipulasi celah dan mengeluarkan baterai. <br><br>  Sistem penguncian terdiri dari rak dengan gigi dan ratchet bistable, yang memungkinkan baki bergerak hanya dalam arah penutupan.  Setelah mencapai periode waktu yang telah ditentukan, servo membuat satu gerakan bolak-balik dan mendorong ratchet, yang diatur dalam keadaan stabil kedua "terbuka".  CFC tetap terbuka sampai pengguna menarik keluar baki secara mekanis.  Saat diperpanjang, baki mendorong ratchet dan memasukkannya ke dalam cocked state lagi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a0b/9a1/c0e/a0b9a1c0eaf74795b582073f40f55b93.jpg"></div><br><br>  Loader dibuat dalam bentuk drum dengan 4 ceruk untuk rokok.  Untuk menghindari upaya mendapatkan rokok melalui loader, mekanisme ratchet tidak memungkinkan gerakan ke arah yang berlawanan, dari sisi di mana bumper dibuat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/69b/1af/cb9/69b1afcb91214e94a40b24be99f6895e.jpg"></div><br><br>  Slot dibuat pada tutup atas, memungkinkan Anda untuk menghilangkan kemungkinan distorsi rokok di dalam kotak dan menghilangkan keripik tembakau. <br><br>  <b>Antarmuka</b> <br><br>  Untuk mengontrol waktu, jumlah rokok di CHYAK, dan jumlah rokok yang dihilangkan, tampilan OLED dipantau.  Ini dimatikan hampir setiap waktu agar tidak mengisi baterai dan dihidupkan hanya oleh sinyal dari sensor kapasitif pusat, yang dipicu ketika tangan dibawa ke CHYAK atau sinyal dari tombol saat memuat rokok.  Tombol lain menangkap saat baki ditutup dan memulai siklus penundaan berikutnya.  Dua sensor kapasitif tambahan terletak di dinding belakang dan digunakan untuk mengatur penghitung rokok (perlu, misalnya, saat mengganti baterai). <br><br>  <b>Elektronik</b> <br><br>  Mikrokontroler adalah Teensy LC.  Perangkat seperti arduin ini, kompatibel dengan sebagian besar perpustakaan Arduino, dipilih karena memiliki dukungan untuk sensor kapasitif (touch sense interface (TSI)).  Sensornya sangat sensitif sehingga mereka dengan mudah merasakan tangan terangkat pada jarak satu sentimeter.  Teensy LC memiliki apa yang disebut mode LLWU, dalam mode ini semua modul dalam mode tidur, dengan pengecualian osilator 1-kHz.  Anda dapat keluar dari mode tidur ini dalam 4 cara: a) mendapatkan interupsi dari sensor kapasitif, b) mendapatkan interupsi dari pin, c) mendapatkan limpahan penghitung 1-kHz (timer daya rendah, LPTMR), d) mendapatkan interupsi dari alarm. <br><br>  Di sini penulis dalam kesulitan: dalam rencana awal itu adalah menggunakan TSI untuk bangun ketika tangan disajikan, dan LPTMR untuk gangguan berkala untuk menyesuaikan tingkat TSI (tergantung pada kondisi lingkungan) dan kontrol waktu.  Tetapi ternyata LPTMR digunakan untuk fungsi TSI, dan karenanya, tidak dapat digunakan sebagai penghitung waktu.  (LPTMR overflow interrupt adalah pemicu perangkat keras untuk TSI, dan, tentu saja, harus cepat untuk memonitor sensor. Biasanya penghitung ini diatur ke minus satu sehingga TSI disurvei dengan frekuensi 1 kHz yang dimungkinkan). <br><br>  Kemungkinan lain adalah dengan menggunakan interupsi alarm RTC, tetapi kenyataannya adalah bahwa Tenncy LC tidak memiliki jam waktu nyata (RTC).  Sebaliknya, RTC ada di prosesor itu sendiri, tetapi tidak ada kabel untuk RTC kuarsa di papan tulis.  Namun, pengembang prosesor telah meninggalkan beberapa celah untuk bertanya.  Osilator 1kHz (yang beroperasi dalam mode tidur) dapat digunakan sebagai sumber untuk register RTC pada pengontrol.  Kemudian ternyata RTC dapat menghitung bukan interval kedua (seperti ketika menggunakan kuarsa pada 32 kHz), tetapi 32 detik jika menggunakan osilator 1 kHz.  Akurasi ini, tentu saja, tidak cukup.  Tapi ada jalan keluar. <br><br>  Begini cara kerjanya: <br><br>  Ada Daftar Penentu Waktu RTC (RTC_TPR).  Register 16-bit ini menghitung pulsa osilator.  Ketika meluap, Daftar Detik Waktu RTC (RTC_TSR) bertambah satu.  Dalam mode klasik, ini adalah detik, yang dibandingkan dengan Register Alarm Waktu RTC (RTC_TAR), dan ketika cocok, interupsi alarm dihasilkan.  Saat menggunakan kuarsa 32kHz biasa, RTC_TSR tidak dipasang sebelumnya, tetapi dihitung dari nol setiap kali (32768 meluap (detik)).  Tetapi jika kita melakukan pra-instal RTC_TSR setiap kali, dengan mempertimbangkan bahwa kita memiliki osilator 1kHz yang lambat, kita bisa mendapatkan alarm interupsi hingga akurasi milidetik (tidak memperhitungkan ketidakakuratan osilator itu sendiri).  Tentu saja, RTC_TAR juga harus dihitung ulang sesuai dengan itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/719/cc7/057/719cc7057df74632be110832ac93d99b.png"></div><br><br>  Misalnya, jika kita ingin mengatur periode menjadi 87 detik, kita harus menulis 2 di RTC_TSR (2 * 32768 = 65536ms = 65.536d), 2 dalam RTC_TAR dan 32768- (87 * 1000-65536) = 11304 di RTC_TSR.  Kemudian 32.768-11.304 = 21.464 detik akan berlalu sebelum RTC_TPR pertama meluap, dan dua siklus penuh 2 * 32.768 = 65.536 akan ditambahkan ke mereka, yang akan menjadi hanya 21.464 + 65.536 = 87 detik <br>  Secara umum, seperti ini: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAlarm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seconds )</span></span></span><span class="hljs-function"> </span></span>{ RTC_SR = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//disable RTC RTC_TPR=32768-(seconds*1000%32768); RTC_TSR=0; //RTC counter RTC_SR = RTC_SR_TCE; //enable RTC RTC_TAR = seconds*1000/32768; }</span></span></code> </pre> <br>  Dan bahkan kita dapat memonitor total waktu (hingga kesalahan 1kHz dari osilator), misalnya, jika pada awal program semua register RTC nol: <br><br><pre> <code class="hljs lisp">timeEllapsed=(<span class="hljs-name"><span class="hljs-name">RTC_TSR*32768+RTC_TPR</span></span>)/1000</code> </pre> <br>  Keakuratan osilator 1kHz kecil, tetapi untuk keperluan kami itu sudah cukup.  Perlu dicatat bahwa ketika memulai alarm baru, kami memodifikasi register RTC, jadi jika Anda perlu memonitor waktu, mereka harus diingat sebelum alarm dimulai, dan setelah keluar dari alarm, mereka dihitung ulang dengan memperhitungkan waktu yang dihabiskan untuk hibernasi.  Saya telah menjelaskannya secara rinci di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang RTC untuk Teency LC</a> <br><br>  Dalam CJC, interupsi setiap 10 menit mengukur dan menyimpan level sinyal dari sensor kapasitif jika tidak ada tangan.  Hal ini dilakukan untuk dapat melacak perubahan pada sinyal saat mereka mendekati.  Dengan latar belakang pada ~ 500 unit, kami menggunakan tingkat kelebihan ~ 20 unit, ini memungkinkan untuk merasakan tangan pada jarak 5-10mm.  Tingkat latar belakang tergantung pada suhu dan kelembaban, jadi untuk keandalannya harus disesuaikan secara berkala.  Saya percaya ini adalah kelemahan pengembang prosesor.  Mengapa mereka tidak diberi kesempatan untuk bangun dari TSI dan penghitung daya rendah lainnya secara bersamaan (cukup tambahkan satu register lagi), karena penyesuaian berkala level TSI hampir wajib, bahkan jika Anda tidak memerlukan timer untuk keperluan lain! <br><br>  Sekarang tentang energi yang dikonsumsi.  Dalam mode tidur LLWU, Teensy LC mengkonsumsi sekitar 15 uA ketika tidak ada body kit.  Kami harus menghubungkan layar OLED lain dan servo.  Kedua perangkat ini memiliki arus bocor besar bahkan dalam keadaan pasif. <br><br>  Semuanya sederhana dengan OLED, ini Adafruit 0.96 ”Monochrome 128x64 OLED display, didukung oleh 3.3V, mengkonsumsi arus sekitar 20 mA saat dihidupkan (tergantung pada jumlah piksel yang terlibat) dan dikendalikan oleh SPI.  Artinya, cukup sambungkan input daya ke output 20 miliampere dari Teensy LC (Teency memiliki berbagai jenis output) dan Anda selesai.  Ketika semua orang tidur, output ini hanya ditransfer ke keadaan ke-3 dan saat ini tidak melalui tampilan, dengan bangun output ditransfer ke output keadaan tinggi dan menjadi Vcc untuk tampilan. <br><br>  Servo sedikit lebih rumit.  Servo dalam mode siaga mengkonsumsi arus sekitar 2 mA, yang tentu saja tidak dapat diterima.  Karena itu, Anda harus mematikannya sepenuhnya saat tidur.  Berbeda dengan Arduin klasik, Teensy LC memiliki pilihan pasokan daya yang cukup kecil: baik 1,7-3,3 V terhubung langsung, atau 2,6-5,5 V (dengan regulator tegangan internal dihidupkan).  Biasanya servos yang dapat diakses bekerja dari setidaknya 1S Lipo, dan ini adalah 3,3-4,2 V. Oleh karena itu, kita perlu menyalakan tiga baterai standar secara seri untuk memiliki dari 3,3 (debit) menjadi 4,6 V (baru).  Untuk sebagian besar servo, 3,3 V berada pada batas operasi, sehingga secara langsung keluaran Teensy tidak dapat digunakan (seperti untuk OLED).  Ya, dan arus selama rotasi adalah sekitar 50 mA, yang sedikit banyak untuk Teensy LC.  Oleh karena itu, servo dihidupkan melalui MOSFET: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d87/121/7a3/d871217a39f04ecfb537dff032ac7fb1.png"></div><br><br>  Dengan pengaktifan ini, sepertinya itu tidak aman, karena ketika MOSFET dimatikan, tegangan pada input ctrl PWM melebihi 3,3 V, dan input Tennsy LC tidak toleran 5V (tidak seperti Arduin klasik).  Tetapi Anda tidak perlu takut dengan hal ini, mengingat bahwa ctrl PWM saat ini sangat kecil, dan tidak perlu takut akan dioda pembatas pada input prosesor (alasan ketidakmungkinan melebihi Vcc + 0,5 ada dalam dioda ini), apalagi, pada arus yang sebanding dengan arus dioda tertutup. dia bahkan tidak akan dalam keadaan terbuka. <br><br>  di CHYAK saya menggunakan HK282 dengan ambang 3.3V (hanya karena saya memilikinya).  Beberapa jenis servo tegangan rendah dan daya rendah dapat diaktifkan langsung dari output Teensy, sesuai dengan skema yang digunakan untuk OLED. <br><br>  Akibatnya, arus dalam mode tidur ternyata sekitar 50 uA, mungkin mungkin untuk mengurangi lebih banyak lagi, tetapi saya memutuskan bahwa ini sudah cukup (jika hanya tidur, baterainya akan bertahan lebih dari 4 tahun: 2000mAh / 0,05mA). <br><br>  <b>Teknis</b> <br><br>  Dicetak pada printer 3D Monoprice Ultimate, plastik PLA, nozzle 0,4 mm, 0,2 mm.  Untuk detail mekanisme penguncian, lapisan 0,1 mm untuk akurasi.  Pegas juga dicetak pada printer 3D.  Mengetik untuk waktu yang lama.  Sebagai contoh, bagian paling tengah (memiliki banyak bagian internal dan dinding ganda untuk elektronik dan kabel) dicetak selama 20 jam.  Itu terjebak bersama-sama dengan lem cyan-akrilat.  Jika ada sesuatu yang pecah di dalam, tidak mungkin untuk melihat (perlindungan dari perokok maniak), Anda harus memecahkannya seperti celengan dan mencetak lagi (argumen yang mendukung printer 3D).  Gambar dan animasi dibuat di SolidWorks, lingkungan pengembangan AtmelStudio (ya, AVR (teency) didukung langsung di luar kotak, seperti Arduino, melalui VisualMicro). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id402867/">https://habr.com/ru/post/id402867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id402853/index.html">Gelombang ketiga solusi blockchain menghadirkan teknologi CATs</a></li>
<li><a href="../id402859/index.html">Laptop dalam pelayanan polisi</a></li>
<li><a href="../id402861/index.html">First Time: untuk pemutaran perdana film</a></li>
<li><a href="../id402863/index.html">Model kontrak yang jujur ​​sebagai mekanisme pengaturan diri PR</a></li>
<li><a href="../id402865/index.html">Dua penerbangan satu tahap Falcon 9 dalam satu video</a></li>
<li><a href="../id402869/index.html">Pelacak trendi yang tidak modis: Samsung, Polar, Withings, yang tidak diharapkan</a></li>
<li><a href="../id402871/index.html">Cara membuka bank di Eropa: lisensi dan blockchain</a></li>
<li><a href="../id402873/index.html">Buku "Jangan mati! Makanan dalam perjuangan untuk hidup "</a></li>
<li><a href="../id402875/index.html">Matriks untuk kamera CCTV. Apa yang harus diperhatikan?</a></li>
<li><a href="../id402877/index.html">Presentasi Pencetak Cokelat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>