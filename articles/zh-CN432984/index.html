<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🎥 🕍 使用Tensorflow.js库在Node.js上进行机器学习 🐹 ↙️ 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，同事们！ 

 Tensorflow库的粉丝也许已经在我们的预购中注意到了这本书 ，他们也密切关注了浏览器中机器和深度学习的可能性，特别是因为Francois Schollet本人并没有忽略这个话题。 我们邀请对猫感兴趣的人，它告诉我们如何使用Tensorflow.js库识别图像。 

 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Tensorflow.js库在Node.js上进行机器学习</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432984/"> 大家好，同事们！ <br><br>  Tensorflow库的粉丝也许已经在我们的预购中注意到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这本书</a> ，他们也密切关注了浏览器中机器和深度学习的可能性，特别是因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Francois Schollet</a>本人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并没有忽略这个</a>话题。 我们邀请对猫感兴趣的人，它告诉我们如何使用Tensorflow.js库识别图像。 <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TensorFlow.js</a>是流行的开源库的新版本，该库通过深度学习功能丰富了JavaScript。 开发人员现在可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级库API</a>定义，训练和运行模型。 <br><br> 借助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预先训练的模型，</a>开发人员现在可以仅用几行JavaScript即可轻松解决复杂的任务，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模式识别</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">音乐生成</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">确定人员位置</a> 。 <br><br>  Tensorflow.js最初是用于在浏览器中工作的前端库，但今年已添加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对</a> Node.js的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实验性支持</a> 。 因此，TensorFlow.js也可以在JavaScript后端应用程序中使用，这完全使我们免于诉诸Python。 <br><br>  <i>阅读有关此库的信息后，我决定尝试执行一个简单的任务...</i> <br><blockquote> 使用来自Node.js的JavaScript时，使用TensorFlow.js来视觉识别图像上的图像 </blockquote> 不幸的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码示例</a>主要描述了该库在浏览器中的使用，旨在简化编写时的预训练模型的加载和使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目实用程序</a>不支持Node.js。 我不得不花很多时间来很好地阅读该库的Typescript源代码。 <br><br> 但是，经过几天的苦战，我还是做到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a> ！ 万岁！ <br><br>  <i>在继续详细分析代码之前，让我们谈谈TensorFlow库的其他实现。</i> <br><br>  <b>张量流</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TensorFlow</a>是一个用于机器学习应用程序的免费软件库。  TensorFlow可用于创建神经网络并实现其他深度学习算法。 <br><br> 这是Google在2015年11月发布的库，最初<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是用Python编写的</a> 。 为了训练和评估创建的模型，它使用CPU或GPU上的计算。 最初，创建该库是为了使用资源密集型GPU在高性能服务器上工作。 <br><br> 最近的更新使优化该库并在资源更有限的环境（例如在移动设备和Web浏览器上）中使用它成为可能。 <br><br>  <b>TensorFlow Lite</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tensorflow Lite</a>是该库针对移动设备和嵌入式系统的精简版，于2017年5月发布。 与之一起，为与模式识别相关的任务提供了一组新的预先训练的深度模型。 该集合称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MobileNet</a> 。  MobileNet模型是专为在资源有限的环境（例如移动设备）中高效运行而设计的。 <br><br>  TensorFlow.js <br><br> 在Tensorflow Lite之后，TensorFlow.js于2018年3月发布。 该版本的库旨在在浏览器中运行，并且基于一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">deeplearn.js</a>的早期项目。  WebGL提供对库的GPU访问。 开发人员使用JavaScript API训练，加载和运行模型。 <br><br> 后来TensorFlow.js扩展为可与Node.js <code>tfjs-node</code>使用，为此使用了<code>tfjs-node</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库add</a> <code>tfjs-node</code> 。 <br><br>  <b>将现有模型导入TensorFlow.js</b> <br><br> 可以使用TensorFlow.js库执行现成的TensorFlow和Keras模型。 在执行模型之前，必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此工具</a>将其转换为新格式。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github上提供了</a>用于图像分类，定义姿势和检测k最近邻的预训练和转换模型。 <br><br>  <b>将TensorFlow.js与Node.js结合使用</b> <br><br> 安装TensorFlow库 <br><br>  TensorFlow.js可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NPM注册表中</a>安装。 <br><br><ul><li>  <code>@tensorflow/tfjs</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">核心TensorFlow.js</a>库 </li><li>  <code>@tensorflow/tfjs-node</code>扩展<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TensorFlow.js Node.js</a> </li><li>  <code>@tensorflow/tfjs-node-gpu</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">具有GPU计算支持的TensorFlow.js Node.js</a>扩展 </li></ul><br><pre> <code class="plaintext hljs">npm install @tensorflow/tfjs @tensorflow/tfjs-node // ... npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</code> </pre> <br>  Node.js的两个扩展都使用本机依赖项，​​这些依赖项将根据需要进行编译。 <br><br>  <b>下载TensorFlow库</b> <br><br>  Tensorflow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的JavaScript API</a>是从核心库提供的。 支持Node.js的扩展模块中没有提供扩展API。 <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ( CPU) require('@tensorflow/tfjs-node') //    ( GPU) require('@tensorflow/tfjs-node-gpu')</span></span></code> </pre> <br>  <b>下载TensorFlow模型</b> <br><br>  TensorFlow.js提供了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NPM库</a> （ <code>tfjs-models</code> ），该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a>可简化加载预训练和转换后的模型的过程，以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对图像</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分类</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定义姿势</a>并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检测k个最近的邻居</a> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MobileNet</a>的图像分类<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模型</a>是一个经过深度训练的神经网络，可以区分<a href="">1000种不同类别的图像</a> 。 <br><br> 在项目的README文件中，以下代码用作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ，用于加载模型。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mobilenet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   const model = await mobilenet.load();</span></span></code> </pre> <br> 我碰到的第一个问题是该代码不适用于Node.js。 <br><br><pre> <code class="plaintext hljs">Error: browserHTTPRequest is not supported outside the web browser.</code> </pre> <br> 在检查了<a href="">源代码之后</a> ，我们看到mobilenet库是<code>tf.Model</code>类的包装器。 调用时， <code>load()</code>方法自动下载位于外部HTTP地址的必要模型文件，并实例化TensorFlow模型。 <br><br> 在撰写本文时，Node.js扩展尚不支持用于动态模型检索的HTTP请求。 剩下的就是手动将模型加载到文件系统中。 <br><br>  <i>但是，阅读了库的源代码后，我发现了一种解决方法...</i> <br><br>  <b>从文件系统下载模型</b> <br><br> 如果MobileNet类是手动创建的，则无法调用模块的<code>load</code>方法，而是重写包含模型的HTTP地址的自动生成的变量<code>path</code> ，并用文件系统中的本地路径替换该地址。 之后，在类实例中调用<code>load</code>方法时，将触发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件系统加载器</a>类； 在这种情况下，我们拒绝使用基于浏览器的HTTP下载器。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-string"><span class="hljs-string">"mobilenet/model.json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load()</code> </pre> <br> 太好了，一切正常！ <br><br> 但是模型文件从哪里来？ <br><br>  <b>MobileNet模型</b> <br><br>  TensorFlow.js的模型包含两种类型的文件：以JSON格式存储的模型配置文件和以二进制格式存储的模型权重。 模型权重通常分为许多部分，以优化浏览器缓存。 <br><br> 考虑了MobileNet模型的<a href="">自动下载代码后</a> ，我们看到这些模型，它们的配置和权重片段是从以下地址的公共容器中提取的。 <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</code> </pre> <br>  URL中的模板参数描述了<a href="">此处</a>列出的模型版本。 最终的分类精度也显示在同一页面上。 <br><br> 源代码表明，只能使用<code>tensorflow-models/mobilenet</code>下载MobileNet v1 <code>tensorflow-models/mobilenet</code> 。 <br><br>  HTTP提取代码从存储位置下载<code>model.json</code>文件，然后以引用的权重递归选择模型的所有片段。 这些是格式为<code>groupX-shard1of1</code> 。 <br><br>  <b>手动下载模型</b> <br><br> 如果要将所有模型文件保存在文件系统中，可以执行以下操作：提取模型配置文件，解析配置文件中引用的所有加权文件的语法，然后手动下载每个加权文件。 <br>  <b>我打算使用具有1.0的alpha值和224像素的图像的MobileNet V1模块</b> 。 因此，我获得了模型配置文件的<a href="">以下URL</a> 。 <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</code> </pre> <br> 在本地下载此文件后，您可以使用<code>jq</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具</a>解析所有加权文件的名称。 <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> group1-shard1of1 group2-shard1of1 group3-shard1of1 ...</code> </pre> <br> 使用<code>sed</code>工具，可以为每个HTTP元素的名称加上URL前缀，以为每个重量文件生成URL。 <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//'</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1 ...</span></span></code> </pre><br> 然后使用<code>parallel</code>和<code>curl</code>命令将所有这些文件下载到我的本地目录中。 <br><br><pre> <code class="plaintext hljs">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</code> </pre> <br>  <b>图片分类</b> <br><br>  TensorFlow.js随附的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此示例代码</a>演示了如何返回图像分类的结果。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> img = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'img'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   const predictions = await model.classify(img);</span></span></code> </pre> <br> 由于缺乏DOM支持，因此在Node.js中不起作用。 <br><br>  <code>classify</code> <a href="">方法</a>接受各种DOM元素（ <code>canvas</code> ， <code>video</code> ， <code>image</code> ），并自动从这些元素中提取“图片”字节并将其转换为<code>tf.Tensor3D</code>类，用作模型输入。 或者，可以直接传输<code>tf.Tensor3D</code> 。 <br><br>  <b>我决定不尝试使用外部软件包手动模拟DOM元素，但发现<code>tf.Tensor3D</code>易于手动组装</b> 。 <br><br>  <b>我们从图像生成Tensor3D</b> <br><br> 阅读用于将DOM元素转换为Tensor3D类<a href="">的</a>方法的<a href="">源代码</a> ，我们发现以下输入参数用于生成Tensor3D类。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(image.height * image.width * numChannels); <span class="hljs-comment"><span class="hljs-comment">//     ,    const outShape = [image.height, image.width, numChannels]; const input = tf.tensor3d(values, outShape, 'int32');</span></span></code> </pre> <br>  <code>pixels</code>是类型为<code>(Int32Array)</code>的二维数组，其中包含每个像素的通道值的顺序列表。  <code>numChannels</code>是每个像素的通道值数量。 <br><br>  <b>为JPEG创建输入值</b> <br><br>  <code>jpeg-js</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a>是使用纯JavaScript编写的Node.js的JPEG编码器/解码器。 使用此库，您可以提取每个像素的RGB值。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buffer, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br> 结果，我们得到一个Uint8Array，每个像素（ <code>width * height</code> ）具有四个通道值（ <code>RGBA</code> ）。  MobileNet模型仅使用三个颜色通道（ <code>RGB</code> ）进行分类，而忽略Alpha通道。 此代码将四通道数组转换为真正的三通道版本。 <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numChannels = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } }</code> </pre> <br>  <b>MobileNet模型的输入要求</b> <br><br> 这里使用的<a href="">MobileNet模型</a>将图像分为高和宽224个像素。 对于每个像素的三个通道值，输入张量必须包含介于-1到1范围内的浮点值。 <br><br> 分类前，必须将具有不同尺寸的图像的输入值转换为正确的尺寸。 另外，从JPEG解码器获得的像素值在0-255的范围内，而不是-1-1。在分类之前还需要转换这些值。 <br><br>  TensorFlow.js具有简化该过程的库方法，但更好的是，有一个<b>特殊的<code>tfjs-models/mobilenet</code>可以<a href="">自动解决此问题</a> ！</b> <br><br> 开发人员可以将类型为<code>int32</code>输入Tensor3D以及各种尺寸传递给<code>classify</code>方法，该方法将输入值转换为分类之前的正确格式。 也就是说，我们在这里无事可做。 太好了！ <br><br>  <b>获得预测</b> <br><br>  Tensorflow的MobileNet模型学习从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageNet</a>数据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集中</a>的<a href="">1000个最重要的类中</a>识别对象。 在模型的输出处，给出概率值，这些值表征在分类图像中找到这些对象的机会。 <br><br>  <i><a href="">此文件中包含</a>使用的模型的训练有素类的完整列表</i> 。 <br><br>  <code>tfjs-models/mobilenet</code>在<code>MobileNet</code>类中提供了<code>classify</code>方法，该方法根据图片所示返回最有可能的类的前X个。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  <code>predictions</code>是X类别和概率的数组，格式如下。 <br><br><pre> <code class="javascript hljs"> { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'panda'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> }</code> </pre> <br>  <b>例子</b> <br><br> 因此，我们已经弄清楚了如何在Node.js中使用TensorFlow.js库和MobileNet模型，现在让我们看看该脚本如何将指定为命令行参数的图像分类。 <br><br>  <i>源代码</i> <br><br> 将此脚本文件和程序包描述符保存在本地文件中。 <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"tf-js"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"script.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@tensorflow-models/mobilenet"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.2.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.12.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs-node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.1.9"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpeg-js"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.3.4"</span></span> } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobilenet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs-node'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jpeg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jpeg-js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NUMBER_OF_CHANNELS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readImage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = fs.readFileSync(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixels } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageByteArray = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = image.data <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageToInput = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = imageByteArray(image, numChannels) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outShape = [image.height, image.width, numChannels]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = tf.tensor3d(values, outShape, <span class="hljs-string"><span class="hljs-string">'int32'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadModel = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> path =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mn } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classify = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (model, path) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = readImage(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = imageToInput(image, NUMBER_OF_CHANNELS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn_model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loadModel(model) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'classification results:'</span></span>, predictions) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.argv.length !== <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'incorrect arguments: node script.js &lt;MODEL&gt; &lt;IMAGE_FILE&gt;'</span></span>) classify(process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre> <br>  <b>测试中</b> <br><br> 按照上述说明将模型文件下载到mobilenet目录。 <br> 使用NPM设置项目依赖项 <br><br> <code>npm install</code> <br> <br> 下载样本JPEG文件进行分类 <br><br> <code>wget http://bit.ly/2JYSal9 -O panda.jpg</code> <br> <br><img src="https://habrastorage.org/webt/vt/sm/-2/vtsm-2o5y-t3vhqx5-qaomhxnfw.jpeg"><br><br> 运行脚本，其参数将是模型文件和输入图像。 <br><br> <code>node script.js mobilenet/model.json panda.jpg</code> <br> <br> 如果一切正常，则以下输出应出现在控制台中。 <br><br><pre> <code class="javascript hljs"> classification results: [ { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'giant panda, panda, panda bear, coon bear'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> } ]</code> </pre> <br> 图片正确分类为包含熊猫的可能性为99.93％！ <br><br>  <b>结论</b> <br><br>  TensorFlow.js库为JavaScript开发人员提供了深度学习的机会。 通过将经过预训练的模型与TensorFlow.js库一起使用，您可以轻松地在JavaScript应用程序中构建新功能，从而以最少的精力和简洁的代码解决复杂的机器学习问题。 <br><br>  TensorFlow.js库的创建纯粹是为了在浏览器中工作，但现在它可以与Node.js交互，尽管并非所有工具和实用程序都支持此新运行时。 对该库进行了几天的修改后，我学会了将其与MobileNet模型一起使用，以可视方式识别本地文件中的图像。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432984/">https://habr.com/ru/post/zh-CN432984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432972/index.html">资料来源：“康韦定律”</a></li>
<li><a href="../zh-CN432976/index.html">匿名圣诞老人2018-2019：吹嘘新年礼物</a></li>
<li><a href="../zh-CN432978/index.html">约翰·罗梅罗（John Romero）：《毁灭战士》倒影</a></li>
<li><a href="../zh-CN432980/index.html">最小的VMware NSX。 第一部分</a></li>
<li><a href="../zh-CN432982/index.html">编译器创建的最简短介绍</a></li>
<li><a href="../zh-CN432986/index.html">C vs Go循环和简单数学</a></li>
<li><a href="../zh-CN432988/index.html">第八届网站管理员。 住在哈布雷</a></li>
<li><a href="../zh-CN432990/index.html">爱迪生声控木灯。 发行价$ 5</a></li>
<li><a href="../zh-CN432992/index.html">他戴上耳机死了：我们处理了林堡一个男生的奇怪死亡</a></li>
<li><a href="../zh-CN432994/index.html">Vivaldi 2.2-数量转换为质量</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>