<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✔️ 🥡 🕑 Buildroot - Parte 1. Información general, construcción de un sistema mínimo, configuración a través del menú ⚜️ ↗️ 🎊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 En esta serie de artículos quiero considerar el sistema de distribución buildroot y compartir la experiencia de personalizarlo. Aquí ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildroot - Parte 1. Información general, construcción de un sistema mínimo, configuración a través del menú</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448638/"><h2 id="vvedenie">  Introduccion </h2><br><p>  En esta serie de artículos quiero considerar el sistema de distribución buildroot y compartir la experiencia de personalizarlo.  Aquí habrá experiencia práctica en la creación de un sistema operativo pequeño con una interfaz gráfica y una funcionalidad mínima. </p><br><p>  En primer lugar, no debe confundir el sistema de compilación y la distribución.  Buildroot puede construir un sistema a partir del conjunto de paquetes que se le ofreció.  Buildroot se basa en archivos MAKE y, por lo tanto, tiene enormes capacidades de personalización.  ¿Reemplazar el paquete con otra versión, agregar su paquete, cambiar las reglas para construir el paquete, personalizar el sistema de archivos después de instalar todos los paquetes?  Buildroot puede hacer todo esto. </p><br><p>  En Rusia, se usa buildroot, pero en mi opinión hay poca información en ruso para principiantes. </p><br><p>  El objetivo del trabajo es crear un kit de distribución con descarga en vivo, interfaz icewm y navegador.  La plataforma de destino es virtualbox. </p><br><p>  ¿Por qué construir su distribución?  A menudo necesita una funcionalidad limitada con recursos limitados.  Más a menudo en automatización necesita crear firmware.  Adaptar una distribución de uso general, limpiar paquetes adicionales y convertirlo en firmware consume más tiempo que crear una nueva distribución.  Usar Gentoo también tiene sus limitaciones. </p><br><p>  El sistema Buildroot es muy poderoso, pero no hará nada por usted.  Solo puede dar oportunidades y automatizar el proceso de ensamblaje. </p><br><p>  Los sistemas de compilación alternativos (yocto, sistema de compilación abierto, etc.) no se consideran ni se comparan. </p><a name="habracut"></a><br><h2 id="gde-vzyat-i-kak-nachat">  Dónde obtener y cómo comenzar </h2><br><p>  El sitio del proyecto es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buildroot.org</a> .  Aquí puede descargar la versión actual y leer el manual.  También puede contactar a la comunidad allí, hay un rastreador de errores, listas de correo y un canal IRC. </p><br><p>  Buildroot funciona con defconfig para la placa de destino del ensamblaje.  Defconfig es un archivo de configuración que almacena solo opciones que no tienen valores predeterminados.  Es él quien determina qué y cómo se recolectará.  En este caso, puede configurar por separado las configuraciones busybox, linux-kernel, uClibc, bootloaders u-boot y barebox, pero todos estarán vinculados a la placa de destino. <br>  Después de desempaquetar el archivo descargado o la clonación de git, preparamos el buildroot para el trabajo.  Los detalles sobre la estructura del directorio se pueden encontrar en el manual, hablaré sobre lo más importante: </p><br><p>  <strong>placa</strong> : un directorio con archivos específicos de cada placa.  Estos pueden ser scripts para formar imágenes del sistema (iso, sdcart, cpio, etc.), directorio de superposición, configuración del kernel, etc. <br>  <strong>configs</strong> - en realidad defconfig placas.  Defconfig es una configuración incompleta de la placa.  Solo se almacenan parámetros distintos de la configuración predeterminada. <br>  <strong>dl</strong> - directorio con códigos fuente descargados / archivos para ensamblar <br>  <strong>salida / destino</strong> : el sistema de archivos ensamblado del sistema operativo resultante.  Posteriormente, se crean imágenes para descargar / instalar. <br>  <strong>output / host</strong> : utilidades de host para compilar <br>  <strong>salida / compilación</strong> - paquetes compilados </p><br><p>  La configuración de compilación se realiza a través de KConfig.  El mismo sistema se utiliza para construir el kernel de Linux.  Lista de los comandos más utilizados (se ejecutan en el directorio buildroot): </p><br><ul><li>  make menuconfig: llama a la configuración de compilación.  También puede usar la interfaz gráfica (make nconfig, make xconfig, make gconfig) </li><li>  make linux-menuconfig - llama a la configuración del kernel. </li><li>  hacer limpio: resultados de ensamblaje claros (todo lo que se almacena en la salida) </li><li>  make - construye el sistema.  No reconstruye procesos ya recopilados </li><li>  make defconfig_name - cambia la configuración a un defconfig específico </li><li>  make list-defconfigs - muestra una lista de defconfig </li><li>  make source: solo descarga los archivos de instalación, sin ensamblar. </li><li>  make help - enumera los comandos posibles </li></ul><br><h3 id="vazhnye-zamechaniya-i-poleznye-sovety">  Notas importantes y consejos </h3><br><p>  ¡Buildroot no reconstruye paquetes ya empaquetados!  Por lo tanto, puede surgir una situación cuando se requiere un reensamblaje completo. </p><br><p>  Puede reconstruir un solo paquete con el comando <strong>make packagename-rebuild.</strong>  Por ejemplo, puede reconstruir el kernel de Linux: </p><br><pre><code class="bash hljs">make linux-rebuild</code> </pre> <br><p>  Buildroot almacena el estado de cualquier paquete creando archivos .stamp en el directorio output / build / $ packagename: </p><br><p><img src="https://habrastorage.org/webt/us/iu/f3/usiuf3l_-ics3e8gdbnzebjszzs.png"></p><br><p>  Por lo tanto, puede reconstruir root-fs e imágenes sin reconstruir paquetes: </p><br><pre> <code class="bash hljs">rm output/build/host-gcc-final-*/.stamp_host_installed;rm -rf output/target;find output/ -name <span class="hljs-string"><span class="hljs-string">".stamp_target_installed"</span></span> |xargs rm -rf ; make</code> </pre> <br><h4 id="poleznye-peremennye">  Variables utiles </h4><br><p>  Buildroot tiene un conjunto de variables para una fácil configuración </p><br><ul><li>  $ TOPDIR - directorio raíz de buildroot </li><li>  $ BASEDIR - directorio de SALIDA </li><li>  $ HOST_DIR, $ STAGING_DIR, $ TARGET_DIR: los directorios de ensamblado alojan fs, staging fs, target fs. </li><li>  $ BUILD_DIR - directorio con paquetes desempaquetados y ensamblados </li></ul><br><h4 id="vizualizaciya">  Visualización </h4><br><p>  Buildroot tiene la capacidad de visualizar: puede crear un diagrama de dependencia, una línea de tiempo de construcción, un gráfico de tamaño de paquete en el sistema final.  Los resultados están en forma de archivos pdf (puede elegir entre svn, png) en el directorio de salida / gráfico. </p><br><p>  Ejemplos de comandos de visualización: </p><br><ul><li>  <code>make graph-depends</code> construir un árbol de dependencia </li><li>  <code>make &lt;pkg&gt;-graph-depends</code> construye un árbol de dependencias de paquete </li><li>  <code>BR2_GRAPH_OUT=png make graph-build</code> construye un gráfico del tiempo de ensamblaje con salida en PNG </li><li>  <code>make graph-size</code> paquete de diagrama de <code>make graph-size</code> gráfico </li></ul><br><h4 id="poleznye-skripty">  Guiones útiles </h4><br><p>  El directorio buildroot tiene un subdirectorio <strong>utils</strong> con scripts útiles.  Por ejemplo, hay un script que verifica la descripción correcta de los paquetes.  Esto puede ser útil al agregar mis paquetes (lo haré más adelante).  El archivo utils / readme.txt contiene una descripción de estos scripts. </p><br><h2 id="soberem-ctokovyy-distributiv">  Construyamos una distribución de stock </h2><br><p>  <em>Es importante recordar que todas las operaciones se realizan en nombre de un usuario normal, no root.</em> <br>  Todos los comandos se ejecutan en la raíz de buildroot.  El paquete buildroot ya tiene un conjunto de configuraciones para muchas placas comunes y virtualización. </p><br><p>  Nos fijamos en la lista de configuraciones: </p><br><p><img src="https://habrastorage.org/webt/us/iu/f3/usiuf3l_-ics3e8gdbnzebjszzs.png"></p><br><p>  Cambie a la configuración qemu_x86_64_defconfig </p><br><pre> <code class="bash hljs">make qemu_x86_64_defconfig</code> </pre> <br><p>  Y comenzamos el montaje </p><br><pre> <code class="bash hljs">make</code> </pre> <br><p>  El ensamblaje se completa con éxito, nos fijamos en los resultados: </p><br><p><img src="https://habrastorage.org/webt/pb/2v/sb/pb2vsbi3oe_repbvq6f0bkqf7ee.png"></p><br><p>  Buildroot ha compilado imágenes que puede ejecutar en Qemu y asegurarse de que funcionen. </p><br><pre> <code class="bash hljs">qemu-system-x86_64 -kernel output/images/bzImage -hda \ output/images/rootfs.ext2 -append <span class="hljs-string"><span class="hljs-string">"root=/dev/sda rw"</span></span> -s -S</code> </pre> <br><p>  El resultado es un sistema que se ejecuta en qemu: </p><br><p><img src="https://habrastorage.org/webt/wz/m7/ua/wzm7uardoe4pbefa1ni8fij4pui.png"></p><br><h2 id="sozdanie-konfiguracii-sobstvennoy-platy">  Crear una configuración de placa personalizada </h2><br><h3 id="dobavlenie-faylov-platy">  Agregar archivos de tablero </h3><br><p>  Nos fijamos en la lista de configuraciones: </p><br><p><img src="https://habrastorage.org/webt/om/em/sx/omemsxpgtlfovmawbojohn5ma_a.png"></p><br><p>  En la lista vemos pc_x86_64_bios_defconfig.  Crearemos nuestro tablero copiándolo de la configuración: </p><br><pre> <code class="bash hljs">cp configs/pc_x86_64_bios_defconfig configs/my_x86_board_defconfig</code> </pre> <br><p>  Inmediatamente cree el directorio de la placa para almacenar nuestros scripts, rootfs-overlay y otros archivos necesarios: </p><br><pre> <code class="bash hljs">mkdir board/my_x86_board</code> </pre> <br><p>  Cambie a este defconfig: </p><br><pre> <code class="bash hljs">make my_x86_board_defconfig</code> </pre> <br><p>  Por lo tanto, ahora la configuración de compilación (almacenada en .config en la raíz del directorio buildroot) corresponde a la máquina de destino x86-64 legacy (bios) al cargar. </p><br><p>  Copie la configuración del kernel de Linux (útil en el futuro): </p><br><pre> <code class="bash hljs">cp board/pc/linux.config board/my_x86_board/</code> </pre> <br><h3 id="nastroyka-parametrov-sborki-cherez-kconfig">  Configure las opciones de compilación a través de KConfig </h3><br><p>  Ejecute la configuración: </p><br><pre> <code class="bash hljs">make menuconfig</code> </pre> <br><p>  Se abre la ventana KConfig.  Es posible configurar con una interfaz gráfica (make nconfig, make xconfig, make gconfig): </p><br><p><img src="https://habrastorage.org/webt/ai/6d/ub/ai6dub6beukqket6qcz3ezc9c5i.png"></p><br><p>  Entramos en la primera sección de las Opciones de destino.  Aquí puede elegir la arquitectura de destino para la que se realizará el ensamblaje. </p><br><p><img src="https://habrastorage.org/webt/pu/jl/v2/pujlv2tlusbnnenf9gstmsosyf4.png"></p><br><p>  Opciones de compilación: hay varias configuraciones de compilación aquí.  Puede especificar directorios con códigos fuente, la cantidad de subprocesos de ensamblaje, espejos para descargar códigos fuente y otras configuraciones.  Deje la configuración predeterminada. </p><br><p>  Cadena de herramientas: aquí se configuran las herramientas de compilación.  Más sobre él. </p><br><p><img src="https://habrastorage.org/webt/mb/-e/gy/mb-egyihomze0cx9vriprqph1ly.png"></p><br><p>  Tipo de cadena de herramientas: tipo de cadena de herramientas utilizada.  Se puede incorporar a buildroot o una cadena de herramientas externa (puede especificar un directorio con uno preconstruido o una url para descargar).  Para diferentes arquitecturas hay opciones adicionales.  Por ejemplo, para armar, simplemente puede seleccionar la versión de la cadena de herramientas externa Linaro. </p><br><p>  Biblioteca C: la elección de la biblioteca C. El funcionamiento de todo el sistema depende de esto.  Usualmente se usa glibc, soportando todas las funcionalidades posibles.  Pero puede ser demasiado grande para el sistema integrado, por lo que a menudo se eligen uClibc o musl.  Elegiremos glibc (en el futuro será necesario usar systemd). </p><br><p>  Cabeceras de núcleo y series de encabezados de núcleo personalizados: deben coincidir con la versión del núcleo que estará en el sistema de compilación.  Para los encabezados del kernel, también puede especificar la ruta al repositorio tarball o git. </p><br><p>  VERSIONES DEL COMPILADOR GCC: seleccione la versión del compilador que se utilizará para el ensamblaje <br>  Habilitar soporte de C ++: seleccione para ensamblar con soporte para bibliotecas de c ++ en el sistema.  En el futuro, esto será útil. </p><br><p>  Opciones de gcc adicionales: puede configurar opciones de compilador adicionales.  No necesitamos hasta ahora. </p><br><p>  La configuración del sistema le permite establecer parámetros futuros para el sistema creado: </p><br><p><img src="https://habrastorage.org/webt/3y/kk/fu/3ykkfukfm4ptl2iiiqs2bhvbn_0.png"></p><br><p>  La mayoría de los puntos están claros por el nombre.  Presta atención a los siguientes puntos: <br>  Ruta de acceso a las tablas de usuarios: tabla con usuarios creados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://buildroot.org/downloads/manual/manual.html#makeuser-syntax</a> ). </p><br><p>  Ejemplo de archivo  El usuario usuario se creará con la contraseña admin, automáticamente gid / uid, / bin / sh shell, usuario de grupo predeterminado, miembro del grupo raíz, comentario usuario de Foo </p><br><pre> <code class="bash hljs">[alexey@alexey-pc buildroot ]$ cat board/my_x86_board/users.txt user -1 user -1 =admin /home/user /bin/sh root Foo user</code> </pre> <br><p>  Directorios de superposición del sistema de archivos raíz: un directorio superpuesto en la parte superior del objetivo ensamblado fs.  Agrega nuevos archivos y reemplaza los existentes. </p><br><p>  Scripts personalizados para ejecutar antes de crear imágenes del sistema de archivos: scripts que se ejecutan inmediatamente antes de que el sistema de archivos se colapse en imágenes.  El script en sí se dejará en blanco por ahora. </p><br><p>  Pasemos a la sección Kernel </p><br><p><img src="https://habrastorage.org/webt/_u/-m/ic/_u-micbjjhq3dg_hoawyozkkqgk.png"></p><br><p>  La configuración del kernel se establece aquí.  El núcleo mismo se configura mediante make linux-menuconfig. <br>  Puede configurar la versión del kernel de diferentes maneras: elija una de las propuestas, ingrese la versión manualmente, especifique el repositorio o el tarball terminado. </p><br><p>  Configuración del kernel: la ruta a la configuración del kernel.  Puede elegir la configuración predeterminada para la arquitectura seleccionada o defocnfig desde Linux.  Las fuentes de Linux tienen un conjunto de defconfig para diferentes sistemas de destino.  Puede encontrar el correcto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mirando directamente la fuente aquí</a> .  Por ejemplo, para un tablero negro de hueso beagle, puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seleccionar una configuración</a> . </p><br><p>  La sección Paquetes de destino le permite elegir qué paquetes se instalarán en el sistema de compilación.  Déjalo sin cambios por ahora.  Más adelante agregaremos nuestros paquetes a esta lista. <br>  Imágenes del sistema de archivos: una lista de las imágenes del sistema de archivos que se compilarán.  Añadir imagen iso </p><br><p><img src="https://habrastorage.org/webt/ne/gz/o-/negzo-lbw2ci9i-hnj7pzg9tm88.png"></p><br><p>  Cargadores de arranque: la elección de los cargadores de arranque ensamblados.  Elige isolinix </p><br><p><img src="https://habrastorage.org/webt/ax/nb/qy/axnbqyxbxffyyyqz7qgle5ectgu.png"></p><br><h3 id="konfigurirovanie-systemd">  Configuración de Systemd </h3><br><p>  Systemd se convierte en uno de los pilares de Linux, junto con kernel y glibc.  Por lo tanto, hice su configuración en un párrafo separado. </p><br><p>  Se configura mediante make menuconfig, luego Paquetes de destino → Herramientas del sistema → systemd.  Aquí puede especificar qué servicios systemd se instalarán e iniciarán al iniciar el sistema. </p><br><p><img src="https://habrastorage.org/webt/_3/nk/sk/_3nkskizxu-lxd5pvq4fr9dqn5c.png"></p><br><h3 id="sohranenie-konfiguracii-sistemy">  Guardar configuración del sistema </h3><br><p>  Guarde esta configuración a través de KConfig. </p><br><p>  Luego guarde nuestro defconfig: </p><br><pre> <code class="bash hljs">make savedefconfig</code> </pre> <br><h3 id="konfigurirovanie-yadra-linux">  Configuración del kernel de Linux </h3><br><p>  La configuración del kernel de Linux se invoca con el siguiente comando: </p><br><pre> <code class="bash hljs">make linux-menuconfig</code> </pre> <br><p>  Agregue soporte para la tarjeta gráfica Virtualbox </p><br><p><img src="https://habrastorage.org/webt/xg/tx/2x/xgtx2xqc52qpvqhzhpojpk3tebs.png"></p><br><p>  Agregar soporte de integración de Virtualbox Guest </p><br><p><img src="https://habrastorage.org/webt/uy/vu/f0/uyvuf00a4y_ulkpvqjwmzi4but8.png"></p><br><p>  Guardar y salir.  <strong>IMPORTANTE</strong> : la configuración se guardará en output / build / linux- $ version / config, pero no en board / my_x86_board / linux.config </p><br><p><img src="https://habrastorage.org/webt/wp/qy/dm/wpqydmxqz1j3ttq_5vcom1uv38q.png"></p><br><p>  Por lo tanto, debe copiar manualmente la configuración en la ubicación de almacenamiento: </p><br><pre> <code class="bash hljs">cp output/build/linux-4.19.25/.config board/my_x86_board/linux.config</code> </pre> <br><p>  Con este comando copio la configuración de kernel COMPLETA, que no siempre es necesaria.  Una forma más correcta es mantener el kernel defconfig: </p><br><pre> <code class="bash hljs">make linux-update-defconfig</code> </pre> <br><p>  Después de eso, realizamos un reensamblaje completo de todo el sistema.  Dado que buildroot no vuelve a ensamblar el ya ensamblado, debe especificar manualmente los paquetes para el reensamblado.  Para no perder tiempo y nervios, es más fácil reconstruir todo el sistema pequeño): </p><br><pre> <code class="bash hljs">make clean;make</code> </pre> <br><p>  Una vez completada la compilación, ejecute VirtualBox (probado en las versiones 5.2 y 6.0) con el arranque desde la unidad de CD. Parámetros del sistema: </p><br><p><img src="https://habrastorage.org/webt/mi/_-/pb/mi_-pb0m79dbqf1tpg8x72hk9vk.png"></p><br><p>  A partir de la iso ensamblada: </p><br><p><img src="https://habrastorage.org/webt/ai/uq/uw/aiuquwkxe2-ac9hom0h5vdpnjve.png"></p><br><h2 id="spisok-ispolzovannyh-materialov">  Listado de materiales utilizados </h2><br><ol><li>  Manual de Buildroot </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448638/">https://habr.com/ru/post/448638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448626/index.html">DDoS para ayudar: cómo realizamos pruebas de estrés y estrés</a></li>
<li><a href="../448628/index.html">Estética técnica y tecnología soviéticas</a></li>
<li><a href="../448632/index.html">¿Java ya está pagado? Desacreditando rumores (¿o no?)</a></li>
<li><a href="../448634/index.html">Lecciones ucranianas</a></li>
<li><a href="../448636/index.html">Hackaday Retro Computer Case</a></li>
<li><a href="../448640/index.html">SSD GIGABYTE Aorus RGB M.2: pequeño, incluso remoto para LED RGB (2 partes)</a></li>
<li><a href="../448642/index.html">Modelo obligatorio de distribución de derechos en FreeBSD</a></li>
<li><a href="../448644/index.html">Expresiones regulares aplicativas como functor alternativo gratuito</a></li>
<li><a href="../448648/index.html">Cómo sentar a todos en la ciencia y no convertir la oficina en un hervidero de odio</a></li>
<li><a href="../448652/index.html">Mozilla WebThings en Raspberry Pi: cómo empezar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>