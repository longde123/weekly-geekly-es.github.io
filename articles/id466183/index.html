<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◾️ 🛡️ 👨🏼‍🏫 Algoritma Pemrosesan String Cerdas di ClickHouse 🎅🏾 🐢 ☁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ClickHouse terus-menerus menghadapi tugas pemrosesan string. Misalnya, mencari, menghitung properti string UTF-8, atau sesuatu yang lebih eksotis, apa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma Pemrosesan String Cerdas di ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  ClickHouse terus-menerus menghadapi tugas pemrosesan string.  Misalnya, mencari, menghitung properti string UTF-8, atau sesuatu yang lebih eksotis, apakah itu pencarian case-sensitive atau pencarian data terkompresi. </p><br><p> Semuanya dimulai dengan fakta bahwa manajer pengembangan ClickHouse Lyosha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">o6CuFl2Q</a> datang kepada kami di Fakultas Ilmu Komputer di Sekolah Tinggi Ekonomi dan menawarkan sejumlah besar topik untuk makalah dan diploma.  Ketika saya melihat "Algoritma Pemrosesan String Cerdas di ClickHouse" (Saya, seseorang yang tertarik pada berbagai algoritma, termasuk yang eksperimental), saya segera menyiapkan rencana untuk bagaimana membuat diploma paling keren.  Kegembiraan dan ekspresi saya dapat digambarkan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  ClickHouse dengan hati-hati memikirkan organisasi penyimpanan data dalam memori - dalam kolom.  Pada akhir setiap kolom ada padding 15 byte untuk membaca register 16-byte yang aman.  Misalnya, ColumnString menyimpan string yang diakhiri null bersama dengan offset.  Sangat mudah untuk bekerja dengan array seperti itu. </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p>  Ada juga ColumnFixedString, ColumnConst dan LowCardinality, tetapi kami tidak akan membicarakannya secara mendetail hari ini.  Poin utama pada titik ini adalah bahwa desain pembacaan yang aman untuk ekornya baik-baik saja, dan lokasi data juga memainkan peran dalam pemrosesan. </p><br><h2 id="poisk-po-podstrokam">  Pencarian Substring </h2><br><p>  Kemungkinan besar, Anda tahu banyak algoritma berbeda untuk menemukan substring dalam string.  Kami akan berbicara tentang yang digunakan di ClickHouse.  Pertama, kami memperkenalkan beberapa definisi: </p><br><ol><li>  tumpukan jerami - garis di mana kita melihat;  panjang biasanya dilambangkan dengan <em>n</em> . </li><li>  jarum - string atau ekspresi reguler yang kita cari;  panjangnya akan dilambangkan dengan <em>m</em> . </li></ol><br><p>  Setelah mempelajari sejumlah besar algoritma, saya dapat mengatakan bahwa ada 2 (maksimal 3) jenis algoritma pencarian substring.  Yang pertama adalah penciptaan dalam satu bentuk atau lain dari struktur sufiks.  Tipe kedua adalah algoritma berdasarkan perbandingan memori.  Ada juga algoritma Rabin-Karp, yang menggunakan hash, tetapi cukup unik dalam jenisnya.  Algoritma tercepat tidak ada, semuanya tergantung pada ukuran alfabet, panjang jarum, tumpukan jerami dan frekuensi kemunculannya. </p><br><p>  Baca tentang berbagai algoritma di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dan berikut ini adalah algoritma yang paling populer: </p><br><ol><li>  Knut - Morris - Pratt, </li><li>  Boyer - Moore, </li><li>  Boyer - Moore - Horspool, </li><li>  Rabin - Carp, </li><li>  Dua sisi (digunakan dalam glibc yang disebut "memmem"), </li><li>  BNDM </li></ol><br><p>  Daftarnya berlanjut.  Kami di ClickHouse dengan jujur ​​mencoba segalanya, tetapi pada akhirnya kami memilih versi yang lebih luar biasa. </p><br><h4 id="algoritm-volnickogo">  Algoritma Volnitsky </h4><br><p>  Algoritma ini diterbitkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> programmer Leonid Volnitsky pada akhir 2010.  Ini agak mengingatkan pada algoritma Boyer-Moore-Horspool, hanya versi yang ditingkatkan. </p><br><p>  Jika <em>m &lt;4</em> , maka algoritma pencarian standar digunakan.  Simpan semua jarum bigrams (2 byte berturut-turut) dari ujung ke tabel hash dengan pengalamatan terbuka ukuran <em>| Sigma |</em>  <em><sup>2</sup></em> elemen (dalam praktiknya, ini adalah 2 <sup>16</sup> elemen), di mana offset bigram ini akan menjadi nilainya, dan bigram itu sendiri akan menjadi hash dan indeks pada saat yang sama.  Posisi awal akan berada di posisi <em>m - 2</em> dari awal tumpukan jerami.  Kami mengikuti tumpukan jerami dengan langkah <em>m - 1</em> , melihat bigram berikutnya dari posisi ini di tumpukan jerami dan mempertimbangkan semua nilai dari bigram di tabel hash.  Kemudian kita akan membandingkan dua buah memori dengan algoritma perbandingan biasa.  Ekor yang tersisa akan diproses oleh algoritma yang sama. </p><br><p>  Langkah <em>m - 1</em> dipilih sedemikian rupa sehingga jika ada jarum di tumpukan jerami, maka kami pasti akan mempertimbangkan bigram entri ini - dengan demikian memastikan bahwa kami mengembalikan posisi entri di tumpukan jerami.  Kejadian pertama dijamin oleh fakta bahwa kami menambahkan indeks dari ujung ke tabel hash oleh bigram.  Ini berarti bahwa ketika kita bergerak dari kiri ke kanan, pertama kita akan mempertimbangkan bigrams dari akhir baris (mungkin awalnya mempertimbangkan bigrams yang sama sekali tidak perlu), kemudian lebih dekat ke awal. </p><br><p> Pertimbangkan sebuah contoh.  Biarkan tumpukan jerami tali menjadi <code>abacabaac</code> dan jarum sama dengan <code>aaca</code> .  Tabel hash adalah <code>{aa : 0, ac : 1, ca : 2}</code> . </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Kami melihat <code>ac</code> bigram.  Di jarum itu, kami menggantikan dalam kesetaraan: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  Tidak cocok  Setelah <code>ac</code> tidak ada entri di tabel hash, kita langkah dengan langkah 3: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Tidak ada bigrams <code>ba</code> di tabel hash, silakan: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Ada jarum bigram di jarum, kita melihat offset dan menemukan entri: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  Algoritme memiliki banyak keunggulan.  Pertama, Anda tidak perlu mengalokasikan memori di heap, dan 64 KB di stack bukan sesuatu yang transendental sekarang.  Kedua, 2 <sup>16</sup> adalah angka yang sangat baik untuk mengambil modulo untuk prosesor;  ini hanya instruksi movzwl (atau, seperti yang kita bercanda, “movsvl”) dan keluarga. </p><br><p>  Rata-rata, algoritma ini terbukti menjadi yang terbaik.  Kami mengambil data dari Yandex.Metrica, permintaannya hampir nyata.  Satu aliran kecepatan, lebih banyak lebih baik, KMP: Algoritma Knut - Morris - Pratt, BM: Boyer - Moore, BMH: Boyer - Moore - Horspool. </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p>  Agar tidak berdasar, algoritme dapat bekerja waktu kuadratik: </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p>  Ini digunakan dalam fungsi <code>position(Column, ConstNeedle)</code> , dan juga bertindak sebagai optimisasi untuk pencarian ekspresi reguler. </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam">  Pencarian Ekspresi Reguler </h2><br><p>  Kami akan memberi tahu Anda bagaimana ClickHouse mengoptimalkan pencarian ekspresi reguler.  Banyak ekspresi reguler mengandung substring di dalam, yang harus di dalam tumpukan jerami.  Agar tidak membangun mesin status terbatas dan mengeceknya, kami akan mengisolasi substring tersebut. </p><br><p>  Untuk melakukan ini cukup sederhana: setiap tanda kurung buka menambah tingkat sarang, setiap tanda kurung tutup akan berkurang;  ada juga karakter khusus untuk ekspresi reguler (mis. '.', '*', '?', '\ w', dll.).  Kita perlu mendapatkan semua substring di level 0. Pertimbangkan sebuah contoh: <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p>  Kami memecahnya menjadi substring yang harus ada di tumpukan jerami dari ekspresi reguler, setelah itu kami memilih panjang maksimum, mencari kandidat di atasnya dan kemudian memeriksa dengan mesin ekspresi reguler biasa RE2.  Pada gambar di atas terdapat ekspresi reguler, diproses oleh mesin RE2 biasa pada 736 MB / s, Hyperscan (sekitar beberapa saat kemudian) mengelola menjadi 1,6 GB / s, dan kami mengelola 1,69 GB / s per inti bersama dengan dekompresi LZ4.  Secara umum, pengoptimalan seperti itu ada di permukaan dan sangat mempercepat pencarian untuk ekspresi reguler, tetapi seringkali tidak diimplementasikan dalam alat, yang sangat mengejutkan saya. </p><br><p>  Kata kunci LIKE juga dioptimalkan menggunakan algoritma ini, hanya setelah LIKE dapat ekspresi reguler yang sangat disederhanakan melalui %%%%% (substring sewenang-wenang) dan <code>_</code> (karakter sewenang-wenang). </p><br><p>  Sayangnya, tidak semua ekspresi reguler mengalami optimasi seperti itu, misalnya, dari <code>yandex|google</code> tidak mungkin untuk secara eksplisit mengisolasi substring yang harus terjadi di tumpukan jerami.  Oleh karena itu, kami datang dengan solusi yang sangat berbeda. </p><br><h2 id="poisk-po-mnogim-podstrokam">  Cari banyak substring </h2><br><p>  Masalahnya adalah ada banyak jarum, dan saya ingin mengerti jika setidaknya satu dari mereka termasuk dalam tumpukan jerami.  Ada metode yang cukup klasik untuk pencarian seperti itu, misalnya, algoritma Aho-Korasik.  Tapi dia tidak terlalu cepat untuk tugas kami.  Kami akan membicarakannya nanti. </p><br><p><del>  Lesha </del>  ClickHouse menyukai solusi non-standar, jadi kami memutuskan untuk mencoba sesuatu yang berbeda dan, mungkin, membuat algoritma pencarian baru sendiri.  Dan mereka melakukannya. </p><br><p>  Kami melihat algoritma Volnitsky dan memodifikasinya sehingga mulai mencari banyak substring sekaligus.  Untuk melakukan ini, Anda hanya perlu menambahkan bigrams dari semua baris dan menyimpan indeks baris di tabel hash.  Langkah ini akan dipilih dari setidaknya semua panjang jarum minus 1 untuk menjamin properti lagi bahwa jika ada kejadian kita akan melihat bigram nya.  Tabel hash akan tumbuh hingga 128 KB (garis lebih panjang dari 255 diproses oleh algoritma standar, kami akan mempertimbangkan tidak lebih dari 256 jarum).  Saya sangat malas, jadi ini adalah contoh dari presentasi (baca dari kiri ke kanan dari atas ke bawah): </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p>  Kami mulai melihat bagaimana suatu algoritma berperilaku dibandingkan dengan yang lain (baris diambil dari data nyata).  Dan untuk sejumlah kecil jalur, ia melakukan segalanya (kecepatan dan pembongkaran ditunjukkan - sekitar 2,5 GB / s). </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p>  Kemudian menjadi menarik.  Misalnya, dengan sejumlah besar bigrams serupa, kami kalah dari beberapa pesaing.  Dapat dimengerti - kita mulai membandingkan banyak keping memori dan menurunkan. </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p>  Anda tidak dapat berakselerasi banyak jika panjang minimum jarum cukup besar.  Jelas, kami memiliki lebih banyak peluang untuk melewatkan seluruh tumpukan jerami tanpa membayar apa pun untuk itu. </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p>  Titik kritis dimulai di suatu tempat pada baris 13-15.  Sekitar 97% dari permintaan yang saya lihat di cluster kurang dari 15 baris: </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p>  Nah, gambar yang sangat menyeramkan - 41 baris, banyak bigrams berulang: </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p>  Akibatnya, di ClickHouse (19.5) kami menerapkan fungsi berikut melalui algoritma ini: </p><br><p>  - <code>multiSearchAny(h, [n_1, ..., n_k])</code> - 1, jika setidaknya salah satu jarum ada di tumpukan jerami. <br>  - <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> - posisi paling kiri dari entri ke tumpukan jerami (dari satu) atau 0 jika tidak ditemukan. <br>  - <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> - indeks jarum paling kiri, yang ditemukan di tumpukan jerami;  0 jika tidak ditemukan. <br>  - <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> - semua posisi pertama dari semua jarum, mengembalikan sebuah array. </p><br><p>  Sufiksnya adalah -UTF8 (kami tidak menormalkan), -CaseInsensitive (kami menambahkan 4 bigrams dengan case yang berbeda), -CaseInsensitiveUTF8 (ada kondisi bahwa huruf besar dan huruf kecil harus memiliki jumlah byte yang sama).  Lihat implementasinya di <a href="">sini</a> . </p><br><p>  Setelah itu, kami bertanya-tanya apakah kami bisa melakukan sesuatu yang mirip dengan banyak ekspresi reguler.  Dan mereka menemukan solusi yang sudah rusak dalam tolok ukur. </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam">  Cari berdasarkan banyak ekspresi reguler </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperscan</a> adalah perpustakaan dari Intel yang segera mencari banyak ekspresi reguler.  Ia menggunakan heuristik untuk mengisolasi subword dari ekspresi reguler yang kami tulis, dan banyak SIMD untuk mencari automaton Glushkov (algoritmenya tampaknya disebut Teddy). </p><br><p>  Secara umum, semuanya ada dalam tradisi terbaik untuk mendapatkan hasil maksimal dari pencarian ekspresi reguler.  Perpustakaan benar-benar melakukan apa yang dideklarasikan dalam fungsinya. </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p>  Untungnya, dalam bulan pengembangan saya di ClickHouse, saya bisa menyalip pengembangan 12 tahun pada kelas pertanyaan yang layak dan saya sangat senang dengan ini. </p><br><p>  Di Yandex, perpustakaan Hyperscan juga digunakan di antispam.  Dilihat oleh ulasan, dia dengan tenang memproses ribuan ekspresi reguler dan dengan cepat mencari mereka. </p><br><p>  Perpustakaan memiliki beberapa kelemahan.  Yang pertama adalah jumlah memori yang tidak berdokumen yang dikonsumsi dan fitur aneh bahwa tumpukan jerami harus kurang dari 2 <sup>32</sup> byte.  Yang kedua - Anda tidak dapat mengembalikan posisi pertama secara gratis, indeks jarum paling kiri, dll. Dan minus ketiga - ada beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> yang tiba-tiba.  Oleh karena itu, di ClickHouse, kami menerapkan fungsi-fungsi berikut menggunakan Hyperscan: </p><br><p>  - <code>multiMatchAny(h, [n_1, ..., n_k])</code> - 1, jika setidaknya salah satu jarum muncul dengan tumpukan jerami. <br>  - <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> - indeks apa pun dari jarum yang <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> tumpukan jerami. </p><br><p>  Kami tertarik, tetapi bagaimana Anda bisa mencari tidak persis, tetapi kira-kira?  Dan datang dengan beberapa solusi. </p><br><h2 id="priblizhyonnyy-poisk">  Perkiraan pencarian </h2><br><p>  Standar dalam pencarian perkiraan adalah jarak Levenshtein - jumlah minimum karakter yang dapat diganti, ditambahkan dan dihapus untuk mendapatkan string b panjang n dari string a panjang m.  Sayangnya, algoritma pemrograman dinamis naif bekerja untuk <em>O (mn)</em> ;  pikiran terbaik ShAD dapat melakukannya dalam <em>O (mn / log max (n, m))</em> ;  mudah untuk memikirkan <em>O ((n + m) ⋅ alpha)</em> , di mana <em>alpha</em> adalah jawabannya;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sains</a> dapat melakukannya untuk <em>O ((alfa - | n - m |) min (m, n, alfa) + m + n)</em> (algoritmanya sederhana, baca setidaknya di ShAD) atau, jika sedikit lebih jelas, untuk <em>O (alfa ^ 2 + m + n)</em> .  Masih ada yang minus: kemungkinan besar tidak mungkin untuk membuang waktu kuadrat dalam kasus terburuk secara polinomi - Peter Indik menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> yang sangat kuat tentang ini. </p><br><p>  Ada latihan: bayangkan bahwa untuk mengganti karakter dalam jarak Levenshtein Anda membayar denda bukan dua, tetapi dua;  kemudian muncul dengan algoritma untuk <em>O ((n + m) log (n + m))</em> . </p><br><p>  Masih tidak berfungsi, terlalu lama dan mahal.  Tetapi dengan bantuan jarak seperti itu, kami melakukan deteksi kesalahan ketik di kueri. </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p>  Selain jarak Levenshtein, ada jarak Hamming.  Dengan dia juga, semuanya sangat buruk, tetapi sedikit lebih baik daripada dengan jarak Levenshtein.  Itu tidak memperhitungkan penghapusan karakter, tetapi hanya mempertimbangkan untuk dua baris dengan panjang yang sama jumlah karakter di mana mereka berbeda.  Oleh karena itu, jika kita menggunakan jarak untuk string dengan panjang m &lt;n, maka hanya dalam mencari substring terdekat. </p><br><p>  Bagaimana menghitung array perbedaan tersebut (array d dari n - m + 1 elemen, di mana d [i] adalah jumlah karakter yang berbeda di i-th dari awal overlay) untuk <em>O (| Sigma | (n + m) log (n + m) )</em> ?  Pertama, lakukan <em>| Sigma |</em>  topeng bit yang menunjukkan apakah simbol ini sama dengan yang dianggap.  Selanjutnya, kami menghitung jawaban untuk masing-masing topeng Sigma dan menambahkan - kami mendapatkan jawaban asli. </p><br><p>  Pertimbangkan sebuah contoh.  <code>abba</code> , substring <code>ba</code> , alfabet biner.  Kami mendapatkan 2 topeng <code>1001, 01</code> dan <code>0110, 10</code> . </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p>  Kami mendapatkan array [0, 1, 2] - ini adalah jawaban yang hampir benar.  Tetapi perhatikan bahwa untuk setiap huruf, jumlah korek api hanyalah produk skalar dari jarum biner tetap dan semua substring tumpukan jerami.  Dan untuk ini, tentu saja, ada transformasi Fourier yang cepat! </p><br><p>  Bagi mereka yang tidak tahu: FFT dapat melipatgandakan dua polinomial derajat <em>m &lt;n</em> untuk waktu <em>O (n log n)</em> , dengan ketentuan bahwa pekerjaan dengan koefisien dilakukan per satuan waktu.  Konvolusi sangat mirip dengan produk skalar.  Cukup untuk menduplikasi koefisien dari polinomial pertama, dan memperluas dan menambah yang kedua dengan jumlah nol yang diperlukan, maka kita mendapatkan semua produk skalar dari satu string biner dan semua substring yang lain di <em>O (n log n)</em> - semacam sihir!  Tapi percayalah, ini benar-benar nyata, dan terkadang orang melakukannya. </p><br><p>  Tetapi tidak di ClickHouse.  Bagi kami, bekerja dengan | Sigma |  = 30 sudah besar, dan FFT bukan algoritma praktis yang paling menyenangkan untuk prosesor atau, seperti yang dikatakan orang awam, "konstanta besar." </p><br><p>  Karena itu, kami memutuskan untuk melihat metrik lain.  Kami sampai ke bioinformatika, di mana orang menggunakan jarak n-gram.  Faktanya, kita mengambil semua n-gram tumpukan jerami dan jarum, pertimbangkan 2 multiset dengan n-gram ini.  Kemudian kita mengambil perbedaan simetris dan membaginya dengan jumlah kardinalitas dua multiset dengan n-gram.  Kami mendapatkan angka dari 0 hingga 1 - semakin dekat ke 0, semakin banyak garis yang serupa.  Pertimbangkan contoh di mana <em>n = 4</em> : </p><br><pre> <code class="plaintext hljs">abcda → {abcd, bcda}; Size = 2 bcdab → {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p>  Sebagai hasilnya, kami membuat jarak 4 gram dan menempel banyak ide dari SSE di sana, dan kami juga sedikit melemahkan implementasi untuk hash double-byte crc32. </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p>  Lihat <a href="">implementasinya</a> .  Perhatian: kode yang sangat menarik dan dioptimalkan untuk kompiler. </p><br><p>  Saya terutama menyarankan Anda untuk memperhatikan <a href="">hack kotor</a> untuk casting huruf kecil untuk ASCII dan poin kode Rusia. </p><br><p>  - <code>ngramDistance(haystack, needle)</code> - mengembalikan angka dari 0 hingga 1;  semakin dekat ke 0, semakin banyak garis yang mirip satu sama lain. <br>  - -UTF8, -CaseInsensitive, -CaseInsensitiveUTF8 (hack kotor untuk Rusia dan ASCII). </p><br><p>  Hyperscan juga tidak berdiri diam - ini memiliki fungsi untuk pencarian perkiraan: Anda dapat mencari garis yang terlihat seperti ekspresi reguler dengan jarak konstan Levenshtein.  Sebuah <em>jarak + 1</em> otomat dibuat, yang saling berhubungan dengan menghapus, mengganti atau menyisipkan karakter, yang berarti "baik", setelah itu algoritma yang biasa untuk memeriksa apakah suatu otomat menerima suatu garis tertentu diterapkan.  Di ClickHouse, kami menerapkannya dengan nama-nama berikut: </p><br><p>  - <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> - mirip dengan multiMatchAny, hanya dengan jarak. <br>  - <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> - mirip dengan multiMatchAnyIndex, hanya dengan jarak. </p><br><p>  Dengan meningkatnya <em>jarak,</em> kecepatan mulai menurun drastis, tetapi masih tetap pada tingkat yang cukup baik. </p><br><p>  Selesaikan pencarian dan mulai memproses string UTF-8.  Ada juga banyak hal menarik. </p><br><h2 id="obrabotka-utf-8-strok">  Pemrosesan jalur UTF-8 </h2><br><p>  Saya akui bahwa sulit untuk menerobos langit-langit implementasi naif dalam string yang dikodekan UTF-8.  Terutama sulit untuk mengacaukan SIMD.  Saya akan membagikan beberapa ide tentang bagaimana melakukan ini. </p><br><p>  Ingat seperti apa urutan UTF-8 yang valid: </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p>  Mari kita coba menghitung panjang titik kode dengan byte pertama.  Di sinilah bit bit dimulai.  Sekali lagi kami menulis beberapa properti: </p><br><p>  - Mulai dari 0xC <em>dan pada 0xD</em> memiliki 2 byte <br>  - 0xC2 = 11 <u>0</u> 00010 <br>  - 0xDF = 11 <u>0</u> 11111 <br>  - 0xE0 = 111 <u>0</u> 0000 <br>  - 0xF4 = 1111 <u>0</u> 100, tidak ada yang lebih jauh dari 0xF4, tetapi jika ada 0xF8, akan ada cerita yang berbeda <br>  - Jawab 7 dikurangi posisi nol pertama dari akhir, jika bukan karakter ASCII </p><br><p>  Kami menghitung panjangnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p>  Untungnya, kami memiliki instruksi stok yang dapat menghitung jumlah nol bit, dimulai dengan yang paling signifikan. </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p>  Hitung bitScanReverse: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p>  Mari kita coba menghitung panjang string UTF-8 berdasarkan poin kode melalui SIMD.  Untuk melakukan ini, lihat setiap byte sebagai nomor yang ditandatangani dan catat properti berikut: </p><br><p>  - 0xBF = -65 <br>  - 0x80 = -128 <br>  - 0xC2 = -62 <br>  - 0x7F = 127 <br>  - semua byte pertama ada di [0xC2, 0x7F] <br>  - semua byte non-pertama dalam [0x80, 0xBF] </p><br><p>  Algoritma ini cukup sederhana.  Bandingkan setiap byte dengan -65 dan, jika lebih besar dari angka ini, tambahkan satu.  Jika kita ingin menggunakan SIMD, maka ini adalah beban biasa 16 byte dari aliran input.  Lalu ada perbandingan byte, yang dalam kasus hasil positif akan memberikan byte 0xFF, dan dalam kasus negatif - 0x00.  Kemudian instruksi <code>pmovmskb</code> , yang akan mengumpulkan bit tinggi dari setiap byte register.  Kemudian jumlah garis bawah meningkat, kami menggunakan intrinsik untuk instruksi SSE4 popcnt.  Skema algoritma ini dapat diilustrasikan dengan sebuah contoh: </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p>  Ternyata seiring dengan dekompresi, pemrosesan per inti akan menjadi sekitar 1,5 GB / s. </p><br><p>  Fungsinya disebut: </p><br><p>  - <code>lengthUTF8(string)</code> - mengembalikan panjang string UTF-8 yang dikodekan dengan benar, sesuatu dianggap tidak valid, pengecualian tidak dilemparkan. </p><br><p>  Kami melangkah lebih jauh karena kami ingin lebih banyak fungsi dengan pemrosesan string UTF-8.  Misalnya, memeriksa validitas dan casting ke ekspresi UTF-8 yang valid. </p><br><p>  Untuk memeriksa validitas, saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/cyb70289/utf8/</a> , diadaptasi untuk ClickHouse (sebenarnya hanya mengubah pemrosesan ekor) dan mendapatkan kecepatan 1,22 GB / s dibandingkan dengan 900 MB / s untuk algoritma naif .  Saya tidak akan menjelaskan algoritma itu sendiri, cukup rumit untuk persepsi. </p><br><p>  - <code>isValidUTF8(string)</code> - mengembalikan 1 jika string dikodekan dengan benar dengan UTF-8, jika tidak 0. <br>  - <code>toValidUTF8(string)</code> - menggantikan karakter UTF-8 yang tidak valid dengan karakter   (U + FFFD).  Semua karakter yang tidak valid berturut-turut dikelompokkan menjadi satu karakter pengganti.  Tidak ada ilmu roket. </p><br><p>  Secara umum, di jalur UTF-8, karena skema statis yang tidak terlalu menyenangkan, selalu sulit untuk menemukan sesuatu yang dioptimalkan dengan baik. </p><br><h2 id="chto-dalshe">  Apa selanjutnya </h2><br><p>  Biarkan saya mengingatkan Anda bahwa ini adalah tesis saya.  Tentu saja, saya membelanya untuk 10/10.  Kami sudah pergi bersamanya ke Highload ++ Siberia (meskipun bagi saya sepertinya ia kurang menarik bagi siapa pun).  Tonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> .  Saya suka bahwa bagian praktis dari tesis ini menghasilkan banyak penelitian yang menarik.  Dan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ijazah</a> itu sendiri.  Ini memiliki banyak kesalahan ketik, karena tidak ada yang membacanya.  :) </p><br><p>  Sebagai bagian dari persiapan diploma, saya melakukan banyak pekerjaan serupa lainnya (tautan mengarah ke permintaan gabungan): </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi concat Dioptimalkan 2 kali</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat format python paling sederhana untuk permintaan</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LZ4 yang Dipercepat sebesar 4%</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya melakukan pekerjaan yang baik pada SIMD untuk ARM dan PPC64LE</a> ; <br>  - Dan dia menyarankan beberapa siswa FCS dengan ijazah di ClickHouse. </p><br><p>  Pada akhirnya, ternyata dalam pengalaman saya, <del>  setiap bulan Lesha mencoba mengucapkan mantra padaku </del>  ClickHouse adalah sistem yang paling menyenangkan untuk menulis kode berkinerja tinggi, di mana ada dokumentasi, komentar, pengembang luar biasa dan dukungan pengembang.  ClickHouse mengagumkan, sungguh.  Bosan dengan pemindahan format JSON?  Datanglah ke Lesha dan minta tugas dari level mana pun - dia akan menyediakannya untuk Anda, dan selama akhir pekan Anda akan mendapatkan kesenangan besar dari menulis kode. </p><br><p>  Tetapi dengan semua prestasi ClickHouse dan desainnya, itu mungkin bukan tentang mereka.  Tidak terutama di dalamnya. </p><br><p>  Saya menjalani studi sarjana selama 4 tahun di FCS, pada bulan Juni saya lulus dari HSE dengan ijazah merah, bekerja selama satu setengah tahun di tim yang luar biasa di Yandex, setelah dipompa dengan baik.  Tanpa pengalaman total selama ini <del>  dan besi </del>  Tidak ada yang tertulis di pos akan berhasil.  FCN sangat keren, jika Anda mengambil yang maksimal darinya.  Terima kasih kepada Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ivan_puzyrevskiy</a> , Ignat Kolesnichenko, Gleb Evstropov, Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">maxim_babenko</a> untuk pertemuan dalam petualangan lucu saya di FCN.  Dan juga terima kasih kepada semua guru yang mengajari saya sesuatu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466183/">https://habr.com/ru/post/id466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466165/index.html">Bagaimana Kecerdasan Buatan Membantu Mengelola Proyek</a></li>
<li><a href="../id466169/index.html">Penawaran khusus untuk siswa yang bekerja dari JetBrains</a></li>
<li><a href="../id466171/index.html">Lima alasan untuk menggunakan JUG.EKB</a></li>
<li><a href="../id466179/index.html">fform: React & JSONSchema - fleksibilitas maksimum</a></li>
<li><a href="../id466181/index.html">Python dari C (C API)</a></li>
<li><a href="../id466187/index.html">Editor logika visual untuk Unity3d. Bagian 2</a></li>
<li><a href="../id466191/index.html">Hal utama tentang pertempuran untuk netralitas jaringan di AS adalah kronologi peristiwa dan keadaan saat ini</a></li>
<li><a href="../id466193/index.html">Umpan otomatis MailChimp kustom dari umpan RSS</a></li>
<li><a href="../id466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../id466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>