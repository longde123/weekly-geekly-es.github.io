<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 👨🏼‍⚕️ 🙍🏾 Découvrez la pseudo console Windows (ConPTY) 👧🏾 ✨ 🙌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article publié le 2 août 2018 

 Il s'agit du deuxième article sur la ligne de commande Windows, où nous discuterons de la nouvelle infrastructure et ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Découvrez la pseudo console Windows (ConPTY)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publié</a> le 2 août 2018</font> <br><br>  Il s'agit du deuxième article sur la ligne de commande Windows, où nous discuterons de la nouvelle infrastructure et des interfaces de programmation de la pseudo-console Windows, c'est-à-dire de la pseudo console Windows (ConPTY): pourquoi nous l'avons développée, pourquoi elle est nécessaire, comment elle fonctionne, comment l'utiliser et bien plus encore. <br><br>  Dans le dernier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Le grave héritage du passé.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Problèmes de ligne de commande Windows »,</a> nous avons parlé des conditions préalables à l'émergence du terminal et de l'évolution de la ligne de commande dans Windows, et avons également commencé à étudier la structure interne de la console Windows et l'infrastructure de ligne de commande Windows.  Nous avons également discuté des nombreux avantages et inconvénients majeurs de la console Windows. <br><br>  L'un des inconvénients est que Windows essaie d'être «utile», mais il interfère avec les développeurs de consoles alternatives et tierces, les développeurs de services, etc.  Lors de la création d'une console ou d'un service, les développeurs doivent avoir accès aux canaux de communication par lesquels leur terminal / service échange des données avec des applications en ligne de commande, ou leur donner accès.  Dans le monde * NIX, ce n'est pas un problème car * NIX fournit une infrastructure pseudo-terminal (PTY) qui facilite la création de canaux de communication pour une console ou un service.  Mais sous Windows, ce n'était pas ... <br><br>  <i><b>... jusqu'à maintenant!</b></i> <br><a name="habracut"></a><br><h1>  Du TTY au PTY </h1><br>  Avant de parler en détail de notre développement, revenons brièvement au développement des terminaux. <br><br><h2>  Au début était ATS </h2><br>  Comme discuté dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> , aux premiers jours de l'informatique, les utilisateurs contrôlaient les ordinateurs à l'aide de télétypes électromécaniques (TTY) connectés à un ordinateur via une sorte de canal de communication série (généralement via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une boucle de courant de 20 mA</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson et Dennis Ritchie (debout) travaillent sur le télétype DEC PDP-11 (messages sans affichage électronique)</i></font> <br><br><h3>  Distribution des terminaux </h3><br>  Les télétypes ont été remplacés par des terminaux informatisés à affichage électronique (généralement des écrans CRT).  En règle générale, les terminaux sont des dispositifs très simples (d'où le terme «terminal stupide»), contenant uniquement l'électronique et la puissance de traitement nécessaires pour les tâches suivantes: <br><br><ol><li>  Réception de la saisie de texte depuis le clavier. </li><li>  Mise en mémoire tampon du texte saisi sur une seule ligne (y compris l'édition locale avant l'envoi). </li><li>  Envoi / réception de texte sur un canal série (généralement via l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface RS-232</a> autrefois omniprésente). </li><li>  Affichage du texte reçu sur l'écran du terminal. </li></ol><br>  Malgré sa simplicité (ou peut-être grâce à elle), les terminaux sont rapidement devenus le principal moyen de gestion des mini-ordinateurs, des mainframes et des serveurs: la plupart des opérateurs de saisie de données, des opérateurs informatiques, des administrateurs système, des scientifiques, des chercheurs, des développeurs de logiciels et des sommités de l'industrie ont travaillé sur les terminaux DEC, IBM, Wyse et bien d'autres. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">L'amiral Grace Hopper dans son bureau avec un terminal DEC VT220 sur son bureau</font></i> <br><br><h3>  Distribution de terminaux logiciels </h3><br>  Depuis le milieu des années 80, au lieu de terminaux spécialisés, des ordinateurs à usage général ont progressivement commencé à être utilisés, qui sont devenus plus abordables, populaires et puissants.  De nombreux premiers PC et autres ordinateurs des années 80 avaient des applications de terminal qui ouvraient la connexion RS-232 au PC et échangeaient des données avec n'importe qui à l'autre extrémité de la connexion. <br><br>  Au fur et à mesure que les ordinateurs à usage général devenaient plus sophistiqués, une interface utilisateur graphique (GUI) et un tout nouveau monde d'applications simultanées, y compris des applications de terminal, sont apparus. <br><br>  Mais il y avait un problème: comment une application de terminal peut-elle interagir avec une autre application de ligne de commande s'exécutant sur la même machine?  Et comment connecter physiquement un câble série entre deux applications s'exécutant sur le même ordinateur? <br><br><h2>  Apparence de pseudo-terminal (PTY) </h2><br>  Dans le monde * NIX, le problème a été résolu en introduisant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pseudo-terminal (PTY)</a> . <br><br>  PTY émule un équipement de télécommunications série dans un ordinateur en exposant les pseudo-appareils maître et esclave («maître» et «esclave»): les applications de terminal se connectent au pseudo-appareil maître, et les applications de ligne de commande (par exemple, des shells comme cmd, PowerShell et bash) se connectent au pseudo-appareil esclave.  Lorsqu'un client terminal transmet du texte et / ou des commandes de contrôle (codées sous forme de texte) au pseudo-périphérique maître, le texte est traduit vers l'esclave qui lui est associé.  Le texte de l'application est envoyé au pseudo-périphérique esclave, puis renvoyé au maître et donc au terminal.  Les données sont toujours envoyées / reçues de manière asynchrone. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Application / Shell pseudo-terminal</font></i> <br><br>  Il est important de noter que le pseudo-périphérique «esclave» émule le comportement du terminal physique et convertit les caractères de commande en signaux POSIX.  Par exemple, si l'utilisateur entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CTRL + C</a> dans le terminal, la valeur ASCII pour CTRL + C (0x03) est envoyée via le maître.  Lorsqu'elle est reçue sur un pseudo-périphérique esclave, la valeur 0x03 est supprimée du flux d'entrée et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">signal SIGINT est</a> généré. <br><br>  Cette infrastructure PTY est largement utilisée par les applications de terminaux * NIX, les gestionnaires de panneaux de texte (par exemple, écran, tmux), etc.  Ces applications appellent <code>openpty()</code> , qui renvoie une paire de descripteurs de fichiers (fd) pour le maître et l'esclave PTY.  Ensuite, l'application peut créer / exécuter une application de ligne de commande enfant (par exemple, bash), qui utilise ses esclaves fd pour écouter et renvoyer du texte au terminal connecté. <br><br>  Ce mécanisme permet aux applications du terminal de «parler» directement avec les applications de ligne de commande s'exécutant localement, tout comme un terminal parlerait à un ordinateur distant via une connexion série / réseau. <br><br><h2>  Quoi, pas de pseudo-console Windows? </h2><br>  Comme nous l'avons vu dans l'article précédent, bien que la console Windows soit conceptuellement similaire au terminal * NIX traditionnel, elle diffère de plusieurs manières clés, en particulier aux niveaux les plus bas, ce qui peut poser des problèmes aux développeurs d'applications de ligne de commande Windows, aux terminaux / consoles tiers et au serveur. applications: <br><br><ol><li>  <b>Windows n'a pas l'infrastructure PTY</b> : lorsqu'un utilisateur lance une application en ligne de commande (par exemple, Cmd, PowerShell, wsl, ipconfig, etc.), Windows lui-même «connecte» une instance de console nouvelle ou existante à l'application. </li><li>  <b>Windows interfère avec les consoles et les applications serveur tierces</b> : Windows (actuellement) ne donne pas aux terminaux un moyen de fournir des canaux de communication par lesquels ils souhaitent interagir avec une application en ligne de commande.  Les terminaux tiers doivent créer des consoles hors de l'écran, y envoyer des données saisies par l'utilisateur et supprimer la sortie en la redessinant sur le propre écran de la console tierce! </li><li>  <b>Seul Windows possède l'API console</b> : les applications de ligne de commande Windows s'appuient sur l'API Win32 Consol, ce qui réduit la portabilité du code, car toutes les autres plates-formes prennent en charge le texte / VT, pas l'API. </li><li>  <b>Accès à distance non standard</b> : la dépendance des applications de ligne de commande sur l'API Consol complique considérablement les scripts d'interaction et d'accès à distance. </li></ol><br><h2>  Que faire </h2><br>  De <b>nombreux</b> développeurs ont souvent demandé un mécanisme de type PTY sous Windows, en particulier ceux qui travaillent avec ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker et OpenSSH. <br><br>  Même Peter Bright, l'éditeur technologique d'Ars Technica, m'a demandé de mettre en œuvre le mécanisme PTY quelques jours plus tard lorsque j'ai commencé à travailler dans l'équipe de la console: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Et récemment encore: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Eh bien, nous l'avons finalement fait: <b>nous avons créé une pseudo-console pour Windows</b> : <br><br><h1>  Bienvenue dans la pseudo console Windows (ConPTY) </h1><br>  Depuis la formation de la Console Team il y a environ quatre ans, le groupe s'est engagé dans la refonte de la console Windows et des mécanismes internes de la ligne de commande.  Dans le même temps, nous avons régulièrement et soigneusement examiné les problèmes décrits ci-dessus et de nombreux autres problèmes et problèmes connexes.  Mais l'infrastructure et le code n'étaient pas prêts à rendre possible la sortie de la pseudo-console ... jusqu'à maintenant! <br><br>  La nouvelle infrastructure de pseudo-console Windows (ConPTY), l'API et certaines autres modifications connexes élimineront / atténueront toute une classe de problèmes ... <b>sans rompre la compatibilité descendante avec les applications de ligne de commande existantes</b> ! <br><br><blockquote>  La nouvelle API Win32 ConPTY (la documentation officielle sera publiée prochainement) est désormais disponible dans les dernières versions d'initiés de Windows 10 et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Windows 10 Insider Preview correspondant</a> .  Ils apparaîtront dans la prochaine version majeure de Windows 10 (quelque part à l'automne / hiver 2018). </blockquote><br><h2>  Architecture console / ConHost </h2><br>  Pour comprendre ConPTY, vous devez étudier l'architecture de la console Windows, ou plutôt ... ConHost! <br><br>  Il est important de comprendre que bien que ConHost implémente tout ce que vous voyez et connaissez en tant qu'application de console Windows, ConHost contient et implémente également la plupart de l'infrastructure de ligne de commande Windows!  Désormais, <b>ConHost devient un véritable "nœud de console"</b> , prenant en charge toutes les applications de ligne de commande et / ou les applications GUI qui interagissent avec les applications de ligne de commande! <br><br>  <b>Comment?</b>  <b>Pourquoi?</b>  <b>Quoi?</b>  Examinons de plus près. <br><br>  Voici une vue d'ensemble de l'architecture de la console interne / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Par rapport à l'architecture de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> , ConHost contient maintenant plusieurs modules supplémentaires pour le traitement VT et le nouveau module ConPTY qui implémente les API ouvertes: <br><br><ul><li>  <b>API ConPTY</b> : Les nouvelles API Win32 ConPTY fournissent un mécanisme similaire au modèle POSIX PTY, mais en réfraction Windows. </li><li>  <b>Interactivité VT</b> : reçoit le texte d'entrée au codage UTF-8, convertit chaque caractère de texte affiché dans l'enregistrement <code>INPUT_RECORD</code> correspondant et l'enregistre dans le tampon d'entrée.  Il traite également les séquences d'échappement, telles que 0x03 (CTRL + C), les convertissant en <code>KEY_EVENT_RECORDS</code> , qui produisent l'action d'échappement appropriée. </li><li>  <b>VT Renderer</b> : génère les séquences VT nécessaires pour déplacer le curseur et rendre le texte et le style dans les zones du tampon de sortie qui ont changé par rapport à l'image précédente. </li></ul><br>  OK, mais qu'est-ce que cela signifie vraiment? <br><br><h2>  Comment fonctionnent les applications de ligne de commande Windows? </h2><br>  Pour mieux comprendre l'impact de la nouvelle infrastructure ConPTY, regardons comment la console Windows et les applications en ligne de commande ont jusqu'à présent fonctionné. <br><br>  Chaque fois qu'un utilisateur lance une application en ligne de commande telle que Cmd, PowerShell ou ssh, Windows crée un nouveau processus Win32 dans lequel il charge le binaire exécutable de l'application et toutes les dépendances (ressources ou bibliothèques). <br><br>  Un processus nouvellement créé hérite généralement des descripteurs stdin et stdout de son parent.  Si le processus parent était un processus d'interface graphique Windows, les descripteurs stdin et stdout sont manquants, donc Windows déploiera et attachera la nouvelle application à la nouvelle instance de console.  La communication entre les applications de ligne de commande et leur console est transmise via ConDrv. <br><br>  Par exemple, lors du démarrage à partir d'une instance PowerShell sans privilèges élevés, le nouveau processus d'application héritera des descripteurs parent stdin / stdout et, par conséquent, recevra les données d'entrée et sortira la sortie sur la même console que le parent. <br><br><blockquote>  Ici, nous devons faire une réservation, car dans certains cas, des applications de ligne de commande sont lancées attachées à une <i>nouvelle</i> instance de la console, en particulier pour des raisons de sécurité, mais la description ci-dessus est généralement vraie. </blockquote><br>  En fin de compte, lorsque l'application de ligne de commande / shell démarre, Windows la connecte à l'instance de console (ConHost.exe) via ConDrv: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  Comment fonctionne ConHost? </h2><br>  Chaque fois qu'une application de ligne de commande est en cours d'exécution, Windows connecte l'application à une instance nouvelle ou existante de ConHost.  L'application et son instance de console sont connectées via le pilote de console en mode noyau (ConDrv), qui envoie / reçoit des messages IOCTL contenant des demandes d'appel API sérialisées et / ou des données texte. <br><br>  Historiquement, comme indiqué dans un article précédent, le travail de ConHost est relativement simple aujourd'hui: <br><br><ul><li>  L'utilisateur génère une entrée à partir du clavier / souris / stylo / pavé tactile, qui est converti en <code>KEY_EVENT_RECORD</code> ou <code>MOUSE_EVENT_RECORD</code> et stocké dans le tampon d'entrée. </li><li>  Le tampon d'entrée est vidé un enregistrement à la fois, effectuant les actions d'entrée demandées, telles que l'affichage du texte à l'écran, le déplacement du curseur, le copier / coller du texte, etc.  Beaucoup de ces actions modifient le contenu du tampon de sortie.  Ces zones modifiées sont enregistrées par le moteur d'état ConHost. </li><li>  Dans chaque cadre, la console affiche les zones modifiées du tampon de sortie. </li></ul><br>  Lorsque l'application de ligne de commande appelle l'API de la console Windows, les appels d'API sont sérialisés en messages IOCTL et envoyés via le pilote ConDrv.  Il délivre ensuite des messages IOCTL à la console connectée, qui décode et exécute l'appel d'API demandé.  Les valeurs renvoyées / sorties sont sérialisées vers le message IOCTL et renvoyées à l'application via ConDrv. <br><br><h2>  ConHost: Contribuer au passé pour l'avenir </h2><br>  Microsoft s'efforce de maintenir la compatibilité descendante avec les applications et outils existants dans la mesure du possible.  Surtout pour la ligne de commande.  En fait, les versions 32 bits de Windows 10 peuvent toujours exécuter la plupart / la plupart des applications et exécutables Win16 16 bits! <br><br>  Comme mentionné ci-dessus, l'un des rôles clés de ConHost est de fournir des services à ses applications de ligne de commande, en particulier les applications héritées qui appellent et s'appuient sur l'API de la console Win32.  Désormais, ConHost propose de nouveaux services: <br><br><ul><li>  Infrastructure transparente de type PTY pour la communication avec les consoles et terminaux modernes </li><li>  Mise à niveau d'applications héritées / traditionnelles en ligne de commande <br><ul><li>  Réception et conversion de texte / VT UTF-8 en enregistrements d'entrée (comme s'ils étaient entrés par l'utilisateur) </li><li>  API de console appelle l'application hébergée, mettant à jour son tampon de sortie en conséquence </li><li>  Afficher les zones modifiées du tampon de sortie en encodage UTF-8, texte / VT </li></ul></li></ul><br>  Voici un exemple de la façon dont une application de console moderne communique avec une application de ligne de commande via ConPTY ConHost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  Dans ce nouveau modèle: <br><br><ol><li>  Console: <br><ol><li>  Crée ses propres canaux de communication </li><li>  Appelle l'API ConPTY pour créer ConPTY, forçant Windows à exécuter une instance de ConHost connectée à l'autre extrémité des canaux </li><li>  Crée une instance d'une application de ligne de commande (par exemple PowerShell) connectée à ConHost, comme d'habitude </li></ol></li><li>  Conhost: <br><ol><li>  Lit le texte / VT UTF-8 à l'entrée et le convertit en enregistrements <code>INPUT_RECORD</code> , qui sont envoyés à l'application de ligne de commande </li><li>  Effectuer des appels d'API à partir d'une application de ligne de commande qui peut modifier le contenu du tampon de sortie </li><li>  Affiche les modifications du tampon de sortie dans l'encodage UTF-8 (texte / VT) et envoie le texte reçu à sa console </li></ol></li><li>  Application en ligne de commande: <br><ol><li>  Il fonctionne comme d'habitude, lit l'entrée et appelle l'API de la console, n'ayant aucune idée que son ConPTY ConHost traduit l'entrée et la sortie de / vers UTF-8! </li></ol></li></ol><br>  Le dernier moment est important!  Lorsque l'ancienne application de ligne de commande utilise des appels à l'API de console comme <code>WriteConsoleOutput(...)</code> , le texte spécifié est écrit dans le tampon de sortie ConHost correspondant.  Périodiquement, ConHost affiche les zones modifiées du tampon de sortie sous forme de texte / VT, qui est renvoyé via stdout à la console. <br><br>  En fin de compte, même les applications de ligne de commande traditionnelles de l'extérieur "parlent" le texte / TV <b>sans aucun changement</b> ! <br><br>  Grâce à la nouvelle infrastructure ConPTY, les consoles tierces peuvent désormais interagir directement avec les applications de ligne de commande modernes et traditionnelles et les échanger toutes en texte / TV. <br><br><h2>  Interaction à distance avec les applications de ligne de commande Windows </h2><br>  Le mécanisme décrit ci-dessus fonctionne correctement sur un ordinateur, mais aide également lors de l'interaction, par exemple, avec une instance PowerShell sur un ordinateur Windows distant ou dans un conteneur. <br><br>  Il y a un problème lors du démarrage d'une application de ligne de commande à distance (c'est-à-dire sur des ordinateurs distants, des serveurs ou des conteneurs).  Le fait est que les applications de ligne de commande sur les machines distantes communiquent avec l'instance ConHost locale, car les messages IOCTL ne sont pas conçus pour être transmis sur le réseau.  Comment transférer les entrées de la console locale vers la machine distante et comment obtenir les sorties de l'application qui s'y exécute?  De plus, que faire des machines Mac et Linux, où il y a des terminaux mais pas de consoles compatibles Windows? <br><br>  Ainsi, afin de contrôler à distance la machine Windows, nous avons besoin d'une sorte de courtier en communication qui peut sérialiser les données en toute transparence sur le réseau, gérer la durée de vie de l'instance d'application, etc. <br><br>  Peut-être quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ssh</a> ? <br><br>  Heureusement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSH a été</a> récemment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">porté sur Windows</a> et ajouté comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">option supplémentaire à Windows 10</a> .  PowerShell Core utilise également ssh comme l'un des protocoles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communication à distance PowerShell Core pris en</a> charge.  Et pour ceux qui exécutent Windows PowerShell, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communication à distance de Windows PowerShell</a> est toujours une option acceptable. <br><br>  Voyons comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSH pour Windows</a> vous permet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">désormais</a> de contrôler à distance les shells <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows</a> et les applications en ligne de commande: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH comprend actuellement certaines complications indésirables: <br><br><ol><li>  Utilisateur: <br><ol><li>  Démarre le client ssh et Windows connecte l'instance de console comme d'habitude </li><li>  Entre du texte dans la console, qui envoie des frappes au client ssh </li></ol></li><li>  client ssh: <br><ol><li>  Lit l'entrée sous forme d'octets de données texte </li><li>  Envoie des données texte sur le réseau au service d'écoute sshd </li></ol></li><li>  Le service sshd passe par plusieurs étapes: <br><ol><li>  Lance le shell par défaut (par exemple, Cmd), ce qui oblige Windows à créer et à connecter une nouvelle instance de la console </li><li>  Recherche et se connecte à la console de l'instance Cmd </li><li>  Déplace la console hors écran (et / ou la cache) </li><li>  Envoie l'entrée reçue du client ssh à la console hors écran comme entrée </li></ol></li><li>  L'instance cmd fonctionne comme toujours: <br><ol><li>  Collecte les entrées du service sshd </li><li>  Est-ce que le travail </li><li>  Appelle l'API de la console pour rendre / styliser le texte, déplacer le curseur, etc. </li></ol></li><li>  Console [hors écran] attachée: <br><ol><li>  Effectuez des appels d'API en mettant à jour le tampon de sortie. </li></ol></li><li>  Service Sshd: <br><ol><li>  Scraps le tampon de sortie de la console hors écran, trouve les différences, les encode en texte / VT et renvoie ... </li></ol></li><li>  Un client ssh qui envoie du texte ... </li><li>  Console qui affiche du texte </li></ol><br>  <b>Amusant, non?</b>  <b>Pas du tout!</b>  Dans cette situation, beaucoup de choses peuvent mal tourner, en particulier dans le processus de simulation et d'envoi des entrées utilisateur et de vidage du tampon de sortie d'une console hors écran.  Cela entraîne une instabilité, des plantages, une corruption des données, une consommation d'énergie excessive, etc.  De plus, toutes les applications ne suppriment pas seulement le texte lui-même, mais aussi ses propriétés, c'est pourquoi la mise en forme et la couleur sont perdues! <br><br><h3>  Travail à distance avec ConHost et ConPTY modernes </h3><br>  <b>Certes, nous pouvons améliorer la situation?</b>  Oui, bien sûr, nous pouvons - apportons quelques modifications architecturales et appliquons notre nouveau ConPTY: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  Le diagramme montre que le circuit a changé comme suit: <br><br><ol><li>  Utilisateur: <br><ol><li>  Démarre le client ssh et Windows connecte l'instance de console comme d'habitude </li><li>  Entre du texte dans la console, qui envoie des frappes au client ssh </li></ol></li><li>  client ssh: <br><ol><li>  Lit l'entrée sous forme d'octets de données texte </li><li>  Envoie des données texte sur le réseau au service d'écoute sshd </li></ol></li><li>  Service Sshd: <br><ol><li>  Crée des canaux stdin / stdout </li><li>  Appelle l'API ConPTY pour lancer ConPTY </li><li>  Démarre une instance Cmd connectée à l'autre extrémité de ConPTY.  Windows lance et monte une nouvelle instance de ConHost </li></ol></li><li>  L'instance cmd fonctionne comme toujours: <br><ol><li>  Collecte les entrées du service sshd </li><li>  Est-ce que le travail </li><li>  Appelle l'API de la console pour rendre / styliser le texte, déplacer le curseur, etc. </li></ol></li><li>  Instance ConPTY ConHost: <br><ol><li>  Effectuez des appels d'API en mettant à jour le tampon de sortie. </li><li>  Affiche les régions modifiées du tampon de sortie sous forme de texte / VT encodé UTF-8, qui est renvoyé à la console / au terminal via ssh </li></ol></li></ol><br>  Cette approche utilisant ConPTY est clairement plus propre et plus simple pour le service sshd.  Les appels à l'API de la console Windows sont entièrement effectués dans l'instance ConHost de l'application de ligne de commande, qui convertit toutes les modifications visibles en texte / VT.  Celui qui se connecte à ConHost, il n'a pas besoin de savoir que l'application y appelle l'API Console, et ne génère pas de texte / VT! <br><br>  Convenez que ce nouveau mécanisme d'accès distant ConPTY conduit à une architecture élégante, cohérente et simple.  Combinées aux puissantes fonctionnalités intégrées à ConHost, à la prise en charge des anciennes applications et à l'affichage des modifications des applications qui appellent les API de la console de la console sous forme de texte / VT, la nouvelle infrastructure ConHost et ConPTY nous aide à déplacer le passé dans le futur. <br><br><h1>  API ConPTY et comment l'utiliser </h1><br><blockquote>  L'API ConPTY est disponible dans la version actuelle du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Windows 10 Insider Preview</a> . </blockquote><br>  Maintenant, je suis sûr que vous ne pouvez pas attendre de voir du code;) <br><br>  Jetez un œil aux déclarations de l'API: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  L'API ConPTY ci-dessus expose essentiellement trois nouvelles fonctions à utiliser: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Crée pty avec dimension dans les colonnes <code>w</code> et les lignes <code>h</code> , en utilisant les canaux créés par l'appelant: <br><ul><li>  <code>size</code> : largeur et hauteur (en caractères) du tampon ConPTY </li><li>  <code>hInput</code> : pour écrire des données d'entrée dans PTY sous forme de séquences texte / VT dans le codage UTF-8 </li><li>  <code>hOutput</code> : pour lire la sortie de PTY sous forme de séquences texte / VT dans le codage UTF-8 </li><li>  <code>dwFlags</code> : Valeurs possibles: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> créé tentera d'hériter de la position du curseur de l'application de terminal parent </li></ul></li><li>  <code>phPC</code> : handle de console pour généré par ConPty </li></ul></li><li>  <b>Retours</b> : succès / échec.  En cas de succès, phPC contient le handle du nouveau ConPty </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Redimensionne le tampon ConPTY interne pour afficher une largeur et une hauteur spécifiques </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   —   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API — ,       ,     Windows   …   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ConEmuMaximus5</a> —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    —  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  «  VT»     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    …   !  ,       , <b></b> ! :D <br><br>       ,   , <i></i>    ,   <i></i>  .   —            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420853/">https://habr.com/ru/post/fr420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420837/index.html">Test de matrices RAID logicielles pour les périphériques NVMe à l'aide de la méthodologie SNIA</a></li>
<li><a href="../fr420841/index.html">Correctif pré-hospitalier ou «Hey Swagger! Où sont mes erreurs? "</a></li>
<li><a href="../fr420843/index.html">7 septembre, Iekaterinbourg - une réunion pour les développeurs .NET</a></li>
<li><a href="../fr420845/index.html">Apprivoiser l'obstiné à l'aide d'une béquille: le trou de l'adaptateur Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../fr420847/index.html">Introduction à la programmation des shaders pour les mises en page</a></li>
<li><a href="../fr420857/index.html">Itinérance Wi-Fi transparente: la théorie en pratique</a></li>
<li><a href="../fr420859/index.html">À la question de Wirth et des chaînes</a></li>
<li><a href="../fr420861/index.html">Se préparer pour C ++ 20. Étude de cas réelle Coroutines TS</a></li>
<li><a href="../fr420863/index.html">Comme nous l'avons fait le premier smartphone russe, a continué</a></li>
<li><a href="../fr420865/index.html">Le principe de moindre action. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>