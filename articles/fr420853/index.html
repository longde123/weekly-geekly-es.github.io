<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ó üë®üèº‚Äç‚öïÔ∏è üôçüèæ D√©couvrez la pseudo console Windows (ConPTY) üëßüèæ ‚ú® üôåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article publi√© le 2 ao√ªt 2018 

 Il s'agit du deuxi√®me article sur la ligne de commande Windows, o√π nous discuterons de la nouvelle infrastructure et ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©couvrez la pseudo console Windows (ConPTY)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publi√©</a> le 2 ao√ªt 2018</font> <br><br>  Il s'agit du deuxi√®me article sur la ligne de commande Windows, o√π nous discuterons de la nouvelle infrastructure et des interfaces de programmation de la pseudo-console Windows, c'est-√†-dire de la pseudo console Windows (ConPTY): pourquoi nous l'avons d√©velopp√©e, pourquoi elle est n√©cessaire, comment elle fonctionne, comment l'utiliser et bien plus encore. <br><br>  Dans le dernier article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Le grave h√©ritage du pass√©.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Probl√®mes de ligne de commande Windows ¬ª,</a> nous avons parl√© des conditions pr√©alables √† l'√©mergence du terminal et de l'√©volution de la ligne de commande dans Windows, et avons √©galement commenc√© √† √©tudier la structure interne de la console Windows et l'infrastructure de ligne de commande Windows.  Nous avons √©galement discut√© des nombreux avantages et inconv√©nients majeurs de la console Windows. <br><br>  L'un des inconv√©nients est que Windows essaie d'√™tre ¬´utile¬ª, mais il interf√®re avec les d√©veloppeurs de consoles alternatives et tierces, les d√©veloppeurs de services, etc.  Lors de la cr√©ation d'une console ou d'un service, les d√©veloppeurs doivent avoir acc√®s aux canaux de communication par lesquels leur terminal / service √©change des donn√©es avec des applications en ligne de commande, ou leur donner acc√®s.  Dans le monde * NIX, ce n'est pas un probl√®me car * NIX fournit une infrastructure pseudo-terminal (PTY) qui facilite la cr√©ation de canaux de communication pour une console ou un service.  Mais sous Windows, ce n'√©tait pas ... <br><br>  <i><b>... jusqu'√† maintenant!</b></i> <br><a name="habracut"></a><br><h1>  Du TTY au PTY </h1><br>  Avant de parler en d√©tail de notre d√©veloppement, revenons bri√®vement au d√©veloppement des terminaux. <br><br><h2>  Au d√©but √©tait ATS </h2><br>  Comme discut√© dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> , aux premiers jours de l'informatique, les utilisateurs contr√¥laient les ordinateurs √† l'aide de t√©l√©types √©lectrom√©caniques (TTY) connect√©s √† un ordinateur via une sorte de canal de communication s√©rie (g√©n√©ralement via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une boucle de courant de 20 mA</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson et Dennis Ritchie (debout) travaillent sur le t√©l√©type DEC PDP-11 (messages sans affichage √©lectronique)</i></font> <br><br><h3>  Distribution des terminaux </h3><br>  Les t√©l√©types ont √©t√© remplac√©s par des terminaux informatis√©s √† affichage √©lectronique (g√©n√©ralement des √©crans CRT).  En r√®gle g√©n√©rale, les terminaux sont des dispositifs tr√®s simples (d'o√π le terme ¬´terminal stupide¬ª), contenant uniquement l'√©lectronique et la puissance de traitement n√©cessaires pour les t√¢ches suivantes: <br><br><ol><li>  R√©ception de la saisie de texte depuis le clavier. </li><li>  Mise en m√©moire tampon du texte saisi sur une seule ligne (y compris l'√©dition locale avant l'envoi). </li><li>  Envoi / r√©ception de texte sur un canal s√©rie (g√©n√©ralement via l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface RS-232</a> autrefois omnipr√©sente). </li><li>  Affichage du texte re√ßu sur l'√©cran du terminal. </li></ol><br>  Malgr√© sa simplicit√© (ou peut-√™tre gr√¢ce √† elle), les terminaux sont rapidement devenus le principal moyen de gestion des mini-ordinateurs, des mainframes et des serveurs: la plupart des op√©rateurs de saisie de donn√©es, des op√©rateurs informatiques, des administrateurs syst√®me, des scientifiques, des chercheurs, des d√©veloppeurs de logiciels et des sommit√©s de l'industrie ont travaill√© sur les terminaux DEC, IBM, Wyse et bien d'autres. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">L'amiral Grace Hopper dans son bureau avec un terminal DEC VT220 sur son bureau</font></i> <br><br><h3>  Distribution de terminaux logiciels </h3><br>  Depuis le milieu des ann√©es 80, au lieu de terminaux sp√©cialis√©s, des ordinateurs √† usage g√©n√©ral ont progressivement commenc√© √† √™tre utilis√©s, qui sont devenus plus abordables, populaires et puissants.  De nombreux premiers PC et autres ordinateurs des ann√©es 80 avaient des applications de terminal qui ouvraient la connexion RS-232 au PC et √©changeaient des donn√©es avec n'importe qui √† l'autre extr√©mit√© de la connexion. <br><br>  Au fur et √† mesure que les ordinateurs √† usage g√©n√©ral devenaient plus sophistiqu√©s, une interface utilisateur graphique (GUI) et un tout nouveau monde d'applications simultan√©es, y compris des applications de terminal, sont apparus. <br><br>  Mais il y avait un probl√®me: comment une application de terminal peut-elle interagir avec une autre application de ligne de commande s'ex√©cutant sur la m√™me machine?  Et comment connecter physiquement un c√¢ble s√©rie entre deux applications s'ex√©cutant sur le m√™me ordinateur? <br><br><h2>  Apparence de pseudo-terminal (PTY) </h2><br>  Dans le monde * NIX, le probl√®me a √©t√© r√©solu en introduisant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pseudo-terminal (PTY)</a> . <br><br>  PTY √©mule un √©quipement de t√©l√©communications s√©rie dans un ordinateur en exposant les pseudo-appareils ma√Ætre et esclave (¬´ma√Ætre¬ª et ¬´esclave¬ª): les applications de terminal se connectent au pseudo-appareil ma√Ætre, et les applications de ligne de commande (par exemple, des shells comme cmd, PowerShell et bash) se connectent au pseudo-appareil esclave.  Lorsqu'un client terminal transmet du texte et / ou des commandes de contr√¥le (cod√©es sous forme de texte) au pseudo-p√©riph√©rique ma√Ætre, le texte est traduit vers l'esclave qui lui est associ√©.  Le texte de l'application est envoy√© au pseudo-p√©riph√©rique esclave, puis renvoy√© au ma√Ætre et donc au terminal.  Les donn√©es sont toujours envoy√©es / re√ßues de mani√®re asynchrone. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Application / Shell pseudo-terminal</font></i> <br><br>  Il est important de noter que le pseudo-p√©riph√©rique ¬´esclave¬ª √©mule le comportement du terminal physique et convertit les caract√®res de commande en signaux POSIX.  Par exemple, si l'utilisateur entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CTRL + C</a> dans le terminal, la valeur ASCII pour CTRL + C (0x03) est envoy√©e via le ma√Ætre.  Lorsqu'elle est re√ßue sur un pseudo-p√©riph√©rique esclave, la valeur 0x03 est supprim√©e du flux d'entr√©e et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">signal SIGINT est</a> g√©n√©r√©. <br><br>  Cette infrastructure PTY est largement utilis√©e par les applications de terminaux * NIX, les gestionnaires de panneaux de texte (par exemple, √©cran, tmux), etc.  Ces applications appellent <code>openpty()</code> , qui renvoie une paire de descripteurs de fichiers (fd) pour le ma√Ætre et l'esclave PTY.  Ensuite, l'application peut cr√©er / ex√©cuter une application de ligne de commande enfant (par exemple, bash), qui utilise ses esclaves fd pour √©couter et renvoyer du texte au terminal connect√©. <br><br>  Ce m√©canisme permet aux applications du terminal de ¬´parler¬ª directement avec les applications de ligne de commande s'ex√©cutant localement, tout comme un terminal parlerait √† un ordinateur distant via une connexion s√©rie / r√©seau. <br><br><h2>  Quoi, pas de pseudo-console Windows? </h2><br>  Comme nous l'avons vu dans l'article pr√©c√©dent, bien que la console Windows soit conceptuellement similaire au terminal * NIX traditionnel, elle diff√®re de plusieurs mani√®res cl√©s, en particulier aux niveaux les plus bas, ce qui peut poser des probl√®mes aux d√©veloppeurs d'applications de ligne de commande Windows, aux terminaux / consoles tiers et au serveur. applications: <br><br><ol><li>  <b>Windows n'a pas l'infrastructure PTY</b> : lorsqu'un utilisateur lance une application en ligne de commande (par exemple, Cmd, PowerShell, wsl, ipconfig, etc.), Windows lui-m√™me ¬´connecte¬ª une instance de console nouvelle ou existante √† l'application. </li><li>  <b>Windows interf√®re avec les consoles et les applications serveur tierces</b> : Windows (actuellement) ne donne pas aux terminaux un moyen de fournir des canaux de communication par lesquels ils souhaitent interagir avec une application en ligne de commande.  Les terminaux tiers doivent cr√©er des consoles hors de l'√©cran, y envoyer des donn√©es saisies par l'utilisateur et supprimer la sortie en la redessinant sur le propre √©cran de la console tierce! </li><li>  <b>Seul Windows poss√®de l'API console</b> : les applications de ligne de commande Windows s'appuient sur l'API Win32 Consol, ce qui r√©duit la portabilit√© du code, car toutes les autres plates-formes prennent en charge le texte / VT, pas l'API. </li><li>  <b>Acc√®s √† distance non standard</b> : la d√©pendance des applications de ligne de commande sur l'API Consol complique consid√©rablement les scripts d'interaction et d'acc√®s √† distance. </li></ol><br><h2>  Que faire </h2><br>  De <b>nombreux</b> d√©veloppeurs ont souvent demand√© un m√©canisme de type PTY sous Windows, en particulier ceux qui travaillent avec ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker et OpenSSH. <br><br>  M√™me Peter Bright, l'√©diteur technologique d'Ars Technica, m'a demand√© de mettre en ≈ìuvre le m√©canisme PTY quelques jours plus tard lorsque j'ai commenc√© √† travailler dans l'√©quipe de la console: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Et r√©cemment encore: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Eh bien, nous l'avons finalement fait: <b>nous avons cr√©√© une pseudo-console pour Windows</b> : <br><br><h1>  Bienvenue dans la pseudo console Windows (ConPTY) </h1><br>  Depuis la formation de la Console Team il y a environ quatre ans, le groupe s'est engag√© dans la refonte de la console Windows et des m√©canismes internes de la ligne de commande.  Dans le m√™me temps, nous avons r√©guli√®rement et soigneusement examin√© les probl√®mes d√©crits ci-dessus et de nombreux autres probl√®mes et probl√®mes connexes.  Mais l'infrastructure et le code n'√©taient pas pr√™ts √† rendre possible la sortie de la pseudo-console ... jusqu'√† maintenant! <br><br>  La nouvelle infrastructure de pseudo-console Windows (ConPTY), l'API et certaines autres modifications connexes √©limineront / att√©nueront toute une classe de probl√®mes ... <b>sans rompre la compatibilit√© descendante avec les applications de ligne de commande existantes</b> ! <br><br><blockquote>  La nouvelle API Win32 ConPTY (la documentation officielle sera publi√©e prochainement) est d√©sormais disponible dans les derni√®res versions d'initi√©s de Windows 10 et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Windows 10 Insider Preview correspondant</a> .  Ils appara√Ætront dans la prochaine version majeure de Windows 10 (quelque part √† l'automne / hiver 2018). </blockquote><br><h2>  Architecture console / ConHost </h2><br>  Pour comprendre ConPTY, vous devez √©tudier l'architecture de la console Windows, ou plut√¥t ... ConHost! <br><br>  Il est important de comprendre que bien que ConHost impl√©mente tout ce que vous voyez et connaissez en tant qu'application de console Windows, ConHost contient et impl√©mente √©galement la plupart de l'infrastructure de ligne de commande Windows!  D√©sormais, <b>ConHost devient un v√©ritable "n≈ìud de console"</b> , prenant en charge toutes les applications de ligne de commande et / ou les applications GUI qui interagissent avec les applications de ligne de commande! <br><br>  <b>Comment?</b>  <b>Pourquoi?</b>  <b>Quoi?</b>  Examinons de plus pr√®s. <br><br>  Voici une vue d'ensemble de l'architecture de la console interne / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Par rapport √† l'architecture de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> , ConHost contient maintenant plusieurs modules suppl√©mentaires pour le traitement VT et le nouveau module ConPTY qui impl√©mente les API ouvertes: <br><br><ul><li>  <b>API ConPTY</b> : Les nouvelles API Win32 ConPTY fournissent un m√©canisme similaire au mod√®le POSIX PTY, mais en r√©fraction Windows. </li><li>  <b>Interactivit√© VT</b> : re√ßoit le texte d'entr√©e au codage UTF-8, convertit chaque caract√®re de texte affich√© dans l'enregistrement <code>INPUT_RECORD</code> correspondant et l'enregistre dans le tampon d'entr√©e.  Il traite √©galement les s√©quences d'√©chappement, telles que 0x03 (CTRL + C), les convertissant en <code>KEY_EVENT_RECORDS</code> , qui produisent l'action d'√©chappement appropri√©e. </li><li>  <b>VT Renderer</b> : g√©n√®re les s√©quences VT n√©cessaires pour d√©placer le curseur et rendre le texte et le style dans les zones du tampon de sortie qui ont chang√© par rapport √† l'image pr√©c√©dente. </li></ul><br>  OK, mais qu'est-ce que cela signifie vraiment? <br><br><h2>  Comment fonctionnent les applications de ligne de commande Windows? </h2><br>  Pour mieux comprendre l'impact de la nouvelle infrastructure ConPTY, regardons comment la console Windows et les applications en ligne de commande ont jusqu'√† pr√©sent fonctionn√©. <br><br>  Chaque fois qu'un utilisateur lance une application en ligne de commande telle que Cmd, PowerShell ou ssh, Windows cr√©e un nouveau processus Win32 dans lequel il charge le binaire ex√©cutable de l'application et toutes les d√©pendances (ressources ou biblioth√®ques). <br><br>  Un processus nouvellement cr√©√© h√©rite g√©n√©ralement des descripteurs stdin et stdout de son parent.  Si le processus parent √©tait un processus d'interface graphique Windows, les descripteurs stdin et stdout sont manquants, donc Windows d√©ploiera et attachera la nouvelle application √† la nouvelle instance de console.  La communication entre les applications de ligne de commande et leur console est transmise via ConDrv. <br><br>  Par exemple, lors du d√©marrage √† partir d'une instance PowerShell sans privil√®ges √©lev√©s, le nouveau processus d'application h√©ritera des descripteurs parent stdin / stdout et, par cons√©quent, recevra les donn√©es d'entr√©e et sortira la sortie sur la m√™me console que le parent. <br><br><blockquote>  Ici, nous devons faire une r√©servation, car dans certains cas, des applications de ligne de commande sont lanc√©es attach√©es √† une <i>nouvelle</i> instance de la console, en particulier pour des raisons de s√©curit√©, mais la description ci-dessus est g√©n√©ralement vraie. </blockquote><br>  En fin de compte, lorsque l'application de ligne de commande / shell d√©marre, Windows la connecte √† l'instance de console (ConHost.exe) via ConDrv: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  Comment fonctionne ConHost? </h2><br>  Chaque fois qu'une application de ligne de commande est en cours d'ex√©cution, Windows connecte l'application √† une instance nouvelle ou existante de ConHost.  L'application et son instance de console sont connect√©es via le pilote de console en mode noyau (ConDrv), qui envoie / re√ßoit des messages IOCTL contenant des demandes d'appel API s√©rialis√©es et / ou des donn√©es texte. <br><br>  Historiquement, comme indiqu√© dans un article pr√©c√©dent, le travail de ConHost est relativement simple aujourd'hui: <br><br><ul><li>  L'utilisateur g√©n√®re une entr√©e √† partir du clavier / souris / stylo / pav√© tactile, qui est converti en <code>KEY_EVENT_RECORD</code> ou <code>MOUSE_EVENT_RECORD</code> et stock√© dans le tampon d'entr√©e. </li><li>  Le tampon d'entr√©e est vid√© un enregistrement √† la fois, effectuant les actions d'entr√©e demand√©es, telles que l'affichage du texte √† l'√©cran, le d√©placement du curseur, le copier / coller du texte, etc.  Beaucoup de ces actions modifient le contenu du tampon de sortie.  Ces zones modifi√©es sont enregistr√©es par le moteur d'√©tat ConHost. </li><li>  Dans chaque cadre, la console affiche les zones modifi√©es du tampon de sortie. </li></ul><br>  Lorsque l'application de ligne de commande appelle l'API de la console Windows, les appels d'API sont s√©rialis√©s en messages IOCTL et envoy√©s via le pilote ConDrv.  Il d√©livre ensuite des messages IOCTL √† la console connect√©e, qui d√©code et ex√©cute l'appel d'API demand√©.  Les valeurs renvoy√©es / sorties sont s√©rialis√©es vers le message IOCTL et renvoy√©es √† l'application via ConDrv. <br><br><h2>  ConHost: Contribuer au pass√© pour l'avenir </h2><br>  Microsoft s'efforce de maintenir la compatibilit√© descendante avec les applications et outils existants dans la mesure du possible.  Surtout pour la ligne de commande.  En fait, les versions 32 bits de Windows 10 peuvent toujours ex√©cuter la plupart / la plupart des applications et ex√©cutables Win16 16 bits! <br><br>  Comme mentionn√© ci-dessus, l'un des r√¥les cl√©s de ConHost est de fournir des services √† ses applications de ligne de commande, en particulier les applications h√©rit√©es qui appellent et s'appuient sur l'API de la console Win32.  D√©sormais, ConHost propose de nouveaux services: <br><br><ul><li>  Infrastructure transparente de type PTY pour la communication avec les consoles et terminaux modernes </li><li>  Mise √† niveau d'applications h√©rit√©es / traditionnelles en ligne de commande <br><ul><li>  R√©ception et conversion de texte / VT UTF-8 en enregistrements d'entr√©e (comme s'ils √©taient entr√©s par l'utilisateur) </li><li>  API de console appelle l'application h√©berg√©e, mettant √† jour son tampon de sortie en cons√©quence </li><li>  Afficher les zones modifi√©es du tampon de sortie en encodage UTF-8, texte / VT </li></ul></li></ul><br>  Voici un exemple de la fa√ßon dont une application de console moderne communique avec une application de ligne de commande via ConPTY ConHost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  Dans ce nouveau mod√®le: <br><br><ol><li>  Console: <br><ol><li>  Cr√©e ses propres canaux de communication </li><li>  Appelle l'API ConPTY pour cr√©er ConPTY, for√ßant Windows √† ex√©cuter une instance de ConHost connect√©e √† l'autre extr√©mit√© des canaux </li><li>  Cr√©e une instance d'une application de ligne de commande (par exemple PowerShell) connect√©e √† ConHost, comme d'habitude </li></ol></li><li>  Conhost: <br><ol><li>  Lit le texte / VT UTF-8 √† l'entr√©e et le convertit en enregistrements <code>INPUT_RECORD</code> , qui sont envoy√©s √† l'application de ligne de commande </li><li>  Effectuer des appels d'API √† partir d'une application de ligne de commande qui peut modifier le contenu du tampon de sortie </li><li>  Affiche les modifications du tampon de sortie dans l'encodage UTF-8 (texte / VT) et envoie le texte re√ßu √† sa console </li></ol></li><li>  Application en ligne de commande: <br><ol><li>  Il fonctionne comme d'habitude, lit l'entr√©e et appelle l'API de la console, n'ayant aucune id√©e que son ConPTY ConHost traduit l'entr√©e et la sortie de / vers UTF-8! </li></ol></li></ol><br>  Le dernier moment est important!  Lorsque l'ancienne application de ligne de commande utilise des appels √† l'API de console comme <code>WriteConsoleOutput(...)</code> , le texte sp√©cifi√© est √©crit dans le tampon de sortie ConHost correspondant.  P√©riodiquement, ConHost affiche les zones modifi√©es du tampon de sortie sous forme de texte / VT, qui est renvoy√© via stdout √† la console. <br><br>  En fin de compte, m√™me les applications de ligne de commande traditionnelles de l'ext√©rieur "parlent" le texte / TV <b>sans aucun changement</b> ! <br><br>  Gr√¢ce √† la nouvelle infrastructure ConPTY, les consoles tierces peuvent d√©sormais interagir directement avec les applications de ligne de commande modernes et traditionnelles et les √©changer toutes en texte / TV. <br><br><h2>  Interaction √† distance avec les applications de ligne de commande Windows </h2><br>  Le m√©canisme d√©crit ci-dessus fonctionne correctement sur un ordinateur, mais aide √©galement lors de l'interaction, par exemple, avec une instance PowerShell sur un ordinateur Windows distant ou dans un conteneur. <br><br>  Il y a un probl√®me lors du d√©marrage d'une application de ligne de commande √† distance (c'est-√†-dire sur des ordinateurs distants, des serveurs ou des conteneurs).  Le fait est que les applications de ligne de commande sur les machines distantes communiquent avec l'instance ConHost locale, car les messages IOCTL ne sont pas con√ßus pour √™tre transmis sur le r√©seau.  Comment transf√©rer les entr√©es de la console locale vers la machine distante et comment obtenir les sorties de l'application qui s'y ex√©cute?  De plus, que faire des machines Mac et Linux, o√π il y a des terminaux mais pas de consoles compatibles Windows? <br><br>  Ainsi, afin de contr√¥ler √† distance la machine Windows, nous avons besoin d'une sorte de courtier en communication qui peut s√©rialiser les donn√©es en toute transparence sur le r√©seau, g√©rer la dur√©e de vie de l'instance d'application, etc. <br><br>  Peut-√™tre quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ssh</a> ? <br><br>  Heureusement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSH a √©t√©</a> r√©cemment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">port√© sur Windows</a> et ajout√© comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">option suppl√©mentaire √† Windows 10</a> .  PowerShell Core utilise √©galement ssh comme l'un des protocoles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communication √† distance PowerShell Core pris en</a> charge.  Et pour ceux qui ex√©cutent Windows PowerShell, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communication √† distance de Windows PowerShell</a> est toujours une option acceptable. <br><br>  Voyons comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenSSH pour Windows</a> vous permet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©sormais</a> de contr√¥ler √† distance les shells <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows</a> et les applications en ligne de commande: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH comprend actuellement certaines complications ind√©sirables: <br><br><ol><li>  Utilisateur: <br><ol><li>  D√©marre le client ssh et Windows connecte l'instance de console comme d'habitude </li><li>  Entre du texte dans la console, qui envoie des frappes au client ssh </li></ol></li><li>  client ssh: <br><ol><li>  Lit l'entr√©e sous forme d'octets de donn√©es texte </li><li>  Envoie des donn√©es texte sur le r√©seau au service d'√©coute sshd </li></ol></li><li>  Le service sshd passe par plusieurs √©tapes: <br><ol><li>  Lance le shell par d√©faut (par exemple, Cmd), ce qui oblige Windows √† cr√©er et √† connecter une nouvelle instance de la console </li><li>  Recherche et se connecte √† la console de l'instance Cmd </li><li>  D√©place la console hors √©cran (et / ou la cache) </li><li>  Envoie l'entr√©e re√ßue du client ssh √† la console hors √©cran comme entr√©e </li></ol></li><li>  L'instance cmd fonctionne comme toujours: <br><ol><li>  Collecte les entr√©es du service sshd </li><li>  Est-ce que le travail </li><li>  Appelle l'API de la console pour rendre / styliser le texte, d√©placer le curseur, etc. </li></ol></li><li>  Console [hors √©cran] attach√©e: <br><ol><li>  Effectuez des appels d'API en mettant √† jour le tampon de sortie. </li></ol></li><li>  Service Sshd: <br><ol><li>  Scraps le tampon de sortie de la console hors √©cran, trouve les diff√©rences, les encode en texte / VT et renvoie ... </li></ol></li><li>  Un client ssh qui envoie du texte ... </li><li>  Console qui affiche du texte </li></ol><br>  <b>Amusant, non?</b>  <b>Pas du tout!</b>  Dans cette situation, beaucoup de choses peuvent mal tourner, en particulier dans le processus de simulation et d'envoi des entr√©es utilisateur et de vidage du tampon de sortie d'une console hors √©cran.  Cela entra√Æne une instabilit√©, des plantages, une corruption des donn√©es, une consommation d'√©nergie excessive, etc.  De plus, toutes les applications ne suppriment pas seulement le texte lui-m√™me, mais aussi ses propri√©t√©s, c'est pourquoi la mise en forme et la couleur sont perdues! <br><br><h3>  Travail √† distance avec ConHost et ConPTY modernes </h3><br>  <b>Certes, nous pouvons am√©liorer la situation?</b>  Oui, bien s√ªr, nous pouvons - apportons quelques modifications architecturales et appliquons notre nouveau ConPTY: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  Le diagramme montre que le circuit a chang√© comme suit: <br><br><ol><li>  Utilisateur: <br><ol><li>  D√©marre le client ssh et Windows connecte l'instance de console comme d'habitude </li><li>  Entre du texte dans la console, qui envoie des frappes au client ssh </li></ol></li><li>  client ssh: <br><ol><li>  Lit l'entr√©e sous forme d'octets de donn√©es texte </li><li>  Envoie des donn√©es texte sur le r√©seau au service d'√©coute sshd </li></ol></li><li>  Service Sshd: <br><ol><li>  Cr√©e des canaux stdin / stdout </li><li>  Appelle l'API ConPTY pour lancer ConPTY </li><li>  D√©marre une instance Cmd connect√©e √† l'autre extr√©mit√© de ConPTY.  Windows lance et monte une nouvelle instance de ConHost </li></ol></li><li>  L'instance cmd fonctionne comme toujours: <br><ol><li>  Collecte les entr√©es du service sshd </li><li>  Est-ce que le travail </li><li>  Appelle l'API de la console pour rendre / styliser le texte, d√©placer le curseur, etc. </li></ol></li><li>  Instance ConPTY ConHost: <br><ol><li>  Effectuez des appels d'API en mettant √† jour le tampon de sortie. </li><li>  Affiche les r√©gions modifi√©es du tampon de sortie sous forme de texte / VT encod√© UTF-8, qui est renvoy√© √† la console / au terminal via ssh </li></ol></li></ol><br>  Cette approche utilisant ConPTY est clairement plus propre et plus simple pour le service sshd.  Les appels √† l'API de la console Windows sont enti√®rement effectu√©s dans l'instance ConHost de l'application de ligne de commande, qui convertit toutes les modifications visibles en texte / VT.  Celui qui se connecte √† ConHost, il n'a pas besoin de savoir que l'application y appelle l'API Console, et ne g√©n√®re pas de texte / VT! <br><br>  Convenez que ce nouveau m√©canisme d'acc√®s distant ConPTY conduit √† une architecture √©l√©gante, coh√©rente et simple.  Combin√©es aux puissantes fonctionnalit√©s int√©gr√©es √† ConHost, √† la prise en charge des anciennes applications et √† l'affichage des modifications des applications qui appellent les API de la console de la console sous forme de texte / VT, la nouvelle infrastructure ConHost et ConPTY nous aide √† d√©placer le pass√© dans le futur. <br><br><h1>  API ConPTY et comment l'utiliser </h1><br><blockquote>  L'API ConPTY est disponible dans la version actuelle du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK Windows 10 Insider Preview</a> . </blockquote><br>  Maintenant, je suis s√ªr que vous ne pouvez pas attendre de voir du code;) <br><br>  Jetez un ≈ìil aux d√©clarations de l'API: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  L'API ConPTY ci-dessus expose essentiellement trois nouvelles fonctions √† utiliser: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Cr√©e pty avec dimension dans les colonnes <code>w</code> et les lignes <code>h</code> , en utilisant les canaux cr√©√©s par l'appelant: <br><ul><li>  <code>size</code> : largeur et hauteur (en caract√®res) du tampon ConPTY </li><li>  <code>hInput</code> : pour √©crire des donn√©es d'entr√©e dans PTY sous forme de s√©quences texte / VT dans le codage UTF-8 </li><li>  <code>hOutput</code> : pour lire la sortie de PTY sous forme de s√©quences texte / VT dans le codage UTF-8 </li><li>  <code>dwFlags</code> : Valeurs possibles: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> cr√©√© tentera d'h√©riter de la position du curseur de l'application de terminal parent </li></ul></li><li>  <code>phPC</code> : handle de console pour g√©n√©r√© par ConPty </li></ul></li><li>  <b>Retours</b> : succ√®s / √©chec.  En cas de succ√®s, phPC contient le handle du nouveau ConPty </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Redimensionne le tampon ConPTY interne pour afficher une largeur et une hauteur sp√©cifiques </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   ‚Äî   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API ‚Äî ,       ,     Windows   ‚Ä¶   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ConEmuMaximus5</a> ‚Äî    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    ‚Äî  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  ¬´  VT¬ª     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    ‚Ä¶   !  ,       , <b></b> ! :D <br><br>       ,   , <i></i>    ,   <i></i>  .   ‚Äî            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420853/">https://habr.com/ru/post/fr420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420837/index.html">Test de matrices RAID logicielles pour les p√©riph√©riques NVMe √† l'aide de la m√©thodologie SNIA</a></li>
<li><a href="../fr420841/index.html">Correctif pr√©-hospitalier ou ¬´Hey Swagger! O√π sont mes erreurs? "</a></li>
<li><a href="../fr420843/index.html">7 septembre, Iekaterinbourg - une r√©union pour les d√©veloppeurs .NET</a></li>
<li><a href="../fr420845/index.html">Apprivoiser l'obstin√© √† l'aide d'une b√©quille: le trou de l'adaptateur Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../fr420847/index.html">Introduction √† la programmation des shaders pour les mises en page</a></li>
<li><a href="../fr420857/index.html">Itin√©rance Wi-Fi transparente: la th√©orie en pratique</a></li>
<li><a href="../fr420859/index.html">√Ä la question de Wirth et des cha√Ænes</a></li>
<li><a href="../fr420861/index.html">Se pr√©parer pour C ++ 20. √âtude de cas r√©elle Coroutines TS</a></li>
<li><a href="../fr420863/index.html">Comme nous l'avons fait le premier smartphone russe, a continu√©</a></li>
<li><a href="../fr420865/index.html">Le principe de moindre action. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>