<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‡ğŸ» ğŸŒ— ğŸ¦† Pengembangan di monorepositori. Laporan Yandex ğŸ¤ŸğŸ¿ ğŸ½ ğŸ¤¹ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Azat Razetdinov, saya sudah berada di Yandex selama 12 tahun, saya mengelola layanan pengembangan antarmuka di Y. Real Estate. Hari ini saya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan di monorepositori. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/469021/">  Nama saya Azat Razetdinov, saya sudah berada di Yandex selama 12 tahun, saya mengelola layanan pengembangan antarmuka di Y. Real Estate.  Hari ini saya ingin berbicara tentang monorepositori.  Jika Anda hanya memiliki satu repositori di tempat kerja - selamat, Anda sudah tinggal dalam satu repositori.  Sekarang tentang mengapa orang lain membutuhkannya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/v_/vr/gi/v_vrgiiye4emmloccesmmogxlim.jpeg"></a> <br><br><blockquote>  Menurut Marina Pereskokova, kepala layanan pengembangan API Yandex.Map, kakek saya menanam monorepa, dan monorepa tumbuh sangat besar. </blockquote><br><a name="habracut"></a>  - Kami di Yandex mencoba berbagai cara untuk bekerja dengan beberapa layanan dan memerhatikan - segera setelah Anda memiliki lebih dari satu layanan, bagian-bagian yang tak terelakkan mulai muncul: model, utilitas, alat, potongan kode, templat, komponen.  Pertanyaannya adalah: di mana harus meletakkan semua ini?  Tentu saja, Anda dapat menyalin-menempel, kami dapat melakukannya, tetapi saya menginginkannya dengan indah. <br><br>  Kami bahkan mencoba entitas seperti eksternal SVN bagi mereka yang ingat.  Kami mencoba git submodules.  Kami mencoba paket npm ketika muncul.  Tapi semua ini entah bagaimana panjang, atau semacamnya.  Anda mendukung paket apa pun, menemukan kesalahan, melakukan koreksi.  Kemudian Anda perlu merilis versi baru, melalui layanan, meng-upgrade ke versi ini, memeriksa apakah semuanya berfungsi, menjalankan tes, menemukan kesalahan, kembali ke repositori perpustakaan, memperbaiki kesalahan, merilis versi baru, melalui layanan, memperbarui dan sebagainya lingkaran.  Itu hanya berubah menjadi rasa sakit. <br><br><img src="https://habrastorage.org/webt/rq/ie/uo/rqieuoverzzoq6wrhpujf4qz8vw.jpeg"><br><br>  Kemudian kami berpikir tentang apakah kami harus berkumpul dalam satu repositori.  Ambil semua layanan dan perpustakaan kami, transfer dan kembangkan dalam satu repositori.  Ada banyak keuntungan.  Saya tidak mengatakan bahwa pendekatan ini ideal, tetapi dari sudut pandang perusahaan dan bahkan departemen dari beberapa kelompok, keuntungan yang signifikan muncul. <br><br>  Bagi saya pribadi, yang paling penting adalah atomicity dari commit, bahwa sebagai pengembang, saya dapat memperbaiki perpustakaan, mem-bypass semua layanan, membuat perubahan, menjalankan tes, memverifikasi bahwa semuanya berfungsi, dorong ke master, dan semua ini dengan satu perubahan.  Tidak perlu membangun kembali, menerbitkan, memperbarui apa pun. <br><br>  Tetapi jika semuanya begitu baik, mengapa belum semua orang pindah ke repositori mono?  Tentu saja, ada juga kelemahannya. <br><br><img src="https://habrastorage.org/webt/bb/1u/pv/bb1upvyscjzd_csjkvxce0yh9a0.jpeg"><br><br>  Menurut Marina Pereskokova, kepala layanan pengembangan API Yandex.Map, kakek saya menanam monorepa, dan monorepa telah tumbuh besar, besar.  Ini adalah fakta, bukan lelucon.  Jika Anda mengumpulkan banyak layanan dalam satu repositori, itu pasti akan tumbuh.  Dan jika kita berbicara tentang git, yang mengeluarkan semua file plus seluruh sejarahnya untuk seluruh keberadaan kode Anda, ini adalah ruang disk yang agak besar. <br><br>  Masalah kedua adalah injeksi ke master.  Anda menyiapkan permintaan kumpulan, melewati ulasan, Anda siap untuk menggabungkannya.  Dan ternyata seseorang berhasil mengungguli Anda dan Anda perlu menyelesaikan konflik.  Anda menyelesaikan konflik, sekali lagi siap untuk dituangkan, dan sekali lagi Anda tidak punya waktu.  Masalah ini sedang diselesaikan, ada menggabungkan sistem antrian, ketika robot khusus mengotomatiskan pekerjaan ini, permintaan jalur, mencoba untuk menyelesaikan konflik, jika bisa.  Jika dia tidak bisa, dia memanggil penulis.  Namun, masalah seperti itu ada.  Ada beberapa solusi yang meningkatkannya, tetapi Anda harus mengingatnya. <br><br>  Ini adalah poin teknis, tetapi ada juga yang bersifat organisasi.  Misalkan Anda memiliki beberapa tim yang membuat beberapa layanan berbeda.  Ketika mereka pindah ke satu repositori, tanggung jawab mereka mulai terkikis.  Karena mereka membuat rilis, diluncurkan dalam produksi - sesuatu pecah.  Kami memulai tanya jawab.  Ternyata itu adalah pengembang dari tim lain yang telah melakukan sesuatu pada kode umum, kami menariknya, melepaskannya, tidak melihatnya, semuanya rusak.  Dan tidak jelas siapa yang bertanggung jawab.  Penting untuk memahami dan menggunakan semua metode yang mungkin: tes unit, tes integrasi, linter - segala sesuatu yang mungkin untuk mengurangi masalah ini dari pengaruh satu kode pada semua layanan lainnya. <br><br>  Menariknya, siapa lagi selain Yandex dan pemain lain yang menggunakan repositori mono?  Cukup banyak orang.  Ini adalah React, Jest, Babel, Ember, Meteor, Angular.  Orang-orang mengerti - lebih mudah, lebih murah, lebih cepat untuk mengembangkan dan menerbitkan paket-paket npm dari satu repositori daripada dari beberapa repositori kecil.  Hal yang paling menarik adalah seiring dengan proses ini, alat untuk bekerja dengan monorepositori mulai berkembang.  Hanya tentang mereka dan saya ingin bicara. <br><br>  Semuanya dimulai dengan membuat monorepositori.  Alat ujung depan paling terkenal di dunia untuk ini disebut lerna. <br><br><img src="https://habrastorage.org/webt/2a/n9/my/2an9myv3k_dokzcizjfhshporh0.jpeg"><br><br>  Cukup buka repositori Anda, jalankan npx lerna init, ia akan mengajukan beberapa pertanyaan sugestif dan menambahkan beberapa entitas ke copy pekerjaan Anda.  Entitas pertama adalah konfigurasi lerna.json, yang menunjukkan setidaknya dua bidang: versi ujung ke ujung dari semua paket Anda dan lokasi paket Anda di sistem file.  Secara default, semua paket ditambahkan ke folder paket, tetapi Anda dapat mengonfigurasinya sesuka Anda, Anda bahkan dapat menambahkannya ke root, lerna juga dapat mengambilnya. <br><br>  Langkah selanjutnya adalah bagaimana menambahkan repositori Anda ke repositori mono, bagaimana cara mentransfernya? <br><br>  Apa yang ingin kita capai?  Kemungkinan besar, Anda sudah memiliki semacam repositori, dalam hal ini A dan B. <br><br><img src="https://habrastorage.org/webt/gd/yl/d0/gdyld0xwsgytno9mhaz7g-t-ikc.jpeg"><br><br>  Ini adalah dua layanan, masing-masing dalam repositori sendiri, dan kami ingin mentransfernya ke mono-repositori baru di folder paket, lebih disukai dengan riwayat komit, sehingga Anda dapat membuat kesalahan git, log git, dan sebagainya. <br><br><img src="https://habrastorage.org/webt/rd/td/z1/rdtdz1-3hqxrjvgsgf4tb4wq5fy.jpeg"><br><br>  Ada alat impor lerna untuk ini.  Anda cukup menentukan lokasi repositori Anda, dan lerna mentransfernya ke monorepo Anda.  Pada saat yang sama, dia, pertama, mengambil daftar semua komit, memodifikasi setiap komit, mengubah path ke file dari root ke paket / nama_paket, dan menerapkannya satu demi satu, menindihnya dalam repositori mono Anda.  Bahkan, setiap komit menyiapkan, mengubah jalur file di dalamnya.  Intinya, lerna melakukan git magic untuk Anda.  Jika Anda membaca kode sumber, hanya ada perintah git yang dieksekusi dalam urutan tertentu. <br><br>  Ini cara pertama.  Ini memiliki kelemahan: jika Anda bekerja di perusahaan di mana ada proses produksi, di mana orang sudah menulis semacam kode, dan Anda akan menerjemahkannya ke dalam monorep, kecil kemungkinan Anda akan melakukannya dalam satu hari.  Anda perlu mencari tahu, mengkonfigurasi, memverifikasi bahwa semuanya dimulai, tes.  Tetapi orang tidak punya pekerjaan, mereka terus melakukan sesuatu. <br><br><img src="https://habrastorage.org/webt/u5/w4/je/u5w4jenpjqspns44ok1grkidxug.jpeg"><br><br>  Untuk transisi yang lebih mulus ke mono-rap, ada alat seperti git subtree.  Ini adalah hal yang lebih canggih, tetapi pada saat yang sama berasal dari git, yang memungkinkan Anda untuk tidak hanya mengimpor repositori individual ke repositori mono dengan semacam awalan, tetapi juga bertukar perubahan bolak-balik.  Yaitu, tim yang membuat layanan dapat dengan mudah dikembangkan lebih lanjut dalam repositori sendiri, sementara Anda dapat menarik perubahannya melalui tarikan git subtree, melakukan perubahan sendiri dan mendorongnya kembali melalui git subtree push.  Dan hidup seperti ini dalam masa transisi selama yang Anda suka. <br><br>  Dan ketika Anda telah mengatur semuanya, memeriksa apakah semua tes sedang berjalan, penyebaran berfungsi, seluruh CI / CD dikonfigurasikan, Anda dapat mengatakan bahwa inilah saatnya untuk melanjutkan.  Untuk masa transisi, solusi hebat, saya sarankan. <br><br>  Ya, kami memindahkan repositori kami ke dalam satu mono-repositori, tetapi di mana sihirnya?  Tetapi kami ingin menyoroti bagian-bagian umum dan entah bagaimana menggunakannya.  Dan untuk ini ada mekanisme "ketergantungan mengikat".  Apa yang mengikat ketergantungan?  Ada alat bootstrap lerna, sebuah perintah yang mirip dengan npm install, jalankan npm install di semua paket Anda. <br><br><img src="https://habrastorage.org/webt/kh/tg/cw/khtgcwjnzf2kjxoy61wgmkevopo.jpeg"><br><br>  Tapi itu belum semuanya.  Selain itu, dia mencari dependensi internal.  Anda dapat menggunakan yang lain dalam satu paket di dalam repositori Anda.  Misalnya, jika Anda memiliki paket A, yang tergantung pada Jest dalam kasus ini, ada paket B, yang tergantung pada Jest dan paket A. Jika paket A adalah alat yang umum, komponen yang umum, maka paket B adalah layanan yang memilikinya menggunakan. <br><br>  Lerna mendefinisikan dependensi internal seperti itu dan secara fisik menggantikan dependensi ini dengan tautan simbolis pada sistem file. <br><br><img src="https://habrastorage.org/webt/or/lk/am/orlkampii1gcc_kxupnpc5k-hxy.jpeg"><br><br><img src="https://habrastorage.org/webt/ia/dp/oo/iadpoole-lvonlr_o30aqvbc8no.jpeg"><br><br>  Setelah Anda menjalankan lerna bootstrap, tepat di dalam folder node_modules, alih-alih folder fisik A, tautan simbolik muncul yang mengarah ke folder dengan paket A. Ini sangat nyaman karena Anda dapat mengedit kode di dalam paket A dan segera memeriksa hasilnya dalam paket B , jalankan tes, integrasi, unit, apa pun yang Anda inginkan.  Pengembangan sangat disederhanakan, Anda tidak perlu lagi memasang kembali paket A, menerbitkan, menghubungkan paket B. Hanya diperbaiki di sini, diperiksa di sana. <br><br>  Harap dicatat bahwa jika Anda melihat folder node_modules, dan di sana dan di sana bercanda, kami telah menduplikasi modul yang diinstal.  Secara umum, ini adalah waktu yang cukup lama ketika Anda memulai lerna bootstrap, tunggu sampai semuanya berhenti, karena ada banyak jenis pekerjaan berulang, dependensi duplikat diperoleh di setiap paket. <br><br>  Untuk mempercepat pemasangan dependensi, mekanisme untuk meningkatkan dependensi digunakan.  Idenya sangat sederhana: Anda dapat mengambil dependensi umum ke root node_modules. <br><br><img src="https://habrastorage.org/webt/so/lj/kr/soljkrixddhlkrth4w95b1bk5ek.jpeg"><br><br>  Jika Anda menentukan opsi --hoist (ini merupakan peningkatan dari bahasa Inggris), maka hampir semua dependensi hanya akan pindah ke root node_modules.  Dan itu hampir selalu berhasil.  Noda diatur sedemikian rupa sehingga jika dia belum menemukan ketergantungan pada levelnya, dia mulai mencari satu level lebih tinggi, jika tidak ada, level lain lebih tinggi dan seterusnya.  Hampir tidak ada yang berubah.  Tetapi pada kenyataannya, kami mengambil dan mendupuplikasi dependensi kami, mentransfer dependensi ke root. <br><br>  Pada saat yang sama, lerna cukup pintar.  Jika ada konflik, misalnya, jika paket A menggunakan Jest versi 1, dan paket B menggunakan versi 2, maka salah satu dari mereka akan muncul, dan yang kedua akan tetap pada levelnya.  Ini kira-kira apa yang sebenarnya dilakukan npm di dalam folder normal node_modules, ia juga mencoba untuk mendeduplikasi dependensi dan secara maksimal membawanya ke root. <br><br>  Sayangnya, keajaiban ini tidak selalu berhasil, terutama dengan alat, dengan Babel, dengan Jest.  Sering terjadi bahwa ia mulai, karena Jest memiliki sistem sendiri untuk menyelesaikan modul, Noda mulai ketinggalan, melempar kesalahan.  Khusus untuk kasus-kasus seperti itu ketika alat tidak mengatasi dependensi yang telah pergi ke root, ada opsi nohoist, yang memungkinkan Anda untuk menunjukkan bahwa paket-paket ini tidak ditransfer ke root, biarkan di tempat. <br><br><img src="https://habrastorage.org/webt/2z/sx/9z/2zsx9zvtkofxy_2uk4au8x1uxbu.jpeg"><br><br>  Jika Anda menentukan --nohoist = jest, maka semua dependensi kecuali jest akan masuk ke root, dan jest akan tetap pada level paket.  Tidak heran saya memberikan contoh seperti itu - itu lelucon yang memiliki masalah dengan perilaku ini, dan nohoist membantu dengan ini. <br><br>  Kelebihan lain dari pemulihan ketergantungan: <br><br><img src="https://habrastorage.org/webt/yp/1n/ur/yp1nurrr-zokokzjy7rgzvmozzi.jpeg"><br><br>  Jika sebelum itu Anda memiliki paket-lock.json terpisah untuk setiap layanan, untuk setiap paket, maka ketika Anda hoyed, semuanya bergerak naik, dan satu-satunya paket-lock.json tersisa.  Ini nyaman dari sudut pandang menuangkan ke master, menyelesaikan konflik.  Setelah semua orang terbunuh, dan hanya itu. <br><br>  Tetapi bagaimana lerna mencapai ini?  Dia cukup agresif dengan npm.  Ketika Anda menentukan hoist, ia mengambil package.json Anda di root, mencadangkannya, menggantikan yang lain, menggabungkan semua dependensi Anda ke dalamnya, menjalankan npm install, hampir semuanya dimasukkan ke dalam root.  Kemudian package.json sementara ini menghapus, mengembalikan milik Anda.  Jika setelah itu Anda menjalankan perintah dengan npm, misalnya, hapus npm, npm tidak akan mengerti apa yang terjadi, mengapa semua dependensi tiba-tiba muncul di root.  Lerna melanggar level abstraksi, dia merangkak ke alat, yang berada di bawah levelnya. <br><br>  Orang-orang dari Yarn adalah orang pertama yang memperhatikan masalah ini dan berkata: apa yang kami siksa, biarkan kami melakukan semuanya untuk Anda secara asli, sehingga semuanya di luar kotak berfungsi. <br><br><img src="https://habrastorage.org/webt/4l/0q/yb/4l0qybezxp0nwi_fulfgleb11oe.jpeg"><br><br>  Benang sudah dapat melakukan hal yang sama di luar kotak: mengikat dependensi, jika ia melihat bahwa paket B tergantung pada paket A, ia akan membuat symlink untuk Anda, gratis.  Dia tahu cara meningkatkan dependensi, apakah secara default, semuanya menambahkan hingga ke root.  Seperti lerna, ia dapat meninggalkan satu-satunya benang. Buka di akar repositori.  Semua orang lain mengaitkannya. Biarkan Anda tidak perlu lagi. <br><br><img src="https://habrastorage.org/webt/wj/bu/e7/wjbue7nf67iucirzohdpfxk75xe.jpeg"><br><br>  Ini dikonfigurasi dengan cara yang sama.  Sayangnya, benang mengasumsikan bahwa semua pengaturan ditambahkan ke package.json, saya tahu ada orang yang mencoba mengambil semua pengaturan alat dari sana, hanya menyisakan minimum.  Sayangnya, benang belum belajar untuk menentukan ini di file lain, hanya package.json.  Ada dua opsi baru, satu baru dan satu wajib.  Karena diasumsikan bahwa repositori root tidak akan pernah mempublikasikan, benang memerlukan private = true untuk ditentukan di sana. <br><br>  Tetapi pengaturan untuk ruang kerja disimpan dalam kunci yang sama.  Pengaturannya sangat mirip dengan pengaturan lerna, ada bidang paket tempat Anda menentukan lokasi paket Anda, dan ada opsi nohoist, sangat mirip dengan opsi nohoist di lerna.  Cukup tentukan pengaturan ini dan dapatkan struktur yang sama seperti di lerna.  Semua dependensi umum pergi ke root, dan yang ditentukan dalam kunci nohoist tetap pada level mereka. <br><br><img src="https://habrastorage.org/webt/6w/rj/8c/6wrj8cm-b68sgcbsm0gstgmwzm8.jpeg"><br><br>  Bagian terbaiknya adalah lerna dapat bekerja dengan benang dan mengambil pengaturannya.  Cukup menentukan dua bidang di lerna.json, lerna akan segera mengerti bahwa Anda menggunakan benang, masuk ke package.json, dapatkan semua pengaturan dari sana dan bekerja dengannya.  Kedua alat ini sudah saling mengenal dan bekerja sama. <br><br><img src="https://habrastorage.org/webt/q5/hs/em/q5hsemi5za3meeg_s7zjj0sak4g.jpeg"><br><br>  Dan mengapa dukungan belum dilakukan pada npm jika begitu banyak perusahaan besar menggunakan repositori mono? <br><br><img src="https://habrastorage.org/webt/h1/al/n6/h1aln6qeuati1bbhmojwgtao1xo.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sub></sup> </h5><br>  Mereka mengatakan bahwa semuanya akan terjadi, tetapi dalam versi ketujuh.  Dukungan dasar di ketujuh, diperpanjang - di kedelapan.  Posting ini dirilis sebulan yang lalu, tetapi pada saat yang sama, tanggalnya masih belum diketahui kapan jam ketujuh akan dirilis.  Kami menunggu dia akhirnya mengejar ketinggalan dengan benang. <br><br>  Ketika Anda memiliki beberapa layanan dalam satu mono-repositori, muncul pertanyaan bagaimana cara mengelolanya agar tidak masuk ke setiap folder, bukan menjalankan perintah?  Ada operasi besar untuk ini. <br><br><img src="https://habrastorage.org/webt/8f/9z/lk/8f9zlkf-hdow1itwrmkiczqm5pk.jpeg"><br><br><img src="https://habrastorage.org/webt/ux/z_/ed/uxz_edv1rkl4bjlydo8q8pndty8.jpeg"><br><br>  Benang memiliki perintah ruang kerja benang, diikuti oleh nama paket dan nama perintah.  Karena benang dari kotak, tidak seperti npm, dapat melakukan ketiga hal: menjalankan perintahnya sendiri, menambahkan ketergantungan pada lelucon, menjalankan skrip dari package.json, seperti tes, dan juga dapat menjalankan file yang dapat dieksekusi dari folder node_modules / .bin.  Dia akan mengajar untuk Anda dengan bantuan heuristik, ia akan mengerti apa yang Anda inginkan.  Sangat nyaman untuk menggunakan ruang kerja benang untuk operasi titik pada satu paket. <br><br>  Ada perintah serupa yang memungkinkan Anda untuk mengeksekusi perintah pada semua paket yang Anda miliki. <br><br><img src="https://habrastorage.org/webt/-e/yn/vd/-eynvdikhrjyxn0we1fkw0loqcw.jpeg"><br><br>  Tunjukkan hanya perintah Anda dengan semua argumen. <br><br><img src="https://habrastorage.org/webt/qk/_t/lx/qk_tlxutn7it2owurvm5ne444o8.jpeg"><br><br>  Dari pro, sangat mudah untuk menjalankan tim yang berbeda.  Dari minus, misalnya, tidak mungkin menjalankan perintah shell.  Misalkan saya ingin menghapus semua folder modul simpul, saya tidak dapat menjalankan thread workspace run rm. <br>  Tidak mungkin menentukan daftar paket, misalnya, saya ingin menghapus ketergantungan hanya dalam dua paket, hanya satu per satu atau secara terpisah. <br><br>  Yah, dia jatuh pada kesalahan pertama.  Jika saya ingin menghapus ketergantungan dari semua paket - dan pada kenyataannya, hanya dua dari mereka yang memilikinya, tetapi saya tidak ingin memikirkan di mana itu, tetapi saya hanya ingin menghapusnya - maka benang tidak akan membiarkannya, maka benang tidak akan membiarkannya, akan jatuh pada situasi pertama di mana paket ini tidak dalam dependensi.  Ini sangat tidak nyaman, kadang-kadang Anda ingin mengabaikan kesalahan, jalankan melalui semua paket. <br><br><img src="https://habrastorage.org/webt/gv/bj/ax/gvbjax1gepdak6jwcxpf7q9u8ea.jpeg"><br><br>  Lerna memiliki toolkit yang jauh lebih menarik, ada dua perintah run dan exec yang terpisah.  Run dapat mengeksekusi skrip dari package.json, dan tidak seperti benang, ia dapat memfilter semuanya dengan paket, Anda dapat menentukan --scope, Anda dapat menggunakan tanda bintang, gumpalan, semuanya cukup universal.  Anda dapat menjalankan operasi ini secara paralel, Anda dapat mengabaikan kesalahan melalui saklar --no-bail. <br><br><img src="https://habrastorage.org/webt/j9/f_/km/j9f_kmpn1tkhfr88nsjykrunm5g.jpeg"><br><br>  Exec sangat mirip.  Tidak seperti benang, ini memungkinkan Anda untuk tidak hanya menjalankan file yang dapat dieksekusi dari node_modules.bin, tetapi juga menjalankan perintah shell sembarang.  Misalnya, Anda dapat menghapus node_modules atau menjalankan beberapa make, apa pun yang Anda inginkan.  Dan opsi yang sama didukung. <br><br><img src="https://habrastorage.org/webt/t4/f4/tv/t4f4tv2z0646cgezhzwamag6qgm.jpeg"><br><br>  Alat yang sangat nyaman, beberapa plus.  Ini adalah kasus ketika lerna merobek benang, berada pada tingkat abstraksi yang tepat.  Inilah yang dibutuhkan lerna: sederhanakan pekerjaan dengan beberapa paket di monorepe. <br><br>  Dengan monoreps ada satu lagi minus.  Ketika Anda memiliki CI / CD, Anda tidak dapat mengoptimalkannya.  Semakin banyak layanan yang Anda miliki, semakin lama waktu yang dibutuhkan.  Misalkan Anda mulai menguji semua layanan untuk setiap permintaan kumpulan, dan semakin banyak, semakin lama waktu yang dibutuhkan.  Operasi selektif dapat digunakan untuk mengoptimalkan proses ini.  Saya akan menyebutkan tiga cara berbeda.  Dua yang pertama dapat digunakan tidak hanya di monorep, tetapi juga di proyek Anda, jika karena alasan tertentu Anda tidak menggunakan metode ini. <br><br>  Yang pertama adalah tahap-lint, yang memungkinkan Anda untuk menjalankan linter, menguji, semua yang Anda inginkan, hanya ke file yang telah diubah atau akan dikomit dalam komit ini.  Jalankan seluruh serat bukan pada seluruh proyek Anda, tetapi hanya pada file yang telah berubah. <br><br><img src="https://habrastorage.org/webt/7v/qj/4z/7vqj4zxxvjc3fyt_bs5nfbk85nc.jpeg"><br><br><img src="https://habrastorage.org/webt/dx/if/eu/dxifeu43kvhxy7kthspwefr2o8m.jpeg"><br><br>  Penyiapannya sangat sederhana.  Masukkan lint-staged, husky, pre-commit-hooks dan katakan bahwa ketika mengubah file js apa saja, Anda perlu menjalankan eslint.  Dengan demikian, pemeriksaan pra-komitmen sangat dipercepat.  Apalagi jika Anda memiliki banyak layanan, repositori mono yang sangat besar.  Maka menjalankan eslint pada semua file terlalu mahal, dan Anda dapat mengoptimalkan kait pra-komitmen pada serat dengan cara ini. <br><br><img src="https://habrastorage.org/webt/x9/n7/dg/x9n7dgdih-y-zepifpkfd9czys8.jpeg"><br><br>  Jika Anda menulis tes pada Jest, itu juga memiliki alat untuk menjalankan tes secara selektif. <br><br><img src="https://habrastorage.org/webt/gd/fp/op/gdfpopeopfjlht4excpli5ec0d8.jpeg"><br><br>  Opsi ini memungkinkan Anda untuk memberikan daftar file sumber dan menemukan semua tes yang satu atau lain cara mempengaruhi file-file ini.  Apa yang bisa digunakan bersamaan dengan pementasan serat?  Harap dicatat, di sini saya tidak menentukan semua file js, tetapi hanya sumbernya.  Kami mengecualikan file js sendiri dengan tes di dalamnya, kami hanya melihat sumbernya.  Kami mulai findRelatedTests dan sangat mempercepat menjalankan unit untuk precommit atau prepush, seperti yang Anda inginkan. <br><br>  Dan metode ketiga dikaitkan dengan monorepositori.  Ini adalah lerna, yang dapat menentukan paket mana yang telah berubah dibandingkan dengan komit dasar.  Ini kemungkinan besar bukan tentang pengait, tetapi tentang CI / CD Anda: Travis atau layanan lain yang Anda gunakan. <br><br><img src="https://habrastorage.org/webt/bn/is/ij/bnisijuykjzbkbi6-mhd19lwvmq.jpeg"><br><br><img src="https://habrastorage.org/webt/ul/d4/u2/uld4u2saou9lwemuj2ky4usffyu.jpeg"><br><br>  Perintah jalankan dan exec memiliki opsi sejak, yang memungkinkan Anda untuk menjalankan perintah apa saja hanya dalam paket-paket yang telah berubah sejak beberapa jenis komit.  Dalam kasus sederhana, Anda bisa menentukan penyihir jika Anda menuangkan semuanya ke dalamnya.  Jika Anda ingin lebih akurat, lebih baik untuk menentukan komit dasar dari permintaan kumpulan Anda melalui alat CI / CD Anda, maka ini akan menjadi pengujian yang lebih jujur. <br><br>  Karena lerna mengetahui semua dependensi di dalam paket, ia dapat mendeteksi dependensi tidak langsung juga.  Jika Anda mengubah perpustakaan A, yang digunakan di perpustakaan B, yang digunakan dalam layanan C, lerna akan memahami ini. ,      .    ,   C   â€” ,      .  lerna      . <br><br>   ,    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">c lerna</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  yarn workspaces   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      . <br><br>  ,   .  ,   .    .  ?    ,        ,       ,   .  ,         ,     .    ,   -      . ,      Babel.     ,   ,     .                  .     ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin mengucapkan terima kasih kepada rekan-rekan saya: Misha </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mishanga</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troshev dan Gosha Besedin. </font><font style="vertical-align: inherit;">Mereka menghabiskan sedikit waktu mempelajari alat-alat yang kami ulas hari ini dan berbagi pengalaman dan pengetahuan mereka. </font><font style="vertical-align: inherit;">Itu saja, terima kasih.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469021/">https://habr.com/ru/post/id469021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469007/index.html">RubyRusia 2019. Nikita Shilnikov pada efek aljabar</a></li>
<li><a href="../id469009/index.html">Kultus kargo dalam pengembangan perangkat lunak</a></li>
<li><a href="../id469011/index.html">11 mitos tentang USB Type-C</a></li>
<li><a href="../id469015/index.html">Slurm: Moskow intensif oleh Kubernetes dan pengumuman lainnya</a></li>
<li><a href="../id469019/index.html">Pertemuan SPA 5: Integrasi Jest dengan QA, UIKit yang kuat, Perpustakaan Komponen, DI untuk Penskalaan, Perintah Platform</a></li>
<li><a href="../id469023/index.html">Cara menemukan pekerjaan dengan relokasi ke Eropa: panduan praktis untuk profesional TI</a></li>
<li><a href="../id469025/index.html">Dinginkan anggur dengan cepat! Penemuan Rusia</a></li>
<li><a href="../id469027/index.html">Ivanovo! Mitap: Bagaimana cara membangun karir di Digital?</a></li>
<li><a href="../id469031/index.html">12 baru kecerdasan buatan Layanan Media Azure</a></li>
<li><a href="../id469033/index.html">Meluncurkan Platform Elbrus untuk PuzzleLib Neural Networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>