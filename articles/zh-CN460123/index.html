<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐀 👧🏽 🏪 在参与者之上的声明式数据处理管道？ 为什么不呢 🛌🏿 🚴🏼 ☔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不久前，在关于SObjectizer发行版之一的讨论中，我们被问到：“是否有可能使DSL来描述数据处理管道？” 换句话说，是否可以这样写： 


A | B | C | D  


 并获得一条工作流水线，其中消息从A到B，再到C，再到D。在控制之下，B接收了A所返回的确切类型。 C恰好收到B返回的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在参与者之上的声明式数据处理管道？ 为什么不呢</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p> 不久前，在关于SObjectizer发行版之一的讨论中，我们被问到：“是否有可能使DSL来描述数据处理管道？” 换句话说，是否可以这样写： </p><br><p><code>A | B | C | D</code> </p> <br><p> 并获得一条工作流水线，其中消息从A到B，再到C，再到D。在控制之下，B接收了A所返回的确切类型。  C恰好收到B返回的那种类型。 依此类推。 </p><br><p> 使用令人惊讶的简单解决方案，这是一项有趣的任务。 例如，这就是管道创建的样子： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p> 或者，在更复杂的情况下（将在下面讨论）： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p> 在本文中，我们将讨论这种管道DSL的实现。 我们将通过几个使用C ++模板的示例来讨论与<code>stage()</code> ， <code>broadcast()</code>和<code>operator|()</code>函数有关的大部分内容。 因此，我希望即使对于不了解SObjectizer的读者来说，它也会很有趣（如果您从未听说过SObjectizer， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>是此工具的概述）。 </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo"> 关于二手演示的几句话 </h1><br><p> 本文中使用的示例受到了我在SCADA领域的过往（甚至是被遗忘的）经历的影响。 </p><br><p> 该演示的想法是处理从某些传感器读取的数据。 需要一段时间才能从传感器获取数据，然后必须对该数据进行验证（应忽略不正确的数据）并将其转换为一些实际值。 例如，从传感器读取的原始数据可以是两个8位整数值，并且这些值应转换为一个浮点数。 </p><br><p> 然后，应将有效值和转换后的值存档，分布在某个位置（例如，在不同的节点上以进行可视化），检查“警报”（如果值超出安全范围，则应进行特殊处理）。 这些操作是独立的，可以并行执行。 </p><br><p> 与检测到的警报相关的操作也可以并行执行：应启动“警报”（这样，当前节点上的SCADA部分可以对此作出反应），有关“警报”的信息应分发到其他地方（例如：存储到历史数据库和/或在SCADA操作员的显示屏上可视化）。 </p><br><p> 这种逻辑可以用文本形式表示： </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p> 或者，以图形形式： </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p> 这是一个比较人为的示例，但是我想展示一些有趣的东西。 首先是流水线中存在并行阶段<code>broadcast()</code>正是由于这个原因而存在<code>broadcast()</code>操作<code>broadcast()</code> ）。 第二个是在某些阶段存在状态。 例如，alarm_detector是有状态阶段。 </p><br><h1 id="pipeline-capabilities"> 管道功能 </h1><br><p> 管道是从不同的阶段构建的。 每个阶段都是以下格式的函数或函子： </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p> 或 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p> 返回<code>void</code>阶段只能用作管道的最后阶段。 </p><br><p> 阶段被捆绑在一起。 每个下一个阶段都接收上一个阶段返回的对象。 如果上一级返回空的<code>opt&lt;Out&gt;</code>值，则不调用下一级。 </p><br><p> 有一个特殊的<code>broadcast</code>阶段。 它是由多个管道构成的。  <code>broadcast</code>阶段从上一阶段接收对象，并将其广播到每个辅助管道。 </p><br><p> 从管道的角度来看， <code>broadcast</code>阶段看起来像以下格式的函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p> 因为<code>broadcast</code>阶段没有返回值，所以<code>broadcast</code>阶段只能是管道中的最后一个阶段。 </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value"> 为什么管道阶段返回一个可选值？ </h2><br><p> 这是因为需要删除一些传入的值。 例如，如果原始值不正确，那么<code>validate</code>阶段将不返回任何内容，并且没有任何处理意义。 </p><br><p> 另一个示例：如果当前的可疑值未产生新的警报情况，则<code>alarm_detector</code>阶段不返回任何内容。 </p><br><h1 id="implementation-details"> 实施细节 </h1><br><h2 id="types-and-functions-related-to-the-application-logic"> 与应用程序逻辑相关的类型和功能 </h2><br><p> 让我们从与应用程序逻辑相关的数据类型和功能开始。 在讨论的示例中，以下数据类型用于将信息从一个阶段传递到另一阶段： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  <code>raw_value</code>的实例将进入管道的第一阶段。 该<code>raw_value</code>包含以<code>raw_measure</code>对象的形式从传感器获取的信息。 然后将<code>raw_value</code>转换为<code>valid_raw_value</code> 。 然后，将<code>valid_raw_value</code>转换为<code>sensor_value</code>并将实际传感器的值形式为<code>calulated_measure</code> 。 如果<code>sensor_value</code>的实例包含可疑值，则将生成<code>suspicious_value</code>的实例。 而且该<code>suspicious_value</code>可以在以后转换为<code>alarm_detected</code>实例。 </p><br><p> 或者，以图形形式： </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p> 现在，我们可以看一下流水线阶段的实现： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p> 只需跳过<code>stage_result_t</code> ， <code>make_result</code>和<code>make_empty</code> ，我们将在下一部分中讨论。 </p><br><p> 我希望这些阶段的代码相当简单。 唯一需要一些其他说明的部分是<code>alarm_detector</code>阶段的实现。 </p><br><p> 在该示例中，仅在25ms时间窗口中至少有两个<code>suspicious_values</code>时才发出警报。 因此，我们必须记住在<code>alarm_detector</code>阶段前一个<code>suspicious_value</code>实例的时间。 这是因为<code>alarm_detector</code>通过函数调用运算符实现为有状态函子。 </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional"> 阶段返回SObjectizer的类型，而不是std ::可选 </h2><br><p> 我之前告诉过阶段可以返回可选值。 但是代码中没有使用<code>std::optional</code> ，在执行阶段可以看到不同类型的<code>stage_result_t</code> 。 </p><br><p> 这是因为SObjectizer的某些特定功能在这里发挥了作用。 返回的值将作为消息在SObjectizer的代理（也称为actor）之间分发。  SObjectizer中的每个消息都作为动态分配的对象发送。 因此，我们在此处进行了某种“优化”：而不是返回<code>std::optional</code>然后分配新的消息对象，我们只是分配一个消息对象并返回指向它的智能指针。 </p><br><p> 实际上， <code>stage_result_t</code>只是SObjectizer的shared_ptr模拟的typedef： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p> 并且<code>make_result</code>和<code>make_empty</code>只是用于构造<code>stage_result_t</code>辅助函数，内部是否带有实际值： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p> 为简单起见，可以肯定地说<code>validation</code>阶段可以这样表示： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p> 但是，由于SObjectizer的特定性，我们不能使用<code>std::shared_ptr</code>而必须处理<code>so_5::message_holder_t</code>类型。 并且我们将具体的隐藏在<code>stage_result_t</code> ， <code>make_result</code>和<code>make_empty</code>帮助器后面。 </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  stage_handler_t和stage_builder_t分离 </h2><br><p> 流水线实现的一个重点是<em>阶段处理程序</em>和<em>阶段构建器</em>概念的分离。 这样做是为了简化。 这些概念的出现使我在管道定义中有两个步骤。 </p><br><p> 第一步，用户描述流水线阶段。 结果，我收到一个<code>stage_t</code>实例，该实例将所有管道阶段保存在其中。 </p><br><p> 第二步，创建一组基础SObjectizer的代理。 这些代理接收带有上一阶段结果的消息，并调用实际的<em>阶段处理程序</em> ，然后将结果发送到下一阶段。 </p><br><p> 但是要创建这组代理，每个阶段都必须有一个<em>阶段构建器</em> 。  <em>阶段构建器</em>可以看作是创建基础SObjectizer代理的工厂。 </p><br><p> 因此，我们具有以下关系：每个管道阶段都产生两个对象： <em>阶段处理程序</em> ，其保存与阶段相关的逻辑；以及<em>阶段构建器</em> ，其创建基础SObjectizer的代理以在适当的时间调用<em>阶段处理程序</em> ： </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>阶段处理程序</em>以以下方式表示： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p> 其中<code>handler_traits_t</code>的定义方式如下： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>阶段构建器</em>仅由<code>std::function</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t"> 帮手类型lambda_traits_t和callable_traits_t </h2><br><p> 因为阶段可以由自由函数或函子表示（例如， <code>alarm_detector</code>类的实例或表示lambda的匿名编译器生成的类的实例），所以我们需要一些帮助程序来检测阶段的参数和返回值的类型。 为此，我使用了以下代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p> 我希望对于具有C ++知识的读者来说，这段代码是可以理解的。 如果没有，请随时在评论中问我，我将很高兴详细解释<code>lambda_traits_t</code>和<code>callable_traits_t</code>背后的逻辑。 </p><br><h2 id="stage-broadcast-and-operator-functions"> 阶段（），广播（）和运算符|（）函数 </h2><br><p> 现在，我们可以查看主要的管道构建功能。 但是在此之前，有必要查看一下模板类<code>stage_t</code>的定义： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p> 这是一个非常简单的结构，仅<code>stage_bulder_t</code>实例。 模板参数未在<code>stage_t</code>内部<code>stage_t</code> ，那么为什么要在此处使用它们？ </p><br><p> 它们是在管道阶段之间进行类型兼容性的编译时检查所必需的。 我们很快就会看到。 </p><br><p> 让我们看一下最简单的管道构建函数， <code>stage()</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> 它接收一个实际的<em>阶段处理程序</em>作为单个参数。 它可以是指向函数，lambda函数或函子的指针。 由于<code>callable_traits_t</code>模板后面的“模板魔术”，自动推导出了舞台的输入和输出类型。 </p><br><p> 在内部创建了一个<em>阶段构建器</em>的实例，该实例作为<code>stage()</code>函数的结果返回到一个新的<code>stage_t</code>对象中。 实际的<em>阶段处理程序</em>由<em>阶段构建器</em> lambda捕获，然后将其用于构建基础SObjectizer的代理（我们将在下一节中讨论）。 </p><br><p> 下一个要检查的函数是<code>operator|()</code> ，它将两个阶段连接在一起并返回一个新阶段： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p> 解释<code>operator|()</code>的逻辑的最简单方法是尝试绘制图片。 假设我们有表达式： </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p> 该表达式将以这种方式转换： </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p> 在这里，我们还可以看到编译时类型检查的工作方式： <code>operator|()</code>的定义要求第一阶段的输出类型是第二阶段的输入。 如果不是这种情况，则不会编译代码。 </p><br><p> 现在，我们来看一下最复杂的管道构建功能，即<code>broadcast()</code> 。 该函数本身非常简单： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> 普通阶段和广播阶段之间的主要区别在于，广播阶段必须拥有辅助<em>阶段构建者</em>的向量。 因此，我们必须创建该矢量并将其传递到广播级的主<em>级构建器</em>中。 因此，我们可以在<code>broadcast()</code>函数内的lambda捕获列表中看到对<code>collect_sink_builders</code>的调用： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p> 如果我们查看<code>collect_sink_builder</code>我们将看到以下代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p> 编译时类型检查在这里也起作用：这是因为对类型为<code>move_sink_builder_to</code>的调用<code>move_sink_builder_to</code>显式参数化。 这意味着以<code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code>进行的调用将导致编译错误，因为编译器禁止调用<code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> 。 </p><br><p> 我还可以注意到，由于<code>broadcast()</code>的子管道的数量在编译时是已知的，因此我们可以使用<code>std::array</code>而不是<code>std::vector</code> ，并且可以避免一些内存分配。 但是这里<code>std::vector</code>只是为了简单起见。 </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes"> 阶段与SObjectizer的代理/ mbox之间的关系 </h2><br><p> 实施管道背后的想法是为每个管道阶段创建一个单独的代理。 代理接收传入的消息，将其传递到相应的<em>阶段处理程序</em> ，分析结果，如果结果不为空，则将结果作为传入消息发送到下一个阶段。 可以通过以下序列图进行说明： </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p> 必须至少简短地讨论一些与SObjectizer相关的事情。 如果您对此类详细信息不感兴趣，则可以跳过以下部分，直接查看结论。 </p><br><h3 id="coop-is-a-group-of-agents-to-work-together"> 合作社是一组一起工作的代理商 </h3><br><p> 代理不是单独引入到SObjectizer中，而是以名为coops的组引入。 合作社是一组应该一起工作的特工，如果缺少该组特工中的一个，则没有继续工作的感觉。 </p><br><p> 因此，将代理引入SObjectizer的过程就像创建coop实例，用适当的代理填充该实例，然后在SObjectizer中注册该coop。 </p><br><p> 因此， <em>阶段构建器</em>的第一个参数是对新合作社的引用。 此合作社是在<code>make_pipeline()</code>函数中创建的（下面讨论），然后由<em>舞台构建器</em>填充并进行注册（再次在<code>make_pipeline()</code>函数中）。 </p><br><h3 id="message-boxes"> 留言框 </h3><br><p>  SObjectizer实现了几个与并发相关的模型。 演员模型只是其中之一。 因此，SObjectizer可以与其他参与者框架有很大的不同。 区别之一是消息的寻址方案。 </p><br><p>  SObjectizer中的消息不是针对参与者，而是<em>消息框</em> （mbox）。 参与者必须从mbox订阅消息。 如果演员从mbox订阅了特定的消息类型，它将收到该类型的消息： </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p> 这一事实至关重要，因为有必要将消息从一个阶段发送到另一个阶段。 这意味着每个阶段都应该有其mbox，并且上一个阶段应该知道mbox。 </p><br><p>  SObjectizer中<em>的</em>每个actor（aka代理）都有<em>直接的mbox</em> 。 该mbox仅与所有者代理关联，并且不能被任何其他代理使用。 为阶段创建的代理的直接mbox将用于阶段交互。 </p><br><p> 该SObjectizer的特定功能规定了一些管道实现细节。 </p><br><p> 首先是<em>舞台构建器</em>具有以下原型的事实： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p> 这意味着<em>阶段构建器将</em>接收下一个阶段的mbox，并应创建一个新代理，该代理会将阶段的结果发送到该mbox。  <em>阶段构建器</em>应返回新代理的mbox。 该mbox将用于创建上一阶段的代理。 </p><br><p> 第二个事实是，阶段代理已按备用订单创建。 这意味着如果我们有管道： </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p> 首先创建阶段C的代理，然后将其mbox用于阶段B的代理创建，然后将B阶段代理的mbox用于创建阶段A的代理。 </p><br><p> 还需要注意的是， <code>operator|()</code>不会创建代理： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  <code>operator|()</code>创建一个仅调用其他构建器但不引入其他代理的构建器。 因此，对于这种情况： </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p> 仅将创建两个代理（用于A阶段和B阶段），然后在<code>operator|()</code>创建的<em>阶段构建器</em>中将它们链接在一起。 </p><br><h3 id="there-is-no-agent-for-broadcast-implementation"> 没有用于<code>broadcast()</code>实现的代理 </h3><br><p> 实现广播阶段的一种明显方法是创建一个特殊代理，该代理将接收传入的消息，然后将该消息重新发送到目标mbox列表。 在描述的管道DSL <a href="">的第一个实现</a>中<a href="">使用了</a>这种方式。 </p><br><p> 但是我们的配套项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">so5extra</a>现在具有mbox的一个特殊变体：广播一个。 该mbox完全满足此处的要求：它接收一条新消息，并将其传递到一组目标mbox。 </p><br><p> 因此，无需创建单独的广播代理，我们可以仅使用so5extra的广播mbox： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent"> 实施阶段代理 </h3><br><p> 现在我们来看看阶段代理的实现： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p> 如果您了解SObjectizer的基础知识，那将是微不足道的。 如果不是，那么很难用几句话来解释（所以请随时在评论中提问）。 </p><br><p>  <code>a_stage_point_t</code>代理的主要实现创建对In类型消息的预订。 当此类消息到达时，将调用<em>阶段处理程序</em> 。 如果<em>阶段处理程序</em>返回实际结果，则将结果发送到下一个阶段（如果存在该阶段）。 </p><br><p> 当相应的阶段是终端阶段而没有下一个阶段时，还有<code>a_stage_point_t</code>的版本。 </p><br><p>  <code>a_stage_point_t</code>的实现可能看起来有些复杂，但是请相信我，它是我编写的最简单的代理之一。 </p><br><h2 id="make_pipeline-function">  make_pipeline（）函数 </h2><br><p> 现在该讨论最后一个管道构建函数<code>make_pipeline()</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p> 这里没有魔术，也没有惊喜。 我们只需要为管道的底层代理创建一个新的合作社，通过调用顶级<em>阶段构建器</em>将该合作社填充到代理中，然后将该合作社注册到SObjectizer中即可。 就这样 </p><br><p>  <code>make_pipeline()</code>的结果是<code>make_pipeline()</code>最左侧（第一级<code>make_pipeline()</code>的mbox。 该mbox应该用于将消息发送到管道。 </p><br><h1 id="the-simulation-and-experiments-with-it"> 仿真与实验 </h1><br><p> 因此，现在我们有了应用程序逻辑的数据类型和函数，以及将这些函数链接到数据处理管道的工具。 让我们看一下结果： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p> 如果运行该示例，我们将看到以下输出： </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p> 可以用 </p><br><p> 但是，我们的管道的各个阶段似乎相继工作，不是吗？ </p><br><p> 是的，是的。 这是因为所有管道代理都绑定到默认的SObjectizer的调度程序。 该调度程序仅使用一个工作线程来处理所有代理的消息处理。 </p><br><p> 但这很容易改变。 只需将另一个参数传递给<code>make_pipeline()</code>调用即可： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p> 这将创建一个新的线程池，并将所有管道代理绑定到该池。 每个代理将独立于其他代理由池服务。 </p><br><p> 如果运行修改后的示例，我们将看到类似的内容： </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p> 因此，我们可以看到管道的不同阶段并行工作。 </p><br><p> 但是是否可以走得更远，并有能力将阶段绑定到不同的调度程序？ </p><br><p> 是的，这是可能的，但是我们必须为<code>stage()</code>函数实现另一个重载： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> This version of <code>stage()</code> accepts not only a <em>stage handler</em> but also a dispatcher binder. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS。 The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460123/">https://habr.com/ru/post/zh-CN460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460113/index.html">有关JSOC CERT或Unbanal法医学的一些故事</a></li>
<li><a href="../zh-CN460115/index.html">Erlang十年编程</a></li>
<li><a href="../zh-CN460117/index.html">俄罗斯最大的客户是中奖还是头痛？ AGIMA经验</a></li>
<li><a href="../zh-CN460119/index.html">由于未使用静态代码分析而无法找到的错误</a></li>
<li><a href="../zh-CN460121/index.html">由于未使用静态代码分析而无法找到的错误</a></li>
<li><a href="../zh-CN460125/index.html">Node.js或Java：性能，资源，流控制，受欢迎程度和个人经验</a></li>
<li><a href="../zh-CN460129/index.html">机器人和草莓：人工智能如何提高田间产量</a></li>
<li><a href="../zh-CN460131/index.html">Sophos XG Firewall：从经典的ME到NGFW，可自动响应信息安全事件</a></li>
<li><a href="../zh-CN460133/index.html">Kotlin / Everywhere-展示活动：7月31日</a></li>
<li><a href="../zh-CN460135/index.html">安全周29：缩放，安全和戏剧性漏洞</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>