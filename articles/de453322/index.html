<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏽 👰🏻 ⛽️ Konfigurieren Sie Nomad Cluster mit Consul und integrieren Sie es in Gitlab 📤 👋🏽 🖖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 

 In letzter Zeit wächst die Popularität von Kubernetes rasant - immer mehr Projekte setzen es zu Hause um. Ich wollte einen Orchestrator ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konfigurieren Sie Nomad Cluster mit Consul und integrieren Sie es in Gitlab</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453322/"><h2>  Einführung </h2><br><br>  In letzter Zeit wächst die Popularität von Kubernetes rasant - immer mehr Projekte setzen es zu Hause um.  Ich wollte einen Orchestrator wie Nomad ansprechen: Er eignet sich perfekt für Projekte, die bereits andere Lösungen von HashiCorp verwenden, z. B. Vault und Consul, und die Projekte selbst sind in Bezug auf die Infrastruktur nicht kompliziert.  Dieser Artikel enthält Anweisungen zum Installieren von Nomad, zum Kombinieren von zwei Knoten in einem Cluster und zum Integrieren von Nomad in Gitlab. <br><br><img src="https://habrastorage.org/webt/bu/yn/4v/buyn4vqshurhgc9kavloja-fzsm.png"><br><br><a name="habracut"></a><br><br><h2>  Prüfstand </h2><br><br>  Ein bisschen über den Prüfstand: Es werden drei virtuelle Server mit den Eigenschaften von 2 CPU, 4 RAM, 50 Gb SSD verwendet, die in einem gemeinsamen lokalen Netzwerk vereint sind.  Ihre Namen und IP-Adressen: <br><br><ol><li>  <b>nomad-livelinux-01</b> : 172.30.0.5 </li><li>  <b>nomad-livelinux-02</b> : 172.30.0.10 </li><li>  <b>consul-livelinux-01</b> : 172.30.0.15 </li></ol><br><br><h2>  Installation von Nomad, Consul.  Erstellen eines Nomadenclusters </h2><br><br>  Fahren wir mit der Grundinstallation fort.  Trotz der einfachen Installation werde ich es für die Integrität des Artikels beschreiben: Tatsächlich wurde es aus Entwürfen und Notizen erstellt, um bei Bedarf schnell darauf zugreifen zu können. <br><br>  Bevor wir mit der Praxis beginnen, werden wir den theoretischen Teil diskutieren, da es in dieser Phase wichtig ist, die zukünftige Struktur zu verstehen. <br><br>  Wir haben zwei Nomadenknoten und wollen sie zu einem Cluster zusammenfassen. Für die Zukunft benötigen wir eine automatische Skalierung des Clusters - dafür benötigen wir Consul.  Mit diesem Tool wird das Clustering und Hinzufügen neuer Knoten zu einer sehr einfachen Aufgabe: Der erstellte Nomad-Knoten stellt eine Verbindung zum Consul-Agenten und dann eine Verbindung zum vorhandenen Nomad-Cluster her.  Daher werden wir zu Beginn den Consul-Server installieren, die grundlegende http-Autorisierung für das Webpanel konfigurieren (standardmäßig ohne Autorisierung und über eine externe Adresse zugänglich) sowie die Consul-Agenten selbst auf den Nomad-Servern. Danach starten wir einfach Nomad. <br><br>  Die Installation der HashiCorp-Tools ist sehr einfach: Tatsächlich verschieben wir die Binärdatei einfach in das bin-Verzeichnis, konfigurieren die Konfigurationsdatei des Tools und erstellen die Servicedatei. <br><br>  Laden Sie die Consul-Binärdatei herunter und entpacken Sie sie in das Home-Verzeichnis des Benutzers: <br><br><pre><code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/consul/1.5.0/consul_1.5.0_linux_amd64.zip root@consul-livelinux-01:~# unzip consul_1.5.0_linux_amd64.zip root@consul-livelinux-01:~# mv consul /usr/local/bin/</span></span></code> </pre> <br><br>  Jetzt haben wir eine vorgefertigte binäre Konsulendatei zur weiteren Konfiguration. <br><br>  Um mit Consul arbeiten zu können, müssen wir mit dem Befehl keygen einen eindeutigen Schlüssel erstellen: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># consul keygen</span></span></code> </pre><br><br>  Fahren wir mit der Konfiguration des Konsuls fort und erstellen das Verzeichnis /etc/consul.d/ mit der folgenden Struktur: <br><br><pre> <code class="bash hljs">/etc/consul.d/ ├── bootstrap │ └── config.json</code> </pre> <br><br>  Das Bootstrap-Verzeichnis enthält die Konfigurationsdatei config.json - darin werden die Consul-Einstellungen festgelegt.  Sein Inhalt: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"bootstrap"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"datacenter"</span></span>: <span class="hljs-string"><span class="hljs-string">"dc1"</span></span>, <span class="hljs-string"><span class="hljs-string">"data_dir"</span></span>: <span class="hljs-string"><span class="hljs-string">"/var/consul"</span></span>, <span class="hljs-string"><span class="hljs-string">"encrypt"</span></span>: <span class="hljs-string"><span class="hljs-string">"your-key"</span></span>, <span class="hljs-string"><span class="hljs-string">"log_level"</span></span>: <span class="hljs-string"><span class="hljs-string">"INFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"enable_syslog"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"start_join"</span></span>: [<span class="hljs-string"><span class="hljs-string">"172.30.0.15"</span></span>] }</code> </pre> <br><br>  Lassen Sie uns die wichtigsten Richtlinien und ihre Bedeutung getrennt untersuchen: <br><br><ul><li>  <b>Bootstrap</b> : wahr.  Wir aktivieren das automatische Hinzufügen neuer Knoten, wenn diese verbunden sind.  Ich stelle fest, dass wir hier nicht die genaue Anzahl der erwarteten Knoten angeben. </li><li>  <b>Server</b> : wahr.  Schalten Sie den Servermodus ein.  Der Konsul auf dieser virtuellen Maschine wird derzeit der einzige Server und Master sein, VM Nomad wird Clients sein. </li><li>  <b>Rechenzentrum</b> : dc1.  Geben Sie den Namen des Rechenzentrums an, um einen Cluster zu erstellen.  Es muss auf Clients und Servern identisch sein. </li><li>  <b>verschlüsseln</b> : Ihr Schlüssel.  Ein Schlüssel, der auch eindeutig sein und auf allen Clients und Servern übereinstimmen muss.  Wird mit dem Befehl consul keygen generiert. </li><li>  <b>start_join</b> .  In dieser Liste geben wir die Liste der IP-Adressen an, zu denen die Verbindung hergestellt werden soll.  Im Moment hinterlassen wir nur unsere eigene Adresse. </li></ul><br><br>  An diesem Punkt können wir den Konsul über die Befehlszeile starten: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># /usr/local/bin/consul agent -config-dir /etc/consul.d/bootstrap -ui</span></span></code> </pre> <br><br>  Dies ist ein guter Weg, um jetzt zu debuggen. Die fortlaufende Verwendung dieser Methode funktioniert jedoch aus offensichtlichen Gründen nicht.  Erstellen Sie eine Servicedatei für die Verwaltung von Consul über systemd: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># nano /etc/systemd/system/consul.service</span></span></code> </pre><br><br>  Der Inhalt der Datei consul.service: <br><br><pre> <code class="bash hljs">[Unit] Description=Consul Startup process After=network.target [Service] Type=simple ExecStart=/bin/bash -c <span class="hljs-string"><span class="hljs-string">'/usr/local/bin/consul agent -config-dir /etc/consul.d/bootstrap -ui'</span></span> TimeoutStartSec=0 [Install] WantedBy=default.target</code> </pre> <br><br>  Führen Sie Consul über systemctl aus: <br><br><pre> <code class="bash hljs">root@consul-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># systemctl start consul</span></span></code> </pre><br><br>  Wir überprüfen: Unser Dienst sollte gestartet werden, und durch Ausführen des Befehls der Konsulmitglieder sollten wir unseren Server sehen: <br><br><pre> <code class="bash hljs">root@consul-livelinux:/etc/consul.d<span class="hljs-comment"><span class="hljs-comment"># consul members consul-livelinux 172.30.0.15:8301 alive server 1.5.0 2 dc1 &lt;all&gt;</span></span></code> </pre> <br><br>  Der nächste Schritt: Installieren von Nginx und Einrichten des Proxys, http-Autorisierung.  Installieren Sie nginx über den Paketmanager und erstellen Sie die Konfigurationsdatei consul.conf im Verzeichnis / etc / nginx / sites-enabled mit den folgenden Inhalten: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> consul-auth { <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> localhost:<span class="hljs-number"><span class="hljs-number">8500</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> consul.doman.name; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://consul-auth; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">auth_basic_user_file</span></span> /etc/nginx/.htpasswd; <span class="hljs-attribute"><span class="hljs-attribute">auth_basic</span></span> <span class="hljs-string"><span class="hljs-string">"Password-protected Area"</span></span>; } }</code> </pre> <br><br>  Vergessen Sie nicht, eine .htpasswd-Datei zu erstellen und einen Benutzernamen und ein Passwort dafür zu generieren.  Dieser Artikel ist erforderlich, damit das Webpanel nicht jedem zugänglich ist, der unsere Domain kennt.  Bei der Konfiguration von Gitlab müssen wir dies jedoch aufgeben. Andernfalls können wir unsere Anwendung nicht für Nomad bereitstellen.  In meinem Projekt befinden sich sowohl Gitlab als auch Nomad nur im grauen Netzwerk, daher gibt es kein solches Problem. <br><br>  Installieren Sie auf den beiden anderen Servern die Consul-Agenten gemäß den folgenden Anweisungen.  Wiederholen Sie die Schritte mit der Binärdatei: <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/consul/1.5.0/consul_1.5.0_linux_amd64.zip root@nomad-livelinux-01:~# unzip consul_1.5.0_linux_amd64.zip root@nomad-livelinux-01:~# mv consul /usr/local/bin/</span></span></code> </pre> <br><br>  In Analogie zum vorherigen Server erstellen wir ein Verzeichnis für die Konfigurationsdateien /etc/consul.d mit folgender Struktur: <br><br><pre> <code class="bash hljs">/etc/consul.d/ ├── client │ └── config.json</code> </pre> <br><br>  Der Inhalt der Datei config.json: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"datacenter"</span></span>: <span class="hljs-string"><span class="hljs-string">"dc1"</span></span>, <span class="hljs-string"><span class="hljs-string">"data_dir"</span></span>: <span class="hljs-string"><span class="hljs-string">"/opt/consul"</span></span>, <span class="hljs-string"><span class="hljs-string">"log_level"</span></span>: <span class="hljs-string"><span class="hljs-string">"DEBUG"</span></span>, <span class="hljs-string"><span class="hljs-string">"node_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomad-livelinux-01"</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"encrypt"</span></span>: <span class="hljs-string"><span class="hljs-string">"your-private-key"</span></span>, <span class="hljs-string"><span class="hljs-string">"domain"</span></span>: <span class="hljs-string"><span class="hljs-string">"livelinux"</span></span>, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dns"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"https"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"grpc"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"http"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"bind_addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"172.30.0.5"</span></span>, #    <span class="hljs-string"><span class="hljs-string">"start_join"</span></span>: [<span class="hljs-string"><span class="hljs-string">"172.30.0.15"</span></span>], #     <span class="hljs-string"><span class="hljs-string">"ports"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dns"</span></span>: <span class="hljs-number"><span class="hljs-number">53</span></span> } }</code> </pre><br><br>  Wir speichern die Änderungen und fahren mit der Konfiguration der Servicedatei und ihres Inhalts fort: <br><br>  /etc/systemd/system/consul.service: <br><br><pre> <code class="bash hljs">[Unit] Description=<span class="hljs-string"><span class="hljs-string">"HashiCorp Consul - A service mesh solution"</span></span> Documentation=https://www.consul.io/ Requires=network-online.target After=network-online.target [Service] User=root Group=root ExecStart=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/consul agent -config-dir=/etc/consul.d/client ExecReload=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/consul reload KillMode=process Restart=on-failure [Install] WantedBy=multi-user.target</code> </pre> <br><br>  Wir starten den Konsul auf dem Server.  Nach dem Start sollte der konfigurierte Dienst nun in nsul-Mitgliedern angezeigt werden.  Dies bedeutet, dass er als Client erfolgreich eine Verbindung zum Cluster hergestellt hat.  Wiederholen Sie dies auf dem zweiten Server. Danach können Sie Nomad installieren und konfigurieren. <br><br>  Eine detailliertere Installation von Nomad ist in der offiziellen Dokumentation beschrieben.  Es gibt zwei traditionelle Installationsmethoden: Herunterladen einer Binärdatei und Kompilieren aus dem Quellcode.  Ich werde die erste Methode wählen. <br><br>  <b>Hinweis</b> : Das Projekt entwickelt sich sehr schnell, häufig werden neue Updates veröffentlicht.  Möglicherweise wird eine neue Version veröffentlicht, wenn dieser Artikel fertiggestellt ist.  Daher empfehle ich, vor dem Lesen die aktuelle Version von Nomad zu überprüfen und herunterzuladen. <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># wget https://releases.hashicorp.com/nomad/0.9.1/nomad_0.9.1_linux_amd64.zip root@nomad-livelinux-01:~# unzip nomad_0.9.1_linux_amd64.zip root@nomad-livelinux-01:~# mv nomad /usr/local/bin/ root@nomad-livelinux-01:~# nomad -autocomplete-install root@nomad-livelinux-01:~# complete -C /usr/local/bin/nomad nomad root@nomad-livelinux-01:~# mkdir /etc/nomad.d</span></span></code> </pre> <br><br>  Nach dem Auspacken erhalten wir eine Nomad'a-Binärdatei mit einem Gewicht von 65 MB - sie muss nach / usr / local / bin verschoben werden. <br><br>  Erstellen Sie ein Datenverzeichnis für Nomad und bearbeiten Sie dessen Servicedatei (diese wird höchstwahrscheinlich am Anfang nicht vorhanden sein): <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># mkdir --parents /opt/nomad root@nomad-livelinux-01:~# nano /etc/systemd/system/nomad.service</span></span></code> </pre> <br><br>  Fügen Sie dort folgende Zeilen ein: <br><br><pre> <code class="bash hljs">[Unit] Description=Nomad Documentation=https://nomadproject.io/docs/ Wants=network-online.target After=network-online.target [Service] ExecReload=/bin/<span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -HUP <span class="hljs-variable"><span class="hljs-variable">$MAINPID</span></span> ExecStart=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/nomad agent -config /etc/nomad.d KillMode=process KillSignal=SIGINT LimitNOFILE=infinity LimitNPROC=infinity Restart=on-failure RestartSec=2 StartLimitBurst=3 StartLimitIntervalSec=10 TasksMax=infinity [Install] WantedBy=multi-user.target</code> </pre> <br><br>  Wir haben es jedoch nicht eilig, nomad auszuführen - wir haben die Konfigurationsdatei noch nicht erstellt: <br><br><pre> <code class="bash hljs">root@nomad-livelinux-01:~<span class="hljs-comment"><span class="hljs-comment"># mkdir --parents /etc/nomad.d root@nomad-livelinux-01:~# chmod 700 /etc/nomad.d root@nomad-livelinux-01:~# nano /etc/nomad.d/nomad.hcl root@nomad-livelinux-01:~# nano /etc/nomad.d/server.hcl</span></span></code> </pre><br><br>  Die endgültige Verzeichnisstruktur lautet wie folgt: <br><br><pre> <code class="bash hljs">/etc/nomad.d/ ├── nomad.hcl └── server.hcl</code> </pre> <br><br>  Die Datei nomad.hcl sollte die folgende Konfiguration enthalten: <br><br><pre> <code class="bash hljs">datacenter = <span class="hljs-string"><span class="hljs-string">"dc1"</span></span> data_dir = <span class="hljs-string"><span class="hljs-string">"/opt/nomad"</span></span></code> </pre> <br><br>  Der Inhalt der Datei server.hcl: <br><br><pre> <code class="bash hljs">server { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> bootstrap_expect = 1 } consul { address = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:8500"</span></span> server_service_name = <span class="hljs-string"><span class="hljs-string">"nomad"</span></span> client_service_name = <span class="hljs-string"><span class="hljs-string">"nomad-client"</span></span> auto_advertise = <span class="hljs-literal"><span class="hljs-literal">true</span></span> server_auto_join = <span class="hljs-literal"><span class="hljs-literal">true</span></span> client_auto_join = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } bind_addr = <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span> advertise { http = <span class="hljs-string"><span class="hljs-string">"172.30.0.5"</span></span> } client { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><br>  Vergessen Sie nicht, die Konfigurationsdatei auf dem zweiten Server zu ändern. Dort müssen Sie den Wert der http-Direktive ändern. <br><br>  Das letzte in dieser Phase ist die Konfiguration von Nginx zum Proxying und Festlegen der http-Autorisierung.  Der Inhalt der Datei nomad.conf: <br><br><pre> <code class="bash hljs">upstream nomad-auth { server 172.30.0.5:4646; } server { server_name nomad.domain.name; location / { proxy_pass http://nomad-auth; proxy_set_header Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; auth_basic_user_file /etc/nginx/.htpasswd; auth_basic <span class="hljs-string"><span class="hljs-string">"Password-protected Area"</span></span>; } }</code> </pre> <br><br>  Jetzt können wir über ein externes Netzwerk auf das Webpanel zugreifen.  Wir verbinden uns und gehen zur Serverseite: <br><br><img src="https://habrastorage.org/webt/en/uq/ck/enuqck8krqstsbt8b6uwbytoy0e.png"><br>  <b>Abbildung 1.</b> Liste der Server in einem Nomad-Cluster <br><br>  Beide Server werden erfolgreich im Bedienfeld angezeigt. Dies wird auch in der Ausgabe des Befehls nomad node status angezeigt: <br><br><img src="https://habrastorage.org/webt/c1/gv/82/c1gv82tjvwtw0onqxqv3huchv1w.png"><br>  <b>Bild 2.</b> Die Ausgabe des Nomadenknotenstatusbefehls <br><br>  Was ist mit Konsul?  Mal sehen.  Wechseln Sie zum Consul-Kontrollfeld zur Knotenseite: <br><img src="https://habrastorage.org/webt/m5/6w/tj/m56wtjjgkos9ed5e_jy9lidmutg.png"><br>  <b>Abbildung 3.</b> Liste der Knoten im Consul-Cluster <br><br>  Jetzt haben wir Nomad in Zusammenarbeit mit Consul vorbereitet.  In der letzten Phase werden wir mit dem interessantesten beginnen: Wir werden die Lieferung von Docker-Containern von Gitlab an Nomad konfigurieren und auch über einige seiner anderen Besonderheiten sprechen. <br><br><h2>  Erstellen Sie Gitlab Runner <br></h2><br><br>  Für die Bereitstellung von Docker-Images für Nomad verwenden wir einen separaten Runner mit der darin enthaltenen Nomad-Binärdatei (hier kann übrigens eine weitere Funktion von Hashicorp-Anwendungen erwähnt werden - einzeln sind sie die einzige Binärdatei).  Laden Sie es in das Runner-Verzeichnis herunter.  Erstellen Sie für ihn die einfachste Docker-Datei mit den folgenden Inhalten: <br><br><pre> <code class="bash hljs">FROM alpine:3.9 RUN apk add --update --no-cache libc6-compat gettext COPY nomad /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/nomad</code> </pre><br><br>  Erstellen Sie im selben Projekt .gitlab-ci.yml: <br><br><pre> <code class="bash hljs">variables: DOCKER_IMAGE: nomad/nomad-deploy DOCKER_REGISTRY: registry.domain.name stages: - build build: stage: build image: <span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/nomad/alpine:3 script: - tag=<span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${DOCKER_IMAGE}</span></span>:latest - docker build --pull -t <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> -f Dockerfile . - docker push <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span></code> </pre> <br><br>  Als Ergebnis haben wir ein zugängliches Image des Nomad-Läufers in der Gitlab-Registrierung. Jetzt können wir direkt zum Projekt-Repository gehen, eine Pipeline erstellen und den Nomad-Job Nomad konfigurieren. <br><br><h2>  Projekteinrichtung <br></h2><br><br>  Beginnen wir mit der Jobdatei für Nomad.  Mein Projekt in diesem Artikel wird ziemlich primitiv sein: Es wird aus einer Aufgabe bestehen.  Der Inhalt von .gitlab-ci lautet wie folgt: <br><br><pre> <code class="bash hljs">variables: NOMAD_ADDR: http://nomad.address.service:4646 DOCKER_REGISTRY: registry.domain.name DOCKER_IMAGE: example/project stages: - build - deploy build: stage: build image: <span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/nomad-runner/alpine:3 script: - tag=<span class="hljs-variable"><span class="hljs-variable">${DOCKER_REGISTRY}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${DOCKER_IMAGE}</span></span>:<span class="hljs-variable"><span class="hljs-variable">${CI_COMMIT_SHORT_SHA}</span></span> - docker build --pull -t <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> -f Dockerfile . - docker push <span class="hljs-variable"><span class="hljs-variable">${tag}</span></span> deploy: stage: deploy image: registry.example.com/nomad/nomad-runner:latest script: - envsubst <span class="hljs-string"><span class="hljs-string">'${CI_COMMIT_SHORT_SHA}'</span></span> &lt; project.nomad &gt; job.nomad - cat job.nomad - nomad validate job.nomad - nomad plan job.nomad || <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -eq 255 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 255; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"success"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> - nomad run job.nomad environment: name: production allow_failure: <span class="hljs-literal"><span class="hljs-literal">false</span></span> when: manual</code> </pre> <br><br>  Hier erfolgt die Bereitstellung im manuellen Modus, Sie können sie jedoch so konfigurieren, dass der Inhalt des Projektverzeichnisses geändert wird.  Die Pipeline besteht aus zwei Phasen: von der Montage des Images und seiner Bereitstellung bis zum Nomaden.  In der ersten Phase sammeln wir das Docker-Image und verschieben es in unsere Registrierung. In der zweiten Phase starten wir unseren Job in Nomad. <br><br><pre> <code class="bash hljs">job <span class="hljs-string"><span class="hljs-string">"monitoring-status"</span></span> { datacenters = [<span class="hljs-string"><span class="hljs-string">"dc1"</span></span>] migrate { max_parallel = 3 health_check = <span class="hljs-string"><span class="hljs-string">"checks"</span></span> min_healthy_time = <span class="hljs-string"><span class="hljs-string">"15s"</span></span> healthy_deadline = <span class="hljs-string"><span class="hljs-string">"5m"</span></span> } group <span class="hljs-string"><span class="hljs-string">"zhadan.ltd"</span></span> { count = 1 update { max_parallel = 1 min_healthy_time = <span class="hljs-string"><span class="hljs-string">"30s"</span></span> healthy_deadline = <span class="hljs-string"><span class="hljs-string">"5m"</span></span> progress_deadline = <span class="hljs-string"><span class="hljs-string">"10m"</span></span> auto_revert = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } task <span class="hljs-string"><span class="hljs-string">"service-monitoring"</span></span> { driver = <span class="hljs-string"><span class="hljs-string">"docker"</span></span> config { image = <span class="hljs-string"><span class="hljs-string">"registry.domain.name/example/project:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CI_COMMIT_SHORT_SHA}</span></span></span><span class="hljs-string">"</span></span> force_pull = <span class="hljs-literal"><span class="hljs-literal">true</span></span> auth { username = <span class="hljs-string"><span class="hljs-string">"gitlab_user"</span></span> password = <span class="hljs-string"><span class="hljs-string">"gitlab_password"</span></span> } port_map { http = 8000 } } resources { network { port <span class="hljs-string"><span class="hljs-string">"http"</span></span> {} } } } } }</code> </pre> <br><br>  Bitte beachten Sie, dass ich eine private Registrierung habe und mich für einen erfolgreichen Docker-Image-Pool anmelden muss.  Die beste Lösung in diesem Fall ist die Eingabe eines Logins und eines Passworts in Vault mit der anschließenden Integration in Nomad.  Nomad unterstützt Vault von Haus aus.  Aber zuerst installieren wir in Vault selbst die erforderlichen Richtlinien für Nomad. Sie können sie herunterladen: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Download the policy and token role $ curl https://nomadproject.io/data/vault/nomad-server-policy.hcl -O -s -L $ curl https://nomadproject.io/data/vault/nomad-cluster-role.json -O -s -L # Write the policy to Vault $ vault policy write nomad-server nomad-server-policy.hcl # Create the token role with Vault $ vault write /auth/token/roles/nomad-cluster @nomad-cluster-role.json</span></span></code> </pre> <br><br>  Nachdem wir die erforderlichen Richtlinien erstellt haben, fügen wir die Integration mit Vault in den Taskblock in der Datei job.nomad ein: <br><br><pre> <code class="bash hljs">vault { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> address = <span class="hljs-string"><span class="hljs-string">"https://vault.domain.name:8200"</span></span> token = <span class="hljs-string"><span class="hljs-string">"token"</span></span> }</code> </pre> <br><br>  Ich verwende die Berechtigung per Token und schreibe sie direkt hier. Es besteht auch die Möglichkeit, das Token als Variable anzugeben, wenn der Nomad Agent ausgeführt wird: <br><br><pre> <code class="bash hljs">$ VAULT_TOKEN=&lt;token&gt; nomad agent -config /path/to/config</code> </pre><br><br>  Jetzt können wir die Schlüssel mit Vault verwenden.  Das Funktionsprinzip ist einfach: Wir erstellen im Nomad-Job eine Datei, in der die Werte von Variablen gespeichert werden, zum Beispiel: <br><br><pre> <code class="bash hljs">template { data = &lt;&lt;EOH {{with secret <span class="hljs-string"><span class="hljs-string">"secrets/pipeline-keys"</span></span>}} REGISTRY_LOGIN=<span class="hljs-string"><span class="hljs-string">"{{ .Data.REGISTRY_LOGIN }}"</span></span> REGISTRY_PASSWORD=<span class="hljs-string"><span class="hljs-string">"{{ .Data.REGISTRY_LOGIN }}{{ end }}"</span></span> EOH destination = <span class="hljs-string"><span class="hljs-string">"secrets/service-name.env"</span></span> env = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><br>  Mit diesem einfachen Ansatz können Sie die Lieferung von Containern an den Nomad-Cluster konfigurieren und in Zukunft damit arbeiten.  Ich werde sagen, dass ich bis zu einem gewissen Grad mit Nomad sympathisiere - es ist besser für kleine Projekte geeignet, bei denen Kubernetes zusätzliche Schwierigkeiten verursachen kann und sein Potenzial bis zum Ende nicht ausschöpft.  Darüber hinaus ist Nomad perfekt für Anfänger - es ist einfach zu installieren und zu konfigurieren.  Beim Testen einiger Projekte stoße ich jedoch auf das Problem früherer Versionen - viele Grundfunktionen existieren einfach nicht oder funktionieren nicht richtig.  Trotzdem glaube ich, dass sich Nomad weiterentwickeln und in Zukunft alle notwendigen Funktionen übernehmen wird. <br><br>  <i>Gepostet von Ilya Andreev, bearbeitet von Alexei Zhadan und Live Linux Team</i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453322/">https://habr.com/ru/post/de453322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453310/index.html">Datenaustausch zwischen React-Komponenten mithilfe der RxJS-Bibliothek</a></li>
<li><a href="../de453312/index.html">PDF Business E-Mail-Generator basierend auf XML-Daten</a></li>
<li><a href="../de453314/index.html">DIY Black Mirror - Unterrichte einen Bot basierend auf seiner Chat-Geschichte</a></li>
<li><a href="../de453316/index.html">Der britische Chiphersteller ARM stellt die Zusammenarbeit mit Huawei ein</a></li>
<li><a href="../de453318/index.html">5 Fehler bei der Implementierung von Push-Benachrichtigungen für mobile Anwendungen</a></li>
<li><a href="../de453324/index.html">Diode als Gleichrichter</a></li>
<li><a href="../de453326/index.html">So automatisieren Sie das IT-Infrastrukturmanagement - diskutieren Sie drei Trends</a></li>
<li><a href="../de453328/index.html">Zehn Jahre an einem abgelegenen Ort</a></li>
<li><a href="../de453330/index.html">Was tun, wenn der RAM abstürzt? Anamnese und Behandlungsmethoden</a></li>
<li><a href="../de453332/index.html">Über die seltsame Methode, Festplattenspeicher zu sparen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>