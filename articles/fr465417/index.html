<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏿 🤲🏾 🙇🏽 Plugins de volume de stockage Kubernetes: Flexvolume vers CSI 👨🏾‍🚒 🔝 🌙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À l'époque où Kubernetes était encore v1.0.0, les plugins de volume existaient. Ils étaient nécessaires pour se connecter aux systèmes Kubernetes afin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugins de volume de stockage Kubernetes: Flexvolume vers CSI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/465417/"><img src="https://habrastorage.org/webt/sj/ie/we/sjieweu7inrj2_yn3mxvtxe8vrw.png"><br><br>  À l'époque où Kubernetes était encore v1.0.0, les plugins de volume existaient.  Ils étaient nécessaires pour se connecter aux systèmes Kubernetes afin de stocker des données de conteneurs persistantes (permanentes).  Leur nombre était faible et parmi les premiers, il y avait des fournisseurs de stockage tels que GCE PD, Ceph, AWS EBS et autres. <br><br>  Les plug-ins ont été livrés avec Kubernetes, pour lequel ils ont obtenu leur nom - dans l'arborescence.  Cependant, beaucoup de l'ensemble existant de ces plug-ins n'était pas suffisant.  Les artisans ont ajouté des plugins simples au cœur de Kubernetes à l'aide de correctifs, après quoi ils ont construit leur propre Kubernetes et l'ont mis sur leurs serveurs.  Mais au fil du temps, les développeurs de Kubernetes ont réalisé que le <i>poisson</i> ne pouvait pas être résolu.  Les gens ont besoin d'une <i>canne à pêche</i> .  Et dans la version Kubernetes v1.2.0, il est apparu ... <a name="habracut"></a><br><br><h2>  Plugin Flexvolume: canne à pêche minimale </h2><br>  Les développeurs de Kubernetes ont créé le plugin FlexVolume, qui était une liaison logique de variables et de méthodes pour travailler avec des pilotes Flexvolume tiers. <br><br>  Arrêtons-nous et examinons de plus près ce qu'est le pilote FlexVolume.  Il s'agit d'un certain <b>fichier exécutable</b> ( <b>fichier</b> binaire, script Python, script Bash, etc.), qui, une fois exécuté, prend des arguments de ligne de commande et renvoie un message avec des champs précédemment connus au format JSON.  Par convention, le premier argument de ligne de commande est toujours la méthode et le reste des arguments sont ses paramètres. <br><br><img src="https://habrastorage.org/webt/ed/rp/2_/edrp2_n7i75s5meu4bgj5wmiydm.png"><br>  <i>CIFS Partage le schéma de connexion dans OpenShift.</i>  <i>Pilote Flexvolume - en plein centre</i> <br><br>  <b>L'ensemble minimal de méthodes</b> ressemble à ceci: <br><br><pre><code class="cs hljs">flexvolume_driver mount <span class="hljs-meta"><span class="hljs-meta">#      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver unmount #      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver init #     #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", // ,     attach/deatach "capabilities":{"attach": True/False} }</span></span></code> </pre> <br>  L'utilisation des méthodes d' <code>attach</code> et de <code>detach</code> déterminera le scénario selon lequel le futur kubelet agira lorsque le pilote sera appelé.  Il existe également des <code>expandfs</code> <code>expandvolume</code> et <code>expandfs</code> spéciales qui sont responsables du redimensionnement dynamique d'un volume. <br><br>  Comme exemple des changements que la méthode <code>expandvolume</code> , et avec elle la possibilité d'effectuer un redimensionnement du volume en temps réel, vous pouvez consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre demande de pull</a> dans l'opérateur Rook Ceph. <br><br>  Voici un exemple d'implémentation du pilote Flexvolume pour travailler avec NFS: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span></span>() { err <span class="hljs-string"><span class="hljs-string">"Invalid usage. Usage: "</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> init"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> mount &lt;mount dir&gt; &lt;json params&gt;"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> unmount &lt;mount dir&gt;"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* 1&gt;&amp;2 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* &gt;&amp;1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ismounted</span></span></span></span>() { MOUNT=`findmnt -n <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> 2&gt;/dev/null | cut -d<span class="hljs-string"><span class="hljs-string">' '</span></span> -f1` <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MOUNT}</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">domount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> NFS_SERVER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.server'</span></span>) SHARE=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.share'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 1 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> mkdir -p <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null mount -t nfs <span class="hljs-variable"><span class="hljs-variable">${NFS_SERVER}</span></span>:/<span class="hljs-variable"><span class="hljs-variable">${SHARE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failure\", \"message\": \"Failed to mount </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${NFS_SERVER}</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${SHARE}</span></span></span><span class="hljs-string"> at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 0 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> umount <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } op=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"init"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success", "capabilities": {"attach": false}}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -lt 2 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> usage <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mount) domount $* ;; unmount) unmount $* ;; *) <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Not supported"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1</code> </pre> <br>  Ainsi, après avoir préparé le fichier exécutable réel, vous devez <b>disposer le pilote dans le cluster Kubernetes</b> .  Le pilote doit être situé sur chaque nœud du cluster selon un chemin prédéfini.  Par défaut, a été sélectionné: <br><br> <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/__~_/</code> <br> <br>  ... mais en utilisant différentes distributions Kubernetes (OpenShift, Rancher ...) le chemin peut être différent. <br><br><h2>  Problèmes de flexvolume: comment lancer une canne à pêche? </h2><br>  Placer le pilote Flexvolume sur les nœuds du cluster s'est avéré être une tâche non triviale.  Après avoir effectué l'opération une fois manuellement, il est facile de rencontrer une situation où de nouveaux nœuds apparaissent dans le cluster: en raison de l'ajout d'un nouveau nœud, de la mise à l'échelle horizontale automatique ou, pire, du remplacement du nœud en raison d'un dysfonctionnement.  Dans ce cas, il est <b>impossible de</b> travailler avec le stockage sur ces nœuds jusqu'à ce que vous leur ajoutiez manuellement le pilote Flexvolume de la même manière. <br><br>  La solution à ce problème était l'une des primitives de Kubernetes - <code>DaemonSet</code> .  Lorsqu'un nouveau nœud apparaît dans le cluster, il obtient automatiquement un pod de notre DaemonSet, auquel un volume local est attaché en cours de route pour trouver les pilotes Flexvolume.  Une fois la création réussie, pod copie les fichiers nécessaires pour que le pilote fonctionne sur le disque. <br><br>  Voici un exemple d'un tel DaemonSet pour disposer le plugin Flexvolume: <br><br><pre> <code class="1c hljs">apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: flex-set spec: template: metadata: name: flex-deploy labels: app: flex-deploy spec: containers: - image: &lt;deployment_image&gt; name: flex-deploy securityContext: privileged: true volumeMounts: - mountPath: /flexmnt name: flexvolume-mount volumes: - name: flexvolume-mount hostPath: path: &lt;host_driver_directory&gt;</code> </pre> <br>  ... et un exemple de script Bash pour disposer un pilote Flexvolume: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -o errexit set -o pipefail VENDOR=k8s.io DRIVER=nfs driver_dir=$VENDOR${VENDOR:+"~"}${DRIVER} if [ ! -d "/flexmnt/$driver_dir" ]; then mkdir "/flexmnt/$driver_dir" fi cp "/$DRIVER" "/flexmnt/$driver_dir/.$DRIVER" mv -f "/flexmnt/$driver_dir/.$DRIVER" "/flexmnt/$driver_dir/$DRIVER" while : ; do sleep 3600 done</span></span></code> </pre> <br>  Il est important de ne pas oublier que l'opération de copie n'est <b>pas atomique</b> .  Il est fort probable que kubelet commence à utiliser le pilote avant la fin du processus de préparation, ce qui entraînera une erreur dans le système.  L'approche correcte serait de copier d'abord les fichiers du pilote sous un nom différent, puis d'utiliser l'opération de renommage atomique. <br><br><img src="https://habrastorage.org/webt/3k/zv/vd/3kzvvdbejy8mi47vpezfpjnqlus.png"><br>  <i>Schéma de travail avec Ceph dans l'instruction Rook: le pilote Flexvolume sur le diagramme est à l'intérieur de l'agent Rook</i> <br><br>  Le problème suivant lors de l'utilisation des pilotes Flexvolume est que pour la plupart des stockages <b>, le logiciel nécessaire doit être installé</b> sur le nœud du cluster (par exemple, le package ceph-common pour Ceph).  Initialement, le plugin Flexvolume n'était pas conçu pour implémenter de tels systèmes complexes. <br><br>  Une solution originale à ce problème peut être vue dans l'implémentation du pilote Flexvolume de l'opérateur Rook: <br><br>  Le pilote lui-même est conçu comme un client RPC.  La prise IPC pour la communication se trouve dans le même répertoire que le pilote lui-même.  Nous nous souvenons que pour copier des fichiers de pilote, il serait bon d'utiliser DaemonSet, qui connecte un répertoire avec le pilote en tant que volume.  Après avoir copié les fichiers de pilote de tour nécessaires, ce module ne meurt pas, mais se connecte au socket IPC via le volume attaché en tant que serveur RPC à part entière.  Le package ceph-common est déjà installé à l'intérieur du conteneur de pod.  Le socket IPC donne l'assurance que le kubelet communiquera avec le pod particulier situé sur le même nœud.  Tout ingénieux est simple! .. <br><br><h2>  Au revoir, nos affectueux ... plugins dans l'arbre! </h2><br>  Les développeurs de Kubernetes ont découvert que le nombre de plugins de stockage à l'intérieur du noyau est de vingt.  Et le changement dans chacun d'entre eux passe en quelque sorte par le cycle de sortie complet de Kubernetes. <br><br>  Il s'avère que pour utiliser la nouvelle version du plugin pour le stockage, <b>vous devez mettre à jour l'intégralité du cluster</b> .  En plus de cela, vous pouvez être surpris que la nouvelle version de Kubernetes devienne soudainement incompatible avec le noyau Linux utilisé ... Et donc, vous essuyez les larmes et serrez les dents et coordonnez avec les autorités et les utilisateurs le temps de mise à jour du noyau Linux et du cluster Kubernetes.  Avec un temps d'arrêt possible dans la prestation de services. <br><br>  La situation est plus que comique, non?  Il est devenu clair pour toute la communauté que l'approche n'avait pas fonctionné.  Avec une décision volontaire, les développeurs de Kubernetes annoncent que les nouveaux plugins de stockage ne seront plus acceptés dans le noyau.  Pour tout le reste, comme nous le savons déjà, dans la mise en œuvre du plugin Flexvolume, un certain nombre de lacunes ont été révélées ... <br><br>  Une fois pour toutes, le dernier plugin ajouté pour les volumes dans Kubernetes, CSI, a été appelé à résoudre le problème avec les entrepôts de données persistants.  Sa version alpha, plus communément appelée plugins de volume CSI hors arbre, a été annoncée dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.9</a> . <br><br><h2>  Interface de stockage de conteneurs, ou spinning CSI 3000! </h2><br>  Tout d'abord, je voudrais noter que CSI n'est pas seulement un plugin de volume, mais un véritable <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">standard</a> pour créer des composants personnalisés pour travailler avec des entrepôts de données</b> .  Il a été supposé que les systèmes d'orchestration de conteneurs, tels que Kubernetes et Mesos, devraient «apprendre» à travailler avec des composants mis en œuvre conformément à cette norme.  Et maintenant, Kubernetes a déjà appris. <br><br>  Quel est le périphérique du plugin CSI dans Kubernetes?  Le plugin CSI fonctionne avec des pilotes spéciaux (pilotes <b>CSI</b> ) écrits par des développeurs tiers.  Le pilote CSI dans Kubernetes doit au moins être composé de deux composants (pods): <br><br><ul><li>  <b>Contrôleur</b> - gère le stockage persistant externe.  Il est implémenté en tant que serveur gRPC pour lequel la primitive <code>StatefulSet</code> est utilisée. </li><li>  <b>Node</b> - est responsable du montage des magasins persistants sur les nœuds de cluster.  Il est également implémenté en tant que serveur gRPC, mais la primitive <code>DaemonSet</code> est utilisée pour cela. </li></ul><br><img src="https://habrastorage.org/webt/4h/vs/af/4hvsafmhi2tmja8fvc_qtzkqtfc.png"><br>  <i>Flux de travail du plugin CSI Kubernetes</i> <br><br>  Vous pouvez en apprendre davantage sur d'autres détails de CSI, par exemple, dans l'article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre le CSI</a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dont</a> nous avons publié la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> il y a un an. <br><br><h3>  Les avantages d'une telle implémentation </h3><br><ul><li>  Pour les choses de base - par exemple, pour enregistrer un pilote pour un nœud - les développeurs de Kubernetes ont implémenté un ensemble de conteneurs.  Vous n'avez plus besoin de créer vous-même une réponse JSON avec des fonctionnalités, comme cela a été fait pour le plugin Flexvolume. </li><li>  Au lieu de «glisser» les nœuds des fichiers exécutables, nous plaçons maintenant les pods dans le cluster.  C'est ce que nous attendions à l'origine de Kubernetes: tous les processus se produisent à l'intérieur de conteneurs déployés à l'aide de primitives Kubernetes. </li><li>  Pour implémenter des pilotes complexes, vous n'avez plus besoin de développer un serveur RPC et un client RPC.  Le client pour nous a été implémenté par les développeurs de Kubernetes. </li><li>  Passer des arguments pour travailler avec le protocole gRPC est beaucoup plus pratique, flexible et plus fiable que de les passer par des arguments de ligne de commande.  Pour comprendre comment ajouter la prise en charge des métriques d'utilisation du volume à CSI en ajoutant une méthode gRPC standardisée, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre demande d'extraction</a> pour le pilote vsphere-csi. </li><li>  La communication se fait via des sockets IPC afin de ne pas se tromper que le pod kubelet envoie ou non une requête. </li></ul><br>  Cette liste vous rappelle-t-elle quelque chose?  Les avantages de CSI sont la <b>solution aux problèmes mêmes</b> qui n'ont pas été pris en compte lors du développement du plugin Flexvolume. <br><br><h2>  Conclusions </h2><br>  CSI en tant que norme pour la mise en œuvre de plugins personnalisés pour interagir avec les entrepôts de données a été très chaleureusement accepté par la communauté.  De plus, en raison de ses avantages et de sa polyvalence, les pilotes CSI sont créés même pour des référentiels tels que Ceph ou AWS EBS, des plugins pour travailler avec qui ont été ajoutés dans la toute première version de Kubernetes. <br><br>  Début 2019, les plugins in-tree <a href="">étaient obsolètes</a> .  Il est prévu de continuer à prendre en charge le plugin Flexvolume, mais il n'y aura pas de développement de nouvelles fonctionnalités pour celui-ci. <br><br>  Nous avons nous-mêmes déjà de l'expérience avec ceph-csi, vsphere-csi et sommes prêts à ajouter à cette liste!  Jusqu'à présent, CSI fait face aux tâches qui lui sont assignées avec un bang, et là, nous attendons et voyons. <br><br>  N'oubliez pas que tout ce qui est nouveau est un vieux bien repensé! <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  «Nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comprenons l'interface de stockage de conteneurs (dans Kubernetes et pas seulement)</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tour ou pas Tour - c'est la question</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprendre à connaître la version alpha des instantanés de volume dans Kubernetes</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465417/">https://habr.com/ru/post/fr465417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465401/index.html">5 activités pour accélérer la résolution de problèmes dans n'importe quelle équipe informatique</a></li>
<li><a href="../fr465403/index.html">Achtung! Nouvelles caméras sur la route ou informations à jour sur les radars et détecteurs de radar</a></li>
<li><a href="../fr465407/index.html">1. Présentation des commutateurs Extreme Enterprise Layer</a></li>
<li><a href="../fr465409/index.html">Meilleures pratiques Vue.js pour le développement Web</a></li>
<li><a href="../fr465415/index.html">Nous parlons de DevOps dans un langage compréhensible</a></li>
<li><a href="../fr465419/index.html">Demain à l'Université ITMO: le processus éducatif, les concours et l'éducation à l'étranger - une sélection d'événements à venir</a></li>
<li><a href="../fr465423/index.html">Fabrication et industrie intelligentes 4.0: trois grandes tendances technologiques</a></li>
<li><a href="../fr465425/index.html">Vepp - le nouveau panneau de contrôle du serveur et du site Web d'ISPsystem</a></li>
<li><a href="../fr465427/index.html">Analyse du framework RPC Apache Dubbo par l'analyseur de code statique PVS-Studio</a></li>
<li><a href="../fr465429/index.html">Pourtant, C est un langage de bas niveau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>