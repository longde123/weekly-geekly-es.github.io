<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍽️ 🥔 😻 使用pytest进行Python测试。 pytest入门，第1章 🧘🏿 🆔 🎬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="返回 下一个 


 我发现使用pytest进行Python测试是pytest测试环境的非常有用的入门指南。 它已经给我带来了公司的红利。 
 
 克里斯·剃须刀 
 起义技术产品副总裁 





 本书中的示例是使用Python 3.6和pytest 3.2编写的。 pytest 3.2支持Py...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用pytest进行Python测试。 pytest入门，第1章</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448782/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p> <em>我发现使用pytest进行Python测试是pytest测试环境的非常有用的入门指南。</em>  <em>它已经给我带来了公司的红利。</em> <em><br></em> <br> 克里斯·剃须刀 <br> 起义技术产品副总裁 </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p> 本书中的示例是使用Python 3.6和pytest 3.2编写的。  pytest 3.2支持Python 2.6、2.7和Python 3.3+。 </p><br><blockquote> 本书网页上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">链接</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a>上提供了Tasks项目以及本书中显示的所有测试的源代码。 您无需下载源代码即可了解测试代码。 示例中以方便的形式提供了测试代码。 但是，为了跟上项目的任务，或者改编测试示例来测试自己的项目（不费力气！），您必须转到本书的网页并下载工作。 在该书的网页上，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/errata">勘误</a>信息链接和一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://forums.pragprog.com/forums/438">论坛</a> 。 </blockquote><p> 在剧透下方是该系列文章的列表。 </p><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>引言</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第1章：pytest入门</strong></a> （本文） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第2章：编写测试函数</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第3章：Pytest固定装置</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第4章：内置灯具</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第5章：插件</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第6章：配置</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第7章：与其他工具一起使用pytest</strong></a> </li></ul></div></div><br><h2 id="poehali"> 走吧 </h2><br><p> 这是测试： </p><br><blockquote>  <strong>ch1 / test_one.py</strong> </blockquote><br><pre><code class="plaintext hljs">def test_passing(): assert (1, 2, 3) == (1, 2, 3)</code> </pre> <br><p> 这是启动时的样子： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest test_one.py ===================== test session starts ====================== collected 1 items test_one.py . =================== 1 passed in 0.01 seconds ===================</code> </pre> <br><p><img src="https://habrastorage.org/webt/v0/ak/lu/v0aklucdm0i8nrqtk1v1dwb2oeg.png"></p><br><p>  <em>test_one.py</em>之后的点表示已运行一项测试并通过了测试。 如果需要更多信息，可以使用<code>-v</code>或<code>--verbose</code> ： </p><br><pre> <code class="plaintext hljs">$ pytest -v test_one.py ===================== test session starts ====================== collected 1 items test_one.py::test_passing PASSED =================== 1 passed in 0.01 seconds ===================</code> </pre> <br><p><img src="https://habrastorage.org/webt/ss/rb/7i/ssrb7i7io-h6ikadzulg5yncvyw.png"></p><br><p> 如果您有彩色端子，则“通过”和底线为绿色。 太好了！ </p><br><p> 这是一个失败的测试： </p><br><blockquote>  <strong>ch1 / test_two.py</strong> </blockquote><br><pre> <code class="plaintext hljs">def test_failing(): assert (1, 2, 3) == (3, 2, 1)</code> </pre> <br><p>  pytest显示测试失败的方式是开发人员喜欢pytest的众多原因之一。 让我们看看结果如何： </p><br><pre> <code class="plaintext hljs">$ pytest test_two.py ===================== test session starts ====================== collected 1 items test_two.py F =========================== FAILURES =========================== _________________________ test_failing _________________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Use -v to get the full diff test_two.py:2: AssertionError =================== 1 failed in 0.04 seconds ===================</code> </pre> <br><p><img src="https://habrastorage.org/webt/dr/sh/wu/drshwua2ie5btbcena-4xlewiz4.png"></p><br><p> 太好了！ 测试test <em>test_failing</em>的部分向我们展示了为什么失败。 </p><br><p>  pytest准确地报告了第一次崩溃：索引0不匹配。 </p><br><p> 该消息的很大一部分是红色，这使它真正脱颖而出（如果您有彩色端子）。 </p><br><p> 这已经是很多信息，但是有一行提示说使用<code>-v</code>可以得到更多关于差异的描述。 </p><br><p> 让我们挂钩这个<code>-v</code> ： </p><br><pre> <code class="plaintext hljs">$ pytest -v test_two.py ===================== test session starts ====================== collected 1 items test_two.py::test_failing FAILED =========================== FAILURES =========================== _________________________ test_failing _________________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Full diff: E - (1, 2, 3) E ? ^ ^ E + (3, 2, 1) E ? ^ ^ test_two.py:2: AssertionError =================== 1 failed in 0.04 seconds ===================</code> </pre> <br><p><img src="https://habrastorage.org/webt/u9/8l/dn/u98ldncvvmy1ha0ygy6krwekhvm.png"></p><br><p> 哇！ <br>  pytest添加脱字号（^）字符，以向我们确切显示差异。 <br> 如果您对pytest的编写，读取和运行测试的简易性以及对输出读取以查看发生故障的位置的简易性印象深刻，那么……您还没有看到任何东西。 它来自哪里，还有更多奇迹。 留下，让我向您展示为什么我认为pytest绝对是最佳的测试平台。 </p><br><p> 在本章的其余部分，您将安装pytest，查看运行它的各种方法，并遵循一些最常用的命令行选项。 在以后的章节中，您将学习如何编写使pytest功能发挥最大作用的测试函数，如何将安装代码放入设置和拆卸部分（称为Fixture）中，以及如何使用Fixture和插件使软件测试真正过载。 </p><br><p> 但是首先我要道歉。 很抱歉测试<code>assert (1, 2, 3) == (3, 2, 1)</code> ，这很无聊。 我听到打了吗？ 没有人会在现实生活中编写这样的测试。 软件测试由检查其他软件的代码组成，这些软件可能永远无法正常运行。 并且<code>(1, 2, 3) == (1, 2, 3)</code>将始终有效。 这就是为什么我们在本书的其余部分中不会使用像这样的愚蠢测试的原因。 我们将考虑对真实软件项目的测试。 我们将使用一个需要测试代码的示例Tasks项目。 希望这足够简单以至于易于理解，但又不至于变得无聊。 </p><br><p> 软件测试的另一个有用的应用程序是测试您对被测软件如何工作的假设，其中可能包括测试您对第三方模块和软件包的理解，甚至构建Python数据结构。 </p><br><p>  Tasks项目使用基于namedtuple factory方法的Task结构，该方法是标准库的一部分。 任务结构用作在用户界面和API之间传输信息的数据结构。 </p><br><p> 在本章的其余部分中，我将使用Task来演示如何启动pytest并使用一些常用的命令行选项。 </p><br><p> 这是任务： </p><br><pre> <code class="plaintext hljs">from collections import namedtuple Task = namedtuple('Task', ['summary', 'owner', 'done', 'id'])</code> </pre> <br><p> 在进入示例之前，让我们退后一步，讨论如何获取pytest并安装它。 </p><br><p> 自Python 2.6起，工厂<em>namedtuple（）</em>函数就存在了，但我仍然发现许多Python开发人员都不知道这有多酷。 至少，将任务用于测试用例比<code>(1, 2, 3) == (1, 2, 3)</code>或<code>(1, 2)==3</code>更有趣。 </p><br><p> 在继续示例之前，让我们退后一步，讨论在哪里获取pytest以及如何安装它。 </p><br><h2 id="dobyvaem-pytest"> 挖掘pytest </h2><br><p>  Pytest总部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.pytest.org</a> 。 这是官方文档。 但是它通过PyPI（Python包索引）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://pypi.python.org/pypi/pytest上</a>传播。 </p><br><p> 像通过PyPI分发的其他Python软件包一样，使用<strong>pip</strong>在用于测试的虚拟环境中安装pytest： </p><br><pre> <code class="plaintext hljs">$ pip3 install -U virtualenv $ python3 -m virtualenv venv $ source venv/bin/activate $ pip install pytest</code> </pre> <br><p> 如果您不熟悉virtualenv或pip，我将为您介绍。 请参阅第155页的附录1“虚拟环境”和第159页的附录2。 </p><br><p>  <strong>Windows，Python 2和venv呢？</strong> </p><br><p>  virtualenv和pip示例应在许多POSIX系统上运行，例如Linux和macOS，以及在许多版本的Python（包括Python 2.7.9和更高版本）上都可以使用。 </p><br><p> 该行中的<em>venv / bin / activate</em>源不适用于Windows，请改用<em>venv \ Scripts \ activate.bat</em> 。 <br> 这样做： </p><br><pre> <code class="plaintext hljs">C:\&gt; pip3 install -U virtualenv C:\&gt; python3 -m virtualenv venv C:\&gt; venv\Scripts\activate.bat (venv) C:\&gt; pip install pytest</code> </pre> <br><p> 对于Python 3.6及更高版本，您可以使用venv代替virtualenv，并且不必担心先安装它。 它包含在Python 3.6及更高版本中。 但是，我听说某些平台在使用virtualenv时仍然表现更好。 </p><br><h2 id="zapuskaem-pytest"> 运行pytest </h2><br><pre> <code class="plaintext hljs">$ pytest --help usage: pytest [options] [file_or_dir] [file_or_dir] [...] ...</code> </pre> <br><p> 没有参数，pytest将检查您的当前目录和测试文件的所有子目录，并运行找到的测试代码。 如果给pytest指定文件名，目录名或它们的列表，则会在此处找到它们，而不是当前目录。 递归检查命令行上指定的每个目录以找到测试代码。 </p><br><p> 例如，让我们创建一个名为task的子目录，并从以下测试文件开始： </p><br><blockquote>  <strong>ch1 /任务/ test_three.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""   Task.""" from collections import namedtuple Task = namedtuple('Task', ['summary', 'owner', 'done', 'id']) Task.__new__.__defaults__ = (None, None, False, None) def test_defaults(): """  ,      .""" t1 = Task() t2 = Task(None, None, False, None) assert t1 == t2 def test_member_access(): """  .field () namedtuple.""" t = Task('buy milk', 'brian') assert t.summary == 'buy milk' assert t.owner == 'brian' assert (t.done, t.id) == (False, None)</code> </pre> <br><p>  test_member_access（）测试旨在演示如何通过名称nd而不是通过索引访问成员，这是使用namedtuples的主要原因之一。 </p><br><p> 让我们在第二个文件中进行更多测试，以演示_asdict（）和_replace（）功能 </p><br><p> 您可以使用<em><code>__new __.__ defaults__</code></em>创建Task对象，而无需指定所有字段。  <em>test_defaults（）</em>测试旨在演示和测试默认设置的工作方式。 </p><br><p>  <em><code>test_member_access()</code></em>测试应演示如何不按索引访问名为nd的成员，这是使用namedtuples的主要原因之一。 <br> 让我们在第二个文件中添加更多测试，以演示<em><code>_asdict()</code></em>和<em><code>_replace()</code></em>函数 </p><br><blockquote>  <strong>ch1 /任务/ test_four.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""   Task.""" from collections import namedtuple Task = namedtuple('Task', ['summary', 'owner', 'done', 'id']) Task.__new__.__defaults__ = (None, None, False, None) def test_asdict(): """_asdict()   .""" t_task = Task('do something', 'okken', True, 21) t_dict = t_task._asdict() expected = {'summary': 'do something', 'owner': 'okken', 'done': True, 'id': 21} assert t_dict == expected def test_replace(): """    fields.""" t_before = Task('finish book', 'brian', False) t_after = t_before._replace(id=10, done=True) t_expected = Task('finish book', 'brian', True, 10) assert t_after == t_expected</code> </pre> <br><p> 要运行pytest，您可以选择指定文件和目录。 如果您未指定任何文件或目录，则pytest将在当前工作目录和子目录中搜索测试。 它搜索以test_开头或以_test结尾的文件。 如果从ch1目录运行pytest而不使用命令，则将对四个文件运行测试： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest ===================== test session starts ====================== collected 6 items test_one.py . test_two.py F tasks/test_four.py .. tasks/test_three.py .. =========================== FAILURES =========================== _________________________ test_failing _________________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Use -v to get the full diff test_two.py:2: AssertionError ============== 1 failed, 5 passed in 0.08 seconds ==============</code> </pre> <br><p><img src="https://habrastorage.org/webt/ut/2o/kw/ut2okwbdqprgbriqvfswsjd-7ti.png"></p><br><p> 要仅运行我们的新任务测试，可以为pytest提供要运行的所有文件名或目录，或者从我们的测试所在的目录中调用pytest： </p><br><pre> <code class="plaintext hljs">$ pytest tasks/test_three.py tasks/test_four.py ===================== test session starts ====================== collected 4 items tasks/test_three.py .. tasks/test_four.py .. =================== 4 passed in 0.02 seconds =================== $ pytest tasks ===================== test session starts ====================== collected 4 items tasks/test_four.py .. tasks/test_three.py .. =================== 4 passed in 0.03 seconds =================== $ cd /path/to/code/ch1/tasks $ pytest ===================== test session starts ====================== collected 4 items test_four.py .. test_three.py .. =================== 4 passed in 0.02 seconds ===================</code> </pre> <br><p><img src="https://habrastorage.org/webt/or/77/t4/or77t4go_qqok-v8qnenx5rxcjy.png"></p><br><p>  pytest通过并找到要运行的测试的pytest执行部分称为测试发现。  pytest之所以能够找到我们要运行的所有测试，是因为我们根据pytest命名约定对它们进行了命名。 </p><br><p> 以下是命名约定的简要概述，以便可以使用pytest检测到您的测试代码： </p><br><ul><li> 测试文件应命名为<code>test_&lt;something&gt;.py</code>或<code>&lt;something&gt;_test.py</code> 。 </li><li> 测试方法和功能应称为<code>test_&lt;something&gt;</code> 。 </li><li> 测试类应称为<code>Test&lt;Something&gt;</code> 。 </li></ul><br><p> 由于我们的测试文件和函数<code>test_</code> ，所以一切都很好。 如果您有一堆名称不同的测试，则有多种方法可以更改这些发现规则。 <br> 我将在第113页的第6章“配置”中进行介绍。 </p><br><p> 让我们仔细看看只运行一个文件的结果： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1/tasks $ pytest test_three.py ================= test session starts ================== platform darwin -- Python 3.6.2, pytest-3.2.1, py-1.4.34, pluggy-0.4.0 rootdir: /path/to/code/ch1/tasks, inifile: collected 2 items test_three.py .. =============== 2 passed in 0.01 seconds ===============</code> </pre> <br><p> 结果告诉了我们很多。 </p><br><blockquote>  =====测试会话开始==== </blockquote><p>  。 </p><br><p>  pytest提供了一个优雅的分隔符来启动测试会话。 会话是单个pytest调用，包括在多个目录中运行的所有测试。 当我在第56页的夹具区域定义中谈论与pytest夹具有关的会话区域时，该会话定义变得很重要。 </p><br><p> 达尔文平台-在我的Mac上。 在Windows计算机上，平台是不同的。 以下是Python和pytest的版本，以及对pytest软件包的依赖。  py和pluggy都是pytest团队开发的软件包，可帮助实现pytest。 </p><br><blockquote>  <strong>rootdir：/路径/到/代码/ ch1 /任务，ini文件：</strong> </blockquote><p>  <code>rootdir</code>是在其中搜索测试代码的所有目录的最顶层共享目录。  <code>inifile</code> （此处为空）列出了使用的配置文件。 配置文件可以是<code>pytest.ini</code> ， <code>tox.ini</code>或<code>setup.cfg</code> 。 有关配置文件的更多信息，请参阅第113页第6章，“配置”。 </p><br><blockquote>  <strong>收集了2个项目</strong> </blockquote><p> 这是文件中的两个测试功能。 </p><br><blockquote>  <strong>test_three.py ..</strong> </blockquote><p>  <code>test_three.py</code>显示测试文件。 每个测试文件只有一行。 两点表示测试已通过-每个测试功能或方法一个点。 点仅用于通过测试。 失败，错误，跳过，xfails和xpass分别用F，E，s，x和X表示。 如果要查看更多通过测试的要点，请使用<code>-v</code>或<code>--verbose</code>选项。 </p><br><blockquote>  == 2在0.01秒内通过== </blockquote><p> 该行表示通过的测试数和整个测试会话所花费的时间。 如果有通过测试，则每个类别的编号也会在此处显示。 </p><br><p> 测试结果是执行测试或查看结果的用户了解测试过程中发生的情况的主要方式。 在pytest中，测试函数可以有几种不同的结果，而不仅仅是通过或失败。 这是测试功能的可能结果： </p><br><ul><li> 通过（。）：测试成功完成。 </li><li> 失败（F）：测试失败（或XPASS +严格）。 </li><li> 跳过：跳过了测试。 您可以使用<code>@pytest.mark.skip()</code>或<code>pytest.mark.skipif()</code>装饰器<code>pytest.mark.skipif()</code>跳过测试，如第34页的“跳过测试”部分所述。 </li><li>  xfail（x）：测试不应该通过，它已经启动并且失败。 您可以使用<code>@pytest.mark.xfail()</code>装饰器<code>@pytest.mark.xfail()</code>第37页的测试标记中将其描述为预期失败<code>@pytest.mark.xfail()</code>来强制pytest指示测试失败。 </li><li>  XPASS（X）：测试不应该通过，它已经启动并通过！ </li><li> 错误（E）：在测试功能之外发生了异常，无论是在第49章第3章pytest固定装置中讨论的夹具中，还是在第95章第5章的插件中讨论的钩子函数中都发生了异常。 </li></ul><br><h2 id="vypolnenie-tolko-odnogo-testa"> 仅执行一项测试 </h2><br><p> 开始编写测试后，可能要做的第一件事就是只运行一个。 直接指定文件并添加名称<code>::test_name</code> ： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -v tasks/test_four.py::test_asdict =================== test session starts =================== collected 3 items tasks/test_four.py::test_asdict PASSED ================ 1 passed in 0.01 seconds =================</code> </pre> <br><p> 现在让我们看一些选项。 </p><br><h2 id="ispolzovanie-opciy"> 使用选项 </h2><br><p> 我们已经使用了verbose， <code>-v</code>或<code>--verbose</code>选项几次，但是还有许多值得了解的选项。 在本书中，我们将只使用其中的一些。 您可以使用pytest <code>--help</code>选项查看完整列表。 </p><br><p> 以下是一些在使用pytest时非常有用的选项。 这不是一个完整的列表，但是这些选项足以启动。 </p><br><pre> <code class="plaintext hljs">$ pytest --help usage: pytest [options] [file_or_dir] [file_or_dir] [...] ... subset of the list ... positional arguments: file_or_dir general: -k EXPRESSION only run tests which match the given substring expression. An expression is a python evaluatable expression where all names are substring-matched against test names and their parent classes. Example: -k 'test_method or test_other' matches all test functions and classes whose name contains 'test_method' or 'test_other', while -k 'not test_method' matches those that don't contain 'test_method' in their names. Additionally keywords are matched to classes and functions containing extra names in their 'extra_keyword_matches' set, as well as functions which have names assigned directly to them. -m MARKEXPR only run tests matching given mark expression. example: -m 'mark1 and not mark2'. --markers show markers (builtin, plugin and per-project ones). -x, --exitfirst exit instantly on first error or failed test. --maxfail=num exit after first num failures or errors. ... --capture=method per-test capturing method: one of fd|sys|no. -s shortcut for --capture=no. ... --lf, --last-failed rerun only the tests that failed at the last run (or all if none failed) --ff, --failed-first run all tests but run the last failures first. This may re-order tests and thus lead to repeated fixture setup/teardown ... reporting: -v, --verbose increase verbosity. -q, --quiet decrease verbosity. --verbosity=VERBOSE set verbosity ... -l, --showlocals show locals in tracebacks (disabled by default). --tb=style traceback print mode (auto/long/short/line/native/no). ... --durations=N show N slowest setup/test durations (N=0 for all). ... collection: --collect-only only collect tests, don't execute them. ... test session debugging and configuration: --basetemp=dir base temporary directory for this test run.(warning: this directory is removed if it exists) --version display pytest lib version and import information. -h, --help show help message and configuration info</code> </pre><br><h3 id="--collect-only">  -仅收集 </h3><br><p>  <code>--collect-only</code>指示将使用给定的参数和配置执行哪些测试。 首先显示此参数很方便，以便将输出用作其他示例的参考。 如果您从ch1目录开始，则应该看到到目前为止在本章中已经看到的所有测试功能： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --collect-only =================== test session starts =================== collected 6 items &lt;Module 'test_one.py'&gt; &lt;Function 'test_passing'&gt; &lt;Module 'test_two.py'&gt; &lt;Function 'test_failing'&gt; &lt;Module 'tasks/test_four.py'&gt; &lt;Function 'test_asdict'&gt; &lt;Function 'test_replace'&gt; &lt;Module 'tasks/test_three.py'&gt; &lt;Function 'test_defaults'&gt; &lt;Function 'test_member_access'&gt; ============== no tests ran in 0.03 seconds ===============</code> </pre> <br><p>  <code>--collect-only</code>对于验证是否正确选择了在运行测试之前选择测试的其他选项很有用。 我们将再次使用它与<code>-k</code>一起显示其工作原理。 </p><br><h3 id="-k-expression">  -k表达 </h3><br><p>  <code>-k</code>允许您使用表达式来定义测试功能。 </p><br><p> 一个非常强大的选择！ 如果名称是唯一的，它可以用作运行单独测试的快捷方式，或者运行名称中具有通用前缀或后缀的一组测试。 假设您要运行测试<code>test_asdict()</code>和<code>test_defaults()</code> 。 您可以使用以下方法检查过滤器：-- <code>--collect-only</code> ： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -k "asdict or defaults" --collect-only =================== test session starts =================== collected 6 items &lt;Module 'tasks/test_four.py'&gt; &lt;Function 'test_asdict'&gt; &lt;Module 'tasks/test_three.py'&gt; &lt;Function 'test_defaults'&gt; =================== 4 tests deselected ==================== ============== 4 deselected in 0.03 seconds ===============</code> </pre> <br><p> 是的 这类似于我们所需要的。 现在，您可以通过删除<code>--collect-only</code>来运行它们： </p><br><pre> <code class="plaintext hljs">$ pytest -k "asdict or defaults" =================== test session starts =================== collected 6 items tasks/test_four.py . tasks/test_three.py . =================== 4 tests deselected ==================== ========= 2 passed, 4 deselected in 0.03 seconds ==========</code> </pre> <br><p> 糟糕！ 只是点。 所以他们过去了。 但是他们是正确的测试吗？ 一种找出方法是使用<code>-v</code>或<code>--verbose</code> ： </p><br><pre> <code class="plaintext hljs">$ pytest -v -k "asdict or defaults" =================== test session starts =================== collected 6 items tasks/test_four.py::test_asdict PASSED tasks/test_three.py::test_defaults PASSED =================== 4 tests deselected ==================== ========= 2 passed, 4 deselected in 0.02 seconds ==========</code> </pre> <br><p> 是的 这些是正确的测试。 </p><br><h3 id="-m-markexpr">  -m MARKEXPR </h3><br><p> 标记是标记一部分测试功能以一起运行的最佳方法之一。 例如，即使它们在单独的文件中，运行<code>test_replace()</code>和<code>test_member_access()</code>一种方法是对其进行标记。 可以使用任何标记名称。 假设您要使用<code>run_these_please</code> 。 使用<code>@pytest.mark.run_these_please</code>装饰器记录测试，如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest ... @pytest.mark.run_these_please <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_member_access</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p> 现在对<code>test_replace()</code>相同。 然后，您可以使用<code>pytest -m run_these_please</code>使用相同的标记运行所有测试： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1/tasks $ pytest -v -m run_these_please ================== test session starts =================== collected 4 items test_four.py::test_replace PASSED test_three.py::test_member_access PASSED =================== 2 tests deselected =================== ========= 2 passed, 2 deselected in 0.02 seconds =========</code> </pre> <br><p> 标记表达不必是单个标记。 您可以将<code>-m "mark1 and mark2"</code>等选项用于带有两个标记的测试，将<code>-m "mark1 and not mark2"</code>用于具有标签1但没有标签2的测试， <code>-m "mark1 or mark2"</code>用于测试与其中之一等，我将在第31页的“标记验证方法”中更详细地讨论标记。 </p><br><h3 id="-x---exitfirst">  -x，--exitfirst </h3><br><p>  <em>pytest</em>的正常行为是运行它找到的所有测试。 如果测试功能检测到<em>断言</em>或<em>异常</em>失败，则此测试将停止并且测试将失败。 然后<em>pytest</em>运行下一个测试。 在大多数情况下，这就是您所需要的。 但是，尤其是在调试问题时，如果测试不正确，它将立即干扰整个测试会话。 这是<code>-x</code>选项的作用。 让我们在目前进行的六个测试中尝试一下： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -x ====================== test session starts ==================== collected 6 items test_one.py . test_two.py F ============================ FAILURES ========================= __________________________ test_failing _______________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Use -v to get the full diff test_two.py:2: AssertionError =============== 1 failed, 1 passed in 0.38 seconds ============</code> </pre><br><p> 在输出的顶部，您看到所有六个测试（或“项目”）均已收集，在最底行，您看到一个测试失败并通过了一个测试，而<em>pytest</em>显示了“ Interrupted”行让我们知道他已经停止了。 如果没有<code>-x</code>则将运行所有六个测试。 让我们在没有<code>-x</code>情况下再次重复。 我们还使用<code>--tb=no</code>来禁用堆栈跟踪，因为您已经看到了它，而不必再次看到它： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --tb=no =================== test session starts =================== collected 6 items test_one.py . test_two.py F tasks/test_four.py .. tasks/test_three.py .. =========== 1 failed, 5 passed in 0.09 seconds ============</code> </pre> <br><p>   ,   <code>-x</code> , pytest    <em>test_two.py</em>    . </p><br><h3 id="--maxfailnum"> --maxfail=num </h3><br><p>  <code>-x</code>       .   ,      ,    ,   <code>--maxfail</code> ,  ,    .            ,      .     ,    <code>--maxfail = 2</code> ,    ,  <code>--maxfail = 1</code>    ,  <code>-x</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --maxfail=2 --tb=no =================== test session starts =================== collected 6 items test_one.py . test_two.py F tasks/test_four.py .. tasks/test_three.py .. =========== 1 failed, 5 passed in 0.08 seconds ============ $ pytest --maxfail=1 --tb=no =================== test session starts =================== collected 6 items test_one.py . test_two.py F !!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!! =========== 1 failed, 1 passed in 0.19 seconds ============</code> </pre> <br><p> E    <code>--tb=no</code> ,   . </p><br><h3 id="-s-and---capturemethod"> -s and --capture=method </h3><br><p>  <code>-s</code>    —    ,     <em>stdout</em> ,           .     <code>--capture=no</code> .   ,        .      ,      ,     ,      .  <code>-s</code>  <code>--capture=no</code>    .         <code>print()</code> ,       . </p><br><p>  ,           , <code>-l/--showlocals</code> ,      ,    . </p><br><p>     <code>--capture=fd</code>  <code>--capture=sys</code> . —  <code>--capture=sys</code>  <code>sys.stdout/stderr</code>  mem-.  <code>--capture=fd</code>    1  2   . </p><br><p>    <code>sys</code>  <code>fd</code>  . ,  ,        .    <code>-s</code> .    ,   <code>-s</code> ,      . </p><br><p>          ;    .   ,       ,      . </p><br><h3 id="-lf---last-failed"> -lf, --last-failed </h3><br><p>              .   <code>--lf</code>     : </p><br><p>  ,     <code>--tb</code> ,    ,         . </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --lf =================== test session starts =================== run-last-failure: rerun last 1 failures collected 6 items test_two.py F ======================== FAILURES ========================= ______________________ test_failing _______________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Use -v to get the full diff test_two.py:2: AssertionError =================== 5 tests deselected ==================== ========= 1 failed, 5 deselected in 0.08 seconds ==========</code> </pre> <br><h3 id="ff---failed-first"> –ff, --failed-first </h3><br><p>  <code>--ff/--failed-first</code>     ,   <code>--last-failed</code> ,     ,    : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --ff --tb=no =================== test session starts =================== run-last-failure: rerun last 1 failures first collected 6 items test_two.py F test_one.py . tasks/test_four.py .. tasks/test_three.py .. =========== 1 failed, 5 passed in 0.09 seconds ============</code> </pre> <br><p>  <code>test_failing()</code>  <code>test\_two.py</code>   <code>test\_one.py</code> . ,  <code>test_failing()</code>     , <code>--ff</code>       </p><br><h3 id="-v---verbose"> -v, --verbose </h3><br><p>  <code>-v/--verbose</code>      .     ,       ,        . </p><br><p>      ,           <code>--ff</code>  <code>--tb=no</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -v --ff --tb=no =================== test session starts =================== run-last-failure: rerun last 1 failures first collected 6 items test_two.py::test_failing FAILED test_one.py::test_passing PASSED tasks/test_four.py::test_asdict PASSED tasks/test_four.py::test_replace PASSED tasks/test_three.py::test_defaults PASSED tasks/test_three.py::test_member_access PASSED =========== 1 failed, 5 passed in 0.07 seconds ============</code> </pre> <br><p><img src="https://habrastorage.org/webt/bw/7f/_4/bw7f_4irv2astplpl5tobqp_xqs.png"></p><br><p>           FAILED   PASSED. </p><br><h3 id="-q---quiet"> -q, --quiet </h3><br><p>  <code>-q/--quiet</code>  <code>-v/--verbose</code> ;      .        <code>--tb=line</code> ,          . </p><br><p>  - <code>q</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -q .F.... ======================== FAILURES ========================= ______________________ test_failing _______________________ def test_failing(): &gt; assert (1, 2, 3) == (3, 2, 1) E assert (1, 2, 3) == (3, 2, 1) E At index 0 diff: 1 != 3 E Full diff: E - (1, 2, 3) E ? ^ ^ E + (3, 2, 1) E ? ^ ^ test_two.py:2: AssertionError 1 failed, 5 passed in 0.08 seconds</code> </pre> <br><p>  <code>-q</code>    ,    .      <code>-q</code>     (  <code>--tb=no</code> ),    ,        . </p><br><h3 id="-l---showlocals"> -l, --showlocals </h3><br><p>    <code>-l/--showlocals</code>         <code>tracebacks</code>   . </p><br><p>            .     <code>test_replace()</code>   </p><br><pre> <code class="plaintext hljs">t_expected = Task('finish book', 'brian', True, 10)</code> </pre> <br><p> 在 </p><br><pre> <code class="plaintext hljs">t_expected = Task('finish book', 'brian', True, 11)</code> </pre> <br><p> 10  11   .       .         <code>--l/--showlocals</code> : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest -l tasks =================== test session starts =================== collected 4 items tasks/test_four.py .F tasks/test_three.py .. ======================== FAILURES ========================= ______________________ test_replace _______________________ @pytest.mark.run_these_please def test_replace(): """replace() should change passed in fields.""" t_before = Task('finish book', 'brian', False) t_after = t_before._replace(id=10, done=True) t_expected = Task('finish book', 'brian', True, 11) &gt; assert t_after == t_expected E AssertionError: assert Task(summary=...e=True, id=10) == Task(summary='...e=True, id=11) E At index 3 diff: 10 != 11 E Use -v to get the full diff t_after = Task(summary='finish book', owner='brian', done=True, id=10) t_before = Task(summary='finish book', owner='brian', done=False, id=None) t_expected = Task(summary='finish book', owner='brian', done=True, id=11) tasks\test_four.py:28: AssertionError =========== 1 failed, 3 passed in 0.08 seconds ============</code> </pre> <br><p><img src="https://habrastorage.org/webt/c1/f_/vk/c1f_vkcnpoeplpn9arlb-fgj85a.png"></p><br><p>   <code>t_after</code> , <code>t_before</code>  <code>t_expected</code>      ,       assert-. </p><br><h3 id="--tbstyle"> --tb=style </h3><br><p>  <code>--tb=style</code>       .    pytest        ,    ,    .  <em>tracebacks</em>    ,  ,   .    <code>--tb=style</code> . ,    ,  short, line  no. <code>short</code>    <em>assert</em>   <strong>E</strong>  ; <code>line</code>     ; <em>no</em>   . </p><br><p>     <code>test_replace()</code> ,    ,       . <code>--tb=no</code>    </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --tb=no tasks =================== test session starts =================== collected 4 items tasks/test_four.py .F tasks/test_three.py .. =========== 1 failed, 3 passed in 0.04 seconds ============</code> </pre> <br><blockquote> --tb=line in many cases is enough to tell what's wrong. If you have a ton of failing tests, this option can help to show a pattern in the failures: </blockquote><p> <code>--tb=line</code>    ,  ,   .      ,        : </p><br><pre> <code class="plaintext hljs">$ pytest --tb=line tasks =================== test session starts =================== collected 4 items tasks/test_four.py .F tasks/test_three.py .. ======================== FAILURES ========================= /path/to/code/ch1/tasks/test_four.py:20: AssertionError: assert Task(summary=...e=True, id=10) == Task( summary='...e=True, id=11) =========== 1 failed, 3 passed in 0.05 seconds ============</code> </pre> <br><p>    verbose tracebacks <code>--tb=short</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --tb=short tasks =================== test session starts =================== collected 4 items tasks/test_four.py .F tasks/test_three.py .. ======================== FAILURES ========================= ______________________ test_replace _______________________ tasks/test_four.py:20: in test_replace assert t_after == t_expected E AssertionError: assert Task(summary=...e=True, id=10) == Task( summary='...e=True, id=11) E At index 3 diff: 10 != 11 E Use -v to get the full diff =========== 1 failed, 3 passed in 0.04 seconds ============</code> </pre> <br><p>   ,   ,  . </p><br><p>     ,     . </p><br><p> pytest <code>--tb=long</code>       traceback. pytest <code>--tb=auto</code>         <em>tracebacks</em> ,      .    . pytest <code>--tb=native</code>     <em>traceback</em>   . </p><br><h3 id="--durationsn"> --durations=N </h3><br><p>  <code>--durations=N</code>  ,       .     ;    N  tests/setups/teardowns   .    <code>--durations=0</code> ,            . </p><br><p>      ,   <code>time.sleep(0.1)</code>    . , : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch1 $ pytest --durations=3 tasks ================= test session starts ================= collected 4 items tasks/test_four.py .. tasks/test_three.py .. ============== slowest 3 test durations =============== 0.10s call tasks/test_four.py::test_replace 0.00s setup tasks/test_three.py::test_defaults 0.00s teardown tasks/test_three.py::test_member_access ============== 4 passed in 0.13 seconds</code> </pre> <br><p>     <em>sleep</em>      ,      .        : call(), (setup)  (teardown).      ,                    ,  ,  ,  .       3, pytest Fixtures,  . 49. </p><br><h3 id="--version"> --version </h3><br><p>  <code>--version</code>   pytest  ,    : </p><br><pre> <code class="plaintext hljs">$ pytest --version This is pytest version 3.0.7, imported from /path/to/venv/lib/python3.5/site-packages/pytest.py</code> </pre> <br><p>    pytest   , pytest     site-packages   . </p><br><h3 id="-h---help"> -h, --help </h3><br><p>  <code>-h/--help</code>  ,   ,     pytest.     ,   stock- pytest,       ,      ,  . </p><br><p>  <code>-h</code> : </p><br><ul><li> : pytest [] [file_or_dir] [file_or_dir] [...] </li><li>      ,      </li><li>  ,   ini   ,        6, ,  . 113 </li><li>   ,      pytest (    6, ,  . 113) </li><li>   ,  pytest <code>--markers</code>      ,    2,   ,  . 23 </li><li>   ,  pytest <code>--fixtures</code>       ,    3,  pytest,  . 49 </li></ul><br><p>        : </p><br><pre> <code class="plaintext hljs">(shown according to specified file_or_dir or current dir if not specified)</code> </pre> <br><p>   ,  ,            .   ,         pytest    conftest.py,    - (hook functions),   ,     . </p><br><p>    pytest   conftest.py               .     conftest.py  ini,   pytest.ini   6 «»,   113. </p><br><h2 id="uprazhneniya"> 练习题 </h2><br><ol><li><p>    ,  <code>python -m virtualenv</code>  <code>python -m venv</code> .    ,        ,    ,       ,   ,      .      ,      .   1,  ,  . 155,     . </p><br></li><li><p>        . </p><br><pre> <code class="plaintext hljs">- $ source venv/bin/activate - $ deactivate On Windows: - C:\Users\okken\sandbox&gt;venv\scripts\activate.bat - C:\Users\okken\sandbox&gt;deactivate</code> </pre> <br></li><li><p>  pytest    . .  2, pip,   159,     .    ,      pytest,       ,     . </p><br></li><li><p>    .    ,          .  pytest   . </p><br></li><li><p>   assert.    assert something == something_else;   , : </p><br><ul><li> assert 1 in [2, 3, 4] </li><li> assert a &lt; b </li><li> assert 'fizz' not in 'fizzbuzz' </li></ul><br></li></ol><br><h2 id="chto-dalshe"> 接下来是什么 </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本章中，我们研究了在哪里获取pytest以及各种运行方式。</font><font style="vertical-align: inherit;">但是，我们没有讨论测试功能中包含的内容。</font><font style="vertical-align: inherit;">在下一章中，我们将考虑编写测试函数，对其进行参数化，以便使用不同的数据调用它们，并将测试分组为类，模块和包。</font></font></p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448782/">https://habr.com/ru/post/zh-CN448782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448770/index.html">更新了Visual Studio Code中的Razor支持。 现在有了烈焰</a></li>
<li><a href="../zh-CN448774/index.html">使用DBMS_SQL的SQL至CSV</a></li>
<li><a href="../zh-CN448776/index.html">RxVMS-适用于Flutter应用程序的实用架构</a></li>
<li><a href="../zh-CN448778/index.html">为Visual Studio Enterprise 2019引入时间旅行调试</a></li>
<li><a href="../zh-CN448780/index.html">什么使软件可以赚钱</a></li>
<li><a href="../zh-CN448786/index.html">使用pytest进行Python测试。 第3章pytest固定装置</a></li>
<li><a href="../zh-CN448788/index.html">使用pytest进行Python测试。 第2章，编写测试函数</a></li>
<li><a href="../zh-CN448790/index.html">SpaceVIL-用于在.Net Core，.Net Standard和JVM上开发的跨平台GUI框架</a></li>
<li><a href="../zh-CN448796/index.html">使用pytest进行Python测试。 配置，第6章</a></li>
<li><a href="../zh-CN448798/index.html">使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>