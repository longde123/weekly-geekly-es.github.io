<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš± ğŸ¤“ ğŸ•´ğŸ½ Menyimpan data dalam EEPROM pada Arduino secara transaksi ğŸ‘´ğŸ¼ ğŸ’“ ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kehadiran EEPROM memberi pengembang alat yang nyaman untuk menyimpan parameter konfigurasi atau kondisi yang perlahan berubah sehingga pemadaman listr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menyimpan data dalam EEPROM pada Arduino secara transaksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482918/">  Kehadiran EEPROM memberi pengembang alat yang nyaman untuk menyimpan parameter konfigurasi atau kondisi yang perlahan berubah sehingga pemadaman listrik harus bertahan.  Pada artikel ini kita akan melihat bagaimana melakukan ini seaman dan senyaman mungkin agar tidak melupakan apa pun dan tidak mengingat apa yang tidak ada. <br><a name="habracut"></a><br>  Misalkan kita memiliki variabel dan kita ingin menyimpannya dalam EEPROM.  Tampaknya semua alat untuk ini ada di tangan kita: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;EEPROM.h&gt; int my_var = DEFAULT_VALUE; EEPROM.get(MY_VAR_ADDR, my_var); my_var = NEW_VALUE; EEPROM.put(MY_VAR_ADDR, my_var);</span></span></span></span></code> </pre> <br>  Namun, pandangan yang lebih dekat mengungkapkan bahwa pendekatan ini menciptakan lebih banyak masalah daripada yang dipecahkan.  Kami akan membahasnya secara berurutan. <br><br>  1. Bagaimana memastikan bahwa kita membaca dengan tepat apa yang kita tulis (untuk menjamin <b>integritas</b> )?  Bayangkan gambar berikut.  Kami menulis surat untuk diri kami sendiri jika kami mati mendadak karena kehilangan daya atau sinyal reset dan meletakkannya di laci meja.  Dalam kehidupan selanjutnya, kita membuka laci meja, mengambil selembar kertas, membaca pesan dan melanjutkan misi kita.  Masalahnya adalah bahwa di dalam kotak selalu ada lembaran kertas yang ditulis dengan teks acak.  Jadi kita perlu cara untuk membedakan pesan yang benar dari yang acak.  Orang bisa meyakinkannya tentang notaris, tetapi dalam kasus yang paling sederhana, tanda tangannya akan cukup jika kita memiliki cara untuk memverifikasi kebenarannya.  Sebagai contoh, kita dapat menggunakan hasil dari ekspresi matematika tergantung pada teks sebagai tanda tangan, sehingga kemungkinan kebetulan acak cukup kecil.  Dalam kasus paling sederhana, ini adalah CRC atau checksum.  Ini akan melindungi kita tidak hanya dari membaca apa yang tidak kita tulis, tetapi juga dari membaca pesan yang rusak.  Setelah semua, teks memudar dari waktu ke waktu, dan elektron dalam rana yang terisolasi bahkan kurang tahan lama - partikel akan terbang dari ruang angkasa dengan energi yang cukup, dan bit akan berubah.  Tetapi ada cara lain untuk mendapatkan pesan yang rusak - ini bukan untuk menambahkannya sampai akhir.  Ini tidak begitu eksotis, karena pada saat pencatatan, konsumsi saat ini meningkat tajam, yang dapat memicu kematian dini penulis. <br><br>  2. Misalkan kita yakin akan kebenaran pesan, tetapi bagaimana saya bisa memastikan bahwa akulah yang menulisnya (untuk menjamin <b>keaslian</b> ).  Seperti kata pepatah, saya berbeda.  Tiba-tiba, orang lain duduk di meja ini sebelum reinkarnasi saya, dan dia memiliki misi yang berbeda, dan untuk alasan apa saya sekarang akan dibimbing oleh pesannya?  Jika kita memberikan catatan kita dengan label tertentu, akan lebih mudah bagi kita untuk membedakan label kita dari orang asing.  Misalnya, label seperti itu bisa menjadi nama variabel yang kita simpan.  Satu-satunya masalah adalah bahwa di EEPROM tidak ada banyak ruang untuk meletakkan nama variabel di sana, dan itu tidak nyaman untuk melakukannya, karena mereka memiliki panjang yang berbeda.  Tapi untungnya ada cara yang lebih sederhana - Anda dapat menghitung checksum atas nama variabel dan menggunakannya sebagai jalan pintas.  Pada saat yang sama, penting untuk menambahkan ukuran variabel dalam byte ke checksum ini agar tidak secara tidak sengaja membaca jumlah yang salah.  Nah, demi kelengkapan, kami menambahkan pengenal numerik lain di sana, untuk menjamin membedakan variabel kami dari orang lain, bahkan jika mereka disebut sama.  Kami menyebut nomor ini sebagai pengenal instan (terinspirasi oleh OOP jika nama variabel dianggap sebagai bidang objek).  Jika kami meningkatkan misi kami ke versi baru yang radikal, sehingga pembaruan ini membuat semua yang lama tidak masuk akal disimpan, maka kita hanya perlu mengubah pengenal instan untuk membatalkan semua yang disimpan oleh versi lama. <br><br>  3. Bagaimana saya bisa membuat operasi penulisan yang tidak lengkap membiarkan nilai lama yang disimpan tidak berubah?  Artinya, operasi penyelamatan harus berhasil, atau seharusnya tidak memiliki efek yang dapat diamati sama sekali.  Dengan kata lain, itu harus <b>atomik</b> atau transaksional jika kita berbicara tentang transaksi yang turun ke pembaruan tanpa syarat dari satu nilai.  Jelas, kami tidak dapat memastikan keaslian rekaman dengan menulis ulang nilai sebelumnya, kami harus menulis ke tempat baru sehingga nilai yang tersimpan lama tetap utuh, setidaknya sampai selesainya rekaman yang baru.  Teknik ini sering disebut 'copy-on-write' jika hanya sebagian dari nilai yang disimpan diperbarui, tetapi bagian yang tetap tidak berubah masih disalin dan ditulis ke lokasi baru.  Mengembangkan analogi kita, kita akan menulis surat kepada diri kita sendiri, membiarkan yang lama tidak tersentuh, tetapi memasok setiap surat dengan nomor seri yang meningkat sehingga dalam kehidupan kita selanjutnya kita memiliki kesempatan untuk menemukan huruf terakhir yang kita tulis.  Namun, pada saat yang sama, muncul masalah baru - tempat di kotak tempat kami meletakkan surat-surat itu akan berakhir cepat atau lambat jika kita tidak membuang surat-surat lama yang telah menjadi tidak relevan.  Mudah dipahami bahwa cukup hanya menyimpan 2 huruf - satu lama dan satu baru, mungkin sedang dalam proses penulisan.  Karenanya, nomor surat juga tidak perlu banyak bit. <br><br>  Anehnya, penulis tidak dapat menemukan satu implementasi yang akan memungkinkan organisasi penyimpanan data di EEPROM, sambil memastikan integritas, keaslian, dan atomisitas.  Saya harus menulis sendiri ke <a href="https://github.com/olegv142/NvTx" rel="nofollow">github.com/olegv142/NvTx</a> <br><br>  Untuk menyimpan setiap variabel di EEPROM, 2 area berturut-turut digunakan - sel dengan struktur yang sama.  Pengidentifikasi variabel dihitung berdasarkan ukurannya, label teks dan pengenal contoh ditulis dalam 2 byte pertama.  Selanjutnya, data ditulis, diikuti oleh 2 byte checksum.  Pada byte pertama, dua bit memiliki tujuan khusus.  Bit yang paling signifikan adalah flag kebenaran, ketika menulis, itu selalu diatur ke satu.  Bit orde rendah digunakan sebagai nomor bit-tunggal era, diperlukan untuk menemukan pesan terakhir.  Rekaman dilakukan dalam sel 'dalam lingkaran'.  Nomor era berubah setiap kali catatan dibuat di sel pertama.  Oleh karena itu algoritma untuk menentukan sel yang terakhir direkam: jika zaman sel adalah sama, maka yang kedua ditulis terakhir, jika berbeda - maka yang pertama. <br><br>  Bit yang benar tampaknya berlebihan, tetapi memiliki fungsi penting.  Pertama-tama, kami membaca data yang disimpan dan memeriksa kebenaran kedua sel.  Jika sel tidak lulus pemeriksaan untuk pengidentifikasi atau checksum yang benar, kami mereset bit kebenarannya.  Operasi penulisan selanjutnya mungkin tidak memeriksa kebenaran sel, tetapi bergantung pada flag ini, yang mengurangi overhead sekitar 2 kali. <br><br>  Mereka yang ingin mempelajari detail implementasi dapat melihat gambar dan kode di <a href="https://github.com/olegv142/NvTx" rel="nofollow">repositori</a> .  Saya, agar tidak membuat pembaca bosan, teruslah gunakan.  Fungsi menulis / membaca data masing-masing menerima 5 parameter, sehingga kenyamanan penggunaannya dikorbankan demi fleksibilitas.  Tapi itu dengan murah hati dikompensasi oleh dua set makro, yang membuat menggunakan perpustakaan sesederhana dalam kasus EEPROM.get / put.  Set makro pertama digunakan jika Anda hanya ingin menyimpan variabel ke alamat yang diberikan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; bool have_my_var = NvTxGetAt(my_var, MY_VAR_ADDR); my_var = NEW_VALUE; NvTxPutAt(my_var, MY_VAR_ADDR);</span></span></span></span></code> </pre><br>  Jika ada beberapa variabel yang akan disimpan, masing-masing harus menentukan alamat dan pada saat yang sama mempertimbangkan ukuran sehingga area memori tempat variabel disimpan tidak tumpang tindih.  Untuk menyederhanakan tugas, set makro kedua mengimplementasikan alokasi alamat otomatis, dan melakukan ini <b>pada waktu kompilasi</b> .  Sebagai contoh, <a href="https://github.com/thijse/Arduino-EEPROMEx" rel="nofollow">perpustakaan Arduino-EEPROMEx</a> dapat mengalokasikan memori saat runtime, sementara itu menyimpan alamat dalam RAM untuk setiap variabel yang disimpan.  Pustaka <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> mengalokasikan ruang di EEPROM tanpa menambahkan apa pun ke kode yang dapat dieksekusi atau isi RAM. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; char my_string[16] = ""; NvPlace(my_var, MY_START_ADDR, MY_INST_ID); NvAfter(my_string, my_var); bool have_my_var = NvTxGet(my_var); my_var = NEW_VALUE; NvTxPut(my_var);</span></span></span></span></code> </pre><br>  Makro NvPlace menetapkan alamat awal area EEPROM, tempat kami akan menyimpan variabel, dan pengidentifikasi contoh.  Makro NvAfter cadangan wilayah memori untuk menyimpan argumen pertama segera setelah wilayah memori disediakan untuk yang kedua.  Saat mengalokasikan memori, juga diverifikasi bahwa kami tidak melampaui ukuran EEPROM yang tersedia, dan juga kami tidak memesan area memori yang tumpang tindih (ini dapat terjadi jika dua NvAfter makro memiliki argumen kedua yang sama).  Jika terjadi pelanggaran terhadap salah satu dari dua kondisi yang ditentukan, program tidak dapat dikompilasi.  Mereka yang ingin berurusan dengan mekanisme alokasi memori akan menemukannya di file header <a href="" rel="nofollow">NvTx.h.</a>  Semua makro NvPlace dan NvAfter lakukan adalah mendefinisikan enumerasi, membentuk nama mereka berdasarkan nama variabel, dan juga menggunakan konstruksi idiomatis yang sangat berguna dari <a href="" rel="nofollow">waktu kompilasi yang ditegaskan</a> . <br><br>  Semoga perpustakaan <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> akan membantu pembaca menulis kode kelas industri yang andal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482918/">https://habr.com/ru/post/id482918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482902/index.html">Tidak, kecerdasan buatan tidak bisa mengalahkan kita</a></li>
<li><a href="../id482904/index.html">Sejarah Singkat Mikroprosesor Ruang, Bagian Satu</a></li>
<li><a href="../id482906/index.html">Tentang keamanan jaringan</a></li>
<li><a href="../id482908/index.html">Bagian kedua dari terjemahan buku David Kouchner, Masters of Doom. Bab 6-12</a></li>
<li><a href="../id482912/index.html">Gagasan jaringan sosial desentralisasi generasi berikutnya</a></li>
<li><a href="../id482920/index.html">Bagaimana autopilot melaju ke dalam kehidupan kita, tetapi kita tidak menyadarinya</a></li>
<li><a href="../id482922/index.html">Drupal Digest - 2019 / Desember</a></li>
<li><a href="../id482926/index.html">Arc adalah sistem kontrol versi untuk monorepositori. Laporan Yandex</a></li>
<li><a href="../id482928/index.html">Visi Predator: Efek Penglihatan Termal</a></li>
<li><a href="../id482930/index.html">Penelitian silsilah - buku metrik, sensus, arsip, database terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>