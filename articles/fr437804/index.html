<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 📅 🎿 Puis-je utiliser Redux sur un serveur? 👍🏻 👭 🅰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redux est un excellent outil pour gérer l'état des applications frontales complexes. L'auteur du document, dont nous publions la traduction aujourd'hu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Puis-je utiliser Redux sur un serveur?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437804/">  Redux est un excellent outil pour gérer l'état des applications frontales complexes.  L'auteur du document, dont nous publions la traduction aujourd'hui, va trouver la réponse à la question de savoir s'il est possible de profiter des fonctionnalités de Redux dans l'environnement serveur. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ff/f8d/685/4fff8d685687bacff24db95abaadd05b.png" alt="image"></a> <a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pourquoi ai-je besoin d'une bibliothèque Redux?</font> </h2><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page d'accueil de la</a> bibliothèque Redux indique qu'il s'agit d'un «conteneur d'état prévisible pour les applications JavaScript».  Redux est généralement appelé un outil pour gérer l'état d'une application, et bien que cette bibliothèque soit principalement utilisée avec React, elle peut être utilisée dans tous les projets basés sur JavaScript. <br><br>  Nous avons déjà mentionné que Redux est utilisé pour contrôler l'état d'une application.  Parlons maintenant de ce qu'est une «condition».  Ce concept est assez difficile à définir, mais nous essayons toujours de le décrire. <br><br>  En considérant l '"état", si nous parlons de personnes ou d'objets du monde matériel, nous cherchons à décrire, en fait, leur état au moment où nous en parlons, en considérant éventuellement un ou plusieurs paramètres.  Par exemple, nous pouvons dire au sujet du lac: "L'eau est très chaude" ou: "L'eau est gelée".  Dans ces déclarations, nous décrivons l'état du lac en termes de température de l'eau. <br><br>  Quand quelqu'un dit de lui-même: «Je suis échoué», il considère le montant d'argent dont il dispose.  Il est clair que dans chacun de ces exemples, nous ne parlons que d'un aspect de l'état des objets.  Mais, dans l'exemple de l'argent, la déclaration peut être celle qui décrit plusieurs paramètres: "Je suis échoué, je n'ai pas mangé depuis longtemps, mais je suis heureux!".  Il est très important de noter ici que l'État est quelque chose d'impermanent.  Cela signifie que cela peut changer.  Par conséquent, lorsque nous apprenons l'état actuel d'un certain objet, nous comprenons que son état réel peut changer quelques secondes ou minutes après que nous en ayons pris connaissance. <br><br>  Lorsque nous traitons de programmes, certaines fonctionnalités sont associées au concept d '«état».  Premièrement, l'état de l'application est représenté par des données stockées quelque part.  Par exemple, ces données peuvent être stockées en mémoire (par exemple, en tant qu'objet JavaScript), mais elles peuvent être stockées dans un fichier, dans une base de données et en utilisant un mécanisme de mise en cache comme Redis.  Deuxièmement, l'état d'une application est généralement lié à son instance spécifique.  Par conséquent, lorsque nous parlons de l'état de l'application, nous entendons une instance spécifique de cette application, un processus, un environnement de travail organisé dans l'application pour un utilisateur spécifique.  Un état d'application peut inclure, par exemple, les informations suivantes: <br><br><ul><li>  L'utilisateur est-il connecté ou non?  Si oui, combien de temps dure la session et quand va-t-elle expirer? </li><li>  Combien de points l'utilisateur a-t-il marqués?  Une telle question est pertinente, par exemple, pour un certain jeu. </li><li>  Où l'utilisateur a-t-il mis la vidéo en pause?  Cette question peut être posée sur l'application du lecteur vidéo. </li></ul><br>  Si nous parlons de l'état des applications à un niveau inférieur, cela peut inclure, par exemple, les informations suivantes: <br><br><ul><li>  Quelles variables sont définies dans l'environnement actuel dans lequel l'application s'exécute (il s'agit des «variables d'environnement»). </li><li>  Quels fichiers le programme utilise-t-il actuellement? </li></ul><br>  En regardant le «snapshot» (ils sont souvent appelés «snapshots» - à partir d'un instantané) du statut de l'application à tout moment, nous pouvons en apprendre davantage sur les conditions dans lesquelles l'application a fonctionné à ce moment et, si nécessaire, recréer ces conditions en application à l'état dans lequel il se trouvait au moment de la réception de l'instantané. <br><br>  L'état peut être modifié lors de l'exécution de certaines actions par l'utilisateur.  Par exemple, si l'utilisateur déplace correctement le personnage du jeu dans un jeu simple, cela peut augmenter le nombre de points.  Dans des applications assez complexes, l'approche de modification d'un état peut devenir plus compliquée; les changements d'état peuvent provenir de différentes sources. <br><br>  Par exemple, dans une partie multijoueur, le nombre de points qu'un utilisateur marque dépend non seulement de ses actions, mais aussi des actions de ceux qui jouent avec lui dans la même équipe.  Et si un personnage contrôlé par ordinateur attaque avec succès un personnage de jeu que l'utilisateur contrôle, l'utilisateur peut perdre un certain nombre de points. <br><br>  Imaginez que nous développons une application frontale comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PWA Twitter</a> .  Il s'agit d'une application d'une page qui comporte plusieurs onglets, par exemple - Accueil, Recherche, Notifications et Messages.  Chacun de ces onglets possède son propre espace de travail, qui est destiné à la fois à l'affichage de certaines informations et à sa modification.  Toutes ces données constituent l'état de l'application.  Ainsi, de nouveaux tweets, notifications et messages arrivent dans l'application toutes les quelques secondes.  L'utilisateur peut travailler avec le programme et avec ces données.  Par exemple, il peut créer un tweet ou le supprimer, il peut retweeter un tweet, il peut lire des notifications, envoyer des messages à quelqu'un, etc.  Tout ce qui vient d'être discuté modifie l'état de l'application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/221/468/f01221468374f7a04c099abb43513871.png"></div><br>  <i><font color="#999999">Tous ces onglets ont leur propre ensemble de composants d'interface utilisateur utilisés pour afficher et modifier les données.</font></i>  <i><font color="#999999">L'état de l'application peut être affecté par les données entrant dans l'application de l'extérieur et les actions de l'utilisateur</font></i> <br><br>  Il est clair que dans une telle application, les sources de changements d'état peuvent être différentes entités, tandis que les changements initiés par différentes sources peuvent se produire presque simultanément.  Si nous gérons l'état manuellement, il peut s'avérer difficile pour nous de surveiller ce qui se passe.  Ces difficultés conduisent à des contradictions.  Par exemple, un tweet peut être supprimé, mais il sera toujours affiché dans le flux de tweet.  Ou, disons, l'utilisateur peut lire la notification ou le message, mais il sera toujours affiché dans le programme comme non visualisé. <br><br>  L'utilisateur peut aimer le tweet, un cœur apparaîtra dans l'interface du programme, mais une requête réseau qui envoie des informations similaires au serveur ne fonctionnera pas.  Par conséquent, ce que l'utilisateur voit sera différent de ce qui est stocké sur le serveur.  C'est pour éviter de telles situations que Redux peut être nécessaire. <br><br><h2>  <font color="#3AC1EF">Comment fonctionne Redux?</font> </h2><br>  Dans la bibliothèque Redux, il existe trois concepts principaux qui visent à rendre la gestion de l'état des applications simple et directe: <br><br><ol><li>  Stockage (magasin).  Un référentiel Redux est un objet JavaScript qui représente l'état d'une application.  Il joue le rôle de "la seule source de données fiables".  Cela signifie que l'application entière doit s'appuyer sur le stockage comme seule entité responsable de la représentation de l'État. </li><li>  Actions  Le magasin d'état est en lecture seule.  Cela signifie qu'il ne peut pas être modifié en y accédant directement.  La seule façon de modifier le contenu du référentiel est d'utiliser des actions.  Tout composant qui souhaite changer d'état doit prendre les mesures appropriées. </li><li>  Réducteurs (réducteurs), également appelés "convertisseurs".  Un réducteur est une fonction pure qui décrit comment un état est modifié par des actions.  Le réducteur prend l'état et l'action actuels, dont l'exécution a été demandée par un certain composant de l'application, après quoi il retourne l'état transformé. </li></ol><br>  L'utilisation de ces trois concepts signifie que l'application ne doit plus surveiller directement les événements qui sont des sources de changements d'état (actions de l'utilisateur, réponses API, l'occurrence d'événements associés à la réception de certaines données via le protocole WebSocket, etc.) et prendre des décisions sur la façon dont ces événements affecteront la condition. <br><br>  En utilisant le modèle Redux, ces événements peuvent déclencher des actions qui changeront d'état.  Les composants qui ont besoin d'utiliser des données stockées dans l'état de l'application peuvent simplement s'abonner aux changements d'état et recevoir des informations qui les intéressent.  En utilisant tous ces mécanismes, Redux s'engage à apporter des changements prévisibles à l'état de l'application. <br><br>  Voici un exemple schématique qui montre comment organiser un système de gestion d'état simple à l'aide de Redux dans notre application fictive: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const tweets = (state = {tweets: []}, action) =&gt; {  switch (action.type) {    //     ,     .    case 'SHOW_NEW_TWEETS':      state.numberOfNewTweets = action.count;      return state.tweets.concat([action.tweets]);    default:      return state;  } }; //  ,     . SHOW_NEW_TWEETS const newTweetsAction = (tweets) =&gt; {  return {      type: 'SHOW_NEW_TWEETS',      tweets: tweets,      count: tweets.length  }; }; const store = createStore(tweets); twitterApi.fetchTweets()  .then(response =&gt; {    //  ,        ,    //    Redux.    store.dispatch(newTweetsAction(response.data));  }); //  ,    SHOW_NEW_TWEETS     //         . const postTweet = (text) =&gt; {  twitterApi.postTweet(text)  .then(response =&gt; {    store.dispatch(newTweetsAction([response.data]));  }); }; // ,  ,   WebSocket,   . //         . SHOW_NEW_TWEETS socket.on('newTweets', (tweets) =&gt; { store.dispatch(newTweetsAction(tweets)); }; //     ,  React,       , // ,         . //         , //    . store.subscribe(() =&gt; {  const { tweets } = store.getSTate();  render(tweets); });</span></span></code> </pre> <br>  En prenant ce code comme base, nous pouvons équiper notre système de gestion de l'état de l'application avec des actions supplémentaires et les envoyer depuis différents endroits de l'application sans risquer de confusion désespérée. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> matériel à partir duquel vous pouvez en apprendre davantage sur les trois principes fondamentaux de Redux. <br><br>  Parlons maintenant de l'utilisation de Redux dans un environnement de serveur. <br><br><h2>  <font color="#3AC1EF">Migration des principes Redux vers l'environnement du serveur</font> </h2><br>  Nous avons exploré les fonctionnalités de Redux utilisées dans le développement d'applications clientes.  Mais, étant donné que Redux est une bibliothèque JavaScript, elle peut théoriquement également être utilisée dans un environnement de serveur.  Nous réfléchirons à la façon dont les principes ci-dessus peuvent être appliqués sur le serveur. <br><br>  Vous vous souvenez de la façon dont nous avons parlé de l'état de l'application client?  Il convient de noter qu'il existe des différences conceptuelles entre les applications client et serveur.  Ainsi, les applications clientes ont tendance à maintenir l'état entre divers événements, par exemple, entre l'exécution des demandes au serveur.  Ces applications sont appelées applications avec état. <br><br>  S'ils ne s'efforçaient pas de stocker l'état, alors, par exemple, lorsqu'il travaille avec un certain service Web qui nécessite un identifiant et un mot de passe, l'utilisateur devrait effectuer cette procédure chaque fois qu'il accède à une nouvelle page de l'interface Web correspondante. <br><br>  Les applications dorsales, en revanche, s'efforcent de ne pas stocker l'état (elles sont également appelées applications sans état).  Ici, en parlant d '«applications backend», nous entendons principalement des projets basés sur certaines API distinctes des applications frontales.  Cela signifie que des informations sur l'état du système doivent être fournies à des applications similaires à chaque accès.  Par exemple, l'API ne contrôle pas si l'utilisateur est connecté ou non.  Il détermine son état en analysant le jeton d'authentification dans ses demandes à cette API. <br><br>  Cela nous amène à une raison importante pour laquelle Redux ne serait guère utilisé sur des serveurs sous la forme dans laquelle nous avons décrit ses capacités ci-dessus. <br><br>  Le fait est que Redux a été conçu pour stocker l'état temporaire de l'application.  Mais l'état de l'application stockée sur le serveur doit généralement exister suffisamment longtemps.  Si vous utilisiez le référentiel Redux dans votre application Node.js côté serveur, l'état de cette application serait effacé à chaque arrêt du processus de <code>node</code> .  Et si nous parlons d'un serveur PHP qui implémente un schéma de gestion d'état similaire, alors l'état sera effacé lorsque chaque nouvelle demande arrivera sur le serveur. <br><br>  La situation est encore plus compliquée si l'on considère les applications serveur en termes d'évolutivité.  Si vous deviez faire évoluer l'application horizontalement, en augmentant le nombre de serveurs, vous auriez alors de nombreux processus Node.js en cours d'exécution en même temps, et chacun aurait sa propre option d'état.  Cela signifie qu'avec la réception simultanée de deux demandes identiques au backend, des réponses différentes auraient pu être données. <br><br>  Comment appliquer les principes de gestion des états dont nous avons discuté sur le serveur?  Jetons un autre regard sur les concepts Redux et voyons comment ils sont généralement utilisés dans un environnement de serveur: <br><br><ol><li>  Dépôt.  Sur le backend, «la seule source de données fiables» est généralement une base de données.  Parfois, afin de faciliter l'accès aux données qui sont souvent nécessaires, ou pour une autre raison, une copie d'une partie de cette base de données peut être faite - sous la forme d'un cache ou sous la forme d'un fichier.  En règle générale, ces copies sont en lecture seule.  Les mécanismes qui les contrôlent sont abonnés aux modifications dans le référentiel principal et, lorsque ces modifications se produisent, mettent à jour le contenu des copies. </li><li>  Actions et réducteurs.  Ce sont les seuls mécanismes utilisés pour changer d'état.  Dans la plupart des applications backend, le code est écrit dans un style impératif, ce qui n'est pas particulièrement propice à l'utilisation de concepts d'action et de réducteurs. </li></ol><br>  Considérons deux modèles de conception qui, par leur nature, sont similaires à ce que la bibliothèque Redux vise à faire.  Ce sont CQRS et Event Sourcing.  En fait, ils ont comparu devant Redux, leur mise en œuvre peut être extrêmement difficile, nous allons donc en parler très brièvement. <br><br><h2>  <font color="#3AC1EF">CQRS et sourçage d'événements</font> </h2><br>  CQRS (Command Query Responsibility Segregation) est un modèle de conception, dans la mise en œuvre duquel l'application lit les données du magasin uniquement à l'aide de requêtes et écrit uniquement à l'aide de commandes. <br><br>  Lorsque vous utilisez CQRS, la seule façon de changer l'état d'une application est d'envoyer une commande.  Les commandes sont similaires aux actions Redux.  Par exemple, dans Redux, vous pouvez écrire du code qui correspond à ce schéma: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CREATE_NEW_USER'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: ... }; store.dispatch(action); <span class="hljs-comment"><span class="hljs-comment">//      const createUser = (state = {}, action) =&gt; { // };</span></span></code> </pre> <br>  Lorsque vous utilisez CQRS, quelque chose comme ceci ressemblerait à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      class Command { handle() { } } class CreateUserCommand extends Command { constructor(user) {   super();   this.user = user; } handle() {   //        } } const createUser = new CreateUserCommand(user); //   (   handle()) dispatch(createUser); //      CommandHandler commandHandler.handle(createUser);</span></span></code> </pre> <br>  Les requêtes sont des mécanismes de lecture de données dans le modèle CQRS.  Ils sont équivalents à la construction <code>store.getState()</code> .  Dans une implémentation CQRS simple, les requêtes interagiront directement avec la base de données, récupérant les enregistrements de celle-ci. <br><br>  Le modèle Event Sourcing est conçu pour enregistrer toutes les modifications de l'état de l'application sous la forme d'une séquence d'événements.  Ce modèle est mieux adapté aux applications qui doivent connaître non seulement leur état actuel, mais également l'historique de ses modifications, la façon dont l'application a atteint son état actuel.  À titre d'exemples, vous pouvez citer l'historique des opérations avec les comptes bancaires, le suivi des colis, le traitement des commandes dans les magasins en ligne, l'organisation du transport de marchandises, la logistique. <br><br>  Voici un exemple d'implémentation du modèle Event Sourcing: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   BankAccount.where({ id: fromAccount.id })     .decrement({ amount });   BankAccount.where({ id: toAccount.id })     .increment({ amount }); } function makeOnlinePayment(account, amount) {   BankAccount.where({ id: account.id })     .decrement({ amount }); } //    Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   dispatchEvent(new TransferFrom(fromAccount, amount, toAccount));   dispatchEvent(new TransferTo(toAccount, amount, fromAccount)); } function makeOnlinePayment(account, amount) {   dispatchEvent(new OnlinePaymentFrom(account, amount)); } class TransferFrom extends Event {   constructor(account, amount, toAccount) {     this.account = account;     this.amount = amount;     this.toAccount = toAccount;   }     handle() {     //    OutwardTransfer        OutwardTransfer.create({ from: this.account, to: this.toAccount, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } } class TransferTo extends Event {   constructor(account, amount, fromAccount) {     this.account = account;     this.amount = amount;     this.fromAccount = fromAccount;   }     handle() {     //    InwardTransfer        InwardTransfer.create({ from: this.fromAccount, to: this.account, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .increment({ amount: this.amount });   } } class OnlinePaymentFrom extends Event {   constructor(account, amount) {     this.account = account;     this.amount = amount;   }     handle() {     //    OnlinePayment        OnlinePayment.create({ from: this.account, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } }</span></span></code> </pre> <br>  Ce qui se passe ici ressemble également à l'utilisation des actions Redux. <br><br>  Cependant, le mécanisme d'enregistrement des événements organise également le stockage à long terme des informations sur chaque changement d'état, et pas seulement le stockage de l'état lui-même.  Cela nous permet de reproduire ces modifications au point dans le temps dont nous avons besoin, rétablissant ainsi le contenu de l'état de l'application à ce moment.  Par exemple, si nous devons comprendre combien d'argent était dans le compte bancaire pour une certaine date, nous devons seulement reproduire les événements qui se sont produits avec le compte bancaire jusqu'à ce que nous arrivions à la bonne date.  Les événements dans ce cas sont représentés par des entrées de fonds sur le compte et par leur débit, par le débit de la commission bancaire et d'autres opérations similaires.  Si des erreurs se produisent (c'est-à-dire lorsque des événements contenant des données incorrectes se produisent), nous pouvons invalider l'état actuel de l'application, corriger les données correspondantes et revenir à l'état actuel de l'application, désormais formé sans erreur. <br><br>  Les modèles CQRS et Event Sourcing sont souvent utilisés ensemble.  Et, fait intéressant, Redux, en fait, est en partie basé sur ces modèles.  Les commandes peuvent être écrites de manière à ce qu'elles soient envoyées, lorsqu'elles sont appelées.  Ensuite, les événements interagissent avec le référentiel (base de données) et mettent à jour l'état.  Dans les applications en temps réel, les objets de requête peuvent également écouter les événements et recevoir des informations d'état mises à jour du référentiel. <br><br>  L'utilisation de l'un de ces modèles dans une application simple peut compliquer inutilement la tâche.  Cependant, dans le cas d'applications conçues pour résoudre des problèmes commerciaux complexes, CQRS et Event Sourcing sont de puissantes abstractions qui aident à mieux modéliser le domaine de ces applications et à améliorer leur gestion d'état. <br><br>  Veuillez noter que les modèles CQRS et Event Sourcing peuvent être implémentés de différentes manières, tandis que certaines de leurs implémentations sont plus complexes que d'autres.  Nous n'avons considéré que des exemples très simples de leur mise en œuvre.  Si vous écrivez des applications serveur dans Node.js, jetez un œil à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wolkenkit</a> .  Ce cadre, parmi ce qui a été trouvé dans ce domaine, fournit au développeur l'une des interfaces les plus simples pour implémenter les modèles CQRS et Event Sourcing. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Redux est un excellent outil pour gérer l'état d'une application, afin de rendre les changements d'état prévisibles.  Dans cet article, nous avons parlé des concepts clés de cette bibliothèque et constaté que, bien que l'utilisation de Redux dans un environnement de serveur ne soit probablement pas une bonne idée, vous pouvez appliquer des principes similaires sur un serveur à l'aide des modèles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CQRS</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Event Sourcing</a> . <br><br>  <b>Chers lecteurs!</b>  Comment organisez-vous la gestion de l'état des applications client et serveur? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437804/">https://habr.com/ru/post/fr437804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437792/index.html">Les Gémeaux ont obtenu des résultats «mystérieux» en vérifiant 5 services de recherche d'ancêtres ADN</a></li>
<li><a href="../fr437794/index.html">Sauvegarde rapide et fiable des données dans le cloud 2</a></li>
<li><a href="../fr437796/index.html">AlphaStar a-t-il implémenté la vitesse surhumaine en tant que patch pour l'erreur d'entraînement à la simulation?</a></li>
<li><a href="../fr437800/index.html">ScrumBut dans l'équipe d'analyse: avant le décollage</a></li>
<li><a href="../fr437802/index.html">Innovate Cloud Technology: Catastrophic Cloud</a></li>
<li><a href="../fr437806/index.html">EcmaScript 10 - JavaScript de cette année (ES2019)</a></li>
<li><a href="../fr437808/index.html">Perf et graphes de flamme</a></li>
<li><a href="../fr437810/index.html">Réalité d'entreprise</a></li>
<li><a href="../fr437812/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 et autres bêtas</a></li>
<li><a href="../fr437814/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 et autres versions bêta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>