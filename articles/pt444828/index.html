<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèø üöø üêª Uma explica√ß√£o simples dos algoritmos de localiza√ß√£o de caminhos e A * üëò üç£ üèä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1. Algoritmo de pesquisa geral 
 1. Introdu√ß√£o 
 Encontrar um caminho √© um desses t√≥picos que geralmente s√£o os mais dif√≠ceis para os desenvolve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma explica√ß√£o simples dos algoritmos de localiza√ß√£o de caminhos e A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="imagem"></div><br><h2>  Parte 1. Algoritmo de pesquisa geral </h2><br><h2>  1. Introdu√ß√£o </h2><br>  Encontrar um caminho √© um desses t√≥picos que geralmente s√£o os mais dif√≠ceis para os desenvolvedores de jogos.  As pessoas especialmente pobres entendem o algoritmo <strong>A *</strong> , e muitas pensam que isso √© algum tipo de m√°gica incompreens√≠vel. <br><br>  O objetivo deste artigo √© explicar a busca pelo caminho em geral e <strong>A *</strong> em particular de uma maneira muito compreens√≠vel e acess√≠vel, pondo fim ao equ√≠voco generalizado de que este t√≥pico √© complexo.  Com a explica√ß√£o certa, tudo √© bem simples. <br><br>  Observe que, no artigo, consideraremos a busca de um caminho <em>para jogos</em> ;  ao contr√°rio de mais artigos acad√™micos, omitiremos algoritmos de pesquisa como Profundidade-Primeiro ou Largura-Primeiro.  Em vez disso, tentaremos passar de zero a <strong>A * o</strong> mais r√°pido poss√≠vel. <br><a name="habracut"></a><br>  Na primeira parte, explicaremos os conceitos mais simples de encontrar um caminho.  Ao entender esses conceitos b√°sicos, voc√™ perceber√° que <strong>A *</strong> √© surpreendentemente √≥bvio. <br><br><h2>  Circuito simples </h2><br>  Embora voc√™ possa aplicar esses conceitos a ambientes 3D complexos arbitr√°rios, vamos come√ßar com um esquema extremamente simples: uma grade quadrada 5 x 5. Por conveni√™ncia, marquei cada c√©lula com uma letra mai√∫scula. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Malha simples.</i> <br><br>  A primeira coisa que faremos √© imaginar esse ambiente como um gr√°fico.  N√£o explicarei em detalhes o que √© um gr√°fico;  Simplificando, este √© um conjunto de c√≠rculos conectados por setas.  Os c√≠rculos s√£o chamados de <em>"n√≥s"</em> e as setas s√£o <em>chamadas de "arestas"</em> . <br><br>  Cada n√≥ representa um <em>"estado"</em> no qual o personagem pode estar.  No nosso caso, o estado do personagem √© sua posi√ß√£o, por isso criamos um n√≥ para cada c√©lula da grade: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>N√≥s representando c√©lulas da grade.</i> <br><br>  Agora adicione as costelas.  Eles indicam os estados que podem ser <em>"alcan√ßados"</em> de cada estado;  no nosso caso, podemos ir de qualquer c√©lula para a pr√≥xima, com exce√ß√£o das bloqueadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Arcos denotam movimentos permitidos entre c√©lulas da grade.</i> <br><br>  Se pudermos ir de <strong>A</strong> a <strong>B</strong> , dizemos que <strong>B</strong> √© um <em>"vizinho"</em> de <strong>um</strong> n√≥. <br><br>  Vale a pena notar que as costelas t√™m uma <em>dire√ß√£o</em> ;  precisamos de arestas de <strong>A</strong> a <strong>B</strong> e de <strong>B</strong> a <strong>A.</strong>  Isso pode parecer sup√©rfluo, mas n√£o quando "condi√ß√µes" mais complexas podem surgir.  Por exemplo, um personagem pode cair do teto para o ch√£o, mas n√£o √© capaz de saltar do ch√£o para o teto.  Voc√™ pode ir do estado "vivo" para o estado "morto", mas n√£o vice-versa.  E assim por diante <br><br><h2>  Exemplo </h2><br>  Suponha que queremos passar de <strong>A</strong> para <strong>T.</strong>  Come√ßamos com <strong>A.</strong>  Voc√™ pode executar exatamente duas a√ß√µes: v√° para <strong>B</strong> ou v√° para <strong>F.</strong> <br><br>  Digamos que nos mudamos para <strong>B.</strong>  Agora podemos fazer duas coisas: retornar a <strong>A</strong> ou ir a <strong>C.</strong>  Lembramos que j√° est√°vamos em <strong>A</strong> e consideramos as op√ß√µes l√°, ent√£o n√£o faz sentido faz√™-lo novamente (caso contr√°rio, podemos passar o dia inteiro movendo <strong>A</strong> ‚Üí <strong>B</strong> ‚Üí <strong>A</strong> ‚Üí <strong>B</strong> ...).  Portanto, iremos para <strong>C.</strong> <br><br>  Sendo em <strong>C</strong> , n√£o temos para onde nos mover.  Voltar a <strong>B √©</strong> in√∫til, ou seja, √© um beco sem sa√≠da.  Escolher a transi√ß√£o para <strong>B</strong> quando est√°vamos em <strong>A</strong> foi uma m√° id√©ia;  talvez voc√™ devesse tentar <strong>F em</strong> vez disso? <br><br>  Continuamos repetindo esse processo at√© terminar em <strong>T.</strong>  Neste momento, simplesmente recriamos o caminho de <strong>A</strong> , retornando em nossos passos.  N√≥s estamos em <strong>T</strong> ;  como chegamos l√°?  De <strong>o</strong> ?  Ou seja, o final do caminho tem a forma <strong>O</strong> ‚Üí <strong>T.</strong>  Como chegamos a <strong>O</strong> ?  E assim por diante <br><br>  Lembre-se de que n√£o estamos realmente nos <em>movendo</em> ;  tudo isso foi apenas um processo de pensamento.  Continuamos em <strong>A</strong> , e n√£o sairemos dela at√© encontrarmos todo o caminho.  Quando digo "mudamos para <strong>B</strong> ", quero dizer "imagine que mudamos para <strong>B</strong> ". <br><br><h2>  Algoritmo geral </h2><br>  <strong>Esta se√ß√£o √© a parte mais importante de todo o artigo</strong> .  Voc√™ absolutamente <em>deve</em> entend√™-lo para poder realizar a busca pelo caminho;  o restante (incluindo <strong>A *</strong> ) s√£o apenas detalhes.  Nesta se√ß√£o, voc√™ entender√° at√© <em>entender o significado</em> . <br><br>  Al√©m disso, esta se√ß√£o √© incrivelmente simples. <br><br>  Vamos tentar formalizar nosso exemplo, transformando-o em um pseudo-c√≥digo. <br><br>  Precisamos rastrear os n√≥s que sabemos alcan√ßar desde o n√≥ inicial.  No in√≠cio, este √© apenas o n√≥ inicial, mas no processo de "explorar" a grade, aprenderemos como chegar a outros n√≥s.  Vamos chamar esta lista de n√≥s de <code>reachable</code> : <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Tamb√©m precisamos rastrear os n√≥s j√° revisados ‚Äã‚Äãpara n√£o consider√°-los novamente.  <code>explored</code> cham√°-los de <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>A seguir, descreverei o n√∫cleo do algoritmo</strong> : em cada etapa da pesquisa, selecionamos um dos n√≥s que sabemos como alcan√ßar e observamos quais novos n√≥s podemos obter dele.  Se determinarmos como alcan√ßar o n√≥ final (alvo), o problema ser√° resolvido!  Caso contr√°rio, continuamos a pesquisa. <br><br>  T√£o simples, o que at√© decepciona?  E isso √© verdade.  Mas este √© o algoritmo inteiro.  Vamos anot√°-lo passo a passo com pseudo-c√≥digo. <br><br>  Continuamos a pesquisar at√© chegarmos ao n√≥ final (nesse caso, encontramos o caminho do n√≥ inicial ao final) ou at√© ficarmos sem n√≥s nos quais voc√™ pode pesquisar (nesse caso, n√£o h√° como os n√≥s inicial e final) . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Escolhemos um dos n√≥s para o qual sabemos como chegar e que ainda n√£o foi investigado: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Se aprendemos como chegar ao n√≥ final, a tarefa estar√° conclu√≠da!  N√≥s s√≥ precisamos construir o caminho seguindo os links <code>previous</code> volta ao n√≥ inicial: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  N√£o faz sentido examinar o n√≥ mais de uma vez; portanto, acompanharemos isso: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Identificamos n√≥s que n√£o podemos alcan√ßar daqui.  Come√ßamos com uma lista de n√≥s adjacentes ao atual e exclu√≠mos os que j√° examinamos: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Tomamos cada um deles: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Se j√° sabemos como alcan√ßar o n√≥, ignore-o.  Caso contr√°rio, adicione-o √† lista <code>reachable</code> , acompanhando como ele entrou: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Encontrar o n√≥ final √© uma maneira de sair do loop.  A segunda √© quando o <code>reachable</code> fica vazio: ficamos sem n√≥s que podem ser explorados e n√£o atingimos o n√≥ final, ou seja, n√£o h√° como o n√≥ inicial para o n√≥ final: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  E ... √© isso.  Este √© o algoritmo inteiro e o c√≥digo de constru√ß√£o do caminho √© alocado em um m√©todo separado: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Aqui est√° a fun√ß√£o que cria o caminho, seguindo os links <code>previous</code> volta ao n√≥ inicial: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Isso √© tudo.  <em>Esse √© o</em> pseudoc√≥digo de <em>cada</em> algoritmo de pesquisa de caminho, incluindo <strong>A *</strong> . <br><br>  Releia esta se√ß√£o at√© entender como tudo funciona e, mais importante, <em>por que</em> tudo funciona.  Seria ideal desenhar um exemplo manualmente no papel, mas voc√™ tamb√©m pode assistir a uma demonstra√ß√£o interativa: <br><br><h2>  Demonstra√ß√£o interativa </h2><br>  Aqui est√° uma demonstra√ß√£o e um exemplo da implementa√ß√£o do algoritmo mostrado acima (voc√™ pode execut√°-lo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina do artigo original</a> ).  <code>choose_node</code> apenas seleciona um n√≥ aleat√≥rio.  Voc√™ pode iniciar o algoritmo passo a passo e examinar a lista de <code>explored</code> <code>reachable</code> e <code>explored</code> , bem como para onde os links <code>previous</code> apontam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Observe que a pesquisa termina assim que um caminho √© detectado;  pode acontecer que alguns n√≥s nem sejam considerados. <br><br><h2>  Conclus√£o </h2><br>  O algoritmo apresentado aqui √© um algoritmo geral para <em>qualquer</em> algoritmo de pesquisa de caminho. <br><br>  Mas o que distingue cada algoritmo de outro, por que <strong>A *</strong> √© <strong>A *</strong> ? <br><br>  Aqui est√° uma dica: se voc√™ executar a pesquisa na demonstra√ß√£o v√°rias vezes, ver√° que o algoritmo nem sempre encontra o mesmo caminho.  Ele encontra <em>um</em> caminho, e esse caminho n√£o √© necessariamente o <em>mais curto</em> .  Porque <br><br><h2>  Parte 2. Estrat√©gias de Pesquisa </h2><br>  Se voc√™ n√£o entender completamente o algoritmo descrito na se√ß√£o anterior, retorne a ele e leia-o novamente, porque √© necess√°rio para entender mais informa√ß√µes.  Quando voc√™ descobrir, <strong>A *</strong> parecer√° completamente natural e l√≥gico para voc√™. <br><br><h2>  Ingrediente secreto </h2><br>  No final da parte anterior, deixei duas perguntas em aberto: se cada algoritmo de pesquisa usa o mesmo c√≥digo, por que <strong>A *</strong> se comporta como <strong>A *</strong> ?  E por que a demo √†s vezes encontra caminhos diferentes? <br><br>  As respostas para as duas perguntas est√£o relacionadas entre si.  Embora o algoritmo esteja bem definido, deixei um aspecto sem solu√ß√£o e, como se v√™, √© a chave para explicar o comportamento dos algoritmos de pesquisa: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  √â essa string de apar√™ncia inocente que distingue todos os algoritmos de pesquisa um do outro.  <code>choose_node</code> depende do m√©todo de implementa√ß√£o de <code>choose_node</code> . <br><br>  Ent√£o, por que a demo encontra caminhos diferentes?  Porque seu m√©todo <code>choose_node</code> seleciona um n√≥ aleatoriamente. <br><br><h2>  O comprimento importa </h2><br>  Antes de mergulhar nas diferen√ßas no comportamento da fun√ß√£o <code>choose_node</code> , precisamos corrigir uma pequena supervis√£o no algoritmo descrito acima. <br><br>  Quando consideramos os n√≥s adjacentes √† corrente, ignoramos aqueles que j√° sabem como: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Isso √© um erro: e se descobr√≠ssemos a <em>melhor</em> maneira de chegar a isso?  Nesse caso, √© necess√°rio alterar o link do n√≥ <code>previous</code> para refletir esse caminho mais curto. <br><br>  Para fazer isso, precisamos saber o comprimento do caminho desde o n√≥ inicial at√© qualquer n√≥ acess√≠vel.  Vamos chamar isso de custo do caminho.  Por enquanto, assumimos que a mudan√ßa de um n√≥ para um dos n√≥s vizinhos tem um custo constante de <code>1</code> . <br><br>  Antes de iniciar a pesquisa, atribu√≠mos o valor do <code>cost</code> de cada n√≥ ao <code>infinity</code> ;  gra√ßas a isso, <em>qualquer</em> caminho ser√° mais curto que isso.  Tamb√©m definiremos o <code>cost</code> n√≥ <code>start_node</code> como <code>0</code> . <br><br>  Ent√£o √© assim que o c√≥digo ficar√°: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Mesmo custo de pesquisa </h2><br>  Vamos agora dar uma olhada no m√©todo <code>choose_node</code> .  Se nos esfor√ßarmos para encontrar o caminho mais curto poss√≠vel, escolher um n√≥ aleatoriamente n√£o √© uma boa ideia. <br><br>  √â melhor escolher um n√≥ que possamos alcan√ßar a partir do n√≥ inicial ao longo do caminho mais curto;  gra√ßas a isso, geralmente preferimos caminhos mais curtos a caminhos mais longos.  Isso n√£o significa que caminhos mais longos n√£o ser√£o considerados, significa que caminhos mais curtos ser√£o considerados primeiro.  Como o algoritmo termina imediatamente ap√≥s encontrar um caminho adequado, isso deve nos permitir encontrar caminhos curtos. <br><br>  Aqui est√° um exemplo poss√≠vel da fun√ß√£o <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitivamente, a busca por esse algoritmo se expande ‚Äúradialmente‚Äù do n√≥ inicial at√© atingir o n√≥ final.  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma demonstra√ß√£o interativa</a> desse comportamento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Conclus√£o </h2><br>  Uma simples mudan√ßa no m√©todo de escolha do n√≥ considerado a seguir nos permitiu obter um algoritmo bastante bom: ele encontra o caminho mais curto do in√≠cio ao n√≥ final. <br><br>  Mas esse algoritmo, at√© certo ponto, permanece "est√∫pido".  Ele continua a procurar em todos os lugares at√© encontrar um n√≥ terminal.  Por exemplo, qual √© o ponto no exemplo mostrado acima para procurar na dire√ß√£o <strong>A</strong> , se √© √≥bvio que estamos nos afastando do n√≥ final? <br><br>  √â poss√≠vel tornar a <code>choose_node</code> mais inteligente?  Podemos <em>direcionar a pesquisa para o n√≥ final</em> , sem nem mesmo saber o caminho correto com anteced√™ncia? <br><br>  Acontece que n√≥s podemos - na pr√≥xima parte, finalmente <code>choose_node</code> , o que nos permite transformar o algoritmo geral de busca de caminho em <strong>A *</strong> . <br><br><h2>  Parte 3. Remova o v√©u de sigilo de A * </h2><br>  O algoritmo obtido na parte anterior √© bastante bom: encontra o caminho mais curto entre o n√≥ inicial e o final.  No entanto, ele gasta sua energia: ele considera as maneiras que uma pessoa obviamente chama de err√¥neas - elas geralmente <em>se afastam</em> da meta.  Como isso pode ser evitado? <br><br><h2>  Algoritmo m√°gico </h2><br>  Imagine que executamos um algoritmo de busca em um computador especial com um chip que pode fazer <em>m√°gica</em> .  Gra√ßas a esse chip incr√≠vel, podemos expressar o <code>choose_node</code> maneira muito simples, que garante o caminho mais curto sem perder tempo explorando caminhos parciais que n√£o levam a lugar nenhum: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Parece tentador, mas os chips m√°gicos ainda precisam de algum tipo de c√≥digo de baixo n√≠vel.  Aqui est√° uma boa aproxima√ß√£o: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Essa √© uma √≥tima maneira de selecionar o pr√≥ximo n√≥: voc√™ seleciona um n√≥ que nos fornece o caminho mais curto do n√≥ inicial ao final, que √© o que precisamos. <br><br>  Tamb√©m minimizamos a quantidade de m√°gica usada: sabemos exatamente qual √© o custo da mudan√ßa do n√≥ inicial para cada n√≥ (este √© <code>node.cost</code> ) e usamos a m√°gica apenas para prever o custo da mudan√ßa do n√≥ para o n√≥ final. <br><br><h2>  N√£o √© m√°gico, mas √© incr√≠vel * </h2><br>  Infelizmente, os chips m√°gicos s√£o novos e precisamos de suporte de equipamentos desatualizados.  A maior parte do c√≥digo nos conv√©m, com exce√ß√£o desta linha: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Ou seja, n√£o podemos usar a magia para descobrir o custo de um caminho inexplorado.  Bem, ent√£o, vamos fazer uma previs√£o.  Seremos otimistas e suporemos que n√£o h√° nada entre os n√≥s atuais e os finais, e podemos simplesmente mover diretamente: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Observe que o <em>caminho mais curto</em> e a <em>dist√¢ncia m√≠nima s√£o</em> diferentes: a dist√¢ncia m√≠nima implica que n√£o h√° absolutamente nenhum obst√°culo entre os n√≥s atuais e finais. <br><br>  Essa estimativa √© bastante simples de obter.  Nos exemplos de nossa grade, essa √© a <em>dist√¢ncia dos blocos de cidade</em> entre dois n√≥s (ou seja, <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Se pud√©ssemos mover na diagonal, ent√£o o valor seria igual a <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> , e assim por diante.  Mais importante, nunca obtemos uma estimativa de valor <em>muito</em> alta. <br><br>  Ent√£o, aqui est√° uma vers√£o n√£o <code>choose_node</code> do <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Uma fun√ß√£o que estima a dist√¢ncia do n√≥ atual ao n√≥ final √© chamada <em>heur√≠stica</em> , e esse algoritmo de busca, senhoras e senhores, √© chamado ... <strong>A *</strong> . <br><br><h2>  Demonstra√ß√£o interativa </h2><br>  Enquanto voc√™ est√° se recuperando do choque causado pela percep√ß√£o de que o misterioso <strong>A *</strong> √© realmente <em>t√£o simples</em> , voc√™ pode olhar para a demonstra√ß√£o (ou execut√°-la no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> ).  Voc√™ notar√° que, diferentemente do exemplo anterior, a pesquisa gasta muito pouco tempo na dire√ß√£o errada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Conclus√£o </h2><br>  Finalmente, chegamos ao algoritmo <strong>A *</strong> , que nada mais √© do que o algoritmo de pesquisa geral descrito na primeira parte do artigo, com algumas melhorias descritas na segunda parte e usando a fun√ß√£o <code>choose_node</code> , que seleciona o n√≥ que, em nossa opini√£o, nos aproxima de n√≥ final.  Isso √© tudo. <br><br>  Aqui est√° um pseudoc√≥digo completo do m√©todo principal para sua refer√™ncia: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  M√©todo <code>build_path</code> : <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  E aqui est√° o m√©todo <code>choose_node</code> , que o transforma em <strong>A *</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Isso √© tudo. <br><br>  Mas por que precisamos da <strong>parte 4</strong> ? <br><br>  Agora que voc√™ entende como o <strong>A *</strong> funciona, quero falar sobre algumas √°reas surpreendentes de sua aplica√ß√£o, que est√£o longe de se limitarem a encontrar caminhos em uma grade de c√©lulas. <br><br><h2>  Parte 4. A * na pr√°tica </h2><br>  As tr√™s primeiras partes do artigo come√ßam com os pr√≥prios fundamentos dos algoritmos de pesquisa de caminho e terminam com uma descri√ß√£o clara do algoritmo <strong>A *</strong> .  Tudo isso √© √≥timo na teoria, mas entender como isso √© aplic√°vel na pr√°tica √© um t√≥pico completamente diferente. <br><br>  Por exemplo, o que acontece se o nosso mundo n√£o √© uma grade? <br><br>  E se um personagem n√£o puder girar instantaneamente 90 graus? <br><br>  Como construir um gr√°fico se o mundo n√£o tem fim? <br><br>  E se n√£o nos importamos com o comprimento do caminho, mas dependemos da energia solar e precisamos estar sob a luz solar o m√°ximo poss√≠vel? <br><br>  Como encontrar o caminho mais curto para qualquer um dos dois n√≥s finais? <br><br><h2>  Fun√ß√£o de custo </h2><br>  Nos primeiros exemplos, procuramos o caminho mais curto entre os n√≥s inicial e final.  No entanto, em vez de armazenar comprimentos de caminho parciais no comprimento vari√°vel, chamamos de <code>cost</code> .  Porque <br><br>  Podemos fazer com que <strong>A *</strong> procure n√£o apenas o <em>caminho mais curto</em> , mas tamb√©m o <em>melhor</em> , e a defini√ß√£o de "melhor" pode ser escolhida com base em nossos objetivos.  Quando precisamos do caminho mais curto, o custo √© o comprimento do caminho, mas se queremos minimizar, por exemplo, o consumo de combust√≠vel, precisamos us√°-lo como custo.  Se queremos maximizar o "tempo gasto sob o sol", ent√£o o custo √© o tempo gasto sem o sol.  E assim por diante <br><br>  No caso geral, isso significa que os custos correspondentes est√£o associados a cada extremidade do gr√°fico.  Nos exemplos mostrados acima, o valor foi definido implicitamente e sempre foi considerado igual a <code>1</code> , porque contamos as etapas ao longo do caminho.  Mas podemos alterar o custo da costela de acordo com o que queremos minimizar. <br><br><h2>  Fun√ß√£o de crit√©rio </h2><br>  Digamos que nosso objeto seja um carro e ele precise chegar ao posto de gasolina.  Qualquer reabastecimento nos conv√©m.  Leva a rota mais curta at√© o posto de gasolina mais pr√≥ximo. <br><br>  A abordagem ing√™nua ser√° calcular o caminho mais curto para cada reabastecimento e selecionar o caminho mais curto.  Isso funcionar√°, mas ser√° um processo bastante caro. <br><br>  E se pud√©ssemos substituir um <code>goal_node</code> por um m√©todo que, em um determinado n√≥, possa dizer se √© finito ou n√£o.  Gra√ßas a isso, podemos procurar v√°rios objetivos ao mesmo tempo.  Tamb√©m precisamos modificar a heur√≠stica para que ela retorne o custo m√≠nimo estimado de todos os n√≥s finais poss√≠veis. <br><br>  Dependendo das especificidades da situa√ß√£o, talvez n√£o consigamos alcan√ßar o objetivo com <em>perfei√ß√£o</em> , ou isso custar√° muito (se enviarmos o personagem por meio de um mapa enorme, a diferen√ßa √© uma polegada importante?), Portanto o m√©todo <code>is_goal_node</code> pode retornar <code>true</code> quando Estamos "perto o suficiente". <br><br><h2>  N√£o √© necess√°ria certeza total. </h2><br>  Representar o mundo como uma grade discreta pode n√£o ser suficiente para muitos jogos.  Tome, por exemplo, um jogo de tiro ou corrida em primeira pessoa.  O mundo √© discreto, mas n√£o pode ser representado como uma grade. <br><br>  Mas h√° um problema mais s√©rio: e se o mundo for infinito?  Nesse caso, mesmo que possamos apresent√°-lo na forma de uma grade, simplesmente n√£o conseguiremos construir um gr√°fico correspondente √† grade, porque deve ser infinito. <br><br>  No entanto, nem tudo est√° perdido.  Obviamente, para o algoritmo de pesquisa de gr√°ficos, definitivamente precisamos de um gr√°fico.  Mas ningu√©m disse que o gr√°fico deveria ser <em>abrangente</em> ! <br><br>  Se voc√™ observar atentamente o algoritmo, notar√° que n√£o estamos fazendo nada com o gr√°fico como um todo;  examinamos o gr√°fico localmente, obtendo n√≥s que podemos alcan√ßar a partir do n√≥ em quest√£o.  Como pode ser visto na demonstra√ß√£o <strong>A *</strong> , alguns n√≥s do gr√°fico n√£o s√£o investigados. <br><br>  Ent√£o, por que n√£o constru√≠mos o gr√°fico no processo de pesquisa? <br><br>  Tornamos a posi√ß√£o atual do personagem o n√≥ inicial.  Ao chamar <code>get_adjacent_nodes</code> ele pode determinar as poss√≠veis maneiras pelas quais o caractere pode se mover de um determinado n√≥ e criar n√≥s vizinhos em tempo real. <br><br><h2>  Al√©m das tr√™s dimens√µes </h2><br>  Mesmo que seu mundo seja <i>realmente</i> uma malha 2D, h√° outros aspectos a serem considerados.  Por exemplo, e se um personagem n√£o puder girar instantaneamente 90 ou 180 graus, como geralmente √© o caso? <br><br>  <em>O estado</em> representado por cada n√≥ de pesquisa n√£o precisa ser apenas uma <em>posi√ß√£o</em> ;  pelo contr√°rio, pode incluir um conjunto de valores arbitrariamente complexo.  Por exemplo, se curvas de 90 graus levarem tanto tempo quanto a transi√ß√£o de uma c√©lula para outra, o estado do personagem poder√° ser definido como <code>[position, heading]</code> .  Cada n√≥ pode representar n√£o apenas a posi√ß√£o do personagem, mas tamb√©m a dire√ß√£o do seu olhar;  e as novas arestas do gr√°fico (expl√≠citas ou indiretas) refletem isso. <br><br>  Se voc√™ voltar para a grade 5x5 original, a posi√ß√£o de pesquisa inicial agora pode ser <code>[A, East]</code> .  Os n√≥s vizinhos agora s√£o <code>[B, East]</code> e <code>[A, South]</code> - se queremos chegar a <strong>F</strong> , primeiro precisamos ajustar a dire√ß√£o para que o caminho assuma a forma <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Atirador em primeira pessoa?  Pelo menos quatro dimens√µes: <code>[X, Y, Z, Heading]</code> .  Talvez at√© <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Observe que quanto mais complexo o estado, mais complexa deve ser a fun√ß√£o heur√≠stica.  <strong>A * em si</strong> √© simples;  a arte geralmente surge de boas heur√≠sticas. <br><br><h2>  Conclus√£o </h2><br>  O objetivo deste artigo √© dissipar de uma vez por todas o mito de que <strong>A *</strong> √© um algoritmo m√≠stico que n√£o pode ser decifrado.  Pelo contr√°rio, mostrei que n√£o h√° nada de misterioso nele e, de fato, pode ser deduzido de maneira simples, come√ßando do zero. <br><br><h3>  Leitura adicional </h3><br>  Amit Patel tem uma excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúIntrodu√ß√£o ao algoritmo A *‚Äù</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> em Habr√©] (e seus outros artigos sobre v√°rios t√≥picos tamb√©m s√£o excelentes!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444828/">https://habr.com/ru/post/pt444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444816/index.html">Carpintaria de bricolage: expectativas e realidade</a></li>
<li><a href="../pt444818/index.html">Citymobil - um guia para startups para aumentar a estabilidade em meio ao crescimento. Parte 1</a></li>
<li><a href="../pt444820/index.html">Mockdown: a maneira mais r√°pida de criar wireframes</a></li>
<li><a href="../pt444822/index.html">JDK 9 / JEP 280: a concatena√ß√£o de cadeias nunca mais ser√° a mesma</a></li>
<li><a href="../pt444824/index.html">O que os rob√¥s Amazon Courier e FedEx parecem primeiro</a></li>
<li><a href="../pt444830/index.html">Nuvem assinatura eletr√¥nica na R√∫ssia e no mundo</a></li>
<li><a href="../pt444832/index.html">"N√£o h√° implanta√ß√µes na sexta-feira" e mais tr√™s regras de desenvolvimento t√°citas</a></li>
<li><a href="../pt444836/index.html">N√£o h√° necessidade de pensar em mem√≥ria, eles disseram ... Oficina CLRium # 5: Garbage Collector</a></li>
<li><a href="../pt444838/index.html">OWASP R√∫ssia Meetup</a></li>
<li><a href="../pt444840/index.html">3. Introdu√ß√£o ao Ponto de Verifica√ß√£o R80.20. Prepara√ß√£o de layout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>