<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘²ğŸ¿ ğŸ†™ ğŸ‘†ğŸ¾ Penggunaan libdispatch yang efektif ğŸ—½ ğŸ”‡ ğŸ™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="( Catatan: penulis bahan aslinya adalah Thomas @tclementdev, pengguna github dan twitter . Narasi orang pertama yang digunakan oleh penulis disimpan d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penggunaan libdispatch yang efektif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471870/">  ( <i>Catatan: penulis bahan aslinya adalah Thomas @tclementdev, pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter</a> . Narasi orang pertama yang digunakan oleh penulis disimpan dalam terjemahan di bawah ini.</i> ) <br><br>  Saya pikir sebagian besar pengembang menggunakan libdispatch secara tidak efisien karena cara itu diperkenalkan ke komunitas, juga karena dokumentasi dan API yang membingungkan.  Saya sampai pada pemikiran ini setelah membaca diskusi tentang "konkurensi" di milis pengembangan Swift (evolusi cepat).  Pesan dari Pierre Habouzit (Pierre Habouzit - terlibat dalam mendukung libdispatch di Apple) secara khusus tercerahkan: <br><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/date.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170904/date.html</a> </li></ul><br>  Dia juga memiliki banyak tweet tentang topik ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder</a> </li></ul><br>  Dibuat oleh saya: <br><br><ul><li>  Program harus memiliki sangat sedikit antrian menggunakan kumpulan global ( <i>utas - kira-kira Per.</i> ).  Jika semua antrian ini aktif secara bersamaan, maka Anda akan menerima jumlah utas yang berjalan secara bersamaan.  Antrian ini harus dianggap sebagai konteks eksekusi dalam program (GUI, penyimpanan, pekerjaan di latar belakang, ...) yang mendapat manfaat dari eksekusi bersamaan. </li><li>  Mulai dengan eksekusi berurutan.  Saat Anda menemukan masalah kinerja, lakukan pengukuran untuk mengetahui penyebabnya.  Dan jika eksekusi paralel membantu, gunakan dengan hati-hati.  Selalu pastikan bahwa kode paralel berfungsi di bawah tekanan dari sistem.  Secara default, gunakan kembali antrian.  Tambahkan baris ketika membawa manfaat terukur.  Sebagian besar aplikasi tidak boleh menggunakan lebih dari tiga hingga empat antrian. </li><li>  Antrian yang memiliki antrian lain ditetapkan sebagai target bekerja dengan baik dan skala. <br>  ( <i>Catatan perev.: Tentang pengaturan antrian sebagai target untuk antrian lain dapat dibaca, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> ) </li><li>  Jangan gunakan dispatch_get_global_queue ().  Ini tidak sesuai dengan kualitas layanan dan prioritas dan dapat menyebabkan pertumbuhan eksplosif dalam jumlah arus.  Alih-alih, jalankan kode Anda di salah satu konteks eksekusi Anda. </li><li>  dispatch_async () adalah pemborosan sumber daya untuk blok kecil yang dapat dieksekusi (&lt;1 ms), karena panggilan ini cenderung memerlukan utas baru karena semangat libdispatch yang berlebihan.  Alih-alih mengalihkan konteks eksekusi untuk melindungi keadaan bersama, gunakan mekanisme kunci untuk mengakses keadaan bersama pada saat yang sama. </li><li>  Beberapa kelas / pustaka dirancang dengan baik karena mereka menggunakan kembali konteks eksekusi yang diberikan kode panggilan kepada mereka.  Ini memungkinkan penggunaan penguncian konvensional untuk memastikan keamanan benang.  os_unfair_lock biasanya merupakan mekanisme penguncian tercepat dalam sistem: ia bekerja lebih baik dengan prioritas dan menyebabkan lebih sedikit saklar konteks. </li><li>  Dalam kasus eksekusi paralel, tugas-tugas Anda tidak harus berjuang di antara mereka sendiri, jika tidak produktivitas turun tajam.  Pertempuran terjadi dalam berbagai bentuk.  Kasus yang jelas: perjuangan untuk merebut kunci.  Namun pada kenyataannya, pertarungan semacam itu tidak lebih dari menggunakan sumber daya bersama, yang menjadi penghambat: IPC (komunikasi antarproses) / daemon OS, malloc (pemblokiran), memori bersama, I / O. </li><li>  Anda tidak perlu semua kode untuk mengeksekusi secara tidak sinkron untuk menghindari peningkatan jumlah thread yang eksplosif.  Jauh lebih baik untuk menggunakan jumlah antrian yang lebih rendah dan menolak menggunakan dispatch_get_global_queue (). <br>  ( <i>Catatan perev. 1: tampaknya, ini adalah kasus ketika peningkatan eksplosif dalam jumlah utas terjadi ketika menyinkronkan sejumlah besar tugas paralel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">'' Jika saya memiliki banyak blok dan semuanya ingin menunggu, kita bisa mendapatkan apa yang kita sebut utas) ledakan. "</a></i> ) <br>  ( <i>Catatan hal. 2: dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> dapat dipahami bahwa Pierre Habuzit berarti antrian yang lebih rendah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"yang diketahui oleh kernel ketika mereka memiliki tugas</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> Di sini kita berbicara tentang kernel OS.</i> ) </li><li>  Kita tidak boleh lupa tentang kerumitan dan bug yang muncul dalam arsitektur yang diisi dengan eksekusi asinkron dan panggilan balik.  Kode yang dapat dieksekusi secara berurutan masih jauh lebih mudah untuk dibaca, ditulis, dan dipelihara. </li><li>  Antrian kompetitif kurang dioptimalkan daripada yang berurutan.  Gunakan mereka jika Anda mengukur perolehan kinerja, jika tidak itu adalah optimasi prematur. </li><li>  Jika Anda perlu mengirim tugas dalam satu antrian baik secara sinkron maupun sinkron, maka alih-alih dispatch_sync () gunakan dispatch_async_and_wait ().  dispatch_async_and_wait () tidak menjamin eksekusi pada utas dari mana panggilan berasal, yang mengurangi pengalihan konteks ketika antrian target aktif. <br>  ( <i>Catatan terjemahan. 1: sebenarnya dispatch_sync () juga tidak menjamin, dokumentasi tentangnya hanya menyatakan "mengeksekusi blok pada utas saat ini, bila memungkinkan. Dengan satu pengecualian: blok yang dikirim ke antrian utama selalu dieksekusi pada utas utama. "</i> ) <br>  ( <i>Catatan, terjemahan 2: tentang dispatch_async_and_wait () dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dan <a href="">dalam kode sumber</a></i> ) </li><li>  Menggunakan 3-4 core dengan benar tidak sesederhana itu.  Sebagian besar dari mereka yang mencoba, pada kenyataannya, tidak dapat mengatasi penskalaan dan pemborosan energi demi peningkatan kecil dalam produktivitas.  Bagaimana prosesor bekerja dengan panas berlebih tidak akan membantu.  Misalnya, Intel akan menonaktifkan Turbo-Boost jika cukup banyak core yang digunakan. </li><li>  Ukur kinerja produk Anda di dunia nyata untuk memastikan Anda membuatnya lebih cepat, bukan lebih lambat.  Hati-hati dengan tes kinerja mikro - mereka menyembunyikan pengaruh cache dan menjaga agar thread pool tetap panas.  Untuk memeriksa apa yang Anda lakukan, Anda harus selalu memiliki tes makro. </li><li>  libdispatch efektif, tetapi tidak ada keajaiban.  Sumber dayanya tidak terbatas.  Anda tidak dapat mengabaikan realitas OS dan perangkat keras tempat kode dijalankan.  Juga, tidak setiap kode diparalelkan dengan baik. </li></ul><br>  Lihatlah semua panggilan dispatch_async () dalam kode Anda dan tanyakan pada diri Anda: apakah tugas yang Anda ajukan dengan panggilan ini benar-benar layak untuk saklar konteks.  Dalam kebanyakan kasus, mengunci mungkin merupakan pilihan terbaik. <br><br>  Segera setelah Anda mulai menggunakan dan menggunakan kembali antrian (konteks eksekusi) dari set yang dirancang sebelumnya, akan ada bahaya kebuntuan.  Bahaya muncul saat mengirim tugas ke antrian ini menggunakan dispatch_sync ().  Ini biasanya terjadi ketika antrian digunakan untuk keamanan thread.  Jadi sekali lagi: solusinya adalah menggunakan mekanisme penguncian dan menggunakan dispatch_async () hanya ketika Anda perlu beralih ke konteks eksekusi lain. <br><br>  Saya pribadi melihat peningkatan kinerja yang sangat besar dengan mengikuti panduan ini. <br>  (dalam program yang sangat dimuat).  Ini adalah pendekatan baru, tetapi sepadan. <br><br><h4>  Lebih banyak tautan </h4><br>  Program harus memiliki sangat sedikit antrian menggunakan kumpulan global <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039368.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039405.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039410.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039420.html</a> </li></ul><br>  ( <i>Catatan perev.: Membaca tautan terakhir, tidak dapat menolak dan mentransfer satu keping dari tengah korespondensi Pierre Habuzit dengan Chris Luttner. Di bawah ini adalah salah satu jawaban dari Pierre Habuzit di 039420.html</i> ) <br><blockquote>  &lt;...&gt; <br>  Saya mengerti bahwa sulit bagi saya untuk menyampaikan sudut pandang saya, karena saya bukan seorang pria dalam arsitektur bahasa, saya seorang pria dalam arsitektur sistem.  Dan saya jelas tidak mengerti Aktor cukup untuk memutuskan bagaimana mengintegrasikan mereka ke dalam OS.  Tetapi bagi saya, kembali ke contoh database, Actor-Database-Data, atau Actor-Network-Interface dari korespondensi sebelumnya, berbeda dari, katakanlah, query SQL ini atau permintaan jaringan ini.  Yang pertama adalah entitas yang harus diketahui oleh OS di dalam kernel.  Sementara query SQL atau permintaan jaringan hanya aktor yang antri untuk eksekusi di tempat pertama.  Dengan kata lain, aktor tingkat atas ini berbeda karena mereka adalah tingkat atas, langsung di atas kernel / runtime tingkat rendah.  Dan inilah intisari yang harus dipikirkan oleh inti.  Ini membuat mereka hebat. <br><br>  Ada 2 jenis antrian dan tingkat API yang sesuai di perpustakaan pengiriman: <br><ul><li>  antrian global yang bukan antrian seperti yang lain.  Dan pada kenyataannya, mereka hanyalah abstraksi dari kumpulan thread. </li><li>  semua antrian lain yang dapat Anda tetapkan target satu untuk yang lain seperti yang Anda inginkan. </li></ul><br>  Hari ini menjadi jelas bahwa ini adalah kesalahan dan harus ada 3 jenis antrian: <br><br><ul><li>  antrian global, yang bukan antrian nyata, tetapi mewakili kumpulan sistem mana yang memerlukan konteks eksekusi Anda (terutama prioritas).  Dan kita harus melarang pengiriman tugas langsung ke antrian ini. </li><li>  antrian lebih rendah (yang telah dilacak GCD dalam beberapa tahun terakhir dan memanggil "basis" dalam kode sumber ( <i>tampaknya kode sumber GCD itu sendiri dimaksudkan - kira-kira diterjemahkan.</i> ). Antrian yang lebih rendah diketahui oleh kernel ketika mereka memiliki tugas. </li><li>  antrian "internal" lainnya yang tidak diketahui oleh kernel sama sekali. </li></ul><br>  Di grup pengembangan pengiriman, kami menyesal setiap hari yang berlalu bahwa perbedaan antara grup antrian kedua dan ketiga awalnya tidak dijelaskan dalam API. <br><br>  Saya suka menyebut grup kedua sebagai "konteks eksekusi", tetapi saya bisa mengerti mengapa Anda ingin menyebutnya Aktor.  Ini mungkin lebih konsisten (dan GCD melakukan hal yang sama, menyajikan ini dan itu sebagai antrian).  "Aktor" tingkat atas seperti itu harus jumlahnya sedikit karena jika mereka semua menjadi aktif pada saat yang sama, maka mereka akan membutuhkan jumlah utas yang sama dalam proses.  Dan ini bukan sumber daya yang bisa ditingkatkan.  Itulah mengapa penting untuk membedakannya.  Dan, seperti yang kita diskusikan, mereka juga biasa digunakan untuk melindungi keadaan bersama, sumber daya, atau sejenisnya.  Ini tidak mungkin dilakukan dengan menggunakan aktor internal. <br>  &lt;...&gt; <br></blockquote><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039429.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170904/039461.html</a> </li></ul><br>  Mulai dengan eksekusi berurutan. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081658384577835009</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081659784841969665</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/904839926180569089</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/904840156330344449</a> </li></ul><br>  Jangan gunakan antrian global <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/773903697474486273</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039368.html</a> </li></ul><br>  Waspadalah terhadap garis kompetitif <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/960915209584914432</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/960916427833163776</a> </li></ul><br>  Jangan gunakan panggilan async untuk melindungi keadaan bersama <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/820473404440489984</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/820473580819337219</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/820740434645221376</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/904467942208823296</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/904468363149099008</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/820473711606124544</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/820473923527589888</a> </li></ul><br>  Jangan gunakan panggilan async untuk tugas-tugas kecil <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081657739451891713</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081642189048840192</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081642631732457472</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081648778975707136</a> </li></ul><br>  Beberapa kelas / perpustakaan seharusnya hanya sinkron <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170904/039461.html</a> </li></ul><br>  Perjuangan tugas paralel di antara mereka sendiri adalah pembunuh produktivitas <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081657739451891713</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081658172610293760</a> </li></ul><br>  Untuk menghindari kebuntuan, gunakan mekanisme penguncian saat Anda perlu melindungi keadaan bersama <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/744269824079998977</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/744269947723866112</a> </li></ul><br>  Jangan gunakan semaphores untuk menunggu tugas asinkron <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1175062243806863360</a> </li></ul><br>  NSOperation API memiliki beberapa jebakan serius yang dapat menyebabkan penurunan kinerja. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1082097847653154817</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1082111968700289026</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039415.html</a> </li></ul><br>  Hindari Tes Kinerja Mikro <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081660679054999552</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/Catfish_Man/status/1081673457182490624</a> </li></ul><br>  Sumber daya tidak terbatas <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1081661310771712001</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039410.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170828/039429.html</a> </li></ul><br>  Tentang dispatch_async_and_wait () <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1135938715098857477</a> </li></ul><br>  Menggunakan 3-4 core tidak mudah <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/pedantcoder/status/1140041360868704256</a> </li></ul><br>  Banyak peningkatan kinerja di iOS 12 telah dicapai dengan daemon single-threaded <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter.com/Catfish_Man/status/1081673457182490624</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471870/">https://habr.com/ru/post/id471870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471860/index.html">Pengurai pasak</a></li>
<li><a href="../id471862/index.html">Implementasi parser PEG</a></li>
<li><a href="../id471864/index.html">Generasi parser PEG</a></li>
<li><a href="../id471866/index.html">Visualisasi parser PEG</a></li>
<li><a href="../id471868/index.html">Genetika cinta: konflik antar gender sebagai dasar kerja sama dalam pasangan burung monogami</a></li>
<li><a href="../id471872/index.html">Antarmuka dalam C # 8: Asumsi Berbahaya dalam Implementasi Default</a></li>
<li><a href="../id471874/index.html">Bagaimana Kami Melewati Pedoman Peninjauan dan Meluncurkan Server di Telepon</a></li>
<li><a href="../id471876/index.html">PDU dan All-All-All: Distribusi Daya Rack</a></li>
<li><a href="../id471878/index.html">Bagaimana cara menulis kontrak pintar untuk WebAssembly di jaringan Ontology? Bagian 1: Karat</a></li>
<li><a href="../id471880/index.html">Ide untuk Geek Halloween, atau waktu untuk memilih GeekMask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>