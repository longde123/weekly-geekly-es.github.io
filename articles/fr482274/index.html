<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåõ üåõ üßùüèº 5 raisons pour lesquelles vous devriez cesser d'utiliser System.Drawing dans ASP.NET üë©üèæ‚Äçü§ù‚Äçüë©üèº üôè üë®üèæ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article ¬´5 raisons pour lesquelles vous devez cesser d'utiliser System.Drawing depuis ASP.NET¬ª . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 raisons pour lesquelles vous devriez cesser d'utiliser System.Drawing dans ASP.NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">¬´5 raisons pour lesquelles vous devez cesser d'utiliser System.Drawing depuis ASP.NET¬ª</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="image"><br><br>  Eh bien, ils l'ont fait.  L'√©quipe corefx a finalement accept√© de <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">nombreuses demandes</a> et inclus System.Drawing dans .NET Core. <a name="habracut"></a>  (article original dat√© de juillet 2017) <br><br>  Le <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">prochain</a> package <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">System.Drawing.Common</a> contiendra la plupart des fonctionnalit√©s System.Drawing du .NET Framework complet et est destin√© √† √™tre utilis√© comme option de compatibilit√© pour ceux qui souhaitent migrer vers .NET Core mais ne peuvent pas le faire en raison de d√©pendances.  De ce point de vue, Microsoft fait ce qu'il faut.  La friction doit √™tre r√©duite car l'adoption de .Net Core est un objectif plus valable. <br><br>  D'un autre c√¥t√©, System.Drawing est l'un des domaines les plus pauvres et les plus d√©favoris√©s du .Net Framework et beaucoup d'entre nous esp√©raient que la mise en ≈ìuvre de .NET Core signifierait la mort lente de System.Drawing.  Et avec cette mort devrait √™tre l'occasion de faire quelque chose de mieux. <br><br>  Par exemple, l'√©quipe Mono a cr√©√© un wrapper compatible .NET pour la biblioth√®que graphique multiplateforme <a href="https://skia.org/" rel="nofollow">Skia de</a> Google, appel√©e <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp</a> .  Pour simplifier l'installation, Nuget a parcouru un long chemin dans la prise en charge des biblioth√®ques natives pour chaque plate-forme.  Skia est assez complet et ses performances font System.Drawing. <br><br>  L'√©quipe <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp</a> a √©galement fait un excellent travail en r√©p√©tant une grande partie de la fonctionnalit√© System.Drawing, mais avec la meilleure API et une impl√©mentation 100% C #.  Ils ne sont toujours pas pr√™ts pour une exploitation productive, mais il semble qu'ils soient d√©j√† assez proches de cela.  Un petit avertissement √† propos de cette biblioth√®que, car nous parlons d'une utilisation dans les applications serveur: maintenant, dans la configuration par d√©faut, Parallel.For est utilis√© √† l'int√©rieur pour acc√©l√©rer certaines op√©rations, ce qui signifie que plus de workflows du pool ASP.NET seront utilis√©s, √©ventuellement <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">En</a> cons√©quence, la <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">r√©duction du d√©bit global de l'application</a> .  J'esp√®re que ce comportement sera revu avant la sortie, mais m√™me maintenant, il suffit de changer une ligne de la configuration pour la rendre plus adapt√©e √† une utilisation sur le serveur. <br><br>  Dans tous les cas, si vous dessinez, tracez ou restituez du texte en images dans une application sur le serveur, vous devriez s√©rieusement envisager de modifier System.Drawing en quelque chose, que vous passiez ou non √† .NET Core. <br><br>  Pour ma part, j'ai assembl√© un pipeline de traitement d'image hautes performances pour .NET et .NET Core, qui fournit une qualit√© d'image que System.Drawing ne peut pas fournir, et le fait dans une architecture hautement √©volutive con√ßue sp√©cifiquement pour une utilisation sur le serveur.  Jusqu'√† pr√©sent, ce n'est que pour Windows, cependant, la multiplateforme est dans les plans.  Si vous utilisez System.Drawing (ou autre chose) pour redimensionner les images sur le serveur, il est pr√©f√©rable de consid√©rer <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> comme un remplacement. <br><br>  Mais une r√©surrection de System.Drawing, qui facilite la transition pour certains d√©veloppeurs, est susceptible de tuer l'essentiel de l'√©lan re√ßu par ces projets, car les d√©veloppeurs ont √©t√© forc√©s de chercher des alternatives.  Malheureusement, dans l'√©cosyst√®me .NET, les biblioth√®ques et packages Microsoft gagneront toujours, quelle que soit la qualit√© des alternatives. <br><br>  Ce message est une tentative de corriger certaines erreurs de calcul de System.Drawing dans l'espoir que les d√©veloppeurs exploreront des alternatives m√™me si System.Drawing reste une option. <br><br>  Je vais commencer par la <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">clause de non</a> - <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">responsabilit√©</a> souvent cit√©e <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">dans la</a> documentation System.Drawing.  Ce rejet a √©t√© soulev√© plusieurs fois dans une <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">discussion sur Github lors de la discussion sur System.Drawing.Common</a> . <br><blockquote>  ¬´Les classes avec l'espace de noms System.Drawing ne sont pas prises en charge pour une utilisation dans les services Windows ou ASP.NET.  Tenter d'utiliser ces classes avec ces types d'applications peut entra√Æner des probl√®mes inattendus, tels qu'une baisse des performances du serveur et des erreurs d'ex√©cution. " </blockquote><br>  Comme beaucoup d'entre vous, j'ai lu cet avertissement il y a tr√®s longtemps, puis je l'ai ignor√© et j'ai toujours utilis√© System.Drawing dans mon application ASP.NET.  Pourquoi?  Parce que j'aime le danger.  Soit cela, soit aucune autre option viable n'a √©t√© trouv√©e.  Et tu sais quoi?  Il ne s'est rien pass√© de mal.  Je n'aurais probablement pas d√ª dire cela, mais je parie que beaucoup d'entre vous ont v√©cu la m√™me chose.  Alors pourquoi ne pas continuer √† utiliser System.Drawing ou des biblioth√®ques bas√©es sur lui? <br><br><h3>  Raison n ¬∞ 1: Descripteurs GDI </h3><br>  Si vous avez d√©j√† rencontr√© des probl√®mes lors de l'utilisation de System.Drawing sur un serveur, c'est tr√®s probablement le cas.  S'il n'est pas test√©, c'est l'une des causes les plus probables. <br><br>  System.Drawing est pour la plupart une enveloppe mince autour de l'API Windows GDI +.  De nombreux objets System.Drawing sont pris en charge par les <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">descripteurs GDI</a> , et ils ont une limite quantitative sur le processeur et la session utilisateur.  Si ce seuil est atteint, vous obtiendrez une exception ¬´M√©moire insuffisante¬ª et / ou une erreur ¬´g√©n√©rique¬ª GDI +. <br><br>  Le probl√®me est que dans .NET, la r√©cup√©ration de place et l'arr√™t du processus peuvent retarder la publication de ces descripteurs au moment o√π vous atteignez la limite, m√™me sous une charge l√©g√®re.  Si vous oubliez (ou ne saviez pas ce dont vous avez besoin) d'appeler Dispose () sur un objet qui contient de tels descripteurs, vous risquez fort de rencontrer de telles erreurs dans votre environnement.  Et comme la plupart des bogues li√©s aux limitations ou aux fuites de ressources, cette situation sera probablement test√©e avec succ√®s et vous piquera en fonctionnement productif.  Naturellement, cela se produit lorsque votre application est sous la plus grande charge, de sorte que le nombre maximum d'utilisateurs d√©couvre votre honte. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">Les restrictions sur le processeur et sur la session utilisateur</a> d√©pendent de la version du syst√®me d'exploitation, et la restriction sur le processeur est personnalisable.  Mais la version n'a pas d'importance, car  Les descripteurs GDI sont repr√©sent√©s en interne par le type de donn√©es USHORT, il y a donc une limite stricte de 65 536 descripteurs par session utilisateur, et m√™me une application bien √©crite risque d'atteindre cette limite sous une charge suffisante.  Lorsque vous pensez qu'un serveur plus puissant vous permettra de servir de plus en plus d'utilisateurs en parall√®le sur une seule instance, ce risque devient plus r√©el.  Et vraiment, qui veut cr√©er un logiciel avec une limite bien connue d'√©volutivit√©? <br><br><h3>  Raison n ¬∞ 2: acc√®s simultan√© </h3><br>  GDI + a toujours eu des probl√®mes de simultan√©it√©, bien que beaucoup d'entre eux √©taient li√©s √† <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">des modifications architecturales dans Windows7 / Windows Server 2008 R2</a> , vous en voyez toujours certains dans les nouvelles versions.  Le plus notable est le <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">verrouillage de processus</a> organis√© par GDI + lors de l'op√©ration DrawImage ().  Si vous redimensionnez des images sur le serveur √† l'aide de System.Drawing (ou des biblioth√®ques qui l'enveloppent), la m√©thode DrawImage () est probablement la base de ce code. <br><br>  De plus, lorsque vous effectuez plusieurs appels √† DrawImage () en m√™me temps, <b>tous</b> seront bloqu√©s jusqu'√† <b>ce</b> qu'ils soient tous ex√©cut√©s.  M√™me si le temps de r√©ponse n'est pas un probl√®me pour vous (pourquoi pas? D√©testez-vous vos utilisateurs?) Gardez √† l'esprit que toutes les ressources m√©moire associ√©es √† ces demandes et tous les descripteurs GDI d√©tenus par les objets associ√©s √† ces demandes sont li√©s √† l'ex√©cution.  En fait, cela ne prend pas trop de charge sur le serveur pour commencer √† causer des probl√®mes. <br><br>  Bien s√ªr, il existe des solutions de contournement pour ce probl√®me particulier.  Par exemple, certains d√©veloppeurs cr√©ent un processus externe pour chaque op√©ration DrawImage ().  Mais en fait, une telle solution de contournement ne fait qu'ajouter une fragilit√© suppl√©mentaire, ce que vous n'auriez vraiment pas d√ª faire. <br><br><h3>  Raison n ¬∞ 3: la m√©moire </h3><br>  Consid√©rez un gestionnaire ASP.NET qui g√©n√®re un graphique.  Il devrait faire quelque chose comme √ßa: <br><br><ol><li>  Cr√©er un bitmap comme toile </li><li>  Dessinez plusieurs formes sur une image bitmap √† l'aide de stylos et / ou de pinceaux </li><li>  Dessinez du texte en utilisant une ou plusieurs polices </li><li>  Enregistrer le bitmap au format PNG dans MemoryStream </li></ol><br>  Disons que le graphique mesure 600 par 400 points.  Il s'agit d'un total de 240 000 points, multipli√© par 4 octets pour un point pour le format RGBA par d√©faut, totalisant 960 000 octets pour un bitmap, plus un peu pour les objets de dessin et un tampon de sauvegarde.  Soit 1 Mo pour toute la demande.  Tr√®s probablement, vous n'obtiendrez pas de probl√®mes de m√©moire pour un tel sc√©nario, et si vous rencontrez quelque chose, vous aurez tr√®s probablement une limite sur le nombre de descripteurs, que j'ai mentionn√© plus t√¥t, car les images, les pinceaux, les stylos et les polices ont leurs propres descripteurs. <br><br>  Le vrai probl√®me survient lorsque System.Drawing est utilis√© pour les t√¢ches de cr√©ation d'image.  System.Drawing est principalement une biblioth√®que graphique, et les biblioth√®ques graphiques sont g√©n√©ralement toutes construites autour de l'id√©e que tout est un bitmap en m√©moire.  C'est g√©nial pendant que vous pensez aux petites choses.  Mais les images peuvent √™tre tr√®s grandes, et elles grossissent chaque jour, car  les appareils photo avec beaucoup de m√©gapixels sont de moins en moins chers. <br><br>  Si vous adoptez l'approche na√Øve de System.Drawing pour la cr√©ation d'images, vous obtenez quelque chose comme ceci pour le gestionnaire de redimensionnement: <br><br><ol><li>  Cr√©ez un bitmap en tant que canevas pour l'image de destination. </li><li>  Chargez l'image d'origine dans un autre bitmap. </li><li>  Appelez DrawImage () avec le param√®tre "image-source" pour l'image de destination, en utilisant le redimensionnement. </li><li>  Enregistrez le bitmap cible au format JPEG dans le flux de m√©moire. </li></ol><br>  Supposons que l'image cible soit de 600 x 400, comme dans l'exemple pr√©c√©dent, puis encore une fois, nous avons 1 Mo pour l' <i>image cible</i> et le flux de m√©moire.  Mais supposons que quelqu'un ait t√©l√©charg√© une image de 24 m√©gapixels √† partir de ses nouveaux reflex num√©riques sophistiqu√©s, alors nous avons besoin de 6000x4000 pixels avec 3 octets pour chacun (72 Mo) pour le bitmap source d√©cod√© au format RVB.  Et nous utiliserons le r√©√©chantillonnage HighQualityBicubic de System.Drawing, car il ne semble que bon.  Ensuite, nous devons prendre en compte les autres points 6000x4000 avec 4 octets chacun, pour la <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">conversion PRGBA qui se produit √† l'int√©rieur de la m√©thode appel√©e</a> , en ajoutant 96 Mo suppl√©mentaires de m√©moire utilis√©e.  Au total, 169 Mo (!) Sont obtenus pour une demande de conversion d'une seule image. <br><br>  Imaginez maintenant que plusieurs utilisateurs fassent de telles choses.  N'oubliez pas que les demandes sont bloqu√©es jusqu'√† ce qu'elles soient toutes enti√®rement ex√©cut√©es.  Combien de temps faut-il pour manquer de m√©moire?  Et m√™me si vous ne craignez pas d'√©puiser compl√®tement tout ce qui est disponible, n'oubliez pas qu'il existe de nombreuses fa√ßons de mieux utiliser la m√©moire de votre serveur que de conserver un tas de pixels.  Tenez compte de l'effet de la pression de la m√©moire sur d'autres parties de l'application / du syst√®me: <br><br><ol><li>  Le cache ASP.NET peut commencer √† vider les √©l√©ments co√ªteux √† recr√©er </li><li>  Le ramasse-miettes d√©marrera plus souvent, ralentissant l'application </li><li>  Le cache du noyau IIS ou le cache du syst√®me de fichiers Windows peut supprimer des √©l√©ments utiles </li><li>  Le pool d'applications peut d√©passer la limite de m√©moire et peut √™tre red√©marr√© </li><li>  Windows peut commencer √† √©changer de la m√©moire sur le disque, ce qui ralentit l'ensemble du syst√®me </li></ol><br>  Tu ne veux vraiment rien de tout √ßa? <br><br>  Les biblioth√®ques con√ßues sp√©cifiquement pour les t√¢ches de traitement d'image abordent ce probl√®me d'une mani√®re compl√®tement diff√©rente.  Ils n'ont pas besoin de charger l'int√©gralit√© de l'image source ou cible en m√©moire.  Si vous n'allez pas dessiner dessus, vous n'avez pas besoin d'un canevas / bitmap.  Cela se fait plus comme ceci: <br><br><ol><li>  Cr√©er un flux pour l'encodeur JPEG de l'image cible </li><li>  Chargez une ligne de l'image d'origine et compressez-la horizontalement </li><li>  R√©p√©tez autant de fois que n√©cessaire pour former une ligne pour le fichier cible </li><li>  Compressez les lignes r√©sultantes verticalement </li><li>  R√©p√©tez √† partir de l'√©tape 2 jusqu'√† ce que toutes les lignes du fichier source soient trait√©es. </li></ol><br>  En utilisant cette m√©thode, la m√™me image peut √™tre trait√©e en utilisant 1 Mo de m√©moire au total, et m√™me des images beaucoup plus grandes n√©cessiteront une l√©g√®re augmentation des frais g√©n√©raux. <br><br>  Je ne connais qu'une seule biblioth√®que .NET optimis√©e par ce principe, et je vais vous donner un indice: ce n'est pas System.Drawing. <br><br><h3>  Raison n ¬∞ 4: CPU </h3><br>  Un autre effet secondaire de System.Drawing √©tant plus orient√© graphiquement qu'orient√© image est que DrawImage () est assez inefficace en termes d'utilisation du CPU.  J'ai couvert cela en d√©tail dans un article <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">pr√©c√©dent</a> , mais cette discussion peut √™tre r√©sum√©e par les faits suivants: <br><br><ul><li>  Dans System.Drawing, la conversion d'√©chelle HighQualityBicubic ne fonctionne qu'avec le format PRGBA.  Dans presque tous les sc√©narios, cela signifie une copie suppl√©mentaire de l'image.  Non seulement cela utilise (consid√©rablement) plus de m√©moire suppl√©mentaire, mais il br√ªle √©galement les cycles du processeur pour convertir et traiter le canal alpha suppl√©mentaire. </li><li>  M√™me apr√®s que l'image est dans son format natif, la conversion d'√©chelle HighQualityBicubic effectue environ 4 fois plus de calculs que n√©cessaire pour obtenir les r√©sultats de conversion corrects. </li></ul><br>  Ces faits ajoutent une quantit√© importante de cycles CPU gaspill√©s.  Dans un environnement nuageux avec paiement √† la minute, cela contribue directement au co√ªt de l'h√©bergement.  Et bien s√ªr, votre temps de r√©ponse en souffrira. <br><br>  Et pensez au fait que de l'√©lectricit√© suppl√©mentaire sera d√©pens√©e et de la chaleur produite.  Votre utilisation de System.Drawing pour les t√¢ches de traitement d'image affecte directement le r√©chauffement climatique.  Tu es un monstre. <br><br><h3>  Raison n ¬∞ 5: le traitement d'image est d'une complexit√© trompeuse </h3><br>  Mis √† part les performances, System.Drawing emp√™che √† plusieurs √©gards le traitement correct de l'image.  Utiliser System.Drawing signifie vivre avec une sortie incorrecte ou tout apprendre sur le profil ICC, la quantification des couleurs, l'orientation exif, la correction et bien d'autres choses sp√©cifiques.  Il s'agit d'un terrier de lapin que la plupart des d√©veloppeurs n'ont ni le temps ni l'envie d'explorer. <br><br>  Les biblioth√®ques telles que ImageResizer et ImageProcessor ont gagn√© beaucoup de fans, en prenant soin de certains de ces d√©tails, mais attention, elles ont System.Drawing √† l'int√©rieur, et elles accompagnent tous les bagages que j'ai d√©crits en d√©tail dans cet article. <br><br><h3>  Raison du bonus: vous pouvez faire mieux </h3><br>  Si vous, comme moi, avez d√ª porter des lunettes √† un moment de votre vie, vous vous souvenez probablement comment c'√©tait la premi√®re fois que vous les mettiez.  Je pensais que je voyais normalement, et si je plisse les yeux correctement, alors tout sera assez clair.  Mais ensuite j'ai mis ces lunettes, et le monde est devenu beaucoup plus d√©taill√© que je n'aurais pu l'imaginer. <br><br>  System.Drawing est √† peu pr√®s la m√™me chose.  Cela fait la bonne chose si vous <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">remplissez correctement les param√®tres</a> , mais vous serez surpris de voir √† quel point vos images peuvent √™tre meilleures si vous utilisez les meilleurs utilitaires. <br><br>  Je vais juste laisser cela ici √† titre d'exemple.  C'est le meilleur syst√®me que System.Drawing puisse faire par rapport aux param√®tres MagicScaler par d√©faut.  Peut-√™tre que votre application b√©n√©ficiera de l'obtention de points ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="image"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="image"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Photo de Jakob Owens</a> <br><br>  Jetez un coup d'≈ìil, explorez des alternatives et s'il vous pla√Æt, au nom de l'amour pour les chatons, arr√™tez d'utiliser System.Drawing dans ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482274/">https://habr.com/ru/post/fr482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482260/index.html">TelegramBot. La fonctionnalit√© de base. Autocollants et √©motic√¥nes. (Partie 3)</a></li>
<li><a href="../fr482262/index.html">Comment se connecter √† Talend Open Studio</a></li>
<li><a href="../fr482264/index.html">Br√©sil, magie noire, Mortal Kombat, Mars et 15 000 personnes. R√©sultats de l'ann√©e Ontiko</a></li>
<li><a href="../fr482268/index.html">M√©gastructures du futur: la sph√®re Dyson, le moteur stellaire et la ¬´bombe du trou noir¬ª</a></li>
<li><a href="../fr482272/index.html">Choisir un entrep√¥t de donn√©es pour Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../fr482276/index.html">GOST R 57580. Des tendances √† l'automatisation efficace</a></li>
<li><a href="../fr482280/index.html">Comment se fait le cosplay. Costume de costume avanc√© d'Isaac Clarke de Dead Space 2</a></li>
<li><a href="../fr482282/index.html">La fin de l'√®re ARMv7 ou un peu sur le portage de jeux</a></li>
<li><a href="../fr482284/index.html">"50 nuances de brun" ou "Comment en sommes-nous arriv√©s l√†"</a></li>
<li><a href="../fr482286/index.html">Revue collective inattendue des cartouches Audio-Technica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>