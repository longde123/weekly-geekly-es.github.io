<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌛 🌛 🧝🏼 5 raisons pour lesquelles vous devriez cesser d'utiliser System.Drawing dans ASP.NET 👩🏾‍🤝‍👩🏼 🙏 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article «5 raisons pour lesquelles vous devez cesser d'utiliser System.Drawing depuis ASP.NET» . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 raisons pour lesquelles vous devriez cesser d'utiliser System.Drawing dans ASP.NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482274/"> Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://photosauce.net/blog/post/5-reasons-you-should-stop-using-systemdrawing-from-aspnet" rel="nofollow">«5 raisons pour lesquelles vous devez cesser d'utiliser System.Drawing depuis ASP.NET»</a> . <br><br><img src="https://habrastorage.org/webt/cz/ak/-m/czak-mp2zhhou0aufqy5s4p8z4c.png" alt="image"><br><br>  Eh bien, ils l'ont fait.  L'équipe corefx a finalement accepté de <a href="https://github.com/dotnet/corefx/search%3Fq%3Dsystem.drawing%26type%3DIssues" rel="nofollow">nombreuses demandes</a> et inclus System.Drawing dans .NET Core. <a name="habracut"></a>  (article original daté de juillet 2017) <br><br>  Le <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">prochain</a> package <a href="https://github.com/dotnet/corefx/pull/20593" rel="nofollow">System.Drawing.Common</a> contiendra la plupart des fonctionnalités System.Drawing du .NET Framework complet et est destiné à être utilisé comme option de compatibilité pour ceux qui souhaitent migrer vers .NET Core mais ne peuvent pas le faire en raison de dépendances.  De ce point de vue, Microsoft fait ce qu'il faut.  La friction doit être réduite car l'adoption de .Net Core est un objectif plus valable. <br><br>  D'un autre côté, System.Drawing est l'un des domaines les plus pauvres et les plus défavorisés du .Net Framework et beaucoup d'entre nous espéraient que la mise en œuvre de .NET Core signifierait la mort lente de System.Drawing.  Et avec cette mort devrait être l'occasion de faire quelque chose de mieux. <br><br>  Par exemple, l'équipe Mono a créé un wrapper compatible .NET pour la bibliothèque graphique multiplateforme <a href="https://skia.org/" rel="nofollow">Skia de</a> Google, appelée <a href="https://github.com/mono/SkiaSharp" rel="nofollow">SkiaSharp</a> .  Pour simplifier l'installation, Nuget a parcouru un long chemin dans la prise en charge des bibliothèques natives pour chaque plate-forme.  Skia est assez complet et ses performances font System.Drawing. <br><br>  L'équipe <a href="https://github.com/JimBobSquarePants/ImageSharp" rel="nofollow">ImageSharp</a> a également fait un excellent travail en répétant une grande partie de la fonctionnalité System.Drawing, mais avec la meilleure API et une implémentation 100% C #.  Ils ne sont toujours pas prêts pour une exploitation productive, mais il semble qu'ils soient déjà assez proches de cela.  Un petit avertissement à propos de cette bibliothèque, car nous parlons d'une utilisation dans les applications serveur: maintenant, dans la configuration par défaut, Parallel.For est utilisé à l'intérieur pour accélérer certaines opérations, ce qui signifie que plus de workflows du pool ASP.NET seront utilisés, éventuellement <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">En</a> conséquence, la <a href="https://www.hanselman.com/blog/BackToParallelBasicsDontBlockYourThreadsMakeAsyncIOWorkForYou.aspx" rel="nofollow">réduction du débit global de l'application</a> .  J'espère que ce comportement sera revu avant la sortie, mais même maintenant, il suffit de changer une ligne de la configuration pour la rendre plus adaptée à une utilisation sur le serveur. <br><br>  Dans tous les cas, si vous dessinez, tracez ou restituez du texte en images dans une application sur le serveur, vous devriez sérieusement envisager de modifier System.Drawing en quelque chose, que vous passiez ou non à .NET Core. <br><br>  Pour ma part, j'ai assemblé un pipeline de traitement d'image hautes performances pour .NET et .NET Core, qui fournit une qualité d'image que System.Drawing ne peut pas fournir, et le fait dans une architecture hautement évolutive conçue spécifiquement pour une utilisation sur le serveur.  Jusqu'à présent, ce n'est que pour Windows, cependant, la multiplateforme est dans les plans.  Si vous utilisez System.Drawing (ou autre chose) pour redimensionner les images sur le serveur, il est préférable de considérer <a href="https://github.com/saucecontrol/PhotoSauce" rel="nofollow">MagicScaler</a> comme un remplacement. <br><br>  Mais une résurrection de System.Drawing, qui facilite la transition pour certains développeurs, est susceptible de tuer l'essentiel de l'élan reçu par ces projets, car les développeurs ont été forcés de chercher des alternatives.  Malheureusement, dans l'écosystème .NET, les bibliothèques et packages Microsoft gagneront toujours, quelle que soit la qualité des alternatives. <br><br>  Ce message est une tentative de corriger certaines erreurs de calcul de System.Drawing dans l'espoir que les développeurs exploreront des alternatives même si System.Drawing reste une option. <br><br>  Je vais commencer par la <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">clause de non</a> - <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">responsabilité</a> souvent citée <a href="https://msdn.microsoft.com/en-us/library/system.drawing.aspx" rel="nofollow">dans la</a> documentation System.Drawing.  Ce rejet a été soulevé plusieurs fois dans une <a href="https://github.com/dotnet/corefx/issues/20325" rel="nofollow">discussion sur Github lors de la discussion sur System.Drawing.Common</a> . <br><blockquote>  «Les classes avec l'espace de noms System.Drawing ne sont pas prises en charge pour une utilisation dans les services Windows ou ASP.NET.  Tenter d'utiliser ces classes avec ces types d'applications peut entraîner des problèmes inattendus, tels qu'une baisse des performances du serveur et des erreurs d'exécution. " </blockquote><br>  Comme beaucoup d'entre vous, j'ai lu cet avertissement il y a très longtemps, puis je l'ai ignoré et j'ai toujours utilisé System.Drawing dans mon application ASP.NET.  Pourquoi?  Parce que j'aime le danger.  Soit cela, soit aucune autre option viable n'a été trouvée.  Et tu sais quoi?  Il ne s'est rien passé de mal.  Je n'aurais probablement pas dû dire cela, mais je parie que beaucoup d'entre vous ont vécu la même chose.  Alors pourquoi ne pas continuer à utiliser System.Drawing ou des bibliothèques basées sur lui? <br><br><h3>  Raison n ° 1: Descripteurs GDI </h3><br>  Si vous avez déjà rencontré des problèmes lors de l'utilisation de System.Drawing sur un serveur, c'est très probablement le cas.  S'il n'est pas testé, c'est l'une des causes les plus probables. <br><br>  System.Drawing est pour la plupart une enveloppe mince autour de l'API Windows GDI +.  De nombreux objets System.Drawing sont pris en charge par les <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v%3Dvs.85).aspx" rel="nofollow">descripteurs GDI</a> , et ils ont une limite quantitative sur le processeur et la session utilisateur.  Si ce seuil est atteint, vous obtiendrez une exception «Mémoire insuffisante» et / ou une erreur «générique» GDI +. <br><br>  Le problème est que dans .NET, la récupération de place et l'arrêt du processus peuvent retarder la publication de ces descripteurs au moment où vous atteignez la limite, même sous une charge légère.  Si vous oubliez (ou ne saviez pas ce dont vous avez besoin) d'appeler Dispose () sur un objet qui contient de tels descripteurs, vous risquez fort de rencontrer de telles erreurs dans votre environnement.  Et comme la plupart des bogues liés aux limitations ou aux fuites de ressources, cette situation sera probablement testée avec succès et vous piquera en fonctionnement productif.  Naturellement, cela se produit lorsque votre application est sous la plus grande charge, de sorte que le nombre maximum d'utilisateurs découvre votre honte. <br><br>  <a href="https://en.wikipedia.org/wiki/Graphics_Device_Interface" rel="nofollow">Les restrictions sur le processeur et sur la session utilisateur</a> dépendent de la version du système d'exploitation, et la restriction sur le processeur est personnalisable.  Mais la version n'a pas d'importance, car  Les descripteurs GDI sont représentés en interne par le type de données USHORT, il y a donc une limite stricte de 65 536 descripteurs par session utilisateur, et même une application bien écrite risque d'atteindre cette limite sous une charge suffisante.  Lorsque vous pensez qu'un serveur plus puissant vous permettra de servir de plus en plus d'utilisateurs en parallèle sur une seule instance, ce risque devient plus réel.  Et vraiment, qui veut créer un logiciel avec une limite bien connue d'évolutivité? <br><br><h3>  Raison n ° 2: accès simultané </h3><br>  GDI + a toujours eu des problèmes de simultanéité, bien que beaucoup d'entre eux étaient liés à <a href="https://blogs.msdn.microsoft.com/e7/2009/04/25/engineering-windows-7-graphics-performance/" rel="nofollow">des modifications architecturales dans Windows7 / Windows Server 2008 R2</a> , vous en voyez toujours certains dans les nouvelles versions.  Le plus notable est le <a href="https://stackoverflow.com/questions/3719748/parallelizing-gdi-image-resizing-net" rel="nofollow">verrouillage de processus</a> organisé par GDI + lors de l'opération DrawImage ().  Si vous redimensionnez des images sur le serveur à l'aide de System.Drawing (ou des bibliothèques qui l'enveloppent), la méthode DrawImage () est probablement la base de ce code. <br><br>  De plus, lorsque vous effectuez plusieurs appels à DrawImage () en même temps, <b>tous</b> seront bloqués jusqu'à <b>ce</b> qu'ils soient tous exécutés.  Même si le temps de réponse n'est pas un problème pour vous (pourquoi pas? Détestez-vous vos utilisateurs?) Gardez à l'esprit que toutes les ressources mémoire associées à ces demandes et tous les descripteurs GDI détenus par les objets associés à ces demandes sont liés à l'exécution.  En fait, cela ne prend pas trop de charge sur le serveur pour commencer à causer des problèmes. <br><br>  Bien sûr, il existe des solutions de contournement pour ce problème particulier.  Par exemple, certains développeurs créent un processus externe pour chaque opération DrawImage ().  Mais en fait, une telle solution de contournement ne fait qu'ajouter une fragilité supplémentaire, ce que vous n'auriez vraiment pas dû faire. <br><br><h3>  Raison n ° 3: la mémoire </h3><br>  Considérez un gestionnaire ASP.NET qui génère un graphique.  Il devrait faire quelque chose comme ça: <br><br><ol><li>  Créer un bitmap comme toile </li><li>  Dessinez plusieurs formes sur une image bitmap à l'aide de stylos et / ou de pinceaux </li><li>  Dessinez du texte en utilisant une ou plusieurs polices </li><li>  Enregistrer le bitmap au format PNG dans MemoryStream </li></ol><br>  Disons que le graphique mesure 600 par 400 points.  Il s'agit d'un total de 240 000 points, multiplié par 4 octets pour un point pour le format RGBA par défaut, totalisant 960 000 octets pour un bitmap, plus un peu pour les objets de dessin et un tampon de sauvegarde.  Soit 1 Mo pour toute la demande.  Très probablement, vous n'obtiendrez pas de problèmes de mémoire pour un tel scénario, et si vous rencontrez quelque chose, vous aurez très probablement une limite sur le nombre de descripteurs, que j'ai mentionné plus tôt, car les images, les pinceaux, les stylos et les polices ont leurs propres descripteurs. <br><br>  Le vrai problème survient lorsque System.Drawing est utilisé pour les tâches de création d'image.  System.Drawing est principalement une bibliothèque graphique, et les bibliothèques graphiques sont généralement toutes construites autour de l'idée que tout est un bitmap en mémoire.  C'est génial pendant que vous pensez aux petites choses.  Mais les images peuvent être très grandes, et elles grossissent chaque jour, car  les appareils photo avec beaucoup de mégapixels sont de moins en moins chers. <br><br>  Si vous adoptez l'approche naïve de System.Drawing pour la création d'images, vous obtenez quelque chose comme ceci pour le gestionnaire de redimensionnement: <br><br><ol><li>  Créez un bitmap en tant que canevas pour l'image de destination. </li><li>  Chargez l'image d'origine dans un autre bitmap. </li><li>  Appelez DrawImage () avec le paramètre "image-source" pour l'image de destination, en utilisant le redimensionnement. </li><li>  Enregistrez le bitmap cible au format JPEG dans le flux de mémoire. </li></ol><br>  Supposons que l'image cible soit de 600 x 400, comme dans l'exemple précédent, puis encore une fois, nous avons 1 Mo pour l' <i>image cible</i> et le flux de mémoire.  Mais supposons que quelqu'un ait téléchargé une image de 24 mégapixels à partir de ses nouveaux reflex numériques sophistiqués, alors nous avons besoin de 6000x4000 pixels avec 3 octets pour chacun (72 Mo) pour le bitmap source décodé au format RVB.  Et nous utiliserons le rééchantillonnage HighQualityBicubic de System.Drawing, car il ne semble que bon.  Ensuite, nous devons prendre en compte les autres points 6000x4000 avec 4 octets chacun, pour la <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-5-push-vs-pull-and-image-validation" rel="nofollow">conversion PRGBA qui se produit à l'intérieur de la méthode appelée</a> , en ajoutant 96 Mo supplémentaires de mémoire utilisée.  Au total, 169 Mo (!) Sont obtenus pour une demande de conversion d'une seule image. <br><br>  Imaginez maintenant que plusieurs utilisateurs fassent de telles choses.  N'oubliez pas que les demandes sont bloquées jusqu'à ce qu'elles soient toutes entièrement exécutées.  Combien de temps faut-il pour manquer de mémoire?  Et même si vous ne craignez pas d'épuiser complètement tout ce qui est disponible, n'oubliez pas qu'il existe de nombreuses façons de mieux utiliser la mémoire de votre serveur que de conserver un tas de pixels.  Tenez compte de l'effet de la pression de la mémoire sur d'autres parties de l'application / du système: <br><br><ol><li>  Le cache ASP.NET peut commencer à vider les éléments coûteux à recréer </li><li>  Le ramasse-miettes démarrera plus souvent, ralentissant l'application </li><li>  Le cache du noyau IIS ou le cache du système de fichiers Windows peut supprimer des éléments utiles </li><li>  Le pool d'applications peut dépasser la limite de mémoire et peut être redémarré </li><li>  Windows peut commencer à échanger de la mémoire sur le disque, ce qui ralentit l'ensemble du système </li></ol><br>  Tu ne veux vraiment rien de tout ça? <br><br>  Les bibliothèques conçues spécifiquement pour les tâches de traitement d'image abordent ce problème d'une manière complètement différente.  Ils n'ont pas besoin de charger l'intégralité de l'image source ou cible en mémoire.  Si vous n'allez pas dessiner dessus, vous n'avez pas besoin d'un canevas / bitmap.  Cela se fait plus comme ceci: <br><br><ol><li>  Créer un flux pour l'encodeur JPEG de l'image cible </li><li>  Chargez une ligne de l'image d'origine et compressez-la horizontalement </li><li>  Répétez autant de fois que nécessaire pour former une ligne pour le fichier cible </li><li>  Compressez les lignes résultantes verticalement </li><li>  Répétez à partir de l'étape 2 jusqu'à ce que toutes les lignes du fichier source soient traitées. </li></ol><br>  En utilisant cette méthode, la même image peut être traitée en utilisant 1 Mo de mémoire au total, et même des images beaucoup plus grandes nécessiteront une légère augmentation des frais généraux. <br><br>  Je ne connais qu'une seule bibliothèque .NET optimisée par ce principe, et je vais vous donner un indice: ce n'est pas System.Drawing. <br><br><h3>  Raison n ° 4: CPU </h3><br>  Un autre effet secondaire de System.Drawing étant plus orienté graphiquement qu'orienté image est que DrawImage () est assez inefficace en termes d'utilisation du CPU.  J'ai couvert cela en détail dans un article <a href="https://photosauce.net/blog/post/lies-damned-lies-and-benchmarks-part-2-drawimage-why-u-so-slow" rel="nofollow">précédent</a> , mais cette discussion peut être résumée par les faits suivants: <br><br><ul><li>  Dans System.Drawing, la conversion d'échelle HighQualityBicubic ne fonctionne qu'avec le format PRGBA.  Dans presque tous les scénarios, cela signifie une copie supplémentaire de l'image.  Non seulement cela utilise (considérablement) plus de mémoire supplémentaire, mais il brûle également les cycles du processeur pour convertir et traiter le canal alpha supplémentaire. </li><li>  Même après que l'image est dans son format natif, la conversion d'échelle HighQualityBicubic effectue environ 4 fois plus de calculs que nécessaire pour obtenir les résultats de conversion corrects. </li></ul><br>  Ces faits ajoutent une quantité importante de cycles CPU gaspillés.  Dans un environnement nuageux avec paiement à la minute, cela contribue directement au coût de l'hébergement.  Et bien sûr, votre temps de réponse en souffrira. <br><br>  Et pensez au fait que de l'électricité supplémentaire sera dépensée et de la chaleur produite.  Votre utilisation de System.Drawing pour les tâches de traitement d'image affecte directement le réchauffement climatique.  Tu es un monstre. <br><br><h3>  Raison n ° 5: le traitement d'image est d'une complexité trompeuse </h3><br>  Mis à part les performances, System.Drawing empêche à plusieurs égards le traitement correct de l'image.  Utiliser System.Drawing signifie vivre avec une sortie incorrecte ou tout apprendre sur le profil ICC, la quantification des couleurs, l'orientation exif, la correction et bien d'autres choses spécifiques.  Il s'agit d'un terrier de lapin que la plupart des développeurs n'ont ni le temps ni l'envie d'explorer. <br><br>  Les bibliothèques telles que ImageResizer et ImageProcessor ont gagné beaucoup de fans, en prenant soin de certains de ces détails, mais attention, elles ont System.Drawing à l'intérieur, et elles accompagnent tous les bagages que j'ai décrits en détail dans cet article. <br><br><h3>  Raison du bonus: vous pouvez faire mieux </h3><br>  Si vous, comme moi, avez dû porter des lunettes à un moment de votre vie, vous vous souvenez probablement comment c'était la première fois que vous les mettiez.  Je pensais que je voyais normalement, et si je plisse les yeux correctement, alors tout sera assez clair.  Mais ensuite j'ai mis ces lunettes, et le monde est devenu beaucoup plus détaillé que je n'aurais pu l'imaginer. <br><br>  System.Drawing est à peu près la même chose.  Cela fait la bonne chose si vous <a href="https://photosauce.net/blog/post/image-scaling-with-gdi-part-3-drawimage-and-the-settings-that-affect-it" rel="nofollow">remplissez correctement les paramètres</a> , mais vous serez surpris de voir à quel point vos images peuvent être meilleures si vous utilisez les meilleurs utilitaires. <br><br>  Je vais juste laisser cela ici à titre d'exemple.  C'est le meilleur système que System.Drawing puisse faire par rapport aux paramètres MagicScaler par défaut.  Peut-être que votre application bénéficiera de l'obtention de points ... <br><br>  Gdi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/9c9/491/9a69c9491e230c3a7e887e830d136860.jpg" alt="image"><br><br>  MagicScaler: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/eec/e24/dd2eece240e1a41b46c74ccde2e5eed2.jpg" alt="image"><br>  <a href="https://unsplash.com/%40jakobowens1" rel="nofollow">Photo de Jakob Owens</a> <br><br>  Jetez un coup d'œil, explorez des alternatives et s'il vous plaît, au nom de l'amour pour les chatons, arrêtez d'utiliser System.Drawing dans ASP.NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482274/">https://habr.com/ru/post/fr482274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482260/index.html">TelegramBot. La fonctionnalité de base. Autocollants et émoticônes. (Partie 3)</a></li>
<li><a href="../fr482262/index.html">Comment se connecter à Talend Open Studio</a></li>
<li><a href="../fr482264/index.html">Brésil, magie noire, Mortal Kombat, Mars et 15 000 personnes. Résultats de l'année Ontiko</a></li>
<li><a href="../fr482268/index.html">Mégastructures du futur: la sphère Dyson, le moteur stellaire et la «bombe du trou noir»</a></li>
<li><a href="../fr482272/index.html">Choisir un entrepôt de données pour Prometheus: Thanos vs VictoriaMetrics</a></li>
<li><a href="../fr482276/index.html">GOST R 57580. Des tendances à l'automatisation efficace</a></li>
<li><a href="../fr482280/index.html">Comment se fait le cosplay. Costume de costume avancé d'Isaac Clarke de Dead Space 2</a></li>
<li><a href="../fr482282/index.html">La fin de l'ère ARMv7 ou un peu sur le portage de jeux</a></li>
<li><a href="../fr482284/index.html">"50 nuances de brun" ou "Comment en sommes-nous arrivés là"</a></li>
<li><a href="../fr482286/index.html">Revue collective inattendue des cartouches Audio-Technica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>