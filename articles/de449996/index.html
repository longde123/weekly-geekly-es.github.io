<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍜 🧜🏿 🏂🏿 Den FFT-Algorithmus verstehen ⚗️ 🍀 🎞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Der Kurs " Algorithmen für Entwickler" beginnt morgen und wir haben noch eine unveröffentlichte Übersetzung. Eigentlich korrigieren wir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Den FFT-Algorithmus verstehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449996/"> Hallo Freunde.  Der Kurs " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen für Entwickler"</a> beginnt morgen und wir haben noch eine unveröffentlichte Übersetzung.  Eigentlich korrigieren wir und teilen Material mit Ihnen.  Lass uns gehen. <br><br>  Die schnelle Fourier-Transformation (FFT) ist einer der wichtigsten Signalverarbeitungs- und Datenanalysealgorithmen.  Ich habe es jahrelang ohne formale Kenntnisse in der Informatik benutzt.  Aber diese Woche kam mir der Gedanke, dass ich mich nie gefragt habe, wie die FFT die diskrete Fourier-Transformation so schnell berechnet.  Ich schüttelte den Staub eines alten Buches über Algorithmen ab, öffnete es und las mit Vergnügen den täuschend einfachen Rechen-Trick, den J.V. Cooley und John Tukey in ihrer klassischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeit</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1965</a> zu diesem Thema beschrieben hatten. <br><br><img src="https://habrastorage.org/webt/n4/54/6k/n4546kuwmamg91yhazlpndgglh4.png"><br><br>  Das Ziel dieses Beitrags ist es, in den Cooley-Tukey-FFT-Algorithmus einzutauchen, die dazu führenden Symmetrien zu erklären und einige einfache Python-Implementierungen zu zeigen, die die Theorie in der Praxis anwenden.  Ich hoffe, dass diese Studie Datenanalysespezialisten wie mir ein vollständigeres Bild davon gibt, was unter der Haube der von uns verwendeten Algorithmen geschieht. <a name="habracut"></a><br><br>  <b>Diskrete Fourier-Transformation</b> <br><br>  FFT ist schnell <img src="https://habrastorage.org/webt/bq/s0/ah/bqs0ahni9guseo62jp5hvz3e4x8.png">  ein Algorithmus zur Berechnung der diskreten Fourier-Transformation (DFT), für die direkt berechnet wird <img src="https://habrastorage.org/webt/ys/jt/e9/ysjte98k7mfch0w1mttpu5fqnbg.png">  .  Die DFT hat wie die bekanntere kontinuierliche Version der Fourier-Transformation eine direkte und inverse Form, die wie folgt definiert sind: <br><br>  <i><b>Direkte diskrete Fourier-Transformation (DFT):</b></i> <br><br><img src="https://habrastorage.org/webt/uj/sh/qc/ujshqcnsbasvypykupwcjocfbcg.png"><br><br>  <i><b>Inverse diskrete Fourier-Transformation (ODPF):</b></i> <br><br><img src="https://habrastorage.org/webt/zg/dp/0t/zgdp0tdylocjv_ck6a0y6m97ac8.png"><br><br>  Die Umwandlung von <code>xn → Xk</code> ist eine Übersetzung vom Konfigurationsraum in den Frequenzraum und kann sowohl zur Untersuchung des Signalleistungsspektrums als auch zur Umwandlung bestimmter Aufgaben für eine effizientere Berechnung sehr nützlich sein.  Einige Beispiele hierfür finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 10 unseres zukünftigen Buches</a> über Astronomie und Statistik. Dort finden Sie auch Bilder und Quellcode in Python.  Ein Beispiel für die Verwendung von FFT zur Vereinfachung der Integration ansonsten komplizierter Differentialgleichungen finden Sie in meinem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Lösen der Schrödinger-Gleichung in Python“</a> . <br><br>  Aufgrund der Bedeutung von FFT (im Folgenden kann die äquivalente FFT - Fast Fourier Transform verwendet werden) enthält Python in vielen Bereichen viele Standardwerkzeuge und -shells zur Berechnung.  Sowohl NumPy als auch SciPy verfügen über Shells aus der äußerst gut getesteten FFTPACK-Bibliothek, die in den <code>scipy.fftpack</code> <code>numpy.fft</code> und <code>scipy.fftpack</code> sind.  Die schnellste FFT, die ich kenne, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFTW-</a> Paket, das auch in Python über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyFFTW-</a> Paket verfügbar ist. <br><br>  Lassen wir diese Implementierungen jedoch zunächst beiseite und fragen uns, wie wir die FFT in Python von Grund auf neu berechnen können. <br><br>  <b>Diskrete Fourier-Transformationsberechnung</b> <br><br>  Der Einfachheit halber werden wir uns nur mit der direkten Konvertierung befassen, da die inverse Transformation auf sehr ähnliche Weise implementiert werden kann.  Wenn wir uns den obigen Ausdruck der DFT ansehen, sehen wir, dass dies nichts weiter als eine einfache lineare Operation ist: Multiplizieren der Matrix mit einem Vektor <br><br><img src="https://habrastorage.org/webt/mg/qb/es/mgqbesmhfu6rqoztm33y2o6dpd0.png"><br><br><img src="https://habrastorage.org/webt/zi/1a/t2/zi1at2pha9pp2xtnu_if6cps-xe.png"><br><br>  mit Matrix M gegeben <br><br><img src="https://habrastorage.org/webt/ox/ka/mc/oxkamcki5i2fn5nqafbue7phkki.png"><br><br>  Vor diesem Hintergrund können wir die DFT mithilfe einer einfachen Matrixmultiplikation wie folgt berechnen: <br><br>  In [1]: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DFT_slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Compute the discrete Fourier Transform of the 1D array x"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] n = np.arange(N) k = n.reshape((N, <span class="hljs-number"><span class="hljs-number">1</span></span>)) M = np.exp(<span class="hljs-number"><span class="hljs-number">-2j</span></span> * np.pi * k * n / N) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.dot(M, x)</code> </pre> <br>  Wir können das Ergebnis überprüfen, indem wir es mit der in numpy integrierten FFT-Funktion vergleichen: <br><br>  In [2]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(DFT_slow(x), np.fft.fft(x))</code> </pre> <br>  0ut [2]: <br><br> <code>True</code> <br> <br>  Um die Langsamkeit unseres Algorithmus zu bestätigen, können wir die Ausführungszeit dieser beiden Ansätze vergleichen: <br><br>  In [3]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 75.4 ms per loop 10000 loops, best of 3: 25.5 µs per loop</code> </pre> <br>  Wir sind mehr als 1000-mal langsamer, was für eine derart vereinfachte Implementierung zu erwarten ist.  Das ist aber nicht das Schlimmste.  Für einen Eingabevektor der Länge N skaliert der FFT-Algorithmus als <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  während unser langsamer Algorithmus wie skaliert <img src="https://habrastorage.org/webt/qk/or/aw/qkoraw_lw5tjqyhr1ubbvmvx0i4.png">  .  Dies bedeutet, dass für <img src="https://habrastorage.org/webt/8s/bu/zi/8sbuziwl0cyxjezr0qezsvibrpo.png">  Wir erwarten, dass die FFT in ungefähr 50 ms abgeschlossen sein wird, während unser langsamer Algorithmus ungefähr 20 Stunden dauern wird! <br><br>  Wie erreicht die FFT eine solche Beschleunigung?  Die Antwort ist, Symmetrie zu verwenden. <br><br>  <b>Symmetrien in der diskreten Fourier-Transformation</b> <br><br>  Eines der wichtigsten Werkzeuge beim Erstellen von Algorithmen ist die Verwendung von Aufgabensymmetrien.  Wenn Sie analytisch zeigen können, dass ein Teil des Problems einfach mit dem anderen zusammenhängt, können Sie das Teilergebnis nur einmal berechnen und diese Berechnungskosten sparen.  Cooley und Tukey verwendeten genau diesen Ansatz, um FFT zu erhalten. <br>  Wir beginnen mit der Frage nach der Bedeutung <img src="https://habrastorage.org/webt/wv/vq/0t/wvvq0twerwsciysi5sgxfsnfooo.png">  .  Aus unserem obigen Ausdruck: <br><br><img src="https://habrastorage.org/webt/hd/el/f3/hdelf3dxco-xuar0bgic_ha89lu.png"><br><br>  wo wir die Identität exp [2π in] = 1 verwendet haben, die für jede ganze Zahl n gilt. <br><br>  Die letzte Zeile zeigt gut die Symmetrieeigenschaft der DFT: <br><br><img src="https://habrastorage.org/webt/ac/dz/wq/acdzwq4jwn4vizgzdafg3as6ila.png"><br><br>  Eine einfache Erweiterung <br><br><img src="https://habrastorage.org/webt/su/bl/c_/sublc_wuerprr4ppl_bqln89c24.png"><br><br>  für jede ganze Zahl i.  Wie wir unten sehen werden, kann diese Symmetrie verwendet werden, um die DFT viel schneller zu berechnen. <br><br>  <b>DFT in FFT: Symmetrie verwenden</b> <br><br>  Cooley und Tukey zeigten, dass FFT-Berechnungen in zwei kleinere Teile unterteilt werden können.  Aus der Definition von DFT haben wir: <br><br><img src="https://habrastorage.org/webt/dg/lz/lm/dglzlmmd1oue7oqyn39gwavofva.png"><br><br>  Wir haben eine diskrete Fourier-Transformation in zwei Terme unterteilt, die an sich kleineren diskreten Fourier-Transformationen sehr ähnlich sind, eine für Werte mit einer ungeraden Zahl und eine für Werte mit einer geraden Zahl.  Bisher haben wir jedoch keine Rechenzyklen gespeichert.  Jeder Term besteht aus (N / 2) ∗ N Berechnungen insgesamt <img src="https://habrastorage.org/webt/bg/lz/we/bglzwecwics3t1gful-oe5auipc.png">  . <br><br>  Der Trick besteht darin, unter jeder dieser Bedingungen Symmetrie zu verwenden.  Da der Bereich von k 0 ≤ k &lt;N ist und der Bereich von n 0 ≤ n &lt;M≡N / 2 ist, sehen wir aus den obigen Symmetrieeigenschaften, dass wir nur die Hälfte der Berechnungen für jede Teilaufgabe durchführen müssen.  Unsere Berechnung <img src="https://habrastorage.org/webt/my/tx/pq/mytxpqv7swzpsqfbq5manbp7kme.png">  ist geworden <img src="https://habrastorage.org/webt/6l/lv/ln/6llvlnumnlnndoir0whpg7qf_gc.png">  wobei M zweimal kleiner als N ist. <br><br>  Es gibt jedoch keinen Grund, sich damit zu befassen: Solange unsere kleineren Fourier-Transformationen ein gerades M haben, können wir diesen „Divide and Conquer“ -Ansatz jedes Mal, wenn sich die Rechenkosten halbieren, erneut anwenden, bis unsere Arrays klein genug sind, sodass die Strategie keine Vorteile mehr bietet.  In der asymptotischen Grenze skaliert dieser rekursive Ansatz als O [NlogN]. <br><br>  Dieser rekursive Algorithmus kann sehr schnell in Python implementiert werden, beginnend mit unserem langsamen DFT-Code, wenn die Größe der Unteraufgabe recht klein wird: <br><br>  In [4]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A recursive implementation of the 1D Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> N % <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> N &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-comment"><span class="hljs-comment"># this cutoff should be optimized return DFT_slow(x) else: X_even = FFT(x[::2]) X_odd = FFT(x[1::2]) factor = np.exp(-2j * np.pi * np.arange(N) / N) return np.concatenate([X_even + factor[:N / 2] * X_odd, X_even + factor[N / 2:] * X_odd])</span></span></code> </pre> <br><br>  Hier werden wir schnell überprüfen, ob unser Algorithmus das richtige Ergebnis liefert: <br>  In [5]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT(x), np.fft.fft(x))</code> </pre> <br><br>  Out [5]: <br> <code>True</code> <br> <br>  Vergleichen Sie diesen Algorithmus mit unserer langsamen Version: <br>  -In [6]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit FFT(x) %timeit np.fft.fft(x)</code> </pre> <br><br><pre> <code class="plaintext hljs">10 loops, best of 3: 77.6 ms per loop 100 loops, best of 3: 4.07 ms per loop 10000 loops, best of 3: 24.7 µs per loop</code> </pre> <br>  Unsere Berechnung ist schneller als die direkte Version!  Darüber hinaus ist unser rekursiver Algorithmus asymptotisch <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  : Wir haben die schnelle Fourier-Transformation implementiert. <br><br>  Beachten Sie, dass wir immer noch nicht in der Nähe der Geschwindigkeit des in numpy integrierten FFT-Algorithmus sind, und dies sollte erwartet werden.  Der FFTPACK-Algorithmus hinter <code>fft</code> numpy ist eine Fortran-Implementierung, die jahrelang verfeinert und optimiert wurde.  Darüber hinaus umfasst unsere NumPy-Lösung sowohl die Rekursion des Python-Stacks als auch die Zuweisung vieler temporärer Arrays, wodurch sich die Rechenzeit erhöht. <br><br>  Eine gute Strategie zur Beschleunigung des Codes bei der Arbeit mit Python / NumPy besteht darin, sich wiederholende Berechnungen nach Möglichkeit zu vektorisieren.  Wir können dies tun - löschen Sie dabei unsere rekursiven Funktionsaufrufe, wodurch unsere Python-FFT noch effizienter wird. <br><br>  <b>Vektorisierte Numpy-Version</b> <br><br>  Bitte beachten Sie, dass in der obigen rekursiven Implementierung von FFT auf der niedrigsten Rekursionsstufe <b>N / 32</b> identische Matrixvektorprodukte ausgeführt werden.  Die Effektivität unseres Algorithmus wird gewinnen, wenn wir diese Matrixvektorprodukte gleichzeitig als ein einzelnes Matrixmatrixprodukt berechnen.  Auf jeder nachfolgenden Rekursionsstufe führen wir auch sich wiederholende Operationen aus, die vektorisiert werden können.  NumPy leistet hervorragende Arbeit bei einer solchen Operation, und wir können diese Tatsache nutzen, um diese vektorisierte Version der schnellen Fourier-Transformation zu erstellen: <br><br>  In [7]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT_vectorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A vectorized, non-recursive version of the Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> np.log2(N) % <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># N_min here is equivalent to the stopping condition above, # and should be a power of 2 N_min = min(N, 32) # Perform an O[N^2] DFT on all length-N_min sub-problems at once n = np.arange(N_min) k = n[:, None] M = np.exp(-2j * np.pi * n * k / N_min) X = np.dot(M, x.reshape((N_min, -1))) # build-up each level of the recursive calculation all at once while X.shape[0] &lt; N: X_even = X[:, :X.shape[1] / 2] X_odd = X[:, X.shape[1] / 2:] factor = np.exp(-1j * np.pi * np.arange(X.shape[0]) / X.shape[0])[:, None] X = np.vstack([X_even + factor * X_odd, X_even - factor * X_odd]) return X.ravel()</span></span></code> </pre> <br>  Obwohl der Algorithmus etwas undurchsichtiger ist, handelt es sich lediglich um eine Neuanordnung der in der rekursiven Version verwendeten Operationen, mit einer Ausnahme: Wir verwenden Symmetrie bei der Berechnung der Koeffizienten und erstellen nur die Hälfte des Arrays.  Wieder bestätigen wir, dass unsere Funktion das richtige Ergebnis liefert: <br><br>  In [8]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT_vectorized(x), np.fft.fft(x))</code> </pre> <br><br>  Out [8]: <br> <code>True</code> <br> <br>  Da unsere Algorithmen viel effizienter werden, können wir ein größeres Array verwenden, um die Zeit zu vergleichen, sodass <code>DFT_slow</code> übrig <code>DFT_slow</code> : <br>  In [9]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) %timeit FFT(x) %timeit FFT_vectorized(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 72.8 ms per loop 100 loops, best of 3: 4.11 ms per loop 1000 loops, best of 3: 505 µs per loop</code> </pre> <br>  Wir haben unsere Implementierung um eine Größenordnung verbessert!  Jetzt sind wir ungefähr zehnmal vom FFTPACK-Benchmark entfernt und verwenden nur ein paar Dutzend Zeilen reines Python + NumPy.  Obwohl dies in Bezug auf die Lesbarkeit immer noch nicht rechnerisch konsistent ist, ist die Python-Version dem FFTPACK-Quellcode, den Sie <a href="">hier</a> anzeigen können, weit überlegen. <br><br>  Wie erreicht FFTPACK diese letzte Beschleunigung?  Im Grunde ist es nur eine Frage der detaillierten Buchhaltung.  FFTPACK verbringt viel Zeit damit, Zwischenberechnungen wiederzuverwenden, die wiederverwendet werden können.  Unsere zerlumpte Version enthält immer noch überschüssige Speicherzuweisung und Kopieren.  In einer einfachen Sprache wie Fortran ist es einfacher, die Speichernutzung zu steuern und zu minimieren.  Darüber hinaus kann der Cooley-Tukey-Algorithmus erweitert werden, um Partitionen mit einer anderen Größe als 2 zu verwenden (was wir hier implementiert haben, ist als Cooley-Tukey-Radix-FFT auf der Basis von 2 bekannt).  Es können auch andere komplexere FFT-Algorithmen verwendet werden, einschließlich grundlegend unterschiedlicher Ansätze, die auf Faltungsdaten basieren (siehe beispielsweise den Blueshtein-Algorithmus und den Raider-Algorithmus).  Die Kombination der oben genannten Erweiterungen und Methoden kann selbst bei Arrays, deren Größe keine Zweierpotenz ist, zu sehr schnellen FFTs führen. <br><br>  Obwohl Funktionen in reinem Python in der Praxis wahrscheinlich nutzlos sind, hoffe ich, dass sie einen Einblick in das geben, was im Hintergrund der FFT-basierten Datenanalyse geschieht.  Als Datenexperten können wir mit der Implementierung der „Black Box“ grundlegender Tools fertig werden, die von unseren algorithmisch orientierten Kollegen erstellt wurden. Ich bin jedoch der festen Überzeugung, dass je besser wir die Algorithmen auf niedriger Ebene verstehen, die wir auf unsere Daten anwenden, desto bessere Praktiken wir werden. <br><br>  Dieser Beitrag wurde vollständig in IPython Notepad geschrieben.  Das vollständige Notizbuch kann hier heruntergeladen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> statisch angezeigt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br>  Viele mögen bemerken, dass das Material alles andere als neu ist, aber es scheint uns ziemlich relevant zu sein.  Schreiben Sie im Allgemeinen, ob der Artikel nützlich war.  Warten auf Ihre Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449996/">https://habr.com/ru/post/de449996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449978/index.html">Igor Antarov vom Moskauer Tesla Club kämpft mit 20 Mythen über Tesla und Elektroautos</a></li>
<li><a href="../de449984/index.html">Google News und Leo Tolstoy: Visualisierung von Word2Vec-Worteinbettungen mit t-SNE</a></li>
<li><a href="../de449986/index.html">Blockchain: Was sollen wir einen Fall bauen?</a></li>
<li><a href="../de449990/index.html">Wie kann man Latex, Formeln und Habr finden?</a></li>
<li><a href="../de449992/index.html">NodeMCU Simple Driver Model (SDM) Schaufenster: Dynamische Benutzeroberfläche</a></li>
<li><a href="../de449998/index.html">FAQ: Was ein reisender Geek über Impfungen wissen muss, bevor er reist</a></li>
<li><a href="../de450000/index.html">(Von rechts nach links (Durch den Spiegel</a></li>
<li><a href="../de450002/index.html">Suchen von Fehlern in LLVM 8 mit PVS-Studio</a></li>
<li><a href="../de450004/index.html">Schneller C / C ++ - Cache, Thread-Sicherheit</a></li>
<li><a href="../de450006/index.html">Kühlung des Kühler-Rechenzentrums: Welches Kühlmittel soll gewählt werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>