<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçú üßúüèø üèÇüèø Den FFT-Algorithmus verstehen ‚öóÔ∏è üçÄ üéûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Der Kurs " Algorithmen f√ºr Entwickler" beginnt morgen und wir haben noch eine unver√∂ffentlichte √úbersetzung. Eigentlich korrigieren wir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Den FFT-Algorithmus verstehen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449996/"> Hallo Freunde.  Der Kurs " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen f√ºr Entwickler"</a> beginnt morgen und wir haben noch eine unver√∂ffentlichte √úbersetzung.  Eigentlich korrigieren wir und teilen Material mit Ihnen.  Lass uns gehen. <br><br>  Die schnelle Fourier-Transformation (FFT) ist einer der wichtigsten Signalverarbeitungs- und Datenanalysealgorithmen.  Ich habe es jahrelang ohne formale Kenntnisse in der Informatik benutzt.  Aber diese Woche kam mir der Gedanke, dass ich mich nie gefragt habe, wie die FFT die diskrete Fourier-Transformation so schnell berechnet.  Ich sch√ºttelte den Staub eines alten Buches √ºber Algorithmen ab, √∂ffnete es und las mit Vergn√ºgen den t√§uschend einfachen Rechen-Trick, den J.V. Cooley und John Tukey in ihrer klassischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeit</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1965</a> zu diesem Thema beschrieben hatten. <br><br><img src="https://habrastorage.org/webt/n4/54/6k/n4546kuwmamg91yhazlpndgglh4.png"><br><br>  Das Ziel dieses Beitrags ist es, in den Cooley-Tukey-FFT-Algorithmus einzutauchen, die dazu f√ºhrenden Symmetrien zu erkl√§ren und einige einfache Python-Implementierungen zu zeigen, die die Theorie in der Praxis anwenden.  Ich hoffe, dass diese Studie Datenanalysespezialisten wie mir ein vollst√§ndigeres Bild davon gibt, was unter der Haube der von uns verwendeten Algorithmen geschieht. <a name="habracut"></a><br><br>  <b>Diskrete Fourier-Transformation</b> <br><br>  FFT ist schnell <img src="https://habrastorage.org/webt/bq/s0/ah/bqs0ahni9guseo62jp5hvz3e4x8.png">  ein Algorithmus zur Berechnung der diskreten Fourier-Transformation (DFT), f√ºr die direkt berechnet wird <img src="https://habrastorage.org/webt/ys/jt/e9/ysjte98k7mfch0w1mttpu5fqnbg.png">  .  Die DFT hat wie die bekanntere kontinuierliche Version der Fourier-Transformation eine direkte und inverse Form, die wie folgt definiert sind: <br><br>  <i><b>Direkte diskrete Fourier-Transformation (DFT):</b></i> <br><br><img src="https://habrastorage.org/webt/uj/sh/qc/ujshqcnsbasvypykupwcjocfbcg.png"><br><br>  <i><b>Inverse diskrete Fourier-Transformation (ODPF):</b></i> <br><br><img src="https://habrastorage.org/webt/zg/dp/0t/zgdp0tdylocjv_ck6a0y6m97ac8.png"><br><br>  Die Umwandlung von <code>xn ‚Üí Xk</code> ist eine √úbersetzung vom Konfigurationsraum in den Frequenzraum und kann sowohl zur Untersuchung des Signalleistungsspektrums als auch zur Umwandlung bestimmter Aufgaben f√ºr eine effizientere Berechnung sehr n√ºtzlich sein.  Einige Beispiele hierf√ºr finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 10 unseres zuk√ºnftigen Buches</a> √ºber Astronomie und Statistik. Dort finden Sie auch Bilder und Quellcode in Python.  Ein Beispiel f√ºr die Verwendung von FFT zur Vereinfachung der Integration ansonsten komplizierter Differentialgleichungen finden Sie in meinem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûL√∂sen der Schr√∂dinger-Gleichung in Python‚Äú</a> . <br><br>  Aufgrund der Bedeutung von FFT (im Folgenden kann die √§quivalente FFT - Fast Fourier Transform verwendet werden) enth√§lt Python in vielen Bereichen viele Standardwerkzeuge und -shells zur Berechnung.  Sowohl NumPy als auch SciPy verf√ºgen √ºber Shells aus der √§u√üerst gut getesteten FFTPACK-Bibliothek, die in den <code>scipy.fftpack</code> <code>numpy.fft</code> und <code>scipy.fftpack</code> sind.  Die schnellste FFT, die ich kenne, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFTW-</a> Paket, das auch in Python √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyFFTW-</a> Paket verf√ºgbar ist. <br><br>  Lassen wir diese Implementierungen jedoch zun√§chst beiseite und fragen uns, wie wir die FFT in Python von Grund auf neu berechnen k√∂nnen. <br><br>  <b>Diskrete Fourier-Transformationsberechnung</b> <br><br>  Der Einfachheit halber werden wir uns nur mit der direkten Konvertierung befassen, da die inverse Transformation auf sehr √§hnliche Weise implementiert werden kann.  Wenn wir uns den obigen Ausdruck der DFT ansehen, sehen wir, dass dies nichts weiter als eine einfache lineare Operation ist: Multiplizieren der Matrix mit einem Vektor <br><br><img src="https://habrastorage.org/webt/mg/qb/es/mgqbesmhfu6rqoztm33y2o6dpd0.png"><br><br><img src="https://habrastorage.org/webt/zi/1a/t2/zi1at2pha9pp2xtnu_if6cps-xe.png"><br><br>  mit Matrix M gegeben <br><br><img src="https://habrastorage.org/webt/ox/ka/mc/oxkamcki5i2fn5nqafbue7phkki.png"><br><br>  Vor diesem Hintergrund k√∂nnen wir die DFT mithilfe einer einfachen Matrixmultiplikation wie folgt berechnen: <br><br>  In [1]: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DFT_slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Compute the discrete Fourier Transform of the 1D array x"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] n = np.arange(N) k = n.reshape((N, <span class="hljs-number"><span class="hljs-number">1</span></span>)) M = np.exp(<span class="hljs-number"><span class="hljs-number">-2j</span></span> * np.pi * k * n / N) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.dot(M, x)</code> </pre> <br>  Wir k√∂nnen das Ergebnis √ºberpr√ºfen, indem wir es mit der in numpy integrierten FFT-Funktion vergleichen: <br><br>  In [2]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(DFT_slow(x), np.fft.fft(x))</code> </pre> <br>  0ut [2]: <br><br> <code>True</code> <br> <br>  Um die Langsamkeit unseres Algorithmus zu best√§tigen, k√∂nnen wir die Ausf√ºhrungszeit dieser beiden Ans√§tze vergleichen: <br><br>  In [3]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 75.4 ms per loop 10000 loops, best of 3: 25.5 ¬µs per loop</code> </pre> <br>  Wir sind mehr als 1000-mal langsamer, was f√ºr eine derart vereinfachte Implementierung zu erwarten ist.  Das ist aber nicht das Schlimmste.  F√ºr einen Eingabevektor der L√§nge N skaliert der FFT-Algorithmus als <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  w√§hrend unser langsamer Algorithmus wie skaliert <img src="https://habrastorage.org/webt/qk/or/aw/qkoraw_lw5tjqyhr1ubbvmvx0i4.png">  .  Dies bedeutet, dass f√ºr <img src="https://habrastorage.org/webt/8s/bu/zi/8sbuziwl0cyxjezr0qezsvibrpo.png">  Wir erwarten, dass die FFT in ungef√§hr 50 ms abgeschlossen sein wird, w√§hrend unser langsamer Algorithmus ungef√§hr 20 Stunden dauern wird! <br><br>  Wie erreicht die FFT eine solche Beschleunigung?  Die Antwort ist, Symmetrie zu verwenden. <br><br>  <b>Symmetrien in der diskreten Fourier-Transformation</b> <br><br>  Eines der wichtigsten Werkzeuge beim Erstellen von Algorithmen ist die Verwendung von Aufgabensymmetrien.  Wenn Sie analytisch zeigen k√∂nnen, dass ein Teil des Problems einfach mit dem anderen zusammenh√§ngt, k√∂nnen Sie das Teilergebnis nur einmal berechnen und diese Berechnungskosten sparen.  Cooley und Tukey verwendeten genau diesen Ansatz, um FFT zu erhalten. <br>  Wir beginnen mit der Frage nach der Bedeutung <img src="https://habrastorage.org/webt/wv/vq/0t/wvvq0twerwsciysi5sgxfsnfooo.png">  .  Aus unserem obigen Ausdruck: <br><br><img src="https://habrastorage.org/webt/hd/el/f3/hdelf3dxco-xuar0bgic_ha89lu.png"><br><br>  wo wir die Identit√§t exp [2œÄ in] = 1 verwendet haben, die f√ºr jede ganze Zahl n gilt. <br><br>  Die letzte Zeile zeigt gut die Symmetrieeigenschaft der DFT: <br><br><img src="https://habrastorage.org/webt/ac/dz/wq/acdzwq4jwn4vizgzdafg3as6ila.png"><br><br>  Eine einfache Erweiterung <br><br><img src="https://habrastorage.org/webt/su/bl/c_/sublc_wuerprr4ppl_bqln89c24.png"><br><br>  f√ºr jede ganze Zahl i.  Wie wir unten sehen werden, kann diese Symmetrie verwendet werden, um die DFT viel schneller zu berechnen. <br><br>  <b>DFT in FFT: Symmetrie verwenden</b> <br><br>  Cooley und Tukey zeigten, dass FFT-Berechnungen in zwei kleinere Teile unterteilt werden k√∂nnen.  Aus der Definition von DFT haben wir: <br><br><img src="https://habrastorage.org/webt/dg/lz/lm/dglzlmmd1oue7oqyn39gwavofva.png"><br><br>  Wir haben eine diskrete Fourier-Transformation in zwei Terme unterteilt, die an sich kleineren diskreten Fourier-Transformationen sehr √§hnlich sind, eine f√ºr Werte mit einer ungeraden Zahl und eine f√ºr Werte mit einer geraden Zahl.  Bisher haben wir jedoch keine Rechenzyklen gespeichert.  Jeder Term besteht aus (N / 2) ‚àó N Berechnungen insgesamt <img src="https://habrastorage.org/webt/bg/lz/we/bglzwecwics3t1gful-oe5auipc.png">  . <br><br>  Der Trick besteht darin, unter jeder dieser Bedingungen Symmetrie zu verwenden.  Da der Bereich von k 0 ‚â§ k &lt;N ist und der Bereich von n 0 ‚â§ n &lt;M‚â°N / 2 ist, sehen wir aus den obigen Symmetrieeigenschaften, dass wir nur die H√§lfte der Berechnungen f√ºr jede Teilaufgabe durchf√ºhren m√ºssen.  Unsere Berechnung <img src="https://habrastorage.org/webt/my/tx/pq/mytxpqv7swzpsqfbq5manbp7kme.png">  ist geworden <img src="https://habrastorage.org/webt/6l/lv/ln/6llvlnumnlnndoir0whpg7qf_gc.png">  wobei M zweimal kleiner als N ist. <br><br>  Es gibt jedoch keinen Grund, sich damit zu befassen: Solange unsere kleineren Fourier-Transformationen ein gerades M haben, k√∂nnen wir diesen ‚ÄûDivide and Conquer‚Äú -Ansatz jedes Mal, wenn sich die Rechenkosten halbieren, erneut anwenden, bis unsere Arrays klein genug sind, sodass die Strategie keine Vorteile mehr bietet.  In der asymptotischen Grenze skaliert dieser rekursive Ansatz als O [NlogN]. <br><br>  Dieser rekursive Algorithmus kann sehr schnell in Python implementiert werden, beginnend mit unserem langsamen DFT-Code, wenn die Gr√∂√üe der Unteraufgabe recht klein wird: <br><br>  In [4]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A recursive implementation of the 1D Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> N % <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> N &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-comment"><span class="hljs-comment"># this cutoff should be optimized return DFT_slow(x) else: X_even = FFT(x[::2]) X_odd = FFT(x[1::2]) factor = np.exp(-2j * np.pi * np.arange(N) / N) return np.concatenate([X_even + factor[:N / 2] * X_odd, X_even + factor[N / 2:] * X_odd])</span></span></code> </pre> <br><br>  Hier werden wir schnell √ºberpr√ºfen, ob unser Algorithmus das richtige Ergebnis liefert: <br>  In [5]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT(x), np.fft.fft(x))</code> </pre> <br><br>  Out [5]: <br> <code>True</code> <br> <br>  Vergleichen Sie diesen Algorithmus mit unserer langsamen Version: <br>  -In [6]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit FFT(x) %timeit np.fft.fft(x)</code> </pre> <br><br><pre> <code class="plaintext hljs">10 loops, best of 3: 77.6 ms per loop 100 loops, best of 3: 4.07 ms per loop 10000 loops, best of 3: 24.7 ¬µs per loop</code> </pre> <br>  Unsere Berechnung ist schneller als die direkte Version!  Dar√ºber hinaus ist unser rekursiver Algorithmus asymptotisch <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  : Wir haben die schnelle Fourier-Transformation implementiert. <br><br>  Beachten Sie, dass wir immer noch nicht in der N√§he der Geschwindigkeit des in numpy integrierten FFT-Algorithmus sind, und dies sollte erwartet werden.  Der FFTPACK-Algorithmus hinter <code>fft</code> numpy ist eine Fortran-Implementierung, die jahrelang verfeinert und optimiert wurde.  Dar√ºber hinaus umfasst unsere NumPy-L√∂sung sowohl die Rekursion des Python-Stacks als auch die Zuweisung vieler tempor√§rer Arrays, wodurch sich die Rechenzeit erh√∂ht. <br><br>  Eine gute Strategie zur Beschleunigung des Codes bei der Arbeit mit Python / NumPy besteht darin, sich wiederholende Berechnungen nach M√∂glichkeit zu vektorisieren.  Wir k√∂nnen dies tun - l√∂schen Sie dabei unsere rekursiven Funktionsaufrufe, wodurch unsere Python-FFT noch effizienter wird. <br><br>  <b>Vektorisierte Numpy-Version</b> <br><br>  Bitte beachten Sie, dass in der obigen rekursiven Implementierung von FFT auf der niedrigsten Rekursionsstufe <b>N / 32</b> identische Matrixvektorprodukte ausgef√ºhrt werden.  Die Effektivit√§t unseres Algorithmus wird gewinnen, wenn wir diese Matrixvektorprodukte gleichzeitig als ein einzelnes Matrixmatrixprodukt berechnen.  Auf jeder nachfolgenden Rekursionsstufe f√ºhren wir auch sich wiederholende Operationen aus, die vektorisiert werden k√∂nnen.  NumPy leistet hervorragende Arbeit bei einer solchen Operation, und wir k√∂nnen diese Tatsache nutzen, um diese vektorisierte Version der schnellen Fourier-Transformation zu erstellen: <br><br>  In [7]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT_vectorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A vectorized, non-recursive version of the Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> np.log2(N) % <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># N_min here is equivalent to the stopping condition above, # and should be a power of 2 N_min = min(N, 32) # Perform an O[N^2] DFT on all length-N_min sub-problems at once n = np.arange(N_min) k = n[:, None] M = np.exp(-2j * np.pi * n * k / N_min) X = np.dot(M, x.reshape((N_min, -1))) # build-up each level of the recursive calculation all at once while X.shape[0] &lt; N: X_even = X[:, :X.shape[1] / 2] X_odd = X[:, X.shape[1] / 2:] factor = np.exp(-1j * np.pi * np.arange(X.shape[0]) / X.shape[0])[:, None] X = np.vstack([X_even + factor * X_odd, X_even - factor * X_odd]) return X.ravel()</span></span></code> </pre> <br>  Obwohl der Algorithmus etwas undurchsichtiger ist, handelt es sich lediglich um eine Neuanordnung der in der rekursiven Version verwendeten Operationen, mit einer Ausnahme: Wir verwenden Symmetrie bei der Berechnung der Koeffizienten und erstellen nur die H√§lfte des Arrays.  Wieder best√§tigen wir, dass unsere Funktion das richtige Ergebnis liefert: <br><br>  In [8]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT_vectorized(x), np.fft.fft(x))</code> </pre> <br><br>  Out [8]: <br> <code>True</code> <br> <br>  Da unsere Algorithmen viel effizienter werden, k√∂nnen wir ein gr√∂√üeres Array verwenden, um die Zeit zu vergleichen, sodass <code>DFT_slow</code> √ºbrig <code>DFT_slow</code> : <br>  In [9]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) %timeit FFT(x) %timeit FFT_vectorized(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 72.8 ms per loop 100 loops, best of 3: 4.11 ms per loop 1000 loops, best of 3: 505 ¬µs per loop</code> </pre> <br>  Wir haben unsere Implementierung um eine Gr√∂√üenordnung verbessert!  Jetzt sind wir ungef√§hr zehnmal vom FFTPACK-Benchmark entfernt und verwenden nur ein paar Dutzend Zeilen reines Python + NumPy.  Obwohl dies in Bezug auf die Lesbarkeit immer noch nicht rechnerisch konsistent ist, ist die Python-Version dem FFTPACK-Quellcode, den Sie <a href="">hier</a> anzeigen k√∂nnen, weit √ºberlegen. <br><br>  Wie erreicht FFTPACK diese letzte Beschleunigung?  Im Grunde ist es nur eine Frage der detaillierten Buchhaltung.  FFTPACK verbringt viel Zeit damit, Zwischenberechnungen wiederzuverwenden, die wiederverwendet werden k√∂nnen.  Unsere zerlumpte Version enth√§lt immer noch √ºbersch√ºssige Speicherzuweisung und Kopieren.  In einer einfachen Sprache wie Fortran ist es einfacher, die Speichernutzung zu steuern und zu minimieren.  Dar√ºber hinaus kann der Cooley-Tukey-Algorithmus erweitert werden, um Partitionen mit einer anderen Gr√∂√üe als 2 zu verwenden (was wir hier implementiert haben, ist als Cooley-Tukey-Radix-FFT auf der Basis von 2 bekannt).  Es k√∂nnen auch andere komplexere FFT-Algorithmen verwendet werden, einschlie√ülich grundlegend unterschiedlicher Ans√§tze, die auf Faltungsdaten basieren (siehe beispielsweise den Blueshtein-Algorithmus und den Raider-Algorithmus).  Die Kombination der oben genannten Erweiterungen und Methoden kann selbst bei Arrays, deren Gr√∂√üe keine Zweierpotenz ist, zu sehr schnellen FFTs f√ºhren. <br><br>  Obwohl Funktionen in reinem Python in der Praxis wahrscheinlich nutzlos sind, hoffe ich, dass sie einen Einblick in das geben, was im Hintergrund der FFT-basierten Datenanalyse geschieht.  Als Datenexperten k√∂nnen wir mit der Implementierung der ‚ÄûBlack Box‚Äú grundlegender Tools fertig werden, die von unseren algorithmisch orientierten Kollegen erstellt wurden. Ich bin jedoch der festen √úberzeugung, dass je besser wir die Algorithmen auf niedriger Ebene verstehen, die wir auf unsere Daten anwenden, desto bessere Praktiken wir werden. <br><br>  Dieser Beitrag wurde vollst√§ndig in IPython Notepad geschrieben.  Das vollst√§ndige Notizbuch kann hier heruntergeladen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> statisch angezeigt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br>  Viele m√∂gen bemerken, dass das Material alles andere als neu ist, aber es scheint uns ziemlich relevant zu sein.  Schreiben Sie im Allgemeinen, ob der Artikel n√ºtzlich war.  Warten auf Ihre Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449996/">https://habr.com/ru/post/de449996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449978/index.html">Igor Antarov vom Moskauer Tesla Club k√§mpft mit 20 Mythen √ºber Tesla und Elektroautos</a></li>
<li><a href="../de449984/index.html">Google News und Leo Tolstoy: Visualisierung von Word2Vec-Worteinbettungen mit t-SNE</a></li>
<li><a href="../de449986/index.html">Blockchain: Was sollen wir einen Fall bauen?</a></li>
<li><a href="../de449990/index.html">Wie kann man Latex, Formeln und Habr finden?</a></li>
<li><a href="../de449992/index.html">NodeMCU Simple Driver Model (SDM) Schaufenster: Dynamische Benutzeroberfl√§che</a></li>
<li><a href="../de449998/index.html">FAQ: Was ein reisender Geek √ºber Impfungen wissen muss, bevor er reist</a></li>
<li><a href="../de450000/index.html">(Von rechts nach links (Durch den Spiegel</a></li>
<li><a href="../de450002/index.html">Suchen von Fehlern in LLVM 8 mit PVS-Studio</a></li>
<li><a href="../de450004/index.html">Schneller C / C ++ - Cache, Thread-Sicherheit</a></li>
<li><a href="../de450006/index.html">K√ºhlung des K√ºhler-Rechenzentrums: Welches K√ºhlmittel soll gew√§hlt werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>