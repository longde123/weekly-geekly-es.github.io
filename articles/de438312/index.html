<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úâÔ∏è üë®üèΩ‚Äçüé§ üö¥üèª Netzwerkautomatisierung mit Ansible: Befehlsmodul üòò üë©‚Äçüë©‚Äçüë¶ üë©üèº‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn man von typischen Szenarien der Netzwerkautomatisierung spricht, kann man nicht auf eine Reihe von Befehlsmodulen verzichten. Dank dieser Module ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Netzwerkautomatisierung mit Ansible: Befehlsmodul</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/438312/">  Wenn man von typischen Szenarien der Netzwerkautomatisierung spricht, kann man nicht auf eine Reihe von Befehlsmodulen verzichten.  Dank dieser Module k√∂nnen Sie mit Ansible Befehle auf Netzwerkger√§ten ausf√ºhren, als w√ºrden Sie sie direkt √ºber die Konsole eingeben.  Gleichzeitig rutscht die Ausgabe von Befehlen nicht nur in das Terminalfenster, um in Vergessenheit zu geraten, sondern kann gespeichert und in Zukunft verwendet werden.  Es kann in Variablen geschrieben, zur Verwendung in nachfolgenden Aufgaben analysiert oder f√ºr die Zukunft in Hostvariablen gespeichert werden. <br><br><img src="https://habrastorage.org/webt/ga/bs/bh/gabsbhxuxhvjzjvvizswbdkkq2o.png" width="100%"><br><br>  Das Ziel dieses Beitrags ist es zu zeigen, dass sich wiederholende Netzwerkverwaltungsaufgaben automatisiert werden k√∂nnen und dass Ansible nicht nur das Verwalten von Konfigurationen erm√∂glicht, sondern auch dazu beitr√§gt, Routine loszuwerden und Zeit zu sparen. <br><a name="habracut"></a><br>  Lassen Sie uns die grundlegenden M√∂glichkeiten zur Verwendung der Netzwerkbefehlsmodule analysieren, einschlie√ülich des Speicherns der Ausgabe von Befehlen mithilfe des Registerparameters.  Wir betrachten auch die Skalierung auf mehrere Netzwerkger√§te mithilfe von Hostvars und die Organisation der bedingten Ausf√ºhrung mithilfe des Parameters wait_for und dreier anderer verwandter Parameter: Intervall, Wiederholungsversuche und √úbereinstimmung. <br><br>  Verschiedene Netzwerkplattformen verf√ºgen √ºber eigene Befehlsmodule, die alle auf der Erweiterungsstufe Red Hat Ansible Engine Networking Add-on unterst√ºtzt werden: <br><br><table><tbody><tr><td>  <b>Netzwerkplattformen</b> </td><td>  <b>Module * os_command</b> </td></tr><tr><td>  Arista eos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eos_command</a> </td></tr><tr><td>  Cisco IOS / IOS-XE </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ios_command</a> </td></tr><tr><td>  Cisco IOS-XR </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iosxr_command</a> </td></tr><tr><td>  Cisco NX-OS </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nxos_command</a> </td></tr><tr><td>  Wacholder Junos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">junos_command</a> </td></tr><tr><td>  Vyos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vyos_command</a> </td></tr></tbody></table><br><h3>  Grundlagen des Befehlsmoduls </h3><br>  Stellen Sie sich ein Playbook vor, in dem der Befehl show version einfach mit dem Modul eos_command ausgef√ºhrt wird: <br><br><pre><code class="plaintext hljs">--- - name: COMMAND MODULE PLAYBOOK hosts: eos connection: network_cli tasks: - name: EXECUTE ARISTA EOS COMMAND eos_command: commands: show version register: output - name: PRINT OUT THE OUTPUT VARIABLE debug: var: output</code> </pre> <br>  Hier haben wir zwei Aufgaben und die erste verwendet das Modul eos_command mit einem einzelnen Befehlsparameter.  Da wir nur einen Befehl ausf√ºhren - show version - kann dieser in derselben Zeile wie der Befehlsparameter selbst angegeben werden.  Wenn es zwei oder mehr Teams gibt, muss jedes von ihnen nach den Befehlen in einer separaten Zeile platziert werden :.  In diesem Beispiel verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schl√ºsselwort register</a> , um die Ausgabe des Befehls show version zu speichern.  Der Registerparameter (kann in jeder Ansible-Aufgabe verwendet werden) legt die Variable fest, in der die Ausgabe unserer Aufgabe gespeichert wird, damit sie sp√§ter verwendet werden kann.  In unserem Beispiel wird diese Variable als Ausgabe bezeichnet. <br><br>  Die zweite Aufgabe in unserem Beispiel verwendet das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debug-Modul</a> , um den Inhalt der neu erstellten Ausgabevariablen anzuzeigen.  Das hei√üt, dies sind die gleichen Daten, die Sie auf der Befehlszeilenschnittstelle des EOS-Ger√§ts sehen w√ºrden, wenn Sie dort "show version" eingeben w√ºrden.  Der Unterschied besteht darin, dass unser Playbook sie in dem Terminalfenster anzeigt, in dem Sie es starten.  Wie Sie sehen k√∂nnen, erleichtert das Debug-Modul das √úberpr√ºfen von Ansible-Variablen. <br><br>  Hier ist die Ausgabe unseres Spielbuchs: <br><br><pre> <code class="plaintext hljs">PLAY [eos] ************************************************************************* TASK [execute Arista eos command] ************************************************** ok: [eos] TASK [print out the output variable] *********************************************** ok: [eos] =&gt; { "output": { "changed": false, "failed": false, "stdout": [ "Arista vEOS\nHardware version: \nSerial number: \nSystem MAC address: 0800.27ec.005e\n\nSoftware image version: 4.20.1F\nArchitecture: i386\nInternal build version: 4.20.1F-6820520.4201F\nInternal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91\n\nUptime: 1 day, 3 hours and 23 minutes\nTotal memory: 2017324 kB\nFree memory: 1111848 kB" ], "stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 3 hours and 23 minutes", "Total memory: 2017324 kB", "Free memory: 1111848 kB" ] ] } } PLAY RECAP ************************************************************************* eos : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  Wie aus dem Screenshot hervorgeht, haben unsere beiden Aufgaben erfolgreich geklappt.  Da die erste Aufgabe die Standarddetailstufe von Nachrichten verwendet, hei√üt es lediglich, dass der eos-Host die Aufgabe mit dem Ergebnis ok abgeschlossen hat, wodurch der Erfolg der Ausf√ºhrung gr√ºn hervorgehoben wird.  Die zweite Aufgabe mit dem Debug-Modul gibt die Ausgabe des ausgef√ºhrten Befehls zur√ºck und zeigt dieselben Informationen in zwei Formaten an: <br><br><ul><li>  stdout </li><li>  stdout_lines </li></ul><br>  Der Abschnitt stdout zeigt dasselbe, was Sie in der Befehlszeilenschnittstelle des Ger√§ts sehen w√ºrden, jedoch in Form einer langen Zeile.  Der Abschnitt stdout_lines unterteilt diese Ausgabe in Zeilen, damit sie bequem gelesen werden kann.  Jedes Element in dieser Liste ist eine separate Zeile in der Ausgabe des Befehls. <br><br>  Vergleichen Sie die Ausgabe des Befehls auf dem Ger√§t und in Ansible: <br><br><table><tbody><tr><td>  <b>Teamleistung in Arista EOS</b> </td><td>  <b>stdout_lines in Ansible</b> </td></tr><tr><td>  eos&gt; show vers <br>  Arista vEOS <br>  Hardwareversion: <br>  Seriennummer: <br>  System-MAC-Adresse: 0800.27ec.005e <br><br>  Software-Image-Version: 4.20.1F <br>  Architektur: i386 <br>  Interne Build-Version: 4.20.1F-6820520.4201F <br>  Interne Build-ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91 <br><br>  Betriebszeit: 1 Tag, 3 Stunden und 56 Minuten <br>  Gesamtspeicher: 2017324 kB <br>  Freier Speicher: 1116624 kB </td><td>  "Stdout_lines": [ <br>  [ <br>  "Arista vEOS", <br>  "Hardwareversion:", <br>  "Seriennummer:", <br>  "System-MAC-Adresse: 0800.27ec.005e", <br>  "", <br>  "Software-Image-Version: 4.20.1F", <br>  "Architektur: i386", <br>  "Interne Build-Version: <br>  4.20.1F-6820520.4201F ", <br>  "Interne Build-ID: <br>  790a11e8-5aaf-4be7-a11a-e61795d05b91 ", <br>  "", <br>  "Betriebszeit: 1 Tag, 3 Stunden und 23 Minuten", <br>  "Gesamtspeicher: 2017324 kB", <br>  Freier Speicher: 1111848 kB <br>  ]] </td></tr></tbody></table><br>  Wenn Sie mit JSON und YAML vertraut sind, haben Sie wahrscheinlich bereits auf eine Kuriosit√§t geachtet: stdout_lines beginnt mit zwei √∂ffnenden Klammern: <br><br><pre> <code class="plaintext hljs">"stdout_lines": [ [</code> </pre><br>  Zwei √∂ffnende Klammern geben an, dass stdout_lines tats√§chlich eine Liste von Zeilenlisten zur√ºckgibt.  Wenn Sie unsere Debug-Aufgabe geringf√ºgig √§ndern, k√∂nnen Sie mit diesem Chip die Ergebnisse des Befehls selektiv anzeigen.  Da unsere Liste nur eine Liste von Zeilen enth√§lt, wird diese Liste als Null bezeichnet (tats√§chlich ist es die erste, aber die Anzahl geht von Grund auf neu).  Lassen Sie uns nun sehen, wie Sie eine separate Zeile daraus extrahieren, z. B. die System-MAC-Adresse.  In der Ausgabe des Befehls ist diese Zeile die vierte in Folge, aber da wir von Grund auf neu z√§hlen, ben√∂tigen wir letztendlich Zeile 3 aus Liste 0, mit anderen Worten: output.stdout_lines [0] [3]. <br><br><pre> <code class="plaintext hljs"> - name: print out a single line of the output variable debug: var: output.stdout_lines[0][3]   debug-   : TASK [print out a single line of the output variable] ****************************** ok: [eos] =&gt; { "output.stdout_lines[0][3]": "System MAC address: 0800.27ec.005e" }</code> </pre><br>  Was ist der Sinn der Listennummerierung und warum wird sie √ºberhaupt ben√∂tigt?  Tatsache ist, dass Sie innerhalb derselben Aufgabe beispielsweise mehrere Teams leiten k√∂nnen (hier haben wir drei Teams): <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show version - show ip int br - show int status register: output - name: print out command debug: var: output.stdout_lines</code> </pre><br>  So sieht die Ausgabe aus: <br><br><pre> <code class="plaintext hljs"> "output.stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 4 hours and 20 minutes", "Total memory: 2017324 kB", "Free memory: 1111104 kB" ], [ "Interface IP Address Status Protocol MTU", "Ethernet1 172.16.1.1/24 up up 1500", "Management1 192.168.2.10/24 up up 1500" ], [ "Port Name Status Vlan Duplex Speed Type Flags", "Et1 connected routed full unconf EbraTestPhyPort ", "Et2 connected 1 full unconf EbraTestPhyPort ", "Et3 connected 1 full unconf EbraTestPhyPort ", "Ma1 connected routed a-full a-1G 10/100/1000" ] ]</code> </pre><br>  Hier ist Listennummer Null die Ausgabe des Befehls show version, Listennummer eins ist die Ausgabe von show ip int br, Listennummer zwei ist die Ausgabe von show int status.  Das hei√üt, die Listennummer wird durch die Reihenfolge bestimmt, in der die Befehle ausgef√ºhrt werden. <br><br><table><tbody><tr><td>  <b>Arista EOS Teams</b> </td><td>  <b>√úbereinstimmende Ausgabelisten</b> </td></tr><tr><td>  Version anzeigen </td><td>  output.stdout_lines [0] </td></tr><tr><td>  show ip int br </td><td>  output.stdout_lines [1] </td></tr><tr><td>  int-Status anzeigen </td><td>  output.stdout_lines [2] </td></tr></tbody></table><br><h3>  Skalierung des Befehlsmoduls: Hostvariablen </h3><br>  Und was passiert, wenn Sie das Playbook auf mehreren Ger√§ten gleichzeitig ausf√ºhren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9g/e0/ap/9ge0apzkt1vioj3gtttw2eivili.png"></div><br><br>  Um eindeutig zu sein, wird die Ausgabevariable als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hostvariable</a> f√ºr jeden Host im Inventar gespeichert.  Wenn wir drei Schalter haben und unser Playbook darauf ausf√ºhren, erhalten wir die Ausgabevariable f√ºr jeden einzelnen Host.  Angenommen, wir ben√∂tigen die IP-Adresse aus dem Befehl show ip int br f√ºr den Ethernet1-Port auf switch03.  Da show ip int br der zweite Befehl ist, der als Teil der Task ausgef√ºhrt wird, und die Ethernet1-Daten in der zweiten Zeile ihrer Ausgabe enthalten sind, m√ºssen wir stdout_lines [1] [1] schreiben.  Um auf die Variablen eines bestimmten Hosts zuzugreifen, verwenden wir das Schl√ºsselwort hostvars und suchen nach dem Host, den wir ben√∂tigen, anhand des Namens. <br><br>  So geht's: <br><br><pre> <code class="plaintext hljs"> - name: debug hostvar debug: var: hostvars["switch03"].output.stdout_lines[1][1]</code> </pre><br>  Daher enth√§lt die Ausgabe genau das, was wir brauchen: <br><br><pre> <code class="plaintext hljs">TASK [debug hostvar] *************************************************************** ok: [switch03] =&gt; { "hostvars[\"switch03\"].output.stdout_lines[1][1]": "Ethernet1 172.16.1.3/24 up up 1500" }</code> </pre><br>  Standardm√§√üig verwendet die Aufgabe die Variablen des aktuellen Hosts. Mit hostvars k√∂nnen Sie jedoch direkt auf die Variablen eines anderen Hosts zugreifen. <br><br><h3>  Bedingungen in Aufgaben mit Befehlsmodulen: Parameter wait_for </h3><br>  Mit dem Parameter wait_for k√∂nnen Sie unmittelbar nach Ausf√ºhrung des Befehls eine Bedingungspr√ºfung durchf√ºhren.  Damit die Aufgabe beispielsweise nur dann als erfolgreich abgeschlossen gilt, wenn die Ausgabe des Statuspr√ºfbefehls bestimmten Text enth√§lt.  Standardm√§√üig wird der Parameter wait_for nicht verwendet, sodass die Aufgabe wie in den obigen Beispielen nur einmal ausgef√ºhrt wird.  Wenn Sie es jedoch explizit festlegen, wird die Aufgabe neu gestartet, bis die Bedingung erf√ºllt ist oder die Anzahl der Versuche √ºberschritten wird (standardm√§√üig sind es 10).  Wenn Sie die Befehlsprotokollierung aktivieren, k√∂nnen Sie im folgenden Playbook sehen (das speziell geschrieben wurde, damit die Bedingung niemals erf√ºllt wird), dass alles einfach so abl√§uft. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show int status wait_for: - result[0] contains DURHAM</code> </pre><br>  In diesem Playbook wird der Befehl show int status zehnmal ausgef√ºhrt, da seine Ausgabe niemals eine DURHAM-Zeile enth√§lt. <br><br>  Sie k√∂nnen dies mit dem Befehl show logging √ºberpr√ºfen: <br><br><pre> <code class="plaintext hljs">Mar 24 20:33:52 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=17 start_time=1521923632.5 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:53 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=18 start_time=1521923633.71 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:54 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=19 start_time=1521923634.81 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:55 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=20 start_time=1521923635.92 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:56 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=21 start_time=1521923636.99 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:58 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=22 start_time=1521923638.07 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:59 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=23 start_time=1521923639.22 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:00 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=24 start_time=1521923640.32 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:01 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=25 start_time=1521923641.4 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:02 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=26 start_time=1521923642.47 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status</code> </pre><br>  Schauen wir uns nun ein Beispiel f√ºr ein echtes Playbook an, in dem alles so konfiguriert ist, dass eine OSPF-Nachbarschaft (Nachbarschaft) mit einem anderen Ger√§t als dem Befehl ip ospf area erstellt wird.  Wir wenden diesen Befehl an und √ºberpr√ºfen dann mit dem Parameter wait_for, ob das Wort FULL in der Ausgabe vorhanden ist: Wenn es vorhanden ist, wurde die Nachbarschaft erfolgreich eingerichtet.  Wenn in 10 Versuchen nicht FULL angezeigt wird, schl√§gt die Aufgabe fehl. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: turn on OSPF for interface Ethernet1 eos_config: lines: - ip ospf area 0.0.0.0 parents: interface Ethernet1 - name: execute Arista eos command eos_command: commands: - show ip ospf neigh wait_for: - result[0] contains FULL</code> </pre><br>  F√ºhren Sie dieses Playbook mit dem Befehl ansible-playbook aus: <br><br><pre> <code class="plaintext hljs">‚ûú ansible-playbook ospf.yml PLAY [eos] ********************************************************************************************* TASK [turn on OSPF for interface Ethernet1] ******************************************************* changed: [eos] TASK [execute Arista eos command] **************************************************************** ok: [eos] PLAY RECAP ****************************************************************************************** eos : ok=2 changed=1 unreachable=0 failed=0</code> </pre><br>  Wir schauen auf die Kommandozeile und sehen, dass das Playbook erfolgreich war: <br><br><pre> <code class="plaintext hljs">eos#show ip ospf neigh Neighbor ID VRF Pri State Dead Time Address Interface 2.2.2.2 default 1 FULL/DR 00:00:33 172.16.1.2 Ethernet1</code> </pre><br>  Zus√§tzlich zu enth√§lt k√∂nnen Sie die folgenden Vergleichsoperatoren verwenden: <br><br><ul><li>  Gleichung: - ist gleich </li><li>  neq: - ungleich </li><li>  gt: - mehr </li><li>  ge: - gr√∂√üer oder gleich </li><li>  lt: - weniger </li><li>  le: - kleiner oder gleich </li></ul><br>  Zus√§tzlich k√∂nnen Sie zusammen mit wait_for drei zus√§tzliche Parameter verwenden (ausf√ºhrlich in der Dokumentation zu den Modulen beschrieben): <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Beschreibung</b> </td></tr><tr><td>  Intervall </td><td>  Zeit zwischen Wiederholungen eines Teams. </td></tr><tr><td>  Wiederholungen </td><td>  Max  Die Anzahl der Wiederholungen, bevor die Aufgabe mit einem Fehler abgeschlossen wird oder die Bedingung erf√ºllt ist. </td></tr><tr><td>  Spiel </td><td>  Das Zusammentreffen aller Bedingungen oder mindestens einer. </td></tr></tbody></table><br>  Lassen Sie uns n√§her auf den √úbereinstimmungsparameter eingehen: <br><br><pre> <code class="plaintext hljs"> - name: execute Arista eos command eos_command: commands: - show ip ospf neigh match: any wait_for: - result[0] contains FULL - result[0] contains 172.16.1.2</code> </pre><br>  Wenn match: any angegeben ist, wird die Aufgabe als erfolgreich angesehen, wenn das Ergebnis FULL oder 172.16.1.2 enth√§lt.  Wenn match: all angegeben ist, muss das Ergebnis sowohl FULL als auch 172.16.1.2 enthalten.  Standardm√§√üig wird match: all verwendet. Wenn Sie mehrere Bedingungen vorschreiben, m√∂chten Sie h√∂chstwahrscheinlich, dass alle und nicht mindestens eine ausgef√ºhrt werden. <br><br>  Wann kann passen: welche n√ºtzlich sein?  Angenommen, Sie m√ºssen √ºberpr√ºfen, ob das Rechenzentrum √ºber eine bidirektionale Verbindung zum Internet verf√ºgt.  Das Rechenzentrum ist mit f√ºnf verschiedenen Internetanbietern verbunden, von denen jeder √ºber eine eigene BGP-Verbindung verf√ºgt.  Ein Playbook kann alle diese f√ºnf Verbindungen √ºberpr√ºfen. Wenn mindestens eine davon funktioniert und nicht alle f√ºnf, melden Sie, dass alles in Ordnung ist.  Denken Sie daran, dass jedes ein logisches ODER ist und alles ein logisches UND ist. <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Beschreibung</b> </td></tr><tr><td>  √úbereinstimmung: beliebig </td><td>  Logisches "ODER" <br>  Es ist mindestens eine Bedingung erforderlich </td></tr><tr><td>  Spiel: alle </td><td>  Logisches "Und" <br>  Alle Bedingungen erforderlich </td></tr></tbody></table><br><h3>  Negative Bedingungen: Aufbau der inversen Logik </h3><br>  Manchmal ist es nicht wichtig, was in der Schlussfolgerung steht, sondern was nicht.  Hier ist es nat√ºrlich immer verlockend, den neq-Vergleichsoperator zu verwenden, aber f√ºr einige Szenarien mit negativen Bedingungen gibt es bessere Optionen.  Wenn Sie beispielsweise die include-Anweisung invertieren m√ºssen (vom Typ "Die Ausgabe des Befehls sollte solche und solche nicht enthalten"), k√∂nnen Sie das Schl√ºsselwort register verwenden, um die Ausgabe zu speichern und sie dann in der n√§chsten Aufgabe mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausdruck when zu verarbeiten</a> .  Wenn Sie beispielsweise das Playbook stoppen m√ºssen, wenn die Bedingungen nicht erf√ºllt sind, verwenden Sie einfach die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fail-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assert-</a> Module, um den Fehler spezifisch zu beenden.  Der Vergleichsoperator neq ist nur dann n√ºtzlich, wenn Sie den genauen Wert aus der Ausgabe extrahieren k√∂nnen (z. B. aus einem Schl√ºssel-Wert-Paar oder aus JSON) und nicht nur aus einer Zeichenfolge oder einer Liste von Zeichenfolgen.  Andernfalls wird ein zeichenweiser Vergleich der Zeichenfolgen durchgef√ºhrt. <br><br><h3>  Was weiter </h3><br>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zum Arbeiten mit der Ausgabe von Befehlen in Netzwerkmodulen.  Es enth√§lt n√ºtzliche Beispiele f√ºr die Verwendung von ge, le und anderen Bedingungen bei der Arbeit mit der Ausgabe im JSON-Format auf bestimmten Netzwerkplattformen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438312/">https://habr.com/ru/post/de438312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438298/index.html">Warum unterrichten, wenn das Entwickeln rentabler ist? Gespr√§ch mit GeekBrains</a></li>
<li><a href="../de438302/index.html">Die erstaunliche Kreativit√§t der digitalen Evolution</a></li>
<li><a href="../de438304/index.html">Vergabe von Unterauftr√§gen? Cool du schl√§gst</a></li>
<li><a href="../de438306/index.html">Strahlung: Wochentags radiochemisches Labor</a></li>
<li><a href="../de438310/index.html">Instagram verwendet maschinelles Lernen, um gef√§lschte Follower zu entfernen</a></li>
<li><a href="../de438314/index.html">1. Check Point Maestro Hyperscale-Netzwerksicherheit - eine neue skalierbare Sicherheitsplattform</a></li>
<li><a href="../de438316/index.html">Grundlagen des signierten Distanzfelds in 2D</a></li>
<li><a href="../de438318/index.html">Wie man die asynchrone / wartende Syntax beherrscht: ein echtes Beispiel</a></li>
<li><a href="../de438320/index.html">Kindern das Programmieren beibringen</a></li>
<li><a href="../de438322/index.html">VSaaS 2025: CCTV-Technologie der Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>