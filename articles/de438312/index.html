<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✉️ 👨🏽‍🎤 🚴🏻 Netzwerkautomatisierung mit Ansible: Befehlsmodul 😘 👩‍👩‍👦 👩🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn man von typischen Szenarien der Netzwerkautomatisierung spricht, kann man nicht auf eine Reihe von Befehlsmodulen verzichten. Dank dieser Module ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Netzwerkautomatisierung mit Ansible: Befehlsmodul</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/438312/">  Wenn man von typischen Szenarien der Netzwerkautomatisierung spricht, kann man nicht auf eine Reihe von Befehlsmodulen verzichten.  Dank dieser Module können Sie mit Ansible Befehle auf Netzwerkgeräten ausführen, als würden Sie sie direkt über die Konsole eingeben.  Gleichzeitig rutscht die Ausgabe von Befehlen nicht nur in das Terminalfenster, um in Vergessenheit zu geraten, sondern kann gespeichert und in Zukunft verwendet werden.  Es kann in Variablen geschrieben, zur Verwendung in nachfolgenden Aufgaben analysiert oder für die Zukunft in Hostvariablen gespeichert werden. <br><br><img src="https://habrastorage.org/webt/ga/bs/bh/gabsbhxuxhvjzjvvizswbdkkq2o.png" width="100%"><br><br>  Das Ziel dieses Beitrags ist es zu zeigen, dass sich wiederholende Netzwerkverwaltungsaufgaben automatisiert werden können und dass Ansible nicht nur das Verwalten von Konfigurationen ermöglicht, sondern auch dazu beiträgt, Routine loszuwerden und Zeit zu sparen. <br><a name="habracut"></a><br>  Lassen Sie uns die grundlegenden Möglichkeiten zur Verwendung der Netzwerkbefehlsmodule analysieren, einschließlich des Speicherns der Ausgabe von Befehlen mithilfe des Registerparameters.  Wir betrachten auch die Skalierung auf mehrere Netzwerkgeräte mithilfe von Hostvars und die Organisation der bedingten Ausführung mithilfe des Parameters wait_for und dreier anderer verwandter Parameter: Intervall, Wiederholungsversuche und Übereinstimmung. <br><br>  Verschiedene Netzwerkplattformen verfügen über eigene Befehlsmodule, die alle auf der Erweiterungsstufe Red Hat Ansible Engine Networking Add-on unterstützt werden: <br><br><table><tbody><tr><td>  <b>Netzwerkplattformen</b> </td><td>  <b>Module * os_command</b> </td></tr><tr><td>  Arista eos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eos_command</a> </td></tr><tr><td>  Cisco IOS / IOS-XE </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ios_command</a> </td></tr><tr><td>  Cisco IOS-XR </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iosxr_command</a> </td></tr><tr><td>  Cisco NX-OS </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nxos_command</a> </td></tr><tr><td>  Wacholder Junos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">junos_command</a> </td></tr><tr><td>  Vyos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vyos_command</a> </td></tr></tbody></table><br><h3>  Grundlagen des Befehlsmoduls </h3><br>  Stellen Sie sich ein Playbook vor, in dem der Befehl show version einfach mit dem Modul eos_command ausgeführt wird: <br><br><pre><code class="plaintext hljs">--- - name: COMMAND MODULE PLAYBOOK hosts: eos connection: network_cli tasks: - name: EXECUTE ARISTA EOS COMMAND eos_command: commands: show version register: output - name: PRINT OUT THE OUTPUT VARIABLE debug: var: output</code> </pre> <br>  Hier haben wir zwei Aufgaben und die erste verwendet das Modul eos_command mit einem einzelnen Befehlsparameter.  Da wir nur einen Befehl ausführen - show version - kann dieser in derselben Zeile wie der Befehlsparameter selbst angegeben werden.  Wenn es zwei oder mehr Teams gibt, muss jedes von ihnen nach den Befehlen in einer separaten Zeile platziert werden :.  In diesem Beispiel verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlüsselwort register</a> , um die Ausgabe des Befehls show version zu speichern.  Der Registerparameter (kann in jeder Ansible-Aufgabe verwendet werden) legt die Variable fest, in der die Ausgabe unserer Aufgabe gespeichert wird, damit sie später verwendet werden kann.  In unserem Beispiel wird diese Variable als Ausgabe bezeichnet. <br><br>  Die zweite Aufgabe in unserem Beispiel verwendet das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debug-Modul</a> , um den Inhalt der neu erstellten Ausgabevariablen anzuzeigen.  Das heißt, dies sind die gleichen Daten, die Sie auf der Befehlszeilenschnittstelle des EOS-Geräts sehen würden, wenn Sie dort "show version" eingeben würden.  Der Unterschied besteht darin, dass unser Playbook sie in dem Terminalfenster anzeigt, in dem Sie es starten.  Wie Sie sehen können, erleichtert das Debug-Modul das Überprüfen von Ansible-Variablen. <br><br>  Hier ist die Ausgabe unseres Spielbuchs: <br><br><pre> <code class="plaintext hljs">PLAY [eos] ************************************************************************* TASK [execute Arista eos command] ************************************************** ok: [eos] TASK [print out the output variable] *********************************************** ok: [eos] =&gt; { "output": { "changed": false, "failed": false, "stdout": [ "Arista vEOS\nHardware version: \nSerial number: \nSystem MAC address: 0800.27ec.005e\n\nSoftware image version: 4.20.1F\nArchitecture: i386\nInternal build version: 4.20.1F-6820520.4201F\nInternal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91\n\nUptime: 1 day, 3 hours and 23 minutes\nTotal memory: 2017324 kB\nFree memory: 1111848 kB" ], "stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 3 hours and 23 minutes", "Total memory: 2017324 kB", "Free memory: 1111848 kB" ] ] } } PLAY RECAP ************************************************************************* eos : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  Wie aus dem Screenshot hervorgeht, haben unsere beiden Aufgaben erfolgreich geklappt.  Da die erste Aufgabe die Standarddetailstufe von Nachrichten verwendet, heißt es lediglich, dass der eos-Host die Aufgabe mit dem Ergebnis ok abgeschlossen hat, wodurch der Erfolg der Ausführung grün hervorgehoben wird.  Die zweite Aufgabe mit dem Debug-Modul gibt die Ausgabe des ausgeführten Befehls zurück und zeigt dieselben Informationen in zwei Formaten an: <br><br><ul><li>  stdout </li><li>  stdout_lines </li></ul><br>  Der Abschnitt stdout zeigt dasselbe, was Sie in der Befehlszeilenschnittstelle des Geräts sehen würden, jedoch in Form einer langen Zeile.  Der Abschnitt stdout_lines unterteilt diese Ausgabe in Zeilen, damit sie bequem gelesen werden kann.  Jedes Element in dieser Liste ist eine separate Zeile in der Ausgabe des Befehls. <br><br>  Vergleichen Sie die Ausgabe des Befehls auf dem Gerät und in Ansible: <br><br><table><tbody><tr><td>  <b>Teamleistung in Arista EOS</b> </td><td>  <b>stdout_lines in Ansible</b> </td></tr><tr><td>  eos&gt; show vers <br>  Arista vEOS <br>  Hardwareversion: <br>  Seriennummer: <br>  System-MAC-Adresse: 0800.27ec.005e <br><br>  Software-Image-Version: 4.20.1F <br>  Architektur: i386 <br>  Interne Build-Version: 4.20.1F-6820520.4201F <br>  Interne Build-ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91 <br><br>  Betriebszeit: 1 Tag, 3 Stunden und 56 Minuten <br>  Gesamtspeicher: 2017324 kB <br>  Freier Speicher: 1116624 kB </td><td>  "Stdout_lines": [ <br>  [ <br>  "Arista vEOS", <br>  "Hardwareversion:", <br>  "Seriennummer:", <br>  "System-MAC-Adresse: 0800.27ec.005e", <br>  "", <br>  "Software-Image-Version: 4.20.1F", <br>  "Architektur: i386", <br>  "Interne Build-Version: <br>  4.20.1F-6820520.4201F ", <br>  "Interne Build-ID: <br>  790a11e8-5aaf-4be7-a11a-e61795d05b91 ", <br>  "", <br>  "Betriebszeit: 1 Tag, 3 Stunden und 23 Minuten", <br>  "Gesamtspeicher: 2017324 kB", <br>  Freier Speicher: 1111848 kB <br>  ]] </td></tr></tbody></table><br>  Wenn Sie mit JSON und YAML vertraut sind, haben Sie wahrscheinlich bereits auf eine Kuriosität geachtet: stdout_lines beginnt mit zwei öffnenden Klammern: <br><br><pre> <code class="plaintext hljs">"stdout_lines": [ [</code> </pre><br>  Zwei öffnende Klammern geben an, dass stdout_lines tatsächlich eine Liste von Zeilenlisten zurückgibt.  Wenn Sie unsere Debug-Aufgabe geringfügig ändern, können Sie mit diesem Chip die Ergebnisse des Befehls selektiv anzeigen.  Da unsere Liste nur eine Liste von Zeilen enthält, wird diese Liste als Null bezeichnet (tatsächlich ist es die erste, aber die Anzahl geht von Grund auf neu).  Lassen Sie uns nun sehen, wie Sie eine separate Zeile daraus extrahieren, z. B. die System-MAC-Adresse.  In der Ausgabe des Befehls ist diese Zeile die vierte in Folge, aber da wir von Grund auf neu zählen, benötigen wir letztendlich Zeile 3 aus Liste 0, mit anderen Worten: output.stdout_lines [0] [3]. <br><br><pre> <code class="plaintext hljs"> - name: print out a single line of the output variable debug: var: output.stdout_lines[0][3]   debug-   : TASK [print out a single line of the output variable] ****************************** ok: [eos] =&gt; { "output.stdout_lines[0][3]": "System MAC address: 0800.27ec.005e" }</code> </pre><br>  Was ist der Sinn der Listennummerierung und warum wird sie überhaupt benötigt?  Tatsache ist, dass Sie innerhalb derselben Aufgabe beispielsweise mehrere Teams leiten können (hier haben wir drei Teams): <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show version - show ip int br - show int status register: output - name: print out command debug: var: output.stdout_lines</code> </pre><br>  So sieht die Ausgabe aus: <br><br><pre> <code class="plaintext hljs"> "output.stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 4 hours and 20 minutes", "Total memory: 2017324 kB", "Free memory: 1111104 kB" ], [ "Interface IP Address Status Protocol MTU", "Ethernet1 172.16.1.1/24 up up 1500", "Management1 192.168.2.10/24 up up 1500" ], [ "Port Name Status Vlan Duplex Speed Type Flags", "Et1 connected routed full unconf EbraTestPhyPort ", "Et2 connected 1 full unconf EbraTestPhyPort ", "Et3 connected 1 full unconf EbraTestPhyPort ", "Ma1 connected routed a-full a-1G 10/100/1000" ] ]</code> </pre><br>  Hier ist Listennummer Null die Ausgabe des Befehls show version, Listennummer eins ist die Ausgabe von show ip int br, Listennummer zwei ist die Ausgabe von show int status.  Das heißt, die Listennummer wird durch die Reihenfolge bestimmt, in der die Befehle ausgeführt werden. <br><br><table><tbody><tr><td>  <b>Arista EOS Teams</b> </td><td>  <b>Übereinstimmende Ausgabelisten</b> </td></tr><tr><td>  Version anzeigen </td><td>  output.stdout_lines [0] </td></tr><tr><td>  show ip int br </td><td>  output.stdout_lines [1] </td></tr><tr><td>  int-Status anzeigen </td><td>  output.stdout_lines [2] </td></tr></tbody></table><br><h3>  Skalierung des Befehlsmoduls: Hostvariablen </h3><br>  Und was passiert, wenn Sie das Playbook auf mehreren Geräten gleichzeitig ausführen? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9g/e0/ap/9ge0apzkt1vioj3gtttw2eivili.png"></div><br><br>  Um eindeutig zu sein, wird die Ausgabevariable als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hostvariable</a> für jeden Host im Inventar gespeichert.  Wenn wir drei Schalter haben und unser Playbook darauf ausführen, erhalten wir die Ausgabevariable für jeden einzelnen Host.  Angenommen, wir benötigen die IP-Adresse aus dem Befehl show ip int br für den Ethernet1-Port auf switch03.  Da show ip int br der zweite Befehl ist, der als Teil der Task ausgeführt wird, und die Ethernet1-Daten in der zweiten Zeile ihrer Ausgabe enthalten sind, müssen wir stdout_lines [1] [1] schreiben.  Um auf die Variablen eines bestimmten Hosts zuzugreifen, verwenden wir das Schlüsselwort hostvars und suchen nach dem Host, den wir benötigen, anhand des Namens. <br><br>  So geht's: <br><br><pre> <code class="plaintext hljs"> - name: debug hostvar debug: var: hostvars["switch03"].output.stdout_lines[1][1]</code> </pre><br>  Daher enthält die Ausgabe genau das, was wir brauchen: <br><br><pre> <code class="plaintext hljs">TASK [debug hostvar] *************************************************************** ok: [switch03] =&gt; { "hostvars[\"switch03\"].output.stdout_lines[1][1]": "Ethernet1 172.16.1.3/24 up up 1500" }</code> </pre><br>  Standardmäßig verwendet die Aufgabe die Variablen des aktuellen Hosts. Mit hostvars können Sie jedoch direkt auf die Variablen eines anderen Hosts zugreifen. <br><br><h3>  Bedingungen in Aufgaben mit Befehlsmodulen: Parameter wait_for </h3><br>  Mit dem Parameter wait_for können Sie unmittelbar nach Ausführung des Befehls eine Bedingungsprüfung durchführen.  Damit die Aufgabe beispielsweise nur dann als erfolgreich abgeschlossen gilt, wenn die Ausgabe des Statusprüfbefehls bestimmten Text enthält.  Standardmäßig wird der Parameter wait_for nicht verwendet, sodass die Aufgabe wie in den obigen Beispielen nur einmal ausgeführt wird.  Wenn Sie es jedoch explizit festlegen, wird die Aufgabe neu gestartet, bis die Bedingung erfüllt ist oder die Anzahl der Versuche überschritten wird (standardmäßig sind es 10).  Wenn Sie die Befehlsprotokollierung aktivieren, können Sie im folgenden Playbook sehen (das speziell geschrieben wurde, damit die Bedingung niemals erfüllt wird), dass alles einfach so abläuft. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show int status wait_for: - result[0] contains DURHAM</code> </pre><br>  In diesem Playbook wird der Befehl show int status zehnmal ausgeführt, da seine Ausgabe niemals eine DURHAM-Zeile enthält. <br><br>  Sie können dies mit dem Befehl show logging überprüfen: <br><br><pre> <code class="plaintext hljs">Mar 24 20:33:52 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=17 start_time=1521923632.5 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:53 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=18 start_time=1521923633.71 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:54 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=19 start_time=1521923634.81 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:55 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=20 start_time=1521923635.92 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:56 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=21 start_time=1521923636.99 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:58 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=22 start_time=1521923638.07 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:59 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=23 start_time=1521923639.22 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:00 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=24 start_time=1521923640.32 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:01 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=25 start_time=1521923641.4 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:02 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=26 start_time=1521923642.47 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status</code> </pre><br>  Schauen wir uns nun ein Beispiel für ein echtes Playbook an, in dem alles so konfiguriert ist, dass eine OSPF-Nachbarschaft (Nachbarschaft) mit einem anderen Gerät als dem Befehl ip ospf area erstellt wird.  Wir wenden diesen Befehl an und überprüfen dann mit dem Parameter wait_for, ob das Wort FULL in der Ausgabe vorhanden ist: Wenn es vorhanden ist, wurde die Nachbarschaft erfolgreich eingerichtet.  Wenn in 10 Versuchen nicht FULL angezeigt wird, schlägt die Aufgabe fehl. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: turn on OSPF for interface Ethernet1 eos_config: lines: - ip ospf area 0.0.0.0 parents: interface Ethernet1 - name: execute Arista eos command eos_command: commands: - show ip ospf neigh wait_for: - result[0] contains FULL</code> </pre><br>  Führen Sie dieses Playbook mit dem Befehl ansible-playbook aus: <br><br><pre> <code class="plaintext hljs">➜ ansible-playbook ospf.yml PLAY [eos] ********************************************************************************************* TASK [turn on OSPF for interface Ethernet1] ******************************************************* changed: [eos] TASK [execute Arista eos command] **************************************************************** ok: [eos] PLAY RECAP ****************************************************************************************** eos : ok=2 changed=1 unreachable=0 failed=0</code> </pre><br>  Wir schauen auf die Kommandozeile und sehen, dass das Playbook erfolgreich war: <br><br><pre> <code class="plaintext hljs">eos#show ip ospf neigh Neighbor ID VRF Pri State Dead Time Address Interface 2.2.2.2 default 1 FULL/DR 00:00:33 172.16.1.2 Ethernet1</code> </pre><br>  Zusätzlich zu enthält können Sie die folgenden Vergleichsoperatoren verwenden: <br><br><ul><li>  Gleichung: - ist gleich </li><li>  neq: - ungleich </li><li>  gt: - mehr </li><li>  ge: - größer oder gleich </li><li>  lt: - weniger </li><li>  le: - kleiner oder gleich </li></ul><br>  Zusätzlich können Sie zusammen mit wait_for drei zusätzliche Parameter verwenden (ausführlich in der Dokumentation zu den Modulen beschrieben): <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Beschreibung</b> </td></tr><tr><td>  Intervall </td><td>  Zeit zwischen Wiederholungen eines Teams. </td></tr><tr><td>  Wiederholungen </td><td>  Max  Die Anzahl der Wiederholungen, bevor die Aufgabe mit einem Fehler abgeschlossen wird oder die Bedingung erfüllt ist. </td></tr><tr><td>  Spiel </td><td>  Das Zusammentreffen aller Bedingungen oder mindestens einer. </td></tr></tbody></table><br>  Lassen Sie uns näher auf den Übereinstimmungsparameter eingehen: <br><br><pre> <code class="plaintext hljs"> - name: execute Arista eos command eos_command: commands: - show ip ospf neigh match: any wait_for: - result[0] contains FULL - result[0] contains 172.16.1.2</code> </pre><br>  Wenn match: any angegeben ist, wird die Aufgabe als erfolgreich angesehen, wenn das Ergebnis FULL oder 172.16.1.2 enthält.  Wenn match: all angegeben ist, muss das Ergebnis sowohl FULL als auch 172.16.1.2 enthalten.  Standardmäßig wird match: all verwendet. Wenn Sie mehrere Bedingungen vorschreiben, möchten Sie höchstwahrscheinlich, dass alle und nicht mindestens eine ausgeführt werden. <br><br>  Wann kann passen: welche nützlich sein?  Angenommen, Sie müssen überprüfen, ob das Rechenzentrum über eine bidirektionale Verbindung zum Internet verfügt.  Das Rechenzentrum ist mit fünf verschiedenen Internetanbietern verbunden, von denen jeder über eine eigene BGP-Verbindung verfügt.  Ein Playbook kann alle diese fünf Verbindungen überprüfen. Wenn mindestens eine davon funktioniert und nicht alle fünf, melden Sie, dass alles in Ordnung ist.  Denken Sie daran, dass jedes ein logisches ODER ist und alles ein logisches UND ist. <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Beschreibung</b> </td></tr><tr><td>  Übereinstimmung: beliebig </td><td>  Logisches "ODER" <br>  Es ist mindestens eine Bedingung erforderlich </td></tr><tr><td>  Spiel: alle </td><td>  Logisches "Und" <br>  Alle Bedingungen erforderlich </td></tr></tbody></table><br><h3>  Negative Bedingungen: Aufbau der inversen Logik </h3><br>  Manchmal ist es nicht wichtig, was in der Schlussfolgerung steht, sondern was nicht.  Hier ist es natürlich immer verlockend, den neq-Vergleichsoperator zu verwenden, aber für einige Szenarien mit negativen Bedingungen gibt es bessere Optionen.  Wenn Sie beispielsweise die include-Anweisung invertieren müssen (vom Typ "Die Ausgabe des Befehls sollte solche und solche nicht enthalten"), können Sie das Schlüsselwort register verwenden, um die Ausgabe zu speichern und sie dann in der nächsten Aufgabe mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausdruck when zu verarbeiten</a> .  Wenn Sie beispielsweise das Playbook stoppen müssen, wenn die Bedingungen nicht erfüllt sind, verwenden Sie einfach die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fail-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assert-</a> Module, um den Fehler spezifisch zu beenden.  Der Vergleichsoperator neq ist nur dann nützlich, wenn Sie den genauen Wert aus der Ausgabe extrahieren können (z. B. aus einem Schlüssel-Wert-Paar oder aus JSON) und nicht nur aus einer Zeichenfolge oder einer Liste von Zeichenfolgen.  Andernfalls wird ein zeichenweiser Vergleich der Zeichenfolgen durchgeführt. <br><br><h3>  Was weiter </h3><br>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zum Arbeiten mit der Ausgabe von Befehlen in Netzwerkmodulen.  Es enthält nützliche Beispiele für die Verwendung von ge, le und anderen Bedingungen bei der Arbeit mit der Ausgabe im JSON-Format auf bestimmten Netzwerkplattformen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438312/">https://habr.com/ru/post/de438312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438298/index.html">Warum unterrichten, wenn das Entwickeln rentabler ist? Gespräch mit GeekBrains</a></li>
<li><a href="../de438302/index.html">Die erstaunliche Kreativität der digitalen Evolution</a></li>
<li><a href="../de438304/index.html">Vergabe von Unteraufträgen? Cool du schlägst</a></li>
<li><a href="../de438306/index.html">Strahlung: Wochentags radiochemisches Labor</a></li>
<li><a href="../de438310/index.html">Instagram verwendet maschinelles Lernen, um gefälschte Follower zu entfernen</a></li>
<li><a href="../de438314/index.html">1. Check Point Maestro Hyperscale-Netzwerksicherheit - eine neue skalierbare Sicherheitsplattform</a></li>
<li><a href="../de438316/index.html">Grundlagen des signierten Distanzfelds in 2D</a></li>
<li><a href="../de438318/index.html">Wie man die asynchrone / wartende Syntax beherrscht: ein echtes Beispiel</a></li>
<li><a href="../de438320/index.html">Kindern das Programmieren beibringen</a></li>
<li><a href="../de438322/index.html">VSaaS 2025: CCTV-Technologie der Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>