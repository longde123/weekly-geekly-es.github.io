<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏽 🍫 👩🏼‍✈️ Funktionen zur Verwendung des Symboldatentyps in JavaScript 👂🏼 🕵🏼 🧙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zeichenprimitive sind eine der Innovationen des ES6-Standards, die JavaScript einige wertvolle Funktionen verliehen haben. Symbole, die durch den Symb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen zur Verwendung des Symboldatentyps in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444340/">  Zeichenprimitive sind eine der Innovationen des ES6-Standards, die JavaScript einige wertvolle Funktionen verliehen haben.  Symbole, die durch den Symboldatentyp dargestellt werden, sind besonders nützlich, wenn sie als Bezeichner für Objekteigenschaften verwendet werden.  Im Zusammenhang mit einem solchen Szenario ihrer Anwendung stellt sich die Frage, was sie können, was die Linien nicht können. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br>  In dem Material, dessen Übersetzung wir heute veröffentlichen, werden wir über den Symboldatentyp in JavaScript sprechen.  Wir beginnen mit der Überprüfung einiger JavaScript-Funktionen, die Sie zum Umgang mit Symbolen benötigen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vorläufige Informationen</font> </h2><br>  In JavaScript gibt es tatsächlich zwei Arten von Werten.  Die ersten typprimitiven Werte, das zweite Objekt (sie enthalten auch Funktionen).  Zu den primitiven Werten gehören einfache Datentypen wie Zahlen (dies umfasst alles von Ganzzahlen bis zu Gleitkommazahlen, <code>Infinity</code> und <code>NaN</code> Werten), logische Werte, Zeichenfolgen, <code>undefined</code> und <code>null</code> .  Beachten Sie, dass <code>null</code> ein primitiver Wert ist, während die Überprüfung von <code>typeof null === 'object'</code> <code>true</code> ergibt. <br><br>  Primitive Werte sind unveränderlich.  Sie können nicht geändert werden.  Natürlich können Sie etwas Neues in eine Variable schreiben, in der ein primitiver Wert gespeichert ist.  Dies schreibt beispielsweise einen neuen Wert in die Variable <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br>  Gleichzeitig gibt es jedoch keine Änderung (Mutation) des primitiven numerischen Wertes <code>1</code> . <br><br>  In einigen Sprachen, zum Beispiel in C, gibt es Konzepte, Argumente von Funktionen als Referenz und als Wert zu übergeben.  JavaScript hat auch etwas ähnliches.  Wie genau die Arbeit mit Daten organisiert ist, hängt von ihrem Typ ab.  Wenn ein primitiver Wert, der durch eine bestimmte Variable dargestellt wird, an die Funktion übergeben und dann in dieser Funktion geändert wird, ändert sich der in der ursprünglichen Variablen gespeicherte Wert nicht.  Wenn Sie jedoch den durch die Variable dargestellten Objektwert an die Funktion übergeben und ändern, ändert sich auch, was in dieser Variablen gespeichert ist. <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br>  Primitive Werte (mit Ausnahme des mysteriösen <code>NaN</code> , das nicht gleich sich selbst ist) erweisen sich immer als gleichwertig mit anderen primitiven Werten, die genauso aussehen wie sie selbst.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Die Konstruktion von Objektwerten, die äußerlich gleich aussehen, führt jedoch nicht dazu, dass Entitäten erhalten werden, wenn sie verglichen werden, wird ihre Gleichheit untereinander offenbart.  Sie können dies überprüfen, indem Sie: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br>  Objekte spielen in JavaScript eine grundlegende Rolle.  Sie werden buchstäblich überall verwendet.  Beispielsweise werden sie häufig in Form von Schlüssel- / Wertsammlungen verwendet.  Vor dem Aufkommen des <code>Symbol</code> Datentyps konnten jedoch nur Zeichenfolgen als Objektschlüssel verwendet werden.  Dies war eine ernsthafte Einschränkung der Verwendung von Objekten in Form von Sammlungen.  Beim Versuch, einen Nicht-Zeichenfolgenwert als Objektschlüssel zuzuweisen, wurde dieser Wert in eine Zeichenfolge umgewandelt.  Sie können dies überprüfen, indem Sie: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br>  Übrigens, obwohl dies uns ein wenig vom Thema Zeichen entfernt, möchte ich darauf hinweisen, dass die <code>Map</code> Datenstruktur erstellt wurde, um die Verwendung von Schlüssel- / Wertdatenspeichern in Situationen zu ermöglichen, in denen der Schlüssel keine Zeichenfolge ist. <br><br><h2>  <font color="#3AC1EF">Was ist ein Symbol?</font> </h2><br>  Nachdem wir die Funktionen primitiver Werte in JavaScript herausgefunden haben, können wir endlich über Zeichen sprechen.  Ein Symbol ist eine einzigartige primitive Bedeutung.  Wenn Sie sich den Symbolen von dieser Position aus nähern, werden Sie feststellen, dass die Symbole in dieser Hinsicht Objekten ähnlich sind, da die Erstellung mehrerer Instanzen der Symbole zur Erstellung unterschiedlicher Werte führt.  Aber Symbole sind darüber hinaus unveränderliche primitive Werte.  Hier ist ein Beispiel für die Arbeit mit Zeichen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Beim Erstellen einer Instanz eines Zeichens können Sie das optionale Argument der ersten Zeichenfolge verwenden.  Dieses Argument beschreibt das Symbol, das beim Debuggen verwendet werden soll.  Dieser Wert wirkt sich nicht auf das Symbol selbst aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Symbole als Schlüssel zum Eigentum von Objekten</font> </h2><br>  Symbole können als Eigenschaftsschlüssel für Objekte verwendet werden.  Es ist sehr wichtig.  Hier ist ein Beispiel für die Verwendung als solche: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br>  Bitte beachten Sie, dass durch Zeichen angegebene Schlüssel beim <code>Object.keys()</code> der <code>Object.keys()</code> -Methode nicht zurückgegeben werden.  Code, der vor dem Erscheinen von Zeichen in JS geschrieben wurde, weiß nichts über sie. Daher sollten Informationen zu den Schlüsseln von Objekten, die durch Zeichen dargestellt werden, nicht von der alten <code>Object.keys()</code> -Methode zurückgegeben werden. <br><br>  Auf den ersten Blick scheint es so, als könnten Sie mit den oben genannten Funktionen von Zeichen private Eigenschaften von JS-Objekten erstellen.  In vielen anderen Programmiersprachen können Sie mithilfe von Klassen Eigenschaften für versteckte Objekte erstellen.  Das Fehlen dieser Funktion wurde lange Zeit als einer der Mängel von JavaScript angesehen. <br><br>  Leider kann der Code, der mit Objekten arbeitet, frei auf ihre Zeichenfolgenschlüssel zugreifen.  Der Code kann darüber hinaus auch auf durch Zeichen angegebene Schlüssel zugreifen, selbst wenn der Code, von dem aus sie mit dem Objekt arbeiten, keinen Zugriff auf das entsprechende Zeichen hat.  Mit der <code>Reflect.ownKeys()</code> -Methode können Sie beispielsweise eine Liste aller Schlüssel eines Objekts <code>Reflect.ownKeys()</code> , sowohl der Zeichenfolgen als auch der Zeichen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br>  Beachten Sie, dass derzeit daran gearbeitet wird, Klassen mit der Möglichkeit auszustatten, private Eigenschaften zu verwenden.  Diese Funktion wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">private Felder bezeichnet</a> .  Es ist wahr, dass nicht alle Objekte betroffen sind, sondern nur diejenigen, die auf der Grundlage zuvor vorbereiteter Klassen erstellt wurden.  Unterstützung für private Felder ist bereits in der Chrome-Browserversion 72 und älter verfügbar. <br><br><h2>  <font color="#3AC1EF">Verhindern Sie Kollisionen von Objekteigenschaftsnamen</font> </h2><br>  Symbole bieten JavaScript natürlich nicht die Möglichkeit, private Eigenschaften von Objekten zu erstellen, aber sie sind aus anderen Gründen eine wertvolle Neuerung in der Sprache.  Sie sind nämlich in Situationen nützlich, in denen bestimmte Bibliotheken Eigenschaften zu Objekten hinzufügen müssen, die außerhalb von ihnen beschrieben wurden, und gleichzeitig keine Angst vor einer Kollision der Namen von Eigenschaften von Objekten haben müssen. <br><br>  Stellen Sie sich ein Beispiel vor, in dem zwei verschiedene Bibliotheken einem Objekt Metadaten hinzufügen möchten.  Möglicherweise müssen beide Bibliotheken das Objekt mit einigen Bezeichnern ausstatten.  Wenn Sie für den Namen einer solchen Eigenschaft einfach eine <code>id</code> Zeichenfolge aus zwei Buchstaben verwenden, kann es vorkommen, dass eine Bibliothek die von der anderen angegebene Eigenschaft überschreibt. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Wenn wir die Symbole in unserem Beispiel verwenden, kann jede Bibliothek bei der Initialisierung die benötigten Symbole generieren.  Diese Symbole können dann verwendet werden, um Objekten Eigenschaften zuzuweisen und auf diese Eigenschaften zuzugreifen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Wenn Sie sich ein solches Szenario ansehen, können Sie vom Auftreten von Zeichen in JavaScript profitieren. <br><br>  Es kann jedoch eine Frage bezüglich der Verwendung von Bibliotheken für die Namen von Eigenschaften von Objekten, zufälligen Zeichenfolgen oder Zeichenfolgen mit einer komplexen Struktur geben, einschließlich beispielsweise des Namens der Bibliothek.  Ähnliche Zeichenfolgen können so etwas wie Namespaces für von Bibliotheken verwendete Bezeichner bilden.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br>  Im Allgemeinen können Sie dies tun.  Ähnliche Ansätze sind in der Tat sehr ähnlich zu dem, was bei der Verwendung von Symbolen passiert.  Und wenn einige Bibliotheken unter Verwendung von zufälligen Bezeichnern oder Namespaces nicht zufällig dieselben Eigenschaftsnamen generieren, gibt es keine Probleme mit den Namen. <br><br>  Ein kluger Leser würde jetzt sagen, dass die beiden Ansätze zur Benennung von Objekteigenschaften nicht vollständig gleichwertig sind.  Eigenschaftsnamen, die zufällig generiert werden oder Namespaces verwenden, haben einen Nachteil: Die entsprechenden Schlüssel sind sehr leicht zu finden, insbesondere wenn der Code die Schlüssel von Objekten durchsucht oder sie serialisiert.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br>  Wenn in dieser Situation ein Symbol für den Schlüsselnamen verwendet würde, würde die JSON-Darstellung des Objekts den Symbolwert nicht enthalten.  Warum ist das so?  Tatsache ist, dass die Tatsache, dass ein neuer Datentyp in JavaScript angezeigt wurde, nicht bedeutet, dass Änderungen an der JSON-Spezifikation vorgenommen wurden.  JSON unterstützt als Eigenschaftsschlüssel nur Zeichenfolgen.  Bei der Serialisierung eines Objekts wird nicht versucht, die Zeichen auf besondere Weise darzustellen. <br><br>  Das betrachtete Problem beim <code>Object.defineProperty()</code> von Eigenschaftsnamen in der JSON-Darstellung von Objekten kann mithilfe von <code>Object.defineProperty()</code> gelöst werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br>  Zeichenfolgenschlüssel, die „versteckt“ sind, indem ihr <code>enumerable</code> auf <code>false</code> verhalten sich ähnlich wie Schlüssel, die durch Zeichen dargestellt werden.  Beide werden beim <code>Object.keys()</code> nicht angezeigt, und beide können mit <code>Reflect.ownKeys()</code> erkannt werden.  So sieht es aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br>  Hier muss ich sagen, dass wir die Möglichkeiten von Symbolen mit anderen Mitteln von JS fast neu erschaffen haben.  Insbesondere fallen sowohl durch Symbole dargestellte Schlüssel als auch private Schlüssel nicht in die JSON-Darstellung eines Objekts.  Beide können anhand der <code>Reflect.ownKeys()</code> -Methode erkannt werden.  Infolgedessen können beide nicht als wirklich privat bezeichnet werden.  Wenn wir davon ausgehen, dass einige zufällige Werte oder Bibliotheksnamespaces zum Generieren von Schlüsselnamen verwendet werden, bedeutet dies, dass wir das Risiko von Namenskollisionen beseitigt haben. <br><br>  Es gibt jedoch einen kleinen Unterschied zwischen der Verwendung von Symbolnamen und Namen, die mit anderen Mechanismen erstellt wurden.  Da Zeichenfolgen unveränderlich sind und Zeichen garantiert eindeutig sind, besteht immer die Möglichkeit, dass jemand nach Durchlaufen aller möglichen Zeichenkombinationen in einer Zeichenfolge eine Namenskollision verursacht.  Aus mathematischer Sicht bedeutet dies, dass Zeichen uns wirklich eine wertvolle Gelegenheit bieten, die Strings nicht haben. <br><br>  Wenn in Node.js beim Untersuchen von Objekten (z. B. mit <code>console.log()</code> ) eine Objektmethode namens <code>console.log()</code> erkannt wird, wird diese Methode verwendet, um eine Zeichenfolgendarstellung des Objekts <code>console.log()</code> und diese dann auf dem Bildschirm anzuzeigen.  Es ist leicht zu verstehen, dass dies absolut nicht jeder berücksichtigen kann. Daher kann ein solches Verhalten des Systems zu einem Aufruf der <code>inspect</code> Object-Methode führen, mit der Probleme gelöst werden sollen, die nicht mit der Bildung der Zeichenfolgendarstellung des Objekts zusammenhängen.  Diese Funktion ist in Node.js 10 veraltet. In Version 11 werden Methoden mit einem ähnlichen Namen einfach ignoriert.  <code>require('util').inspect.custom</code> diese Funktion zu implementieren, wird nun das <code>require('util').inspect.custom</code> .  Dies bedeutet, dass niemand jemals in der Lage sein wird, das System versehentlich zu stören, indem er eine Objektmethode namens <code>inspect</code> . <br><br><h2>  <font color="#3AC1EF">Nachahmung von Privateigentum</font> </h2><br>  Hier ist ein interessanter Ansatz, mit dem Sie die privaten Eigenschaften von Objekten simulieren können.  Dieser Ansatz beinhaltet die Verwendung einer weiteren modernen JavaScript-Funktion - Proxy-Objekte.  Solche Objekte dienen als Wrapper für andere Objekte, mit denen der Programmierer in die mit diesen Objekten ausgeführten Aktionen eingreifen kann. <br><br>  Proxy-Objekte bieten viele Möglichkeiten, die an Objekten ausgeführten Aktionen abzufangen.  Wir sind an der Möglichkeit interessiert, den Vorgang des Lesens von Schlüsseln eines Objekts zu steuern.  Wir werden hier nicht auf Details zu Proxy-Objekten eingehen.  Wenn Sie interessiert sind, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Publikation an. <br><br>  Wir können Proxys verwenden, um zu steuern, welche Eigenschaften des Objekts von außen sichtbar sind.  In diesem Fall möchten wir einen Proxy erstellen, der zwei uns bekannte Eigenschaften verbirgt.  Einer hat den String-Namen <code>_favColor</code> und der zweite wird durch ein Zeichen dargestellt, das in die Variable <code>favBook</code> wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br>  Der Umgang mit einer Eigenschaft, deren Name durch die Zeichenfolge <code>_favColor</code> ist nicht schwierig: Lesen Sie einfach den Quellcode.  Dynamische Tasten (wie die oben gezeigten UUID-Tasten) können mit Brute Force abgeglichen werden.  Ohne Bezugnahme auf das Symbol können Sie jedoch nicht über das <code>proxy</code> Objekt auf den Wert von <code>Metro 2033</code> zugreifen. <br><br>  Es ist zu beachten, dass es in Node.js eine Funktion gibt, die die Privatsphäre von Proxy-Objekten verletzt.  Diese Funktion ist in der Sprache selbst nicht vorhanden und daher für andere JS-Laufzeiten, z. B. einen Browser, nicht relevant.  Tatsache ist, dass Sie mit dieser Funktion auf das hinter dem Proxy-Objekt versteckte Objekt zugreifen können, wenn Sie Zugriff auf das Proxy-Objekt haben.  Hier ist ein Beispiel, das die Fähigkeit demonstriert, die im vorherigen Codefragment gezeigten Mechanismen zu umgehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br>  Um die Verwendung dieser Funktion in einer bestimmten Instanz von Node.js zu verhindern, müssen Sie entweder das globale <code>Reflect</code> Objekt oder die Bindung des <code>util</code> Prozesses <code>util</code> .  Dies ist jedoch eine andere Aufgabe.  Wenn Sie interessiert sind, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Beitrag zum Schutz von JavaScript-basierten APIs. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir über den Datentyp <code>Symbol</code> gesprochen, darüber, welche Funktionen JavaScript-Entwicklern zur Verfügung gestellt werden und welche vorhandenen Sprachmechanismen zur Simulation dieser Funktionen verwendet werden können. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie Symbole in Ihren JavaScript-Projekten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444340/">https://habr.com/ru/post/de444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444328/index.html">Die Neugestaltung der Benutzeroberfläche ist oft Zeitverschwendung</a></li>
<li><a href="../de444330/index.html">Serverless CMS ist endlich ein würdiger Konkurrent für Wordpress</a></li>
<li><a href="../de444332/index.html">Informationssicherheit und Catering: Wie Manager über IT-Produkte denken</a></li>
<li><a href="../de444336/index.html">Schnelle Erfassungslisten: Was ist der Unterschied zwischen schwachen, starken und nicht besessenen Links?</a></li>
<li><a href="../de444338/index.html">Kapselung in Python 3</a></li>
<li><a href="../de444342/index.html">Entwicklung einfacher, moderner JavaScript-Anwendungen mit Webpack und fortschrittlichen Webtechnologien</a></li>
<li><a href="../de444344/index.html">10 Schritte zu einem erfolgreichen Python-Projekt</a></li>
<li><a href="../de444346/index.html">GraphQL und Golang</a></li>
<li><a href="../de444348/index.html">Wie unterscheiden sich funktionale React-Komponenten von klassenbasierten Komponenten?</a></li>
<li><a href="../de444350/index.html">Aus irgendeinem Grund startet MVP (Minimum Viable Product) nicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>