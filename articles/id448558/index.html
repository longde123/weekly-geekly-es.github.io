<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸƒ ğŸš¦ ğŸ‚ğŸ» Apakah mungkin untuk membuat gambar yang realistis tanpa angka floating point? ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ‡ ğŸ”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 

 "Apa yang terjadi jika kita mengganti angka floating point dengan angka rasional dan mencoba membuat gambar?" 

 Saya bertanya pada dir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah mungkin untuk membuat gambar yang realistis tanpa angka floating point?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  Pendahuluan </h2><br><hr><br>  "Apa yang terjadi jika kita mengganti angka floating point dengan angka rasional dan mencoba membuat gambar?" <br><br>  Saya bertanya pada diri sendiri pertanyaan ini setelah berpikir tentang tweet seorang peneliti dan guru grafis komputer Morgan McGwire.  Dia berbicara tentang seberapa banyak siswa sains komputer terkejut ketika mereka pertama kali mengetahui bahwa untuk menyimpan angka floating-point yang akrab di komputer modern, kompromi harus dilakukan.  Dan kompromi-kompromi ini membuat tugas-tugas sederhana menjadi sulit, misalnya, memeriksa apakah suatu titik termasuk dalam segitiga.  Masalahnya, tentu saja, adalah bahwa memeriksa empat titik di bidang yang sama (coplanarity) menggunakan determinan atau semacam perkalian vektor (tetapi sebenarnya ini adalah hal yang sama) tidak akan pernah memberikan nilai persis sama dengan nol, yang diperlukan ini adalah metode matematika.  Bahkan jika perhitungan nyata berada di pesawat yang sama adalah akurat, kompromi yang sama dengan akurasi hampir 1,0 akan memberikan jawaban bahwa keempat poin itu sendiri bukan coplanar. <br><br>  Ini memunculkan ide pada saya - jika kita mengasumsikan bahwa semua data renderer yang masuk (koordinat titik, transformasi 3D, dll.) Ditetapkan sebagai bilangan rasional, maka mereka akan membuat semua operasi, dari membuat sinar, melintasi struktur percepatan ke persimpangan sinar dengan segitiga hanya bilangan rasional?  Jika itu masalahnya, maka kita akan dapat melakukan tes coplanarity dengan tepat!  Anda mungkin bertanya-tanya mengapa adegan 3D yang dinyatakan dalam bilangan rasional hanya akan memberikan hasil dalam bilangan rasional ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Adegan sederhana, jejak jalan yang dilakukan oleh aritmatika rasional.</i>  <i>Ini menggunakan sistem angka floating- <b>point</b> , bukan angka floating- <b>point</b> .</i> <br><a name="habracut"></a><br>  Pertama, bilangan rasional adalah bilangan yang dapat dinyatakan sebagai rasio dua bilangan bulat, misalnya 1/2 atau 355/113.  Kedua, "operasi rendering normal", seperti tes kotak pembatas, memeriksa persimpangan sinar dengan segitiga, pantulan sinar, dll., Didasarkan pada produk vektor dan skalar, serta pembagian skalar (ini termasuk mengoordinasikan transformasi dan inversi matriks, angka empat, dll.), yang pada gilirannya didasarkan pada empat operasi dasar: penambahan, pengurangan, perkalian, dan pembagian.  Saat menambahkan, mengurangi, mengalikan dan membagi angka rasional, angka rasional juga diperoleh.  Ahli matematika akan mengatakan bahwa banyak bilangan rasional membentuk bidang yang ditutup di bawah empat operasi aritmatika dasar.  Bagi kami, ini berarti bahwa jika kita mematuhi bilangan rasional secara eksklusif, maka kita dapat benar-benar beralih dari data input adegan 3D ke gambar yang diberikan sepenuhnya tanpa meninggalkan dunia bilangan rasional. <br><br>  Pengecualian untuk aturan "tindakan pada bilangan rasional memberikan bilangan rasional" adalah akar kuadrat dan fungsi trigonometri / transendental.  Adapun yang terakhir, saya selalu mengatakan bahwa jika Anda harus melakukan perhitungan trigonometri di interior geometri penyaji Anda, maka kemungkinan besar Anda melakukan sesuatu yang salah (dan saya menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara memperbaiki kasus yang paling standar</a> ) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> tentang HabrÃ©].  Adapun akar kuadrat, dengan pengecualian bagian kerucut (bola, silinder, dll.) Dan melakukan peneduhan / DFOS / pewarnaan, tidak perlu untuk menormalkan sinar dan normal ke permukaan sesering yang biasanya dilakukan.  Itu tentu tidak perlu dilakukan untuk membuat sinar, lintasan, persimpangan, refleksi, dll.  Sayangnya, sangat sering saya melihat bahwa pemrogram menormalkan nilai-nilai tanpa alasan selain "baik, saya tidak tahu, saya melakukannya sehingga saya bisa memainkannya dengan aman."  Dalam praktiknya, di bagian render di mana geometri dilacak, sangat jarang diperlukan untuk menormalkan nilai-nilai, jadi saya memiliki harapan bahwa Anda dapat melacak seluruh adegan tanpa meninggalkan dunia angka rasional - inilah yang saya sebut "rendering rasional". <br><br>  Untuk menerapkannya, saya perlu membuat sistem angka berdasarkan angka rasional yang dapat digunakan komputer.  Kemudian di atasnya, saya bisa menerapkan algoritma penelusuran jalur biasa, menghitung gambar tanpa kehilangan keakuratan, melakukan pemeriksaan coplanarity yang memiliki jawaban akurat, dan membuat semua siswa yang mempelajari grafik komputer senang. <br><br>  Artikel ini adalah kisah tentang dua malam penelitian tentang realisme ide semacam itu.  Saya akan berbicara tentang banyak aspek yang saya pelajari, tentang apa yang saya hasilkan dan tentang beberapa kejutan yang saya temukan dalam proses itu.  Artikel ini ditulis dalam urutan kronologis pekerjaan saya.  Selain itu, ditulis dengan gaya informal dan sangat tidak ilmiah (yang saya banggakan).  Gambar yang ditunjukkan di atas adalah semacam spoiler, tetapi baca artikel sampai akhir, karena saya akan berbicara tentang yang baik dan yang buruk. <br><br><h2>  Persiapan </h2><br><hr><br>  Hal pertama yang saya lakukan adalah untuk menerapkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shadertoy</a> pelacak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minimal</a> terbatas untuk adegan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat sederhana yang</a> terdiri dari pesawat, bola, paralelepiped persegi panjang dan segitiga - blok bangunan penyaji nyata.  Kemudian saya menyalin kode ke file C ++ dan, setelah membuat beberapa perubahan kecil, mengkompilasinya menggunakan kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">piLibs</a> saya.  Jadi untuk perbandingan, saya mendapatkan gambar yang dilacak yang diberikan ke CPU menggunakan angka reguler sesuai dengan standar IEEE754 dengan floating point.  Saya juga menghapus semua normalisasi ray dari kode jejak, karena, sebagaimana disebutkan di atas, tidak ada satupun yang benar-benar diperlukan.  Biarkan saya mengingatkan Anda bahwa akar kuadrat diperlukan untuk normalisasi, dan bilangan rasional tidak dipertahankan ketika digunakan (akar kuadrat dari bilangan rasional bukan bilangan rasional).  Beberapa saat kemudian kita akan melihat bahwa masih dimungkinkan untuk menerapkan akar kuadrat, tentu saja, saya hanya ingin membuat kode sebersih mungkin untuk melihat sejauh mana saya bisa pergi dengan aritmatika yang tepat dari bilangan rasional tanpa pembulatan. <br><br>  Langkah persiapan terakhir - saya mengambil semua vec3, mat4x4 dan kelas dasar aljabar / matematika, dan kemudian mengubahnya sehingga mereka menggunakan rasional alih-alih mengapung.  Karena struktur rasional saya membebani semua operator standar (tambah, sub, mul, div, pembalikan tanda, perbandingan, dll.), Penggantian terjadi tanpa masalah.  Saya segera mengimplementasikan sisa operasi biasa (abs, sign, mod, fract, floor, sqrt, dll.), Yang secara teoritis cukup untuk mendapatkan rendering rasional yang indah. <br><br><h2>  Tes 1 - Solusi Naif </h2><br><hr><br>  Tapi mari kita lihat seperti apa implementasi pertama ini.  Awalnya saya selalu mencoba yang paling sederhana, dan kemudian saya melihat hasilnya.  Dan cara paling sederhana untuk menerapkan nilai-nilai rasional adalah dengan menggunakan dua bilangan bulat.  Seperti yang disarankan oleh nama bagian ini, ini bukan keputusan akhir saya, tetapi untuk upaya pertama itu adalah keputusan yang masuk akal.  Jadi, setiap angka <b>x</b> harus direpresentasikan sebagai pembilang <b>N</b> dan penyebut <b>D</b> , membentuk nilai <b>N</b> / <b>D.</b>  Nilai <b>x</b> didekati dengan pasangan <b>N</b> / <b>D terbaik</b> (dalam kedalaman bit yang ditentukan), yang paling dekat dengan nilai <b>x yang</b> sebenarnya.  Saya memutuskan bahwa kedua angka harus positif, dan tanda nomor tersebut harus disimpan dalam bit yang terpisah untuk menyederhanakan pekerjaan dan menghilangkan ambiguitas, meskipun ini tidak terlalu penting.  Pada tahap ini, baik pembilang dan penyebut bertipe unsigned.  Tetapi bahkan ketika memisahkan tanda, <b>N</b> / <b>D</b> memiliki banyak redundansi: misalnya, 1/4 dan 7/28 menunjukkan angka yang sama, tetapi memiliki representasi bit yang sama sekali berbeda.  Kita akan membahas ini nanti, tetapi untuk sekarang, jangan memfokuskan perhatian kita dan melihat bagaimana empat operasi aritmatika dasar terlihat dalam bentuk rasional ini. <br><br>  Pertama, perhatikan bahwa mengurangi <b>a</b> - <b>b</b> hanyalah penambahan <b>a</b> dan nilai yang berlawanan dengan <b>b</b> , yaitu, <b>a</b> + ( <b>-b</b> ), di mana <b>-b</b> dapat dihitung dengan hanya mengganti tanda <b>b</b> .  Demikian pula, membagi <b>a</b> / <b>b</b> sama dengan mengalikan <b>a</b> dan kebalikan dari <b>b</b> .  Atau, dengan kata lain, <b>a</b> / <b>b</b> = <b>a</b> Â· (1 / <b>b</b> ), di mana (1 / <b>b</b> ) dapat dihitung dengan hanya mengubah tempat-tempat pembilang <b>b</b> dan penyebut <b>b <sub>dari</sub></b> angka <b>b</b> .  Jadi, di sini adalah properti menarik pertama dari aritmatika rasional - divisi dan multiplikasi memiliki biaya yang sama, oleh karena itu, tidak seperti rendering floating point yang biasa, di mana divisi biasanya dihindari, ditunda atau disembunyikan di bawah keterlambatan permintaan tekstur lambat, tidak perlu takut operasi ini dalam aritmatika rasional . <br><br>  Kami beralih ke penjumlahan dengan perkalian: kami tahu bahwa nilai kebalikan dan kebalikannya mudah dihitung, jadi kami mendapatkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  Pelestarian tanda selama perkalian adalah sepele, hanya xor, karena dua nilai positif memberikan hasil positif, serta dua yang negatif.  Menyimpan tanda untuk penambahan adalah proses yang lebih rumit, dan untuk solusi cepat saya menerapkannya melalui tiga cabang (penambahan itu sepele jika tanda <b>a</b> dan <b>b</b> bertepatan, tetapi ketika mereka tidak cocok, maka Anda perlu memilih jumlah yang lebih kecil dan mengurangi dari yang lebih besar - dalam artikel Saya akan menjelaskan detail sekecil itu dengan lebih detail, tetapi hanya lay out kode sumber di suatu tempat). <br><br>  Saya juga akan melewatkan implementasi fract () dan floor ();  jika Anda memutuskan untuk mencoba menerapkannya sendiri, Anda akan melihat kesederhanaan dan keindahannya.  Perhatian juga harus diberikan kepada operator pembanding.  Setelah merawat tanda-tanda dan dengan asumsi bahwa <b>a</b> dan <b>b</b> positif, kita dapat <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  Penting untuk dicatat di sini bahwa bahkan untuk perbandingan kita memerlukan beberapa operasi multiplikasi, yang dapat mengarah pada transisi ke ukuran kata berikutnya dan akan menjadi penting sedikit lebih rendah. <br><br>  Akhirnya, kita melihat akar kuadrat dalam bagian yang terpisah, mengetahui bahwa sebagian besar kita tidak membutuhkannya (kecuali untuk bola dari tes pertama ini). <br><br>  Ini cukup untuk menjalankan render pertama dan melacak adegan uji (bidang + bola + segitiga + kotak persegi panjang) untuk melihat apa yang terjadi.  Saya dengan murah hati menggunakan bilangan rasional 65-bit untuk tes pertama ini, yang sebenarnya mewakili sejumlah besar data (sebanding dengan tipe data "ganda"): 32 bit diambil oleh pembilang, 32 bit adalah penyebut, dan bit lainnya adalah tanda.  Yang pertama adalah gambar yang diperoleh dengan pendekatan naif ini, yang kedua adalah gambar yang dibuat menggunakan angka floating point (referensi): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>"Naif" angka rasional 65-bit</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Referensi titik mengambang</i> <br><br>  Hasilnya sangat buruk, kotak dan segitiga bahkan tidak muncul di render, dan bidang dan bidang lantai terlalu berisik.  Masalahnya, tentu saja, adalah bahwa setiap kali bilangan rasional saya melakukan operasi aritmatika dasar pada salah satu tahap algoritmik rendering, pembilang dan penyebut menjadi semakin tidak terkendali, karena penggandaan bilangan bulat digunakan.  Pikirkan hal-hal berikut: jika unit dunia awal kita adalah meter, dan kita akan mengikat geometri sumber (simpul dan kamera) dengan akurasi milimeter, maka hanya data sumber yang akan menempati volume 16-bit untuk adegan yang agak kecil.  Pada saat yang sama, dengan resolusi layar HD standar dan penghalusan 4X, angka arah sinar rasional akan dengan mudah membutuhkan 12 bit.  Artinya, selama interaksi pertama balok dan geometri, operasi aritmatika yang paling sederhana, menggunakan kedua set data input, akan mengubah hasilnya menjadi panjang 28-bit - cukup dekat dengan batas 32-bit yang saya tetapkan untuk diri saya sendiri dalam implementasi pertama ini.  Dan ini bahkan sebelum kami menampilkan produk skalar atau vektor yang pertama.  Pada saat produk skalar selesai, pemberi render akan membutuhkan bilangan rasional yang panjangnya ratusan bit untuk mewakili bilangan.  Tentu saja, ini adalah kasus terburuk, tetapi kasus rata-rata akan dekat dengan ini.  Menimbang bahwa saya hanya mengalokasikan kapasitas 32-bit untuk pembilang dan penyebut, mudah untuk memahami seberapa cepat nilai melampaui batas dalam tes ini - tidak mengherankan bahwa dengan pengecualian bidang lantai dan bagian bola, hampir tidak ada yang terlihat. <br><br><h2>  Tes 2 - Pengurangan oleh faktor umum terbesar </h2><br><hr><br>  Kemudian saya memperbaiki sistem dengan menggunakan properti yang saya sebutkan secara singkat di atas - angka rasional yang berbeda dapat berarti jumlah yang sama.  Dan pada kenyataannya, 6/12 adalah nilai yang sama dengan 1/2, tetapi menggunakan lebih banyak bit daripada yang terakhir.  Oleh karena itu, idenya adalah sebagai berikut: jika setelah setiap operasi aritmatika dasar (atau setelahnya) saya akan mengekstrak semua pembagi umum dari pembilang dan penyebut, dan membawa pecahan ke bentuk yang paling sederhana, maka mungkin saya akan dapat menjaga semuanya terkendali dan melanjutkan operasi lebih lama dengan aritmatika yang tepat tanpa kehilangan keakuratan.  Mungkin Anda bisa melakukan ini cukup lama untuk mendapatkan gambar yang bersih dan dirender?  Saya akan mengambil penyimpangan kecil untuk menunjukkan contoh lain: 588/910 dapat disederhanakan menjadi 42/65, karena 14 adalah pembagi 588 dan 910. Tetapi untuk menyimpan 42/65, jelas, lebih sedikit bit yang dibutuhkan daripada 588/910.  Menemukan nomor terbesar yang mungkin secara bersamaan membagi dua angka lainnya dapat dilakukan dengan menggunakan algoritma Great Common Divisor (GCD), implementasi efektif yang dapat Anda temukan di mana saja (saya secara pribadi menyalinnya langsung dari Wikipedia dan mempercepatnya sedikit dengan melakukan langkah pemindaian bit menggunakan operasi x64 internal).  Jadi, dipersenjatai dengan algoritma GCD, kelas rasional saya harus terus menyederhanakan fraksi yang dihasilkan selama proses rendering.  Ini bisa dilakukan dengan dua cara: <br><br>  Yang pertama adalah mengonversi hasil antara dari operator penambahan dan multiplikasi ke tipe data bit berikutnya (dalam solusi naif saya saat ini adalah uin64_t), cari GCD dalam tipe data yang lebih banyak ini, dan kemudian kurangi hasilnya menjadi panjang bit asli (32).  Cara kedua adalah menganalisis bagaimana <b>suatu <sub>n</sub></b> , <b>a</b> , <b><sub>d</sub></b> , <b>b</b> , dan <b>b <sub>d</sub></b> digabungkan satu sama lain dalam operator aritmatika dan mengekstrak pembagi umum dari mereka sebelum melakukan penggandaan.  Pendekatan kedua pada dasarnya menghilangkan kebutuhan akan panjang bit yang besar.  Mengetahui bahwa mungkin perlu menggunakannya, saya memutuskan untuk memilih metode pertama, karena lebih mudah untuk diterapkan dan memungkinkan saya untuk mempercepat pekerjaan saya (malam hari terbang sangat cepat).  Setelah melakukan semua ini, mari kita lihat render apa yang dapat saya buat sekarang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>Angka rasional 65-bit dikurangi oleh GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Referensi titik mengambang</i> <br><br>  Jauh lebih baik!  Sejauh ini, jauh dari ideal, tentu saja, tetapi terlihat menjanjikan.  Saya membuat kotak dan segitiga muncul, dan bola sekarang tampak jauh lebih tebal.  Namun, artefak lucu muncul di sudut kanan atas, dan bilangan rasional untuk banyak piksel masih melampaui batas, yang mengarah ke banyak titik dalam gambar.  Namun, perlu dicatat bahwa untuk beberapa (banyak) piksel, saya mulai mendapatkan hasil yang <b>akurat</b> dan sempurna!  Yaitu, pelacak menemukan persimpangan titik dan jarak yang secara matematis akurat, yang merupakan akar penyebab mencoba menggunakan bilangan rasional. <br><br>  Sebelum melanjutkan ke langkah berikutnya dalam proses membuktikan penerapan bilangan rasional, saya ingin berhenti sebentar dan membagikan temuan saya mengenai GCD dan pengurangan bilangan rasional. <br><br>  Penemuan pertama terkait dengan volume bit bilangan rasional.  Meskipun saya masih tidak dapat membuat gambar yang indah dan ini lebih penting daripada khawatir tentang mengoptimalkan volume data, dan meskipun implementasi awal ini masih menggunakan banyak bit (1 + 32 + 32), saya sudah memikirkan tentang limbah yang disebutkan sebelumnya bit dalam bentuk pecahan berlebih.  Secara khusus, setelah menambahkan tahap dengan GCD, kombinasi bit seperti 2/4 tidak lagi berlaku, karena mereka secara otomatis dikurangi menjadi 1/2 sebelum menulis ke register atau variabel apa pun.  Artinya, dalam arti tertentu, dari semua 2 kombinasi bit yang bisa menjadi pembilang dan penyebut, banyak yang tetap tidak digunakan.  Dan Anda tidak dapat membuang bit seperti itu.  Atau mungkinkah?  Berapa banyak ruang yang sebenarnya saya hilangkan?  Saya melakukan sedikit penyimpangan untuk mengeksplorasi masalah ini. <br><br><h2>  Digresi - Pada Bilangan Saling Utama </h2><br><hr><br>  Ilustrasi di bawah ini menunjukkan penggunaan bit untuk bilangan rasional dalam 5/5 bit dan 7/7 bit.  Sumbu horizontal dan vertikal grafik mewakili nilai pembilang dan penyebut semua bilangan rasional yang memungkinkan memiliki pembilang dan penyebut hingga 5 bit (31) dan 7 bit (127).  Piksel hitam adalah kombinasi yang tidak digunakan, dan piksel putih adalah pecahan yang digunakan.  Misalnya, seluruh diagonal berwarna hitam, kecuali untuk 1/1 piksel, karena semua fraksi dari bentuk n / n dikurangi menjadi 1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Menggunakan bit untuk 5/5 rasional</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Menggunakan bit untuk 7/7 rasional</i> <br><br>  Jika Anda menghitung piksel, seperti yang saya lakukan, maka Anda dapat dengan cepat memahami bahwa proporsi piksel bermanfaat dengan peningkatan jumlah bit cenderung 60,8%.  Sebuah riset online kecil menunjukkan kepada saya bahwa rasio ini ternyata tepat 6 / Ï€ <sup>2</sup> , karena ini juga merupakan probabilitas menjadi relatif prima (tidak memiliki pembagi umum) untuk dua angka acak.  Anda mungkin bertanya, dari mana pi itu berasal? ,  Â«  â€â€œ  Â» â€”  ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- </a> ,    2, 1/Î¶(2).      ,   -            . <br><br>     , ,          40%  .      ,      ,        â€¦      .  ,    ,  ,   ,  ,       .  -      -  -,          ,          ,          . ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     . <br><br>    ,   :      ,          .     ,       â€”               (, , ),  Â«Â»  ,       ,     .      ,    .  ,   ,    ,             .             .     . <br><br> ,    â€”  -      ,      ,       . ,    16/16-  ,              ,    16/16     ++    . <br><br><h2>  3 â€”    </h2><br><hr><br> ,         . ,              .        <b></b> ,      ,           ,    ,  ,      ( ,     â€”      ,            . ,     ,       ,           ). <br><br>     ,   ,     ,    -       .       ,         ,          .  ,      ,     ,  ,    <b></b> .        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam implementasi pertama saya, saya melihat jumlah bit yang diperlukan untuk pembilang dan penyebut, mengambil maksimum untuk keduanya, dan menggeser keduanya dengan jumlah bit ini (membulatkan ke bilangan bulat terdekat). </font><font style="vertical-align: inherit;">Ketika ini diterapkan pada operator penjumlahan dan multiplikasi, semuanya mulai terlihat cukup dapat diterima:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angka rasional 65-bit dikurangi oleh GCD dan normalisasi</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i>   </i> <br><br>      ,               .     32/32 (65 ) 16/16 (33 ),      !    ,        ,        .     ,       .        . <br><br><h2>  4 â€”    </h2><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, saya memutuskan untuk mengalihkan perhatian dan berhenti mencari alasan - jika saya ingin menemukan sesuatu yang menarik untuk dirender dalam bilangan rasional, maka mereka harus menempati 32 bit dan tidak lebih. Lebih baik menemukan ide yang bagus atau berhenti, dan akhiri di sana (ini adalah awal dari eksperimen malam kedua).</font></font><br><br>   ,       ,          . ,      â€”        ,    . ,   ,    .    ,     ,  .             .   ,              ,  Â«Â»   .              .        16/16,     32-    16/16,   5/27  13/19,  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu layak untuk dicoba. </font><font style="vertical-align: inherit;">Bagaimanapun, beberapa baris kode pengemasan / pembongkaran di setter internal dan getter dapat ditulis dengan cepat. </font><font style="vertical-align: inherit;">Skema yang paling logis bagi saya sepertinya 1 | 5 | 26, yaitu:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 bit: tanda </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-bit: posisi garis fraksi (B) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26-bit: data pembilang dan penyebut gabungan; </font><font style="vertical-align: inherit;">pembilangnya adalah bit 26-B atas, penyebutnya adalah bit B lebih rendah,</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana bilangan pecahan (B) menentukan ukuran penyebut. </font><font style="vertical-align: inherit;">Misalnya, angka 7/3 akan ditulis sebagai</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/3 = 0 00010 000000000000000000000111 11, </font></font></blockquote><br>   0   ,   2   ( 3),     2 ,       . <br><br>  ,     IEEE754,     :       Â«1Â»,           .       .     Â«3Â»      Â«1Â»     Â«1Â»: <br><br><blockquote> 7/3 = 0 00001 0000000000000000000000111 1 </blockquote><br>         ,       :      ,     ,    1        .  ,               ,       2 <sup>26</sup> ,      .   !           , Â«rationalÂ»,       ,              â€”        ,       (Â«intÂ»  Â«floatÂ»)        !    ,          Â«intÂ»  Â«rationalÂ».    ,           . <br><br>  ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i>32-     <b> </b> (1|5|26)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i>32-    <b></b></i> <br><br> --, !   -    ,           ,      - .       . ,  ,           ,    ,        .                (  ),  ,            . <br><br>           (     â€”       ).         (      )           ,     GPU  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.shadertoy.com/view/Xd2fzR</a> . <br><br>       C++,         .    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i>32-     <b> </b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32-bit floating </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point</font></font></b></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;"> standar</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wow, ini sangat bagus! </font><font style="vertical-align: inherit;">Meskipun kebocoran cahaya terlihat jelas di sudut-sudut di mana tepi lantai dan langit-langit terhubung. </font><font style="vertical-align: inherit;">Lihatlah mereka dalam perkiraan: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin mereka disebabkan oleh masalah dalam implementasi saya dari persimpangan sinar dan kotak persegi panjang, yang hanya dinyatakan dalam bilangan rasional; </font><font style="vertical-align: inherit;">Saya tidak akan terkejut. </font><font style="vertical-align: inherit;">Atau mungkin saya berlari ke batas-batas apa angka rasional mampu. </font><font style="vertical-align: inherit;">Namun, saya cukup senang. </font><font style="vertical-align: inherit;">Selain itu, saya memiliki perubahan dan percobaan lain yang ingin saya uji untuk waktu singkat yang tersisa:</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa eksperimen lain </font></font></h2><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aritmatika yang tepat dalam 64 bit </font></font></h3><br>         64-  ,   32- (1|5|26)      .     64-     ? <br><br>      1|6|57 (       x64   ).  57  /      .              <b></b>  (         ,       ).    !   ,      ,       ,      .     ,    ,     Â«Â»  .  .  ,  ,  64      ,       .        :   - ,      ,     ,    ? ,        Â«Â»  ?        ,        . <br><br><h3>   </h3><br>   ()             .           .     ( <b></b> )       (  ),        .      â€”       ,       ,      .             .      . <br><br>   :   ,       <b>x</b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (Â«Â» ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  Setelah mencari di Wikipedia, saya menemukan bahwa persamaan khusus ini disebut "persamaan Pell yang Dimodifikasi".  Ada algoritma yang menemukan nilai <b>x</b> dan <b>y</b> terkecil untuk menyelesaikan persamaan ini.  Sayangnya, perhatian saya dengan cepat beralih ke matematika Diophantine lain yang penasaran, dan saya tidak melanjutkan penerapan salah satu dari algoritma ini. <br><br><h3>  Pengurangan yang lebih efektif </h3><br>  Pada menit-menit terakhir malam itu, saya berpikir tentang mengeksplorasi ide menggunakan banyak anggota yang bergabung dalam operator geometris yang kompleks, misalnya, dalam produk vektor.  Katakanlah komponen pertama dari produk vektor adalah <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  dengan asumsi bahwa sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Ini berarti bahwa sekarang saya dapat mencoba menemukan pembagi umum, misalnya, antara a dan d, atau e dan h, dan menggunakannya untuk pengurangan awal. <br><br>  Saya punya ide lain: jika pada tahap tertentu kecepatan rendering menjadi masalah, maka Anda dapat sepenuhnya menonaktifkan langkah-langkah mencari GCD dan hanya menerapkan normalisasi.  Pemeriksaan cepat menunjukkan bahwa dalam kasus ini, gambar yang dihasilkan masih tetap dapat diterima dan bekerja dengan baik pada kecepatan yang jauh lebih tinggi.  Namun, dalam kasus ini, tentu saja, kami mendapatkan hasil yang lebih akurat sedikit. <br><br>  Sebagai kompromi, Anda dapat menolak untuk menerapkan prosedur atau skema GCD, dan menggunakan sesuatu yang sederhana secara matematis, sulit dikodekan dalam kode dan efektif, menentukan pembagian dengan hanya 2, 3, dan 5. Meskipun kami tidak akan menemukan jumlah pembagi yang lengkap, oleh dalam praktiknya, ini akan mengarah pada menemukan sejumlah besar singkatan.  Pikirkan tentang hal ini - keterbagian dengan 2 terjadi tiga kali lebih sering daripada dibagikan dengan 7, dan 20 kali lebih sering daripada dibagi dengan 41! <br><br><h2>  Kesimpulan </h2><br><hr><br>  Setelah percobaan ini, saya mulai percaya bahwa representasi bilangan mungkin didasarkan pada bilangan rasional, mirip dengan apa yang saya sebut "fraksi garis mengambang".  Representasi yang kompatibel dengan bilangan bulat dan mampu melakukan banyak operasi dalam aritmatika yang tepat untuk banyak tugas (asalkan data input disajikan dalam bentuk rasional).  Versi 64-bit (1 | 6 | 57) memiliki potensi besar, meskipun versi 32-bit (1 | 5 | 26) telah menciptakan rendering yang menarik. <br><br>  Jika itu bukan percobaan untuk dua malam, tetapi sesuatu yang profesional dibuat di studio atau perusahaan, maka di masa depan langkah-langkah berikut dapat diambil: <br><br>  * Dapatkan histogram jumlah piksel yang akurat dan tidak terlacak (dengan kata lain, frekuensi eksekusi normalisasi) <br>  * Cobalah untuk menerapkan pengurangan kode-keras pada pembagi 2, 3, dan 5 dan mengukur persentase piksel yang tepat yang hilang <br>  * Tampilkan perbedaan piksel antara rendering titik mengambang dan rendering titik mengambang fraksi <br>  * Temukan cara cerdik untuk menggunakan nilai yang tidak digunakan dari format bit "pecahan garis mengambang", misalnya, untuk menunjukkan Inf dan NaN <br>  * Menerapkan deteksi NaN, Inf, underflow, overflow. <br><br>  Secara keseluruhan, ini adalah studi yang menarik.  Dalam prosesnya, saya menemukan beberapa kejutan, muncul dengan satu penemuan kecil dan belajar banyak tentang persamaan Pell, akar kuadrat, GCD, mekanisme internal x86_64, fungsi zeta Riemann dan beberapa aspek lainnya.  Saya sangat senang dengan ini! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448558/">https://habr.com/ru/post/id448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448544/index.html">Bundel dalam baja. Bagaimana mereka terbentuk</a></li>
<li><a href="../id448546/index.html">UITableView header dan footer ukuran otomatis dengan AutoLayout</a></li>
<li><a href="../id448548/index.html">Konstruksi dalam seni: dari Brueghel ke Vasya Lozhkin</a></li>
<li><a href="../id448550/index.html">Kontes Laporan di #PAYMENTSECURITY 2019 Dibuka</a></li>
<li><a href="../id448552/index.html">ProLiant Series 100 - The Lost Younger Brother</a></li>
<li><a href="../id448560/index.html">Rencana transformasi AI: bagaimana mengelola perusahaan di era AI?</a></li>
<li><a href="../id448562/index.html">Google Membantu Polisi Menemukan Perangkat Dekat Tempat Tindak Pidana Menggunakan Data Lokasi</a></li>
<li><a href="../id448564/index.html">Yang pertama dalam kelompok - yang pertama jatuh: penilaian risiko kepemimpinan pada kelompok hewan yang diatur sendiri</a></li>
<li><a href="../id448568/index.html">Cara menerapkan ISO 27001: petunjuk penggunaan</a></li>
<li><a href="../id448570/index.html">Kami memperkirakan throughput saluran MIMO (termasuk algoritma penuangan air)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>