<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèª ü§¥üèæ ü§´ Ich muss schnell gehen: Auf Geschwindigkeit in iOS bauen. Teil 2 üëèüèæ üå∫ üíáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal befinden Sie sich in einer Situation, in der Ihre App keine gute Leistung erbringt. Hier sind einige Instrumente, die Sie verwenden k√∂nnen, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ich muss schnell gehen: Auf Geschwindigkeit in iOS bauen. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/436440/"><img src="https://habrastorage.org/webt/tz/wv/z9/tzwvz9iexzkjdiqq7-3qrb6226w.png"><br><br>  Manchmal befinden Sie sich in einer Situation, in der Ihre App keine gute Leistung erbringt.  Hier sind einige Instrumente, die Sie verwenden k√∂nnen, und Best Practices, die Sie implementieren k√∂nnen, um die Dinge zu verbessern. <a name="habracut"></a><br><br>  Dies ist der zweite Teil des Artikels, der auf dem Keynote-Vortrag von Luke Parham, einem iOS-Ingenieur bei Fyusion und Autor von Tutorials f√ºr die iOS-Entwicklung auf RayWenderlich.com, auf der International Mobile Developers Conference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV</a> im Jahr 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> . <br><br><h2>  Kernanimationsinstrument </h2><br>  Wenn Sie viele Profile erstellt und alle Engp√§sse festgestellt haben, treten manchmal immer noch Leistungsprobleme auf.  Dies liegt an der Funktionsweise der Benutzeroberfl√§che in iOS.  Jedes Mal, wenn Sie Frames festlegen oder UIViews erstellen, geschieht tats√§chlich unter der Haube eine CATransaction, oder das System erstellt sie f√ºr Sie.  Und diese werden an einen Gegenstand namens "Render-Server" verschickt.  Der Rendering-Server ist f√ºr die Erstellung von Animationen verantwortlich.  Wenn Sie ein UIView animateWith ausf√ºhren: Was auch immer, dies geschieht alles auf dem Render-Server, der ein weiterer Thread ist und alle Animationen der App verarbeitet. <br><br><img src="https://habrastorage.org/webt/pl/st/mf/plstmfhgbvefqbeoxgair-w4yh0.jpeg"><br><br>  Hier ist ein Zeitprofiler, der oben eine Bildratenanzeige hat.  Und unten finden Sie die wichtigsten Debug-Optionen.  Wir werden √ºber die zwei wichtigsten und am einfachsten zu behebenden Probleme berichten. <br><br><img src="https://habrastorage.org/webt/wv/qv/q_/wvqvq_97keqipatnlv6fettbkmk.jpeg"><br><br>  Die erste ist farbgemischte Schichten.  Dies ist wirklich einfach zu beheben.  Und das bringt uns zum ersten Abschnitt der Leistungspolizei.  Grunds√§tzlich haben viele Apps Probleme: Selbst iMessage, die beliebte Apple-App, macht eine Menge nicht wirklich gro√üartiger Dinge.  Hier sehen wir, dass es viel Rot gibt: <br><br><img src="https://habrastorage.org/webt/ym/n6/ei/ymn6eidnyg-8hgprlklb8fezsey.jpeg"><br><br>  Rot bedeutet, dass Sie Etiketten mit wei√üem Hintergrund haben.  Und dann befinden sie sich auf einem anderen wei√üen Hintergrund und sind aus irgendeinem Grund nicht so eingestellt, dass sie undurchsichtig sind.  Der Mixer mischt also diese Farben, Wei√ü und Wei√ü, und erh√§lt dadurch eine wei√üe Farbe.  F√ºr jedes Pixel mit Rot werden zus√§tzliche Berechnungen ohne Nutzen durchgef√ºhrt. Im Hintergrund wird immer noch Wei√ü angezeigt. <br><br>  Um dies zu vermeiden, k√∂nnen Sie Ebenen nach M√∂glichkeit undurchsichtig machen, wenn sie dieselbe Farbe und dieselbe Farbe haben.  Wenn die Unteransicht dieselbe Hintergrundfarbe hat, ist eine √úberblendung nicht erforderlich.  Alles, was Sie tun m√ºssen, ist, die Deckkraft Ihrer Ebenen auf 1 zu setzen und dann sicherzustellen, dass die Hintergrundfarbe eingestellt ist.  Wenn Ihre Hintergrundfarbe klar ist, ist sie immer nicht undurchsichtig. <br><br><img src="https://habrastorage.org/webt/dk/of/us/dkofush4_wsglsxcge8m2tygf5q.jpeg"><br><br><h3>  Offscreen-Rendering </h3><br>  Offscreen-gerenderte Elemente werden gelb angezeigt, wenn Sie diese Option aktivieren.  Das Sch√∂ne am Core Animation-Instrument ist, dass Sie andere Apps sehen k√∂nnen.  Sie k√∂nnen diese Optionen aktivieren und dann zu einer beliebigen App in Ihrem System wechseln, um zu sehen, was sie falsch machen.  In diesem Fall hat Instagram oben diese kleinen Blasen, die Ihnen die Geschichten der Leute zeigen. <br><br><img src="https://habrastorage.org/webt/tq/vw/vr/tqvwvrzd2lo4se8-1s9iojgbqri.jpeg"><br><br>  Wie Sie sehen k√∂nnen, sind sie alle gelb.  Auf dem iPhone 5 sind sie aggressiv langsam.  Dies liegt daran, dass das Rendern au√üerhalb des Bildschirms viel schlechter ist als das Mischen von Alpha.  Es blockiert die GPU.  Am Ende m√ºssen zus√§tzliche Berechnungen zwischen der GPU und der CPU durchgef√ºhrt werden, sodass Sie zus√§tzliche Verz√∂gerungen erhalten, die die meiste Zeit nicht erforderlich sind. <br><br><h3>  Bezier-Pfad statt Kurvenfahrt </h3><br>  Die n√§chste Regel: Verwenden Sie nicht die Eigenschaft Eckenradius.  Wenn Sie eine Ansicht haben und view.layer.cornerRadius festlegen, wird immer ein Off-Screen-Rendering eingef√ºhrt.  Stattdessen k√∂nnen Sie einen Bezier-Pfad und die gleiche Art von CGBitmap-Material von fr√ºher verwenden.  In diesem Fall ein UIGraphics-Kontext.  Diese Funktion arbeitet mit UIImage, das eine Gr√∂√üe annimmt, abgerundete Ecken basierend auf dieser Gr√∂√üe erstellt und einen Bezierpfad zum Abschneiden verwendet.  Dann schneiden wir das Bild ab und geben es aus dem UIImage-Kontext zur√ºck.  Dies gibt also ein vorgerundetes Bild zur√ºck, anstatt die Ansicht zu runden, in der sich das Bild befindet. <br><br><img src="https://habrastorage.org/webt/fy/6k/_8/fy6k_8ymknn7sd52mzccdrjj-ny.jpeg"><br><br>  Das letzte Beispiel.  Hier ist Twitter und dies ist eine Echtzeitansicht dieser laufenden Animation.  Es soll sich √∂ffnen und Ihnen die Informationen anzeigen, aber all dieser Text und das gesamte Material wurden au√üerhalb des Bildschirms gerendert, sodass die Animation auf ein Crawlen verlangsamt wurde.  Dies ist die am wenigsten leistungsf√§hige Sache, die ich jemals in einer App im App Store gefunden habe. <br><br><img src="https://habrastorage.org/webt/5a/kw/uk/5akwuksf-c6laq1eyzdd_njtpqm.gif"><br><br>  Wie ist das passiert?  Eine Sache, die dazu f√ºhrt, ist die shouldRasterize-Eigenschaft eines CALayer.  Dies ist eine Option auf einer Ebene, mit der Sie gerenderte Texturen zwischenspeichern k√∂nnen.  Es gibt viele seltsame Regeln.  Wenn es in einer bestimmten Anzahl von Millisekunden nicht verwendet wurde, verl√§sst es den Cache.  Wenn es dann den Cache verl√§sst, wird es in jedem Frame au√üerhalb des Bildschirms gerendert.  Es ist die m√∂glichen Vorteile, die es hat, nicht wirklich wert.  Und es ist schwer zu √ºberpr√ºfen, ob es Ihnen tats√§chlich zugute kommt. <br><br><h3>  Zusammenfassung </h3><br>  Vermeiden Sie das Rendern au√üerhalb des Bildschirms und das Mischen von Alpha, wenn Sie k√∂nnen.  Alpha-Blending ist manchmal notwendig.  Es ist besser als das Rendern au√üerhalb des Bildschirms.  Das Rendern au√üerhalb des Bildschirms erfolgt aus mehreren Gr√ºnden.  Es kann aus Schatten geschehen;  es kann durch Eckenrundung passieren;  es kann durch Maskieren passieren. <br><br>  Machen Sie Ansichten nach M√∂glichkeit undurchsichtig.  Verwenden Sie die Eigenschaft "Eckenradius" nicht so oft wie m√∂glich mit Bezier-Pfaden.  Verwenden Sie die Ebenenschatteneigenschaften auch nicht, wenn Sie Textschatten ausf√ºhren.  Sie k√∂nnen stattdessen NSShadow verwenden. <br><br><h2>  Aktivit√§tsspur </h2><br>  Die Aktivit√§tsverfolgung ist eine Art viel niedrigere Version von etwas, das der Zeitprofiler tun w√ºrde.  Sie erhalten einen √úberblick √ºber alle Ihre Threads und deren Interaktion.  Und es ist ziemlich kompliziert.  Aber es hat wirklich sch√∂ne Funktionen, die Sie einrichten k√∂nnen. <br><br><h3>  Systemablaufverfolgung </h3><br>  Verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemverfolgung</a> , um die Zeiten f√ºr bestimmte Ereignisse zu verfolgen.  Sie k√∂nnen M√∂glichkeiten einrichten, um bestimmte Ereignisse und Codeabschnitte zu verfolgen und zu sehen, wie lange sie in einer realen Anwendung dauern.  Auf diese Weise erhalten Sie detaillierte Informationen zu den Vorg√§ngen in Ihrem System. <br><br><ul><li>  Verwenden Sie "Wegweiser", um zu signalisieren, wenn etwas Wichtiges passiert. </li><li>  Punkte sind einzelne Ereignisse, wenn / wenn Sie sehen m√∂chten, wie eine Animation aufgetreten ist oder so etwas. </li><li>  Regionen haben einen Anfang und ein Ende.  Bei der Bilddecodierung k√∂nnen Sie sehen, wann sie beginnt und wann sie endet, sodass Sie absch√§tzen k√∂nnen, wie lange es im Allgemeinen gedauert hat. </li></ul><br><br><img src="https://habrastorage.org/webt/7r/dr/kg/7rdrkgwhhgvrcbhuizxs02jxkeq.jpeg"><br><br>  So richten Sie eine Systemablaufverfolgungsvorlage ein.  Sie erstellen diese Liste von Ereignissen, die auftreten k√∂nnen.  Nummer eins ist also ein Bilddownload.  Zwei ist eine Bilddecodierung, und drei ist diese Neigungsanimation, die ich hinzugef√ºgt habe.  Grunds√§tzlich richten Sie einige zus√§tzliche Optionen ein, um zu sehen, welche Farben angezeigt werden.  Grunds√§tzlich senden Sie ihm eine Nummer wie 1 oder 2, die je nach dem, was Sie dort einsenden, rot oder gr√ºn ist. <br><br><img src="https://habrastorage.org/webt/ub/lx/qx/ublxqxc19dzgw-gonkynp2xrcfq.jpeg"><br><br>  Wenn Sie sich in Objective-C befinden, m√ºssen Sie diesen kdebug_signpost-Header importieren.  In Swift ist es nur f√ºr Sie verf√ºgbar. <br><br><img src="https://habrastorage.org/webt/xf/k1/zd/xfk1zdzomfbd_wvseum7t215drs.jpeg"><br><br>  Und dann m√ºssen Sie diese Funktion aufrufen, entweder kdebug_signpost oder kdebug_signpost_start und kdebug_ signpost_end.  Und sie arbeiten mit dem Code, den Sie √ºbergeben haben.  Also haben wir diese drei Ereignisse mit diesen Zahlen eingerichtet.  Dann geben Sie diese Nummer hier ein.  Sie √ºbergeben ihm ein Objekt, das im Grunde der Schl√ºssel f√ºr dieses Ereignis ist.  Und dann ist die letzte Zahl die Farbe.  2 ist also so, als w√ºsstest du rot oder so. <br><br>  Ich habe ein Swift-Beispielprojekt auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> .  Ich habe die Dinge irgendwie vereinfacht.  Es gibt einen Anfang und ein Ende, die etwas einfacher zu handhaben sind. <br><br>  So sieht es aus, wenn Sie eine Ablaufverfolgung ausgef√ºhrt haben.  Es wird Ihnen zun√§chst nichts zeigen.  Wenn Sie dann die App beenden, f√ºhrt sie einige Berechnungen durch und zeigt Ihnen hier Informationen. <br><br><img src="https://habrastorage.org/webt/y_/fo/aa/y_foaaegix7nld0j5y8y8drigvs.jpeg"><br><br>  Hier k√∂nnen wir unsere Bilddownloads sehen, die ungef√§hr 200 Millisekunden gedauert haben.  Und dann gibt es eine Bilddecodierung, die etwa 40 Millisekunden gedauert hat.  Das ist wirklich cool, wenn du eine Menge verr√ºckter Dinge in deiner App hast.  Sie k√∂nnen alle diese Ereignisse einrichten und dann einfach anzeigen, wie lange sie jeweils dauern und wie sie miteinander interagieren.  Das ist es f√ºr die Systemverfolgung. <br><br><h2>  Bonus </h2><br>  Schauen Sie sich das Beispiel einer Kameraverlangsamung an, bei der wir sehen k√∂nnen, was passiert, wenn die App AR-Elemente enth√§lt: <br><br><img src="https://habrastorage.org/webt/gv/ir/ht/gvirht8m60rtskuhbx3pld8w9ci.jpeg"><br><br>  Wir haben einen Effekt angewendet, der 26,4% aller Berechnungen f√ºr jeden Frame in Anspruch nahm, um nur einen Effekt zu berechnen.  Und es verlangsamte die Kamera auf etwas Verr√ºcktes wie 10 Bilder pro Sekunde. <br><br>  Als ich mich hier vertiefte und mir diesen gro√üen Engpass ansah, sah ich, dass das Wichtigste, was den gr√∂√üten Teil der Arbeit erledigte, die Verwendung intensiver NSDispatchData war. <br><br><img src="https://habrastorage.org/webt/ks/6w/av/ks6wavxsrckbxvp1vacruzjuigm.jpeg"><br><br>  Dies ist eine Unterklasse von NSData.  Und das alles ist das Abrufen von Bytes mit Bereichsfunktion.  Und das ist eine einfache Funktion.  Es werden lediglich einige Bytes aus den Daten entnommen und an einer anderen Stelle abgelegt.  Es ist nicht zu verr√ºckt, aber anscheinend nahmen alle Dinge, die es intern tat, 18% dieser 26% ein. <br><br>  <b>Regel Nr. 1</b> <br><br>  Es ist eine NSData und es bekommt Bytes.  Das ist eine einfache Objective-C-Sache, aber wenn Sie darauf sto√üen und das ein Engpass ist, ist es Zeit, stattdessen auf C umzusteigen.  Da der Engpass bei einem Aufruf zum Abrufen von Float-Werten lag, k√∂nnen Sie einfach memcpy () verwenden.  Mit memcpy () k√∂nnen Sie einen Datenblock an einen anderen Ort verschieben.  Reduziert ziemlich viel Overhead. <br><br>  Wenn Sie wie NSData suchen, sind diese Klassen wie Tausende von Zeilen.  Da ist also viel los.  In diesem Fall haben wir das Original in rot. <br><br><img src="https://habrastorage.org/webt/0-/g5/bf/0-g5bfby8b-tindkrc-kng4vqsk.jpeg"><br><br>  Hier erhalten Sie einen Bereich, nehmen einige Bytes und kopieren sie in den Puffer.  Die memcpy () - Version ist fast genau dasselbe.  Es sieht nicht komplizierter aus und macht aggressiv weniger Dinge. <br><br><img src="https://habrastorage.org/webt/0_/io/la/0_iolawo_uvibvyrwifn8oioocc.jpeg"><br><br>  Wenn wir das √§ndern und es erneut ausf√ºhren, stieg der Wert von 26% auf 0,6%, indem diese eine Zeile in memcpy () ge√§ndert wurde.  Und dann stieg die Bildrate dramatisch an. <br><br>  <b>Regel Nr. 2</b> <br><br>  Vermeiden Sie √úberzeichnungen, wenn Sie eine Art Rendering-App ausf√ºhren oder wenn Sie so etwas wie eine Ladeleiste ausf√ºhren.  H√§ufig treten Ereignisse mit mehr als 60 Bildern pro Sekunde auf.  In diesem Fall k√∂nnen Sie dieses Update der Benutzeroberfl√§che mithilfe eines CADisplayLink drosseln.  Es hat eine Eigenschaft namens PreferredFramesPerSecond.  Das ist nur f√ºr iOS 10 oder h√∂her.  F√ºr √§ltere m√ºssen Sie es manuell tun, aber es ist immer noch n√ºtzlich. <br><br><img src="https://habrastorage.org/webt/or/zx/bw/orzxbwk4shxzoc_vtsft1pgnhcy.jpeg"><br><br>  Sie k√∂nnen die gew√ºnschte Framerate einstellen.  Viele Male f√ºr das Laden von Balken werde ich es auf ungef√§hr 15 Bilder pro Sekunde einstellen, weil es nicht wirklich wichtig ist.  Es m√ºssen nicht 60 Bilder pro Sekunde aktualisiert werden.  Dies kann Ihnen viel Arbeit ersparen, wenn die Dinge so oder so gleich aussehen. <br><br>  <b>Regel Nr. 3</b> <br><br>  Verwenden Sie IMP-Caching.  Dies ist nur f√ºr Objective-C n√ºtzlich.  Wenn Sie inObjective-C eine Methode unter der Haube aufrufen, rufen Sie tats√§chlich die Objective-C-Funktion zum Senden von Nachrichten auf (objc_msgSend ()).  Wenn Sie diese Anrufe in Spuren sehen, die einen gro√üen Teil der Zeit in Anspruch nehmen, ist dies etwas, das Sie tats√§chlich leicht loswerden k√∂nnen.  Es ist im Grunde die Cache-Tabelle, in der Sie Funktionszeiger nachschlagen, indem Sie ihr einen Namen f√ºr eine Methode geben.  Anstatt diese Suche jedes Mal durchzuf√ºhren, k√∂nnen Sie den Funktionszeiger zwischenspeichern und einfach direkt aufrufen.  Normalerweise ist es mindestens doppelt so schnell. <br><br><img src="https://habrastorage.org/webt/j-/ns/cg/j-nscgmdv5ex1an1s2d2mhn9yxg.jpeg"><br><br>  Wenn Sie keinen zwischengespeicherten Zeiger haben, k√∂nnen Sie ihn durch Aufrufen von methodForSelector abrufen :.  Dann rufen wir diese Methode einfach wie einen regul√§ren Funktionsaufruf auf.  Sie √ºbergeben dem Objekt den Selektor und danach kommen alle Argumente. <br><br>  <b>Regel 4</b> <br><br>  Verwenden Sie kein ARC.  ARC ist etwas, das eine Menge Overhead hinzuf√ºgt.  In Ihrem Code passiert all dieses Zeug und es ist alles mit Retains und Releases bestreut.  Es macht so viel wie es muss, und es macht eine Menge mehr.  Wenn Sie also wirklich optimieren m√∂chten, wenn Sie feststellen, dass Ihre Ablaufverfolgung eine Reihe von Aufbewahrungs- und Freigabeanrufen enth√§lt und diese eine Menge Zeit in Anspruch nehmen, k√∂nnen Sie einfach auf die Nichtverwendung von ARC umsteigen, was viel mehr Arbeit bedeutet. <br><br>  Es ist auch schwierig, Ihre Teamkollegen dazu zu bringen, dem zuzustimmen und nicht sauer zu sein. <br><br>  Verwenden Sie Swift nicht, wenn es besonders leistungsempfindlich ist.  Swift ist eine sch√∂ne Sprache.  Es hat einige wirklich nette Funktionen.  Es wird jedoch auch mehr Boilerplate verwendet, um ein hohes Ma√ü an Funktionalit√§t zu erreichen.  Wenn Sie schnell sein m√∂chten, sollten Sie so nah wie m√∂glich an die Baugruppe heranr√ºcken.  Und das geht schneller, weil es automatisch weniger Code gibt. <br><br>  Wenn Sie sich mit dem Zeug besch√§ftigen, wenn Sie es f√ºr interessant hielten, gibt es ein wirklich gutes Buch mit dem Titel ‚ÄûiOS und MacOS: Performance Tuning‚Äú von Marcel Weiher.  Es geht sehr tief in viele dieser Sachen und viel mehr dar√ºber hinaus.  Ich habe auch eine Videoserie.  Ich mache Videos f√ºr RayWenderlich.  Es gibt eine praktische Instrumentenserie, die ich gemacht habe und die diese Dinge etwas ausf√ºhrlicher erkl√§rt und einige Beispiele enth√§lt.  Wenn Sie also mehr √ºber Instrumente erfahren m√∂chten, k√∂nnen Sie sich diese Videoserie ansehen.  Und dann WWDC-Videos - es gibt eine Menge davon, die verschiedene Performance-Dinge wie diese erkl√§ren. <br><br><h2>  Video </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie den ersten Teil eines Artikels, der auf Lukes Vortrag basiert.  Sehen Sie sich hier den vollst√§ndigen Vortrag an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZIQjrPdFcI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436440/">https://habr.com/ru/post/de436440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436430/index.html">Bekenntnis eines Graphomanen</a></li>
<li><a href="../de436432/index.html">SAP: Was ben√∂tigen Sie, um SAPUI5 zu lernen?</a></li>
<li><a href="../de436434/index.html">PVS-Studio f√ºr Java</a></li>
<li><a href="../de436436/index.html">Das CERN plant den Bau eines neuen Beschleunigers mit einer Tunnell√§nge von 100 km</a></li>
<li><a href="../de436438/index.html">Roscosmos nannte die m√∂glichen Gr√ºnde f√ºr den Verlust der Kommunikation mit dem Spektr-R-Orbitalobservatorium</a></li>
<li><a href="../de436442/index.html">Ein Kopf ist gut und zwei sind besser oder Paarprogrammierung in Aktion</a></li>
<li><a href="../de436444/index.html">Unsichtbare Bereitstellung einer monolithischen Anwendung in der Produktion unter AWS. Pers√∂nliche Erfahrung</a></li>
<li><a href="../de436448/index.html">Test 27 ‚ÄùIPS-Monitor Acer HA270bid: zur Selbstverbesserung</a></li>
<li><a href="../de436450/index.html">Fernbedienung und Kontrolle, Freiheit und Regierung. Gespr√§ch mit Staply</a></li>
<li><a href="../de436452/index.html">7 Bereiche der Linux-Entwicklung im Jahr 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>