<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏽 👝 🖐🏼 Wir beschleunigen die verteilte Verarbeitung großer Graphen nicht nur mit probabilistischen Datenstrukturen 👩🏽‍⚖️ ⛲️ 💿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der wertvollsten Ressourcen eines sozialen Netzwerks ist das „Diagramm der Freundschaften“ - Informationen werden über Verbindungen in dieser Spa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir beschleunigen die verteilte Verarbeitung großer Graphen nicht nur mit probabilistischen Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/465985/"><p><img src="https://habrastorage.org/webt/u1/y0/hk/u1y0hkslkriigc-z1_wkrilk2bm.jpeg"></p><br><p>  Eine der wertvollsten Ressourcen eines sozialen Netzwerks ist das „Diagramm der Freundschaften“ - Informationen werden über Verbindungen in dieser Spalte verbreitet, interessante Inhalte werden an Benutzer gesendet und konstruktives Feedback wird an Inhaltsautoren gesendet.  Gleichzeitig ist das Diagramm eine wichtige Informationsquelle, mit der Sie den Benutzer besser verstehen und den Dienst kontinuierlich verbessern können.  In diesen Fällen, in denen das Diagramm wächst, ist es jedoch technisch immer schwieriger, Informationen daraus zu extrahieren.  In diesem Artikel werden wir über einige Tricks sprechen, die zum Verarbeiten großer Diagramme in OK.ru verwendet werden. </p><a name="habracut"></a><br><p>  Betrachten Sie zunächst eine einfache Aufgabe aus der realen Welt: Bestimmen Sie das Alter des Benutzers.  Wenn Sie das Alter kennen, kann das soziale Netzwerk relevantere Inhalte auswählen und sich besser an die Person anpassen.  Es scheint, dass das Alter bereits beim Erstellen einer Seite in sozialen Netzwerken angegeben wird, aber tatsächlich sind Benutzer häufig gerissen und geben ein anderes Alter als das tatsächliche an.  Ein sozialer Graph kann helfen, die Situation zu korrigieren :). </p><br><p> Nehmen wir zum Beispiel Bob (alle Charaktere im Artikel sind fiktiv, jeder Zufall mit der Realität ist das Ergebnis der Kreativität eines zufälligen Hauses): </p><br><p><img src="https://habrastorage.org/webt/wq/ht/tp/wqhttpoxzxunnad14b4csy9owhe.png"></p><br><p>  Einerseits sind die Hälfte von Bobs Freunden Teenager, was darauf hindeutet, dass Bob auch ein Teenager ist.  Er hat aber auch ältere Freunde, so dass das Vertrauen in die Antwort gering ist.  Zusätzliche Informationen aus dem sozialen Diagramm können helfen, die Antwort zu verdeutlichen: </p><br><p><img src="https://habrastorage.org/webt/w5/ef/ku/w5efku89o5lqu0hrv0kbrl9nte8.png"></p><br><p>  Wenn wir nicht nur die Bögen berücksichtigen, an denen Bob direkt beteiligt ist, sondern auch die Bögen zwischen seinen Freunden, können wir sehen, dass Bob Teil einer dichten Gemeinschaft von Jugendlichen ist, die es uns ermöglicht, mit größerem Vertrauen eine Schlussfolgerung über sein Alter zu ziehen. </p><br><p>  Eine solche Datenstruktur ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ego-Netzwerk</a> oder Ego-Subgraph bekannt und wird seit langem erfolgreich zur Lösung vieler Probleme eingesetzt: Suche nach Communitys, Identifizierung von Bots und Spam, Empfehlungen von Freunden und Inhalten usw.  Die Berechnung des Ego eines Untergraphen für <strong>alle</strong> Benutzer in einem Diagramm mit Hunderten von Millionen Knoten und Dutzenden von Milliarden Bögen ist jedoch mit einer Reihe von "kleinen technischen Schwierigkeiten" behaftet :). </p><br><p>  Das Hauptproblem besteht darin, dass bei der Betrachtung von Informationen über den "zweiten Schritt" in der Grafik eine quadratische Explosion der Anzahl der Verbindungen auftritt.  Beispielsweise kann für einen Benutzer mit 150 direkten Ego-Links ein Untergraph bis zu bis enthalten <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2">150</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-4">150</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-6">149</span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-9">2</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-11"><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-13">11.32</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="27.38ex" height="2.66ex" viewBox="0 -832 11788.4 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-35" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-2B" x="1723" y="0"></use><g transform="translate(2724,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-35" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-2217" x="4448" y="0"></use><g transform="translate(5170,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-34" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-39" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-2F" x="6672" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-32" x="7172" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-3D" x="7951" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-24" x="9007" y="0"></use><g transform="translate(9507,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-2E" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-33" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/company/odnoklassniki/blog/465985/&amp;usg=ALkJrhjp3TwHqh7nOhVt42TLx08CCAWHgw#MJMAIN-32" x="1780" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 150 + 150 * 149/2 = $ 11.32</script>  Links und für einen aktiven Benutzer mit 5.000 Freunden kann der Ego-Untergraph auf mehr als 12.000.000 Links anwachsen. </p><br><p>  Eine zusätzliche Komplikation ist die Tatsache, dass das Diagramm in einer verteilten Umgebung gespeichert ist und kein Knoten ein vollständiges Bild des Diagramms im Speicher hat.  Die Arbeit an einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgewogenen Partitionierung von Graphen wird</a> sowohl in der Akademie als auch in der Industrie durchgeführt, aber selbst die besten Ergebnisse beim Sammeln des Ego-Subgraphen führen zu einer "Alles mit allen" -Kommunikation: Um Informationen über die Freunde der Freunde des Benutzers zu erhalten, müssen Sie zu allen "Partitionen" gehen. in den meisten Fällen. </p><br><p>  Eine der funktionierenden Alternativen in diesem Fall ist die erzwungene Duplizierung von Daten (z. B. Algorithmus 3 in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Google</a> ). Diese Duplizierung ist jedoch auch nicht kostenlos.  Versuchen wir herauszufinden, was in diesem Prozess verbessert werden kann. </p><br><h3 id="naivnyy-algoritm">  Naiver Algorithmus </h3><br><p>  Betrachten Sie zunächst den „naiven“ Algorithmus zum Generieren eines Ego-Subgraphen: </p><br><p><img src="https://habrastorage.org/webt/1o/zn/qz/1oznqzgjwr2iadbhoko7vgvp7hm.png"></p><br><p>  Der Algorithmus nimmt an, dass der ursprüngliche Graph als Adjazenzliste gespeichert ist, d.h.  Informationen zu allen Freunden des Benutzers werden in einem einzigen Datensatz mit der Benutzer-ID im Schlüssel und der Liste der Freunde-ID im Wert gespeichert.  Um den zweiten Schritt zu machen und Informationen über Freunde zu erhalten, benötigen Sie: </p><br><ol><li>  Konvertieren Sie ein Diagramm in die Liste der Kanten, wobei jede Kante ein separater Eintrag ist. </li><li>  Stellen Sie sicher, dass die Liste der Kanten sich selbst verbindet, wodurch alle Pfade in einem Diagramm der Länge 2 angezeigt werden. </li><li>  Nach Pfadanfang gruppieren. </li></ol><br><p>  Bei der Ausgabe für jeden Benutzer erhalten wir Listen mit Pfaden der Länge 2 für jeden Benutzer.  Es sollte hier angemerkt werden, dass die resultierende Struktur tatsächlich eine <strong>zweistufige Nachbarschaft des Benutzers ist</strong> , während der Ego-Untergraph seine Teilmenge ist.  Um den Vorgang abzuschließen, müssen wir daher alle Bögen herausfiltern, die außerhalb der unmittelbaren Freunde liegen. </p><br><p>  Dieser Algorithmus ist gut, da er in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Zeilen auf Scala</a> unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Spark</a> implementiert ist.  Aber die Vorteile enden hier: Für ein Diagramm der industriellen Größe liegt das Volumen der Netzwerkkommunikation über dem Grenzwert und die Betriebszeit wird in Tagen gemessen.  Die Hauptschwierigkeit entsteht durch zwei Shuffle-Operationen, die beim Verbinden und Gruppieren auftreten.  Ist es möglich, die Menge der gesendeten Daten zu reduzieren? </p><br><h3 id="ego-podgraf-v-odin-shuffle">  Ego-Subgraph in einem Shuffle </h3><br><p>  Da unser Diagramm der Freundschaften symmetrisch ist, können Sie die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tomas Schank</a> vorgeschlagenen Optimierungen verwenden: </p><br><ol><li>  Sie können alle Pfade der Länge 2 ohne Verbindung erhalten - wenn Bob Freunde Alice und Harry hat, gibt es Alice-Bob-Harry- und Harry-Bob-Alice-Pfade. </li><li>  Bei der Gruppierung entsprechen zwei Pfade am Eingang derselben neuen Kante.  Der Pfad Bob-Alice-Dave und Bob-Dave-Alice enthält dieselben Informationen für Bob. Dies bedeutet, dass Sie nur jeden zweiten Pfad senden können, indem Sie Benutzer nach ihrer ID sortieren. </li></ol><br><p>  Nach dem Anwenden der Optimierungen sieht das Arbeitsschema folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/zp/jx/da/zpjxdat-xtd9tqukfqt9tta8n0i.png"></p><br><ol><li>  In der ersten Phase der Generierung erhalten wir eine Liste von Pfaden der Länge 2 mit einem Filter der Auftrags-ID. </li><li>  Beim zweiten gruppieren wir nach dem ersten Benutzer auf dem Weg. </li></ol><br><p>  In dieser Einstellung erfüllt der Algorithmus eine Mischoperation, und die Größe der über das Netzwerk übertragenen Daten wird halbiert.  :) :) </p><br><h3 id="raskladyvaem-ego-podgraf-v-pamyati">  Legen Sie den Ego-Untergraphen in Erinnerung </h3><br><p>  Ein wichtiges Thema, das wir noch nicht in Betracht gezogen haben, ist die Zerlegung der Daten im Ego eines Untergraphen in den Speicher.  Um das Diagramm als Ganzes zu speichern, haben wir eine Adjazenzliste verwendet.  Diese Struktur eignet sich für Aufgaben, bei denen das fertige Diagramm als Ganzes durchlaufen werden muss. Sie ist jedoch teuer, wenn Sie ein Diagramm aus Teilen erstellen und subtilere Analysen durchführen möchten.  Die ideale Struktur für unsere Aufgabe sollte effektiv die folgenden Operationen ausführen: </p><br><ol><li>  Die Vereinigung zweier Graphen aus verschiedenen Partitionen. </li><li>  Alle menschlichen Freunde bekommen. </li><li>  Überprüfen, ob zwei Personen verbunden sind. </li><li>  Speicherung im Speicher ohne Boxaufwand. </li></ol><br><p>  Eines der am besten geeigneten Formate für diese Anforderungen ist das Analogon einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spärlichen CSR-Matrix</a> : </p><br><p><img src="https://habrastorage.org/webt/nm/rl/ch/nmrlchko5kxd5cslkvu2kh37vkq.png"></p><br><p>  Das Diagramm wird in diesem Fall in Form von drei Arrays gespeichert: </p><br><ol><li>  Benutzer - Ein sortiertes Array mit der ID aller Benutzer, die am Diagramm teilnehmen. </li><li>  index - Ein Array mit der gleichen Größe wie Benutzer, in dem für jeden Benutzer ein Indexzeiger auf den Beginn von Informationen zu Benutzerbeziehungen im dritten Array gespeichert ist. </li><li>  Freunde - Ein Array mit einer Größe, die der Anzahl der Kanten im Diagramm entspricht, wobei die IDs verwandter Benutzer nacheinander für die entsprechenden IDs von Benutzern angezeigt werden.  Das Array ist nach Verarbeitungsgeschwindigkeit innerhalb der Informationen über die Links eines einzelnen Benutzers sortiert. </li></ol><br><p>  In diesem Format wird die Operation zum Zusammenführen von zwei Graphen in linearer Zeit ausgeführt und die Operation zum Abrufen von Informationen über einen bestimmten Benutzer oder über ein Benutzerpaar pro Logarithmus der Anzahl der Eckpunkte.  In diesem Fall hängt der Overhead im Speicher nicht von der Größe des Diagramms ab, da eine feste Anzahl von Arrays verwendet wird.  Durch Hinzufügen eines vierten Datenarrays mit einer Größe, die der Größe von Freunden entspricht, können Sie zusätzliche Informationen speichern, die mit den Beziehungen im Diagramm verknüpft sind. </p><br><p>  Unter Verwendung der Graphensymmetrieeigenschaft kann nur die Hälfte der "oberen dreieckigen" Bögen gespeichert werden (wenn Bögen nur von einer kleineren ID zu einer größeren ID gespeichert werden). In diesem Fall dauert die Rekonstruktion aller Verbindungen eines einzelnen Benutzers jedoch linear.  Ein guter Kompromiss in diesem Fall kann ein Ansatz sein, der eine "obere dreieckige" Codierung zum Speichern und Übertragen zwischen Knoten und eine symmetrische Codierung beim Laden des Ego des Subgraphen in den Speicher zur Analyse verwendet. </p><br><h3 id="umenshaem-shuffle">  Shuffle reduzieren </h3><br><p>  Selbst nach der Implementierung aller oben genannten Optimierungen funktioniert die Aufgabe, alle Ego-Untergraphen zu erstellen, noch zu lange.  In unserem Fall ca. 6 Stunden bei hoher Auslastung des Clusters.  Ein genauerer Blick zeigt, dass die Hauptursache für die Komplexität immer noch der Mischvorgang ist, während ein erheblicher Teil der am Mischen beteiligten Daten in den folgenden Phasen verworfen wird.  Tatsache ist, dass der beschriebene Ansatz für jeden Benutzer eine vollständige zweistufige Nachbarschaft erstellt, während der Ego-Teilgraph nur eine relativ kleine Teilmenge dieser Nachbarschaft ist, die nur <em>interne</em> Bögen enthält. </p><br><p>  Wenn wir zum Beispiel durch die Verarbeitung von Bobs direkten Nachbarn - Harry und Frank - wussten, dass sie keine Freunde voneinander sind, konnten wir bereits im ersten Schritt solche externen Pfade herausfiltern.  Um jedoch für alle Gary und Frenkov herauszufinden, ob sie Freunde sind, müssen Sie das Freundschaftsdiagramm an allen Rechenknoten in den Speicher ziehen oder während der Verarbeitung jedes Datensatzes Fernaufrufe tätigen, was je nach den Bedingungen der Aufgabe unmöglich ist. </p><br><p>  Dennoch gibt es eine Lösung, wenn wir uns in einem kleinen Prozentsatz der Fälle erlauben, Fehler zu machen, wenn wir eine Freundschaft finden, in der sie tatsächlich nicht existiert.  Es gibt eine ganze Familie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">probabilistischer Datenstrukturen</a> , die es ermöglichen, den Speicherverbrauch während der Datenspeicherung um Größenordnungen zu reduzieren und gleichzeitig eine gewisse Fehlermenge zuzulassen.  Die bekannteste Struktur dieser Art ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Bloom-Filter</a> , der seit vielen Jahren erfolgreich in Industriedatenbanken eingesetzt wird, um Fehler im "Long Tail" -Cache auszugleichen. </p><br><p>  Die Hauptaufgabe des Bloom-Filters besteht darin, die Frage zu beantworten: "Ist dieses Element in den vielen zuvor gesehenen Elementen enthalten?"  Wenn der Filter mit "Nein" antwortet, ist das Element wahrscheinlich nicht in der Menge enthalten, aber wenn er mit "Ja" antwortet, besteht eine geringe Wahrscheinlichkeit, dass das Element immer noch nicht vorhanden ist. </p><br><p>  In unserem Fall ist das "Element" ein Benutzerpaar, und die "Menge" sind alle Kanten des Diagramms.  Dann kann der Bloom-Filter erfolgreich angewendet werden, um die Größe des Shuffle zu reduzieren: </p><br><p><img src="https://habrastorage.org/webt/eo/_e/ua/eo_eua9cf1wxdkxttwevejawbje.png"></p><br><p>  Nachdem wir den Bloom-Filter im Voraus mit Informationen über das Diagramm vorbereitet haben, können wir durch Harrys Freunde herausfinden, dass Bob und Ilona keine Freunde sind, was bedeutet, dass wir Bob keine Informationen über die Verbindung zwischen Gary und Ilona senden müssen.  Die Informationen, dass Harry und Bob alleine Freunde sind, müssen jedoch noch gesendet werden, damit Bob seine Freundschaftsgrafik nach der Gruppierung vollständig wiederherstellen kann. </p><br><h3 id="ubiraem-shuffle">  Shuffle entfernen </h3><br><p>  Nach dem Anwenden des Filters wird die gesendete Datenmenge um ca. 80% reduziert, und die Aufgabe wird in 1 Stunde mit einer moderaten Clusterlast abgeschlossen, sodass Sie andere Aufgaben parallel parallel ausführen können.  In diesem Modus kann es bereits "in Betrieb genommen" und täglich in Betrieb genommen werden, es besteht jedoch noch Optimierungspotenzial. </p><br><p>  So paradox es auch klingen mag, das Problem kann gelöst werden, ohne auf Shuffle zurückzugreifen, wenn Sie sich einen bestimmten Prozentsatz an Fehlern erlauben.  Und der Bloom-Filter kann uns dabei helfen: </p><br><p><img src="https://habrastorage.org/webt/el/zv/ya/elzvyazgijeu9ew7yt8te-xvmm8.png"></p><br><p>  Wenn wir Bobs Freundesliste mit einem Filter durchsehen, stellen wir fest, dass Alice und Charlie mit <em>ziemlicher Sicherheit</em> Freunde sind. Wir können den entsprechenden Bogen sofort zu Bobs Ego-Untergraph hinzufügen.  Der gesamte Vorgang dauert in diesem Fall weniger als 15 Minuten und erfordert keine Datenübertragung über das Netzwerk. Abhängig von den Filtereinstellungen kann jedoch in der Realität ein bestimmter Prozentsatz der Lichtbögen fehlen. </p><br><p>  Die vom Filter hinzugefügten zusätzlichen Bögen führen bei einigen Aufgaben nicht zu erheblichen Verzerrungen: Wenn Sie beispielsweise Dreiecke zählen, können Sie das Ergebnis leicht korrigieren, und wenn Sie Attribute für Algorithmen für maschinelles Lernen vorbereiten, kann die ML-Anpassung selbst die nächste Anpassung lernen. </p><br><p>  Bei einigen Aufgaben führen zusätzliche Bögen jedoch zu einer fatalen Verschlechterung der Qualität des Ergebnisses: Wenn Sie beispielsweise mit einem entfernten Ego (ohne die Oberseite des Benutzers) nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbundenen Komponenten</a> im Ego-Teilgraphen suchen, steigt die Wahrscheinlichkeit einer „Phantombrücke“ zwischen den Komponenten quadratisch in Bezug auf ihre Größe, was dazu führt dass wir fast überall eine große Komponente bekommen. </p><br><p>  Es gibt auch einen Zwischenbereich, in dem der negative Effekt zusätzlicher Bögen experimentell bewertet werden muss: Beispielsweise können einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Community-</a> Suchalgorithmen ein wenig Rauschen recht erfolgreich bewältigen und eine nahezu identische Community-Struktur zurückgeben. </p><br><h3 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h3><br><p>  Ego-Benutzer-Subgraphen sind eine wichtige Informationsquelle, die in OK aktiv verwendet wird, um die Qualität von Empfehlungen zu verbessern, demografische Daten zu verfeinern und Spam zu bekämpfen. Ihre Berechnung ist jedoch mit einer Reihe von Schwierigkeiten verbunden. </p><br><p>  In dem Artikel untersuchten wir die Entwicklung des Ansatzes zur Erstellung von Ego-Subgraphen für alle Benutzer eines sozialen Netzwerks und konnten die Arbeitszeit von den ersten 20 Stunden auf 1 Stunde und bei einem kleinen Prozentsatz von Fehlern auf 10 bis 15 Minuten verbessern. </p><br><p>  Die drei „Säulen“, auf denen die endgültige Entscheidung basiert, sind: </p><br><ol><li>  Verwendung der Graphsymmetrieeigenschaft und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tomas-Schank-</a> Algorithmen. </li><li>  Speichern Sie Ego-Subgraphen mithilfe einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spärlichen CSR-Matrix</a> effizient. </li><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Bloom-Filter</a> , um die Datenübertragung über das Netzwerk zu reduzieren. </li></ol><br><p>  Beispiele für die Entwicklung des Algorithmuscodes finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeppelin-Notizbuch</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465985/">https://habr.com/ru/post/de465985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465975/index.html">SQL-Handbuch: Besseres Schreiben von Abfragen (Teil 2)</a></li>
<li><a href="../de465977/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 31. CDP, Syslog und NTP</a></li>
<li><a href="../de465979/index.html">Denken Sie daran, alles ^ W ist genau das, was Sie brauchen. Erfahrung mit Anki. Teil 1 (einleitend, vorletzt)</a></li>
<li><a href="../de465981/index.html">Meine IBM DB2 Express-C-Verwaltungserfahrung bei Verwendung mit 1C: Enterprise</a></li>
<li><a href="../de465983/index.html">Intel Comet Lake: etwas 14 nm in der zehnten Generation</a></li>
<li><a href="../de465987/index.html">Der Papagei ist gelandet. Die Ankündigung des Buches "Generatives Deep Learning"</a></li>
<li><a href="../de465989/index.html">Produktstrategie und Organisationsstrategie im Sinne des Systems Engineering</a></li>
<li><a href="../de465991/index.html">Arbeiter sauberer schneller Architektur</a></li>
<li><a href="../de465993/index.html">Sie müssen keine digitale Sicherheit sparen</a></li>
<li><a href="../de465995/index.html">LDC - Ausflug</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>