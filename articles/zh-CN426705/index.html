<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛓️ 👨🏾‍🤝‍👨🏼 🏯 Hyperledger Fabric智能合约开发和测试 🔗 📼 🥤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric（HLF）是一个使用分布式分类帐技术（DLT）的开源平台，旨在开发可在由组织团体使用访问规则（允许）创建和控制的商业网络环境中工作的应用程序。 


 该平台以HLF术语支持智能合约-以通用语言（例如Golang，JavaScript，Java）创建的链代码，与以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hyperledger Fabric智能合约开发和测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric（HLF）是一个使用分布式分类帐技术（DLT）的开源平台，旨在开发可在由组织团体使用访问规则（允许）创建和控制的商业网络环境中工作的应用程序。 </p><br><p> 该平台以HLF术语支持智能合约-以通用语言（例如Golang，JavaScript，Java）创建的链代码，与以太坊不同，例如以太坊使用以面向合同的有限功能的Solidity语言（LLL，Viper等）。 </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p> 由于需要部署大量的区块链网络组件，因此链代码的开发和测试可能是一个相当漫长的过程，需要花费大量时间来测试更改。 本文讨论了一种使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CCKit</a>库快速开发和测试HLF Golang智能合约的方法。 </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf"> 基于HLF的应用 </h2><br><p> 从开发人员的角度来看，区块链应用程序包含两个主要部分： </p><br><ul><li>  <strong>链上</strong> -在区块链网络的隔离环境中运行的智能合约（程序），用于确定创建规则和交易属性的组成。 在智能合约中，主要动作是从区块链网络状态读取，更新和删除数据。 应该强调的是，从状态中删除数据会留下该数据存在的信息。 </li><li>  <strong>脱链</strong>是通过SDK与区块链环境进行交互的应用程序（例如，API）。 交互被理解为调用智能合约功能并监视智能合约事件-外部事件可以导致智能合约中的数据更改，而智能合约中的事件可以触发外部系统中的操作。 </li></ul><br><p> 通常通过“家庭”区块链网络节点读取数据。 为了记录数据，应用程序将请求发送到参与特定智能合约“批准策略”的组织的节点。 </p><br><p> 为了开发链下代码（API等），使用了专用的SDK，该SDK封装了与区块链节点的交互，收集响应等。 对于HLF，有用于Go（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1，2</a> ）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.Js</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java的</a> SDK实现。 </p><br><h2 id="komponenty-hyperledger-fabric">  Hyperledger面料组件 </h2><br><h3 id="kanal"> 频道 </h3><br><p> 通道是节点的单独子网，支持独立的区块链（分类帐）以及用于操作智能合约的区块链的当前状态（键值）（ <em>世界状态</em> ）。 主机可以访问任意数量的通道。 </p><br><h3 id="tranzakciya"> 交易额 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hyperledger Fabric</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事务</a>是对区块链状态的原子更新，即执行chaincode方法的结果。 事务包括一个调用链码方法的请求，该链代码方法带有一些由调用节点签名的参数（事务提议），以及来自在其上“确认”事务的节点的一组响应（事务提议响应）（认可）。 响应包含有关“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">读写集”</a>块链状态变化的键值对的信息和服务信息（确认交易的节点的签名和证书）。 因为 各个通道的块链在物理上是分开的，因此只能在一个通道的上下文中执行事务。 </p><br><p> 诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比特币</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以太坊之</a>类的“经典” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块</a>链平台使用由所有节点执行的订购-执行交易周期，这限制了区块链网络的可扩展性。 </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric使用具有3个主要操作的事务执行和分发架构： </p><br><ul><li><p> 执行（ <strong>执行</strong> ）-通过在一个或多个网络节点上运行的智能合约进行创建，交易-分布式注册表状态的原子变化（ <em>认可</em> ） </p><br></li><li><p> 排序-专门的订购<em>者</em>服务使用可插入共识算法将交易排序和分组为块。 </p><br></li><li><p> 验证-由网络节点验证来自<em>订购者</em>的交易，然后再将来自其的信息放入其分布式注册表中 </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p> 这种方法允许您在交易执行阶段进入区块链网络之前执行它，并水平扩展网络节点的运行。 </p><br><h3 id="cheynkod"> 链码 </h3><br><p> 链码（也可以称为智能合约）是用Golang，JavaScript（HLF 1.1+）或Java（HLF 1.3+）编写的程序，它定义用于创建更改区块链状态的交易的规则。 该程序在区块链节点分布式网络的几个独立节点上同时执行，通过协调交易“确认”所需的所有节点上程序执行的结果，为智能合约的执行创建了中立的环境。 </p><br><p> 该代码必须实现一个由方法组成的接口： </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li> 在实例化或升级代码时调用<strong>Init</strong>方法。 此方法对代码状态进行必要的初始化。 在方法代码中区分调用是实例化还是升级，这一点很重要，因此，由于错误，您不会初始化（重置）在代码操作过程中已经接收到非零状态的数据。 </li><li> 访问代码代码的任何功能时，将<strong>调用Invoke</strong>方法。 此方法适用于智能合约的状态。 </li></ul><br><p> 链码安装在区块链网络的对等点上。 在系统级别，代码的每个实例对应于连接到特定网络节点的单独的docker-container，该节点执行调度调用以执行代码。 <br> 与以太坊智能合约不同，可以更新链接逻辑，但是这要求托管代码的所有节点都必须安装更新版本。 </p><br><p> 响应从外部通过SDK调用chaincode函数，chaincode会更改区块链（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Read-Write Set</a> ）以及事件的状态。 链码是指一个特定的通道，并且只能在一个通道中更改数据。 同时，如果安装了代码的主机也可以访问其他通道，则代码的逻辑可以从这些通道读取数据。 </p><br><p> 用于管理区块链网络运行各个方面的特殊链代码称为系统链代码。 </p><br><h3 id="politika-odobreniya-endorsement-policy"> 背书政策 </h3><br><p> 批准策略在特定链码生成的交易级别定义共识规则。 该策略设置确定哪些通道节点应创建事务的规则。 为此，批准策略中指定的每个节点必须运行链接方法（“执行”步骤），执行“模拟”，之后，签名的结果将由发起交易的SDK收集和验证（所有模拟结果必须相同，该策略要求的所有节点的签名都必须存在）。 接下来，SDK将交易发送给<em>订购者</em> ，此后，所有有权访问该通道的节点都将通过<em>订购者</em>接收交易，并执行“验证”步骤。 需要强调的是，并非所有通道节点都必须参与“执行”步骤。 </p><br><p> 批准策略是在实例化或升级代码时确定的。 在1.3版中，不仅可以在链码级别设置策略，而且可以在单个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于状态的认可密钥</a>级别设置策略。 批准政策示例： </p><br><ul><li> 节点A，B，C，D </li><li> 大多数通道节点 </li><li> 来自A，B，C，D，E，F的至少3个节点 </li></ul><br><h3 id="sobytie"> 大事记 </h3><br><p> 事件是一个命名数据集，可让您发布区块链链状态的“更新提要”。 事件属性集定义了链码。 </p><br><h2 id="infrastruktura-seti"> 网络基础设施 </h2><br><h3 id="uzel-seti-peer"> 主持人（对等） </h3><br><p> 主机连接到其具有访问权限的任意数量的通道。 主机维护其版本的区块链和区块链的状态，并提供运行链代码的环境。 如果主机不是批准策略的一部分，则不必使用链码进行设置。 </p><br><p> 在主机软件级别，可以将区块链的当前状态（世界状态）存储在LevelDB或CouchDB中。  CouchDB的优点是它支持使用MongoDB语法的丰富查询。 </p><br><h3 id="orderer"> 订购者 </h3><br><p> 事务管理服务接受已签名的事务作为输入，并确保事务以正确的顺序分布在网络节点上。 </p><br><p> 定购者不运行智能合约，并且不包含区块链和区块链状态。 目前（1.3），有两种<em>订购者</em>实现方式-一个开发<em>单独</em>版本和一个基于Kafka的版本，该版本提供崩溃容错能力。 预计在2018年底将实现支持部分参与者的错误行为（拜占庭容错）的<em>订购者</em>的实施。 </p><br><h3 id="servis-identifikacii-membership-services"> 身份服务 </h3><br><p> 在Hyperledger Fabric网络中，所有成员均具有其他成员已知的身份（身份）。 为了进行标识，使用了公钥基础结构（PKI），通过该PKI，可以为组织，基础结构元素（节点，订购者），应用程序和最终用户创建X.509证书。 结果，可以通过网络级别，单个通道上或智能合约的逻辑中的访问规则来控制对读取和修改数据的访问。 在同一个区块链网络中，各种类型的多种识别服务可以同时工作。 </p><br><h1 id="realizaciya-cheynkoda"> 代码的实现 </h1><br><p>  Chaincode可以被视为具有实现特定业务逻辑的方法的对象。 与经典OOP不同，链码不能具有属性字段。 为了处理状态，该状态的存储由HLF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块</a>链平台提供，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ChainchainStubInterface</a>层，该层在<em>调用</em> <em>Init</em>和<em>Invoke</em>方法时传递。 它提供了接收函数调用参数并更改块链状态的功能： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p> 在基于Solidity开发的以太坊智能合约中，每种方法都具有公共功能。 在Hyperledger Fabric链代码中，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ChaincodeStubInterface</a>函数的<em>Init</em>和<em>Invoke</em>方法。  <em>使用GetArgs（），</em>可以以字节数组的形式获取函数调用的参数，而调用<em>Invoke</em>时数组的第一个元素包含chaincode函数的名称。 因为 任何chaincode方法的调用都通过Invoke方法传递；我们可以说这是前端控制器模式的实现。 </p><br><p> 例如，如果我们考虑为<a href="">ERC-20</a>令牌实现标准以太坊接口，则智能合约应实现以下方法： </p><br><ul><li>  totalSupply（） </li><li>  balanceOf（地址_所有者） </li><li> 转移（地址_to，uint256 _value） </li></ul><br><p> 对于HLF实现， <em>Invoke</em>函数<em>代码</em>必须能够处理其中<em>Invoke</em>调用的第一个参数包含所需方法名称的情况（例如，“ totalSupply”或“ balanceOf”）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>可以看到实现ERC-20标准的示例。 </p><br><h2 id="primery-cheynkodov"> 链码示例 </h2><br><p> 除了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hyperledger Fabric</a>文档外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有</a>一些链代码示例： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块链保险应用程序（2018）</a> </li><li>  <a href="">弹珠</a> </li><li>  <a href="">汽车租赁演示（2017）</a>第 </li></ul><br><p> 在这些示例中，链代码的实现相当冗长，并且包含许多重复的逻辑，用于选择被调用的路由函数），检查参数数量，json编组/解组： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p> 当您只是忘记解组输入数据时，这样的代码组织会导致代码的可读性下降和可能的错误，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> 。 关于HLF开发计划的演讲提到了链代码开发方法的修订版，特别是Java链代码中的注释的引入等，但是，该计划与仅在2019年预期的版本相关。 开发智能合约的经验得出的结论是，如果您在单独的库中选择基本功能，则开发和测试链代码将更加容易。 </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit-用于开发和测试链式代码的库 </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CCKit</a>库总结了开发和测试链代码的实践。 作为开发链码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展的</a>一部分，以Ethereum智能合约<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展的</a> OpenZeppelin库为例。  CCKit使用以下体系结构解决方案： </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta"> 将呼叫路由到智能合约功能 </h2><br><p> 路由是指应用程序响应客户端请求的算法。 例如，几乎所有的http框架都使用这种方法。 路由器使用某些规则来绑定请求和请求处理程序。 关于链码，这是将链码功能的名称与处理程序功能相关联。 </p><br><p> 在智能合约的最新示例中，例如在<a href="">Insurance App中</a> ，它使用链码函数名称和Golang代码形式的函数之间的映射： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  CCKit路由器使用类似于http路由器的方法，并且能够将请求上下文用于链码功能和中间件功能 </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda"> 调用代码的上下文 </h2><br><p> 与通常可以访问http请求参数的http请求上下文类似，CCKit路由器使用对<a href="">智能合约</a>函数的调用上下文，该函数是<em>shim.ChaincodeStubInterface</em>之上的<em>抽象</em> 。 上下文可以是链接函数处理程序的唯一参数;通过它，处理程序可以接收函数调用的参数，以及访问辅助功能以使用智能合约的状态（State），创建答案（Response）等。 </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p> 因为 上下文是一个接口，在某些链式代码中，它可以扩展。 </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware"> 中间件功能 </h2><br><p> 在调用代码代码方法的处理程序之前，将调用中间处理功能（中间件），可以访问对代码方法和下一个中间函数的调用上下文，或者直接访问下一个（下一个）方法的处理程序。 中间件可用于： </p><br><ul><li> 转换输入数据（在下面的示例中， <em>p.String</em>和<em>p.Struct</em>是中间件） </li><li> 使用该功能的限制（例如<em>owner.Only</em> ） </li><li> 请求处理周期的完成 </li><li> 从堆栈中调用下一个中间处理函数 </li></ul><br><h2 id="konvertaciya-struktur-dannyh"> 数据结构转换 </h2><br><p>  chaincode接口假定将字节数组的数组提供给输入，其每个元素都是chaincode函数的属性。 为了防止从链接函数的每个处理程序中的函数调用参数将字节组数据手动编组为golang数据类型（int，字符串，结构，数组），在CCKit路由器中创建路由规则时会设置预期的数据类型，并自动转换类型。 在下面的示例中， <em>carGet</em>函数需要一个字符串类型的参数，而<em>carRegister</em>函数<em>需要一个CarPayload</em>结构。 该参数也被命名，它允许处理程序按名称从上下文中获取其值。 下面将给出处理程序的示例。  Protobuf也可以用于描述链接数据方案。 </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p> 此外，在将数据写入智能合约的状态以及创建事件（golang类型被序列化为字节数组）时，将使用自动转换（编组）。 </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov"> 调试和记录链代码的工具 </h2><br><p> 要调试代码，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">debug</a>扩展，该扩展实现了智能合约方法，该方法将允许您检查智能合约状态下是否存在键，以及直接读取/更改/删除键值。 </p><br><p> 为了在对chaincode函数的调用的上下文中记录日志，可以使用Log（）方法，该方法返回HLF中使用的记录器的实例。 </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta"> 智能合约方法访问控制方法 </h2><br><p> 作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所有者</a>扩展的一部分，实现了用于存储有关实例化链代码的所有者和智能合约方法的访问修饰符（中间件）的信息的基本原语。 </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov"> 智能合约测试工具 </h2><br><p> 部署区块链网络，安装和初始化链代码是一个相当复杂的设置，而且过程很长。 通过使用智能合约的DEV模式，可以减少重新安装/升级智能合约代码的时间，但是，更新代码的过程仍然很慢。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">shim</a>软件包包含<a href="">MockStub</a>的实现，该实现包装对代码的调用，以模拟其在HLF区块链环境中的操作。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MockStub</a>可以使您几乎立即获得测试结果，并可以减少开发时间。 如果我们考虑HLF中代码的一般操作方案，则MockStub本质上替代了SDK，从而使您可以调用代码的功能，并模拟在主机上启动代码的环境。 </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  HLF交付中的MockStub包含了<em>shim.ChaincodeStubInterface</em>接口的几乎所有方法的实现，但是，在当前版本（1.3）中，它缺少某些重要方法的实现，例如GetCreator。 因为 链代码可以使用此方法来获得用于访问控制的事务创建者的证书，为了最大程度地覆盖测试，具有此方法的存根的能力很重要。 </p><br><p>  CCKit库包含MockStub的扩展版本，其中包含缺少的方法的实现以及用于事件通道的方法等。 </p><br><h2 id="primer-cheynkoda"> 链码示例 </h2><br><p> 例如，让我们创建一个简单的链码来存储有关已注册汽车的信息 </p><br><h3 id="model-dannyh"> 资料模型 </h3><br><p> 代码的状态是键值存储，其中键是字符串，值是字节数组。 基本做法是将经过分类处理的golang数据结构实例存储为值。 因此，要使用链码中的数据，从状态读取后，需要解组字节数组。 </p><br><p> 为了记录有关汽车的信息，我们将使用以下属性集： </p><br><ul><li> 标识符（车号） </li><li> 汽车模型 </li><li> 车主信息 </li><li> 数据变更时间信息 </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p> 要将数据传输到链码，请创建一个单独的结构，该结构仅包含来自链码外部的字段： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami"> 使用按键 </h3><br><p> 智能合约状态下的记录键是一个字符串。 它还支持创建复合键的功能，其中组合键的各个部分之间用零字节（ <em>U + 0000</em> ）分隔。 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p> 在<em>CCKit中，</em>如果传输的结构支持<em>Keyer</em>接口，则使用智能合约状态<em>的</em>功能可以自动创建记录密钥。 </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p> 要记录汽车，密钥生成功能如下： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya"> 智能合约功能声明（路由） </h3><br><p> 在链码的构造方法中，我们可以定义链码的功能及其参数。 汽车登记代码中将包含3个功能 </p><br><ul><li>  carList，返回一个Car结构数组 </li><li>  carGet，接受汽车标识符并返回汽车结构 </li><li>  carRegister，接受CarPayload结构的序列化实例，并返回注册结果。 仅链代码的所有者可以访问此方法，链代码的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所有者</a>使用中间件从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">所有者</a>包中保存该代码 </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p> 上面的示例使用<a href="">Chaincode</a>结构，其中将<em>Init</em>和<em>Invoke</em>方法的处理委托给路由器： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p> 使用路由器和基本的Chaincode结构可以重用处理程序功能。 例如，要在不检查对<code>carRegister</code>函数的访问权限的情况下实现链<code>carRegister</code> ，只需创建一个新的<a href="">构造方法即可</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta"> 实施智能合约的功能 </h3><br><p>  Golang函数<strong>-CCKit</strong>路由器中的智能合约函数处理程序可以分为三种类型： </p><br><ul><li>  <em>StubHandlerFunc-</em>标准处理程序接口，接受<em>shim.ChaincodeStubInterface</em> ，返回标准响应对等<em>体。</em> </li><li>  <em>ContextHandlerFunc-</em>获取上下文并返回对等<em>体</em> </li><li>  <em>HandlerFunc-</em>获取上下文，返回接口和错误。 可以返回字节数组，也可以根据创建的对等方自动将任何golang类型转换为字节数组。 响应状态将为<em>shim.Ok</em>或<em>shim.Error</em> ，具体取决于传递的错误。 </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       —        ,     .      BDD – Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p> 因为   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie"> 结论 </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426705/">https://habr.com/ru/post/zh-CN426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426695/index.html">爱好者的机器视觉相机。 如何使用相机进行离线导航？</a></li>
<li><a href="../zh-CN426697/index.html">在Android下使用LibUsb设备</a></li>
<li><a href="../zh-CN426699/index.html">使用pytest进行Python测试。 简单，快速，高效和可扩展。 前言与引言</a></li>
<li><a href="../zh-CN426701/index.html">Flutter-跨平台开发的新视角</a></li>
<li><a href="../zh-CN426703/index.html">明斯克的DataVizDay有趣的是</a></li>
<li><a href="../zh-CN426707/index.html">审批系统。 我们如何发明自行车</a></li>
<li><a href="../zh-CN426709/index.html">JavaScript计时器：所有您需要知道的</a></li>
<li><a href="../zh-CN426713/index.html">英特尔至强W-3175X：家庭用28核</a></li>
<li><a href="../zh-CN426717/index.html">欺骗的错觉：基于逆向预测的视觉光学错觉</a></li>
<li><a href="../zh-CN426719/index.html">SIBUR上的数据科学黑客马拉松：过去的样子</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>