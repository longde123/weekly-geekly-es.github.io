<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöä üôáüèΩ ü¶å Guide Node.js, partie 6: boucle d'√©v√©nement, pile d'appels, minuteurs üë®üèª‚Äçüåæ üöÖ üèÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, dans la sixi√®me partie de la traduction du manuel Node.js, nous parlerons de la boucle d'√©v√©nements, de la pile d'appels, de la fonction ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide Node.js, partie 6: boucle d'√©v√©nement, pile d'appels, minuteurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Aujourd'hui, dans la sixi√®me partie de la traduction du manuel Node.js, nous parlerons de la boucle d'√©v√©nements, de la pile d'appels, de la fonction <code>process.nextTick()</code> et des temporisateurs.  La compr√©hension de ces m√©canismes et d'autres m√©canismes Node.js est l'une des pierres angulaires du d√©veloppement d'applications r√©ussi pour cette plate-forme. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Nous vous conseillons de lire] Autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales et mise en route</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript, V8, quelques astuces de d√©veloppement</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H√©bergement, REPL, travailler avec la console, les modules</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers npm, package.json et package-lock.json</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm et npx</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucle d'√©v√©nements, pile d'appels, temporisateurs</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 8: Protocoles HTTP et WebSocket</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, partie 9: utilisation du syst√®me de fichiers</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 10: Modules standard, flux, bases de donn√©es, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF complet du guide Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Boucle d'√©v√©nement</font> </h2><br>  Si vous voulez comprendre comment le code JavaScript est ex√©cut√©, la boucle d'√©v√©nement est l'un des concepts les plus importants que vous devez comprendre.  Ici, nous allons parler du fonctionnement de JavaScript en mode monothread et de la gestion des fonctions asynchrones. <br><br>  Je d√©veloppe JavaScript depuis de nombreuses ann√©es, mais je ne peux pas dire que j'ai compl√®tement compris comment tout fonctionne, pour ainsi dire, "sous le capot".  Le programmeur peut ne pas √™tre au courant des subtilit√©s du dispositif des sous-syst√®mes internes de l'environnement dans lequel il travaille.  Mais il est g√©n√©ralement utile d'avoir au moins une id√©e g√©n√©rale de ces choses. <br><br>  Le code JavaScript que vous √©crivez s'ex√©cute en mode monothread.  √Ä un certain moment, une seule action est ex√©cut√©e.  Cette limitation est en fait tr√®s utile.  Cela simplifie consid√©rablement le fonctionnement des programmes, √©liminant ainsi la n√©cessit√© pour les programmeurs de r√©soudre des probl√®mes sp√©cifiques aux environnements multithreads. <br><br>  En fait, un programmeur JS doit faire attention uniquement aux actions que son code effectue exactement et essayer d'√©viter les situations qui provoquent le blocage du thread principal.  Par exemple - passer des appels r√©seau en mode synchrone et des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cycles</a> sans fin. <br><br>  En r√®gle g√©n√©rale, les navigateurs, dans chaque onglet ouvert, ont leur propre boucle d'√©v√©nements.  Cela vous permet d'ex√©cuter le code de chaque page dans un environnement isol√© et d'√©viter les situations o√π une certaine page, dans le code dont il existe une boucle infinie ou des calculs lourds sont effectu√©s, est capable de ¬´suspendre¬ª l'int√©gralit√© du navigateur.  Le navigateur prend en charge le travail de nombreuses boucles d'√©v√©nements simultan√©ment existantes, utilis√©es, par exemple, pour traiter les appels vers diverses API.  De plus, une boucle d'√©v√©nement propri√©taire est utilis√©e pour prendre en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les travailleurs Web</a> . <br><br>  La chose la plus importante dont un programmeur JavaScript doit constamment se souvenir est que son code utilise sa propre boucle d'√©v√©nements, donc le code doit √™tre √©crit pour que cette boucle d'√©v√©nements ne soit pas bloqu√©e. <br><br><h2>  <font color="#3AC1EF">Verrou de boucle d'√©v√©nement</font> </h2><br>  Tout code JavaScript qui prend trop de temps √† ex√©cuter, c'est-√†-dire un code qui ne prend pas le contr√¥le de la boucle d'√©v√©nements trop longtemps, bloque l'ex√©cution de tout autre code de page.  Cela conduit m√™me √† bloquer le traitement des √©v√©nements de l'interface utilisateur, ce qui se refl√®te dans le fait que l'utilisateur ne peut pas interagir avec les √©l√©ments de la page et travailler normalement avec, par exemple, le d√©filement. <br><br>  Presque tous les m√©canismes d'E / S JavaScript de base ne sont pas bloquants.  Cela s'applique √† la fois au navigateur et √† Node.js.  Parmi ces m√©canismes, par exemple, nous pouvons mentionner les outils pour effectuer des requ√™tes r√©seau utilis√©s dans les environnements client et serveur, et les outils pour travailler avec les fichiers Node.js.  Il existe des m√©thodes synchrones pour effectuer de telles op√©rations, mais elles ne sont utilis√©es que dans des cas particuliers.  C'est pourquoi les rappels traditionnels et les m√©canismes plus r√©cents - promesses et la construction asynchrone / attendent - sont d'une grande importance dans JavaScript. <br><br><h2>  <font color="#3AC1EF">Pile d'appels</font> </h2><br>  La pile d'appels JavaScript est bas√©e sur le principe LIFO (Last In, First Out - Last In, First Out).  La boucle d'√©v√©nements v√©rifie constamment la pile d'appels pour voir si elle a une fonction qui doit √™tre ex√©cut√©e.  Si, lors de l'ex√©cution du code, une fonction y est appel√©e, des informations la concernant sont ajout√©es √† la pile des appels et cette fonction est ex√©cut√©e. <br><br>  Si m√™me avant que vous n'√©tiez pas int√©ress√© par le concept de ¬´pile d'appel¬ª, alors si vous avez rencontr√© des messages d'erreur qui incluent une trace de pile, vous imaginez d√©j√† √† quoi il ressemble.  Ici, par exemple, ressemble √† ceci dans un navigateur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Message d'erreur du navigateur</font></i> <br><br>  Le navigateur, lorsqu'une erreur se produit, rend compte de la s√©quence d'appels aux fonctions, dont les informations sont stock√©es dans la pile d'appels, ce qui vous permet de trouver la source de l'erreur et de comprendre quels appels √† quelles fonctions ont conduit √† la situation. <br><br>  Maintenant que nous avons parl√© de la boucle d'√©v√©nements et de la pile d'appels en termes g√©n√©raux, consid√©rons un exemple qui illustre l'ex√©cution d'un fragment de code et √† quoi ressemble ce processus en termes de boucle d'√©v√©nements et de pile d'appels. <br><br><h2>  <font color="#3AC1EF">Boucle d'√©v√©nement et pile d'appels</font> </h2><br>  Voici le code que nous exp√©rimenterons: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Si ce code est ex√©cut√©, les √©l√©ments suivants arriveront √† la console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Un tel r√©sultat est tout √† fait attendu.  A savoir, lorsque ce code est ex√©cut√©, la fonction <code>foo()</code> est d'abord appel√©e.  √Ä l'int√©rieur de cette fonction, nous appelons d'abord la fonction <code>bar()</code> , puis la fonction <code>baz()</code> .  Dans le m√™me temps, la pile d'appels lors de l'ex√©cution de ce code subit les modifications illustr√©es dans la figure suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Modification de l'√©tat de la pile d'appels lors de l'ex√©cution du code sous enqu√™te</font></i> <br><br>  La boucle d'√©v√©nements, √† chaque it√©ration, v√©rifie s'il y a quelque chose dans la pile des appels, et si c'est le cas, elle le fait jusqu'√† ce que la pile des appels soit vide. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">It√©rations de boucle d'√©v√©nement</font></i> <br><br><h2>  <font color="#3AC1EF">Mise en file d'attente d'une fonction</font> </h2><br>  L'exemple ci-dessus semble assez ordinaire, il n'a rien de sp√©cial: JavaScript trouve le code qui doit √™tre ex√©cut√© et l'ex√©cute dans l'ordre.  Nous parlerons de la fa√ßon de diff√©rer l'ex√©cution de la fonction jusqu'√† ce que la pile d'appels soit effac√©e.  Pour ce faire, la construction suivante est utilis√©e: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Il vous permet d'ex√©cuter la fonction pass√©e √† la fonction <code>setTimeout()</code> apr√®s l'ex√©cution de toutes les autres fonctions appel√©es dans le code de programme. <br><br>  Prenons un exemple: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Ce que ce code imprime peut sembler inattendu: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Lorsque nous ex√©cutons cet exemple, la fonction <code>foo()</code> est appel√©e en premier.  Dans ce document, nous appelons <code>setTimeout()</code> , en passant cette fonction, comme premier argument, <code>bar</code> .  En passant <code>0</code> comme deuxi√®me argument, nous informons le syst√®me que cette fonction doit √™tre ex√©cut√©e le plus t√¥t possible.  Ensuite, nous appelons la fonction <code>baz()</code> . <br><br>  Voici √† quoi ressemblera la pile d'appels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Modification de l'√©tat de la pile d'appels lors de l'ex√©cution du code</font></i> <br><br>  Voici l'ordre dans lequel les fonctions de notre programme seront maintenant ex√©cut√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">It√©rations de boucle d'√©v√©nement</font></i> <br><br>  Pourquoi cela se passe-t-il ainsi? <br><br><h2>  <font color="#3AC1EF">File d'attente des √©v√©nements</font> </h2><br>  Lorsque la fonction <code>setTimeout()</code> est appel√©e, le navigateur ou la plateforme Node.js d√©marre une minuterie.  Une fois que la minuterie a fonctionn√© (dans notre cas, cela se produit imm√©diatement, puisque nous l'avons d√©fini sur 0), la fonction de rappel pass√©e √† <code>setTimeout()</code> entre dans la file d'attente d'√©v√©nements. <br><br>  La file d'attente des √©v√©nements, en ce qui concerne le navigateur, comprend les √©v√©nements d√©clench√©s par l'utilisateur - √©v√©nements provoqu√©s par des clics de souris sur les √©l√©ments de la page, √©v√©nements qui sont d√©clench√©s lorsque les donn√©es sont entr√©es √† partir du clavier.  Les gestionnaires d' <code>onload</code> DOM comme <code>onload</code> , les fonctions appel√©es lors de la r√©ception de r√©ponses aux demandes asynchrones de chargement de donn√©es, sont imm√©diatement l√†.  Ici, ils attendent leur tour de traiter. <br><br>  La boucle d'√©v√©nements donne la priorit√© √† ce qui se trouve dans la pile des appels.  Tout d'abord, il fait tout ce qu'il parvient √† trouver sur la pile, et une fois la pile vide, il proc√®de au traitement de ce qui se trouve dans la file d'attente des √©v√©nements. <br><br>  Nous n'avons pas besoin d'attendre qu'une fonction comme <code>setTimeout()</code> finisse de fonctionner, car des fonctions similaires sont fournies par le navigateur et utilisent leurs propres flux.  Ainsi, par exemple, en d√©finissant le minuteur sur 2 secondes √† l'aide de la fonction <code>setTimeout()</code> , vous ne devriez pas, apr√®s avoir arr√™t√© l'ex√©cution d'un autre code, attendre ces 2 secondes, car le minuteur fonctionne en dehors de votre code. <br><br><h2>  <font color="#3AC1EF">ES6 Job Queue</font> </h2><br>  ECMAScript 2015 (ES6) a introduit le concept de Job Queue, qui est utilis√© par les promesses (elles sont √©galement apparues dans ES6).  Gr√¢ce √† la file d'attente des travaux, le r√©sultat de l'ex√©cution de la fonction asynchrone peut √™tre utilis√© le plus rapidement possible, sans avoir √† attendre que la pile d'appels soit effac√©e. <br><br>  Si une promesse est r√©solue avant la fin de la fonction en cours, le code correspondant sera ex√©cut√© imm√©diatement apr√®s la fin de la fonction en cours. <br><br>  J'ai trouv√© une analogie int√©ressante pour ce dont nous parlons.  Cela peut √™tre compar√© √† des montagnes russes dans un parc d'attractions.  Une fois que vous avez parcouru la colline et que vous voulez recommencer, vous prenez un billet et montez en queue de file.  Voici comment fonctionne la file d'attente des √©v√©nements.  Mais la file d'attente des travaux est diff√©rente.  Ce concept est similaire √† un billet √† prix r√©duit, qui vous donne le droit de faire le prochain voyage imm√©diatement apr√®s avoir termin√© le pr√©c√©dent. <br><br>  Prenons l'exemple suivant: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Voici ce qui sera sorti apr√®s son ex√©cution: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Ce que vous pouvez voir ici montre une s√©rieuse diff√©rence entre les promesses (et la construction async / wait, qui est bas√©e sur elles) et les fonctions asynchrones traditionnelles, dont l'ex√©cution est organis√©e √† l'aide de <code>setTimeout()</code> ou d'autres API de la plate-forme utilis√©e. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  La m√©thode <code>process.nextTick()</code> interagit avec la boucle d'√©v√©nements d'une mani√®re sp√©ciale.  Une tique est un seul cycle complet d'√©v√©nements.  En passant la fonction √† la m√©thode <code>process.nextTick()</code> , nous informons le syst√®me que cette fonction doit √™tre appel√©e une fois l'it√©ration en cours de la boucle d'√©v√©nements termin√©e, avant le d√©but de la suivante.  L'utilisation de cette m√©thode ressemble √† ceci: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Supposons qu'une boucle d'√©v√©nement soit occup√©e √† ex√©cuter du code pour la fonction actuelle.  Une fois cette op√©ration termin√©e, le moteur JavaScript ex√©cutera toutes les fonctions pass√©es √† <code>process.nextTick()</code> lors de l'op√©ration pr√©c√©dente.  En utilisant ce m√©canisme, nous nous effor√ßons de nous assurer qu'une certaine fonction est ex√©cut√©e de mani√®re asynchrone (apr√®s la fonction actuelle), mais d√®s que possible, sans la placer dans la file d'attente. <br><br>  Par exemple, si vous utilisez la construction <code>setTimeout(() =&gt; {}, 0)</code> , la fonction sera ex√©cut√©e √† la prochaine it√©ration de la boucle d'√©v√©nements, c'est-√†-dire bien plus tard que lors de l'utilisation de <code>process.nextTick()</code> dans la m√™me situation.  Cette m√©thode doit √™tre utilis√©e lorsqu'il est n√©cessaire de garantir l'ex√©cution de code au tout d√©but de la prochaine it√©ration de la boucle d'√©v√©nements. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Une autre fonction fournie par Node.js pour l'ex√©cution de code asynchrone est <code>setImmediate()</code> .  Voici comment l'utiliser: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  La fonction de rappel pass√©e √† <code>setImmediate()</code> sera ex√©cut√©e √† la prochaine it√©ration de la boucle d'√©v√©nement. <br><br>  En quoi <code>setImmediate()</code> diff√©rent de <code>setTimeout(() =&gt; {}, 0)</code> (c'est-√†-dire d'un minuteur qui devrait fonctionner d√®s que possible) et de <code>process.nextTick()</code> ? <br><br>  La fonction pass√©e √† <code>process.nextTick()</code> s'ex√©cutera une fois l'it√©ration en cours de la boucle d'√©v√©nements termin√©e.  Autrement dit, une telle fonction sera toujours ex√©cut√©e avant la fonction dont l'ex√©cution est planifi√©e √† l'aide de <code>setTimeout()</code> ou <code>setImmediate()</code> . <br><br>  L'appel de la fonction <code>setTimeout()</code> avec un d√©lai d√©fini de 0 ms est tr√®s similaire √† l'appel de <code>setImmediate()</code> .  L'ordre d'ex√©cution des fonctions qui leur sont transf√©r√©es d√©pend de divers facteurs, mais dans les deux cas, des rappels seront appel√©s √† la prochaine it√©ration de la boucle d'√©v√©nements. <br><br><h2>  <font color="#3AC1EF">Minuteries</font> </h2><br>  Nous avons d√©j√† parl√© de la fonction <code>setTimeout()</code> , qui vous permet de planifier des appels aux rappels qui lui sont pass√©s.  Prenons un peu de temps pour d√©crire plus en d√©tail ses fonctionnalit√©s et consid√©rons une autre fonction, <code>setInterval()</code> , similaire √† celle-ci.  Dans Node.js, les fonctions de travail avec les temporisateurs sont incluses dans le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">temporisateur</a> , mais vous pouvez les utiliser sans connecter ce module dans le code, car elles sont globales. <br><br><h3>  <font color="#3AC1EF">‚ñç fonction setTimeout ()</font> </h3><br>  Rappelez-vous que lorsque vous appelez la fonction <code>setTimeout()</code> , elle re√ßoit un rappel et l'heure, en millisecondes, apr√®s laquelle le rappel sera appel√©.  Prenons un exemple: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Ici, nous passons <code>setTimeout()</code> nouvelle fonction qui est imm√©diatement d√©crite, mais ici nous pouvons utiliser la fonction existante en passant <code>setTimeout()</code> son nom et un ensemble de param√®tres pour l'ex√©cuter.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  La fonction <code>setTimeout()</code> renvoie un identifiant de temporisateur.  Habituellement, il n'est pas utilis√©, mais vous pouvez l'enregistrer et, si n√©cessaire, supprimer le minuteur si le rappel planifi√© n'est plus n√©cessaire: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Z√©ro retard</font> </h3><br>  Dans les sections pr√©c√©dentes, nous avons utilis√© <code>setTimeout()</code> , en le passant, comme le temps apr√®s lequel il est n√©cessaire d'appeler le rappel, <code>0</code> .  Cela signifiait que le rappel serait appel√© d√®s que possible, mais apr√®s l'ach√®vement de la fonction actuelle: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Un tel code affichera les √©l√©ments suivants: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Cette technique est particuli√®rement utile dans les situations o√π, lors de l'ex√©cution de t√¢ches de calcul lourdes, je ne voudrais pas bloquer le thread principal, permettant √† d'autres fonctions d'√™tre ex√©cut√©es, divisant ces t√¢ches en plusieurs √©tapes, ex√©cut√©es en tant <code>setTimeout()</code> . <br><br>  Si nous rappelons la fonction <code>setImmediate()</code> ci-dessus, alors elle est standard dans Node.js, ce qui ne peut pas √™tre dit √† propos des navigateurs (elle est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©ment√©e</a> dans IE et Edge, mais pas dans d'autres). <br><br><h3>  <font color="#3AC1EF">‚ñç fonction setInterval ()</font> </h3><br>  La fonction <code>setInterval()</code> est similaire √† <code>setTimeout()</code> , mais il existe des diff√©rences entre elles.  Au lieu d'ex√©cuter le rappel qui lui est pass√© une fois, <code>setInterval()</code> appellera p√©riodiquement, avec l'intervalle sp√©cifi√©, ce rappel.  Cela continuera, id√©alement, jusqu'au moment o√π le programmeur arr√™tera explicitement ce processus.  Voici comment utiliser cette fonctionnalit√©: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Un rappel pass√© √† la fonction ci-dessus sera appel√© toutes les 2 secondes.  Afin de fournir la possibilit√© d'arr√™ter ce processus, vous devez obtenir l'identifiant du temporisateur retourn√© par <code>setInterval()</code> et utiliser la commande <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Une technique courante consiste √† appeler <code>clearInterval()</code> √† l'int√©rieur du rappel pass√© √† <code>setInterval()</code> lorsqu'une certaine condition est remplie.  Par exemple, le code suivant sera ex√©cut√© p√©riodiquement jusqu'√† ce que la propri√©t√© <code>App.somethingIWait</code> soit <code>App.somethingIWait</code> sur <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç R√©glage r√©cursif setTimeout ()</font> </h3><br>  La fonction <code>setInterval()</code> appellera le rappel qui lui est pass√© toutes les <code>n</code> millisecondes, sans se soucier de savoir si ce rappel s'est termin√© apr√®s son appel pr√©c√©dent. <br><br>  Si chaque appel √† ce rappel n√©cessite toujours le m√™me temps inf√©rieur √† <code>n</code> , aucun probl√®me ne se pose ici. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Appel√© p√©riodiquement, chaque session d'ex√©cution prend le m√™me temps, se situant dans l'intervalle entre les appels</font></i> <br><br>  Peut-√™tre que cela prend un temps diff√©rent pour terminer un rappel, qui est toujours inf√©rieur √† <code>n</code> .  Si, par exemple, nous parlons d'effectuer certaines op√©rations de r√©seau, alors cette situation est tout √† fait attendue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Appel√© p√©riodiquement, chaque session d'ex√©cution prend un temps diff√©rent, se situant entre les appels</font></i> <br><br>  Lorsque vous utilisez <code>setInterval()</code> , une situation peut se produire lorsque le rappel prend plus de <code>n</code> , ce qui conduit √† l'appel suivant avant la fin de l'appel pr√©c√©dent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Appel√© p√©riodiquement, chaque session prend un temps diff√©rent, qui parfois ne correspond pas √† l'intervalle entre les appels</font></i> <br><br>  Afin d'√©viter cette situation, vous pouvez utiliser la technique de r√©glage de minuterie r√©cursive en utilisant <code>setTimeout()</code> .  Le fait est que le prochain rappel est pr√©vu apr√®s la fin de son pr√©c√©dent appel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Avec cette approche, le sc√©nario suivant peut √™tre impl√©ment√©: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Un appel r√©cursif √† setTimeout () pour planifier l'ex√©cution du rappel</font></i> <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Aujourd'hui, nous avons parl√© des m√©canismes internes de Node.js, tels que la boucle d'√©v√©nements, la pile d'appels, et discut√© du travail avec des temporisateurs qui vous permettent de planifier l'ex√©cution de code.  La prochaine fois, nous aborderons le sujet de la programmation asynchrone. <br><br>  <b>Chers lecteurs!</b>  Avez-vous rencontr√© des situations o√π vous avez d√ª utiliser process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424553/">https://habr.com/ru/post/fr424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424537/index.html">Sberbank a lanc√© son propre op√©rateur SberMobile</a></li>
<li><a href="../fr424539/index.html">Java 11: nouveau dans String</a></li>
<li><a href="../fr424541/index.html">Histoire du fiasco UGJ 2018: comment cr√©er un jeu que personne n'aime (ne le faites pas!)</a></li>
<li><a href="../fr424543/index.html">Java 11 / JDK 11: disponibilit√© g√©n√©rale</a></li>
<li><a href="../fr424551/index.html">Warm and tube: cinq balala√Økas sur la technologie audio magn√©tique</a></li>
<li><a href="../fr424555/index.html">Manuel Node.js, partie 7: programmation asynchrone</a></li>
<li><a href="../fr424557/index.html">Guide Node.js, partie 8: protocoles HTTP et WebSocket</a></li>
<li><a href="../fr424559/index.html">R√©sistance Big Data 1 ou Joe insaisissable. Anonymat Internet, anti-d√©tection, anti-tracking pour anti-you et anti-us</a></li>
<li><a href="../fr424563/index.html">Beeline envoie les d√©tails des conversations √† des √©trangers</a></li>
<li><a href="../fr424565/index.html">Pr√©sentation: num√©risation 3D de locaux immobiliers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>