<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍇 🤳🏽 🕥 Tables normales dans Markdown 🚿 👨🏼‍🎓 🚩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tables de démarque sont infernales: 


1. Vous ne pouvez pas écrire de texte dans des cellules plus longues que quelques mots, et encore moins une...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tables normales dans Markdown</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474826/"><p><img src="https://habrastorage.org/webt/it/y9/mc/ity9mc1t7inx3qdwqydyznnzvya.png"></p><br><p>  Les tables de démarque sont infernales: </p><br><ol><li>  Vous ne pouvez pas écrire de texte dans des cellules plus longues que quelques mots, et encore moins une liste. </li><li>  Si le dialecte autorise le paragraphe 1, il n'est pas pratique de le formater. </li><li>  Si les cellules ne sont pas alignées, le tableau ne peut pas être lu. </li><li>  Il n'y a pas de prise en charge pour les tables du même type et l'automatisation, telles que la numérotation des lignes. </li></ol><br><p>  Il est temps d'écrire un filtre pour Pandoc qui dessine des tableaux à partir de YAML structuré, avec une numérotation des lignes, une orientation horizontale, des modèles de graphique, et en même temps de savoir comment écrire des filtres Lua. </p><a name="habracut"></a><br><p>  J'écris habituellement des textes dans Markdown et les convertis au format cible à l'aide de Pandoc.  Il s'agit d'un programme qui convertit les documents entre les formats, par exemple, à partir de Markdown, vous pouvez obtenir du HTML et un autre dialecte de MD et DOCX et PDF (plus de 30 formats d'entrée et plus de 50 formats de sortie).  Pandoc Markdown possède de nombreuses extensions pratiques pour les liens, les notes de bas de page, les signatures et les formules. </p><br><p> Pandoc fonctionne comme une composition de fonctions (il aurait été écrit en Haskell): un format d'entrée spécifique → une représentation abstraite d'un document → un format de sortie spécifique.  Une représentation abstraite peut être modifiée à l'aide de filtres écrits en Lua.  Les filtres n'ont pas besoin de connaître le format de sortie, mais ils peuvent en tenir compte. </p><br><p> Notre filtre recherchera des blocs de code abstraits dans la <code>table</code> langage conditionnel dans une représentation abstraite, lira YAML à l'intérieur et générera des représentations abstraites de tables que Pandoc lui-même produira au format cible. </p><br><pre> <code class="bash hljs">pandoc --lua-filter table.lua input.md -o output.html</code> </pre> <br><p>  Quelles sont les alternatives et pourquoi sont-elles pires? </p><br><ul><li>  <strong>Les tableaux HTML</strong> fonctionnent uniquement dans Markdown et sont convertis uniquement en HTML;  seul le problème du formatage riche en cellules est résolu. </li><li>  <strong>Les générateurs de tableaux</strong> nécessitent de passer d'un éditeur de texte; il n'est pas pratique de modifier le contenu des cellules qu'ils contiennent ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ). </li><li>  <strong>Les plugins éditeurs</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emacs Org-Mode</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugins VIM</a> ) ne sont pas universels et ne sont pas toujours disponibles. </li></ul><br><p>  En revanche, <code>pandoc-crossref</code> et tous les petits pains Pandoc fonctionnent avec le filtre des tableaux récapitulatifs.  Le filtre peut également être utilisé pour générer des tables Markdown standard en spécifiant le format de sortie approprié.  Des inconvénients: </p><br><ul><li>  Les cellules ne peuvent pas être fusionnées; Pandoc ne le prend pas (encore) en charge. </li><li>  Pour les tableaux horizontaux, la stylisation doit être effectuée en utilisant le format de sortie, par exemple, via CSS. </li></ul><br><p>  La description du tableau comprend trois parties: </p><br><ol><li><p>  <strong>Structure de la table</strong> </p><br><p>  Une liste ordonnée de graphiques (colonnes): </p><br><ul><li>  Au minimum, la colonne doit avoir un titre. </li><li>  Afin de pouvoir réorganiser les colonnes sans toucher aux données, l'attribut d'enregistrement affiché dans la colonne ( <code>id</code> ) doit être spécifié. </li><li>  Les colonnes spéciales n'ont pas d'ID, mais ont une description de la façon de les remplir.  Vous avez d'abord besoin d'un numéro de série ( <code>special: number</code> ). </li><li>  Alignement des colonnes ( <code>align</code> ). </li></ul><br><p>  De plus, le tableau peut être vertical ou horizontal ( <code>orientation</code> ).  Dans ce dernier cas, les graphiques seront des lignes. </p><br></li><li><p>  <strong>Propriétés de la table:</strong> identifiant des liens ( <code>id</code> ) et signature ( <code>caption</code> ).  Pandoc vous permet de signer des tables, mais pas des blocs de code. </p><br></li><li><p>  <strong>Données</strong> sous la forme d'un tableau de dictionnaires YAML. </p><br></li></ol><br><p>  La structure peut être commune à plusieurs tables, vous pouvez donc la décrire à la fois directement avec la table et une fois dans les métadonnées (front-matter), puis faire référence au modèle nommé. </p><br><p>  Plan de mise en œuvre: </p><br><ol><li><p>  À partir des métadonnées du document, nous formons un dictionnaire de modèles. </p><br></li><li><p>  Pour chaque bloc de code avec la <code>table</code> classe: </p><br><ol><li>  Nous analysons les tables YAML. </li><li>  Si un modèle est spécifié, nous le prenons dans le dictionnaire, sinon nous remplissons le modèle de YAML. </li><li>  Nous remplissons les propriétés individuelles du tableau de YAML. </li><li>  Nous formons des entrées de table à partir de YAML (un enregistrement est une ligne dans une table régulière ou une colonne dans une horizontale). </li><li>  Nous «dessinons» un tableau selon un modèle, des propriétés et des enregistrements. </li></ol><br></li></ol><br><p>  Le niveau supérieur est implémenté tel qu'écrit (tout le code est disponible sur le lien à la fin de l'article): </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pandoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> meta_templates = doc.meta[<span class="hljs-string"><span class="hljs-string">'table-templates'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> meta_templates <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(meta_templates) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> templates[name] = parse_template(value) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> blocks = pandoc.walk_block(pandoc.Div(doc.blocks), { CodeBlock = create_table }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pandoc.Pandoc(blocks, doc.meta) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  La fonction <code>parse_template()</code> convertit légèrement le format des métadonnées.  Pandoc représente leurs valeurs en tant <code>MetaBlock</code> et <code>MetaInline</code> .  Soit des lignes simples en sont faites à l' <code>pandoc.utils.stringify()</code> (par exemple, l'orientation), soit des éléments visuels (par exemple, un bloc de texte dans l'en-tête de la colonne). </p><br><p>  <strong>À propos du débogage.</strong>  Il existe de nombreux exemples dans la documentation Pandoc, mais les types ne sont pas très détaillés.  Pour le débogage des filtres, il est pratique d'avoir une fonction de vidage variable.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les bibliothèques sérieuses</a> impriment trop de détails, je préfère l'une des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">options</a> simples. </p><br><div class="spoiler">  <b class="spoiler_title">Fonctions de conversion des métadonnées en éléments de document</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_inlines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> content == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(content) == <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {pandoc.Str(content)} <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(content) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to_inlines(<span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(content)) <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> content.t == <span class="hljs-string"><span class="hljs-string">'MetaInlines'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inlines = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(content) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> inlines[i] = item <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inlines <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_blocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(content) == <span class="hljs-string"><span class="hljs-string">'table'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> content.t == <span class="hljs-string"><span class="hljs-string">'MetaBlocks'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {pandoc.Plain(to_inlines(content))} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  La fonction <code>create_table()</code> est appelée pour chaque bloc de code en triple backtics. </p><br><p>  Nous nous intéressons uniquement aux blocs de code «dans le langage» du <code>table</code> : </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contains(<span class="hljs-string"><span class="hljs-string">'table'</span></span>, block.classes) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Pour analyser YAML à l'intérieur d'un bloc de code, nous créons un document composé uniquement de métadonnées YAML, analysons-le avec Pandoc et ne laissons que des métadonnées: </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> meta = pandoc.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-string"><span class="hljs-string">'---\n'</span></span> .. block.text .. <span class="hljs-string"><span class="hljs-string">'\n---'</span></span>).meta</code> </pre> <br><p>  Ensuite, à partir de la <code>meta</code> lien vers un modèle ou une structure de table et les propriétés d'une table spécifique est lu. </p><br><p>  La fonction <code>fill_table()</code> lit des <code>meta</code> sur les attributs spécifiés dans la description du graphique.  Au même stade, si la colonne est marquée comme spéciale, son contenu est généré: </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> data = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, serie <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(template.series) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> serie.special == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> data[i] = to_blocks(#datum + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data[i] = to_blocks(item[serie.id]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  La fonction <code>format_table()</code> forme le tableau de cellules résultant en fonction de l'orientation du tableau et crée un objet tableau abstrait.  Il convient de noter que si les largeurs ou les en-têtes doivent être définis pour toutes les colonnes ou pour aucune, sinon Pandoc ne créera tout simplement pas de tableau. </p><br><p>  Le script terminé peut être placé dans <code>~/.local/share/pandoc</code> (le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">répertoire de données</a> <code>~/.local/share/pandoc</code> ) pour y accéder par son nom depuis n'importe où. </p><br><h2 id="p-s">  PS </h2><br><p>  À propos de la prise en compte des filtres de format de sortie.  Par exemple, j'écris des spoilers dans Pandoc comme ceci: </p><br><pre> <code class="markdown hljs">::: {.spoiler title=""}  . :::</code> </pre> <br><p>  Il n'y a pas de spoilers dans le modèle de document Pandoc, donc le filtre doit produire des blocs bruts de la manière suivante environ.  Bien sûr, le vrai code ( <code>spoiler.lua</code> ) doit prendre en compte le format de sortie via la variable <code>FORMAT</code> , et non mécaniquement: le fragment ci-dessous produit des blocs bruts en HTML, bien que le format de sortie soit markdown. </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(el)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> el.attr <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contains(<span class="hljs-string"><span class="hljs-string">'spoiler'</span></span>, el.attr.classes) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> title = el.attr.attributes[<span class="hljs-string"><span class="hljs-string">'title'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(el.content, <span class="hljs-number"><span class="hljs-number">1</span></span>, pandoc.RawBlock(<span class="hljs-string"><span class="hljs-string">'html'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> .. <span class="hljs-string"><span class="hljs-string">'spoiler title="'</span></span> .. title .. <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'RawBlock'</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(el.content, pandoc.RawBlock(<span class="hljs-string"><span class="hljs-string">'html'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> .. <span class="hljs-string"><span class="hljs-string">'/spoiler&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'RawBlock'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.content <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2 id="ssylki">  Les références </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code d'article GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pandoc Lua Filter Documentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Collection officielle de filtres</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474826/">https://habr.com/ru/post/fr474826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474812/index.html">Shader n'est pas magique. Écriture de shaders dans Unity. Vertex Shaders</a></li>
<li><a href="../fr474814/index.html">Antiquités: le messager de la décadence ou de l'obsolescence non planifiée</a></li>
<li><a href="../fr474816/index.html">Projets pour animaux de compagnie - petite vie</a></li>
<li><a href="../fr474818/index.html">Y a-t-il des nombres aléatoires dans CSS?</a></li>
<li><a href="../fr474822/index.html">WISE-PaaS - une plateforme cloud pour l'Internet industriel des objets</a></li>
<li><a href="../fr474830/index.html">Programmation orientée protocole, partie 3</a></li>
<li><a href="../fr474832/index.html">Fonctionnement de la cryptographie à courbe elliptique dans TLS 1.3</a></li>
<li><a href="../fr474838/index.html">SIBUR Challenge 2019 - Concours d'analyse de données industrielles</a></li>
<li><a href="../fr474840/index.html">Qu'est-ce qu'ils étudient dans la spécialité de la science des données dans les universités étrangères</a></li>
<li><a href="../fr474842/index.html">Cas: Service de voiture. Développement de campagnes publicitaires et implémentation de Bitrix24</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>