<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎵 🌧️ 👩‍🍳 Como estender o Kubernetes 🍊 🥕 👨🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje falaremos sobre DevOps, ou melhor, principalmente sobre Ops. Eles dizem que há muito poucas pessoas satisfeitas com o nível de automação de suas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como estender o Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424609/">  Hoje falaremos sobre DevOps, ou melhor, principalmente sobre Ops.  Eles dizem que há muito poucas pessoas satisfeitas com o nível de automação de suas operações.  Mas a situação parece ser corrigível.  Neste artigo, Nikolai Ryzhikov falará sobre sua experiência com a expansão do Kubernetes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/4f7/1a2/b1a4f71a2809a5b098e738ed4e0b5d3f.png"><br><br>  O material foi preparado com base no discurso de Nikolai na conferência de outono do DevOops 2017. Sob o corte - transcrição em vídeo e texto do relatório. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3BMTNx2xCtQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <i>Atualmente, Nikolai Ryzhikov está trabalhando no setor de Saúde-TI para criar sistemas de informação médica.</i>  <i>Membro da comunidade de programadores funcionais de São Petersburgo FPROG.</i>  <i>Membro ativo da comunidade Online Clojure, membro do padrão de troca de informações médicas HL7 FHIR.</i>  <i>Programa há 15 anos.</i> <br><hr><br>  Que lado temos para o DevOps?  Nossa fórmula de DevOps é bastante simples há 10 anos: os desenvolvedores são responsáveis ​​pelas operações, os desenvolvedores são implantados, os desenvolvedores são mantidos.  Com esse arranjo, que parece um pouco duro, você se tornará o DevOps.  Se você deseja implementar DevOps de maneira rápida e dolorosa - torne os desenvolvedores responsáveis ​​por sua produção.  Se os caras são espertos, eles começam a sair e entender tudo. <br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/799/e0d/8f4799e0d6f25b897b6bd72f2ba1081a.png"><br>  Nossa história: há muito tempo, quando não havia Chef e automação, já implantamos o Capistrano automático.  Então eles começaram a entediá-lo, para que ele fizesse moda.  Mas então o Chef apareceu.  Mudamos para ele e partimos para a nuvem: estávamos cansados ​​de nossos data centers.  Então Ansible apareceu, Docker se levantou.  Depois disso, nos mudamos para a Terraform com o supervisor de portaria escrito à mão do Condomínio em Camel.  E agora estamos nos mudando para Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/366/af1/be8/366af1be8b4c4cf204553b48c8a76e70.png"><br>  Qual é a pior coisa das operações?  Muito poucas pessoas estão satisfeitas com o nível de automação de suas operações.  Isso é assustador, confirmo: gastamos muitos recursos e esforços para coletar todas essas pilhas para nós mesmos, e o resultado é insatisfatório. <br><br>  Há um sentimento de que, com o advento do Kubernetes, algo pode mudar.  Estou comprometido com a manufatura enxuta e, do ponto de vista dele, as operações geralmente não são úteis.  Operações ideais são a ausência ou o mínimo de operações em um projeto.  O valor é criado quando um desenvolvedor faz um produto.  Quando está pronta, a entrega não agrega valor.  Mas você precisa reduzir custos. <br><img src="https://habrastorage.org/getpro/habr/post_images/731/1a4/6e3/7311a46e3eb4d1d73d788f6ee881be3a.png"><br>  Para mim, o ideal sempre foi o heroku.  Nós o usamos para aplicativos simples, onde o desenvolvedor implementou seu serviço, basta dizer git push e configurar heroku.  Demora um minuto. <br><img src="https://habrastorage.org/getpro/habr/post_images/a57/4c0/12b/a574c012ba1158086cd3578287d6d2a9.png"><br>  Como ser  Você pode comprar NoOps - também heroku.  E eu aconselho você a comprar, caso contrário, há uma chance de gastar mais dinheiro no desenvolvimento de operações normais. <br><br>  Existem caras da Deis, eles estão tentando fazer algo como heroku no Kubernetes.  Existe a fundição em nuvem, que também fornece uma plataforma na qual trabalhar. <br><img src="https://habrastorage.org/getpro/habr/post_images/bbd/7b9/7e0/bbd7b97e07aae6af9a54663d633e3cc2.png"><br>  Mas se você se incomodar com algo mais complexo ou grande, poderá fazer isso sozinho.  Agora, junto com o Docker e o Kubernetes, isso se torna uma tarefa que pode ser concluída em um período de tempo razoável e a um custo razoável.  Costumava ser muito duro. <br><img src="https://habrastorage.org/getpro/habr/post_images/299/2d2/90a/2992d290a7167b9fe4a8cf2320528b8e.png"><br><h2>  Um pouco sobre o Docker e o Kubernetes </h2><br>  Um dos problemas das operações é a repetibilidade.  A grande coisa que o docker trouxe são duas fases.  Temos uma fase de construção. <br><br>  O segundo ponto que agrada na janela de encaixe é uma interface universal para o lançamento de serviços arbitrários.  Alguém montou o Docker, colocou algo dentro e as operações são suficientes para dizer que o Docker é executado e iniciado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/ca2/5ad/0b4ca25ade4ae7d3513539aaa576d3e7.png"><br><br>  O que é o Kubernetes?  Por isso, criamos o Docker e precisamos iniciá-lo, integrá-lo, configurá-lo e conectá-lo a outras pessoas em algum lugar.  O Kubernetes permite que você faça isso.  Ele introduz uma série de abstrações, chamadas "recurso".  Iremos rapidamente examiná-los e até tentar criar. <br><br><h2>  Abstração </h2><br>  A primeira abstração é um POD ou um conjunto de contêineres.  Feito corretamente, o que exatamente é um <b>conjunto de</b> contêineres, e não um.  Os conjuntos podem vasculhar entre si volumes que se vêem através do host local.  Isso permite que você use um padrão como o side-car (é quando lançamos o contêiner principal e existem contêineres auxiliares nas proximidades que o ajudam). <br><br>  Por exemplo, a abordagem do embaixador.  É quando você não deseja que o contêiner pense onde alguns serviços estão localizados.  Você coloca um contêiner próximo a ele que sabe onde estão esses serviços.  E eles ficam disponíveis para o contêiner principal no host local.  Assim, o ambiente começa a parecer que você está trabalhando localmente. <br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/ab5/bda/0b8ab5bdae5f0d0e7375ff1b08efc6ee.png"><br>  Vamos aumentar o POD e ver como ele é descrito.  Localmente, você pode desenvolver o minikube.  Ele consome várias CPUs, mas permite que você crie um pequeno cluster Kubernetes em uma caixa virtual e trabalhe com ele. <br><br>  Vamos implantar o POD.  Eu disse que o Kubernetes aplica e inundou o POD.  Posso ver quais PODs tenho: vejo que um POD está implantado.  Isso significa que o Kubernetes lançou esses contêineres. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/862/d90/970862d90a9afea1066caa69c1af63c8.png"></div><br>  Eu posso até entrar neste contêiner. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/603/8f7/1226038f78d2c9593826e7f26d611853.png"></div><br>  Nesta perspectiva, o Kubernetes é feito para pessoas.  De fato, o que fazemos constantemente em operações, na ligação do Kubernetes, por exemplo, usando o utilitário kubectl, pode ser feito facilmente. <br><br>  Mas o POD é mortal.  Começa como uma execução no Docker: se alguém o interrompe, ninguém o levanta.  Além dessa abstração, o Kubernetes começa a criar o seguinte - por exemplo, um conjunto de réplicas.  Este é um supervisor que monitora os PODs, monitora seu número e, se os PODs caírem, ele os levanta.  Este é um conceito importante de autocura em Kubernetes que permite que você durma em paz à noite. <br><br>  Acima da replicaset, há uma abstração da implantação - também um recurso que permite fazer a implantação em tempo zero.  Por exemplo, um replicaset funciona.  Quando implantamos e alteramos a versão do contêiner, por exemplo a nossa, dentro da implantação, outro replicaset aumenta.  Aguardamos até que esses contêineres sejam iniciados, passemos por suas verificações de integridade e depois mudamos rapidamente para o novo conjunto de replicas.  Também clássico e boas práticas. <br><img src="https://habrastorage.org/getpro/habr/post_images/02e/d07/f33/02ed07f333733af0155ee539be18c669.png"><br>  Vamos pegar um serviço simples.  Por exemplo, temos uma implantação.  No interior, ele descreve o padrão de PODs que ele buscará.  Podemos aplicar essa implantação, ver o que temos.  Funcionalidade interessante do Kubernetes - tudo está no banco de dados e podemos ver o que acontece no sistema. <br><br>  Aqui vemos uma implantação.  Se tentarmos olhar para os PODs, vemos que alguns PODs aumentaram.  Podemos pegar e remover esse POD.  O que acontece com os PODs?  Um é destruído e o segundo se eleva imediatamente.  Este controlador de replicaset não encontrou o POD desejado e lançou outro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/7f4/0d4/5247f40d4fb21eb93bda0ce14124245e.png"></div><br>  Além disso, se esse é algum tipo de serviço da Web, ou dentro de nossos serviços deve se comunicar, precisamos de uma descoberta de serviço.  Você deve dar ao serviço um nome e um ponto de entrada.  O Kubernetes oferece um recurso chamado serviço para isso.  Ele pode lidar com o balanceamento de carga e ser responsável pela descoberta de serviços. <br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/926/6e5/2fa9266e57c6718a81241ae1ac15da8e.png"><br>  Vamos ver um serviço simples.  Nós o conectamos à implantação e aos PODs por meio de etiquetas: um link tão dinâmico.  Um conceito muito importante no Kubernetes: o sistema é dinâmico.  Não importa em que ordem tudo isso será criado.  O serviço tentará encontrar PODs com essas etiquetas e iniciar seu equilíbrio de carga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b48/992/f7d/b48992f7dca832fce9b45276936a4914.png"></div><br>  Aplique serviço, veja quais serviços temos.  Entramos em nosso teste de POD, que foi criado, e fazemos a pesquisa.  O Kubernetes nos fornece um DNS-ku através do qual os serviços podem ver e descobrir um ao outro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b05/66f/01e/b0566f01e54210ea26c5b6526b0ed0de.png"></div><br>  O serviço é mais uma interface.  Existem várias implementações diferentes, porque as tarefas de balanceamento de carga e serviço são bastante complicadas: de uma maneira, trabalhamos com bancos de dados comuns, no outro com bancos de dados carregados, e alguns simples são simplificados.  Este também é um conceito importante no Kubernetes: algumas coisas podem ser chamadas de interfaces, em vez de implementações.  Eles não são corrigidos rigidamente e diferentes, por exemplo, os provedores de nuvem oferecem implementações diferentes.  Ou seja, por exemplo, há um volume persistente de recurso, que já é implementado em cada nuvem específica por seus meios regulares. <br><br>  Em seguida, geralmente queremos disponibilizar o serviço da web.  Kubernetes tem uma abstração de entrada.  Geralmente, o SSL é adicionado lá. <br><img src="https://habrastorage.org/getpro/habr/post_images/fc7/69e/4e7/fc769e4e7a526588c3f3ae32388d9c11.png"><br>  A entrada mais simples se parece com isso.  Lá, escrevemos as regras: para quais URLs, para quais hosts, para qual serviço interno redirecionar a solicitação.  Da mesma maneira, podemos aumentar nossa entrada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69d/79c/046/69d79c046478f1fde2a073f2fe37067f.png"></div><br>  Após o qual, após se registrar localmente nos hosts, você pode ver este serviço a partir daqui. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/752/75c/73d75275c26a468f49cd192e781595db.png"></div><br>  Essa é uma tarefa tão regular: implantamos um determinado serviço da web e nos encontramos um pouco com o Kubernetes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a3/1f8/c2f/1a31f8c2f639a4758d95719ee6dca1e0.png"></div><br>  Vamos limpar tudo, remover a entrada e analisar todos os recursos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c75/990/40c/c7599040cd85c2c155e8acf057be0246.png"></div><br>  Existem vários recursos, como configmap e secret.  Estes são recursos puramente informativos que você pode montar em um contêiner e transferir para lá, por exemplo, a senha do postgres.  Você pode associar isso a variáveis ​​de ambiente que serão injetadas no contêiner na inicialização.  Você pode montar o sistema de arquivos.  Tudo é bastante conveniente: tarefas padrão, soluções agradáveis. <br><br>  Há um volume persistente - uma interface que é implementada de maneira diferente por diferentes provedores de nuvem.  Ele é dividido em duas partes: há uma reivindicação de volume persistente (solicitação) e, em seguida, é criado um EBS que arrasta para o contêiner.  Você pode trabalhar com um serviço com estado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/5c1/2f7/cd65c12f71d417ffd11e3e62c76b484c.png"><br><br>  Mas como isso funciona por dentro?  O conceito em si é muito simples e transparente.  Kubernetes tem duas partes.  Um é apenas um banco de dados no qual temos todos esses recursos.  Os recursos podem ser considerados tablets: especificamente, essas instâncias são simplesmente registros em tablets.  Além do Kubernetes, um servidor de API está configurado.  Ou seja, quando você tem um cluster Kubernetes, geralmente se comunica com o servidor da API (mais precisamente, o cliente se comunica com ele). <br><br>  Assim, o que criamos (PODs, serviços etc.) é simplesmente gravado no banco de dados.  Este banco de dados é implementado pelo ETCD, ou seja,  para que seja estável no nível de alta disponibilidade. <br><br>  O que vem depois?  Além disso, sob cada tipo de recursos, há um determinado controlador.  Este é apenas um serviço que monitora seu tipo de recurso e faz algo no mundo exterior.  Por exemplo, um Docker é executado.  Se tivermos PODs, para cada Nó existe um serviço de kubelet que monitora os PODs que estão conectados a esse nó.  E tudo o que ele faz é o Docker executar após a próxima verificação periódica se esse POD não está lá. <br><br>  Além disso, o que é muito importante - tudo acontece em tempo real, portanto a potência deste controlador é maior que o mínimo.  Freqüentemente, o controlador ainda pega as métricas e analisa o que foi iniciado.  I.e.  remove o feedback do mundo real e o grava no banco de dados, para que você ou outros controladores possam vê-lo.  Por exemplo, o mesmo status de POD será gravado de volta no ETCD. <br><br>  Assim, tudo é implementado no Kubernetes.  É muito legal que o modelo de informações seja separado da sala de operações.  No banco de dados através da interface CRUD usual, declaramos o que deveria ser.  Em seguida, o conjunto de controladores tenta fazer tudo certo.  É verdade que isso nem sempre acontece. <br><br>  Este é um modelo cibernético.  Temos uma certa predefinição: existe algum tipo de máquina que está tentando direcionar o mundo real ou a máquina para o local necessário.  Nem sempre é assim: devemos ter um ciclo de feedback.  Às vezes, uma máquina não pode fazer isso e deve recorrer a uma pessoa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59e/0a9/1e8/59e0a91e8974351a5f0f49fd94709c9a.png"><br><br>  Em sistemas reais, pensamos em abstrações do próximo nível: temos alguns serviços, bancos de dados e todos nós o conectamos.  Não pensamos em PODs e Ingresss e queremos criar um próximo nível de abstração. <br><img src="https://habrastorage.org/getpro/habr/post_images/77f/5cb/697/77f5cb6974c6ac85e0b5e8b13921d672.png"><br>  Para que o desenvolvedor fosse o mais fácil possível: para que ele simplesmente dissesse: "Quero iniciar esse e tal serviço", e tudo o mais aconteceu por dentro. <br><br>  Existe algo como HELM.  Este é o caminho errado - modelagem de estilo ansible, onde estamos apenas tentando gerar um conjunto de recursos configurados e soltá-los em um cluster Kubernetes. <br><br>  O problema, em primeiro lugar, é que isso é feito apenas no momento da rolagem.  Ou seja, ele não pode implementar muita lógica.  Em segundo lugar, em tempo de execução, essa abstração desaparece.  Quando vou olhar para o meu cluster, vejo apenas PODs e serviços.  Não vejo que esse e esse serviço seja implantado, que tal e qual base com replicação seja criada lá.  Eu só vejo dezenas de lares lá.  A abstração desaparece como em uma matriz. <br><img src="https://habrastorage.org/getpro/habr/post_images/696/6e6/9bd/6966e69bd8b289229194911f62a11f84.png"><br><h2>  Modelo de solução interna </h2><br>  Por outro lado, o próprio Kubernetes já fornece um modelo de extensão muito interessante e simples.  Podemos declarar novos tipos de recursos, por exemplo implantação.  Este é um recurso criado sobre PODs ou replicaset.  Podemos escrever um controlador nesse recurso, colocá-lo no banco de dados e executar nosso loop cibernético para que tudo funcione.  Isso parece interessante, e parece-me que este é o caminho certo para estender o Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/39e/491/c51/39e491c511ea25078eda191097d88b24.png"><br>  Gostaria de poder apenas escrever algum manifesto para o meu serviço no estilo heroku.  Um exemplo muito simples: quero implantar algum tipo de aplicativo no meu ambiente real.  Já possui contratos, SSL, domínios comprados.  Eu só gostaria de dar aos desenvolvedores a interface mais simples possível.  O manifesto me diz qual contêiner levantar, quais recursos esse contêiner ainda precisa.  Ele lança esse anúncio no cluster e tudo começa a funcionar. <br><img src="https://habrastorage.org/getpro/habr/post_images/a91/24e/8a8/a9124e8a8309c952cc0a65b32f28d76f.png"><br><br>  Como isso ficará em termos de recursos e controladores personalizados?  Aqui teremos um aplicativo de recurso no banco de dados.  E o controlador do aplicativo gerará três recursos.  Ou seja, ele anotará as regras de entrada sobre como encaminhar para esse serviço, iniciar o serviço de balanceamento de carga e iniciar a implantação com algum tipo de configuração. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/938/d22/807938d229cb312ca761214fa30829ed.png"><br><br>  Antes de criarmos um recurso personalizado no Kubernetes, precisamos declará-lo.  Para isso, existe um meta-recurso chamado CustomResourceDefinition. <br><br>  Para declarar um novo recurso no Kubernetes, basta publicar esse anúncio.  Considere esta tabela de criação. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/253/7d3/09e2537d3520f688c7029a357d9773dd.png"></div><br>  Criou uma tabela.  Depois disso, podemos examinar o kubectl e obter os recursos de terceiros que temos.  Assim que anunciamos, também recebemos um banner.  Podemos fazer, por exemplo, o kubeclt obter aplicativos.  Mas até agora nenhum aplicativo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5b/c40/9ad/d5bc409ad70866a12358ccb68ba497f8.png"></div><br>  Vamos escrever um aplicativo.  Depois disso, podemos criar uma instância de recurso personalizado.  Vamos dar uma olhada no YAML e criá-lo por postagem em um URL específico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/e55/454/044e554549dc4dc00d262ecf49d8d72d.png"></div><br>  Se executarmos e examinarmos o kubectl, um aplicativo será exibido.  Mas enquanto nada acontece, ele está apenas no banco de dados.  Você pode, por exemplo, pegar e solicitar todos os recursos do aplicativo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/234/74d/70123474de1bf62ece27d49587098368.png"></div><br>  Podemos criar um segundo recurso desse tipo a partir do mesmo modelo, simplesmente alterando o nome.  Aqui está o segundo recurso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/a58/4b0/842a584b09631555234babcbd3c7e57c.png"></div><br>  Além disso, nosso controlador deve fazer modelagem, semelhante ao que o HELM faz.  Ou seja, depois de receber uma descrição do nosso aplicativo, preciso gerar uma implantação de recursos e um serviço de recursos, além de fazer uma entrada na entrada.  Esta é a parte mais fácil: aqui no clojure é erlmacro.  Eu passo a estrutura de dados, ele puxa a função de implantação, passa para depuração, que é o pipeline.  E esta é uma função pura: modelagem simples.  Dessa forma, da forma mais ingênua, eu poderia criá-lo imediatamente, transformá-lo em um utilitário de console e começar a distribuí-lo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b33/bf5/2cb/b33bf52cbd901d2c5e0a0641daed9161.png"></div><br>  Fazemos o mesmo pelo serviço: a função de serviço aceita a declaração e gera o recurso Kubernetes para nós. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/daf/e7f/c2edafe7f36d7c0db4573054991c436a.png"></div><br>  Fazemos o mesmo para a linha de entrada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/22f/156/5d022f15612aa3dcc19f635b0dd9b403.png"></div><br>  Como isso tudo vai funcionar?  Haverá algo no mundo real e haverá o que queremos.  O que queremos - pegamos o recurso do aplicativo e geramos nele o que deveria ser.  E agora precisamos ver o que é.  O que solicitamos através da API REST.  Podemos obter todos os serviços, todas as implantações. <br><br>  Como nosso controlador personalizado funcionará?  Ele receberá o que queremos e o que é, tira dessa div e aplica-se ao Kubernetes.  Isso é semelhante ao React.  Eu vim com um DOM virtual quando algumas funções simplesmente geram uma árvore de objetos JS.  E então um determinado algoritmo calcula o patch e o aplica ao DOM real. <br><br>  Faremos o mesmo aqui.  Isso é feito em 50 linhas de código.  Quer - tudo está no Github.  No final, devemos obter a função reconciliar ações. <br><br>  Temos uma função de reconciliação de ações que não faz nada e apenas calcula essa div.  Ela pega o que é, mais o que é necessário.  E então ele mostra o que precisa ser feito para trazer o primeiro para o segundo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/460/49b/90d/46049b90d8fa93dfe9279c02828cfa1c.png"></div><br>  Vamos puxá-la.  Não há nada de errado com ela, ela pode ser prejudicada.  Ela diz que você precisa criar um serviço de entrada, fazer duas entradas nele, criar uma implantação 1 e 2, criar um serviço 1 e 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/c0a/c10/c72c0ac10e4924fde59ed749339345aa.png"></div><br>  Nesse caso, já deve haver apenas um serviço.  Vimos pela entrada que resta apenas uma entrada. <br><br>  Tudo o que resta é escrever uma função que aplique esse patch ao cluster Kubernetes.  Para fazer isso, simplesmente transmitimos ações de reconciliação para a função de reconciliação, e tudo será aplicado.  E agora vemos que o POD aumentou, a implantação se tornou e o serviço foi iniciado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/144/1a5/66b1441a56d805344c7e734d3b9b2c80.png"></div><br>  Vamos adicionar outro serviço: execute a função reconciliar ações novamente.  Vamos ver o que aconteceu.  Tudo começou, está tudo bem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32a/f9f/c1e/32af9fc1e444ed1c135e4bbe828a946f.png"></div><br>  Como lidar com isso?  Empacotamos tudo isso em um contêiner Docker.  Depois disso, escrevemos uma função que acorda periodicamente, faz uma reconciliação e adormece.  A velocidade não é muito importante, ela pode dormir por cinco segundos e executar ações de reconciliação com menos frequência. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bec/04e/8d1/bec04e8d1791843d80aed4f2b3f2a673.png"></div><br>  Nosso controlador personalizado é apenas um serviço que será ativado e calculará periodicamente o patch. <br><br>  Agora temos dois serviços zaddeloino, vamos excluir um dos aplicativos.  Vamos ver como nosso cluster reagiu: está tudo bem.  Excluímos o segundo: tudo está limpo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/a23/96e/5ffa2396ef22187604393a9ae657edd5.png"></div><br>  Vamos ver através dos olhos do desenvolvedor.  Ele só precisa dizer que o Kubernetes aplica e nomeia o novo serviço.  Fazemos isso, nosso controlador pegou tudo e o criou. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/ca6/3d7/bd6ca63d77dfbadee1587b6f44a680bd.png"></div><br>  Em seguida, coletamos tudo isso em um serviço de implantação e lançamos esse controlador personalizado no cluster usando as ferramentas padrão do Kubernetes.  Criamos uma abstração para 200 linhas de código. <br><br>  Tudo parece HELM, mas na verdade mais poderoso.  O controlador trabalha em um cluster: vê a base, vê o mundo exterior e pode ser inteligente o suficiente. <br><br><h2>  IC próprio </h2><br>  Considere os exemplos de extensão Kubernetes.  Decidimos que o IC deveria fazer parte da infraestrutura.  Isso é bom, é conveniente do ponto de vista da segurança - um repositório privado.  Tentamos usar o jenkins, mas é uma ferramenta desatualizada.  Eu queria um CI hacker.  Não precisamos de interfaces, amamos o ChatOps: diga no bate-papo se a compilação caiu ou não.  Além disso, eu queria depurar tudo localmente. <br><img src="https://habrastorage.org/getpro/habr/post_images/9a4/ecf/86e/9a4ecf86e022a465ce11072352456728.png"><br>  Sentamos e escrevemos nosso IC em uma semana.  Apenas como uma extensão para o Kubernetes.  Se você pensa em CI, essa é apenas uma ferramenta que executa algum tipo de trabalho.  Como parte desse trabalho, criamos algo, executamos testes e frequentemente implantamos. <br><br>  Como tudo isso funciona?  Ele é construído com o mesmo conceito de controladores personalizados.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, deixamos no Kubernetes uma descrição de quais repositórios estamos seguindo. </font><font style="vertical-align: inherit;">O controlador apenas acessa o github e adiciona gancho da web. </font><font style="vertical-align: inherit;">Ainda temos introspecção. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, vem o gancho da web, cuja única tarefa é processar o JSON recebido e soltá-lo no recurso de compilação personalizado, que também é dobrado no banco de dados Kubernetes. </font><font style="vertical-align: inherit;">O recurso de construção é monitorado pelo controlador de construção, que lê o manifesto dentro do projeto e inicia o POD. </font><font style="vertical-align: inherit;">Nesse POD, todos os serviços necessários são lançados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No POD, um agente muito simples que lê uma declaração no estilo travis ou circleci, e no YAML, um conjunto de etapas. </font><font style="vertical-align: inherit;">Ele começa a cumpri-los. </font><font style="vertical-align: inherit;">Então, no final da compilação, ele lança seu resultado no telegrama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro recurso que obtivemos com o Kubernetes é que um dos comandos na execução de seu IC ou entrega contínua pode ser definido simplesmente enquanto o sono for verdadeiro 10, e seu POD congelará nesta etapa. </font><font style="vertical-align: inherit;">Você executa o kubectl exec, se encontra dentro da sua compilação e pode estrear. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro recurso - tudo é construído em janelas de encaixe e você pode depurar o script localmente, iniciando a janela de encaixe. </font><font style="vertical-align: inherit;">Tudo levou duas semanas e 300 linhas de código.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/334/ec3/72f334ec33db75d3b32e4c464a24dc03.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trabalhar com o postgres </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso produto é construído no postgres, usamos todos os tipos de recursos interessantes. Até escrevemos várias extensões. Mas não podemos usar o RDS ou qualquer outra coisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora estamos no processo de desenvolvimento de um operador para um postgres indestrutível. Vou soar arquitetura. Eu quero dizer: "Cluster, me dê um postgres que não possa ser morto". Adicione a isso que eu preciso de duas réplicas assíncronas, uma síncrona, backups diários e até um terabyte. Eu jogo tudo, então meu controlador de cluster começa a orquestrar e expandir meu contêiner. Ele cria recursos de instância que são responsáveis ​​por cada postgres de instância. Este será o postgres de cluster.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controlador pginstance adicional, bastante simples, apenas tentando executar o POD ou a implantação lá com este postgres. O coração é volume persistente. Toda esta máquina assume o controle total do postgres. Você fornece a ela um contêiner Docker, que possui apenas postgres binários. Tudo o resto: o próprio controlador faz a configuração e a criação do cluster de início do postgres. Ele faz isso para que possamos reconfigurar mais tarde e para que ele possa configurar a replicação, os níveis de log etc. No início, o POD temporário é executado sobre o volume persistente e cria um cluster postgres para o mestre lá. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, além disso, a implantação começa com o mestre. Em seguida, um volume persistente é criado da mesma maneira. Outro POD é executado, faz um backup básico, faz o backup e, além disso, a implantação começa com um escravo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, o controlador de cluster cria um recurso de backup (depois de ter sido descrito com backups). E o controlador de backup já pega e joga em algum S3.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/972/b42/457/972b42457c664d988fd8eeee0aaa603c.png"><br><br><h2>  O que vem a seguir? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos apresentar o futuro próximo a você. Pode acontecer que, mais cedo ou mais tarde, tenhamos recursos personalizados tão interessantes, controladores personalizados que direi "Dê-me o postgres, dê-me kafka, deixe-me o IC e inicie tudo". Tudo será simples. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se não estamos falando sobre o futuro próximo, eu, como programador declarativo, acho que apenas a programação lógica ou relacional é superior à programação funcional. Lá, nossa semântica de operações é completamente separada da semântica de informações. Se olharmos atentamente para nossos controladores personalizados, fizemos, por exemplo, um aplicativo de recurso em nosso banco de dados. E extraímos mais três recursos adicionais. Isso é muito semelhante à exibição do banco de dados. Esta é uma descoberta de fato. Esta é uma visão lógica ou de relação.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O próximo passo para o Kubernetes é fornecer uma certa ilusão de uma base relacional ou lógica em vez de uma API REST cortada, na qual você pode simplesmente escrever uma regra. Como, mais cedo ou mais tarde, tudo flui para o banco de dados, incluindo feedback, as regras podem parecer assim: "Se a carga aumentou assim, aumente a replicação assim". Teremos uma pequena regra sql ou lógica. Tudo que você precisa é de um mecanismo genérico que siga isso. Mas este é um futuro brilhante.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f1e/930/fb4f1e930029011d081eeb911203d289.png"><br><br><blockquote>    —   <b>DevOops 2018</b> !     —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«The DevOps Handbook»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«Learning Chef: A Guide to Configuration Management and Automation»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«How to containerize your Go code»</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«Liquid Software: How to Achieve Trusted Continuous Updates in the DevOps World»</a> —      .         -    . <br><br>  :       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ! <br><br>    : <b> 1 </b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode reservar um </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">ingresso</font></a><font style="vertical-align: inherit;"> para o DevOops 2018 com desconto.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424609/">https://habr.com/ru/post/pt424609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424599/index.html">Você precisa escolher o software que precisa: escrito dentro do prazo ou de alta qualidade</a></li>
<li><a href="../pt424601/index.html">Arquitetura da informação na Internet parte 1</a></li>
<li><a href="../pt424603/index.html">O livro “Por que estamos errados? Armadilhas para o pensamento em ação. ” Trechos Parte 1</a></li>
<li><a href="../pt424605/index.html">Fundos Zuckerberg: Colaboração + Tecnologia + Ciência Aberta</a></li>
<li><a href="../pt424607/index.html">Ascensão de Helidon</a></li>
<li><a href="../pt424611/index.html">Como criar um funcionário de um freelancer</a></li>
<li><a href="../pt424613/index.html">Experiência no uso de redux sem redutores</a></li>
<li><a href="../pt424615/index.html">Saída da função curva para limitar parâmetros, sinais e não apenas no Wolfram Mathematica</a></li>
<li><a href="../pt424621/index.html">Super-heróis que não são filmes. Quem e como protege o canteiro de obras do Lakhta Center contra incêndios?</a></li>
<li><a href="../pt424623/index.html">Vamos processar o som no Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>