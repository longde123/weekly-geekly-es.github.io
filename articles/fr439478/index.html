<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎤 👩‍👦‍👦 🦆 C # divertissant. Cinq exemples de pauses café 👨‍⚕️ 🤽 👨🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ayant déjà écrit plus d'un article sur Veeam Academy , nous avons décidé d'ouvrir une petite cuisine interne et de vous proposer quelques exemples en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # divertissant. Cinq exemples de pauses café</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/439478/">  Ayant déjà écrit plus d'un article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Veeam Academy</a> , nous avons décidé d'ouvrir une petite cuisine interne et de vous proposer quelques exemples en C # que nous analysons avec nos étudiants.  Lors de leur compilation, nous avons été guidés par le fait que notre public est des développeurs débutants, mais il peut également être intéressant pour les programmeurs expérimentés de regarder sous le chat.  Notre objectif est de montrer la profondeur du trou du lapin, tout en expliquant les caractéristiques de la structure interne de C #. <br><br>  D'un autre côté, nous serons heureux d'entendre les commentaires de collègues expérimentés qui souligneront les défauts de nos exemples ou partageront les leurs.  Ils aiment utiliser ces questions lors des entretiens, alors nous avons certainement tous quelque chose à dire. <br><br>  Nous espérons que notre sélection vous sera utile, vous aidera à rafraîchir vos connaissances ou tout simplement à sourire. <br><br><img src="https://habrastorage.org/webt/wm/5l/4q/wm5l4qgp5-jl50kt_2oswu4tyu8.jpeg" alt="image"><br><a name="habracut"></a><br><h4>  Exemple 1 </h4><br>  Structures en C #.  Avec eux, même les développeurs expérimentés ont souvent des questions, qui sont si souvent utilisées par toutes sortes de tests en ligne. <br><br>  Notre premier exemple est un exemple de pleine conscience et de connaissance de ce dans quoi le bloc d'utilisation se développe.  Et aussi tout à fait un sujet de communication lors de l'entretien. <br><br>  Considérez le code: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SDummy(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (d) { Console.WriteLine(d.GetDispose()); } Console.WriteLine(d.GetDispose()); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'imprimera la méthode Main sur la console?</b> <div class="spoiler_text">  Notez que SDummy est une structure qui implémente l'interface IDisposable, de sorte que les variables de type SDummy peuvent être utilisées dans le bloc using. <br><br>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la spécification du langage C #, l'</a> utilisation de l'instruction pour les types significatifs au moment de la compilation se développe en un bloc try-finally: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(d.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)d).Dispose(); }</code> </pre><br>  Ainsi, dans notre code, la méthode GetDispose () est appelée à l'intérieur du bloc using, qui renvoie le champ booléen _dispose, dont la valeur n'a pas encore été définie pour l'objet d (elle est définie uniquement dans la méthode Dispose (), qui n'a pas encore été appelée) et donc la valeur est renvoyée La valeur par défaut est False.  Et ensuite? <br><br>  Et puis le plus intéressant. <br>  Exécuter une ligne dans un bloc enfin <br><pre> <code class="cs hljs"> ((IDisposable)d).Dispose();</code> </pre><br>  mène normalement à la boxe.  Ce n'est pas difficile à voir, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (en haut à droite dans Résultats, sélectionnez d'abord C #, puis IL): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/b5/ix/4pb5ixpt4bwwwgrgiqeopcstdsg.jpeg" alt="image" width="80%"></div><br>  Dans ce cas, la méthode Dispose est déjà appelée pour un autre objet, et pas du tout pour l'objet d. <br>  Exécutez notre programme et voyez que le programme affiche vraiment «False False» sur la console.  Mais est-ce aussi simple que cela?  :) <br><br>  En fait, aucun emballage ne se produit.  Ce qui, selon Eric Lippert, est fait dans un souci d'optimisation (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). <br>  Mais, s'il n'y a pas d'emballage (ce qui en soi peut sembler surprenant), pourquoi «False False» et non «False True» à l'écran, car Dispose devrait maintenant être appliqué au même objet?!? <br><br>  Et là pas pour ça! <br>  Jetez un œil à ce que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilateur C #</a> étend notre programme en: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { SDummy sDummy = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(SDummy); SDummy sDummy2 = sDummy; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(sDummy.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)sDummy2).Dispose(); } Console.WriteLine(sDummy.GetDispose()); } }</code> </pre><br><br>  Il existe une nouvelle variable sDummy2, à laquelle la méthode Dispose () est appliquée! <br>  D'où vient cette variable cachée? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Passons</a> à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouveau</a> aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécifications</a> : <br><blockquote>  Une instruction using de la forme «instruction using (expression)» a les trois mêmes extensions possibles.  Dans ce cas, ResourceType est implicitement le type à la compilation de l'expression ... La variable 'resource' est inaccessible et invisible à l'instruction incorporée. <br></blockquote><br>  T.O.  la variable sDummy est invisible et inaccessible à l'instruction incorporée du bloc using, et toutes les opérations à l'intérieur de cette expression sont effectuées avec une autre variable sDummy2. <br><br>  Par conséquent, la méthode Main renvoie à la console «False False», et non «False True», comme le croient ceux qui ont rencontré cet exemple pour la première fois.  Dans ce cas, n'oubliez pas qu'il n'y a pas de packaging, mais une variable cachée supplémentaire est créée. <br><br>  La conclusion générale est la suivante: les types de valeurs mutables sont mauvais, il vaut mieux les éviter. <br><br>  Un exemple similaire est considéré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Si le sujet est intéressant, nous vous recommandons fortement de jeter un œil. <br><br>  Je voudrais remercier tout spécialement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SergeyT</a> pour ses précieux commentaires sur cet exemple. <br><br></div></div><br><br><h4>  Exemple 2 </h4><br>  Les constructeurs et la séquence de leurs appels est l'un des principaux sujets de tout langage de programmation orienté objet.  Parfois, une telle séquence d'appels peut surprendre et, pire encore, «remplir» le programme au moment le plus inattendu. <br><br>  Considérez donc la classe MyLogger: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger innerInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerInstance; } } }</code> </pre><br>  Supposons que cette classe possède une logique métier dont nous avons besoin pour prendre en charge la journalisation (la fonctionnalité n'est pas si importante en ce moment). <br><br>  Voyons ce qu'il y a dans notre classe MyLogger: <br><br><ol><li>  Constructeur statique spécifié </li><li>  Il existe un constructeur privé sans paramètres </li><li>  Variable statique fermée innerInstance définie </li><li>  Et il existe une propriété statique ouverte d'Instance pour communiquer avec le monde extérieur </li></ol><br>  Pour faciliter l'analyse de cet exemple, nous avons ajouté une sortie de console simple aux constructeurs de la classe. <br><br>  En dehors de la classe (sans utiliser des astuces comme la réflexion), nous ne pouvons utiliser que la propriété publique statique Instance, que nous pouvons appeler comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = MyLogger.Instance; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Que produira ce programme?</b> <div class="spoiler_text">  Nous savons tous qu'un constructeur statique est appelé avant d'accéder à n'importe quel membre de la classe (à l'exception des constantes).  Dans ce cas, il n'est lancé qu'une seule fois dans le domaine d'application. <br><br>  Dans notre cas, nous nous tournons vers le membre de la classe - la propriété Instance, qui devrait provoquer le démarrage du constructeur statique en premier, puis le constructeur de l'instance de classe sera appelé.  C'est-à-dire  le programme affichera: <br><br>  <b>Constructeur d'enregistreurs statiques</b> <b><br></b>  <b>Constructeur de l'enregistreur d'instance</b> <b><br></b> <br><br>  Cependant, après avoir démarré le programme, nous obtenons sur la console: <br><br>  <b>Constructeur de l'enregistreur d'instance</b> <b><br></b>  <b>Constructeur d'enregistreurs statiques</b> <b><br></b> <br><br>  Comment ça?  Le constructeur d'instance a fonctionné avant le constructeur statique?!? <br>  Réponse: oui! <br><br>  Et voici pourquoi. <br><br>  La norme C # ECMA-334 stipule ce qui suit pour les classes statiques: <br><br>  <i>17.4.5.1: «Si un constructeur statique (§17.11) existe dans la classe, l'exécution des initialiseurs de champ statique se produit immédiatement avant d'exécuter ce constructeur statique.</i> <i><br></i>  <i>...</i> <i><br></i>  <i>17.11: ... Si une classe contient des champs statiques avec des initialiseurs, ces initialiseurs sont exécutés dans l'ordre textuel immédiatement avant d'exécuter le constructeur statique</i> <br><br>  (Ce qui dans une traduction libre signifie: s'il y a un constructeur statique dans la classe, alors l'initialisation des champs statiques commence immédiatement AVANT le démarrage du constructeur statique. <br>  ... <br>  Si la classe contient des champs statiques avec des initialiseurs, ces initialiseurs sont lancés dans l'ordre dans le texte du programme AVANT l'exécution du constructeur statique.) <br><br>  Dans notre cas, le champ statique innerInstance est déclaré avec l'initialiseur, qui est le constructeur de l'instance de classe.  Selon la norme ECMA, l'initialiseur doit être appelé AVANT d'appeler le constructeur statique.  Ce qui se passe dans notre programme: le constructeur d'instance, étant l'initialiseur du champ statique, est appelé AVANT le constructeur statique.  D'accord, de façon assez inattendue. <br><br>  Notez que cela n'est vrai que pour les initialiseurs de champs statiques.  En général, un constructeur statique est appelé AVANT d'appeler le constructeur de l'instance de classe. <br><br>  Comme, par exemple, ici: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); } }</code> </pre><br>  Et le programme devrait sortir sur la console: <br><br>  <b>Constructeur d'enregistreurs statiques</b> <b><br></b>  <b>Constructeur de l'enregistreur d'instance</b> <b><br></b> <br></div></div><br><img src="https://habrastorage.org/webt/zr/ee/h3/zreeh3h-fqruztz8hdljydmzl1q.jpeg" alt="image"><br><br><h4>  Exemple 3 </h4><br>  Les programmeurs doivent souvent écrire des fonctions auxiliaires (utilitaires, aides, etc.) pour leur faciliter la vie.  En règle générale, ces fonctions sont assez simples et ne prennent souvent que quelques lignes de code.  Mais vous pouvez trébucher même à l'improviste. <br><br>  Supposons que nous devons implémenter une fonction qui vérifie l'étrangeté du nombre (c'est-à-dire que le nombre n'est pas divisible par 2 sans reste). <br><br>  Une implémentation pourrait ressembler à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  À première vue, tout va bien et, par exemple, pour les nombres 5.7 et 11, nous nous attendons vraisemblablement à True. <br><br><div class="spoiler">  <b class="spoiler_title">Que renverra la fonction isOddNumber (-5)?</b> <div class="spoiler_text">  -5 est un nombre impair, mais en réponse à notre fonction, nous obtenons Faux! <br>  Voyons quelle est la raison. <br><br>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSDN</a> , ce qui suit est écrit sur le reste de l'opérateur de division%: <br>  "Pour les opérandes entiers, le résultat de% b est la valeur produite par a - (a / b) * b" <br>  Dans notre cas, pour a = -5, b = 2 on obtient: <br>  -5% 2 = (-5) - ((-5) / 2) * 2 = -5 + 4 = -1 <br>  Mais -1 n'est pas toujours égal à 1, ce qui explique notre résultat Faux. <br><br>  L'opérateur% est sensible au signe des opérandes.  Par conséquent, afin de ne pas recevoir de telles «surprises», il est préférable de comparer le résultat avec zéro, qui n'a aucun signe: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Ou obtenez une fonction distincte pour vérifier la parité et implémenter la logique à travers elle: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEvenNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !isEvenNumber(i); }</code> </pre><br></div></div><br><h4>  Exemple 4 </h4><br>  Tous ceux qui ont programmé en C # ont probablement rencontré LINQ, ce qui est si pratique pour travailler avec des collections, créer des requêtes, filtrer et agréger des données ... <br><br>  Nous ne regarderons pas sous le capot de LINQ.  Peut-être que nous le ferons une autre fois. <br><br>  En attendant, considérons un petit exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }); Console.WriteLine(summResult);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Que produira ce code?</b> <div class="spoiler_text">  Nous obtenons à l'écran la valeur de la variable summResult, qui est égale à la valeur initiale, c'est-à-dire  0. <br><br>  Pourquoi est-ce arrivé? <br><br>  Et parce que la définition d'une requête LINQ et le lancement de cette requête sont deux opérations qui sont effectuées séparément.  Ainsi, la définition d'une requête ne signifie pas son lancement / exécution. <br><br>  La variable summResult est utilisée à l'intérieur d'un délégué anonyme dans la méthode Select: les éléments du tableau dataArray sont triés séquentiellement et ajoutés à la variable summResult. <br><br>  Nous pouvons supposer que notre code imprimera la somme des éléments du tableau dataArray.  Mais LINQ ne fonctionne pas de cette façon. <br><br>  Considérez la variable selectedData.  Le mot clé var est «sucre syntaxique», ce qui dans de nombreux cas réduit la taille du code du programme et améliore sa lisibilité.  Et le type réel de la variable selectedData implémente l'interface IEnumerable.  C'est-à-dire  notre code ressemble à ceci: <br><br><pre> <code class="cs hljs"> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; });</code> </pre><br>  Ici, nous définissons la requête (Query), mais la requête elle-même ne démarre pas.  De la même manière, vous pouvez travailler avec la base de données en spécifiant la requête SQL sous forme de chaîne, mais pour obtenir le résultat, reportez-vous à la base de données et exécutez cette requête de manière explicite. <br><br>  Autrement dit, jusqu'à présent, nous avons seulement déposé une demande, mais nous ne l'avons pas lancée.  C'est pourquoi la valeur de la variable summResult reste inchangée.  Une requête peut être lancée, par exemple, à l'aide des méthodes ToArray, ToList ou ToDictionary: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        selectedData IEnumerable&lt;int&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; return x; }); //   selectedData selectedData.ToArray(); //    summResult Console.WriteLine(summResult);</span></span></code> </pre><br>  Ce code affichera déjà la valeur de la variable summResult, égale à la somme de tous les éléments du tableau dataArray, égale à 15. <br><br>  Nous l'avons compris.  Et puis qu'est-ce que ce programme affichera à l'écran? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//1 var summResult = dataArray.Sum() + dataArray.Skip(3).Take(2).Sum(); //2 var groupedData = dataArray.GroupBy(x =&gt; x).Select( //3 x =&gt; { summResult += x.Key; return x.Key; }); Console.WriteLine(summResult); //4</span></span></code> </pre><br>  La variable groupedData (ligne 3) implémente en fait l'interface IEnumerable et définit essentiellement la demande à la source de données dataArray.  Cela signifie que pour qu'un délégué anonyme fonctionne, ce qui modifie la valeur de la variable summResult, cette demande doit être exécutée explicitement.  Mais il n'y a pas un tel lancement dans notre programme.  Par conséquent, la valeur de la variable summResult ne sera modifiée qu'à la ligne 2, et nous ne pouvons pas prendre en compte tout le reste dans nos calculs. <br><br>  Ensuite, il est facile de calculer la valeur de la variable summResult, qui est, respectivement, 15 + 7, c'est-à-dire  22. <br></div></div><br><h4>  Exemple 5 </h4><br>  Disons tout de suite - nous ne considérons pas cet exemple lors de nos conférences à l'Académie, mais parfois nous en discutons pendant les pauses café plutôt comme une blague. <br><br>  Malgré le fait qu'il ne soit guère indicatif du point de vue de la détermination du niveau du développeur, nous avons rencontré cet exemple dans plusieurs tests différents.  Peut-être qu'il est utilisé pour la polyvalence, car il fonctionne de la même manière en C et C ++, ainsi qu'en C # et Java. <br><br>  Qu'il y ait donc une ligne de code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Quelle sera la valeur de la variable i?</b> <div class="spoiler_text">  Réponse: 1 <br><br>  Vous pourriez penser que l'arithmétique numérique est utilisée ici sur les tailles de chaque type en octets, car les signes «+» et «-» sont plutôt inattendus ici pour la conversion de type. <br><br>  En C #, le type entier est connu pour être de 4 octets de long, 8 de long, car 2. <br><br>  Il est alors facile de penser que notre ligne de code sera équivalente à l'expression arithmétique suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">2</span></span>)-(<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">8</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br>  Mais ce n'est pas le cas.  Et pour confondre et diriger par un tel faux raisonnement, l'exemple peut être changé, par exemple, comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)-<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  Les signes «+» et «-» sont utilisés dans cet exemple non pas comme des opérations arithmétiques binaires, mais comme des opérateurs unaires.  Ensuite, notre ligne de code n'est qu'une séquence de conversions de type explicites mélangées à des appels à des opérations unaires, qui peuvent être écrites comme suit: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)( <span class="hljs-comment"><span class="hljs-comment">// call explicit operator int(char), ie char to int +( // call unary operator + (char)( // call explicit operator char(int), ie int to char -( // call unary operator - (int)( // call explicit operator int(long), ie long to int +( // call unary operator + (long)( // call explicit operator long(int), ie int to long -1 ) ) ) ) ) ) );</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/0a/wm/vn/0awmvncxvmyw1jzjgc_uavq8rf8.jpeg" alt="image"><br><br><h3>  Intéressé par l'apprentissage à la Veeam Academy? </h3><br>  Maintenant, il y a un ensemble pour le printemps intensif sur C # à Saint-Pétersbourg, et nous invitons tout le monde à subir des tests en ligne sur le site Web de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Veeam Academy.</a> <br><br>  Le cours commence le 18 février 2019, se poursuit jusqu'à la mi-mai et sera, comme toujours, entièrement gratuit.  L'inscription pour toute personne qui souhaite subir un test d'entrée est déjà disponible sur le site Web de l'Académie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">academy.veeam.ru</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vg/k6/ol/vgk6olkeyayj8hqamzvva75ycrk.jpeg" alt="image" width="50%"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439478/">https://habr.com/ru/post/fr439478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439466/index.html">La sonde en orbite lunaire de la NASA a pris les premières photos de la station chinoise Chang'e-4 - deux pixels de lumière</a></li>
<li><a href="../fr439468/index.html">Où mène la recherche du SCADA parfait</a></li>
<li><a href="../fr439470/index.html">L'Allemagne prévoit d'abandonner le charbon dans un avenir proche</a></li>
<li><a href="../fr439472/index.html">Automatisation du contrôle des frontières au sein de l'entreprise</a></li>
<li><a href="../fr439476/index.html">Argot de Cockney: histoire moderne et statut social</a></li>
<li><a href="../fr439480/index.html">Cédez le passage, ou pourquoi votre CRM (et CRM) ralentit-il?</a></li>
<li><a href="../fr439482/index.html">devleads - motivation (non) financière</a></li>
<li><a href="../fr439484/index.html">Obtention de données d'énumération dans une perspective Automapper</a></li>
<li><a href="../fr439486/index.html">Types de référence .NET vs types de valeur. Partie 1</a></li>
<li><a href="../fr439488/index.html">Enregistrement vidéo Meetup QA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>