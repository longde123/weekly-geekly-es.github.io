<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÆ ü§õüèæ üöÜ Padr√£o descart√°vel (Princ√≠pio do projeto descart√°vel) pt.3 üåå üëπ üí∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading 


 Agora vamos falar sobre gelo fino. Nas se√ß√µes anteriores sobre IDisposable, tocamos em um conceito muito importante subjacente n√£o ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Padr√£o descart√°vel (Princ√≠pio do projeto descart√°vel) pt.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443962/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="multithreading">  Multithreading </h2><br><p>  Agora vamos falar sobre gelo fino.  Nas se√ß√µes anteriores sobre IDisposable, tocamos em um conceito muito importante subjacente n√£o apenas aos princ√≠pios de design de tipos descart√°veis, mas a qualquer tipo em geral.  Este √© o conceito de integridade do objeto.  Isso significa que, em um dado momento, um objeto est√° em um estado estritamente determinado e qualquer a√ß√£o com esse objeto transforma seu estado em uma das op√ß√µes pr√©-determinadas ao projetar um tipo desse objeto.  Em outras palavras, nenhuma a√ß√£o com o objeto deve transform√°-lo em um estado indefinido.  Isso resulta em um problema com os tipos projetados nos exemplos acima.  Eles n√£o s√£o seguros para threads.  H√° uma chance de os m√©todos p√∫blicos desses tipos serem chamados quando a destrui√ß√£o de um objeto estiver em andamento.  Vamos resolver esse problema e decidir se devemos resolv√™-lo. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre><code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; object _disposingSync = new object(); public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Seek(int position) { lock(_disposingSync) { CheckDisposed(); // Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  O c√≥digo de valida√ß√£o <code>_disposed</code> em Dispose () deve ser inicializado como uma se√ß√£o cr√≠tica.  De fato, todo o c√≥digo de m√©todos p√∫blicos deve ser inicializado como uma se√ß√£o cr√≠tica.  Isso resolver√° o problema do acesso simult√¢neo a um m√©todo p√∫blico de um tipo de inst√¢ncia e a um m√©todo de destrui√ß√£o.  No entanto, traz outros problemas que se tornam uma bomba de tempo: </p><br><ul><li>  O uso intensivo de m√©todos de inst√¢ncia de tipo, bem como a cria√ß√£o e destrui√ß√£o de objetos, reduzir√£o significativamente o desempenho.  Isso ocorre porque a trava consome tempo.  Esse tempo √© necess√°rio para alocar tabelas SyncBlockIndex, verificar o thread atual e muitas outras coisas (trataremos deles no cap√≠tulo sobre multithreading).  Isso significa que teremos que sacrificar o desempenho do objeto ao longo de sua vida √∫til pela ‚Äú√∫ltima milha‚Äù de sua vida. </li><li>  Tr√°fego de mem√≥ria adicional para objetos de sincroniza√ß√£o. </li><li>  Etapas adicionais que o GC deve seguir para passar por um gr√°fico de objeto. </li></ul><br><p>  Agora, vamos citar o segundo e, na minha opini√£o, o mais importante.  Permitimos a destrui√ß√£o de um objeto e, ao mesmo tempo, esperamos trabalhar com ele novamente.  O que esperamos nesta situa√ß√£o?  que isso ir√° falhar?  Como se o Dispose for executado primeiro, o uso dos m√©todos de objeto a seguir resultar√° definitivamente em <code>ObjectDisposedException</code> .  Portanto, voc√™ deve delegar a sincroniza√ß√£o entre as chamadas Dispose () e outros m√©todos p√∫blicos de um tipo para o lado do servi√ßo, ou seja, para o c√≥digo que criou a inst√¢ncia da classe <code>FileWrapper</code> .  Isso ocorre porque apenas o lado criador sabe o que far√° com uma inst√¢ncia de uma classe e quando destru√≠-la.  Por outro lado, uma chamada Dispose deve produzir apenas erros cr√≠ticos, como <code>OutOfMemoryException</code> , mas n√£o IOException por exemplo.  Isso ocorre devido aos requisitos para a arquitetura de classes que implementam IDisposable.  Isso significa que, se Dispose for chamado de mais de um encadeamento de cada vez, a destrui√ß√£o de uma entidade pode ocorrer a partir de dois encadeamentos simultaneamente <code>if(_disposed) return;</code> a verifica√ß√£o do <code>if(_disposed) return;</code> ).  Depende da situa√ß√£o: se um recurso <em>puder ser</em> liberado v√°rias vezes, n√£o haver√° necessidade de verifica√ß√µes adicionais.  Caso contr√°rio, a prote√ß√£o √© necess√°ria: </p><br><pre> <code class="plaintext hljs">// I don't show the whole pattern on purpose as the example will be too long // and will not show the essence class Disposable : IDisposable { private volatile int _disposed; public void Dispose() { if(Interlocked.CompareExchange(ref _disposed, 1, 0) == 0) { // dispose } } }</code> </pre> <br><h2 id="two-levels-of-disposable-design-principle">  Dois n√≠veis de Princ√≠pio de Design Descart√°vel </h2><br><p>  Qual √© o padr√£o mais popular para implementar <code>IDisposable</code> que voc√™ pode encontrar nos livros do .NET e na Internet?  Que padr√£o √© esperado de voc√™ durante as entrevistas para um novo emprego em potencial?  Provavelmente este: </p><br><pre> <code class="plaintext hljs">public class Disposable : IDisposable { bool _disposed; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(disposing) { // here we release managed resources } // here we release unmanaged resources } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</code> </pre> <br><p>  O que h√° de errado com este exemplo e por que n√£o escrevemos assim antes?  De fato, esse √© um bom padr√£o adequado para todas as situa√ß√µes.  No entanto, seu uso onipresente n√£o √© um bom estilo, na minha opini√£o, pois quase n√£o lidamos com recursos n√£o gerenciados na pr√°tica, o que faz com que metade do padr√£o n√£o sirva para nada.  Al√©m disso, como gerencia simultaneamente recursos gerenciados e n√£o gerenciados, viola o princ√≠pio da divis√£o de responsabilidades.  Eu acho que isso est√° errado.  Vamos olhar para uma abordagem um pouco diferente.  <em>Princ√≠pio do projeto descart√°vel</em> .  Em resumo, funciona da seguinte maneira: </p><br><p>  O descarte √© dividido em dois n√≠veis de classes: </p><br><ul><li>  Os tipos de n√≠vel 0 encapsulam diretamente recursos n√£o gerenciados <br><ul><li>  Eles s√£o abstratos ou compactados. </li><li>  Todos os m√©todos devem ser marcados: <br>  - PrePrepareMethod, para que um m√©todo possa ser compilado ao carregar um tipo <br><ul><li>  SecuritySafeCritical para se proteger contra uma chamada do c√≥digo, trabalhando sob restri√ß√µes </li><li>  ReliabilityContract (Consistency.WillNotCorruptState, Cer.Success / MayFail)] para colocar o CER em um m√©todo e em todas as chamadas filho <br>  - Eles podem fazer refer√™ncia aos tipos de n√≠vel 0, mas devem incrementar o contador de objetos de refer√™ncia para garantir a ordem correta de entrada na "√∫ltima milha" </li></ul></li></ul></li><li>  Os tipos de n√≠vel 1 encapsulam apenas recursos gerenciados <br><ul><li>  Eles s√£o herdados apenas dos tipos de N√≠vel 1 ou implementam diretamente IDisposable </li><li>  Eles n√£o podem herdar tipos de N√≠vel 0 ou CriticalFinalizerObject </li><li>  Eles podem encapsular os tipos gerenciados de N√≠vel 1 e N√≠vel 0 </li><li>  Eles implementam o IDisposable.Dispose destruindo objetos encapsulados a partir dos tipos de n√≠vel 0 e indo para o n√≠vel 1 </li><li>  Eles n√£o implementam um finalizador, pois n√£o lidam com recursos n√£o gerenciados </li><li>  Eles devem conter uma propriedade protegida que d√™ acesso aos tipos de n√≠vel 0. </li></ul></li></ul><br><p>  √â por isso que usei a divis√£o em dois tipos desde o in√≠cio: o que cont√©m um recurso gerenciado e o que possui um recurso n√£o gerenciado.  Eles devem funcionar de maneira diferente. </p><br><h2 id="other-ways-to-use-dispose">  Outras maneiras de usar Dispose </h2><br><p>  A id√©ia por tr√°s da cria√ß√£o do IDisposable era liberar recursos n√£o gerenciados.  Mas, como em muitos outros padr√µes, √© muito √∫til para outras tarefas, por exemplo, liberar refer√™ncias a recursos gerenciados.  Embora liberar recursos gerenciados n√£o pare√ßa muito √∫til.  Quero dizer, eles s√£o chamados de gerenciados de prop√≥sito, para que possamos relaxar com um sorriso em rela√ß√£o aos desenvolvedores de C / C ++, certo?  No entanto, n√£o √© assim.  Sempre pode haver uma situa√ß√£o em que perdemos uma refer√™ncia a um objeto, mas ao mesmo tempo pensamos que est√° tudo bem: o GC coletar√° lixo, incluindo o nosso objeto.  No entanto, verifica-se que a mem√≥ria cresce.  Entramos no programa de an√°lise de mem√≥ria e vemos que outra coisa cont√©m esse objeto.  O problema √© que pode haver uma l√≥gica para a captura impl√≠cita de uma refer√™ncia √† sua entidade na plataforma .NET e na arquitetura de classes externas.  Como a captura est√° impl√≠cita, um programador pode perder a necessidade de seu lan√ßamento e depois obter um vazamento de mem√≥ria. </p><br><h3 id="delegates-events">  Delegados, eventos </h3><br><p>  Vejamos este exemplo sint√©tico: </p><br><pre> <code class="plaintext hljs">class Secondary { Action _action; void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action(); } } class Primary { Secondary _foo = new Secondary(); public void PlanSayHello() { _foo.SaveForUseInFuture(Strategy); } public void SayHello() { _foo.CallAction(); } void Strategy() { Console.WriteLine("Hello!"); } }</code> </pre> <br><p>  Qual problema esse c√≥digo mostra?  A classe secund√°ria armazena o tipo de <code>Action</code> delegado no campo <code>_action</code> que √© aceito no m√©todo <code>SaveForUseInFuture</code> .  Em seguida, o m√©todo <code>PlanSayHello</code> dentro <code>Primary</code> classe <code>Primary</code> passa o ponteiro para o m√©todo <code>Strategy</code> para <code>Secondary</code> classe <code>Secondary</code> .  √â curioso, mas se, neste exemplo, voc√™ passar em algum lugar um m√©todo est√°tico ou um m√©todo de inst√¢ncia, o <code>SaveForUseInFuture</code> transmitido n√£o ser√° alterado, mas uma inst√¢ncia de classe <code>Primary</code> ser√° referenciada <em>implicitamente</em> ou de nenhuma maneira.  Externamente, parece que voc√™ instruiu qual m√©todo chamar.  Mas, de fato, um delegado √© constru√≠do n√£o apenas usando um ponteiro de m√©todo, mas tamb√©m usando o ponteiro para uma inst√¢ncia de uma classe.  Um interlocutor deve entender para qual inst√¢ncia de uma classe deve chamar o m√©todo <code>Strategy</code> !  Essa √© a inst√¢ncia da classe <code>Secondary</code> que implicitamente aceitou e mant√©m o ponteiro para a inst√¢ncia da classe <code>Primary</code> , embora ela n√£o seja indicada explicitamente.  Para n√≥s, significa apenas que, se <code>_foo</code> ponteiro <code>_foo</code> para outro lugar e perdermos a refer√™ncia ao <code>Primary</code> , o GC <em>n√£o coletar√° o</em> objeto <code>Primary</code> , pois o <code>Secondary</code> o manter√°.  Como podemos evitar tais situa√ß√µes?  Precisamos de uma abordagem determinada para divulgar uma refer√™ncia para n√≥s.  Um mecanismo que se encaixa perfeitamente a esse prop√≥sito √© <code>IDisposable</code> </p><br><pre> <code class="plaintext hljs">// This is a simplified implementation class Secondary : IDisposable { Action _action; public event Action&lt;Secondary&gt; OnDisposed; public void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action?.Invoke(); } void Dispose() { _action = null; OnDisposed?.Invoke(this); } }</code> </pre> <br><p>  Agora o exemplo parece aceit√°vel.  Se uma inst√¢ncia de uma classe for passada para terceiros e a refer√™ncia ao delegado <code>_action</code> for perdida durante esse processo, definiremos como zero e o terceiro ser√° notificado sobre a destrui√ß√£o da inst√¢ncia e excluiremos a refer√™ncia a ela. . <br>  O segundo perigo de c√≥digo executado nos delegados s√£o os princ√≠pios de funcionamento do <code>event</code> .  Vejamos o que eles resultam: </p><br><pre> <code class="plaintext hljs"> // a private field of a handler private Action&lt;Secondary&gt; _event; // add/remove methods are marked as [MethodImpl(MethodImplOptions.Synchronized)] // that is similar to lock(this) public event Action&lt;Secondary&gt; OnDisposed { add { lock(this) { _event += value; } } remove { lock(this) { _event -= value; } } }</code> </pre> <br><p>  O sistema de mensagens C # oculta as partes internas dos eventos e mant√©m todos os objetos que se inscreveram para atualizar atrav√©s do <code>event</code> .  Se algo der errado, uma refer√™ncia a um objeto assinado permanecer√° em <code>OnDisposed</code> e o manter√°.  √â uma situa√ß√£o estranha, pois em termos de arquitetura obtemos um conceito de "fonte de eventos" que n√£o deve conter nada logicamente.  Mas, de fato, os objetos inscritos na atualiza√ß√£o s√£o mantidos implicitamente.  Al√©m disso, n√£o podemos alterar algo dentro dessa matriz de delegados, embora a entidade nos perten√ßa.  A √∫nica coisa que podemos fazer √© excluir esta lista atribuindo null a uma fonte de eventos. </p><br><p>  A segunda maneira √© implementar m√©todos <code>add</code> / <code>remove</code> explicitamente, para que possamos controlar uma cole√ß√£o de delegados. </p><br><blockquote>  Outra situa√ß√£o impl√≠cita pode aparecer aqui.  Pode parecer que, se voc√™ atribuir nulo a uma fonte de eventos, a seguinte assinatura de eventos causar√° <code>NullReferenceException</code> .  Eu acho que isso seria mais l√≥gico. </blockquote><p>  No entanto, isso n√£o √© verdade.  Se o c√≥digo externo se inscrever nos eventos ap√≥s a <code>OnDisposed</code> uma fonte de eventos, o FCL criar√° uma nova inst√¢ncia da classe Action e a armazenar√° no <code>OnDisposed</code> .  Essa implica√ß√£o em C # pode enganar um programador: lidar com campos nulos deve produzir um tipo de alerta, em vez de calma.  Aqui tamb√©m demonstramos uma abordagem quando o descuido de um programador pode levar a vazamentos de mem√≥ria. </p><br><h3 id="lambdas-closures">  Fechamentos Lambdas </h3><br><p>  Usar a√ß√∫car sint√°tico como lambdas √© especialmente perigoso. </p><br><blockquote>  Eu gostaria de abordar o a√ß√∫car sint√°tico como um todo.  Eu acho que voc√™ deve us√°-lo com bastante cuidado e somente se souber exatamente o resultado.  Exemplos com express√µes lambda s√£o fechamentos, fechamentos em Express√µes e muitas outras mis√©rias que voc√™ pode infligir a si mesmo. </blockquote><p>  Obviamente, voc√™ pode dizer que sabe que uma express√£o lambda cria um fechamento e pode resultar em risco de vazamento de recursos.  Mas √© t√£o elegante e agrad√°vel que √© dif√≠cil evitar o uso do lambda em vez de alocar todo o m√©todo, que ser√° descrito em um local diferente do local em que ser√° usado.  De fato, voc√™ n√£o deve aceitar essa provoca√ß√£o, embora nem todos possam resistir.  Vejamos o exemplo: </p><br><pre> <code class="plaintext hljs"> button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);</code> </pre> <br><p>  Concordo, esta linha parece muito segura.  Mas ele esconde um grande problema: agora <code>button</code> vari√°vel <code>button</code> refere-se implicitamente ao <code>service</code> e o mant√©m.  Mesmo se decidirmos que n√£o precisamos mais de <code>service</code> , o <code>button</code> ainda manter√° a refer√™ncia enquanto essa vari√°vel estiver ativa.  Uma das maneiras de resolver esse problema √© usar um padr√£o para criar <code>IDisposable</code> partir de qualquer <code>Action</code> ( <code>System.Reactive.Disposables</code> ): </p><br><pre> <code class="plaintext hljs">// Here we create a delegate from a lambda Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy); // Here we subscribe button.Clicked += action; // We unsubscribe var subscription = Disposable.Create(() =&gt; button.Clicked -= action); // where it is necessary subscription.Dispose();</code> </pre> <br><p>  Admita, isso parece um pouco demorado e perdemos todo o prop√≥sito de usar express√µes lambda.  √â muito mais seguro e simples usar m√©todos privados comuns para capturar vari√°veis ‚Äã‚Äãimplicitamente. </p><br><h3 id="threadabort-protection">  Prote√ß√£o Threadabort </h3><br><p>  Quando voc√™ cria uma biblioteca para um desenvolvedor de terceiros, n√£o pode prever o comportamento dele em um aplicativo de terceiros.  √Äs vezes, voc√™ pode apenas adivinhar o que um programador fez na sua biblioteca que causou um resultado espec√≠fico.  Um exemplo est√° funcionando em um ambiente multithread quando a consist√™ncia da limpeza dos recursos pode se tornar um problema cr√≠tico.  Observe que, quando escrevemos o m√©todo <code>Dispose()</code> , podemos garantir a aus√™ncia de exce√ß√µes.  No entanto, n√£o podemos garantir que, durante a execu√ß√£o do m√©todo <code>Dispose()</code> , n√£o ocorra <code>ThreadAbortException</code> que desabilite nosso encadeamento de execu√ß√£o.  Aqui devemos lembrar que, quando o <code>ThreadAbortException</code> ocorre, todos os blocos catch / finalmente s√£o executados de qualquer maneira (no final de um bloco catch / finalmente o ThreadAbort ocorre mais adiante).  Portanto, para garantir a execu√ß√£o de um determinado c√≥digo usando o Thread.Abort, voc√™ precisa agrupar uma se√ß√£o cr√≠tica na <code>try { ... } finally { ... }</code> , veja o exemplo abaixo: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; _someInstance.Unsubscribe(this); _disposed = true; }</code> </pre> <br><p>  Pode-se abortar isso a qualquer momento usando o <code>Thread.Abort</code> .  Destr√≥i parcialmente um objeto, embora voc√™ ainda possa trabalhar com ele no futuro.  Ao mesmo tempo, o seguinte c√≥digo: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; // ThreadAbortException protection try {} finally { _someInstance.Unsubscribe(this); _disposed = true; } }</code> </pre> <br><p>  est√° protegido contra essa interrup√ß√£o e ser√° executado sem problemas e com certeza, mesmo se <code>Thread.Abort</code> aparecer entre a chamada do m√©todo <code>Unsubscribe</code> e a execu√ß√£o de suas instru√ß√µes. </p><br><h2 id="results">  Resultados </h2><br><h3 id="advantages">  Vantagens </h3><br><p>  Bem, aprendemos muito sobre esse padr√£o mais simples.  Vamos determinar suas vantagens: </p><br><ol><li>  A principal vantagem do padr√£o √© a capacidade de liberar recursos determinadamente, ou seja, quando voc√™ precisar deles. </li><li>  A segunda vantagem √© a introdu√ß√£o de uma maneira comprovada de verificar se uma inst√¢ncia espec√≠fica precisa destruir suas inst√¢ncias ap√≥s o uso. </li><li>  Se voc√™ implementar o padr√£o corretamente, um tipo projetado funcionar√° com seguran√ßa em termos de uso por componentes de terceiros, bem como em termos de descarregamento e destrui√ß√£o de recursos quando um processo falha (por exemplo, devido √† falta de mem√≥ria).  Esta √© a √∫ltima vantagem. </li></ol><br><h3 id="disadvantages">  Desvantagens </h3><br><p>  Na minha opini√£o, esse padr√£o tem mais desvantagens do que vantagens. </p><br><ol><li>  Por um lado, qualquer tipo que implemente esse padr√£o instrui outras partes que, se o usarem, receber√£o uma esp√©cie de oferta p√∫blica.  Isso √© t√£o impl√≠cito que, como no caso de ofertas p√∫blicas, um usu√°rio de um tipo nem sempre sabe que o tipo tem essa interface.  Portanto, voc√™ deve seguir as instru√ß√µes do IDE (digite um ponto, Dis ... e verifique se h√° um m√©todo na lista de membros filtrados de uma classe).  Se voc√™ vir um padr√£o Dispose, dever√° implement√°-lo em seu c√≥digo.  √Äs vezes, isso n√£o acontece imediatamente e, nesse caso, voc√™ deve implementar um padr√£o por meio de um sistema de tipos que adiciona funcionalidade.  Um bom exemplo √© que <code>IEnumerator&lt;T&gt;</code> implica <code>IDisposable</code> . </li><li>  Geralmente, quando voc√™ cria uma interface, √© necess√°rio inserir IDisposable no sistema das interfaces de um tipo quando uma delas precisa herdar IDisposable.  Na minha opini√£o, isso danifica as interfaces que projetamos.  Quero dizer, quando voc√™ cria uma interface, primeiro cria um protocolo de intera√ß√£o.  Este √© um conjunto de a√ß√µes que voc√™ pode executar com <em>algo</em> oculto por tr√°s da interface.  <code>Dispose()</code> √© um m√©todo para destruir uma inst√¢ncia de uma classe.  Isso contradiz a ess√™ncia de um <em>protocolo de intera√ß√£o</em> .  De fato, esses s√£o os detalhes de implementa√ß√£o que se infiltraram na interface. </li><li>  Apesar de determinado, Dispose () n√£o significa destrui√ß√£o direta de um objeto.  O objeto ainda existir√° ap√≥s sua <em>destrui√ß√£o,</em> mas em outro estado.  Para torn√°-lo verdadeiro, CheckDisposed () deve ser o primeiro comando de cada m√©todo p√∫blico.  Isso parece uma solu√ß√£o tempor√°ria que algu√©m nos deu dizendo: "V√° em frente e multiplique"; </li><li>  H√° tamb√©m uma pequena chance de obter um tipo que implemente <code>IDisposable</code> por meio de implementa√ß√£o <em>expl√≠cita</em> .  Ou voc√™ pode obter um tipo que implementa o ID dispon√≠vel, sem chance de determinar quem deve destru√≠-lo: voc√™ ou a parte que o deu.  Isso resultou em um antipadr√£o de v√°rias chamadas de Dispose () que permitem destruir um objeto destru√≠do; </li><li>  A implementa√ß√£o completa √© dif√≠cil e √© diferente para recursos gerenciados e n√£o gerenciados.  Aqui, a tentativa de facilitar o trabalho dos desenvolvedores por meio do GC parece estranha.  Voc√™ pode substituir o m√©todo <code>virtual void Dispose()</code> e introduzir algum tipo DisposableObject que implementa todo o padr√£o, mas que n√£o resolve outros problemas relacionados ao padr√£o; </li><li>  Como regra geral, o m√©todo Dispose () √© implementado no final de um arquivo enquanto '.ctor' √© declarado no in√≠cio.  Se voc√™ modificar uma classe ou introduzir novos recursos, √© f√°cil esquecer de adicionar disposi√ß√£o para eles. </li><li>  Finalmente, √© dif√≠cil determinar a ordem de <em>destrui√ß√£o</em> em um ambiente multithread quando voc√™ usa um padr√£o para gr√°ficos de objetos em que objetos implementam total ou parcialmente esse padr√£o.  Quero dizer situa√ß√µes em que Dispose () pode come√ßar em extremidades diferentes de um gr√°fico.  Aqui √© melhor usar outros padr√µes, por exemplo, o padr√£o Lifetime. </li><li>  O desejo dos desenvolvedores de plataformas de automatizar o controle de mem√≥ria combinado com as realidades: os aplicativos interagem com o c√≥digo n√£o gerenciado com muita frequ√™ncia + voc√™ precisa controlar o lan√ßamento de refer√™ncias a objetos para que o Garbage Collector possa colet√°-los.  Isso acrescenta grande confus√£o ao entender quest√µes como: ‚ÄúComo devemos implementar um padr√£o corretamente‚Äù?  "Existe algum padr√£o confi√°vel"?  Talvez chamando <code>delete obj; delete[] arr;</code> <code>delete obj; delete[] arr;</code>  √© mais simples? </li></ol><br><h2 id="domain-unloading-and-exit-from-an-application">  Descarregamento de dom√≠nio e sa√≠da de um aplicativo </h2><br><p>  Se voc√™ chegou a essa parte, ficou mais confiante no sucesso de futuras entrevistas de emprego.  No entanto, n√£o discutimos todas as perguntas relacionadas a esse padr√£o simples, como pode parecer.  A √∫ltima pergunta √© se o comportamento de um aplicativo √© diferente no caso de coleta simples de lixo e quando o lixo √© coletado durante o descarregamento do dom√≠nio e ao sair do aplicativo.  Essa quest√£o se refere apenas a <code>Dispose()</code> ... No entanto, <code>Dispose()</code> e finaliza√ß√£o andam de m√£os dadas e raramente encontramos uma implementa√ß√£o de uma classe que tenha finaliza√ß√£o, mas n√£o tem o m√©todo <code>Dispose()</code> .  Ent√£o, vamos descrever a finaliza√ß√£o em uma se√ß√£o separada.  Aqui apenas adicionamos alguns detalhes importantes. </p><br><p>  Durante o descarregamento do dom√≠nio do aplicativo, voc√™ descarrega os dois assemblies carregados no dom√≠nio do aplicativo e todos os objetos que foram criados como parte do dom√≠nio a serem descarregados.  De fato, isso significa a limpeza (coleta pelo GC) desses objetos e a chamada de finalizadores para eles.  Se a l√≥gica de um finalizador aguarda a finaliza√ß√£o de outros objetos serem destru√≠dos na ordem correta, voc√™ deve prestar aten√ß√£o √† propriedade <code>Environment.HasShutdownStarted</code> indicando que um aplicativo est√° descarregado da mem√≥ria e ao m√©todo <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code> indicando que isso o dom√≠nio √© descarregado, e √© esse o motivo da finaliza√ß√£o.  Se esses eventos ocorrerem, a ordem de finaliza√ß√£o dos recursos geralmente se torna sem import√¢ncia.  N√£o podemos atrasar o descarregamento do dom√≠nio ou de um aplicativo, pois devemos fazer tudo o mais r√°pido poss√≠vel. </p><br><p>  √â assim que esta tarefa √© resolvida como parte de uma classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LoaderAllocatorScout</a> </p><br><pre> <code class="plaintext hljs">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in // an unmanaged code // So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown. // We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList. if (!Environment.HasShutdownStarted &amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()) { // Destroy returns false if the managed LoaderAllocator is still alive. if (!Destroy(m_nativeLoaderAllocator)) { // Somebody might have been holding a reference on us via weak handle. // We will keep trying. It will be hopefully released eventually. GC.ReRegisterForFinalize(this); } }</code> </pre> <br><h2 id="typical-implementation-faults">  Falhas t√≠picas de implementa√ß√£o </h2><br><p>  Como mostrei a voc√™, n√£o h√° um padr√£o universal para implementar IDisposable.  Al√©m disso, a confian√ßa no controle autom√°tico de mem√≥ria engana as pessoas e elas tomam decis√µes confusas ao implementar um padr√£o.  Todo o .NET Framework est√° cheio de erros em sua implementa√ß√£o.  Para provar meu argumento, vejamos esses erros usando exatamente o exemplo do .NET Framework.  Todas as implementa√ß√µes est√£o dispon√≠veis em: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDisposable Usages</a> </p><br><p>  <strong>Classe</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FileEntry cmsinterop.cs</a> </p><br><blockquote>  Este c√≥digo √© escrito com pressa apenas para fechar o problema.  Obviamente, o autor queria fazer algo, mas mudou de id√©ia e manteve uma solu√ß√£o falha </blockquote><br><pre> <code class="plaintext hljs">internal class FileEntry : IDisposable { // Other fields // ... [MarshalAs(UnmanagedType.SysInt)] public IntPtr HashValue; // ... ~FileEntry() { Dispose(false); } // The implementation is hidden and complicates calling the *right* version of a method. void IDisposable.Dispose() { this.Dispose(true); } // Choosing a public method is a serious mistake that allows for incorrect destruction of // an instance of a class. Moreover, you CANNOT call this method from the outside public void Dispose(bool fDisposing) { if (HashValue != IntPtr.Zero) { Marshal.FreeCoTaskMem(HashValue); HashValue = IntPtr.Zero; } if (fDisposing) { if( MuiMapping != null) { MuiMapping.Dispose(true); MuiMapping = null; } System.GC.SuppressFinalize(this); } } }</code> </pre> <br><p>  <a href="">Sistema de</a> <strong>classes SemaphoreSlim</strong> <a href="">/ Threading / SemaphoreSlim.cs</a> </p><br><blockquote>  Este erro est√° no topo dos erros do .NET Framework em rela√ß√£o ao IDisposable: SuppressFinalize para classes em que n√£o h√° finalizador.  Isso √© muito comum. </blockquote><br><pre> <code class="plaintext hljs">public void Dispose() { Dispose(true); // As the class doesn't have a finalizer, there is no need in GC.SuppressFinalize GC.SuppressFinalize(this); } // The implementation of this pattern assumes the finalizer exists. But it doesn't. // It was possible to do with just public virtual void Dispose() protected virtual void Dispose(bool disposing) { if (disposing) { if (m_waitHandle != null) { m_waitHandle.Close(); m_waitHandle = null; } m_lockObj = null; m_asyncHead = null; m_asyncTail = null; } }</code> </pre> <br><p>  <strong>Chamando Close + Dispose</strong> <a href="">Some NativeWatcher c√≥digo de projeto</a> </p><br><blockquote>  √Äs vezes, as pessoas chamam de Fechar e Dispor.  Isso est√° errado, mas n√£o produzir√° um erro, pois o segundo Dispose n√£o gera uma exce√ß√£o. </blockquote><p>  De fato, Close √© outro padr√£o para tornar as coisas mais claras para as pessoas.  No entanto, tornou tudo mais claro. </p><br><pre> <code class="plaintext hljs">public void Dispose() { if (MainForm != null) { MainForm.Close(); MainForm.Dispose(); } MainForm = null; }</code> </pre> <br><h2 id="general-results">  Resultados gerais </h2><br><ol><li>  O IDposable √© um padr√£o da plataforma e a qualidade de sua implementa√ß√£o influencia a qualidade de todo o aplicativo.  Al√©m disso, em algumas situa√ß√µes, isso influencia a seguran√ßa do seu aplicativo que pode ser atacada por recursos n√£o gerenciados. </li><li>  A implementa√ß√£o do IDisposable deve ser maximamente produtiva.  Isso √© especialmente verdade na se√ß√£o de finaliza√ß√£o, que funciona em paralelo com o restante do c√≥digo, carregando o Garbage Collector. </li><li>  Ao implementar o IDisposable, voc√™ n√£o deve usar Dispose () simultaneamente com m√©todos p√∫blicos de uma classe.  A destrui√ß√£o n√£o pode acompanhar o uso.  Isso deve ser considerado ao projetar um tipo que usar√° o objeto IDisposable. </li><li>  No entanto, deve haver uma prote√ß√£o contra a chamada 'Dispose ()' de dois threads simultaneamente.  Isso resulta da declara√ß√£o de que Dispose () n√£o deve produzir erros. </li><li>  Os tipos que cont√™m recursos n√£o gerenciados devem ser separados de outros tipos.  Quero dizer, se voc√™ agrupar um recurso n√£o gerenciado, aloque um tipo separado para ele.  Esse tipo deve conter a finaliza√ß√£o e deve ser herdado de <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code> .  Essa separa√ß√£o de responsabilidades resultar√° em suporte aprimorado ao sistema de tipos e simplificar√° a implementa√ß√£o para destruir inst√¢ncias de tipos via Dispose (): os tipos com esta implementa√ß√£o n√£o precisar√£o implementar um finalizador. </li><li>  Em geral, esse padr√£o n√£o √© confort√°vel tanto em uso quanto em manuten√ß√£o de c√≥digo.  Provavelmente, devemos usar a abordagem Inversion of Control quando destruirmos o estado dos objetos via padr√£o <code>Lifetime</code> .  No entanto, falaremos sobre isso na pr√≥xima se√ß√£o. </li></ol><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443962/">https://habr.com/ru/post/pt443962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443952/index.html">Internet Soberana - pelo nosso dinheiro</a></li>
<li><a href="../pt443954/index.html">Singularidade tecnol√≥gica: o mito moderno do fim do mundo sob o disfarce da hip√≥tese de progresso</a></li>
<li><a href="../pt443956/index.html">Rede social em 2019: Yandex lan√ßou o Aura</a></li>
<li><a href="../pt443958/index.html">Padr√£o descart√°vel (princ√≠pio do design descart√°vel) pt. 1</a></li>
<li><a href="../pt443960/index.html">Padr√£o descart√°vel (Princ√≠pio do projeto descart√°vel) pt. 2</a></li>
<li><a href="../pt443964/index.html">Kolesa Conf √© a maior confer√™ncia de TI do Cazaquist√£o. An√∫ncio de relat√≥rios</a></li>
<li><a href="../pt443966/index.html">Google Docs - um bate-papo favorito entre os alunos</a></li>
<li><a href="../pt443968/index.html">Como compramos uma casa com pain√©is solares e o que aconteceu</a></li>
<li><a href="../pt443972/index.html">Yandex procurar√° piratas usando um rob√¥</a></li>
<li><a href="../pt443974/index.html">Mem√≥ria e Span pt. 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>