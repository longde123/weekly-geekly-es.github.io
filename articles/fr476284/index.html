<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 ⛱️ 🤵🏽 Nous formulons une stratégie pour travailler avec les erreurs dans React 🛠️ 🚶🏽 🤤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment rendre la chute douce? 


 Je n'ai pas trouvé de guide complet sur la gestion des erreurs dans les applications React, j'ai donc décidé de par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous formulons une stratégie pour travailler avec les erreurs dans React</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476284/"><h2>  Comment rendre la chute douce? </h2><br><img src="https://habrastorage.org/webt/74/fa/c-/74fac--ati8ide9e4o946p1r-4g.jpeg"><br><br>  Je n'ai pas trouvé de guide complet sur la gestion des erreurs dans les applications React, j'ai donc décidé de partager l'expérience acquise dans cet article.  L'article est destiné aux développeurs débutants et peut être un point de départ pour systématiser la gestion des erreurs dans l'application. <br><a name="habracut"></a><br><h3>  Problèmes et définition d'objectifs </h3><br>  Lundi matin, vous buvez calmement du café et vous vantez d'avoir corrigé plus de bugs que la semaine dernière puis le manager vient en courant et agite les mains - «nous sommes tombés, tout est très triste, nous perdons de l'argent».  Vous exécutez et ouvrez votre Mac, accédez à la version de production de votre SPA, faites quelques clics pour jouer au bug, voyez l'écran blanc et seul le Tout-Puissant sait ce qui s'y est passé, montez dans la console, commencez à creuser, à l'intérieur du composant t il y a un composant avec le nom parlant b, dans lequel l'erreur ne peut pas lire la propriété getId d'undefined.  N heures de recherche et vous vous précipitez avec un cri victorieux pour lancer le correctif.  Ces raids se produisent avec une certaine fréquence et sont devenus la norme, mais si je dis que tout peut être différent?  Comment réduire le temps de débogage des erreurs et construire le processus pour que le client ne remarque pratiquement pas d'erreurs de calcul inévitables lors du développement? <br><br>  <b>Examinons dans l'ordre les problèmes que nous avons rencontrés:</b> <br><br><ol><li>  <u>Même si l'erreur est insignifiante ou localisée dans le module, dans tous les cas l'application entière devient inopérante</u> <br>  Avant React version 16, les développeurs ne disposaient pas d'un mécanisme de capture d'erreur standard unique et il y avait des situations où la corruption des données entraînait une baisse du rendu uniquement dans les étapes suivantes ou un comportement d'application étrange.  Chaque développeur a traité les erreurs parce qu'il y était habitué, et le modèle impératif avec try / catch ne correspond généralement pas bien aux principes déclaratifs de React.  Dans la version 16, l'outil Error Boundaries est apparu, qui a essayé de résoudre ces problèmes, nous verrons comment l'appliquer. </li><li>  <u>L'erreur est reproduite uniquement dans l'environnement de production ou ne peut pas être reproduite sans données supplémentaires.</u> <br>  Dans un monde idéal, l'environnement de développement est le même que la production, et nous pouvons reproduire n'importe quel bogue localement, mais nous vivons dans le monde réel.  Il n'y a pas d'outils de débogage sur le système de combat.  Il est difficile et non productif de découvrir de tels incidents, fondamentalement, vous devez faire face au code obscurci et au manque d'informations sur l'erreur, et non à l'essence du problème.  Nous ne considérerons pas la question de savoir comment rapprocher les conditions de l'environnement de développement des conditions de production, cependant, nous considérerons des outils qui vous permettent d'obtenir des informations détaillées sur les incidents qui se sont produits. </li></ol><br>  Tout cela réduit la vitesse de développement et la fidélité des utilisateurs au produit logiciel, je me suis donc fixé les 3 objectifs les plus importants: <br><br><ol><li>  Améliorez l'expérience utilisateur avec l'application en cas d'erreurs; </li><li>  Réduisez le délai entre la mise en production de l'erreur et sa détection; </li><li>  Accélérez le processus de recherche et de débogage des problèmes dans l'application pour le développeur. </li></ol><br>  <b>Quelles tâches doivent être résolues?</b> <br><br><ol><li>  <u>Gérer les erreurs critiques avec la limite d'erreur</u> <br>  Pour améliorer l'expérience utilisateur avec l'application, nous devons intercepter les erreurs d'interface utilisateur critiques et les traiter.  Dans le cas où l'application est constituée de composants indépendants, une telle stratégie permettra à l'utilisateur de travailler avec le reste du système.  Nous pouvons également essayer de prendre des mesures pour restaurer l'application après un plantage, si possible. <br></li><li>  <u>Enregistrer les informations d'erreur étendues</u> <br>  Si une erreur se produit, envoyez des informations de débogage au serveur de surveillance, qui filtrera, stockera et affichera des informations sur les incidents.  Cela nous aidera à détecter rapidement et à déboguer facilement les erreurs après le déploiement. <br></li></ol><br>  <b>Gestion des erreurs critiques</b> <br><br>  Depuis la version 16, React a modifié le comportement standard de gestion des erreurs.  Désormais, les exceptions qui n'ont pas été détectées à l'aide de Error Boundary entraîneront le démontage de l'arborescence React entière et, par conséquent, l'inopérabilité de l'application entière.  Cette décision est argumentée par le fait qu'il vaut mieux ne rien montrer que de donner à l'utilisateur la possibilité d'obtenir des résultats imprévisibles.  Vous pouvez en lire plus dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle de React</a> . <br><br><img src="https://habrastorage.org/webt/jz/-o/ik/jz-oik4v7a3skcbdxn_pttvugq8.png"><br><br>  De plus, beaucoup sont confus par la note que la limite d'erreur ne détecte pas les erreurs des gestionnaires d'événements et du code asynchrone, mais si vous y pensez, tout gestionnaire peut finalement changer l'état, en fonction du nouveau cycle de rendu qui sera appelé, ce qui, finalement, compte peut provoquer une erreur dans le code de l'interface utilisateur.  Sinon, il ne s'agit pas d'une erreur critique pour l'interface utilisateur et elle peut être gérée de manière spécifique à l'intérieur du gestionnaire. <br><br>  De notre point de vue, une erreur critique est une exception qui s'est produite à l'intérieur du code de l'interface utilisateur et si elle n'est pas traitée, l'arborescence React entière sera démontée.  Les erreurs restantes ne sont pas critiques et peuvent être traitées selon la logique de l'application, par exemple, à l'aide de notifications. <br><br>  Dans cet article, nous nous concentrerons sur la gestion des erreurs critiques, malgré le fait que les erreurs non critiques peuvent également entraîner une inopérabilité de l'interface dans le pire des cas.  Leur traitement est difficile à séparer en un bloc commun et chaque cas individuel nécessite une décision en fonction de la logique d'application. <br><br>  En général, les erreurs non critiques peuvent être très critiques (un jeu de mots), donc les informations les concernant doivent être enregistrées de la même manière que pour les erreurs critiques. <br><br>  Nous concevons maintenant la limite d'erreur pour notre application simple, elle se composera d'une barre de navigation, d'un en-tête et d'un espace de travail principal.  Il est assez simple pour se concentrer uniquement sur la gestion des erreurs, mais il a une structure typique pour de nombreuses applications. <br><br><img src="https://habrastorage.org/webt/q6/my/hd/q6myhdx0kjcwrwxe2q7b3sxdweu.png"><br><br>  Nous avons un panneau de navigation de 3 liens, chacun menant à des composants indépendants les uns des autres, nous voulons donc obtenir un comportement tel que même si l'un des composants ne fonctionne pas, nous pouvons continuer à travailler avec les autres. <br><br>  Par conséquent, nous aurons ErrorBoundary pour chaque composant accessible via le menu de navigation et le ErrorBoundary général, qui informe sur le plantage de l'application entière, dans le cas où une erreur s'est produite dans le composant d'en-tête, le panneau de navigation ou dans ErrorBoundary, mais nous ne l'avons pas résolu traiter et jeter plus loin. <br><br>  Envisagez de répertorier une application entière enveloppée dans ErrorBoundary <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppWithBoundary = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Application has crashed"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    &lt;Router&gt;      &lt;Layout&gt;        &lt;Sider width={200}&gt;          &lt;SideNavigation /&gt;        &lt;/Sider&gt;        &lt;Layout&gt;          &lt;Header&gt;            &lt;ActionPanel /&gt;          &lt;/Header&gt;          &lt;Content&gt;            &lt;Switch&gt;              &lt;Route path="/link1"&gt;                &lt;Page1                  title="Link 1 content page"                  errorMessage="Page for link 1 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/link2"&gt;                &lt;Page2                  title="Link 2 content page"                  errorMessage="Page for link 2 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/link3"&gt;                &lt;Page3                  title="Link 3 content page"                  errorMessage="Page for link 3 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/"&gt;                &lt;MainPage                  title="Main page"                  errorMessage="Only main page crashed"                /&gt;              &lt;/Route&gt;            &lt;/Switch&gt;          &lt;/Content&gt;        &lt;/Layout&gt;      &lt;/Layout&gt;    &lt;/Router&gt;  ); }</code> </pre> <br>  Il n'y a pas de magie dans ErrorBoundary, c'est juste un composant de classe dans lequel la méthode componentDidCatch est définie, c'est-à-dire que n'importe quel composant peut devenir ErrorBoundary, si vous y définissez cette méthode. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorBoundary</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{  state = {    <span class="hljs-attr"><span class="hljs-attr">hasError</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,  }  componentDidCatch(error) {    <span class="hljs-comment"><span class="hljs-comment">//            this.setState({ hasError: true });  }  render() {    if (this.state.hasError) {      return (        &lt;Result          status="warning"          title={this.props.errorMessage}          extra={            &lt;Button type="primary" key="console"&gt;              Some action to recover            &lt;/Button&gt;          }  /&gt;      );    }    return this.props.children;  } };</span></span></code> </pre><br>  Voici à quoi ressemble ErrorBoundary pour le composant Page, qui sera rendu dans le bloc Content: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageBody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ title }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  &lt;Content title={title}&gt;    &lt;Empty className="content-empty" /&gt;  &lt;/Content&gt; ); const MainPage = ({ errorMessage, title }) =&gt; (  &lt;ErrorBoundary errorMessage={errorMessage}&gt;    &lt;PageBody title={title} /&gt;  &lt;/ErrorBoundary&gt;</code> </pre><br>  Étant donné que ErrorBoundary est un composant React normal, nous pouvons utiliser le même composant ErrorBoundary pour encapsuler chaque page dans son propre gestionnaire, en passant simplement différents paramètres à ErrorBoundary, car ce sont des instances différentes de la classe, leur état ne dépendra pas les uns des autres . <br><br>  <b>IMPORTANT: ErrorBoundary peut détecter des erreurs uniquement dans les composants qui se trouvent en dessous dans l'arborescence.</b> <br><br>  Dans la liste ci-dessous, l'erreur ne sera pas interceptée par le ErrorBoundary local, mais sera levée et interceptée par le gestionnaire au-dessus de l'arborescence: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ errorMessage }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{errorMessage}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {null.toString()}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre><br>  Et ici, l'erreur est détectée par la limite d'erreur locale: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrorProneComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>.toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ errorMessage }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{errorMessage}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorProneComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br>  Après avoir encapsulé chaque composant séparé dans notre ErrorBoundary, nous avons obtenu le comportement nécessaire, mis le code délibérément erroné dans le composant à l'aide de link3 et voir ce qui se passe.  Nous oublions intentionnellement de passer le paramètre steps: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageBody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ title, steps }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  &lt;Content title={title}&gt;    &lt;Steps current={2} direction="vertical"&gt;      {steps.map(({ title, description }) =&gt; (&lt;Step title={title} description={description} /&gt;))}    &lt;/Steps&gt;  &lt;/Content&gt; ); const Page = ({ errorMessage, title }) =&gt; (  &lt;ErrorBoundary errorMessage={errorMessage}&gt;    &lt;PageBody title={title} /&gt;  &lt;/ErrorBoundary&gt; );</code> </pre><br><img src="https://habrastorage.org/webt/6g/9g/fv/6g9gfvuuusmxrbedlytcmezyghe.png"><br><br>  L'application nous informera qu'une erreur s'est produite, mais elle ne tombera pas complètement, nous pouvons naviguer dans le menu de navigation et travailler avec d'autres sections. <br><br><img src="https://habrastorage.org/webt/4w/os/zh/4woszhf9ahhcl-uzdfwthj-d6a0.png"><br><br>  Une configuration aussi simple nous permet d'atteindre facilement notre objectif, mais dans la pratique, peu de gens accordent beaucoup d'attention au traitement des erreurs, ne planifiant que l'exécution régulière de l'application. <br><br>  <b>Enregistrement des informations d'erreur</b> <br><br>  Maintenant que nous avons placé suffisamment de ErrorBoundary dans notre application, il est nécessaire de sauvegarder les informations sur les erreurs afin de les détecter et de les corriger le plus rapidement possible.  Le moyen le plus simple consiste à utiliser les services SaaS, tels que Sentry ou Rollbar.  Ils ont des fonctionnalités très similaires, vous pouvez donc utiliser n'importe quel service de surveillance des erreurs. <br><br>  Je vais montrer un exemple de base sur Sentry, car en quelques minutes, vous pouvez obtenir des fonctionnalités minimales.  Dans le même temps, Sentry lui-même intercepte les exceptions et modifie même console.log pour obtenir toutes les informations d'erreur.  Après cela, toutes les erreurs qui se produiront dans l'application seront envoyées et stockées sur le serveur.  Sentry dispose de mécanismes de filtrage des événements, d'obscurcissement des données personnelles, de liens vers les versions et bien plus encore.  Nous ne considérerons que le scénario d'intégration de base. <br><br>  Pour vous connecter, vous devez vous inscrire sur leur site officiel et parcourir le guide de démarrage rapide, qui vous dirigera immédiatement après l'inscription. <br><br>  Dans notre application, nous ajoutons seulement quelques lignes et tout décolle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Sentry <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@sentry/browser'</span></span>; Sentry.init({<span class="hljs-attr"><span class="hljs-attr">dsn</span></span>: “https:<span class="hljs-comment"><span class="hljs-comment">//12345f@sentry.io/12345”});</span></span></code> </pre><br>  Encore une fois, cliquez sur le lien / link3 dans notre application et obtenez l'écran d'erreur, après quoi nous allons à l'interface sentinelle, apparemment qu'un événement s'est produit et échoue à l'intérieur. <br><br><img src="https://habrastorage.org/webt/qx/4p/bm/qx4pbm5d1dgv3gvxpabgeydwpoa.png"><br><br>  Les erreurs sont automatiquement regroupées par type, fréquence et heure d'occurrence; divers filtres peuvent être appliqués.  Nous avons un événement - nous y tombons et sur l'écran suivant, nous voyons un tas d'informations utiles, par exemple, la trace de la pile <br><br><img src="https://habrastorage.org/webt/bq/o8/ed/bqo8ed5grqrsme3yw8wa4rftwhu.png"><br><br>  et la dernière action de l'utilisateur avant l'erreur (fil d'Ariane). <br><br><img src="https://habrastorage.org/webt/bq/o8/ed/bqo8ed5grqrsme3yw8wa4rftwhu.png"><br><br>  Même avec une configuration aussi simple, nous pouvons accumuler et analyser les informations sur les erreurs et les utiliser pour un débogage ultérieur.  Dans cet exemple, une erreur est envoyée par le client en mode développement, afin que nous puissions observer les informations complètes sur le composant et les erreurs.  Afin d'obtenir des informations similaires à partir du mode de production, vous devez en outre configurer la synchronisation des données de version avec Sentry, qui stockera le sourcemap en lui-même, vous permettant ainsi d'enregistrer suffisamment d'informations sans augmenter la taille du bundle.  Nous ne considérerons pas une telle configuration dans le cadre de cet article, mais j'essaierai de parler des pièges d'une telle solution dans un article séparé après sa mise en œuvre. <br><br>  <b>Le résultat:</b> <br><br>  La gestion des erreurs à l'aide de ErrorBoundary nous permet de lisser les coins avec un plantage partiel de l'application, augmentant ainsi l'expérience utilisateur du système et l'utilisation de systèmes de surveillance des erreurs spécialisés pour réduire le temps de détection et de débogage des problèmes. <br><br>  Réfléchissez soigneusement à une stratégie de traitement et de surveillance des erreurs de votre application, cela vous fera gagner beaucoup de temps et d'efforts à l'avenir.  <b>Une stratégie bien pensée améliorera principalement le processus de traitement des incidents, et ce n'est qu'alors qu'elle affectera la structure du code.</b> <br><br>  <i>PS</i> Vous pouvez essayer différentes options de configuration ErrorBoundary ou connecter vous-même Sentry à l'application dans la branche feature_sentry, en remplaçant les clés par celles obtenues lors de l'inscription sur le site. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application de démonstration Git-hub</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle de React's Error Boundary</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476284/">https://habr.com/ru/post/fr476284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476270/index.html">Notre victoire: TopCoder Open 2019</a></li>
<li><a href="../fr476272/index.html">Réponses aux tâches du stand PVS-Studio lors des conférences 2018-2019</a></li>
<li><a href="../fr476276/index.html">Écrire un simple équilibreur sur Go</a></li>
<li><a href="../fr476278/index.html">Conférence BLACK HAT USA. Devenez riche ou mourez: gagnez de l'argent sur Internet en utilisant Black Hat. 3e partie</a></li>
<li><a href="../fr476280/index.html">À travers les épines jusqu'au DOS: quatre disquettes qui ont changé le monde</a></li>
<li><a href="../fr476286/index.html">Top 5 des cadres JS pour le développement frontal en 2020. Partie 1</a></li>
<li><a href="../fr476288/index.html">Top 5 des cadres JS pour le développement frontal en 2020. 2e partie</a></li>
<li><a href="../fr476290/index.html">Gestion des erreurs dans Express</a></li>
<li><a href="../fr476292/index.html">SVG ou toile?</a></li>
<li><a href="../fr476294/index.html">Réseau de jeu distribué comme alternative à GFN: comment et pourquoi il peut décoller, là où il fonctionne déjà en Fédération de Russie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>