<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐁 🥊 🌞 Système d'exploitation en temps réel AQUA RTOS pour MK AVR dans l'environnement BASCOM AVR ✍🏽 🚳 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsqu'il écrit pour du code MK plus compliqué que «clignoter une lumière», le développeur est confronté aux limitations inhérentes à la programmation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Système d'exploitation en temps réel AQUA RTOS pour MK AVR dans l'environnement BASCOM AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453708/"> Lorsqu'il écrit pour du code MK plus compliqué que «clignoter une lumière», le développeur est confronté aux limitations inhérentes à la programmation linéaire dans le style de «supercycle plus interruptions».  Le traitement des interruptions nécessite de la rapidité et de la concision, ce qui conduit à ajouter des indicateurs au code et à rendre le style de projet «super-cycle avec interruptions et indicateurs». <br><br>  Si la complexité du système augmente, le nombre de drapeaux interdépendants augmente exponentiellement et le projet se transforme rapidement en un «code de pâtes» mal lisible et gérable. <br><br>  L'utilisation de systèmes d'exploitation en temps réel permet de se débarrasser du "code des pâtes" et de rendre la flexibilité et la gérabilité à un projet MK complexe. <br>  Plusieurs systèmes d'exploitation coopératifs en temps réel ont été développés et très appréciés des microcontrôleurs AVR.  Cependant, ils sont tous écrits en C ou Assembleur et ne conviennent pas à ceux qui programment MK dans l'environnement BASCOM AVR, les privant d'un outil aussi utile pour écrire des applications sérieuses. <br><br>  Pour corriger cette lacune, j'ai développé un RTOS simple pour l'environnement de programmation BASCOM AVR, que je porte à l'attention des lecteurs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/0be/c64/cd60bec64b2a0b96ed562770a9063355.jpg" alt="image"><br><a name="habracut"></a><br>  Pour beaucoup, le style de programmation MK familier est le soi-disant  <i>supercycle</i> .  Dans ce cas, le code se compose d'un ensemble de fonctions, procédures et descripteurs (constantes, variables), éventuellement ceux de bibliothèque, généralement appelés «code d'arrière-plan», ainsi qu'une grande boucle infinie enfermée dans une construction <b>do-loop</b> .  Au démarrage, l'équipement du MK lui-même et des appareils externes est d'abord initialisé, les constantes et les valeurs initiales des variables sont définies, puis le contrôle est transféré à ce supercycle infini. <br>  La simplicité du supercycle est évidente.  La plupart des tâches effectuées par MK, parce que d'une manière ou d'une autre cyclique.  Les inconvénients sont également évidents: si un appareil ou un signal nécessite une réaction immédiate, MK le fournira au plus tôt lorsque le cycle se retournera.  Si la durée du signal est plus courte que la période de cycle, un tel signal sera ignoré. <br><br>  Dans l'exemple ci-dessous, nous voulons vérifier si le bouton est <b>enfoncé</b> : <br><br><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">' -  if button = 1 then '     '  -  loop</span></span></code> </pre> <br>  Évidemment, si "un certain code" fonctionne assez longtemps, MK peut ne pas remarquer une courte pression sur un bouton. <br><br>  Heureusement, MK est équipé d'un système d'interruption qui peut résoudre ce problème: tous les signaux critiques peuvent être «suspendus» aux interruptions et un gestionnaire peut être écrit pour chacun.  Le niveau suivant apparaît donc: un <i>supercycle avec des interruptions</i> . <br>  L'exemple ci-dessous montre la structure du programme avec un supercycle et une interruption qui traite un clic de bouton: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  loop end '   button_isr: '  -    return</span></span></code> </pre> <br>  Cependant, l'utilisation d'interruptions pose un nouveau problème: le code du gestionnaire d'interruptions doit être aussi rapide et court que possible;  à l'intérieur des interruptions, la fonctionnalité MK est limitée.  Étant donné que les AVR MK n'ont pas de système d'interruption hiérarchique, une autre interruption ne peut pas se produire à l'intérieur d'une interruption - ils sont actuellement désactivés sur le plan matériel.  L'interruption doit donc être exécutée le plus rapidement possible, sinon les autres interruptions (et éventuellement les plus importantes) seront ignorées et non traitées. <br><br><div class="spoiler">  <b class="spoiler_title">Interrompre la mémoire</b> <div class="spoiler_text">  En fait, étant à l'intérieur de l'interruption, MK est capable de noter le fait d'une autre interruption dans un registre spécial, ce qui permet de la traiter plus tard.  Cependant, cette interruption ne peut pas être traitée immédiatement. <br></div></div><br>  Par conséquent, nous ne pouvons pas écrire quelque chose de compliqué dans le gestionnaire d'interruption, surtout si ce code doit avoir des retards - car jusqu'à ce que le retard fonctionne, le MK ne reviendra pas au programme principal (supercycle) et sera sourd aux autres interruptions. <br><br>  Pour cette raison, dans le gestionnaire d'interruption, vous n'avez souvent qu'à signaler le fait de l'événement avec un indicateur - le vôtre pour chaque événement - puis à vérifier et à traiter les indicateurs à l'intérieur du supercycle.  Bien sûr, cela rallonge le temps de réaction à l'événement, mais au moins nous ne manquons pas quelque chose d'important. <br><br>  Ainsi, le prochain niveau de complexité se pose - un <i>supercycle avec des interruptions et des drapeaux</i> . <br><br>  Le code suivant s'affiche: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  if button_flag = 1 then '     button_flag = 0 '     end if '  -  loop end ' ***    *** button_isr: button_flag = 1 return</span></span></code> </pre> <br>  Un nombre considérable de programmes pour MK sont limités par cela.  Cependant, ces programmes sont généralement encore plus ou moins simples.  Si vous écrivez quelque chose de plus compliqué, alors le nombre de drapeaux commence à croître comme une boule de neige, et le code devient de plus en plus confus et illisible.  De plus, dans l'exemple ci-dessus, le problème des retards n'a pas été résolu.  Bien sûr, vous pouvez "suspendre" une interruption distincte sur la minuterie, et dans celle-ci ... également contrôler divers drapeaux.  Mais cela rend le programme complètement moche, le nombre de drapeaux interdépendants augmente de façon exponentielle, et même le développeur lui-même peut difficilement trouver un tel "code de pâtes" assez rapidement.  Essayer de trouver une erreur ou de modifier le code devient souvent égal dans les efforts pour développer un nouveau projet. <br><br>  Comment résoudre le problème du "code de pâtes" et le rendre plus lisible et gérable?  Le <i>système d'exploitation</i> (OS) vient à la rescousse.  Dans ce document, la fonctionnalité que MK doit implémenter est divisée en tâches dont le fonctionnement est contrôlé par le système d'exploitation. <br><br><h2>  Types de systèmes d'exploitation pour MK </h2><br>  Les systèmes d'exploitation pour MK peuvent être divisés en deux grandes classes: OS avec éviction et OS coopératif.  Dans l'un de ces systèmes d'exploitation, les tâches sont contrôlées par une procédure spéciale appelée <i>répartiteur</i> .  Dans un OS avec <i>éviction, le</i> répartiteur bascule indépendamment à tout moment l'exécution d'une tâche à une autre, en allouant à chacun un certain nombre de cycles d'horloge (éventuellement différents, selon la priorité de la tâche).  Cette approche dans son ensemble fonctionne très bien, vous permettant de ne pas regarder du tout le contenu des tâches: vous pouvez écrire au moins le code de la tâche <br><br><pre> <code class="vbscript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  - et le reste des tâches (y compris celle-ci) seront toujours exécutées.  Cependant, les systèmes d'exploitation préemptifs nécessitent beaucoup de ressources (mémoire du processeur et cycles d'horloge), car chaque commutateur doit enregistrer complètement le contexte de la tâche à désactiver et charger le contexte de la reprise.  Le contexte se réfère ici au contenu des registres de la machine et de la pile (BASCOM utilise deux piles - une matérielle pour les adresses de retour des sous-programmes et une logicielle pour transmettre les arguments).  Non seulement une telle charge nécessite beaucoup de cycles de processeur, mais le contexte de chaque tâche doit également être stocké quelque part pendant un certain temps jusqu'à ce qu'il fonctionne.  Dans les "gros" processeurs, initialement orientés vers le multitâche, ces fonctions sont souvent prises en charge dans le matériel, et elles ont beaucoup plus de ressources.  Dans AVR MK, il n'y a pas de prise en charge matérielle pour le multitâche (tout doit être fait «manuellement»), et la mémoire disponible est petite.  Par conséquent, les OS de déplacement, bien qu'ils existent, ne conviennent pas trop aux MK simples. <br><br>  Une autre chose est le <i>système d'exploitation coopératif</i> .  Ici, la tâche elle-même contrôle à quel moment transférer le contrôle au répartiteur, lui permettant de démarrer d'autres tâches.  De plus, les tâches ici sont nécessaires pour ce faire - sinon l'exécution du code se bloquera.  D'une part, il semble que cette approche réduit la fiabilité globale: si une tâche se bloque, elle n'appellera jamais le répartiteur et l'ensemble du système cessera de répondre.  D'un autre côté, un code linéaire ou un supercycle n'est pas mieux à cet égard - car ils peuvent geler avec exactement le même risque. <br><br>  Cependant, un OS coopératif a un avantage important.  Étant donné qu'ici le programmeur définit le moment de la commutation lui-même, cela ne peut pas se produire soudainement, par exemple, pendant que la tâche travaille avec une ressource ou au milieu du calcul d'une expression arithmétique.  Par conséquent, dans un système d'exploitation coopératif, dans la plupart des cas, vous pouvez vous passer du maintien du contexte.  Cela économise considérablement le temps et la mémoire du processeur, et semble donc beaucoup plus adapté à la mise en œuvre sur MK AVR. <br><br><h2>  Changement de tâche dans BASCOM AVR </h2><br>  Afin d'implémenter la commutation de tâches dans l'environnement BASCOM AVR, le code de tâche, dont chacune est implémentée comme une procédure normale, doit en quelque sorte appeler le répartiteur - également implémenté comme une procédure normale. <br>  Imaginez que nous ayons deux tâches, chacune à un endroit quelconque de son code étant appelée par le répartiteur. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> task1() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">'  1 '  loop end sub ' ---------------------------------- sub task2() do '  2 '  loop end sub</span></span></code> </pre> <br>  Supposons que la tâche 1 a été exécutée. Voyons ce qui se passe sur la pile lorsqu'elle exécute un «appel de répartiteur»: <br><br><blockquote>  adresse de retour au code principal (2 octets) <br>  haut de la pile -&gt; adresse de retour à la tâche 1 qui a appelé le répartiteur (2 octets) </blockquote><br>  Le haut de la pile pointera vers l'adresse de l'instruction de la tâche 1, qui suit l'appel du répartiteur (l'instruction de <b>boucle</b> dans notre exemple). <br><br>  L'objectif du répartiteur dans le cas le plus simple est de transférer le contrôle à la tâche 2. La question est de savoir comment procéder?  (supposons que le répartiteur connaisse déjà l'adresse de la tâche 2). <br><br>  Pour ce faire, le répartiteur doit extraire l'adresse de retour à la tâche 1 de la pile (et un endroit à retenir), puis mettre l'adresse de la tâche 2 à cet endroit de la pile, puis donner la commande de retour.  Le processeur extraira l'adresse qui y est placée de la pile et, au lieu de revenir à la tâche 1, procédera à l'exécution de la tâche 2. <br><br>  À son tour, lorsque la tâche 2 appelle le répartiteur, nous retirons également la pile et enregistrons l'adresse où il sera possible de revenir à la tâche 2 et de charger l'adresse de la tâche 1 précédemment enregistrée dans la pile. Donnez la commande de <b>retour</b> et nous serons au point de continuation de la tâche 1 . <br><br>  En conséquence, nous obtenons un tel gâchis: <br><br><blockquote>  Tâche 1 -&gt; Dispatcher -&gt; Tâche 2 -&gt; Dispatcher -&gt; Tâche 1 .... </blockquote><br>  Pas mal!  Et ça marche.  Mais, bien sûr, cela ne suffit pas pour un système d'exploitation pratiquement utilisable.  Après tout, toutes les tâches ne doivent pas toujours fonctionner - par exemple, elles peuvent <i>s'attendre à</i> quelque chose (l'expiration du délai, l'apparition d'un signal, etc.).  Ainsi, les tâches doivent avoir un <i>statut</i> (TRAVAUX, PRÊT, ATTENDU, etc.).  De plus, il serait bien que les tâches soient <i>prioritaires</i> .  Ensuite, si plusieurs tâches sont prêtes à être exécutées, le répartiteur poursuivra la tâche qui a la priorité la plus élevée. <br><br><h2>  AQUA RTOS </h2><br>  Pour mettre en œuvre l'idée décrite, la coopérative OS AQUA RTOS a été développée, qui fournit les services nécessaires aux tâches et permet la mise en œuvre du multitâche coopératif dans l'environnement BASCOM AVR. <br><br><div class="spoiler">  <b class="spoiler_title">Avis important concernant le mode de procédure dans BASCOM AVR</b> <div class="spoiler_text">  Avant de commencer la description de AUQA RTOS, il convient de noter que l'environnement BASCOM AVR prend en charge deux types de procédures d'adressage.  Ceci est régulé par le sous-mode de configuration = new |  vieux. <br>  Dans le cas de la spécification de l'ancienne option, le compilateur, d'une part, compilera tout le code de manière linéaire, qu'il soit utilisé quelque part ou non, et d'autre part, les procédures sans arguments conçus dans le style de sub name / end sub seront perçues comme des procédures , dans le style du nom: / return.  Cela nous permet de passer l'adresse de la procédure sous forme d'étiquette comme argument à une autre procédure en utilisant le modificateur bylabel.  Cela s'applique également aux procédures conçues dans le style du sous-nom / sous-style de fin (vous devez passer le nom de la procédure sous forme d'étiquette). <br>  Dans le même temps, le mode submode = old impose certaines restrictions: les procédures de tâche ne doivent pas contenir d'arguments;  le code des fichiers connectés via $ include est inclus dans le projet général de manière linéaire, par conséquent, le contournement doit être fourni dans les fichiers connectés - passez du début à la fin en utilisant goto et une étiquette. <br>  Ainsi, dans AQUA RTOS, l'utilisateur doit soit utiliser uniquement l'ancienne notation de tâche dans le style nom_tâche: / return pour les tâches, soit utiliser le sous-nom / sous-titre le plus courant, en ajoutant le modificateur submode = old au début de son code, et contourner les fichiers inclus goto label / include file code / label:. <br></div></div><br><h3>  États des tâches AQUA RTOS </h3><br>  Les statuts suivants sont définis pour les tâches dans AQUA RTOS: <br><br><pre> <code class="vbscript hljs">OSTS_UNDEFINE OSTS_READY OSTS_RUN OSTS_DELAY OSTS_STOP OSTS_WAIT OSTS_PAUSE OSTS_RESTART</code> </pre> <br>  Si la tâche n'a pas encore été initialisée, elle se voit attribuer le statut <b>OSTS_UNDEFINE</b> . <br>  Après l'initialisation, la tâche a le statut <b>OSTS_STOP</b> . <br>  Si la tâche <i>est prête à être exécutée</i> , elle se voit attribuer le statut <b>OSTS_READY</b> . <br>  La tâche en cours d'exécution a le statut <b>OSTS_RUN</b> . <br>  De là, elle peut aller aux statuts <b>OSTS_STOP, OSTS_READY, OSTS_DELAY, OSTS_WAIT, OSTS_PAUSE</b> . <br>  Le statut <b>OSTS_DELAY</b> a une tâche remplissant un <i>délai</i> . <br>  Le statut <b>OSTS_WAIT est</b> affecté aux tâches qui <i>attendent un sémaphore, un événement ou un message</i> (plus d'informations à leur sujet ci-dessous). <br><br>  Quelle est la différence entre les <b>statuts</b> <b>OSTS_STOP</b> et <b>OSTS_PAUSED</b> ? <br>  Si, pour une raison quelconque, la tâche reçoit le statut <b>OSTS_STOP</b> , la reprise ultérieure de la tâche (à la réception du statut <b>OSTS_READY</b> ) sera effectuée à partir de son point d'entrée, c'est-à-dire  dès le début.  À partir du statut <b>OSTS_PAUSE, la</b> tâche continuera de fonctionner à l'endroit où elle a été suspendue. <br><br><h3>  Gestion de l'état des tâches </h3><br>  Le système d'exploitation lui-même peut gérer automatiquement les tâches, ainsi que l'utilisateur, en appelant les services du système d'exploitation.  Il existe plusieurs services de gestion des tâches (les noms de tous les services OS commencent par le préfixe <b>OS_</b> ): <br><br><pre> <code class="vbscript hljs">OS_InitTask(task_label, task_prio) OS_Stop() OS_StopTask(task_label) OS_Pause() OS_PauseTask(task_label) OS_Resume() OS_ResumeTask(task_label) OS_Restart()</code> </pre> <br>  Chacun d'eux a deux options: <b>OS_service</b> et <b>OS_serviceTask</b> (à l'exception du service <b>OS_InitTask</b> , qui n'a qu'une seule option; le service <b>OS_Init</b> initialise le système d'exploitation lui-même). <br><br>  Quelle est la différence entre <b>OS_service</b> et <b>OS_serviceTask</b> ?  La première méthode agit sur la tâche elle-même qui l'a provoquée;  la seconde vous permet de définir comme argument un pointeur vers une autre tâche et donc d'en gérer une autre à partir d'une tâche. <br><br><div class="spoiler">  <b class="spoiler_title">À propos d'OS_Resume</b> <div class="spoiler_text">  Tous les services de gestion des tâches, à l'exception de OS_Resume et OS_ResumeTask, appellent automatiquement le gestionnaire de tâches après le traitement.  En revanche, les services OS_Resume * définissent uniquement l'état de la tâche sur OSTS_READY.  Ce statut sera traité uniquement lorsque le répartiteur est explicitement appelé. <br></div></div><br><h3>  Priorité et file d'attente des tâches </h3><br>  Comme mentionné ci-dessus, dans un système réel, certaines tâches peuvent être plus importantes, tandis que d'autres peuvent être secondaires.  Par conséquent, une fonctionnalité utile du système d'exploitation est la possibilité d'attribuer une priorité aux tâches.  Dans ce cas, s'il y a plusieurs tâches prédéfinies en même temps, le système d'exploitation sélectionnera d'abord la tâche avec la priorité la plus élevée.  Si <b>toutes les</b> tâches prédéfinies ont une priorité égale, le système d'exploitation les mettra à exécution dans un cercle, dans un ordre appelé "carrousel" ou round-robin. <br><br>  Dans AQUA RTOS, la priorité est affectée à une tâche lorsqu'elle est <i>initialisée</i> via un appel au service <b>OS_InitTask</b> , qui <b>reçoit l'</b> adresse de la tâche comme premier argument et un nombre compris entre 1 et 15 comme deuxième argument. <i>Un nombre inférieur signifie une priorité plus élevée</i> .  Pendant le fonctionnement de l'OS, aucune modification de la priorité affectée à la tâche n'est fournie. <br><br><h3>  Retards </h3><br>  Dans chaque tâche, le retard est traité indépendamment des autres tâches. <br>  Ainsi, pendant que le système d'exploitation calcule le retard d'une tâche, d'autres peuvent être exécutées. <br>  Pour l'organisation des retards fournis les services <b>OS_Delay |</b>  <b>OS_DelayTask</b> .  L'argument est le nombre de millisecondes pendant lequel la tâche est <i>retardée</i> .  La dimension de l'argument étant <b>dword</b> , le délai maximum est de 4294967295 ms, soit environ 120 heures, ce qui semble suffisant pour la plupart des applications.  Après avoir appelé le service de retard, le répartiteur est automatiquement appelé, ce qui transfère le contrôle à d'autres tâches pendant la durée du retard. <br><br><h3>  Sémaphores </h3><br>  Les sémaphores dans AQUA RTOS sont quelque chose comme des indicateurs et des variables disponibles pour les tâches.  Ils sont de deux types - binaires et dénombrables.  Les premiers n'ont que deux états: libre et fermé.  Le second est un compteur d'octets (le service de comptage des sémaphores dans la version actuelle d'AQUA RTOS n'est pas implémenté (je suis un paresseux), donc tout ce qui est dit ci-dessous ne s'applique qu'aux sémaphores binaires). <br><br>  La différence entre un sémaphore et un simple indicateur est que la tâche peut être effectuée pour <i>attendre la libération du</i> sémaphore spécifié.  À certains égards, l'utilisation de sémaphores ressemble vraiment à un chemin de fer: en atteignant le sémaphore, la composition (tâche) vérifiera le sémaphore, et s'il n'est pas ouvert, il attendra que le signal d'activation apparaisse pour aller plus loin.  À ce moment, d'autres trains (tâches) peuvent continuer à se déplacer (rouler). <br><br>  Dans ce cas, tout le travail noir est affecté au répartiteur.  Dès qu'il est demandé à la tâche d'attendre le sémaphore, le contrôle est automatiquement transféré au répartiteur et il peut démarrer d'autres tâches - jusqu'à ce que le sémaphore spécifié soit libéré.  Dès que l'état du sémaphore devient <i>libre</i> , le répartiteur affecte à toutes les tâches qui attendaient ce sémaphore l'état <i>prêt</i> ( <b>OSTS_READY</b> ), et elles seront exécutées dans l'ordre de priorité et de priorité. <br>  Au total, AQUA RTOS fournit 16 sémaphores binaires (ce nombre peut, en principe, être augmenté en modifiant la dimension de la variable dans l'unité de contrôle des tâches, car à l'intérieur, ils sont implémentés sous forme de drapeaux binaires). <br>  Les sémaphores binaires fonctionnent via les services suivants: <br><br><pre> <code class="vbscript hljs">hBSem OS_CreateBSemaphore() OS_WaitBSemaphore(hBSem) OS_WaitBSemaphoreTask(task_label, hBSem) OS_BusyBSemaphore(hBSem) OS_FreeBSemaphore(hBSem)</code> </pre> <br>  Avant d'utiliser un sémaphore doit être <i>créé</i> .  Cela se fait en appelant le service <b>OS_CreateBSemaphore</b> , qui renvoie l'identificateur d'octet unique (handle) du sémaphore <b>hBSem</b> créé, ou via le gestionnaire défini par l'utilisateur génère une erreur <b>OSERR_BSEM_MAX_REACHED</b> , indiquant que le nombre maximal possible de sémaphores binaires a été atteint. <br><br>  Vous pouvez travailler avec l'identifiant reçu en le passant comme argument à d'autres services de sémaphore. <br><br>  Service <b>OS_WaitBSemaphore |</b>  <b>OS_WaitBSemaphoreTask</b> met la tâche (actuelle | spécifiée) dans un état pour <i>attendre la libération du sémaphore</i> <b>hBSem</b> si ce sémaphore est occupé, puis transfère le contrôle au répartiteur afin qu'il puisse démarrer d'autres tâches.  Si le sémaphore est libre, le transfert de contrôle ne se produit pas et la tâche se poursuit simplement. <br><br>  Les <b>services</b> <b>OS_BusyBSemaphore</b> et <b>OS_FreeBSemaphore</b> définissent le sémaphore <b>hBSem</b> sur <i>occupé</i> ou <i>libre,</i> respectivement. <br><br>  La destruction des sémaphores afin de simplifier le système d'exploitation et de réduire la quantité de code n'est pas fournie.  Ainsi, tous les sémaphores créés sont statiques. <br><br><h3>  Les événements </h3><br>  En plus des sémaphores, les tâches peuvent être pilotées par des événements.  Une tâche peut être chargée d' <i>attendre un certain événement</i> , et une autre tâche (ainsi que le code d'arrière-plan) peut <i>signaler</i> cet événement.  Dans le même temps, toutes les tâches qui attendaient cet événement recevront le statut <i>prêt pour l'exécution</i> ( <b>OSTS_READY</b> ) et seront définies par le répartiteur pour exécution dans l'ordre de priorité et de priorité. <br><br>  À quels événements la tâche peut-elle répondre?  Eh bien, par exemple: <br><ul><li>  interruption; </li><li>  occurrence d'une erreur; </li><li>  libération de la ressource (il est parfois plus pratique d'utiliser un sémaphore pour cela); </li><li>  changer l'état de la ligne d'E / S ou appuyer sur une touche du clavier; </li><li>  recevoir ou envoyer un caractère via RS-232; </li><li>  transfert d'informations d'une partie de l'application à une autre (voir aussi messages). </li></ul><br>  Le système d'événements est implémenté via les services suivants: <br><br><pre> <code class="vbscript hljs">hEvent OS_CreateEvent() OS_WaitEvent(hEvent) OS_WaitEventTask(task_label, hEvent) OS_WaitEventTO(hEvent, dwTimeout) OS_SignalEvent(hEvent)</code> </pre> <br>  Avant d'utiliser un événement, vous devez <i>le créer</i> .  Cela se fait en appelant la fonction <b>OS_CreateEvent</b> , qui renvoie un identifiant d'octet unique (handle) pour l'événement <b>hEvent</b> , ou renvoie une erreur <b>OSERR_EVENT_MAX_REACHED</b> via le gestionnaire défini par l'utilisateur, indiquant que la limite du nombre d'événements pouvant être générés dans le système d'exploitation a été atteinte (255 événements différents maximum). <br><br>  Pour faire attendre une tâche à un événement <b>hEvent</b> , appelez <b>OS_WaitEvent</b> dans son code, en passant le <b>descripteur d'</b> événement comme argument.  Après avoir appelé ce service, le contrôle sera automatiquement transféré au répartiteur. <br><br>  Contrairement au service de sémaphore, le service d'événements fournit une option pour attendre un événement avec un <i>délai d'expiration</i> .  Pour ce faire, utilisez le service <b>OS_WaitEventTO</b> .  Le deuxième argument ici, vous pouvez spécifier le nombre de millisecondes pendant lequel la tâche peut attendre l'événement.  Si le délai spécifié a expiré, la tâche recevra le statut <i>prêt à être exécuté</i> comme si l'événement s'était produit et sera définie par le répartiteur pour poursuivre l'exécution dans l'ordre de priorité et de priorité.  La tâche peut découvrir qu'il ne s'agissait pas d'un événement, mais d'un délai d'expiration, que la tâche pouvait vérifier en vérifiant l' <b>indicateur</b> global <b>OS_TIMEOUT</b> . <br><br> <i></i>             <b>OS_SignalEvent</b> ,       .    ,   ,    <i>  </i> ,           . <br><br><h3>  Des messages </h3><br>        ,       :         ,           –   . <br>     : <br><br><pre> <code class="vbscript hljs">hTopic OS_CreateMessage() OS_WaitMessage(hTopic) OS_WaitMessageTask(task_label, hTopic) OS_WaitMessageTO(hTopic, dwTimeout) OS_SendMessage(hTopic, wMessage) word_ptr OS_GetMessage(hTopic) word_ptr OS_PeekMessage(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_GetMessageString(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_PeekMessageString(hTopic)</code> </pre> <br>    ,    <i> </i> .     <b>OS_CreateMessage</b> ,      <b>hTopic</b> ,       <b>OSERR_TOPIC_MAX_REACHED</b> ,   ,       ,     . <br><br>        <b>hTopic</b> ,      <b>OS_WaitMessage</b> ,      .          .  ,        <i>    <b>hTopic</b></i> . <br><br>     <b>OS_WaitMessageTO</b>    <b>OS_WaitEventTO</b>  . <br><br>      <b>OS_SendMessage</b> .     ,     ,   –   <b>word</b> .      ,   <i>  </i> , ,   ,    . <br><br>    ,     BASCOM  <b>varptr</b> , , : <br><br><pre> <code class="vbscript hljs">strMessage = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span> OS_SendMessage hTopic, varptr (strMessage)</code> </pre> <br>     <b>OS_WaitMessage</b> ,  ,    ,          ,     —      .        .      <b>word</b> ,      ,    ,   .   <b>OS_GetMessage</b>   ,  <b>OS_PeekMessage</b>  . <br><br>     ,   ,    <b>OS_GetMessageString</b>  <b>OS_PeekMessageString</b> ,     ,   ,     . <br><br><h3>    </h3><br>        AQUA RTOS       <b>TIMER0</b> .  ,   (  )     .      , ..          .    1 . <br><br><h2>    AQUA RTOS </h2><br><h3>   </h3><br>       ,           .   <b>OS_SIM = TRUE | FALSE</b> ,    . <br><br>  ,      <b>OS_MAX_TASK</b> ,       .    ,     (  ),      .        ,   . <i>    ,    .</i> <br><br><h3>   </h3><br>    AQUA RTOS   .      <b>OS_Init</b> .      .    ,     –     .  ,   ,    –  . <br><br>         (    ) –      ,            .          ,      -    . <br><br> ,     AQUA RTOS            : <br><br><pre> <code class="vbscript hljs">OS_Init my_err_trap <span class="hljs-comment"><span class="hljs-comment">'... '... '... sub my_err_trap(err_code as byte) print err_code end sub</span></span></code> </pre> <br><h3>   </h3><br>     ,     : <br><br><pre> <code class="vbscript hljs">OS_InitTask task_1, <span class="hljs-number"><span class="hljs-number">1</span></span> OS_InitTask task_2 , <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">'... OS_InitTask task_N , 1</span></span></code> </pre> <br><h2>   </h2><br><h3>   </h3><br> ,    ,       Arduino Nano V3.       -  (, test),     bas-: <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() '       led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output ' ***    *** '   OS_Init my_err_trap '   OS_InitTask task_1, 1 OS_InitTask task_2 , 1 '      «» (OSTS_STOP) '    ,     ' «  » (OSTS_READY)   OS_ResumeTask OS_ResumeTask task_1 OS_ResumeTask task_2 '      OS_Sheduler end ' ***  *** sub task_1 () do toogle led_1 '   1 OS_delay 1000 '   1000  loop end sub sub task_2 () do toogle led_2 '   2 OS_delay 333 '   333  loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br>      <b>D4</b>  <b>D5</b>  Arduino (   ,   -  ).     100...500     <b>GND</b> .      .       2  0,66 . <br><br>   . ,     (  ,      aliases),  –  ,   – . <br><br>         «»,     «  » (,       –  -           ,        ,      ;          ).        <b>OS_ResumeTask</b> . <br><br>     ,    .    ? , !          . ,    ,      ,         <b>end</b> . <br><br>    .    ,         <b>do – loop</b> .    –            ,   ,      –       ,      .       <b>OS_Delay</b> .        ,       . <br><br>       <b>OS_SIM = TRUE</b>       ,   ,   ,   . <br><br> ,   , ,      «  »,       .   ,    «   »,         . <br><br>  ,    (, <b>task_1</b> ),       (     <b>end</b>   )     <b>task_1</b> ,       ,    <b>return</b> ,             –  ,    <b>task_1</b> ( <b>do</b>   <b>task_1</b> ). <br><br>  <b>task_1</b> ,   ,   <b>OS_delay</b> , ,   ,   . <br><br>   ,    ,     <b>task_1</b> (  ,    <b>OS_delay</b> , ..  <b>loop</b> ),  , « », ,      <b>task_2</b> .       <b>task_2</b> (      <b>do</b>    <b>task_2</b> )    <b>return</b> ,             –  ,    <b>task_2</b> . <br><br>  <b>task_2</b> ,   ,   <b>OS_delay</b> , ,   ,   . <br><br>   ,    ,     <b>task_1</b> (  ,    <b>OS_delay</b> , ..  <b>loop</b> ),  , « », ,      <b>task_2</b> .       ,       <b>task_1</b>     ,   ,      .  (  <b>loop</b>    <b>task_1</b> ),    . <br><br>  <b>task_1</b>   <b>loop</b> ,     « 1 –  –  2 – »   . <br><br><h3>   </h3><br>         . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() const OS_SIM = TURE '       '   dim hTopic as byte '     dim task_1_cnt as byte '    1 dim strMessage as string * 16 '  ' ***    *** OS_CreateMessage hTopic OS_Init my_err_trap OS_InitTask task_1 , 1 OS_InitTask task_2 , 1 OS_ResumeTask task_1 OS_ResumeTask task_2 OS_Sheduler end ' ***  *** sub task_1() do print "task 1" OS_Sheduler incr task_1_cnt '    1 if task_1_cnt &gt; 3 then print "task 1 is sending message to task 2" strMessage = "Hello, task 2!" '    2 OS_SendMessage hTopic , varptr(strMessage) task_1_cnt = 0 end if loop end sub sub task_2() do print "task 2 is waiting messages..." '      1 OS_WaitMessage hTopic print "message recieved: " ; OS_GetMessageString (hTopic) loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br>           : <br><br><blockquote> task 1 <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br> task 1 <br> task 1 is sending message to task 2 <br> task 1 <br> message recieved: Hello, task 2! <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br>  ... <br></blockquote><br>  ,        .    1  <b>task 1</b> ,     ,      .  2  <b>task 2 is waiting messages...</b> ,        <b>hTopic</b> ,     ,     1.    <b>task 1</b>     . ,   ,   2   ,     1   <b>incr</b> ,    . <br>   <b>task_1_cnt</b>   1   ,   ,    –   <b>loop</b>    <b>task 1</b> .     ,   ,    2  ,    .    . <br><br><h3>   </h3><br>             : <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_scankeys() declare sub task_led_1() declare sub task_led_2() '        led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output button_1 alias pind.6 button_2 alias pind.7 config portd.6 = input config portd.7 = input '   dim eventButton_1 as byte dim eventButton_2 as byte ' ***    *** eventButton_1 = OS_CreateEvent '       eventButton_2 = OS_CreateEvent OS_Init my_err_trap OS_InitTask task_scankeys , 1 OS_InitTask task_led_1 , 1 OS_InitTask task_led_2 , 1 OS_ResumeTask task_scankeys OS_ResumeTask task_led_1 OS_ResumeTask task_led_2 OS_Sheduler end ' ***  *** sub task_scankeys() do debounce button_1 , 0 , btn_1_click , sub debounce button_2 , 0 , btn_2_click , sub OS_Sheduler loop btn_1_click: OS_SignalEvent eventButton_1 return btn_2_click: OS_SignalEvent eventButton_2 return end sub sub task_led_1() do OS_WaitEvent eventButton_1 toggle led_1 loop end sub sub task_led_2() do OS_WaitEvent eventButton_2 toggle led_2 loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><h2>     AQUA RTOS </h2><br><br>   ,         .           ;     ,   ,  .  ,     : ,      95…97°;               (,  GSM-),      . <br><br><h3>    </h3><br>         « +  + »  ,     .     ,    . <br>        : <br><br><ul><li>     – <b>ControlHeater()</b> </li><li>      – <b>ShowGoods()</b> </li><li>  /    – <b>AcceptMoney()</b> </li><li>   – <b>ScanKeys()</b> </li><li>   – <b>MakeChange()</b> </li><li>   – <b>ReleaseCoffee()</b> </li><li>    – <b>Alarm()</b> </li></ul><br>        . <br> <b>ControlHeater()</b>  ,        .       ,      ,    .      .     5. <br> <b>ShowGoods()</b>   .       ,   -   .      8,             . <br> <b>ScanKeys()</b>     ,       .     3,      40 . <br> <b>AcceptMoney()</b>     .      ,   <b>ScanKeys(),</b>     20 . <br> <b>MakeChange ()</b>     .     <b>ReleaseCoffee()</b>    10. <br> <b>ReleaseCoffee()</b>   ,           .       2. <br>   –    ,  <b>Alarm()</b>      – 1,     ,      . <br><br>  ,       .  ,      EEPROM   ,       . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    declare sub ControlHeater() declare sub ShowGoods() declare sub AcceptMoney() declare sub ScanKeys() declare sub MakeChange () declare sub ReleaseCoffee() declare sub Alarm()</span></span></code> </pre> <br>     RTOS      :          (  ,    ) –      . <br><br> , <b>ReleaseCoffee()</b>    : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> ReleaseCoffee() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> OS_WaitMessage bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) Release wItem <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre> <br>  <b>ReleaseCoffee</b>        <b>bCoffeeSelection</b>    ,     (   ,      ).    , <b>ReleaseCoffee()</b>    ,    ,     (  ) <b>wItem</b>    <b>OS_GetMessage</b>    .  <b>ReleaseCoffee()</b>   ,       : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage()</code> </pre> <br>    , <b>ShowGoods()</b>            .       <b>ReleaseCoffee()</b> ,   .       : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bGoodsReliased as byte bGoodsReliased = OS_CreateEvent()</code> </pre> <br>    <b>ReleaseCoffee()</b>   <b>Release wItem</b>     <b>bGoodsReliased</b> : <br><br><pre> <code class="vbscript hljs">OS_SignalEvent bGoodsReliased</code> </pre> <br><h3>   </h3><br>  ,     ,    ,      ,     .      <b>OS_Init</b> : <br><br><pre> <code class="vbscript hljs">OS_Init Mailfuncion</code> </pre> <br>       – ,      : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> Mailfuncion (bCoffeeErr) print <span class="hljs-string"><span class="hljs-string">"Mailfunction! Error #: "</span></span>; bCoffeeErr <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isErrCritical (bCoffeeErr) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallService(bCoffeeErr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre><br>      (    -  :  ,  GSM-  ..),   ,   ,    . <br><br><h3>   </h3><br>   ,  ,   ..     ,   .  ,           <b>OS_InitTask</b> : <br><br><pre> <code class="vbscript hljs">OS_InitTask ControlHeater , <span class="hljs-number"><span class="hljs-number">5</span></span> OS_InitTask ShowGoods , <span class="hljs-number"><span class="hljs-number">8</span></span> OS_InitTask AcceptMoney , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask ScanKeys , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask MakeChange, <span class="hljs-number"><span class="hljs-number">10</span></span> OS_InitTask ReleaseCoffee , <span class="hljs-number"><span class="hljs-number">2</span></span> OS_InitTask Alarm , <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>      , ,    , ,         .          .     ,      <b>OS_ResumeTask</b>    «  »: <br><br><pre> <code class="vbscript hljs">OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm</code> </pre> <br>   ,         ;          «»       .  <b>OS_ResumeTask</b>           (  ),    . ,  ,    ,   . <br><br><h3>   </h3><br>     ,   .     : <br><br><pre> <code class="vbscript hljs">OS_Sheduler</code> </pre> <br>          <b>end</b> –         . <br><br>     : <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $include "coffee_hardware.bas" '      '       Coffee_ $regfile = "m328pdef.dat" ' Arduino Nano v3 $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 Coffee_InitHardware '    '   declare sub Mailfuncion (byval bCoffeeErr as byte) '   declare sub ControlHeater () '   declare sub ShowGoods () '    declare sub AcceptMoney () '   declare sub ScanKeys () '   declare sub MakeChange () '      declare sub ReleaseCoffee () '   declare sub Alarm () '    '     Coffee_InitHardware () '   dim wMoney as long '    dim wGoods as long '   ' ***    *** '   OS_Init Mailfuncion '       dim bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage() '     dim bGoodsReliased as byte bGoodsReliased = OS_CreateEvent() '   OS_InitTask ControlHeater , 5 OS_InitTask ShowGoods , 8 OS_InitTask AcceptMoney , 3 OS_InitTask ScanKeys , 3 OS_InitTask MakeChange, 10 OS_InitTask ReleaseCoffee , 2 OS_InitTask Alarm , 1 '     OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm '   OS_Sheduler end ' ***   *** ' ----------------------------------- sub ControlHeater() do select case GetWaterTemp() case is &gt; 97 Coffee_HeaterOff '   case is &lt; 95 Coffee_HeaterOn '   case is &lt; 5 CallServce (WARNING_WATER_FROZEN) '   end select OS_Delay 60000 '  1  loop end sub ' ----------------------------------- sub ShowGoods() do LEDS = Coffee_GetDrinkSupplies() '    D, '         '   LEDS OS_WaitEvent bGoodsReliased '   " " loop end sub ' ----------------------------------- sub AcceptMoney() do wMoney = wMoney + ReadMoneyAcceptor() OS_Delay 20 loop end sub ' ----------------------------------- sub ScanKeys() do wGoods = ButtonPressed() if wMoney &gt;= GostOf(wGoods) then OS_SendMessage bCoffeeSelection, wGoods '     bCoffeeSelection,  '     end if OS_Delay 40 loop end sub ' ----------------------------------- sub MakeChange() do OS_WaitEvent bGoodsReliased '   " " Refund wMoney loop end sub ' ----------------------------------- sub ReleaseCoffee() do OS_WaitMessage bCoffeeSelection '  bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) '   Release wItem '    wMoney = wMoney – CostOf (wItem) '     OS_SignalEvent bGoodsReliased '     '  ,       : ' MakeChange  ShowGoods '  ,  ,     loop end sub ' ----------------------------------- sub Alarm() do OS_Delay 1000 if Hijack() = 1 then CallPolice() end if loop end sub ' ----------------------------------- ' ***    *** sub Mailfuncion (bCoffeeErr) print "Mailfunction! Error #: "; bCoffeeErr if isErrCritical (bCoffeeErr) = 1 then CallService() end if end sub</span></span></code> </pre> <br> ,             ,    .              <b>OS_SendMessage()</b>  ,        /.     .  ,   ,  ,  ,     . <br><br><h2>   AQUA RTOS </h2><br> <a href=""><b>   1.05     </b></a> <br><br><h2>  </h2><br> <i>Q:  AQUA?</i> <br> A: ,    ,   « »,   ,   .   ,   ,     ,  ,  « »   WiFi-.   ,  ,  ,     EEPROM  ,  , - .            .      –       « »,    ,  .    ,    .    AQUA. <br><br> <i>Q:        ?</i> <br> A: . ,  ,          ,      ,    ,    .   ,        .    ,   ,      ,       ,    ,  , -,  .   ,         . , -     ( ? –   )    .         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453708/">https://habr.com/ru/post/fr453708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453694/index.html">Connectez-vous à Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453696/index.html">Reliure angulaire bidirectionnelle, un peu plus de compréhension</a></li>
<li><a href="../fr453698/index.html">L'information quantique dans la conscience quantique</a></li>
<li><a href="../fr453700/index.html">Leçons sur SDL 2: Leçon 1 - Bonjour, SDL 2</a></li>
<li><a href="../fr453706/index.html">Comment j'ai réussi l'examen de certification Google Cloud Professional Data Engineer</a></li>
<li><a href="../fr453710/index.html">Pratique de développement dans les grands projets: mitap SberPractice iOS # 1</a></li>
<li><a href="../fr453712/index.html">Comment eBay a fait un scanner de codes-barres sur WebAssembly</a></li>
<li><a href="../fr453714/index.html">Client de test TON (Telegram Open Network) et le nouveau langage Fift pour les contrats intelligents</a></li>
<li><a href="../fr453716/index.html">Coworking à la campagne pour les informaticiens familiaux - y a-t-il quelqu'un?</a></li>
<li><a href="../fr453720/index.html">Subtilités d'expressions lambda en C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>