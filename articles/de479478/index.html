<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😻 😚 🐖 Java-Plug-In ohne Schmerzen 👆🏻 🔇 👨🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel möchte ich Ihnen erklären, wie Sie schnell und einfach ein Java-Anwendungsframework mit Unterstützung für das dynamische Laden von P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java-Plug-In ohne Schmerzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/">  In diesem Artikel möchte ich Ihnen erklären, wie Sie schnell und einfach ein Java-Anwendungsframework mit Unterstützung für das dynamische Laden von Plugins erstellen.  Der Leser wird wahrscheinlich sofort denken, dass eine solche Aufgabe schon lange gelöst ist, und Sie können einfach vorgefertigte Frameworks verwenden oder Ihren Klassenlader schreiben, aber in der von mir vorgeschlagenen Lösung ist nichts davon erforderlich: <br><br><ul><li>  Wir benötigen keine speziellen Bibliotheken oder Frameworks ( <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> , Guice usw.) </li><li>  Wir werden keine Bytecode-Analyse mit ASM und ähnlichen Bibliotheken verwenden. </li><li>  Wir werden unseren Klassenlader nicht schreiben. </li><li>  Reflexionen und Anmerkungen werden nicht verwendet. </li><li>  Sie müssen sich nicht mit dem Klassenpfad herumärgern, um Plugins zu finden.  Wir werden den Klassenweg überhaupt nicht berühren. </li><li> Wir werden auch kein XML, YAML oder andere deklarative Sprachen verwenden, um Erweiterungspunkte (Erweiterungspunkte in Plugins) zu beschreiben. </li></ul><br>  Es gibt jedoch noch eine Anforderung: Eine solche Lösung funktioniert nur mit Java 9 oder höher.  Weil es auf <a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">Modulen und Diensten</a> basieren wird. <br><a name="habracut"></a><br>  Also fangen wir an.  Wir formulieren das Problem genauer: <br><blockquote> Sie müssen ein minimales Anwendungsframework implementieren, das beim Start Benutzer-Plugins aus dem <code>plugins</code> Ordner lädt. </blockquote><br>  Das heißt, die zusammengestellte Anwendung sollte ungefähr so ​​aussehen: <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar …</code> </pre> <br>  Beginnen wir mit dem Kernmodul.  Dieses Modul ist der Kern unserer Anwendung, das heißt unser Framework. <br><br><div class="spoiler">  <b class="spoiler_title">Für diejenigen, die Wert auf Zeit legen, steht das fertige Projekt auf GitHub zur Verfügung.</b>  <b class="spoiler_title">Montageanleitung.</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">Link</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br>  Erstellen Sie die folgenden 4 Java-Dateien im Modul: <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br>  Die erste Datei, <code>IService.java</code> , beschreibt unseren Erweiterungspunkt.  Andere Plugins können dann zu diesem Erweiterungspunkt beitragen („Contribute“).  Dies ist das Standardprinzip für die Erstellung von Plug-In-Anwendungen, das als <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Prinzip der Abhängigkeitsinversion</a> (Dependency Inversion) bezeichnet wird.  Dieses Prinzip basiert auf der Tatsache, dass der Kernel nicht von bestimmten Klassen abhängt, sondern von Schnittstellen. <br><br>  Ich habe dem Erweiterungspunkt den abstrakten Namen <code>IService</code> , da ich jetzt ausschließlich ein Konzept demonstriere.  In Wirklichkeit kann es sich um einen beliebigen bestimmten Erweiterungspunkt handeln. Wenn Sie beispielsweise einen Grafikeditor schreiben, kann dies die Auswirkung der Bildverarbeitung sein, z. B. <code>IEffectProvider</code> , <code>IEffectContribution</code> oder etwas anderes, je nachdem, wie Sie die Erweiterungspunkte benennen möchten.  Gleichzeitig wird die Anwendung selbst einige grundlegende Effekte enthalten, und Entwickler von Drittanbietern werden in der Lage sein, zusätzliche komplexere Effekte zu schreiben und diese in Form von Plug-Ins bereitzustellen.  Der Benutzer muss diese Effekte nur in den <code>plugins</code> Ordner stellen und die Anwendung neu starten. <br><br>  Die Datei <code>IService.java</code> lautet wie folgt: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br>  Daher ist <code>IService</code> nur eine Schnittstelle, die einige abstrakte <code>doJob()</code> ich wiederhole, die Details sind nicht wichtig, in Wirklichkeit wird es etwas Konkretes sein). <br><br>  <code>getServices()</code> die zweite Methode <code>getServices()</code> .  Diese Methode gibt alle Implementierungen der <code>IService</code> Schnittstelle zurück, die in dieser Modulschicht und ihren <code>IService</code> gefunden wurden.  Wir werden später genauer darauf eingehen. <br><br>  Die zweite Datei, <code>BasicService.java</code> , ist die <code>IService</code> der <code>IService</code> Schnittstelle.  Es ist immer vorhanden, auch wenn die Anwendung keine Plugins enthält.  Mit anderen Worten, <code>core</code> ist nicht nur der Core, sondern auch gleichzeitig ein Plugin für sich, das immer geladen wird.  Die <code>BasicService.java</code> Datei sieht folgendermaßen aus: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br>  Der Einfachheit halber <code>doJob()</code> nur die Zeichenfolge <code>"Basic service"</code> und das <code>doJob()</code> . <br><br>  So haben wir im Moment folgendes Bild: <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br>  In der dritten Datei, <code>Main.java</code> , ist die Methode <code>main()</code> implementiert.  Es ist ein wenig magisch, zu verstehen, was Sie wissen müssen, was eine Modulebene ist. <br><br><h2>  Über Modulebenen </h2><br>  Wenn Java die Anwendung startet, fallen alle Plattformmodule + Module, die im Argument <code>--module-path</code> (und gegebenenfalls auch <code>--module-path</code> ) aufgeführt sind, in die sogenannte <code>Boot</code> Schicht.  Wenn wir in unserem Fall das Modul core.jar kompilieren und <code>java --module-path core.jar --module core</code> über die Befehlszeile <code>java --module-path core.jar --module core</code> mindestens die Module <code>java.base</code> und <code>core</code> in der <code>Boot</code> Ebene: <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  Die <code>Boot</code> Schicht ist in jeder Java-Anwendung immer vorhanden, und dies ist die kleinstmögliche Konfiguration.  Die meisten Anwendungen existieren in einer einzigen Modulschicht.  In unserem Fall möchten wir jedoch das dynamische Laden von Plugins aus dem <code>plugins</code> Ordner durchführen.  Wir könnten den Benutzer nur zwingen, die Startzeile der Anwendung zu korrigieren, damit er selbst die erforderlichen Plugins zu <code>--module-path</code> hinzufügt. Dies ist jedoch nicht die beste Lösung.  Vor allem diejenigen, die keine Programmierer sind und nicht verstehen, warum sie irgendwo hinklettern und etwas für eine so einfache Sache reparieren müssen. <br><br>  Zum Glück gibt es eine Lösung: Mit Java können Sie in Runtime Ihre eigenen Modul-Layer erstellen, die die Module von dem Ort laden, den wir benötigen.  Für unsere Zwecke ist eine neue Ebene für Plugins ausreichend, die eine <code>Boot</code> Ebene als übergeordnete Ebene hat (jede Ebene muss eine übergeordnete Ebene haben): <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br>  Die Tatsache, dass die Plugin-Ebene die <code>Boot</code> Ebene als übergeordnete Ebene hat, bedeutet, dass die Module aus der Plugin-Ebene auf die Module aus der <code>Boot</code> Ebene verweisen können, aber nicht umgekehrt. <br><br>  <code>Main.java</code> Sie nun wissen, was eine Modulebene ist, können Sie sich endlich den Inhalt der Datei <code>Main.java</code> : <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br>  Wenn Sie sich diesen Code zum ersten Mal ansehen, scheint er sehr kompliziert zu sein, aber aufgrund der großen Anzahl neuer unbekannter Klassen ist dies ein falsches Gefühl.  Wenn Sie etwas über die Bedeutung der <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">Klassen</a> <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">ModuleFinder</a> , <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Configuration</a> und <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer wissen</a> , ist alles in Ordnung.  Und außerdem gibt es nur ein paar Dutzend Zeilen!  Dies ist die gesamte Logik, die einmal geschrieben wurde. <br><br><h2>  Modulbeschreibung </h2><br>  Es gibt eine weitere (vierte) Datei, die wir nicht berücksichtigt haben: <code>module-info.java</code> .  Dies ist die kürzeste Datei, die die Deklaration unseres Moduls und eine Beschreibung der Dienste (Erweiterungspunkte) enthält: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br>  Die Bedeutung der Zeilen dieser Datei sollte offensichtlich sein: <br><br><ul><li>  Erstens exportiert das Modul das Paket <code>org.example.pluginapp.core</code> , <code>org.example.pluginapp.core</code> Plugins von der <code>IService</code> Schnittstelle erben können (andernfalls wäre <code>IService</code> außerhalb des Kernmoduls nicht <code>IService</code> ). </li><li>  Zweitens gibt er bekannt, dass er den <code>IService</code> . </li><li>  Drittens sagt er, dass er eine Implementierung des <code>IService</code> Dienstes über die <code>BasicService</code> Klasse <code>BasicService</code> . </li></ul><br>  Da die Moduldeklaration in Java geschrieben ist, erhalten wir sehr wichtige Vorteile: <i>Compilerprüfungen und statische Garantien</i> .  Wenn wir beispielsweise im Namen der Typen einen Fehler gemacht oder ein nicht vorhandenes Paket angegeben hätten, hätten wir es sofort erhalten.  Bei einigen OSGi-Versionen hätten wir zum Zeitpunkt der Kompilierung keine Überprüfungen, da die Deklaration der Erweiterungspunkte in XML geschrieben wäre. <br><br>  Der Rahmen ist also fertig.  Lass es uns versuchen: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br>  Was ist passiert? <br><br><ol><li>  Java hat versucht, die Module im Ordner <code>plugins</code> finden und keine gefunden. </li><li>  Eine leere Ebene wurde erstellt. </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> suchte nach allen <code>IService</code> Implementierungen. </li><li>  In der leeren Ebene hat er keine Service-Implementierungen gefunden, da dort keine Module vorhanden sind. </li><li>  Nach dieser Schicht setzte er die Suche in der übergeordneten Schicht (d. H. Der <code>Boot</code> Schicht) fort und fand eine Implementierung von <code>BasicService</code> im Kernmodul. </li><li>  Alle gefundenen Implementierungen hatten die Methode <code>doJob()</code> aufgerufen.  Da nur eine Implementierung gefunden wurde, wurde nur der <code>"Basic service"</code> gedruckt. </li></ol><br><h2>  Ein Plugin schreiben </h2><br>  Nachdem Sie den Kern unserer Anwendung geschrieben haben, ist es jetzt an der Zeit, Plugins dafür zu schreiben.  Schreiben wir zwei Plugins <code>plugin1</code> und <code>plugin2</code> : Lassen Sie den ersten <code>"Service 1"</code> , den zweiten <code>"Service 2"</code> <code>plugin2</code> .  Dazu müssen Sie in <code>plugin1</code> und <code>plugin2</code> zwei weitere <code>IService</code> Implementierungen <code>plugin1</code> : <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br>  Erstelle das erste Plugin mit zwei Dateien: <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  <code>Service1.java</code> Datei: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  <code>module-info.java</code> Datei: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br>  Beachten Sie, dass <code>plugin1</code> ist.  Dies ist das zuvor erwähnte Prinzip der Abhängigkeitsinversion: Der Kernel ist nicht von Plugins abhängig, sondern umgekehrt. <br><br>  Das zweite Plugin ist dem ersten Plugin völlig ähnlich, daher werde ich es hier nicht geben. <br><br>  Jetzt sammeln wir die Plugins, legen sie in den <code>plugins</code> Ordner und führen die Anwendung aus: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br>  Hurra, die Plugins wurden abgeholt!  Wie ist das passiert: <br><br><ol><li>  Java hat zwei Module im Ordner <code>plugins</code> . </li><li>  Es wurde eine Ebene mit zwei Modulen <code>plugins1</code> und <code>plugins2</code> . </li><li>  ServiceLoader suchte nach allen <code>IService</code> Implementierungen. </li><li>  In der Plugin-Ebene fand er zwei Implementierungen des <code>IService</code> Dienstes. </li><li>  Danach setzte er die Suche in der übergeordneten Ebene (d. H. Der <code>Boot</code> Ebene) fort und fand eine Implementierung von <code>BasicService</code> im Kernmodul. </li><li>  Alle gefundenen Implementierungen hatten die Methode <code>doJob()</code> aufgerufen. </li></ol><br>  Beachten Sie, dass genau deshalb, weil die Suche nach Dienstanbietern mit untergeordneten Schichten beginnt und dann zu den übergeordneten Schichten geht, zuerst <code>"Service 1"</code> und <code>"Service 2"</code> und dann <code>"Basic Service"</code> gedruckt werden.  Wenn die Dienste so sortiert werden sollen, dass zuerst die Basisdienste und dann die Plugins <code>IService.getServices()</code> werden, können Sie die Methode <code>IService.getServices()</code> optimieren, indem Sie die Sortierung dort hinzufügen (möglicherweise müssen Sie die Methode <code>int getOrdering()</code> zur <code>IService</code> Schnittstelle <code>IService</code> ). <br><br><h2>  Zusammenfassung </h2><br>  Daher habe ich gezeigt, wie Sie eine Plug-in-Java-Anwendung mit den folgenden Eigenschaften schnell und effizient organisieren können: <br><br><ul><li>  <b>Einfachheit:</b> Für Erweiterungspunkte und ihre Bindungen werden nur die grundlegenden Java-Funktionen (Schnittstellen, Klassen und <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ) verwendet, ohne Frameworks, Reflektionen, Anmerkungen und Klassenladeprogramme. </li><li>  <b>Deklarierbarkeit:</b> Erweiterungspunkte werden in <b>Modulbeschreibungen</b> beschrieben.  Schauen Sie sich <code>module-info.java</code> und verstehen Sie, welche Erweiterungspunkte existieren und welche Plugins zu diesen Punkten beitragen. </li><li>  <b>Statische Garantien:</b> Bei Fehlern in den Modulbeschreibungen wird das Programm nicht kompiliert.  Außerdem erhalten Sie als Bonus zusätzliche Warnungen, wenn Sie IntelliJ IDEA verwenden (zum Beispiel, wenn Sie vergessen haben, <code>uses</code> und <code>ServiceLoader.load()</code> ). </li><li>  <b>Sicherheit: Das</b> modulare Java-System prüft beim Start, ob die Konfiguration der Module korrekt ist und weigert sich, das Programm bei Fehlern auszuführen. </li></ul><br>  Ich wiederhole, ich habe nur die Idee gezeigt.  In einer echten Plug-in-Anwendung gibt es zehn bis hundert Module und hundert bis tausend Erweiterungspunkte. <br><br>  Ich habe mich dazu entschlossen, dieses Thema anzusprechen, weil ich in den letzten 7 Jahren eine modulare Anwendung mit Eclipse RCP geschrieben habe, in der das berüchtigte OSGi als Plug-In-System verwendet wird und die Plug-In-Deskriptoren in XML geschrieben sind.  Wir haben mehr als hundert Plugins und arbeiten immer noch mit Java 8. Aber selbst wenn wir auf die neue Java-Version wechseln, werden wir wahrscheinlich keine Java-Module verwenden, da diese stark an OSGi gebunden sind. <br><br>  Wenn Sie jedoch eine Plug-in-Anwendung von Grund auf neu schreiben, sind Java-Module eine der möglichen Optionen für deren Implementierung.  Denken Sie daran, dass Module nur ein Werkzeug und kein Ziel sind. <br><br><h2>  Kurz über mich </h2><br>  Ich programmiere seit mehr als 10 Jahren (8 davon in Java), reagiere auf <a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a> und <a href="https://stackoverflow.com/users/706317/zhekakozlov">starte</a> meinen eigenen <a href="https://t.me/miniJUG">Kanal in Telegram,</a> der sich Java widmet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479478/">https://habr.com/ru/post/de479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479462/index.html">Serialisierung in C ++</a></li>
<li><a href="../de479464/index.html">Rohre & Filter. Beispielanwendung und Implementierung mit Spring</a></li>
<li><a href="../de479466/index.html">Habraiting 2019: Statistik und Ranking der besten Artikel für 2019</a></li>
<li><a href="../de479468/index.html">Edge of Honesty und John Doe</a></li>
<li><a href="../de479474/index.html">Warum ist die Selbstorganisation von Teams in Scrum so wichtig und warum kann es keine Manager geben?</a></li>
<li><a href="../de479480/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479482/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479486/index.html">Heterogene Programmierung und oneAPI Toolkit. Der improvisierte Vortrag von Intel-Experten beantwortet Ihre Fragen</a></li>
<li><a href="../de479488/index.html">Von einem Laptop - ein Heimserver mit redundanter Stromversorgung für den Mikrotik-Router</a></li>
<li><a href="../de479492/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>