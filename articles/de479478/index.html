<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòª üòö üêñ Java-Plug-In ohne Schmerzen üëÜüèª üîá üë®üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich Ihnen erkl√§ren, wie Sie schnell und einfach ein Java-Anwendungsframework mit Unterst√ºtzung f√ºr das dynamische Laden von P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java-Plug-In ohne Schmerzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/">  In diesem Artikel m√∂chte ich Ihnen erkl√§ren, wie Sie schnell und einfach ein Java-Anwendungsframework mit Unterst√ºtzung f√ºr das dynamische Laden von Plugins erstellen.  Der Leser wird wahrscheinlich sofort denken, dass eine solche Aufgabe schon lange gel√∂st ist, und Sie k√∂nnen einfach vorgefertigte Frameworks verwenden oder Ihren Klassenlader schreiben, aber in der von mir vorgeschlagenen L√∂sung ist nichts davon erforderlich: <br><br><ul><li>  Wir ben√∂tigen keine speziellen Bibliotheken oder Frameworks ( <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> , Guice usw.) </li><li>  Wir werden keine Bytecode-Analyse mit ASM und √§hnlichen Bibliotheken verwenden. </li><li>  Wir werden unseren Klassenlader nicht schreiben. </li><li>  Reflexionen und Anmerkungen werden nicht verwendet. </li><li>  Sie m√ºssen sich nicht mit dem Klassenpfad herum√§rgern, um Plugins zu finden.  Wir werden den Klassenweg √ºberhaupt nicht ber√ºhren. </li><li> Wir werden auch kein XML, YAML oder andere deklarative Sprachen verwenden, um Erweiterungspunkte (Erweiterungspunkte in Plugins) zu beschreiben. </li></ul><br>  Es gibt jedoch noch eine Anforderung: Eine solche L√∂sung funktioniert nur mit Java 9 oder h√∂her.  Weil es auf <a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">Modulen und Diensten</a> basieren wird. <br><a name="habracut"></a><br>  Also fangen wir an.  Wir formulieren das Problem genauer: <br><blockquote> Sie m√ºssen ein minimales Anwendungsframework implementieren, das beim Start Benutzer-Plugins aus dem <code>plugins</code> Ordner l√§dt. </blockquote><br>  Das hei√üt, die zusammengestellte Anwendung sollte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar ‚Ä¶</code> </pre> <br>  Beginnen wir mit dem Kernmodul.  Dieses Modul ist der Kern unserer Anwendung, das hei√üt unser Framework. <br><br><div class="spoiler">  <b class="spoiler_title">F√ºr diejenigen, die Wert auf Zeit legen, steht das fertige Projekt auf GitHub zur Verf√ºgung.</b>  <b class="spoiler_title">Montageanleitung.</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">Link</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br>  Erstellen Sie die folgenden 4 Java-Dateien im Modul: <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br>  Die erste Datei, <code>IService.java</code> , beschreibt unseren Erweiterungspunkt.  Andere Plugins k√∂nnen dann zu diesem Erweiterungspunkt beitragen (‚ÄûContribute‚Äú).  Dies ist das Standardprinzip f√ºr die Erstellung von Plug-In-Anwendungen, das als <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Prinzip der Abh√§ngigkeitsinversion</a> (Dependency Inversion) bezeichnet wird.  Dieses Prinzip basiert auf der Tatsache, dass der Kernel nicht von bestimmten Klassen abh√§ngt, sondern von Schnittstellen. <br><br>  Ich habe dem Erweiterungspunkt den abstrakten Namen <code>IService</code> , da ich jetzt ausschlie√ülich ein Konzept demonstriere.  In Wirklichkeit kann es sich um einen beliebigen bestimmten Erweiterungspunkt handeln. Wenn Sie beispielsweise einen Grafikeditor schreiben, kann dies die Auswirkung der Bildverarbeitung sein, z. B. <code>IEffectProvider</code> , <code>IEffectContribution</code> oder etwas anderes, je nachdem, wie Sie die Erweiterungspunkte benennen m√∂chten.  Gleichzeitig wird die Anwendung selbst einige grundlegende Effekte enthalten, und Entwickler von Drittanbietern werden in der Lage sein, zus√§tzliche komplexere Effekte zu schreiben und diese in Form von Plug-Ins bereitzustellen.  Der Benutzer muss diese Effekte nur in den <code>plugins</code> Ordner stellen und die Anwendung neu starten. <br><br>  Die Datei <code>IService.java</code> lautet wie folgt: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br>  Daher ist <code>IService</code> nur eine Schnittstelle, die einige abstrakte <code>doJob()</code> ich wiederhole, die Details sind nicht wichtig, in Wirklichkeit wird es etwas Konkretes sein). <br><br>  <code>getServices()</code> die zweite Methode <code>getServices()</code> .  Diese Methode gibt alle Implementierungen der <code>IService</code> Schnittstelle zur√ºck, die in dieser Modulschicht und ihren <code>IService</code> gefunden wurden.  Wir werden sp√§ter genauer darauf eingehen. <br><br>  Die zweite Datei, <code>BasicService.java</code> , ist die <code>IService</code> der <code>IService</code> Schnittstelle.  Es ist immer vorhanden, auch wenn die Anwendung keine Plugins enth√§lt.  Mit anderen Worten, <code>core</code> ist nicht nur der Core, sondern auch gleichzeitig ein Plugin f√ºr sich, das immer geladen wird.  Die <code>BasicService.java</code> Datei sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br>  Der Einfachheit halber <code>doJob()</code> nur die Zeichenfolge <code>"Basic service"</code> und das <code>doJob()</code> . <br><br>  So haben wir im Moment folgendes Bild: <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br>  In der dritten Datei, <code>Main.java</code> , ist die Methode <code>main()</code> implementiert.  Es ist ein wenig magisch, zu verstehen, was Sie wissen m√ºssen, was eine Modulebene ist. <br><br><h2>  √úber Modulebenen </h2><br>  Wenn Java die Anwendung startet, fallen alle Plattformmodule + Module, die im Argument <code>--module-path</code> (und gegebenenfalls auch <code>--module-path</code> ) aufgef√ºhrt sind, in die sogenannte <code>Boot</code> Schicht.  Wenn wir in unserem Fall das Modul core.jar kompilieren und <code>java --module-path core.jar --module core</code> √ºber die Befehlszeile <code>java --module-path core.jar --module core</code> mindestens die Module <code>java.base</code> und <code>core</code> in der <code>Boot</code> Ebene: <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  Die <code>Boot</code> Schicht ist in jeder Java-Anwendung immer vorhanden, und dies ist die kleinstm√∂gliche Konfiguration.  Die meisten Anwendungen existieren in einer einzigen Modulschicht.  In unserem Fall m√∂chten wir jedoch das dynamische Laden von Plugins aus dem <code>plugins</code> Ordner durchf√ºhren.  Wir k√∂nnten den Benutzer nur zwingen, die Startzeile der Anwendung zu korrigieren, damit er selbst die erforderlichen Plugins zu <code>--module-path</code> hinzuf√ºgt. Dies ist jedoch nicht die beste L√∂sung.  Vor allem diejenigen, die keine Programmierer sind und nicht verstehen, warum sie irgendwo hinklettern und etwas f√ºr eine so einfache Sache reparieren m√ºssen. <br><br>  Zum Gl√ºck gibt es eine L√∂sung: Mit Java k√∂nnen Sie in Runtime Ihre eigenen Modul-Layer erstellen, die die Module von dem Ort laden, den wir ben√∂tigen.  F√ºr unsere Zwecke ist eine neue Ebene f√ºr Plugins ausreichend, die eine <code>Boot</code> Ebene als √ºbergeordnete Ebene hat (jede Ebene muss eine √ºbergeordnete Ebene haben): <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br>  Die Tatsache, dass die Plugin-Ebene die <code>Boot</code> Ebene als √ºbergeordnete Ebene hat, bedeutet, dass die Module aus der Plugin-Ebene auf die Module aus der <code>Boot</code> Ebene verweisen k√∂nnen, aber nicht umgekehrt. <br><br>  <code>Main.java</code> Sie nun wissen, was eine Modulebene ist, k√∂nnen Sie sich endlich den Inhalt der Datei <code>Main.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br>  Wenn Sie sich diesen Code zum ersten Mal ansehen, scheint er sehr kompliziert zu sein, aber aufgrund der gro√üen Anzahl neuer unbekannter Klassen ist dies ein falsches Gef√ºhl.  Wenn Sie etwas √ºber die Bedeutung der <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">Klassen</a> <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">ModuleFinder</a> , <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Configuration</a> und <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer wissen</a> , ist alles in Ordnung.  Und au√üerdem gibt es nur ein paar Dutzend Zeilen!  Dies ist die gesamte Logik, die einmal geschrieben wurde. <br><br><h2>  Modulbeschreibung </h2><br>  Es gibt eine weitere (vierte) Datei, die wir nicht ber√ºcksichtigt haben: <code>module-info.java</code> .  Dies ist die k√ºrzeste Datei, die die Deklaration unseres Moduls und eine Beschreibung der Dienste (Erweiterungspunkte) enth√§lt: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br>  Die Bedeutung der Zeilen dieser Datei sollte offensichtlich sein: <br><br><ul><li>  Erstens exportiert das Modul das Paket <code>org.example.pluginapp.core</code> , <code>org.example.pluginapp.core</code> Plugins von der <code>IService</code> Schnittstelle erben k√∂nnen (andernfalls w√§re <code>IService</code> au√üerhalb des Kernmoduls nicht <code>IService</code> ). </li><li>  Zweitens gibt er bekannt, dass er den <code>IService</code> . </li><li>  Drittens sagt er, dass er eine Implementierung des <code>IService</code> Dienstes √ºber die <code>BasicService</code> Klasse <code>BasicService</code> . </li></ul><br>  Da die Moduldeklaration in Java geschrieben ist, erhalten wir sehr wichtige Vorteile: <i>Compilerpr√ºfungen und statische Garantien</i> .  Wenn wir beispielsweise im Namen der Typen einen Fehler gemacht oder ein nicht vorhandenes Paket angegeben h√§tten, h√§tten wir es sofort erhalten.  Bei einigen OSGi-Versionen h√§tten wir zum Zeitpunkt der Kompilierung keine √úberpr√ºfungen, da die Deklaration der Erweiterungspunkte in XML geschrieben w√§re. <br><br>  Der Rahmen ist also fertig.  Lass es uns versuchen: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br>  Was ist passiert? <br><br><ol><li>  Java hat versucht, die Module im Ordner <code>plugins</code> finden und keine gefunden. </li><li>  Eine leere Ebene wurde erstellt. </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> suchte nach allen <code>IService</code> Implementierungen. </li><li>  In der leeren Ebene hat er keine Service-Implementierungen gefunden, da dort keine Module vorhanden sind. </li><li>  Nach dieser Schicht setzte er die Suche in der √ºbergeordneten Schicht (d. H. Der <code>Boot</code> Schicht) fort und fand eine Implementierung von <code>BasicService</code> im Kernmodul. </li><li>  Alle gefundenen Implementierungen hatten die Methode <code>doJob()</code> aufgerufen.  Da nur eine Implementierung gefunden wurde, wurde nur der <code>"Basic service"</code> gedruckt. </li></ol><br><h2>  Ein Plugin schreiben </h2><br>  Nachdem Sie den Kern unserer Anwendung geschrieben haben, ist es jetzt an der Zeit, Plugins daf√ºr zu schreiben.  Schreiben wir zwei Plugins <code>plugin1</code> und <code>plugin2</code> : Lassen Sie den ersten <code>"Service 1"</code> , den zweiten <code>"Service 2"</code> <code>plugin2</code> .  Dazu m√ºssen Sie in <code>plugin1</code> und <code>plugin2</code> zwei weitere <code>IService</code> Implementierungen <code>plugin1</code> : <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br>  Erstelle das erste Plugin mit zwei Dateien: <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  <code>Service1.java</code> Datei: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  <code>module-info.java</code> Datei: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br>  Beachten Sie, dass <code>plugin1</code> ist.  Dies ist das zuvor erw√§hnte Prinzip der Abh√§ngigkeitsinversion: Der Kernel ist nicht von Plugins abh√§ngig, sondern umgekehrt. <br><br>  Das zweite Plugin ist dem ersten Plugin v√∂llig √§hnlich, daher werde ich es hier nicht geben. <br><br>  Jetzt sammeln wir die Plugins, legen sie in den <code>plugins</code> Ordner und f√ºhren die Anwendung aus: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br>  Hurra, die Plugins wurden abgeholt!  Wie ist das passiert: <br><br><ol><li>  Java hat zwei Module im Ordner <code>plugins</code> . </li><li>  Es wurde eine Ebene mit zwei Modulen <code>plugins1</code> und <code>plugins2</code> . </li><li>  ServiceLoader suchte nach allen <code>IService</code> Implementierungen. </li><li>  In der Plugin-Ebene fand er zwei Implementierungen des <code>IService</code> Dienstes. </li><li>  Danach setzte er die Suche in der √ºbergeordneten Ebene (d. H. Der <code>Boot</code> Ebene) fort und fand eine Implementierung von <code>BasicService</code> im Kernmodul. </li><li>  Alle gefundenen Implementierungen hatten die Methode <code>doJob()</code> aufgerufen. </li></ol><br>  Beachten Sie, dass genau deshalb, weil die Suche nach Dienstanbietern mit untergeordneten Schichten beginnt und dann zu den √ºbergeordneten Schichten geht, zuerst <code>"Service 1"</code> und <code>"Service 2"</code> und dann <code>"Basic Service"</code> gedruckt werden.  Wenn die Dienste so sortiert werden sollen, dass zuerst die Basisdienste und dann die Plugins <code>IService.getServices()</code> werden, k√∂nnen Sie die Methode <code>IService.getServices()</code> optimieren, indem Sie die Sortierung dort hinzuf√ºgen (m√∂glicherweise m√ºssen Sie die Methode <code>int getOrdering()</code> zur <code>IService</code> Schnittstelle <code>IService</code> ). <br><br><h2>  Zusammenfassung </h2><br>  Daher habe ich gezeigt, wie Sie eine Plug-in-Java-Anwendung mit den folgenden Eigenschaften schnell und effizient organisieren k√∂nnen: <br><br><ul><li>  <b>Einfachheit:</b> F√ºr Erweiterungspunkte und ihre Bindungen werden nur die grundlegenden Java-Funktionen (Schnittstellen, Klassen und <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ) verwendet, ohne Frameworks, Reflektionen, Anmerkungen und Klassenladeprogramme. </li><li>  <b>Deklarierbarkeit:</b> Erweiterungspunkte werden in <b>Modulbeschreibungen</b> beschrieben.  Schauen Sie sich <code>module-info.java</code> und verstehen Sie, welche Erweiterungspunkte existieren und welche Plugins zu diesen Punkten beitragen. </li><li>  <b>Statische Garantien:</b> Bei Fehlern in den Modulbeschreibungen wird das Programm nicht kompiliert.  Au√üerdem erhalten Sie als Bonus zus√§tzliche Warnungen, wenn Sie IntelliJ IDEA verwenden (zum Beispiel, wenn Sie vergessen haben, <code>uses</code> und <code>ServiceLoader.load()</code> ). </li><li>  <b>Sicherheit: Das</b> modulare Java-System pr√ºft beim Start, ob die Konfiguration der Module korrekt ist und weigert sich, das Programm bei Fehlern auszuf√ºhren. </li></ul><br>  Ich wiederhole, ich habe nur die Idee gezeigt.  In einer echten Plug-in-Anwendung gibt es zehn bis hundert Module und hundert bis tausend Erweiterungspunkte. <br><br>  Ich habe mich dazu entschlossen, dieses Thema anzusprechen, weil ich in den letzten 7 Jahren eine modulare Anwendung mit Eclipse RCP geschrieben habe, in der das ber√ºchtigte OSGi als Plug-In-System verwendet wird und die Plug-In-Deskriptoren in XML geschrieben sind.  Wir haben mehr als hundert Plugins und arbeiten immer noch mit Java 8. Aber selbst wenn wir auf die neue Java-Version wechseln, werden wir wahrscheinlich keine Java-Module verwenden, da diese stark an OSGi gebunden sind. <br><br>  Wenn Sie jedoch eine Plug-in-Anwendung von Grund auf neu schreiben, sind Java-Module eine der m√∂glichen Optionen f√ºr deren Implementierung.  Denken Sie daran, dass Module nur ein Werkzeug und kein Ziel sind. <br><br><h2>  Kurz √ºber mich </h2><br>  Ich programmiere seit mehr als 10 Jahren (8 davon in Java), reagiere auf <a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a> und <a href="https://stackoverflow.com/users/706317/zhekakozlov">starte</a> meinen eigenen <a href="https://t.me/miniJUG">Kanal in Telegram,</a> der sich Java widmet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479478/">https://habr.com/ru/post/de479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479462/index.html">Serialisierung in C ++</a></li>
<li><a href="../de479464/index.html">Rohre & Filter. Beispielanwendung und Implementierung mit Spring</a></li>
<li><a href="../de479466/index.html">Habraiting 2019: Statistik und Ranking der besten Artikel f√ºr 2019</a></li>
<li><a href="../de479468/index.html">Edge of Honesty und John Doe</a></li>
<li><a href="../de479474/index.html">Warum ist die Selbstorganisation von Teams in Scrum so wichtig und warum kann es keine Manager geben?</a></li>
<li><a href="../de479480/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479482/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479486/index.html">Heterogene Programmierung und oneAPI Toolkit. Der improvisierte Vortrag von Intel-Experten beantwortet Ihre Fragen</a></li>
<li><a href="../de479488/index.html">Von einem Laptop - ein Heimserver mit redundanter Stromversorgung f√ºr den Mikrotik-Router</a></li>
<li><a href="../de479492/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>