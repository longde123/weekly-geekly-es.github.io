<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïí ü§≥üèø üöº Estructuras de datos ex√≥ticos: Merkle Patricia Trie modificada üëÜüèº üö¢ ü§≥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""¬øQu√© clase de demonio deber√≠a recordar de memoria todos estos malditos algoritmos y estructuras de datos?" 


 Sobre esto se reduce a los comentarios...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estructuras de datos ex√≥ticos: Merkle Patricia Trie modificada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"¬øQu√© clase de demonio deber√≠a recordar de memoria todos estos malditos algoritmos y estructuras de datos?"</em> </p><br><p>  Sobre esto se reduce a los comentarios de la mayor√≠a de los art√≠culos sobre el paso de entrevistas t√©cnicas.  La tesis principal, por regla general, es que todo lo utilizado de una forma u otra ya se ha implementado diez veces y es muy poco probable que este programador ordinario tenga que lidiar.  Bueno, hasta cierto punto esto es cierto.  Pero, como se vio despu√©s, no todo fue implementado, y yo, desafortunadamente (¬øo afortunadamente?) A√∫n ten√≠a que crear una Estructura de Datos. </p><br><p>  Misteriosa Merkle Modificada Patricia Trie. </p><br><p>  Como no hay informaci√≥n sobre este √°rbol en absoluto en el habr, y en el medio, un poco m√°s, quiero decirles qu√© tipo de animal es y con qu√© se come. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Que es esto </h2><br><p>  <em>Descargo de responsabilidad: la principal fuente de informaci√≥n para la implementaci√≥n para m√≠ fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el papel amarillo</a> , as√≠ como los c√≥digos fuente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parity-ethereum</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-ethereum</a> .</em>  <em>Hab√≠a un m√≠nimo de informaci√≥n te√≥rica sobre la justificaci√≥n de ciertas decisiones, por lo que todas las conclusiones sobre las razones para tomar ciertas decisiones son personales.</em>  <em>En caso de que me equivoque en algo, estar√© encantado de hacer correcciones en los comentarios.</em> </p><br><p>  <em>Un √°rbol</em> es una estructura de datos que es un gr√°fico ac√≠clico conectado.  Aqu√≠ todo es simple, todos est√°n familiarizados con esto. </p><br><p>  <em>El √°rbol de prefijos</em> es el √°rbol ra√≠z en el que se pueden almacenar pares clave-valor debido al hecho de que los nodos se dividen en dos tipos: aquellos que contienen parte de la ruta (prefijo) y nodos hoja que contienen el valor almacenado.  Un valor est√° presente en un √°rbol si y solo si, usando la tecla, podemos ir desde la ra√≠z del √°rbol y encontrar un nodo con un valor al final. </p><br><p>  <em>El √°rbol PATRICIA</em> es un √°rbol de prefijos en el que los prefijos son binarios, es decir, cada nodo clave almacena informaci√≥n sobre un bit. </p><br><p>  <em>El</em> √°rbol <em>Merkle</em> es un √°rbol hash construido sobre alg√∫n tipo de cadena de datos, que agrega estos mismos hash en uno (ra√≠z), almacenando informaci√≥n sobre el estado de todos los bloques de datos.  Es decir, el hash ra√≠z es una especie de "firma digital" del estado de la cadena de bloques.  Esta cosa se usa activamente en la cadena de bloques, y puede encontrar m√°s informaci√≥n al respecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="El trabajo duro es ..."></p><br><p>  Total: Merkle Patricia Trie modificada (en adelante MPT para abreviar) es un √°rbol hash que almacena pares clave-valor, y las claves se presentan en forma binaria.  Y sobre qu√© es exactamente "Modificado", lo descubriremos un poco m√°s tarde cuando discutamos la implementaci√≥n. </p><br><h2 id="zachem-eto">  ¬øPor qu√© es esto? </h2><br><p>  MPT se utiliza en el proyecto Ethereum para almacenar datos sobre cuentas, transacciones, resultados de su ejecuci√≥n y otros datos necesarios para el funcionamiento del sistema. <br>  A diferencia de Bitcoin, en el que el estado est√° impl√≠cito y cada nodo lo calcula de forma independiente, el saldo de cada cuenta (as√≠ como los datos asociados con √©l) se almacena directamente en la cadena de bloques en el aire.  Adem√°s, la ubicaci√≥n y la inmutabilidad de los datos deben proporcionarse criptogr√°ficamente: pocas personas usar√°n criptomonedas en las que el saldo de una cuenta aleatoria puede cambiar sin razones objetivas. </p><br><p>  El principal problema que enfrentan los desarrolladores de Ethereum es la creaci√≥n de una estructura de datos que pueda almacenar efectivamente pares clave-valor y al mismo tiempo proporcionar verificaci√≥n de los datos almacenados.  Entonces apareci√≥ MPT. </p><br><h2 id="kak-eto">  Como es eso </h2><br><p>  MPT es un √°rbol de prefijo PATRICIA en el que las claves son secuencias de bytes. </p><br><p>  Los bordes de este √°rbol son secuencias de mordisco (medios bytes).  En consecuencia, un nodo puede tener hasta diecis√©is descendientes (correspondientes a ramas de 0x0 a 0xF). </p><br><p>  Los nodos se dividen en 3 tipos: </p><br><ul><li>  Nodo de rama.  El nodo utilizado para ramificar.  Contiene hasta 1 a 16 enlaces a nodos secundarios.  Tambi√©n puede contener un valor. </li><li>  Nodo de extensi√≥n.  Un nodo auxiliar que almacena una parte de la ruta com√∫n a varios nodos secundarios, as√≠ como un enlace al nodo de rama, que se encuentra debajo. </li><li>  Nodo de la hoja.  Un nodo que contiene parte de la ruta y el valor almacenado.  Es el final de la cadena. </li></ul><br><p> Como ya se mencion√≥, MPT est√° construido sobre otro repositorio de kv, que almacena nodos en forma de "enlace" =&gt; "nodo codificado <code>RLP</code> ". </p><br><p>  <em>Y aqu√≠ se nos ocurre un nuevo concepto: RLP.</em>  <em>En resumen, este es un m√©todo para codificar datos que representan listas o secuencias de bytes.</em>  <em>Ejemplo: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>No entrar√© en detalles en particular, y en la implementaci√≥n utilizo una biblioteca preparada, ya que la cobertura de este tema tambi√©n inflar√° un art√≠culo ya bastante grande.</em>  <em>Si a√∫n est√° interesado, puede leer m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</em>  <em>Nos limitamos al hecho de que podemos codificar datos en <code>RLP</code> y volver a decodificarlos.</em> </p><br><p>  Un enlace a un nodo se define de la siguiente manera: si la longitud del nodo codificado <code>RLP</code> es de 32 o m√°s bytes, entonces el enlace es un hash <code>keccak</code> de la representaci√≥n <code>RLP</code> del nodo.  Si la longitud es inferior a 32 bytes, el enlace es la representaci√≥n <code>RLP</code> del propio nodo. </p><br><p>  Obviamente, en el segundo caso, no necesita guardar el nodo en la base de datos, porque  se guardar√° completamente dentro del nodo padre. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Los nodos son diferentes."></p><br><p>  La combinaci√≥n de tres tipos de nodos le permite almacenar datos de manera efectiva en el caso de que haya pocas claves (entonces la mayor√≠a de las rutas se almacenar√°n en nodos de extensi√≥n y hoja, y habr√° pocos nodos de ramificaci√≥n), y en el caso de que haya muchos nodos (las rutas no se almacenar√°n expl√≠citamente, pero se "reunir√°n" durante el paso a trav√©s de los nodos de las ramas). </p><br><p>  Un ejemplo completo de un √°rbol que usa todo tipo de nodos: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="El √°rbol est√° lleno pero no grueso."></p><br><p>  Como habr√°s notado, las partes almacenadas de las rutas tienen prefijos.  Los prefijos son necesarios para varios prop√≥sitos: </p><br><ol><li>  Distinguir los nodos de extensi√≥n de los nodos hoja. </li><li>  Para alinear secuencias de un n√∫mero impar de mordiscos. </li></ol><br><p>  Las reglas para crear prefijos son muy simples: </p><br><ul><li>  El prefijo toma 1 mordisco.  Si la longitud de la ruta (excluyendo el prefijo) es impar, entonces la ruta comienza inmediatamente despu√©s del prefijo.  Si la longitud de la ruta es par, para alinear despu√©s del prefijo, primero se agrega nibble 0x0. </li><li>  El prefijo es inicialmente 0x0. </li><li>  Si la longitud de la ruta es impar, entonces se agrega 0x1 al prefijo, si es par - 0x0. </li><li>  Si la ruta conduce a un nodo Hoja, se agrega 0x2 al prefijo, si se agrega 0x0 al nodo Extensi√≥n. </li></ul><br><p>  En beatiks, creo, ser√° m√°s claro: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Remoci√≥n que no es remoci√≥n </h3><br><p>  A pesar de que el √°rbol tiene la operaci√≥n de eliminar nodos, de hecho, todo lo que alguna vez se agreg√≥ permanece en el √°rbol para siempre. </p><br><p>  Esto es necesario para no crear un √°rbol completo para cada bloque, sino para almacenar solo la diferencia entre las versiones antiguas y nuevas del √°rbol. </p><br><p>  En consecuencia, utilizando diferentes hashes de ra√≠z como punto de entrada, podemos obtener cualquiera de los estados en los que el √°rbol ha estado. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Lo que est√° escrito con un bol√≠grafo ..."></p><br><p>  Estas no son todas las optimizaciones.  Hay m√°s, pero no hablaremos al respecto, por lo que el art√≠culo es amplio.  Sin embargo, puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer por</a> ti mismo. </p><br><h2 id="realizaciya">  Implementaci√≥n </h2><br><p>  La teor√≠a ha terminado, pasemos a la pr√°ctica.  Utilizaremos lingua franca del mundo de TI, que es <code>python</code> . </p><br><p>  Como habr√° mucho c√≥digo, y para el formato del art√≠culo habr√° que reducir y dividir mucho, dejar√© inmediatamente un enlace a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . <br>  Si es necesario, all√≠ puede ver la imagen completa. </p><br><p>  Primero, definimos la interfaz de √°rbol que queremos obtener como resultado: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  La interfaz es extremadamente simple.  Las operaciones disponibles son obtener, eliminar, insertar y cambiar (combinadas en la actualizaci√≥n), as√≠ como obtener el hash ra√≠z. </p><br><p>  El almacenamiento se transferir√° al m√©todo <code>__init__</code> , una estructura de datos tipo <code>dict</code> en la que almacenaremos los nodos, as√≠ como la <code>root</code> , la "parte superior" del √°rbol.  Si <code>None</code> se pasa <code>None</code> como <code>root</code> , asumimos que el √°rbol est√° vac√≠o y funciona desde cero. </p><br><p>  _Observaci√≥n: es posible que se pregunte por qu√© las variables en los m√©todos se nombran como <code>encoded_key</code> y <code>encoded_value</code> , y no solo <code>key</code> / <code>value</code> .  La respuesta es simple: de acuerdo con la especificaci√≥n, todas las claves y valores deben estar codificados en <code>RLP</code> .  No nos molestaremos con esto y dejaremos esta ocupaci√≥n en los hombros de los usuarios de la biblioteca. </p><br><p>  Sin embargo, antes de comenzar a implementar el √°rbol en s√≠, se deben hacer dos cosas importantes: </p><br><ol><li>  Implemente la clase <code>NibblePath</code> , que es una cadena de nibbles, para no codificarlos manualmente. </li><li>  Para implementar la clase <code>Node</code> en el marco de esta clase: <code>Extension</code> , <code>Leaf</code> y <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Nibblepath </h3><br><p>  Entonces, <code>NibblePath</code> .  Dado que nos moveremos activamente alrededor del √°rbol, la base de la funcionalidad de nuestra clase deber√≠a ser la capacidad de establecer el "desplazamiento" desde el comienzo de la ruta, as√≠ como recibir un mordisco espec√≠fico.  Sabiendo esto, definimos la base de nuestra clase (as√≠ como un par de constantes √∫tiles para trabajar con los prefijos a continuaci√≥n): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  Muy simple, ¬øno es as√≠? </p><br><p>  Queda por escribir solo funciones para codificar y decodificar una secuencia de nibbles. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  En principio, este es el m√≠nimo necesario para un trabajo conveniente con mordiscos.  Por supuesto, en la implementaci√≥n actual todav√≠a hay una serie de m√©todos auxiliares (como <code>combine</code> , fusionar dos caminos en uno), pero su implementaci√≥n es muy trivial.  Si est√° interesado, la versi√≥n completa se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><h3 id="node">  Nodo </h3><br><p>  Como ya sabemos, nuestros nodos se dividen en tres tipos: Hoja, Extensi√≥n y Rama.  Todos ellos pueden codificarse y decodificarse, y la √∫nica diferencia son los datos que se almacenan en su interior.  Para ser sincero, esto es lo que se piden los tipos de datos algebraicos, y en <code>Rust</code> , por ejemplo, escribir√≠a algo en el esp√≠ritu: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  Sin embargo, no hay ADT en Python como tal, por lo que definiremos la clase <code>Node</code> , y dentro de ella hay tres clases correspondientes a los tipos de nodos.  Implementamos la codificaci√≥n directamente en las clases de nodo y la decodificaci√≥n en la clase de <code>Node</code> . </p><br><p>  La implementaci√≥n, sin embargo, es elemental: </p><br><p>  Hoja: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Extensi√≥n: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Rama: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Todo es muy sencillo.  Lo √∫nico que puede causar preguntas es la funci√≥n <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Entonces confieso, tuve que usar una muleta peque√±a.</em>  <em>El hecho es que la biblioteca <code>rlp</code> decodifica los datos de forma recursiva, y el enlace a otro nodo, como sabemos, puede ser datos <code>rlp</code> (en caso de que el nodo codificado tenga menos de 32 caracteres).</em>  <em>Trabajar con enlaces en dos formatos (bytes hash y un nodo descodificado) es muy inconveniente.</em>  <em>Por lo tanto, escrib√≠ dos funciones que, despu√©s de decodificar el nodo, devuelven los enlaces en formato de bytes y los decodifican si es necesario, antes de guardarlos.</em>  <em>Estas funciones son:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Termine con nodos escribiendo una clase <code>Node</code> .  Solo habr√° 2 m√©todos: decodificar el nodo y convertir el nodo en un enlace. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Un descanso </h2><br><p>  Fuh!  Hay mucha informaci√≥n  Creo que es hora de relajarse.  Aqu√≠ hay otro gato para ti: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Puedes comer algo durante el descanso"></p><br><p>  Milota, verdad?  Bien, de vuelta a nuestros √°rboles. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hurra: los elementos auxiliares est√°n listos, pasamos a los m√°s deliciosos.  Por si acaso, recordar√© la interfaz de nuestro √°rbol.  Al mismo tiempo, implementamos el m√©todo <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Pero con los m√©todos restantes trataremos uno por uno. </p><br><h3 id="get">  obtener </h3><br><p>  El m√©todo <code>get</code> (como, en principio, los otros m√©todos) constar√° de dos partes.  El m√©todo mismo preparar√° los datos y traer√° el resultado a la forma esperada, mientras que el trabajo real ocurrir√° dentro del m√©todo auxiliar. </p><br><p>  El m√©todo b√°sico es extremadamente simple: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  Sin embargo, <code>_get</code> no <code>_get</code> mucho m√°s complicado: para llegar al nodo deseado, necesitamos ir desde la ra√≠z a la ruta completa.  Si al final encontramos un nodo con datos (Hoja o Rama) - hurra, los datos se reciben.  Si no fue posible pasar, falta la clave requerida en el √°rbol. </p><br><p>  Implementaci√≥n </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Bueno, al mismo tiempo, escribiremos m√©todos para guardar y cargar nodos.  Son simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  actualizar </h3><br><p>  El m√©todo de <code>update</code> ya es m√°s interesante.  Simplemente vaya hasta el final e inserte el nodo Hoja no siempre funcionar√°.  Es probable que el punto de separaci√≥n clave est√© en alg√∫n lugar dentro del nodo Hoja o Extensi√≥n ya guardado.  En este caso, tendr√° que separarlos y crear varios nodos nuevos. </p><br><p>  En general, toda la l√≥gica se puede describir mediante las siguientes reglas: </p><br><ol><li>  Si bien el camino coincide por completo con los nodos existentes, descendemos recursivamente del √°rbol. </li><li>  Si la ruta est√° terminada y estamos en el nodo Rama u Hoja, significa que la <code>update</code> simplemente actualiza el valor correspondiente a esta clave. </li><li>  Si las rutas est√°n divididas (es decir, no actualizamos el valor, pero insertamos uno nuevo), y estamos en el nodo Rama, creamos un nodo Hoja y le especificamos un enlace en la rama correspondiente. </li><li>  Si las rutas est√°n divididas y estamos en un nodo Hoja o Extensi√≥n, necesitamos crear un nodo Rama que separe las rutas y, si es necesario, un nodo Extensi√≥n para la parte com√∫n de la ruta. </li></ol><br><p>  Expresemos esto gradualmente en c√≥digo.  ¬øPor qu√© gradualmente?  Debido a que el m√©todo es grande y ser√° dif√≠cil de entender a granel. <br>  Sin embargo, dejar√© un enlace al m√©todo completo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  No hay suficiente l√≥gica general, todo lo m√°s interesante est√° adentro <code>if</code> s. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Primero, tratemos con los nodos Leaf.  Solo son posibles 2 escenarios con ellos: </p><br><ol><li><p>  El resto del camino que estamos siguiendo es exactamente el mismo que el camino almacenado en el nodo Hoja.  En este caso, solo necesitamos cambiar el valor, guardar el nuevo nodo y devolverle un enlace. </p><br></li><li><p>  Los caminos son diferentes. <br>  En este caso, debe crear un nodo Branch que separe las dos rutas. <br>  Si una de las rutas est√° vac√≠a, su valor se transferir√° directamente al nodo Branch. <br>  De lo contrario, tendremos que crear dos nodos Leaf acortados por la longitud de la parte com√∫n de las rutas + 1 mordisco (este mordisco se indicar√° mediante el √≠ndice de la rama correspondiente del nodo Branch). </p><br></li></ol><br><p>  Tambi√©n deber√° verificar si hay una parte com√∫n de la ruta para comprender si tambi√©n necesitamos crear un nodo de Extensi√≥n. </p><br><p>  En el c√≥digo, se ver√° as√≠: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  El procedimiento <code>_create_branch_node</code> es el siguiente: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  En el caso del nodo Extensi√≥n, todo parece un nodo Hoja. </p><br><ol><li><p>  Si la ruta desde el nodo de Extensi√≥n es un prefijo para nuestra ruta, simplemente avanzamos recursivamente. </p><br></li><li><p>  De lo contrario, necesitamos hacer la separaci√≥n usando el nodo Branch, como en el caso descrito anteriormente. </p><br></li></ol><br><p>  En consecuencia, el c√≥digo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  El procedimiento <code>_create_branch_extension</code> l√≥gicamente equivalente al procedimiento <code>_create_branch_leaf</code> , pero funciona con el nodo Extension. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Pero con el nodo Branch, todo es simple.  Si la ruta est√° vac√≠a, simplemente guardamos el nuevo valor en el nodo Branch actual.  Si el camino no est√° vac√≠o, "mordimos" un mordisco de √©l y recursivamente bajamos. </p><br><p>  El c√≥digo, creo, no necesita comentarios. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  eliminar </h3><br><p>  Fuh!  El √∫ltimo m√©todo permanece.  El es el m√°s alegre.  La complejidad de la eliminaci√≥n es que necesitamos devolver la estructura al estado en el que habr√≠a ca√≠do si hubi√©ramos hecho toda la cadena de <code>update</code> , excluyendo solo la clave eliminada. </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum ‚Äî <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      ‚Äî     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" ‚Äî    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   ‚Äî    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    ‚Äî   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     ‚Ä¶ </p><br><p>  Por qu√©   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    ‚Äî     Leaf-.          ‚Äî      Extension-.         ,    ,    2   ‚Äî  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> ‚Äî <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    ‚Äî Leaf  Extension,           ,   . </p><br><p>     ‚Äî Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  El resto </h3><br><p>      .  , ‚Ä¶    <code>root</code> . </p><br><p>  Aqu√≠: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  ‚Ä¶  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> ‚Äî  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="Eso es todo amigos!"></p><br><h2 id="rezultaty">  Resultados </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    ‚Äî  ,       . </p><br><p> -,   ,  ,            ‚Äî .  ,        skip list  interval tree,     ‚Äî , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     ‚Äî   . </p><br><p>   ,  ,        ‚Äî    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446558/">https://habr.com/ru/post/446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446546/index.html">Microsoft extiende la ventaja de Azure IP con nuevos beneficios de IP para los innovadores y nuevas empresas de Azure IoT</a></li>
<li><a href="../446548/index.html">An√°lisis de estad√≠sticas en campa√±as publicitarias: cree una nueva m√©trica en el DataFrame (python)</a></li>
<li><a href="../446550/index.html">Problemas de patr√≥n de coordinador y qu√© tiene que ver RouteComposer con √©l</a></li>
<li><a href="../446552/index.html">Trabajar con comandos APDU utilizando el ejemplo EToken</a></li>
<li><a href="../446554/index.html">Programa para residentes de Yandex, o C√≥mo convertirse en un ingeniero de ML para un back-end experimentado</a></li>
<li><a href="../446560/index.html">"Intercambio de cortes√≠a": la esencia del conflicto entre las dos compa√±√≠as de transmisi√≥n m√°s famosas</a></li>
<li><a href="../446562/index.html">Asincron√≠a en programaci√≥n</a></li>
<li><a href="../446566/index.html">Proyecto Cero. C√≥mo Amazon quiere lidiar con las falsificaciones</a></li>
<li><a href="../446568/index.html">Actualizaci√≥n de CMS a gran escala Umbraco 8: novedades</a></li>
<li><a href="../446570/index.html">La historia de la primera GPU: Rendition V√©rit√© 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>