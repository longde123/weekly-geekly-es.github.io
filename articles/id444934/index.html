<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👞 👨‍❤️‍💋‍👨 🚵🏿 Kami mengadaptasi AutoMapper untuk diri kami sendiri 👩🏽 🚵🏾 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AutoMapper adalah salah satu alat utama yang digunakan dalam mengembangkan aplikasi Enterprise, jadi saya ingin menulis kode sesedikit mungkin sambil ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mengadaptasi AutoMapper untuk diri kami sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444934/"><p>  AutoMapper adalah salah satu alat utama yang digunakan dalam mengembangkan aplikasi Enterprise, jadi saya ingin menulis kode sesedikit mungkin sambil mendefinisikan pemetaan entitas. </p><br><p>  Saya tidak suka duplikasi di MapFrom dengan proyeksi luas. </p><br><pre><code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .ForMember(x =&gt; x.Name, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Surname)) .ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.Number, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Number))</code> </pre> <br><p>  Saya ingin menulis ulang seperti ini: </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .From(x=&gt;x.IdentityCard.Passport).To()</code> </pre> <a name="habracut"></a><br><h4>  Proyeksi </h4><br><p>  AutoMapper dapat membangun pemetaan dalam memori dan menerjemahkannya ke SQL, melengkapi Expression, memproyeksikan dalam DTO sesuai dengan aturan yang Anda jelaskan di profil. </p><br><pre> <code class="cs hljs">EntityQueryable.Select(dtoPupil =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PupilDto() { Name = dtoPupil.Identity.Passport, Surname = dtoPupil.Identity.Passport.Surname})</code> </pre> <br><p>  80% pemetaan yang harus saya tulis adalah pemetaan yang melengkapi Ekspresi dari IQueryble. </p><br><p>  Ini sangat nyaman: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ActionResult&lt;IEnumerable&lt;PupilDto&gt;&gt; GetAdultPupils(){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _context.Pupils .Where(x=&gt;x.Identity.Passport.Age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; ...) .ProjectTo&lt;PupilDto&gt;().ToList(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Dalam gaya deklaratif, kami membentuk kueri di tabel Murid, menambahkan pemfilteran, diproyeksikan ke DTO yang diinginkan dan mengembalikannya ke klien, sehingga Anda dapat menulis semua metode baca antarmuka CRUD sederhana. Dan semua ini akan dilakukan pada tingkat basis data. </p><br><p>  Benar, dalam aplikasi serius tindakan seperti itu tidak mungkin memuaskan pelanggan. </p><br><h4>  Kontra AutoMapper'a </h4><br><p>  1) Sangat verbose, dengan pemetaan "lebar" Anda harus menulis aturan yang tidak sesuai pada satu baris kode. </p><br><p>  Profil tumbuh dan berubah menjadi arsip kode yang ditulis sekali dan berubah hanya ketika refactoring nama. </p><br><p>  2) Jika Anda menggunakan pemetaan sesuai dengan konvensi, namanya hilang <br>  properti di DTO: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PupilDto</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  Pupil       IdentityCard // IdentityCard     Passport public string IdentityCardPassportName { get; set; } public string IdentityCardPassportSurname { get; set; } }</span></span></code> </pre> <br><p>  3) Kurangnya keamanan jenis </p><br><p>  1 dan 2 adalah momen yang tidak menyenangkan, tetapi Anda bisa bertahan dengan itu, tetapi dengan kurangnya keamanan tipe saat mendaftar, ini sudah lebih sulit untuk dipasang, ini tidak boleh dikompilasi: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Name - string // Age - int ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)</span></span></code> </pre> <br><p>  Kami ingin menerima informasi tentang kesalahan tersebut pada tahap kompilasi, dan bukan pada saat run-time. </p><br><p>  Menggunakan pembungkus ekstensi untuk menghilangkan titik-titik ini. </p><br><h4>  Menulis pembungkus </h4><br><p>  Mengapa pendaftaran harus ditulis dengan cara ini? </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil, PupilDto&gt;() .ForMember(x =&gt; x.Name, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Name)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Surname)) .ForMember(x =&gt; x.Age, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.House, s =&gt; s.MapFrom(x =&gt; x.Address.House)) .ForMember(x =&gt; x.Street, s =&gt; s.MapFrom(x =&gt; x.Address.Street)) .ForMember(x =&gt; x.Country, s =&gt; s.MapFrom(x =&gt; x.Address.Country)) .ForMember(x =&gt; x.Surname, s =&gt; s.MapFrom(x =&gt; x.Identity.Passport.Age)) .ForMember(x =&gt; x.Group, s =&gt; s.MapFrom(x=&gt;x.EducationCard.StudyGroup.Number))</code> </pre><br><p>  Jauh lebih ringkas: </p><br><pre> <code class="cs hljs">CreateMap&lt;Pupil,PupilDto&gt;() <span class="hljs-comment"><span class="hljs-comment">//    // PassportName = Passport.Name, PassportSurname = Passport.Surname .From(x =&gt; x.IdentityCard.Passport).To() // House,Street,Country -   .From(x =&gt; x.Address).To() //    -  DTO,  -  .From(x =&gt; x.EducationCard.Group).To((x =&gt; x.Group,x =&gt; x.Number));</span></span></code> </pre> <br><p>  Metode <em>Ke</em> akan menerima tupel jika Anda perlu menentukan aturan pemetaan </p><br><p>  IMapping &lt;TSource, TDest&gt; adalah antarmuka automaper di mana metode ForMember, ForAll () didefinisikan ... semua metode ini mengembalikan ini (Fluent Api). </p><br><p>  Kami akan mengembalikan pembungkus untuk mengingat Ekspresi dari metode Dari </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt; From&lt;TSource, TDest, TProjection&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IMappingExpression&lt;TSource, TDest&gt; mapping, Expression&lt;Func&lt;TSource, TProjection&gt;&gt; expression) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt;(mapping, expression);</code> </pre> <br><p>  Sekarang programmer, setelah menulis metode Dari, akan segera melihat kelebihan metode <em>To</em> , dengan demikian kami akan memberitahunya API, dalam kasus seperti itu kita dapat menyadari semua pesona metode ekstensi, kami memperluas perilaku tanpa memiliki akses tulis ke sumber automapper </p><br><h4>  Kami melambangkan </h4><br><p>  Menerapkan metode diketik <em>Ke</em> lebih rumit. </p><br><p>  Mari kita coba merancang metode ini, kita perlu memecahnya menjadi potongan-potongan sebanyak mungkin dan mengeluarkan semua logika dalam metode lain.  Segera setuju bahwa kami akan membatasi jumlah parameter tuple hingga sepuluh. </p><br><p>  Ketika tugas serupa dijumpai dalam praktik saya, saya segera melihat ke arah Roslyn, saya tidak merasa ingin menulis banyak jenis metode yang sama dan melakukan Copy Paste, lebih mudah untuk menghasilkannya. </p><br><p>  Dalam generik ini akan membantu kita.  Diperlukan untuk menghasilkan 10 metode dengan jumlah generik dan parameter yang berbeda </p><br><p>  Pendekatan pertama pada proyektil itu sedikit berbeda, saya ingin membatasi jenis kembalinya (int, string, boolean, DateTime) dan tidak menggunakan tipe universal. </p><br><p>  Kesulitannya adalah bahkan untuk 3 parameter kita harus menghasilkan 64 overload yang berbeda, dan ketika menggunakan generik hanya 1: </p><br><pre> <code class="cs hljs">IMappingExpression&lt;TSource, TDest&gt; To&lt;TSource, TDest, TProjection,T,T1, T2, T3&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0, (Expression&lt;Func&lt;TDest, T1&gt;&gt;, Expression&lt;Func&lt;TProjection, T1&gt;&gt;) arg1, (Expression&lt;Func&lt;TDest, T2&gt;&gt;, Expression&lt;Func&lt;TProjection, T2&gt;&gt;) arg2, (Expression&lt;Func&lt;TDest, T3&gt;&gt;, Expression&lt;Func&lt;TProjection, T3&gt;&gt;) arg3) { ... }</code> </pre> <br><p>  Tapi ini bukan masalah utama, kita menghasilkan kode, itu akan memakan waktu dan kita akan mendapatkan seluruh rangkaian metode yang diperlukan. </p><br><p>  Masalahnya berbeda, ReSharper tidak akan mengambil begitu banyak kelebihan dan hanya menolak untuk bekerja, Anda akan kehilangan Intellisience dan memuat IDE. </p><br><p>  Kami menerapkan metode yang membutuhkan satu tuple: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IMappingExpression&lt;TSource, TDest&gt; To &lt;TSource, TDest, TProjection, T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0) { <span class="hljs-comment"><span class="hljs-comment">//    RegisterByConvention(mapperExpressionWrapper); //    expreession RegisterRule(mapperExpressionWrapper, arg0); //  IMappingExpression,     //   extension  return mapperExpressionWrapper.MappingExpression; }</span></span></code> </pre> <br><p>  Pertama, mari kita periksa pemetaan properti apa yang dapat ditemukan oleh konvensi, ini adalah metode yang cukup sederhana, untuk setiap properti di DTO kita mencari jalan di entitas asli.  Metode harus disebut secara refleksif, karena Anda perlu mendapatkan lambda yang diketik, dan tipenya tergantung pada prop. </p><br><p>  Tidak mungkin mendaftarkan lambda dari tipe Expression &lt;Func &lt;TSource, object &gt;&gt;, maka AutoMapper akan memetakan semua properti DTO untuk mengetik objek </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RegisterByConvention&lt;TSource, TDest, TProjection&gt;( MapperExpressionWrapper&lt;TSource, TDest, TProjection&gt; mapperExpressionWrapper) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> properties = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TDest).GetProperties().ToList(); properties.ForEach(prop =&gt; { <span class="hljs-comment"><span class="hljs-comment">// mapperExpressionWrapper.FromExpression = x=&gt;x.Identity.Passport // prop.Name = Name // ruleByConvention Expression&lt;Func&lt;Pupil,string&gt;&gt; x=&gt;x.Identity.Passport.Name var ruleByConvention = _cachedMethodInfo .GetMethod(nameof(HelpersMethod.GetRuleByConvention)) .MakeGenericMethod(typeof(TSource), typeof(TProjection), prop.PropertyType) .Invoke(null, new object[] {prop, mapperExpressionWrapper.FromExpression}); if (ruleByConvention == null) return; // mapperExpressionWrapper.MappingExpression.ForMember(prop.Name, s =&gt; s.MapFrom((dynamic) ruleByConvention)); }); }</span></span></code> </pre> <br><p>  <em>RegisterRule</em> menerima tuple yang mendefinisikan aturan pemetaan, itu perlu "terhubung" di dalamnya <br>  FromExpression dan ekspresi diteruskan ke tuple. </p><br><p>  Ini akan membantu kami Expression. Karena itu, EF Core 2.0 tidak mendukungnya, versi yang lebih baru mulai mendukung.  Ini akan memungkinkan Anda membuat "komposisi lambd": </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;Pupil,StudyGroup&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = x=&gt;x.EducationCard.StudyGroup; Expression&lt;Func&lt;StudyGroup,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; @<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> = x=&gt;x.Number; <span class="hljs-comment"><span class="hljs-comment">//invoke = x=&gt;x.EducationCard.StudyGroup.Number; var composition = Expression.Lambda&lt;Func&lt;Pupil, string&gt;&gt;( Expression.Invoke(@for,from.Body),from.Parameters.First())</span></span></code> </pre><br><p>  Metode <em>RegisterRule</em> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RegisterRule&lt;TSource, TDest, TProjection, T (MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt; mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) rule) { <span class="hljs-comment"><span class="hljs-comment">//rule = (x=&gt;x.Group,x=&gt;x.Number) var (from, @for) = rule; //      @for = (Expression&lt;Func&lt;TProjection, T&gt;&gt;) _interpolationReplacer.Visit(@for); //mapperExpressionWrapper.FromExpression = (x=&gt;x.EducationCard.StudyGroup) var result = Expression.Lambda&lt;Func&lt;TSource, T&gt;&gt;( Expression.Invoke(@for, mapperExpressionWrapper.FromExpression.Body), mapperExpressionWrapper.FromExpression.Parameters.First()); var destPropertyName = from.PropertiesStr().First(); // result = x =&gt; Invoke(x =&gt; x.Number, x.EducationCard.StudyGroup) //  ,  result = x=&gt;x.EducationCard.StudyCard.Number mapperExpressionWrapper.MappingExpression .ForMember(destPropertyName, s =&gt; s.MapFrom(result)); }</span></span></code> </pre> <br><p>  Metode <em>To</em> dirancang agar mudah diperluas saat menambahkan parameter tuple.  Saat menambahkan tuple lain ke parameter, Anda perlu menambahkan generik, parameter lain, dan memanggil metode <em>RegisterRule</em> untuk parameter baru. </p><br><p>  Contoh untuk dua parameter: </p><br><pre> <code class="cs hljs">IMappingExpression&lt;TSource, TDest&gt; To&lt;TSource, TDest, TProjection, T, T1&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> MapperExpressionWrapper&lt;TSource,TDest,TProjection&gt;mapperExpressionWrapper, (Expression&lt;Func&lt;TDest, T&gt;&gt;, Expression&lt;Func&lt;TProjection, T&gt;&gt;) arg0, (Expression&lt;Func&lt;TDest, T1&gt;&gt;, Expression&lt;Func&lt;TProjection, T1&gt;&gt;) arg1) { RegisterByConvention(mapperExpressionWrapper); RegisterRule(mapperExpressionWrapper, arg0); RegisterRule(mapperExpressionWrapper, arg1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapperExpressionWrapper.MappingExpression; }</code> </pre> <br><p>  Kami menggunakan <em>CSharpSyntaxRewriter</em> , ini adalah pengunjung yang berjalan melalui simpul pohon sintaksis.  Kami mengambil sebagai metode dasar dengan <em>To</em> dengan satu argumen dan menambahkan parameter generik dan memanggil <em>RegisterRule</em> ; </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitMethodDeclaration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodDeclarationSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     To if (node.Identifier.Value.ToString() != "To") return base.VisitMethodDeclaration(node); // returnStatement = return mapperExpressionWrapper.MappingExpression; var returnStatement = node.Body.Statements.Last(); //beforeReturnStatements: //[RegisterByConvention(mapperExpressionWrapper), // RegisterRule(mapperExpressionWrapper, arg0)] var beforeReturnStatements = node.Body.Statements.SkipLast(1); //   RegisterRule  returStatement var newBody = SyntaxFactory.Block( beforeReturnStatements.Concat(ReWriteMethodInfo.Block.Statements) .Concat(new[] {returnStatement})); //     return node.Update( node.AttributeLists, node.Modifiers, node.ReturnType, node.ExplicitInterfaceSpecifier, node.Identifier, node.TypeParameterList.AddParameters (ReWriteMethodInfo.Generics.Parameters.ToArray()), node.ParameterList.AddParameters (ReWriteMethodInfo.AddedParameters.Parameters.ToArray()), node.ConstraintClauses, newBody, node.SemicolonToken); }</span></span></code> </pre> <br><p>  <em>ReWriteMethodInfo</em> berisi simpul pohon sintaks yang dihasilkan yang perlu Anda tambahkan.  Setelah itu, kita mendapatkan daftar 10 objek bertipe MethodDeclarationSyntax (pohon sintaks yang mewakili metode). </p><br><p>  Pada langkah berikutnya, kita mengambil kelas di mana metode templat <em>Ke</em> terletak dan menulis semua metode baru ke dalamnya menggunakan Pengunjung lain, di mana kita mendefinisikan kembali VisitClassDeclatation. </p><br><p>  Metode <em>Pembaruan</em> memungkinkan Anda untuk mengedit simpul pohon yang ada, di bawah kapnya mengulangi semua argumen yang diteruskan, dan jika setidaknya satu berbeda dari yang asli, membuat simpul baru. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitClassDeclaration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ClassDeclarationSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//todo refactoring it return node.Update( node.AttributeLists, node.Modifiers, node.Keyword, node.Identifier, node.TypeParameterList, node.BaseList, node.ConstraintClauses, node.OpenBraceToken, new SyntaxList&lt;MemberDeclarationSyntax&gt;(ReWriteMethods), node.CloseBraceToken, node.SemicolonToken); }</span></span></code> </pre> <br><p>  Pada akhirnya, kita mendapatkan SyntaxNode - sebuah kelas dengan metode yang ditambahkan, menulis simpul ke file baru. Sekarang kita telah membebani metode <em>To</em> , yang mengambil 1 hingga 10 tupel dan pemetaan yang jauh lebih ringkas. </p><br><h4>  Titik ekspansi </h4><br><p>  Mari kita lihat AutoMapper sebagai sesuatu yang lebih.  Penyedia Kueri tidak dapat menguraikan cukup banyak kueri, dan bagian tertentu dari kueri ini dapat ditulis ulang secara berbeda.  Di sinilah AutoMapper berperan, ekstensi adalah titik ekstensi tempat kami dapat menambahkan aturan kami sendiri. </p><br><p>  Kami akan menggunakan pengunjung dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang</a> menggantikan interpolasi string dengan penggabungan dalam metode <em>RegusterRule</em> . Akibatnya, semua ekspresi yang menentukan pemetaan dari entitas akan melewati pengunjung ini, sehingga <em>menghilangkan</em> kebutuhan untuk memanggil <em>ReWrite</em> setiap kali. Ini bukan obat mujarab, satu-satunya cara yang kami bisa mengelola adalah proyeksi, tetapi masih membuat hidup lebih mudah. </p><br><p>  Kami juga dapat menambahkan beberapa ekstensi yang nyaman, misalnya, untuk pemetaan berdasarkan kondisi: </p><br><pre> <code class="cs hljs">CreateMap&lt;Passport,PassportDto&gt;() .ToIf(x =&gt; x.Age, x =&gt; x &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>, x =&gt; <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Age}</span></span></span><span class="hljs-string">"</span></span>, x =&gt; <span class="hljs-string"><span class="hljs-string">"Adult"</span></span>)</code> </pre> <br><p>  Hal utama adalah tidak bermain dengan ini dan tidak mulai mentransfer logika kompleks ke level tampilan <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444934/">https://habr.com/ru/post/id444934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444924/index.html">WIAD pertama di Moskow: bagaimana kelanjutannya dan apa yang mereka bicarakan</a></li>
<li><a href="../id444926/index.html">Intisari Desain: Direktur Kreatif, Produktivitas, dan Headset Kebenaran</a></li>
<li><a href="../id444928/index.html">95% dari volume perdagangan Bitcoin yang diumumkan ternyata palsu</a></li>
<li><a href="../id444930/index.html">Mereka merangkak github</a></li>
<li><a href="../id444932/index.html">Bagaimana tidak memahami prinsip-prinsip pengembangan arsitektur SOLID</a></li>
<li><a href="../id444936/index.html">Firmware ZXHN H118N dari Dom.ru tanpa solder dan programmer</a></li>
<li><a href="../id444938/index.html">Layanan yang bermanfaat dan tidak terlalu umum</a></li>
<li><a href="../id444940/index.html">Tip & Trik Forensik Digital: Cara Menghubungkan Gambar Encase ke Mesin Virtual</a></li>
<li><a href="../id444942/index.html">Ketika saya mengunjungi Sekolah 42 yang legendaris: "kumpulan", kucing dan Internet, bukan guru</a></li>
<li><a href="../id444944/index.html">Ketika saya mengunjungi Sekolah 42 yang legendaris: "kolam", kucing dan Internet, bukan guru. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>