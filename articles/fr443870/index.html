<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 😸 🚄 Unity: édition de maillage procédural 🍶 🏇🏼 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La conversion de modèles à la volée est une pratique courante pour simuler la physique des déformations, ainsi que dans les jeux avec un contenu génér...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity: édition de maillage procédural</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/443870/"> La conversion de modèles à la volée est une pratique courante pour simuler la physique des déformations, ainsi que dans les jeux avec un contenu généré dynamiquement et modifiable.  Dans de tels cas, il est pratique d'appliquer des méthodes d'édition procédurale et de création de géométrie.  Ces derniers permettent souvent d'économiser des octets précieux lors de la transmission de données téléchargées depuis le réseau.  De plus, c'est amusant! <br><br>  L'article vise à pomper les compétences du traitement procédural des maillages dans Unity.  Nous parlerons des opérations de transformation et de génération de parties d'un maillage. <br><br><img src="https://habrastorage.org/webt/if/ur/hv/ifurhvuqkiyhlqceodrpurzxjre.jpeg"><a name="habracut"></a><br><br>  Notre kit gentlemanly pour l'édition procédurale de modèles 3D comprend trois opérations de base: triangulation, déplacement de points, extrusion.  Nous parlerons en détail des deux derniers.  Tout d'abord, considérez les opérations de mouvement les plus simples - déplacement des sommets, rotation et mise à l'échelle des arêtes et des triangles.  Ensuite, nous traiterons de l'une des méthodes de génération d'une nouvelle géométrie - l'opération d'extrusion. <br><br>  <i>Dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication précédente,</a> nous avons décrit notre structure pour un travail pratique avec les données des modèles 3D.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Code de structure</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMeshPool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;CustomMesh&gt; Pool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CustomMesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pool[id]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomMesh customMesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CustomMesh&gt;(); pointer = GetAvailableIndex(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointer &lt; Pool.Count) Pool[pointer] = customMesh; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Pool.Add(customMesh); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pointer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = Pool[index] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Pool[index] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAvailableIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableIndex = Pool.FindIndex(mesh =&gt; mesh == <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> availableIndex != <span class="hljs-number"><span class="hljs-number">-1</span></span> ? availableIndex : Pool.Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flush</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pool != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Pool.Clear(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Triangle[] Triangles; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] normals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2[] uv0, uv2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3[] vertices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triangles, Vector3[] normals, Vector2[] uv0, Vector2[] uv2, Color[] colors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vertices = vertices; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals = normals; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.normals[i].normalized; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv0 = uv0; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uv2 = uv2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.colors = colors; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = CustomMeshPool.GetAvailableIndex(); CustomMeshPool.Push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Id = ptr; Triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle[triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; Triangles = Triangles .AsParallel() .Select((t, i) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle(ptr, i, triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>], triangles[i * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>])) .ToArray(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _index; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _index = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_edges != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].TriangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Edge[] _edges; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Edge[] Edges { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _edges; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { _edges = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { _edges[i].TriangleIndex = _index; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexOutOfRangeException(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex V2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.MeshId != MeshId) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not the same mesh"</span></span>); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2</span></span></span><span class="hljs-function">)</span></span> { _index = index; _meshId = meshId; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge[<span class="hljs-number"><span class="hljs-number">3</span></span>]; edges[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v0, v1); edges[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v1, v2); edges[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(meshId, index, v2, v0); _edges = edges; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v0; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vertex v1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _triangleIndex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TriangleIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _triangleIndex; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _triangleIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Edge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meshId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> triangleIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v0Index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1Index</span></span></span><span class="hljs-function">)</span></span> { _meshId = meshId; _triangleIndex = triangleIndex; v0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v0Index }; v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vertex() { MeshId = meshId, Index = v1Index }; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _meshId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MeshId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _meshId; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _meshId = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).vertices[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).vertices[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 normal { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).normals[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).normals[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv0 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv0[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv0[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 uv2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).uv2[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).uv2[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CustomMeshPool.GetMesh(_meshId).colors[Index]; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { CustomMeshPool.GetMesh(_meshId).colors[Index] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br></div></div><br>  <i>Comme vous pouvez le voir, PLINQ est utilisé ici.</i>  <i>En effet, les algorithmes de géométrie de calcul peuvent souvent être optimisés par le multithreading.</i> <i><br></i>  <i>Bien sûr, plus de constructions LINQ sont créées pendant l'exécution de constructions LINQ que lorsque le code «manuel» est exécuté.</i>  <i>Cependant, cet inconvénient est largement compensé par la brièveté de ces conceptions, ainsi que par la présence d'outils intégrés de gestion des ressources dans PLINQ.</i>  <i>De plus, la transition entre les implémentations monothread et multithread s'effectue avec une seule commande, ce qui facilite grandement le processus de débogage.</i> <br><br><h3>  Je tord, tord, je veux confondre </h3><br>  Nous procédons aux opérations du mouvement.  Il n'y a rien de compliqué à déplacer des sommets.  N'oubliez pas les pics coïncidents: si nécessaire, leur position devrait également changer. <br><br>  L'algorithme est implémenté en ajoutant un vecteur de mouvement à la position du sommet.  Le décalage se produit par rapport à l'origine du modèle ( <b>pivot</b> ).  Il est à noter que la position des polygones lors de telles transformations peut changer, mais pas les normales de leurs sommets.  Cependant, pour simplifier la présentation, nous ne considérerons pas cette nuance. <br><br>  <i><b>Les outils de CAO</b> ont une fonction pour recalculer les normales, qui est généralement appelée après avoir appliqué les transformations requises.</i>  <i>Il existe différentes façons de procéder à cette allocation.</i>  <i>La plus courante calcule la normale au plan de chaque triangle, puis attribue une normale à chaque sommet comme moyenne des normales des triangles auxquels ce sommet appartient.</i> <br><br>  En général, il n'y a aucune bonne raison de compliquer le code et d'appliquer la matrice de transformation.  Le résultat de l'ajout d'un vecteur de mouvement à la position du sommet correspond à une idée intuitive de son mouvement. <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/cu/hn/l9/cuhnl9znzfmayguevbhrwr8c2lo.gif"><br></td><td><img src="https://habrastorage.org/webt/o0/st/e0/o0ste0gv_uhldid9h7jgca7a6ua.gif"><br></td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">Liste des méthodes pour déplacer un sommet</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newPosition = position + movement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[i]) vertices[i] = newPosition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position = newPosition; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVerticesInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[vertices.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buffer.Length; i++) { buffer[i] = Mathf.Abs(position.x - vertices[i].x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - vertices[i].y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - vertices[i].z) &lt; Mathf.Epsilon; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; } }</code> </pre><br></div></div><br>  Le mouvement des arêtes et des triangles est mis en œuvre de la même manière - en ajoutant un vecteur de déplacement. <br><br><div class="spoiler">  <b class="spoiler_title">Il y a encore des gifs</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/mr/bo/wu/mrbowu8z94mgyhmjop8fawq1nu8.gif"><br></td><td><img src="https://habrastorage.org/webt/2x/6u/cn/2x6ucnuhg9jwftw9lbcc3vbk_ss.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mf/cx/k5/mfcxk5fm7xq0ifpm03ofn4izurg.gif"><br></td><td><img src="https://habrastorage.org/webt/p8/ot/f-/p8otf-gbjezo3rtn57tf-yvvh9c.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Liste des méthodes de déplacement des triangles et des arêtes</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = v0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = v1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.Translate(movement); v1.Translate(movement); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Translate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 movement, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = V0.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = V1.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = V2.position + movement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { V0.Translate(movement); V1.Translate(movement); V2.Translate(movement); } } }</code> </pre><br></div></div><br>  Mais il est plus pratique de faire pivoter et de mettre à l'échelle à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la matrice de transformation</a> .  Le résultat de l'exécution de ces opérations par rapport à l'origine des coordonnées du modèle ne sera probablement pas ce que vous attendiez ou vouliez voir.  Le point de référence de rotation et de mise à l'échelle est généralement considéré comme le milieu de l'objet - comme le plus compréhensible pour l'homme. <br><br><div class="spoiler">  <b class="spoiler_title">Beaucoup de GIF</b> <div class="spoiler_text"><table><tbody><tr><td><img src="https://habrastorage.org/webt/ct/mo/26/ctmo26dwz_yjk7fshly8l-4q4v4.gif"><br></td><td><img src="https://habrastorage.org/webt/4w/by/ou/4wbyoul70b8-c9_yasiyxxgupqu.gif"><br></td><td><img src="https://habrastorage.org/webt/c_/pl/iy/c_pliy99pbhj8tjbgcdo0vi95i4.gif"><br></td><td><img src="https://habrastorage.org/webt/7g/eb/qa/7gebqanr-htgbvpjo4g1jza9yns.gif"><br></td></tr><tr><td><img src="https://habrastorage.org/webt/mm/fw/0g/mmfw0gazms88c0mslnsah4lynhk.gif"><br></td><td><img src="https://habrastorage.org/webt/nd/cl/a9/ndcla9f1f-lwdd69i-fxndyspg0.gif"><br></td><td><img src="https://habrastorage.org/webt/2c/on/sb/2consbni6vccpanjp80oya-ccow.gif"><br></td><td><img src="https://habrastorage.org/webt/ji/2b/rh/ji2brhm7pb7nrzuqva691l6c7rm.gif"><br></td></tr></tbody></table><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Liste des méthodes de rotation et de mise à l'échelle des triangles et des bords</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (v0.position + v1.position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(v0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(v1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(MeshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(MeshId).GetVerticesInPosition(v1.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v0.position = newV0Position; v1.position = newV1Position; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Triangle { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot) + pivot; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.normal = matrix.MultiplyPoint(V0.normal); Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.normal = matrix.MultiplyPoint(V1.normal); Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.normal = matrix.MultiplyPoint(V2.normal); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withCoincident = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pivot = (V0.position + V1.position + V2.position) / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(pivot, Quaternion.identity, scale); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV0Position = matrix.MultiplyPoint(V0.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV1Position = matrix.MultiplyPoint(V1.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newV2Position = matrix.MultiplyPoint(V2.position - pivot); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withCoincident) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = CustomMeshPool.GetMesh(_meshId).vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV0 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V0.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV1 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V1.position); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskV2 = CustomMeshPool.GetMesh(_meshId).GetVerticesInPosition(V2.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV0[i]) vertices[i] = newV0Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV1[i]) vertices[i] = newV1Position; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maskV2[i]) vertices[i] = newV2Position; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.position = newV0Position; Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.position = newV1Position; Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.position = newV2Position; } } }</code> </pre><br></div></div><br><h3>  Swarm un trou soigné pour nous-mêmes </h3><br>  Dans la modélisation 3D, une opération d'extrusion est souvent utilisée.  Pour sa mise en œuvre, le vecteur mouvement (déplacement) et l'ensemble des polygones doivent être connus.  Le processus d'extrusion peut être décomposé en deux étapes: <br><br>  1. Le décalage des polygones par un vecteur de mouvement donné ( <b>décalage</b> ).  Dans ce cas, il faut dupliquer les sommets séparés par des polygones frontières pour ne pas perturber la position des éléments qui n'appartiennent pas à la partie déplacée.  En d'autres termes, vous devez déchirer et déplacer la pièce sélectionnée.  Si cette étape est terminée en premier, le modèle tombera probablement en morceaux qui devront être joints à l'avenir. <br><br><img src="https://habrastorage.org/webt/bb/cn/on/bbcnon5sqdhusvi-qqhqhk05vlu.jpeg"><br><br>  2. Ajout d'une nouvelle géométrie entre la frontière de la pièce déplacée et la frontière qui a été formée pendant l'extrusion.  L'écart entre les parties principale et décalée du modèle est rempli de polygones formant un mur. <br><br><img src="https://habrastorage.org/webt/rv/nx/ts/rvnxts5zhi2y05xd8ykqftgtniw.png"><br><br>  Dans la mise en œuvre, il est plus pratique de construire d'abord le mur, car avant le décalage, nous avons la position initiale des bords sur la bordure et nous pouvons utiliser ces données immédiatement.  Sinon, vous devrez soit inverser la direction du vecteur de cisaillement, soit enregistrer certaines informations sur l'état initial du maillage. <br><br>  Le modèle et ses parties avec lesquelles nous travaillons sont constitués d'ensembles de polygones adjacents par paires (triangles).  Nous appelons chacun de ces ensembles un <b>cluster</b> . <br><br><img src="https://habrastorage.org/webt/7q/y7/6h/7qy76hwucntbje_fcnbw8nznapc.png"><br>  <i>Deux clusters dédiés dans <b>Blender</b></i> <i><br></i> <br>  Tout d'abord, nous devons obtenir tous les bords des contours qui délimitent les clusters sélectionnés.  Pour ce faire, ajoutez simplement les bords à la liste de manière séquentielle.  Si un bord correspondant est trouvé, il doit être supprimé sans ajouter le bord actuel.  Pour le bon fonctionnement d'un tel algorithme, il est nécessaire d'introduire une restriction: sur l'ensemble de triangles sélectionné il n'y a pas plus de deux arêtes coïncidentes.  Dans les cas où l' <b>extrusion est</b> utilisée, les modèles remplissent souvent cette condition, et un algorithme plus complexe nécessite de grandes ressources de calcul. <br><br><div class="spoiler">  <b class="spoiler_title">Liste des méthodes pour obtenir des bords appartenant aux contours</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LinkedListExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;LinkedListNode&lt;T&gt;&gt; Nodes&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> LinkedList&lt;T&gt; list) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = list.First; node != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; node = node.Next) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vertex { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsInPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.Abs(position.x - other.x) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.y - other.y) &lt; Mathf.Epsilon &amp;&amp; Mathf.Abs(position.z - other.z) &lt; Mathf.Epsilon; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Edge { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Coincides</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge other, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeDirection = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v0.IsInPosition(other.v0.position) &amp;&amp; v1.IsInPosition(other.v1.position) || !includeDirection &amp;&amp; v1.IsInPosition(other.v0.position) &amp;&amp; v0.IsInPosition(other.v1.position); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LinkedList&lt;Edge&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObtainHullEdges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Edge&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>]); edge = edges.Nodes().FirstOrDefault(e =&gt; e.Value.Coincides(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) edges.Remove(edge); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> edges.AddFirst(Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edges; } }</code> </pre><br></div></div><br>  Après avoir reçu tous les bords du contour, vous devez construire les murs correspondants.  Il existe de nombreuses options de mise en œuvre, mais nous avons décidé de prendre le chemin de moindre résistance - générer des parallélogrammes dans la direction du vecteur de mouvement en fonction des bords séparément.  Puisque nous avons tous un déplacement, à la suite de cette action, les parallélogrammes formeront une paroi solide et fermée pour chaque groupe.  Reste à déterminer l'orientation des éléments du mur. <br><br>  Le mur, comme tout le maillage, est constitué de triangles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Selon la convention <b>OpenGL</b> , un</a> triangle détaché est rendu à l'écran si, lors de la projection de ses points sur le plan de l'écran, les contourner dans l'ordre correspond à une marche dans le sens horaire: <br><br><img src="https://habrastorage.org/webt/5l/a1/um/5la1umkwunfu0krizz83sz40nvs.jpeg"><br><br>  Ainsi, un triangle correspond à un certain vecteur normal qui définit la face avant.  Chaque triangle est délimité par un contour convexe composé de trois arêtes.  Chaque arête a deux sommets représentés dans notre structure comme <b>v0</b> et <b>v1</b> .  Nous définissons la direction du bord de sorte que <b>v0</b> soit le début, <b>v1</b> soit la fin.  Maintenant, si la direction des bords du triangle est définie en fonction du contournement de ses sommets, alors tout contour externe du cluster doit avoir un contournement dans le sens horaire ou antihoraire et tout contour interne - vice versa.  Nous avons implémenté les constructeurs <b>CustomMesh</b> et <b>Triangle</b> afin que la traversée des sommets de tous les triangles corresponde à la direction horaire. <br><br><img src="https://habrastorage.org/webt/4a/ty/j_/4atyj_c-9-_bpgu3xphnvhgx690.jpeg"><br><br><img src="https://habrastorage.org/webt/6c/yw/so/6cywsooz53z8ytpuyb6y8t1rh7m.jpeg"><br><br>  Ayant la direction de contourner le contour, nous pouvons dire avec certitude quel côté de la nervure est la partie intérieure du contour et lequel est l'extérieur.  Sur la base de ces informations, nous choisirons l'orientation du mur.  Soit ( <b>v0, v1</b> ) l'arête sur la base de laquelle le parallélogramme souhaité doit être généré.  Nous prenons les deux points <b>v2</b> et <b>v3</b> comme positions de décalage <b>v0</b> et <b>v1</b> .  Ensuite, nous construisons deux triangles selon le schéma suivant: <br><br><img src="https://habrastorage.org/webt/vv/ox/zl/vvoxzlj-mc7mu50fdolvczhdbf0.jpeg"><br><br>  Et donc pour chaque bord du contour. <br><br><div class="spoiler">  <b class="spoiler_title">Liste d'une méthode de construction de murs à l'aide d'une liste d'arêtes</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeEdgesSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Edge[] edges, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset == Vector3.zero || edges == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || edges.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesLength = vertices.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesLength) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initTrianglesLength = Triangles.Length; Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Triangles, initTrianglesLength + edges.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>); edges .AsParallel() .Select((edge, i) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = initVerticesLength + i * <span class="hljs-number"><span class="hljs-number">4</span></span>; vertices[j] = edge.v0.position; vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = edge.v1.position; vertices[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.position + offset; vertices[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.position + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == vertices.Length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = Vector3.Cross(vertices[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] - vertices[j], offset); normals[j] = normals[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = normals[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = normal; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == vertices.Length) { uv0[j] = uv0[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv0; uv0[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv0[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv0; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == vertices.Length) { uv2[j] = uv2[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.uv2; uv2[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = uv2[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.uv2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == vertices.Length) { colors[j] = colors[j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = edge.v0.color; colors[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = colors[j + <span class="hljs-number"><span class="hljs-number">3</span></span>] = edge.v1.color; } Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span>, Id, j, j + <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span> ); Triangles[initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle( initTrianglesLength + i * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, Id, j + <span class="hljs-number"><span class="hljs-number">3</span></span>, j + <span class="hljs-number"><span class="hljs-number">2</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }).ToArray(); } }</code> </pre><br></div></div><br>  Avec cette approche, la face avant des murs générés sera correcte pour les toboggans et les fosses.  Il n'y a qu'une seule limitation importante: l'ensemble des triangles sur lesquels l'opération d' <b>extrusion</b> est effectuée ne doit pas être enroulé autour de lui-même par rapport au vecteur de mouvement. <br><br><img src="https://habrastorage.org/webt/4w/8v/te/4w8vtezc5p0mprdnzsmcgxk8htq.jpeg"><br>  <i>Un sous-ensemble de polygones qui n'est pas valide en ce qui concerne le décalage.</i>  <i>Même dans <b>Blender</b> avec une telle extrusion, il ne sera pas possible d'éviter une courbe géométrique.</i> <br><br><img src="https://habrastorage.org/webt/ki/yh/5q/kiyh5qy9-uz1sqf27f_zls89f00.jpeg"><br>  <i>Sous-ensembles valides de polygones</i> <br><br>  Le mur est prêt, il reste à décaler les triangles.  Cette étape de l'algorithme est facile à comprendre, même si la mise en œuvre s'est avérée lourde. <br><br>  Dans notre cas, nous devons nous assurer que chaque sommet du cluster n'appartient qu'à ses triangles.  Si la condition n'est pas remplie, certains polygones voisins peuvent atteindre le cluster.  La solution à cette situation consiste à dupliquer chaque sommet qui appartient à la fois à la grappe et au reste du modèle.  Ensuite, pour tous les polygones du cluster, remplacez l'index de ce sommet par l'index en double.  Lorsque la condition est satisfaite, nous déplaçons tous les sommets du cluster vers le vecteur de mouvement. <br><br><div class="spoiler">  <b class="spoiler_title">Liste d'une méthode pour déplacer un cluster de polygones</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TranslateTrianglesHard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] hullVerts</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newVertexIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initVerticesCount = vertices.Length; Triangles.Where((t, i) =&gt; !triIndices.Contains(i)).Select(t =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V0.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V0.Index)) newVertexIndices.Add(t.V0.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V1.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V1.Index)) newVertexIndices.Add(t.V1.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hullVerts.Contains(t.V2.Index) &amp;&amp; !newVertexIndices.ContainsKey(t.V2.Index)) newVertexIndices.Add(t.V2.Index, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }).ToArray(); Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vertices, initVerticesCount + newVertexIndices.Count); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) vertices[pair.Value] = vertices[pair.Key] + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (normals != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; normals.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> normals, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) normals[pair.Value] = normals[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv0 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv0.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv0, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv0[pair.Value] = uv0[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uv2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; uv2.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> uv2, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) uv2[pair.Value] = uv2[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colors != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; colors.Length == initVerticesCount) { Array.Resize(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> colors, vertices.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> newVertexIndices) colors[pair.Value] = colors[pair.Key]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alreadyMoved = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triIndices.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V0.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V0.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v0.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v1.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V0.Index)) { vertices[Triangles[triIndices[i]].V0.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V0.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V1.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V1.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">0</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V1.Index)) { vertices[Triangles[triIndices[i]].V1.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V1.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertexIndices.ContainsKey(Triangles[triIndices[i]].V2.Index)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = newVertexIndices[Triangles[triIndices[i]].V2.Index]; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">1</span></span>].v1.Index = index; Triangles[triIndices[i]].Edges[<span class="hljs-number"><span class="hljs-number">2</span></span>].v0.Index = index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!alreadyMoved.Contains(Triangles[triIndices[i]].V2.Index)) { vertices[Triangles[triIndices[i]].V2.Index] += offset; alreadyMoved.Add(Triangles[triIndices[i]].V2.Index); } } } }</code> </pre><br></div></div><br>  C'est fait.  Maintenant, en additionnant les résultats de toutes les étapes, nous obtenons un trou ou une colline. <br><br><div class="spoiler">  <b class="spoiler_title">Liste de la méthode finale pour l'opération d'extrusion</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomMesh</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudeTriangles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] triIndices, Vector3 offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> edges = ObtainHullEdges(triIndices); ExtrudeEdgesSet(edges.ToArray(), offset); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hullVertices = edges.Select(edge =&gt; edge.v0.Index).ToArray(); TranslateTrianglesHard(triIndices, offset, hullVertices); } }</code> </pre><br></div></div><br>  Après avoir joué avec les coordonnées du scan de texture et le déplacement des points de contour, vous pouvez obtenir un tel retrait: <br><br><img src="https://habrastorage.org/webt/bw/at/oe/bwatoexbyvwkfjrztopbegi8uwi.png"><br><br><h3>  Et ce n'est pas tout </h3><br>  En plus des opérations d'édition décrites ci-dessus, nous utilisons également d'autres méthodes pratiques pour travailler avec des modèles. <br><br>  Par exemple, nous avons également écrit la méthode <b>Combine ()</b> pour combiner deux <b>CustomMesh</b> .  La principale différence entre notre implémentation et <b>UnityEngine.Mesh.CombineMeshes ()</b> est que si certains sommets sont complètement équivalents lors de la combinaison des maillages, nous n'en laissons qu'un, évitant ainsi une géométrie inutile. <br><br>  Dans le même module, nous avons implémenté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de triangulation du plan de Delaunay</a> .  En l'utilisant, vous pouvez, par exemple, fermer un grand trou créé en utilisant <b>Extruder</b> avec un couvercle plat avec une texture d'eau et obtenir un lac: <br><br><img src="https://habrastorage.org/webt/zx/d_/7a/zxd_7akztomgl6ccvb0nfofnha8.png"><br><br>  Eh bien, triez-le!  Dans le prochain article, nous examinerons les caractéristiques de l'importation de <b>.fbx</b> dans <b>Unity</b> et les méthodes de validation de modèle dans un projet. <br><br><div class="spoiler">  <b class="spoiler_title">Pour une collation (juste pour lulz)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/x8/mk/wu/x8mkwuv2ose4mtecuzy3ph0m2bg.png"><br><img src="https://habrastorage.org/webt/cc/bu/lr/ccbulroovvqlk-jgmedg99jehfc.png"><br><img src="https://habrastorage.org/webt/ut/lr/2-/utlr2-kfdve0lkp6j97xcvaz6aa.png"><br><img src="https://habrastorage.org/webt/jk/km/pn/jkkmpnrhfhxdvxqxsp6sajwbxri.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443870/">https://habr.com/ru/post/fr443870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443854/index.html">Conception RPG à quatre axes</a></li>
<li><a href="../fr443856/index.html">Travail des métaux sur machines CNC: comment commencer à produire des produits de classe mondiale?</a></li>
<li><a href="../fr443860/index.html">Programmeur en tant que service pour les petites entreprises. Volera-t-il ou non?</a></li>
<li><a href="../fr443862/index.html">Les serrures de voiture du procureur. Bestchange est de nouveau verrouillé</a></li>
<li><a href="../fr443868/index.html">En tant que programmeur, je suis allé au gymnase, et ce qui en est sorti</a></li>
<li><a href="../fr443872/index.html">Présentation des nouvelles fonctionnalités de nanoCAD SPDS Steelwork version 1.2</a></li>
<li><a href="../fr443874/index.html">Comparaison des frameworks d'apprentissage en profondeur: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe, etc.</a></li>
<li><a href="../fr443876/index.html">Nous développons un bot Telegram pour suivre les films sur NodeJS et TypeScript</a></li>
<li><a href="../fr443878/index.html">DEV Labs 2019. Python pour résoudre des tâches non triviales. Mitap en ligne</a></li>
<li><a href="../fr443882/index.html">MOSDROID # 15 Phosphorus: vidéo de performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>