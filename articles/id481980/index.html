<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧 🧙🏽 🔶 Bagaimana kami mengoptimalkan skrip di Unity 👩🏾‍🔬 👉🏽 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak artikel dan tutorial Unity performance yang hebat. Kami tidak mencoba untuk mengganti atau memperbaikinya dengan artikel ini, ini hanya rin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami mengoptimalkan skrip di Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> Ada banyak artikel dan tutorial Unity performance yang hebat.  Kami tidak mencoba untuk mengganti atau memperbaikinya dengan artikel ini, ini hanya ringkasan singkat dari langkah-langkah yang kami ambil setelah membaca artikel ini, serta langkah-langkah yang memungkinkan kami untuk menyelesaikan masalah kami.  Saya sangat menyarankan agar Anda setidaknya mempelajari materi di <a href="https://learn.unity.com/">https://learn.unity.com/</a> . <br><br>  Dalam proses pengembangan game kami, kami menemui masalah yang dari waktu ke waktu menyebabkan terhambatnya proses game.  Setelah menghabiskan beberapa waktu di Unity Profiler, kami menemukan dua jenis masalah: <br><br><ul><li>  Shader Non-Dioptimalkan </li><li>  Skrip tidak dioptimalkan dalam C # </li></ul><br>  Sebagian besar masalah disebabkan oleh kelompok kedua, jadi saya memutuskan untuk fokus pada skrip C # dalam artikel ini (mungkin juga karena saya belum menulis satu shader pun dalam hidup saya). <br><br><h1>  Cari kelemahannya </h1><br>  Tujuan artikel ini bukan untuk menulis tutorial tentang cara menggunakan profiler;  Saya hanya ingin berbicara tentang apa yang paling kami minati selama proses pembuatan profil. <br><br>  <strong>Unity Profiler selalu merupakan cara terbaik untuk</strong> menemukan penyebab keterlambatan skrip.  Saya sangat merekomendasikan untuk <strong>membuat profil game langsung di perangkat</strong> , dan tidak di editor.  Karena permainan kami dibuat untuk iOS, saya harus menghubungkan perangkat dan menggunakan Pengaturan Bangun yang ditunjukkan pada gambar, setelah itu profiler terhubung secara otomatis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>Bangun Pengaturan untuk Pembuatan Profil</em> <br><br>  Jika Anda mencoba google "Random lag in Unity" atau permintaan serupa lainnya, Anda akan menemukan bahwa kebanyakan orang merekomendasikan <strong>fokus pada pengumpulan sampah</strong> , yang persis seperti yang saya lakukan.  Sampah dihasilkan setiap kali Anda berhenti menggunakan beberapa objek (instance kelas), setelah itu pengumpul sampah Unity mulai dari waktu ke waktu untuk membersihkan kekacauan dan membebaskan memori, yang membutuhkan jumlah waktu yang gila dan menyebabkan penurunan frame rate. <br><a name="habracut"></a><br><h2>  Bagaimana menemukan skrip sampah di profiler? </h2><br>  Cukup pilih Penggunaan CPU -&gt; Pilih tampilan Hirarki -&gt; Urutkan berdasarkan GC Alloc <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>Opsi profiler untuk pengumpulan sampah</em> <br><br>  Tugas Anda adalah mencapai beberapa angka nol di kolom alokasi GC untuk adegan permainan. <br><br>  Cara lain yang baik adalah dengan <strong>mengurutkan entri berdasarkan ms Waktu</strong> (run time) dan mengoptimalkan skrip sehingga mereka mengambil sesedikit mungkin waktu.  Langkah ini memiliki dampak besar bagi kami, karena salah satu komponen kami berisi <strong>besar untuk loop</strong> , yang membutuhkan waktu lama untuk menyelesaikan (ya, kami belum menemukan cara untuk menghilangkan loop), jadi mengoptimalkan waktu eksekusi semua skrip benar-benar diperlukan bagi kami, karena kami perlu menghemat runtime pada loop yang mahal ini, sambil mempertahankan frekuensi stabil 60 fps. <br><br>  Berdasarkan data profil, saya membagi pengoptimalan menjadi dua bagian: <br><br><ul><li>  Membuang sampah </li><li>  Mengurangi waktu tunggu </li></ul><br><h1>  Bagian 1: melawan sampah </h1><br>  Pada bagian ini saya akan memberi tahu Anda apa yang kami lakukan untuk membuang sampah.  Ini adalah pengetahuan paling mendasar yang harus dipahami oleh pengembang mana pun;  mereka telah menjadi bagian penting dari analisis harian kami dalam setiap permintaan tarikan / penggabungan. <br><br><h2>  Aturan pertama: tidak ada objek baru dalam metode Perbarui </h2><br>  Idealnya, metode <strong>Pembaruan, FixedUpdate, dan LateUpdate tidak boleh mengandung kata kunci "baru"</strong> .  Anda harus selalu menggunakan apa yang sudah Anda miliki. <br><br>  Terkadang <strong>membuat objek baru tersembunyi</strong> di beberapa metode internal Unity, jadi tidak begitu jelas.  Kami akan membicarakan ini nanti. <br><br><h2>  Aturan kedua: buat sekali dan gunakan kembali! </h2><br>  Intinya, ini berarti Anda harus mengalokasikan memori untuk semua yang Anda bisa dalam metode Mulai dan Sedarlah.  Aturan ini sangat mirip dengan yang pertama.  Ini sebenarnya hanyalah cara lain untuk menghilangkan kata kunci "baru" dari metode Pembaruan. <br><br>  Kode itu: <br><br><ul><li>  menciptakan instance baru </li><li>  mencari objek permainan </li></ul><br>  Anda harus selalu mencoba untuk beralih dari metode Perbarui ke Mulai atau Sedarlah. <br><br>  Berikut adalah contoh dari perubahan kami: <br><br>  Alokasi memori untuk daftar dalam metode Mulai, pembersihan (Bersihkan) dan digunakan kembali jika perlu. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br>  Menyimpan tautan dan menggunakannya kembali sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br>  Hal yang sama berlaku untuk metode FindGameObjectsWithTag atau metode lain yang mengembalikan array baru. <br><br><h2>  Aturan ketiga: waspadai string dan hindari penggabungannya </h2><br>  Ketika membuat sampah, garisnya mengerikan.  Bahkan operasi string yang paling sederhana pun dapat menghasilkan banyak sampah.  Mengapa  String hanyalah array, dan array ini tidak berubah.  Ini berarti bahwa setiap kali Anda menggabungkan dua baris, array baru dibuat, dan yang lama berubah menjadi sampah.  Untungnya, StringBuilder dapat digunakan untuk menghindari atau meminimalkan pembuatan sampah tersebut. <br><br>  Berikut adalah contoh bagaimana Anda dapat memperbaiki situasi: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br>  Semuanya baik-baik saja dengan contoh yang ditunjukkan di atas, tetapi masih ada banyak kemungkinan untuk meningkatkan kode.  Seperti yang Anda lihat, hampir seluruh string dapat dianggap statis.  Kami membagi string menjadi dua bagian untuk dua objek UI. Teks.  Pertama, yang satu hanya berisi teks statis <strong>"Player" + nama + "memiliki skor"</strong> , yang dapat ditetapkan dalam metode Mulai, dan yang kedua berisi nilai skor, yang diperbarui di setiap frame.  <strong>Selalu buat garis statis benar-benar statis dan hasilkan dalam metode Mulai atau Sedarlah</strong> .  Setelah peningkatan ini, hampir semuanya beres, tetapi sedikit sampah masih dihasilkan saat memanggil Int.ToString (), Float.ToString (), dll. <br><br>  Kami memecahkan masalah ini dengan membuat dan mengalokasikan memori untuk semua lini yang memungkinkan.  Ini mungkin tampak seperti pemborosan memori yang bodoh, tetapi solusi seperti itu sangat cocok dengan kebutuhan kita dan sepenuhnya menyelesaikan masalah.  Jadi, pada akhirnya, kami mendapat array statis, akses yang dapat langsung diakses menggunakan indeks untuk mengambil string yang diinginkan yang menunjukkan angka: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2>  Aturan Keempat: Nilai-Nilai Cache Dikembalikan dengan Metode Akses </h2><br>  Ini bisa sangat sulit, karena bahkan metode pengaksesan sederhana seperti yang ditunjukkan di bawah ini menghasilkan sampah: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br>  Cobalah untuk menghindari menggunakan metode akses dalam metode Pembaruan.  Panggil metode akses hanya sekali dalam metode Mulai dan cache nilai kembali. <br><br>  Secara umum, saya sarankan <strong>TIDAK memanggil metode akses string atau metode akses array dalam metode Pembaruan</strong> .  Dalam kebanyakan kasus, cukup <strong>untuk mendapatkan tautan sekali dalam metode Mulai</strong> . <br><br>  Berikut adalah dua contoh umum dari kode metode akses lain yang tidak dioptimalkan: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2>  Aturan Kelima: Gunakan Fungsi yang Tidak Mengalokasikan Memori </h2><br>  Untuk beberapa fungsi Unity, alternatif non-memori dapat ditemukan.  Dalam kasus kami, semua fungsi ini terkait dengan fisika.  Pengakuan tabrakan kami didasarkan pada <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br>  Untuk kasus khusus ini, Anda dapat menemukan fungsi non-memori yang disebut <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br>  Banyak fungsi lain juga memiliki alternatif yang serupa, jadi <strong>selalu periksa dokumentasi untuk fungsi NonAlloc</strong> . <br><br><h2>  Aturan keenam: jangan gunakan LINQ </h2><br>  Tapi jangan lakukan itu.  Maksud saya, Anda tidak perlu menggunakannya dalam kode apa pun yang sering berjalan.  Saya tahu bahwa ketika menggunakan LINQ, kodenya lebih mudah dibaca, tetapi dalam banyak kasus kinerja dan alokasi memori dari kode semacam itu mengerikan.  Tentu saja, kadang-kadang dapat digunakan, tetapi, jujur ​​saja, dalam game kami, kami tidak menggunakan LINQ sama sekali. <br><br><h2>  Aturan ketujuh: buat sekali dan gunakan kembali, bagian 2 </h2><br>  Kali ini kita berbicara tentang objek penyatuan.  Saya tidak akan masuk ke rincian pooling, karena ini telah dikatakan berkali-kali, misalnya, pelajari tutorial ini: <a href="https://learn.unity.com/tutorial/object-pooling">https://learn.unity.com/tutorial/object-pooling</a> <br><br>  Dalam kasus kami, skrip pengumpulan objek berikut digunakan.  Kami memiliki level yang dihasilkan diisi dengan rintangan yang ada selama periode waktu tertentu sampai pemain melewati bagian level ini.  Contoh hambatan seperti itu dibuat dari cetakan jika kondisi tertentu dipenuhi.  Kode ini dalam metode Pembaruan.  Kode ini sama sekali tidak efisien dalam hal memori dan runtime.  Kami memecahkan masalah dengan membuat kumpulan 40 rintangan: jika perlu, kami mendapatkan hambatan dari kolam dan mengembalikan objek ke kolam ketika tidak lagi diperlukan. <br><br><h2>  Aturan kedelapan: lebih penuh perhatian dengan transformasi kemasan (Tinju)! </h2><br>  Tinju menghasilkan sampah!  Tapi apa itu tinju?  Paling sering, tinju terjadi ketika Anda melewatkan tipe nilai (int, float, bool, dll.) Ke fungsi yang mengharapkan objek tipe objek. <br><br>  Berikut adalah contoh tinju yang perlu kami perbaiki dalam proyek kami: <br><br>  Kami menerapkan sistem pesan kami sendiri di proyek.  Setiap pesan dapat berisi jumlah data yang tidak terbatas.  Data disimpan dalam kamus yang didefinisikan sebagai berikut: <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br>  Kami juga memiliki setter yang menetapkan nilai dalam kamus ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  Tinju di sini cukup jelas.  Anda dapat memanggil fungsi sebagai berikut: <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br>  Kemudian nilai "12" dikenakan tinju dan ini menghasilkan sampah. <br><br>  Kami memecahkan masalah dengan membuat wadah data terpisah untuk setiap jenis primitif, dan wadah Obyek sebelumnya hanya digunakan untuk jenis referensi. <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br>  Kami juga memiliki setter terpisah untuk setiap tipe data: <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Dan semua setter ini diimplementasikan sedemikian rupa sehingga mereka memanggil fungsi umum yang sama: <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Masalah tinju telah diatasi! <br><br>  Baca lebih lanjut tentang ini di artikel <a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a> . <br><br><h2>  Aturan kesembilan: siklus selalu dicurigai </h2><br>  Aturan ini sangat mirip dengan yang pertama dan kedua.  Coba hapus semua kode opsional dari loop karena alasan kinerja dan memori. <br><br>  Dalam kasus umum, kami berupaya untuk menghilangkan loop dalam metode Pembaruan, tetapi jika kami tidak dapat melakukannya tanpa mereka, maka kami setidaknya akan menghindari alokasi memori dalam loop tersebut.  Jadi, ikuti <strong>aturan 1–8 dan terapkan pada loop</strong> secara umum, bukan hanya metode Perbarui. <br><br><h2>  Aturan 10: tidak ada sampah di perpustakaan eksternal </h2><br>  Jika ternyata sebagian sampah dihasilkan oleh kode yang diunduh dari Asset store, maka masalah ini memiliki banyak solusi.  Tetapi sebelum melakukan reverse engineering dan debugging, kembali saja ke Asset store dan perbarui perpustakaan.  Dalam kasus kami, semua aset yang digunakan masih didukung oleh penulis yang terus merilis pembaruan peningkatan kinerja, jadi ini menyelesaikan semua masalah kami.  <strong>Ketergantungan harus relevan!</strong>  Saya lebih suka menyingkirkan perpustakaan daripada tetap tidak didukung. <br><br><h1>  Bagian 2: memaksimalkan runtime </h1><br>  Beberapa aturan di atas membuat perbedaan yang halus jika kodenya jarang dipanggil.  Ada satu loop besar dalam kode kami yang berjalan di setiap frame, jadi bahkan perubahan kecil ini memiliki efek yang sangat besar. <br><br>  Beberapa perubahan ini, jika digunakan secara tidak tepat atau dalam situasi yang salah, dapat menyebabkan waktu berjalan yang lebih buruk.  <strong>Selalu periksa profiler setelah memasukkan setiap optimasi dalam kode untuk memastikan bahwa Anda bergerak ke arah yang benar</strong> . <br><br>  Sejujurnya, beberapa <strong>aturan ini mengarah pada kode yang dapat dibaca lebih buruk</strong> , dan kadang-kadang bahkan <strong>melanggar rekomendasi</strong> , misalnya, penyematan kode yang disebutkan dalam salah satu aturan di bawah ini. <br><br>  Banyak dari aturan ini tumpang tindih dengan yang disajikan di bagian pertama artikel.  Biasanya, kinerja kode penghasil sampah lebih rendah dibandingkan dengan kode tanpa penghasil sampah. <br><br><h2>  Aturan pertama: urutan eksekusi yang benar </h2><br>  <strong>Pindahkan kode dari metode FixedUpdate, Update, LateUpdate ke metode Mulai dan Sedarlah</strong> .  Saya tahu ini kedengarannya gila, tetapi percayalah, jika Anda mempelajari kode Anda, Anda akan menemukan ratusan baris kode yang dapat dipindahkan ke metode yang dijalankan hanya sekali. <br><br>  Dalam kasus kami, kode ini biasanya dikaitkan dengan <br><br><ul><li>  Panggilan ke GetComponent &lt;&gt; </li><li>  Komputasi yang benar-benar mengembalikan hasil yang sama di setiap frame </li><li>  Banyak contoh dari objek yang sama, biasanya daftar </li><li>  Cari GameObjects </li><li>  Mendapatkan tautan ke Transform dan menggunakan metode akses lainnya </li></ul><br>  Berikut adalah daftar kode sampel yang telah kami pindahkan dari metode Perbarui ke metode Mulai: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2>  Aturan kedua: jalankan kode hanya bila perlu </h2><br>  Dalam kasus kami, ini terutama terkait dengan skrip pembaruan UI.  Berikut adalah contoh bagaimana kami mengubah implementasi kode yang menampilkan status terkini dari item yang dikumpulkan di level. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br>  Karena pada setiap level hanya ada beberapa item untuk dikumpulkan, tidak masuk akal untuk mengubah teks UI di setiap frame.  Oleh karena itu, kami mengubah teks hanya ketika angkanya berubah. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br>  Kode ini jauh lebih baik, terutama jika tindakannya jauh lebih rumit daripada hanya mengubah UI. <br><br>  Jika Anda mencari solusi yang lebih komprehensif, saya sarankan menerapkan <a href="https://en.wikipedia.org/wiki/Observer_pattern">template Observer</a> menggunakan acara C # ( <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a> ). <br><br>  Bagaimanapun, ini masih belum cukup bagi kami, dan kami ingin menerapkan solusi yang sepenuhnya digeneralisasi, jadi kami membuat perpustakaan yang mengimplementasikan <a href="https://facebook.github.io/flux/">Flux</a> in Unity.  Ini mengarah ke solusi yang sangat sederhana, di mana seluruh keadaan permainan disimpan di objek "Store", dan semua elemen UI dan komponen lainnya diberi tahu ketika keadaan berubah dan bereaksi terhadap perubahan ini tanpa kode dalam metode Pembaruan. <br><br><h2>  Aturan ketiga: siklus selalu dicurigai </h2><br>  Ini persis aturan yang sama yang saya sebutkan di bagian pertama artikel.  Jika kode memiliki semacam loop yang berulang memotong sejumlah besar elemen, maka untuk meningkatkan kinerja loop, gunakan kedua aturan dari kedua bagian artikel. <br><br><h2>  Aturan Keempat: For Better Than Foreach </h2><br>  Loop Foreach sangat mudah untuk ditulis, tetapi "sangat sulit" untuk dieksekusi.  Di dalam loop Foreach, Enumerator digunakan untuk memproses iteratif dataset dan mengembalikan nilainya.  Ini lebih rumit daripada mengulangi indeks dalam loop sederhana. <br><br>  Oleh karena itu, dalam proyek kami, kami sedapat mungkin mengganti Foreach loop dengan For: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br>  Dalam kasus kami dengan besar untuk loop, perubahan ini sangat signifikan.  <strong>Sederhana untuk loop mempercepat kode dua kali</strong> . <br><br><h2>  Aturan kelima: array lebih baik daripada daftar </h2><br>  Dalam kode kami, kami menemukan bahwa sebagian besar daftar memiliki panjang konstan, atau kami dapat menghitung jumlah elemen maksimum.  Oleh karena itu, kami menerapkannya kembali berdasarkan array, dan dalam beberapa kasus ini menyebabkan percepatan dua kali lipat pengulangan atas data. <br><br>  Dalam beberapa kasus, daftar atau struktur data kompleks lainnya tidak dapat dihindari.  Kebetulan Anda sering harus menambah atau menghapus elemen, dan dalam hal ini lebih baik menggunakan daftar.  Tetapi secara umum, <strong>array harus selalu digunakan untuk daftar panjang tetap</strong> . <br><br><h2>  Aturan Keenam: Operasi Apung Lebih Baik Daripada Operasi Vektor </h2><br>  Perbedaan ini hampir tidak terlihat jika Anda tidak melakukan ribuan operasi seperti itu, seperti yang terjadi dalam kasus kami, jadi bagi kami peningkatan produktivitas ternyata signifikan. <br><br>  Kami membuat perubahan serupa: <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2>  Aturan ketujuh: mencari objek dengan benar </h2><br>  Selalu pikirkan apakah Anda benar-benar perlu menggunakan metode GameObject.Find ().  Metode ini berat dan membutuhkan waktu yang tidak sedikit.  Anda tidak boleh menggunakan metode ini dalam metode Perbarui.  Kami menemukan bahwa sebagian besar panggilan Temukan kami dapat <strong>diganti dengan tautan langsung di editor</strong> , yang tentu saja jauh lebih baik. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br>  Jika ini tidak mungkin dilakukan, maka setidaknya <strong>pertimbangkan untuk menggunakan tag (Tag) dan mencari objek dengan labelnya menggunakan GameObject.FindWithTag</strong> . <br><br>  Jadi, dalam kasus umum: <strong>Tautan langsung&gt; GameObject.FindWithTag ()&gt; GameObject.Find ()</strong> <br><br><h2>  Aturan Kedelapan: Hanya Bekerja dengan Objek yang Relevan </h2><br>  Dalam kasus kami, ini penting untuk mengenali tabrakan menggunakan RayCast-s (CircleCast, dll.).  Alih-alih mengenali tumbukan dan memutuskan mana yang penting dalam kode, <strong>kami memindahkan objek game ke lapisan yang sesuai</strong> sehingga kami dapat menghitung tumbukan hanya untuk objek yang diperlukan. <br><br>  Berikut ini sebuah contoh <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2>  Aturan kesembilan: gunakan label dengan benar </h2><br>  Tidak ada keraguan bahwa label sangat berguna dan dapat meningkatkan kinerja kode, tetapi ingat bahwa <strong>hanya ada satu cara yang benar untuk membandingkan label objek</strong> ! <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2>  Aturan kesepuluh: Waspadalah terhadap trik dengan kamera! </h2><br>  Sangat mudah untuk menggunakan <strong>Camera.main</strong> , tetapi kinerja dari tindakan ini sangat buruk.  Alasannya adalah bahwa di balik layar setiap panggilan ke Camera.main, mesin Unity benar-benar mengeksekusi hasil FindGameObjectsWithTag (), jadi kami sudah mengerti bahwa Anda tidak perlu sering memanggilnya, dan yang terbaik untuk menyelesaikan masalah ini dengan <strong>caching tautan dalam metode Mulai</strong> atau bangun. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2>  Aturan Kesebelas: Posisi Lokal Lebih Baik Dari Posisi </h2><br>  <strong>Jika memungkinkan, gunakan Transform.LocalPosition untuk getter dan setter alih-alih Transform.Position</strong> .  Di dalam setiap panggilan Transform.Position, lebih banyak operasi dilakukan, misalnya, menghitung posisi global dalam kasus panggilan pengambil atau menghitung posisi lokal dari global dalam kasus panggilan setter.  Dalam proyek kami, ternyata Anda dapat menggunakan LocalPositions dalam 99% kasus menggunakan Transform.Position, dan Anda tidak perlu membuat perubahan lain dalam kode. <br><br><h2>  Aturan Keduabelas: Jangan Gunakan LINQ </h2><br>  Ini sudah dibahas di bagian pertama.  Tapi jangan gunakan itu, itu saja. <br><br><h2>  Aturan ketigabelas: jangan takut (kadang-kadang) melanggar aturan </h2><br>  Kadang-kadang bahkan memanggil fungsi sederhana bisa jadi terlalu mahal.  Dalam hal ini, Anda harus selalu mempertimbangkan menyematkan kode (Code Inlining).  Apa artinya ini?  Bahkan, kami hanya mengambil kode dari fungsi dan menyalinnya langsung ke tempat di mana kami ingin menggunakan fungsi untuk menghindari memanggil metode tambahan. <br><br>  Dalam kebanyakan kasus, ini tidak akan berpengaruh apa pun, karena penyisipan kode dilakukan secara otomatis pada tahap kompilasi, tetapi ada aturan tertentu yang digunakan oleh kompiler untuk memutuskan apakah akan menyematkan kode (misalnya, metode virtual tidak pernah disematkan; untuk lebih jelasnya, lihat <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https: //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ).  Jadi buka saja profiler, luncurkan game pada perangkat target dan lihat apakah ada sesuatu yang dapat ditingkatkan. <br><br>  Dalam kasus kami, ada beberapa fungsi yang kami putuskan untuk diintegrasikan untuk meningkatkan kinerja, terutama pada loop yang besar. <br><br><h1>  Kesimpulan </h1><br>  Menerapkan aturan yang tercantum dalam artikel, kami dengan mudah mencapai stabil 60 fps di game untuk iOS, bahkan di iPhone 5S.  Mungkin beberapa aturan mungkin hanya spesifik untuk proyek kami, tetapi saya pikir sebagian besar dari mereka harus diingat ketika menulis kode atau memeriksanya untuk menghindari masalah di masa depan.  Itu selalu lebih baik untuk terus-menerus menulis kode berdasarkan kinerja daripada nanti untuk refactor potongan kode besar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481980/">https://habr.com/ru/post/id481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481960/index.html">2. Tumpukan elastis: analisis log keamanan. Logstash</a></li>
<li><a href="../id481964/index.html">Cara mengatur rilis</a></li>
<li><a href="../id481970/index.html">"Format dan Media Audio yang Terlupakan": Awal Mula dari Audio Ringkas atau "Perubahan Pertama" untuk Bobbin</a></li>
<li><a href="../id481974/index.html">Menguji Water Melon menggunakan Neural Networks: Full Dev. Siklus dari prototyping ke App. di google play</a></li>
<li><a href="../id481978/index.html">Cara mengatur kerja efektif tim tata letak terdistribusi</a></li>
<li><a href="../id481988/index.html">Mengapa Koji adalah sumber yang sempurna untuk pencipta aplikasi KaiOS pemula</a></li>
<li><a href="../id481990/index.html">Sepuluh tahun malware: botnet terbesar 2010</a></li>
<li><a href="../id481992/index.html">Tekton Pipeline - jaringan pipa asli Kubernetes</a></li>
<li><a href="../id481996/index.html">Detektif Habra di akhir pekan 2. Level baru</a></li>
<li><a href="../id481998/index.html">Mesin Turing, sebagai model program otomat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>