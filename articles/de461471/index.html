<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎦 🙏🏻 🚻 .NET - Tools zum Arbeiten mit Multithreading und Asynchronität - Teil 2 🙇🏼 🙆🏽 👩🏼‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe diesen Artikel ursprünglich im CodingSight- Blog veröffentlicht. 
 Es ist hier auch in russischer Sprache erhältlich. 

 Dieser Artikel enthä...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET - Tools zum Arbeiten mit Multithreading und Asynchronität - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Ich habe diesen Artikel ursprünglich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodingSight-</a> Blog veröffentlicht.</i> <i><br></i>  <i>Es ist hier auch in russischer Sprache erhältlich.</i> <br><br>  Dieser Artikel enthält den zweiten Teil meiner Rede beim Multithreading-Treffen.  Den ersten Teil können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ansehen.  Im ersten Teil konzentrierte ich mich auf die grundlegenden Tools zum Starten eines Threads oder einer Aufgabe, auf die Möglichkeiten, ihren Status zu verfolgen, und auf einige zusätzliche nützliche Dinge wie PLinq.  In diesem Teil werde ich die Probleme beheben, die in einer Multithread-Umgebung auftreten können, sowie einige Möglichkeiten, sie zu beheben. <br><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In Bezug auf gemeinsam genutzte Ressourcen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mögliche Probleme in Multithread-Umgebungen</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rennbedingung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschäftigt warten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fadenhunger</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchronisationsmethoden</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verriegelt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Enter, Monitor.Exit, sperren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Wait, Monitor.Pulse [Alle]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ResetEvent-Familie</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  In Bezug auf gemeinsam genutzte Ressourcen </h2><br>  Sie können kein Programm schreiben, das auf mehreren Threads basiert, ohne über gemeinsam genutzte Ressourcen zu verfügen.  Selbst wenn es auf Ihrer aktuellen Abstraktionsebene funktioniert, werden Sie feststellen, dass es tatsächlich über gemeinsam genutzte Ressourcen verfügt, sobald Sie eine oder mehrere Abstraktionsebenen herunterfahren.  Hier einige Beispiele: <br><br>  <b>Beispiel 1:</b> <br><br>  Um mögliche Probleme zu vermeiden, lassen Sie die Threads mit verschiedenen Dateien arbeiten, eine Datei für jeden Thread.  Es scheint Ihnen, dass das Programm keinerlei gemeinsame Ressourcen hat. <br><br>  Wenn Sie ein paar Ebenen tiefer gehen, werden Sie feststellen, dass es nur eine Festplatte gibt und es Sache des Treibers oder des Betriebssystems ist, eine Lösung für Probleme mit dem Festplattenzugriff zu finden. <br><br>  <b>Beispiel 2:</b> <br><br>  Nachdem Sie <i>Beispiel 1</i> gelesen haben, haben Sie beschlossen, die Dateien auf zwei verschiedenen Remotecomputern mit physisch unterschiedlicher Hardware und Betriebssystemen abzulegen.  Sie pflegen auch zwei verschiedene FTP- oder NFS-Verbindungen. <br><br>  Wenn Sie noch einmal ein paar Stufen tiefer gehen, haben Sie verstanden, dass sich nichts wirklich geändert hat, und das Problem des wettbewerbsfähigen Zugriffs wird jetzt an den Netzwerkkartentreiber oder das Betriebssystem des Computers delegiert, auf dem das Programm ausgeführt wird. <br><br>  <b>Beispiel 3:</b> <br><br>  Nachdem Sie den größten Teil Ihrer Haare herausgezogen haben, um zu beweisen, dass Sie ein Multithread-Programm schreiben können, entscheiden Sie sich, die Dateien vollständig zu löschen und die Berechnungen auf zwei verschiedene Objekte zu verschieben, wobei die Links zu jedem Objekt nur für das jeweilige Objekt verfügbar sind Fäden. <br><br>  Um das letzte Dutzend Nägel in den Sarg dieser Idee zu hämmern: Eine Laufzeit und ein Garbage Collector, ein Thread-Scheduler, physisch ein einheitlicher RAM und ein Prozessor gelten weiterhin als gemeinsam genutzte Ressourcen. <br><br>  Wir haben also gelernt, dass es unmöglich ist, ein Multithread-Programm ohne gemeinsam genutzte Ressourcen auf allen Abstraktionsebenen und im gesamten Umfang des Technologie-Stacks zu schreiben.  Glücklicherweise kümmert sich jede Abstraktionsebene (in der Regel) teilweise oder sogar vollständig um die Probleme des Wettbewerbszugriffs oder verweigert sie einfach sofort (Beispiel: Jedes UI-Framework erlaubt nicht die Arbeit mit Elementen aus verschiedenen Threads).  Daher treten die Probleme mit gemeinsam genutzten Ressourcen normalerweise auf Ihrer aktuellen Abstraktionsebene auf.  Um sich um sie zu kümmern, wird das Konzept der Synchronisation eingeführt. <br><a name="Problems"></a><br><h2>  Mögliche Probleme in Multithread-Umgebungen </h2><br>  Wir können Softwarefehler in die folgenden Kategorien einteilen: <br><ol><li>  Das Programm liefert kein Ergebnis - es stürzt ab oder friert ein. </li><li>  Das Programm liefert ein falsches Ergebnis. </li><li>  Das Programm liefert ein korrektes Ergebnis, erfüllt jedoch einige nicht funktionsbezogene Anforderungen nicht - es verbraucht zu viel Zeit oder Ressourcen. </li></ol><br>  In Umgebungen mit mehreren Threads sind die Hauptprobleme, die zu den Fehlern Nr. 1 und Nr. 2 führen, <b>Deadlock</b> und <b>Race Condition</b> . <br><br><a name="Deadlock"></a><br><h3>  Deadlock </h3><br>  Deadlock ist ein gegenseitiger Block.  Es gibt viele Variationen eines Deadlocks.  Das folgende kann als das häufigste angesehen werden: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Während <b>Thread 1</b> etwas tat, blockierte <b>Thread 2</b> Ressource <b>B.</b>  <b>Einige Zeit</b> später blockierte <b>Thread 1</b> Ressource <b>A</b> und versuchte, Ressource B zu blockieren. Leider wird dies nie passieren, da <b>Thread 2</b> Ressource <b>B erst</b> nach dem Blockieren von Ressource <b>A</b> loslässt <b>.</b> <br><a name="RaceCondition"></a><br><h3>  Rennbedingung </h3><br>  Race-Condition ist eine Situation, in der sowohl das Verhalten als auch die Ergebnisse der Berechnungen vom Thread-Scheduler der Ausführungsumgebung abhängen <br><br>  Das Problem ist, dass Ihr Programm einmal in hundert oder sogar in einer Million nicht richtig funktioniert. <br><br>  Die Dinge können schlimmer werden, wenn Probleme zu dritt auftreten.  Beispielsweise kann das spezifische Verhalten des Thread-Schedulers zu einem gegenseitigen Deadlock führen. <br><br>  Zusätzlich zu diesen beiden Problemen, die zu expliziten Fehlern führen, gibt es auch Probleme, die, wenn sie nicht zu falschen Berechnungsergebnissen führen, dazu führen können, dass das Programm viel mehr Zeit oder Ressourcen benötigt, um das gewünschte Ergebnis zu erzielen.  Zwei dieser Probleme sind <b>Busy Wait</b> und <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Beschäftigt warten </h3><br>  Busy Wait ist ein Problem, das auftritt, wenn das Programm Prozessorressourcen eher für das Warten als für die Berechnung ausgibt. <br><br>  In der Regel sieht dieses Problem folgendermaßen aus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Dies ist ein Beispiel für einen extrem schlechten Code, da er einen Kern Ihres Prozessors vollständig belegt und überhaupt nichts Produktives tut.  Ein solcher Code kann nur gerechtfertigt werden, wenn es von entscheidender Bedeutung ist, eine Änderung eines Werts in einem anderen Thread schnell zu verarbeiten.  Und mit "schnell" meine ich, dass Sie nicht einmal ein paar Nanosekunden warten können.  In allen anderen Fällen, dh in allen Fällen, in denen sich ein vernünftiger Verstand einfallen lassen kann, ist es viel bequemer, die Variationen von ResetEvent und deren Slim-Versionen zu verwenden.  Wir werden etwas später darüber sprechen. <br><br>  Wahrscheinlich würden einige Leser vorschlagen, das Problem zu lösen, dass ein Kern vollständig mit dem Warten beschäftigt ist, indem Thread.Sleep (1) (oder ähnliches) zum Zyklus hinzugefügt wird.  Während dieses Problem behoben wird, wird ein neues erstellt. Die Reaktionszeit auf Änderungen beträgt jetzt durchschnittlich 0,5 ms.  Einerseits ist es nicht so viel, andererseits ist dieser Wert katastrophal höher als das, was wir mit Synchronisationsprimitiven der ResetEvent-Familie erreichen können. <br><a name="ThreadStarvation"></a><br><h3>  Fadenhunger </h3><br>  Thread Starvation ist ein Problem mit dem Programm, das zu viele gleichzeitig arbeitende Threads hat.  Hier geht es speziell um die Threads, die mit der Berechnung beschäftigt sind, anstatt auf die Antwort einer E / A zu warten.  Mit diesem Problem verlieren wir alle möglichen Leistungsvorteile, die mit Threads einhergehen, da der Prozessor viel Zeit für das Wechseln von Kontexten benötigt. <br><br>  Sie können solche Probleme mithilfe verschiedener Profiler finden.  Das Folgende ist ein Screenshot des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotTrace-</a> Profilers, der im Timeline-Modus arbeitet <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(zum Vergrößern anklicken).</i> <br><br>  Normalerweise haben Programme, die nicht unter dem Thread-Hunger leiden, keine rosa Abschnitte in den Diagrammen, die die Threads darstellen.  Darüber hinaus können wir in der Kategorie Subsysteme sehen, dass das Programm 30,6% der Zeit auf die CPU gewartet hat. <br><br>  Wenn ein solches Problem diagnostiziert wird, können Sie es ganz einfach beheben: Sie haben zu viele Threads gleichzeitig gestartet, also starten Sie einfach weniger Threads. <br><a name="SyncPrimitives"></a><br><h2>  Synchronisationsmethoden </h2><br><a name="Interlocked"></a><br><h3>  Verriegelt </h3><br>  Dies ist wahrscheinlich die leichteste Synchronisationsmethode.  Interlocked ist eine Reihe einfacher atomarer Operationen.  Wenn eine atomare Operation ausgeführt wird, kann nichts passieren.  In .NET wird Interlocked durch die gleichnamige statische Klasse mit einer Auswahl von Methoden dargestellt, von denen jede eine atomare Operation implementiert. <br><br>  Versuchen Sie, ein Programm zu schreiben, das 10 Threads startet, von denen jeder dieselbe Variable millionenfach erhöht, um den ultimativen Horror nichtatomarer Operationen zu erkennen.  Wenn sie mit ihrer Arbeit fertig sind, geben Sie den Wert dieser Variablen aus.  Leider wird es stark von 10 Millionen abweichen.  Außerdem ist es jedes Mal anders, wenn Sie das Programm ausführen.  Dies geschieht, weil selbst eine so einfache Operation wie das Inkrement keine atomare ist und die Wertextraktion aus dem Speicher, die Berechnung eines neuen Werts und das erneute Schreiben in den Speicher umfasst.  Zwei Threads können also jede dieser Operationen ausführen, und in diesem Fall geht ein Inkrement verloren. <br><br>  Die Interlocked-Klasse bietet die Increment / Decrement-Methoden, und es ist nicht schwer zu erraten, was sie tun sollen.  Sie sind sehr praktisch, wenn Sie Daten in mehreren Threads verarbeiten und etwas berechnen.  Ein solcher Code funktioniert viel schneller als das klassische Schloss.  Wenn wir Interlocked in der im vorherigen Absatz beschriebenen Situation verwenden würden, würde das Programm in jedem Szenario zuverlässig einen Wert von 10 Millionen erzeugen. <br><br>  Die Funktion der CompareExchange-Methode ist nicht so offensichtlich.  Seine Existenz ermöglicht jedoch die Implementierung vieler interessanter Algorithmen.  Am wichtigsten sind diejenigen aus der Familie ohne Schlösser. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Diese Methode nimmt drei Werte an.  Der erste Wert wird durch eine Referenz geleitet, und dieser Wert wird in den zweiten Wert geändert, wenn Position1 gleich Vergleich ist, und wenn der Vergleich durchgeführt wird.  Der ursprüngliche Wert von location1 wird zurückgegeben.  Das klingt kompliziert, daher ist es einfacher, einen Code zu schreiben, der dieselben Vorgänge wie CompareExchange ausführt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Der einzige Unterschied besteht darin, dass die Interlocked-Klasse dies auf atomare Weise implementiert.  Wenn wir diesen Code selbst schreiben würden, könnten wir uns einem Szenario stellen, in dem die Bedingung location1 == compareand bereits erfüllt ist.  Wenn jedoch die Anweisung location1 = value ausgeführt wird, hat ein anderer Thread den Wert location1 bereits geändert, sodass er verloren geht. <br><br>  Wir finden ein gutes Beispiel dafür, wie diese Methode in dem Code verwendet werden kann, den der Compiler für jedes C # -Ereignis generiert. <br><br>  Schreiben wir eine einfache Klasse mit einem Ereignis namens MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Lassen Sie uns nun das Projekt in der Release-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und den Build über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotPeek</a> mit aktivierter Option " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom</a> Compiler generierten Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> " öffnen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Hier können wir sehen, dass der Compiler hinter den Kulissen einen ziemlich komplexen Algorithmus generiert hat.  Dieser Algorithmus verhindert, dass wir ein Abonnement für das Ereignis verlieren, bei dem einige Threads gleichzeitig dieses Ereignis abonniert haben.  Lassen Sie uns die Methode add näher erläutern und dabei berücksichtigen, was die CompareExchange-Methode hinter den Kulissen tut: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Dies ist viel einfacher zu handhaben, erfordert aber wahrscheinlich noch eine Erklärung.  So würde ich den Algorithmus beschreiben: <br><br>  <i>Wenn MyEvent immer noch das gleiche ist wie zu dem Zeitpunkt, als wir mit der Ausführung von Delegate.Combine begonnen haben, setzen Sie es auf das, was Delegate.Combine zurückgibt.</i>  <i>Wenn dies nicht der Fall ist, versuchen Sie es erneut, bis es funktioniert.</i> <br><br>  Auf diese Weise gehen Abonnements niemals verloren.  Sie müssen ein ähnliches Problem lösen, wenn Sie ein dynamisches, threadsicheres und sperrfreies Array implementieren möchten.  Wenn plötzlich mehrere Threads Elemente zu diesem Array hinzufügen, ist es wichtig, dass alle diese Elemente erfolgreich hinzugefügt werden. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, sperren </h3><br>  Diese Konstruktionen werden am häufigsten für die Thread-Synchronisation verwendet.  Sie implementieren das Konzept eines kritischen Abschnitts: Das heißt, der zwischen den Aufrufen von Monitor.Enter und Monitor.Exit geschriebene Code kann nur von einem Thread zu einem bestimmten Zeitpunkt auf einer Ressource ausgeführt werden.  Der Sperroperator dient als Syntaxzucker für die in try-finally eingeschlossenen Enter / Exit-Aufrufe.  Eine angenehme Eigenschaft des kritischen Abschnitts in .NET ist, dass er den Wiedereintritt unterstützt.  Dies bedeutet, dass der folgende Code ohne echte Probleme ausgeführt werden kann: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es ist unwahrscheinlich, dass jemand genau so schreibt. Wenn Sie diesen Code jedoch auf einige Methoden in der Tiefe des Aufrufstapels verteilen, können Sie mit dieser Funktion einige IFs sparen.  Damit dieser Trick funktioniert, mussten die Entwickler von .NET eine Einschränkung hinzufügen: Sie können nur Instanzen von Referenztypen als Synchronisationsobjekt verwenden, und jedem Objekt, in das die Thread-ID geschrieben wird, werden einige Bytes hinzugefügt. <br><br>  Diese Besonderheit des Arbeitsprozesses des kritischen Abschnitts in C # führt zu einer interessanten Einschränkung für den Sperroperator: Sie können den Operator await nicht innerhalb des Sperroperators verwenden.  Das hat mich zunächst überrascht, da eine ähnliche Try-finally-Monitor.Enter / Exit-Konstruktion kompiliert werden kann.  Was ist los?  Es ist wichtig, den vorherigen Absatz erneut zu lesen und einige Kenntnisse über die Funktionsweise von async / await anzuwenden: Der Code nach dem Warten wird nicht im selben Thread wie der Code vor dem Warten ausgeführt.  Dies hängt vom Synchronisationskontext ab und davon, ob die ConfigureAwait-Methode aufgerufen wird oder nicht.  Daraus folgt, dass Monitor.Exit möglicherweise auf einem anderen Thread als Monitor.Enter ausgeführt wird, was dazu führt, dass SynchronizationLockException ausgelöst wird.  Wenn Sie mir nicht glauben, versuchen Sie, den folgenden Code in einer Konsolenanwendung auszuführen. Dadurch wird eine <b>SynchronizationLockException</b> generiert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Es ist erwähnenswert, dass in einer WinForms- oder WPF-Anwendung dieser Code korrekt funktioniert, wenn Sie ihn vom Hauptthread aus aufrufen, da es einen Synchronisationskontext gibt, der die Rückkehr zum UI-Thread nach dem Aufruf von wait implementiert.  In jedem Fall ist es besser, nicht mit kritischen Abschnitten im Kontext eines Codes herumzuspielen, der den Operator await enthält.  In solchen Beispielen ist es besser, Synchronisationsprimitive zu verwenden, die wir uns etwas später ansehen werden. <br><br>  Während wir uns mit kritischen Abschnitten in .NET befassen, ist es wichtig, eine weitere Besonderheit der Implementierung zu erwähnen.  Ein kritischer Abschnitt in .NET funktioniert in zwei Modi: Spin-Wait und Core-Wait.  Wir können den Spin-Wait-Algorithmus wie den folgenden Pseudocode darstellen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Diese Optimierung zielt darauf ab, einen kritischen Abschnitt so schnell wie möglich in kurzer Zeit zu erfassen, auf der Grundlage, dass die Ressource, selbst wenn sie derzeit belegt ist, sehr bald freigegeben wird.  Wenn dies nicht in kurzer Zeit geschieht, wechselt der Thread zum Warten im Kernmodus, was einige Zeit in Anspruch nimmt - genauso wie das Zurückkehren vom Warten.  Die Entwickler von .NET haben das Szenario der kurzen Blöcke so weit wie möglich optimiert.  Wenn viele Threads anfangen, den kritischen Abschnitt zwischen sich zu ziehen, kann dies leider zu einer plötzlichen hohen Belastung der CPU führen. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Nachdem bereits der zyklische Wartealgorithmus (Spin-Wait) erwähnt wurde, lohnt es sich, über die SpinLock- und SpinWait-Strukturen von BCL zu sprechen.  Sie sollten sie verwenden, wenn Grund zu der Annahme besteht, dass es immer möglich ist, einen Block sehr schnell zu erhalten.  Auf der anderen Seite sollten Sie nicht wirklich darüber nachdenken, bis die Profilerstellungsergebnisse zeigen, dass der Engpass Ihres Programms durch die Verwendung anderer Synchronisationsprimitive verursacht wird. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Alle] </h3><br>  Wir sollten diese beiden Methoden nebeneinander betrachten.  Mit ihrer Hilfe können Sie verschiedene Producer-Consumer-Szenarien implementieren. <br><br>  Producer-Consumer ist ein Muster eines Multi-Prozess- / Multi-Threaded-Designs, das einen oder mehrere Threads / Prozesse impliziert, die Daten erzeugen, und einen oder mehrere Prozesse / Threads, die diese Daten verarbeiten.  Normalerweise wird eine gemeinsam genutzte Sammlung verwendet. <br><br>  Beide Methoden können nur von einem Thread aufgerufen werden, der derzeit einen Block hat.  Die Wait-Methode gibt den Block frei und friert ein, bis ein anderer Thread Pulse aufruft. <br><br>  Als Demonstration dafür habe ich ein kleines Beispiel geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Ich habe hier eher ein Bild als einen Text verwendet, um die Reihenfolge der Befehlsausführung genau anzuzeigen.)</i> <br>  <b>Erläuterung:</b> Ich habe beim Starten des zweiten Threads eine Latenz von 100 ms festgelegt, um sicherzustellen, dass er später ausgeführt wird. <br>  - T1: Zeile 2 der Thread wird gestartet <br>  - T1: Zeile 3 Der Thread tritt in einen kritischen Abschnitt ein <br>  - T1: Zeile 6, in der der Thread in den Ruhezustand wechselt <br>  - T2: Zeile 3 der Thread wird gestartet <br>  - T2: Zeile 4 friert ein und wartet auf den kritischen Abschnitt <br>  - T1: Zeile 7 lässt den kritischen Abschnitt los und friert ein, während darauf gewartet wird, dass Pulse herauskommt <br>  - T2: Zeile 8 tritt in den kritischen Abschnitt ein <br>  - T2: Zeile 11 signalisiert T1 mit Hilfe von Pulse <br>  - T2: Zeile 14 kommt aus dem kritischen Abschnitt.  T1 kann seine Ausführung nicht fortsetzen, bevor dies geschieht. <br>  - T1: Zeile 15 kommt aus dem Warten heraus <br>  - T1: Zeile 16 kommt aus dem kritischen Abschnitt heraus <br><br>  <i>In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> gibt es eine wichtige Bemerkung zur Verwendung der Pulse / Wait-Methoden: Monitor speichert keine Statusinformationen, was bedeutet, dass das Aufrufen der Pulse-Methode vor der Wait-Methode zu einem Deadlock führen kann.</i>  <i>Wenn ein solcher Fall möglich ist, ist es besser, eine der Klassen aus der ResetEvent-Familie zu verwenden.</i> <br><br>  Das vorige Beispiel zeigt deutlich, wie die Wait / Pulse-Methoden der Monitor-Klasse funktionieren, lässt jedoch noch einige Fragen zu den Fällen offen, in denen wir sie verwenden sollten.  Ein gutes Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> von BlockingQueue &lt;T&gt;.  Andererseits verwendet die Implementierung von BlockingCollection &lt;T&gt; aus System.Collections.Concurrent SemaphoreSlim für die Synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Ich liebe dieses Synchronisationsprimitiv sehr und es wird durch die gleichnamige Klasse aus dem System.Threading-Namespace dargestellt.  Ich denke, dass viele Programme viel besser funktionieren würden, wenn ihre Entwickler diese Klasse anstelle der Standardsperre verwenden würden. <br><br>  Idee: Viele Threads können lesen und der einzige kann schreiben.  Wenn ein Thread schreiben möchte, können keine neuen Lesevorgänge gestartet werden - sie warten auf das Schreiben bis zum Ende.  Es gibt auch das Upgrade-Read-Lock-Konzept.  Sie können es verwenden, wenn Sie während des Lesevorgangs verstehen, dass etwas geschrieben werden muss - eine solche Sperre wird in einer atomaren Operation in eine Schreibsperre umgewandelt. <br><br>  Im System.Threading-Namespace gibt es auch die ReadWriteLock-Klasse, es wird jedoch dringend empfohlen, sie nicht für Neuentwicklungen zu verwenden.  Die Slim-Version hilft dabei, Fälle zu vermeiden, die zu Deadlocks führen, und ermöglicht die schnelle Erfassung eines Blocks, da sie die Synchronisation im Spin-Wait-Modus unterstützt, bevor Sie in den Core-Modus wechseln. <br><br>  Wenn Sie vor dem Lesen dieses Artikels nichts über diese Klasse gewusst haben, haben Sie sich inzwischen an viele Beispiele aus dem kürzlich geschriebenen Code erinnert, in denen dieser Ansatz für Blöcke es dem Programm ermöglichte, effektiv zu arbeiten. <br><br>  Die Oberfläche der ReaderWriterLockSlim-Klasse ist einfach und leicht zu verstehen, aber nicht so benutzerfreundlich: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Normalerweise wickle ich es gerne in eine Klasse ein - das macht es viel handlicher. <br><br>  <i><b>Idee:</b> Erstellen Sie Read / WriteLock-Methoden, die zusammen mit der Dispose-Methode ein Objekt zurückgeben.</i>  <i>Sie können dann unter Verwenden auf sie zugreifen, und es wird wahrscheinlich nicht zu sehr von der Standardsperre abweichen, wenn es um die Anzahl der Zeilen geht.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Dies ermöglicht es uns, später im Code Folgendes zu schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  Die ResetEvent-Familie </h3><br>  Ich füge die folgenden Klassen in diese Familie ein: ManualResetEvent, ManualResetEventSlim und AutoResetEvent. <br><br>  Die ManualResetEvent-Klasse, ihre Slim-Version und die AutoResetEvent-Klasse können in zwei Zuständen existieren: <br><br>  - Nicht signalisiert - In diesem Zustand frieren alle Threads, die WaitOne aufgerufen haben, ein, bis das Ereignis in einen signalisierten Zustand wechselt. <br>  - Signalisiert - In diesem Zustand werden alle Threads freigegeben, die zuvor bei einem WaitOne-Aufruf eingefroren wurden.  Alle neuen WaitOne-Aufrufe eines signalisierten Ereignisses werden relativ sofort ausgeführt. <br><br>  AutoResetEvent unterscheidet sich von ManualResetEvent dadurch, dass es automatisch in den nicht signalisierten Zustand wechselt, nachdem <b>genau ein Thread</b> freigegeben wurde.  Wenn einige Threads eingefroren sind, während auf AutoResetEvent gewartet wird, wird beim Aufrufen von Set nur ein zufälliger Thread freigegeben, im Gegensatz zu ManualResetEvent, bei dem alle Threads freigegeben werden. <br><br>  Schauen wir uns ein Beispiel für die Funktionsweise von AutoResetEvent an: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  In diesen Beispielen können wir sehen, dass das Ereignis erst automatisch in den nicht signalisierten Zustand wechselt, nachdem der Thread freigegeben wurde, der bei einem WaitOne-Aufruf eingefroren wurde. <br><br>  Im Gegensatz zu ReaderWriterLock gilt ManualResetEvent auch nach Erscheinen der Slim-Version nicht als veraltet.  Diese schlanke Version der Klasse kann für kurze Wartezeiten wirksam sein, wie dies im Spin-Wait-Modus der Fall ist.  Die Standardversion ist gut für lange Wartezeiten. <br><br>  Neben den Klassen ManualResetEvent und AutoResetEvent gibt es auch die Klasse CountdownEvent.  Diese Klasse ist sehr nützlich für die Implementierung von Algorithmen, die Ergebnisse nach einem parallelen Abschnitt zusammenführen.  Dieser Ansatz wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fork-Join bezeichnet</a> .  Es gibt einen großartigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu dieser Klasse, daher werde ich ihn hier nicht im Detail beschreiben. <br><a name="Conclusions"></a><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der Arbeit mit Threads gibt es zwei Probleme, die zu falschen Ergebnissen oder sogar zum Fehlen von Ergebnissen führen können - Race Condition und Deadlock. </li><li>  Probleme, die dazu führen können, dass das Programm mehr Zeit oder Ressourcen verbringt, sind Thread-Hunger und beschäftigtes Warten. </li><li>  .NET bietet viele Möglichkeiten zum Synchronisieren von Threads. </li><li>  Es gibt zwei Arten von Blockwartezeiten - Spin Wait und Core Wait.  Einige Thread-Synchronisationsprimitive in .NET verwenden beide. </li><li>  Interlocked ist eine Reihe von atomaren Operationen, mit denen sperrfreie Algorithmen implementiert werden können.  Es ist das schnellste Synchronisationsprimitiv. </li><li>  Die Operatoren lock und Monitor. Enter / Exit implementieren das Konzept eines kritischen Abschnitts - eines Codefragments, das nur von einem Thread zu einem bestimmten Zeitpunkt ausgeführt werden kann. </li><li>  Die Monitor.Pulse / Wait-Methoden sind nützlich für die Implementierung von Producer-Consumer-Szenarien. </li><li>  ReaderWriterLockSlim kann nützlicher sein als die Standard-Sperrfälle, wenn paralleles Lesen erwartet wird. </li><li>  Die ResetEvent-Klassenfamilie kann für die Thread-Synchronisierung hilfreich sein. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461471/">https://habr.com/ru/post/de461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461461/index.html">Backup gedeiht im Cloud-Zeitalter, aber Bandspulen werden nicht vergessen. Gespräch mit Veeam</a></li>
<li><a href="../de461463/index.html">Geschäftsprozesse in Unternehmen: Spekulation und Realität. Licht mit R.</a></li>
<li><a href="../de461465/index.html">Messanleitung</a></li>
<li><a href="../de461467/index.html">Ein Beispiel für das Erstellen eines Makefile für Go-Anwendungen</a></li>
<li><a href="../de461469/index.html">Wie ist es, Code mit 1000 Wörtern pro Minute zu hören?</a></li>
<li><a href="../de461473/index.html">Debugging-Algorithmen für Grafiken - jetzt mit Bildern</a></li>
<li><a href="../de461475/index.html">AMA mit Habr. 1011</a></li>
<li><a href="../de461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../de461487/index.html">Mini-CTF-Aufgaben</a></li>
<li><a href="../de461493/index.html">Django 3.0 wird asynchron sein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>