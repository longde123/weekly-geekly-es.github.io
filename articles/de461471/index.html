<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¶ üôèüèª üöª .NET - Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 2 üôáüèº üôÜüèΩ üë©üèº‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe diesen Artikel urspr√ºnglich im CodingSight- Blog ver√∂ffentlicht. 
 Es ist hier auch in russischer Sprache erh√§ltlich. 

 Dieser Artikel enth√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET - Tools zum Arbeiten mit Multithreading und Asynchronit√§t - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Ich habe diesen Artikel urspr√ºnglich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodingSight-</a> Blog ver√∂ffentlicht.</i> <i><br></i>  <i>Es ist hier auch in russischer Sprache erh√§ltlich.</i> <br><br>  Dieser Artikel enth√§lt den zweiten Teil meiner Rede beim Multithreading-Treffen.  Den ersten Teil k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ansehen.  Im ersten Teil konzentrierte ich mich auf die grundlegenden Tools zum Starten eines Threads oder einer Aufgabe, auf die M√∂glichkeiten, ihren Status zu verfolgen, und auf einige zus√§tzliche n√ºtzliche Dinge wie PLinq.  In diesem Teil werde ich die Probleme beheben, die in einer Multithread-Umgebung auftreten k√∂nnen, sowie einige M√∂glichkeiten, sie zu beheben. <br><br><h2>  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In Bezug auf gemeinsam genutzte Ressourcen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√∂gliche Probleme in Multithread-Umgebungen</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rennbedingung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besch√§ftigt warten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fadenhunger</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synchronisationsmethoden</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verriegelt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Enter, Monitor.Exit, sperren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monitor.Wait, Monitor.Pulse [Alle]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ResetEvent-Familie</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlussfolgerungen</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  In Bezug auf gemeinsam genutzte Ressourcen </h2><br>  Sie k√∂nnen kein Programm schreiben, das auf mehreren Threads basiert, ohne √ºber gemeinsam genutzte Ressourcen zu verf√ºgen.  Selbst wenn es auf Ihrer aktuellen Abstraktionsebene funktioniert, werden Sie feststellen, dass es tats√§chlich √ºber gemeinsam genutzte Ressourcen verf√ºgt, sobald Sie eine oder mehrere Abstraktionsebenen herunterfahren.  Hier einige Beispiele: <br><br>  <b>Beispiel 1:</b> <br><br>  Um m√∂gliche Probleme zu vermeiden, lassen Sie die Threads mit verschiedenen Dateien arbeiten, eine Datei f√ºr jeden Thread.  Es scheint Ihnen, dass das Programm keinerlei gemeinsame Ressourcen hat. <br><br>  Wenn Sie ein paar Ebenen tiefer gehen, werden Sie feststellen, dass es nur eine Festplatte gibt und es Sache des Treibers oder des Betriebssystems ist, eine L√∂sung f√ºr Probleme mit dem Festplattenzugriff zu finden. <br><br>  <b>Beispiel 2:</b> <br><br>  Nachdem Sie <i>Beispiel 1</i> gelesen haben, haben Sie beschlossen, die Dateien auf zwei verschiedenen Remotecomputern mit physisch unterschiedlicher Hardware und Betriebssystemen abzulegen.  Sie pflegen auch zwei verschiedene FTP- oder NFS-Verbindungen. <br><br>  Wenn Sie noch einmal ein paar Stufen tiefer gehen, haben Sie verstanden, dass sich nichts wirklich ge√§ndert hat, und das Problem des wettbewerbsf√§higen Zugriffs wird jetzt an den Netzwerkkartentreiber oder das Betriebssystem des Computers delegiert, auf dem das Programm ausgef√ºhrt wird. <br><br>  <b>Beispiel 3:</b> <br><br>  Nachdem Sie den gr√∂√üten Teil Ihrer Haare herausgezogen haben, um zu beweisen, dass Sie ein Multithread-Programm schreiben k√∂nnen, entscheiden Sie sich, die Dateien vollst√§ndig zu l√∂schen und die Berechnungen auf zwei verschiedene Objekte zu verschieben, wobei die Links zu jedem Objekt nur f√ºr das jeweilige Objekt verf√ºgbar sind F√§den. <br><br>  Um das letzte Dutzend N√§gel in den Sarg dieser Idee zu h√§mmern: Eine Laufzeit und ein Garbage Collector, ein Thread-Scheduler, physisch ein einheitlicher RAM und ein Prozessor gelten weiterhin als gemeinsam genutzte Ressourcen. <br><br>  Wir haben also gelernt, dass es unm√∂glich ist, ein Multithread-Programm ohne gemeinsam genutzte Ressourcen auf allen Abstraktionsebenen und im gesamten Umfang des Technologie-Stacks zu schreiben.  Gl√ºcklicherweise k√ºmmert sich jede Abstraktionsebene (in der Regel) teilweise oder sogar vollst√§ndig um die Probleme des Wettbewerbszugriffs oder verweigert sie einfach sofort (Beispiel: Jedes UI-Framework erlaubt nicht die Arbeit mit Elementen aus verschiedenen Threads).  Daher treten die Probleme mit gemeinsam genutzten Ressourcen normalerweise auf Ihrer aktuellen Abstraktionsebene auf.  Um sich um sie zu k√ºmmern, wird das Konzept der Synchronisation eingef√ºhrt. <br><a name="Problems"></a><br><h2>  M√∂gliche Probleme in Multithread-Umgebungen </h2><br>  Wir k√∂nnen Softwarefehler in die folgenden Kategorien einteilen: <br><ol><li>  Das Programm liefert kein Ergebnis - es st√ºrzt ab oder friert ein. </li><li>  Das Programm liefert ein falsches Ergebnis. </li><li>  Das Programm liefert ein korrektes Ergebnis, erf√ºllt jedoch einige nicht funktionsbezogene Anforderungen nicht - es verbraucht zu viel Zeit oder Ressourcen. </li></ol><br>  In Umgebungen mit mehreren Threads sind die Hauptprobleme, die zu den Fehlern Nr. 1 und Nr. 2 f√ºhren, <b>Deadlock</b> und <b>Race Condition</b> . <br><br><a name="Deadlock"></a><br><h3>  Deadlock </h3><br>  Deadlock ist ein gegenseitiger Block.  Es gibt viele Variationen eines Deadlocks.  Das folgende kann als das h√§ufigste angesehen werden: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  W√§hrend <b>Thread 1</b> etwas tat, blockierte <b>Thread 2</b> Ressource <b>B.</b>  <b>Einige Zeit</b> sp√§ter blockierte <b>Thread 1</b> Ressource <b>A</b> und versuchte, Ressource B zu blockieren. Leider wird dies nie passieren, da <b>Thread 2</b> Ressource <b>B erst</b> nach dem Blockieren von Ressource <b>A</b> losl√§sst <b>.</b> <br><a name="RaceCondition"></a><br><h3>  Rennbedingung </h3><br>  Race-Condition ist eine Situation, in der sowohl das Verhalten als auch die Ergebnisse der Berechnungen vom Thread-Scheduler der Ausf√ºhrungsumgebung abh√§ngen <br><br>  Das Problem ist, dass Ihr Programm einmal in hundert oder sogar in einer Million nicht richtig funktioniert. <br><br>  Die Dinge k√∂nnen schlimmer werden, wenn Probleme zu dritt auftreten.  Beispielsweise kann das spezifische Verhalten des Thread-Schedulers zu einem gegenseitigen Deadlock f√ºhren. <br><br>  Zus√§tzlich zu diesen beiden Problemen, die zu expliziten Fehlern f√ºhren, gibt es auch Probleme, die, wenn sie nicht zu falschen Berechnungsergebnissen f√ºhren, dazu f√ºhren k√∂nnen, dass das Programm viel mehr Zeit oder Ressourcen ben√∂tigt, um das gew√ºnschte Ergebnis zu erzielen.  Zwei dieser Probleme sind <b>Busy Wait</b> und <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Besch√§ftigt warten </h3><br>  Busy Wait ist ein Problem, das auftritt, wenn das Programm Prozessorressourcen eher f√ºr das Warten als f√ºr die Berechnung ausgibt. <br><br>  In der Regel sieht dieses Problem folgenderma√üen aus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Dies ist ein Beispiel f√ºr einen extrem schlechten Code, da er einen Kern Ihres Prozessors vollst√§ndig belegt und √ºberhaupt nichts Produktives tut.  Ein solcher Code kann nur gerechtfertigt werden, wenn es von entscheidender Bedeutung ist, eine √Ñnderung eines Werts in einem anderen Thread schnell zu verarbeiten.  Und mit "schnell" meine ich, dass Sie nicht einmal ein paar Nanosekunden warten k√∂nnen.  In allen anderen F√§llen, dh in allen F√§llen, in denen sich ein vern√ºnftiger Verstand einfallen lassen kann, ist es viel bequemer, die Variationen von ResetEvent und deren Slim-Versionen zu verwenden.  Wir werden etwas sp√§ter dar√ºber sprechen. <br><br>  Wahrscheinlich w√ºrden einige Leser vorschlagen, das Problem zu l√∂sen, dass ein Kern vollst√§ndig mit dem Warten besch√§ftigt ist, indem Thread.Sleep (1) (oder √§hnliches) zum Zyklus hinzugef√ºgt wird.  W√§hrend dieses Problem behoben wird, wird ein neues erstellt. Die Reaktionszeit auf √Ñnderungen betr√§gt jetzt durchschnittlich 0,5 ms.  Einerseits ist es nicht so viel, andererseits ist dieser Wert katastrophal h√∂her als das, was wir mit Synchronisationsprimitiven der ResetEvent-Familie erreichen k√∂nnen. <br><a name="ThreadStarvation"></a><br><h3>  Fadenhunger </h3><br>  Thread Starvation ist ein Problem mit dem Programm, das zu viele gleichzeitig arbeitende Threads hat.  Hier geht es speziell um die Threads, die mit der Berechnung besch√§ftigt sind, anstatt auf die Antwort einer E / A zu warten.  Mit diesem Problem verlieren wir alle m√∂glichen Leistungsvorteile, die mit Threads einhergehen, da der Prozessor viel Zeit f√ºr das Wechseln von Kontexten ben√∂tigt. <br><br>  Sie k√∂nnen solche Probleme mithilfe verschiedener Profiler finden.  Das Folgende ist ein Screenshot des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotTrace-</a> Profilers, der im Timeline-Modus arbeitet <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(zum Vergr√∂√üern anklicken).</i> <br><br>  Normalerweise haben Programme, die nicht unter dem Thread-Hunger leiden, keine rosa Abschnitte in den Diagrammen, die die Threads darstellen.  Dar√ºber hinaus k√∂nnen wir in der Kategorie Subsysteme sehen, dass das Programm 30,6% der Zeit auf die CPU gewartet hat. <br><br>  Wenn ein solches Problem diagnostiziert wird, k√∂nnen Sie es ganz einfach beheben: Sie haben zu viele Threads gleichzeitig gestartet, also starten Sie einfach weniger Threads. <br><a name="SyncPrimitives"></a><br><h2>  Synchronisationsmethoden </h2><br><a name="Interlocked"></a><br><h3>  Verriegelt </h3><br>  Dies ist wahrscheinlich die leichteste Synchronisationsmethode.  Interlocked ist eine Reihe einfacher atomarer Operationen.  Wenn eine atomare Operation ausgef√ºhrt wird, kann nichts passieren.  In .NET wird Interlocked durch die gleichnamige statische Klasse mit einer Auswahl von Methoden dargestellt, von denen jede eine atomare Operation implementiert. <br><br>  Versuchen Sie, ein Programm zu schreiben, das 10 Threads startet, von denen jeder dieselbe Variable millionenfach erh√∂ht, um den ultimativen Horror nichtatomarer Operationen zu erkennen.  Wenn sie mit ihrer Arbeit fertig sind, geben Sie den Wert dieser Variablen aus.  Leider wird es stark von 10 Millionen abweichen.  Au√üerdem ist es jedes Mal anders, wenn Sie das Programm ausf√ºhren.  Dies geschieht, weil selbst eine so einfache Operation wie das Inkrement keine atomare ist und die Wertextraktion aus dem Speicher, die Berechnung eines neuen Werts und das erneute Schreiben in den Speicher umfasst.  Zwei Threads k√∂nnen also jede dieser Operationen ausf√ºhren, und in diesem Fall geht ein Inkrement verloren. <br><br>  Die Interlocked-Klasse bietet die Increment / Decrement-Methoden, und es ist nicht schwer zu erraten, was sie tun sollen.  Sie sind sehr praktisch, wenn Sie Daten in mehreren Threads verarbeiten und etwas berechnen.  Ein solcher Code funktioniert viel schneller als das klassische Schloss.  Wenn wir Interlocked in der im vorherigen Absatz beschriebenen Situation verwenden w√ºrden, w√ºrde das Programm in jedem Szenario zuverl√§ssig einen Wert von 10 Millionen erzeugen. <br><br>  Die Funktion der CompareExchange-Methode ist nicht so offensichtlich.  Seine Existenz erm√∂glicht jedoch die Implementierung vieler interessanter Algorithmen.  Am wichtigsten sind diejenigen aus der Familie ohne Schl√∂sser. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Diese Methode nimmt drei Werte an.  Der erste Wert wird durch eine Referenz geleitet, und dieser Wert wird in den zweiten Wert ge√§ndert, wenn Position1 gleich Vergleich ist, und wenn der Vergleich durchgef√ºhrt wird.  Der urspr√ºngliche Wert von location1 wird zur√ºckgegeben.  Das klingt kompliziert, daher ist es einfacher, einen Code zu schreiben, der dieselben Vorg√§nge wie CompareExchange ausf√ºhrt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Der einzige Unterschied besteht darin, dass die Interlocked-Klasse dies auf atomare Weise implementiert.  Wenn wir diesen Code selbst schreiben w√ºrden, k√∂nnten wir uns einem Szenario stellen, in dem die Bedingung location1 == compareand bereits erf√ºllt ist.  Wenn jedoch die Anweisung location1 = value ausgef√ºhrt wird, hat ein anderer Thread den Wert location1 bereits ge√§ndert, sodass er verloren geht. <br><br>  Wir finden ein gutes Beispiel daf√ºr, wie diese Methode in dem Code verwendet werden kann, den der Compiler f√ºr jedes C # -Ereignis generiert. <br><br>  Schreiben wir eine einfache Klasse mit einem Ereignis namens MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Lassen Sie uns nun das Projekt in der Release-Konfiguration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und den Build √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotPeek</a> mit aktivierter Option " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom</a> Compiler generierten Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> " √∂ffnen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Hier k√∂nnen wir sehen, dass der Compiler hinter den Kulissen einen ziemlich komplexen Algorithmus generiert hat.  Dieser Algorithmus verhindert, dass wir ein Abonnement f√ºr das Ereignis verlieren, bei dem einige Threads gleichzeitig dieses Ereignis abonniert haben.  Lassen Sie uns die Methode add n√§her erl√§utern und dabei ber√ºcksichtigen, was die CompareExchange-Methode hinter den Kulissen tut: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Dies ist viel einfacher zu handhaben, erfordert aber wahrscheinlich noch eine Erkl√§rung.  So w√ºrde ich den Algorithmus beschreiben: <br><br>  <i>Wenn MyEvent immer noch das gleiche ist wie zu dem Zeitpunkt, als wir mit der Ausf√ºhrung von Delegate.Combine begonnen haben, setzen Sie es auf das, was Delegate.Combine zur√ºckgibt.</i>  <i>Wenn dies nicht der Fall ist, versuchen Sie es erneut, bis es funktioniert.</i> <br><br>  Auf diese Weise gehen Abonnements niemals verloren.  Sie m√ºssen ein √§hnliches Problem l√∂sen, wenn Sie ein dynamisches, threadsicheres und sperrfreies Array implementieren m√∂chten.  Wenn pl√∂tzlich mehrere Threads Elemente zu diesem Array hinzuf√ºgen, ist es wichtig, dass alle diese Elemente erfolgreich hinzugef√ºgt werden. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, sperren </h3><br>  Diese Konstruktionen werden am h√§ufigsten f√ºr die Thread-Synchronisation verwendet.  Sie implementieren das Konzept eines kritischen Abschnitts: Das hei√üt, der zwischen den Aufrufen von Monitor.Enter und Monitor.Exit geschriebene Code kann nur von einem Thread zu einem bestimmten Zeitpunkt auf einer Ressource ausgef√ºhrt werden.  Der Sperroperator dient als Syntaxzucker f√ºr die in try-finally eingeschlossenen Enter / Exit-Aufrufe.  Eine angenehme Eigenschaft des kritischen Abschnitts in .NET ist, dass er den Wiedereintritt unterst√ºtzt.  Dies bedeutet, dass der folgende Code ohne echte Probleme ausgef√ºhrt werden kann: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es ist unwahrscheinlich, dass jemand genau so schreibt. Wenn Sie diesen Code jedoch auf einige Methoden in der Tiefe des Aufrufstapels verteilen, k√∂nnen Sie mit dieser Funktion einige IFs sparen.  Damit dieser Trick funktioniert, mussten die Entwickler von .NET eine Einschr√§nkung hinzuf√ºgen: Sie k√∂nnen nur Instanzen von Referenztypen als Synchronisationsobjekt verwenden, und jedem Objekt, in das die Thread-ID geschrieben wird, werden einige Bytes hinzugef√ºgt. <br><br>  Diese Besonderheit des Arbeitsprozesses des kritischen Abschnitts in C # f√ºhrt zu einer interessanten Einschr√§nkung f√ºr den Sperroperator: Sie k√∂nnen den Operator await nicht innerhalb des Sperroperators verwenden.  Das hat mich zun√§chst √ºberrascht, da eine √§hnliche Try-finally-Monitor.Enter / Exit-Konstruktion kompiliert werden kann.  Was ist los?  Es ist wichtig, den vorherigen Absatz erneut zu lesen und einige Kenntnisse √ºber die Funktionsweise von async / await anzuwenden: Der Code nach dem Warten wird nicht im selben Thread wie der Code vor dem Warten ausgef√ºhrt.  Dies h√§ngt vom Synchronisationskontext ab und davon, ob die ConfigureAwait-Methode aufgerufen wird oder nicht.  Daraus folgt, dass Monitor.Exit m√∂glicherweise auf einem anderen Thread als Monitor.Enter ausgef√ºhrt wird, was dazu f√ºhrt, dass SynchronizationLockException ausgel√∂st wird.  Wenn Sie mir nicht glauben, versuchen Sie, den folgenden Code in einer Konsolenanwendung auszuf√ºhren. Dadurch wird eine <b>SynchronizationLockException</b> generiert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Es ist erw√§hnenswert, dass in einer WinForms- oder WPF-Anwendung dieser Code korrekt funktioniert, wenn Sie ihn vom Hauptthread aus aufrufen, da es einen Synchronisationskontext gibt, der die R√ºckkehr zum UI-Thread nach dem Aufruf von wait implementiert.  In jedem Fall ist es besser, nicht mit kritischen Abschnitten im Kontext eines Codes herumzuspielen, der den Operator await enth√§lt.  In solchen Beispielen ist es besser, Synchronisationsprimitive zu verwenden, die wir uns etwas sp√§ter ansehen werden. <br><br>  W√§hrend wir uns mit kritischen Abschnitten in .NET befassen, ist es wichtig, eine weitere Besonderheit der Implementierung zu erw√§hnen.  Ein kritischer Abschnitt in .NET funktioniert in zwei Modi: Spin-Wait und Core-Wait.  Wir k√∂nnen den Spin-Wait-Algorithmus wie den folgenden Pseudocode darstellen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Diese Optimierung zielt darauf ab, einen kritischen Abschnitt so schnell wie m√∂glich in kurzer Zeit zu erfassen, auf der Grundlage, dass die Ressource, selbst wenn sie derzeit belegt ist, sehr bald freigegeben wird.  Wenn dies nicht in kurzer Zeit geschieht, wechselt der Thread zum Warten im Kernmodus, was einige Zeit in Anspruch nimmt - genauso wie das Zur√ºckkehren vom Warten.  Die Entwickler von .NET haben das Szenario der kurzen Bl√∂cke so weit wie m√∂glich optimiert.  Wenn viele Threads anfangen, den kritischen Abschnitt zwischen sich zu ziehen, kann dies leider zu einer pl√∂tzlichen hohen Belastung der CPU f√ºhren. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Nachdem bereits der zyklische Wartealgorithmus (Spin-Wait) erw√§hnt wurde, lohnt es sich, √ºber die SpinLock- und SpinWait-Strukturen von BCL zu sprechen.  Sie sollten sie verwenden, wenn Grund zu der Annahme besteht, dass es immer m√∂glich ist, einen Block sehr schnell zu erhalten.  Auf der anderen Seite sollten Sie nicht wirklich dar√ºber nachdenken, bis die Profilerstellungsergebnisse zeigen, dass der Engpass Ihres Programms durch die Verwendung anderer Synchronisationsprimitive verursacht wird. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Alle] </h3><br>  Wir sollten diese beiden Methoden nebeneinander betrachten.  Mit ihrer Hilfe k√∂nnen Sie verschiedene Producer-Consumer-Szenarien implementieren. <br><br>  Producer-Consumer ist ein Muster eines Multi-Prozess- / Multi-Threaded-Designs, das einen oder mehrere Threads / Prozesse impliziert, die Daten erzeugen, und einen oder mehrere Prozesse / Threads, die diese Daten verarbeiten.  Normalerweise wird eine gemeinsam genutzte Sammlung verwendet. <br><br>  Beide Methoden k√∂nnen nur von einem Thread aufgerufen werden, der derzeit einen Block hat.  Die Wait-Methode gibt den Block frei und friert ein, bis ein anderer Thread Pulse aufruft. <br><br>  Als Demonstration daf√ºr habe ich ein kleines Beispiel geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Ich habe hier eher ein Bild als einen Text verwendet, um die Reihenfolge der Befehlsausf√ºhrung genau anzuzeigen.)</i> <br>  <b>Erl√§uterung:</b> Ich habe beim Starten des zweiten Threads eine Latenz von 100 ms festgelegt, um sicherzustellen, dass er sp√§ter ausgef√ºhrt wird. <br>  - T1: Zeile 2 der Thread wird gestartet <br>  - T1: Zeile 3 Der Thread tritt in einen kritischen Abschnitt ein <br>  - T1: Zeile 6, in der der Thread in den Ruhezustand wechselt <br>  - T2: Zeile 3 der Thread wird gestartet <br>  - T2: Zeile 4 friert ein und wartet auf den kritischen Abschnitt <br>  - T1: Zeile 7 l√§sst den kritischen Abschnitt los und friert ein, w√§hrend darauf gewartet wird, dass Pulse herauskommt <br>  - T2: Zeile 8 tritt in den kritischen Abschnitt ein <br>  - T2: Zeile 11 signalisiert T1 mit Hilfe von Pulse <br>  - T2: Zeile 14 kommt aus dem kritischen Abschnitt.  T1 kann seine Ausf√ºhrung nicht fortsetzen, bevor dies geschieht. <br>  - T1: Zeile 15 kommt aus dem Warten heraus <br>  - T1: Zeile 16 kommt aus dem kritischen Abschnitt heraus <br><br>  <i>In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> gibt es eine wichtige Bemerkung zur Verwendung der Pulse / Wait-Methoden: Monitor speichert keine Statusinformationen, was bedeutet, dass das Aufrufen der Pulse-Methode vor der Wait-Methode zu einem Deadlock f√ºhren kann.</i>  <i>Wenn ein solcher Fall m√∂glich ist, ist es besser, eine der Klassen aus der ResetEvent-Familie zu verwenden.</i> <br><br>  Das vorige Beispiel zeigt deutlich, wie die Wait / Pulse-Methoden der Monitor-Klasse funktionieren, l√§sst jedoch noch einige Fragen zu den F√§llen offen, in denen wir sie verwenden sollten.  Ein gutes Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> von BlockingQueue &lt;T&gt;.  Andererseits verwendet die Implementierung von BlockingCollection &lt;T&gt; aus System.Collections.Concurrent SemaphoreSlim f√ºr die Synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Ich liebe dieses Synchronisationsprimitiv sehr und es wird durch die gleichnamige Klasse aus dem System.Threading-Namespace dargestellt.  Ich denke, dass viele Programme viel besser funktionieren w√ºrden, wenn ihre Entwickler diese Klasse anstelle der Standardsperre verwenden w√ºrden. <br><br>  Idee: Viele Threads k√∂nnen lesen und der einzige kann schreiben.  Wenn ein Thread schreiben m√∂chte, k√∂nnen keine neuen Lesevorg√§nge gestartet werden - sie warten auf das Schreiben bis zum Ende.  Es gibt auch das Upgrade-Read-Lock-Konzept.  Sie k√∂nnen es verwenden, wenn Sie w√§hrend des Lesevorgangs verstehen, dass etwas geschrieben werden muss - eine solche Sperre wird in einer atomaren Operation in eine Schreibsperre umgewandelt. <br><br>  Im System.Threading-Namespace gibt es auch die ReadWriteLock-Klasse, es wird jedoch dringend empfohlen, sie nicht f√ºr Neuentwicklungen zu verwenden.  Die Slim-Version hilft dabei, F√§lle zu vermeiden, die zu Deadlocks f√ºhren, und erm√∂glicht die schnelle Erfassung eines Blocks, da sie die Synchronisation im Spin-Wait-Modus unterst√ºtzt, bevor Sie in den Core-Modus wechseln. <br><br>  Wenn Sie vor dem Lesen dieses Artikels nichts √ºber diese Klasse gewusst haben, haben Sie sich inzwischen an viele Beispiele aus dem k√ºrzlich geschriebenen Code erinnert, in denen dieser Ansatz f√ºr Bl√∂cke es dem Programm erm√∂glichte, effektiv zu arbeiten. <br><br>  Die Oberfl√§che der ReaderWriterLockSlim-Klasse ist einfach und leicht zu verstehen, aber nicht so benutzerfreundlich: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Normalerweise wickle ich es gerne in eine Klasse ein - das macht es viel handlicher. <br><br>  <i><b>Idee:</b> Erstellen Sie Read / WriteLock-Methoden, die zusammen mit der Dispose-Methode ein Objekt zur√ºckgeben.</i>  <i>Sie k√∂nnen dann unter Verwenden auf sie zugreifen, und es wird wahrscheinlich nicht zu sehr von der Standardsperre abweichen, wenn es um die Anzahl der Zeilen geht.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Dies erm√∂glicht es uns, sp√§ter im Code Folgendes zu schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  Die ResetEvent-Familie </h3><br>  Ich f√ºge die folgenden Klassen in diese Familie ein: ManualResetEvent, ManualResetEventSlim und AutoResetEvent. <br><br>  Die ManualResetEvent-Klasse, ihre Slim-Version und die AutoResetEvent-Klasse k√∂nnen in zwei Zust√§nden existieren: <br><br>  - Nicht signalisiert - In diesem Zustand frieren alle Threads, die WaitOne aufgerufen haben, ein, bis das Ereignis in einen signalisierten Zustand wechselt. <br>  - Signalisiert - In diesem Zustand werden alle Threads freigegeben, die zuvor bei einem WaitOne-Aufruf eingefroren wurden.  Alle neuen WaitOne-Aufrufe eines signalisierten Ereignisses werden relativ sofort ausgef√ºhrt. <br><br>  AutoResetEvent unterscheidet sich von ManualResetEvent dadurch, dass es automatisch in den nicht signalisierten Zustand wechselt, nachdem <b>genau ein Thread</b> freigegeben wurde.  Wenn einige Threads eingefroren sind, w√§hrend auf AutoResetEvent gewartet wird, wird beim Aufrufen von Set nur ein zuf√§lliger Thread freigegeben, im Gegensatz zu ManualResetEvent, bei dem alle Threads freigegeben werden. <br><br>  Schauen wir uns ein Beispiel f√ºr die Funktionsweise von AutoResetEvent an: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  In diesen Beispielen k√∂nnen wir sehen, dass das Ereignis erst automatisch in den nicht signalisierten Zustand wechselt, nachdem der Thread freigegeben wurde, der bei einem WaitOne-Aufruf eingefroren wurde. <br><br>  Im Gegensatz zu ReaderWriterLock gilt ManualResetEvent auch nach Erscheinen der Slim-Version nicht als veraltet.  Diese schlanke Version der Klasse kann f√ºr kurze Wartezeiten wirksam sein, wie dies im Spin-Wait-Modus der Fall ist.  Die Standardversion ist gut f√ºr lange Wartezeiten. <br><br>  Neben den Klassen ManualResetEvent und AutoResetEvent gibt es auch die Klasse CountdownEvent.  Diese Klasse ist sehr n√ºtzlich f√ºr die Implementierung von Algorithmen, die Ergebnisse nach einem parallelen Abschnitt zusammenf√ºhren.  Dieser Ansatz wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fork-Join bezeichnet</a> .  Es gibt einen gro√üartigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zu dieser Klasse, daher werde ich ihn hier nicht im Detail beschreiben. <br><a name="Conclusions"></a><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Bei der Arbeit mit Threads gibt es zwei Probleme, die zu falschen Ergebnissen oder sogar zum Fehlen von Ergebnissen f√ºhren k√∂nnen - Race Condition und Deadlock. </li><li>  Probleme, die dazu f√ºhren k√∂nnen, dass das Programm mehr Zeit oder Ressourcen verbringt, sind Thread-Hunger und besch√§ftigtes Warten. </li><li>  .NET bietet viele M√∂glichkeiten zum Synchronisieren von Threads. </li><li>  Es gibt zwei Arten von Blockwartezeiten - Spin Wait und Core Wait.  Einige Thread-Synchronisationsprimitive in .NET verwenden beide. </li><li>  Interlocked ist eine Reihe von atomaren Operationen, mit denen sperrfreie Algorithmen implementiert werden k√∂nnen.  Es ist das schnellste Synchronisationsprimitiv. </li><li>  Die Operatoren lock und Monitor. Enter / Exit implementieren das Konzept eines kritischen Abschnitts - eines Codefragments, das nur von einem Thread zu einem bestimmten Zeitpunkt ausgef√ºhrt werden kann. </li><li>  Die Monitor.Pulse / Wait-Methoden sind n√ºtzlich f√ºr die Implementierung von Producer-Consumer-Szenarien. </li><li>  ReaderWriterLockSlim kann n√ºtzlicher sein als die Standard-Sperrf√§lle, wenn paralleles Lesen erwartet wird. </li><li>  Die ResetEvent-Klassenfamilie kann f√ºr die Thread-Synchronisierung hilfreich sein. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461471/">https://habr.com/ru/post/de461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461461/index.html">Backup gedeiht im Cloud-Zeitalter, aber Bandspulen werden nicht vergessen. Gespr√§ch mit Veeam</a></li>
<li><a href="../de461463/index.html">Gesch√§ftsprozesse in Unternehmen: Spekulation und Realit√§t. Licht mit R.</a></li>
<li><a href="../de461465/index.html">Messanleitung</a></li>
<li><a href="../de461467/index.html">Ein Beispiel f√ºr das Erstellen eines Makefile f√ºr Go-Anwendungen</a></li>
<li><a href="../de461469/index.html">Wie ist es, Code mit 1000 W√∂rtern pro Minute zu h√∂ren?</a></li>
<li><a href="../de461473/index.html">Debugging-Algorithmen f√ºr Grafiken - jetzt mit Bildern</a></li>
<li><a href="../de461475/index.html">AMA mit Habr. 1011</a></li>
<li><a href="../de461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../de461487/index.html">Mini-CTF-Aufgaben</a></li>
<li><a href="../de461493/index.html">Django 3.0 wird asynchron sein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>