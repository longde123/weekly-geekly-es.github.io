<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 ♟️ 😑 “ Class-fields-proposal”或“ tc39 commit出了什么问题” 🕓 👂🏽 🏌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="很久以前，我们所有人都希望在JS中进行常规封装，而无需不必要的手势即可使用它。 我们还需要方便的构造来声明类属性。 最后，我们希望语言中的所有这些功能都以不破坏现有应用程序的方式出现。 


看来这是幸福： class-fields-proposal ，经过tc39委员会多年的折磨，它仍然进入了st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“ Class-fields-proposal”或“ tc39 commit出了什么问题”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428119/"><p> 很久以前，我们所有人都希望在JS中进行常规封装，而无需不必要的手势即可使用它。 我们还需要方便的构造来声明类属性。 最后，我们希望语言中的所有这些功能都以不破坏现有应用程序的方式出现。 </p><br><p>看来这是幸福： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">class-fields-proposal</a> ，经过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tc39委员会</a>多年的折磨，它仍然进入了<code>stage 3</code> ，甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在chrome中</a>得以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现</a> 。 </p><br><p> 老实说，我真的很想写一篇关于为什么要使用新语言功能以及如何使用它的文章，但是不幸的是，这篇文章根本不是关于那方面的。 </p><a name="habracut"></a><br><h1 id="opisanie-tekuschego-propozala"> 当前缺失的描述 </h1><br><p> 在此，我将不再重复<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始说明</a> ， <a href="">常见问题解答</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规格更改</a> ，而仅简要概述要点。 </p><br><h2 id="polya-klassa"> 类字段 </h2><br><p> 声明字段并在类中使用它们： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p> 访问课程外的字段： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ax);</code> </pre> <br><p> 一切似乎都是显而易见的，多年来，我们一直在通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Babel</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TypeScript</a>使用这种语法。 </p><br><p> 只有细微的差别。 这种新语法使用<code>[[Define]]</code> ，而不是<code>[[Set]]</code>我们一直以来所使用<code>[[Set]]</code>语义。 </p><br><p> 实际上，这意味着上面的代码<strong>与</strong>此<strong>不相等</strong> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p> 但实际上这<strong>等效</strong>于此： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p> 而且，尽管对于上面的示例，这两种方法本质上都是相同的，但这是<strong>非常</strong>不同的，这就是原因： </p><br><p> 假设我们有一个这样的父类： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p> 基于此，我们创建了另一个： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p> 他们使用了它： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.method(); <span class="hljs-comment"><span class="hljs-comment">//   2  </span></span></code> </pre> <br><p> 然后，由于某种原因，以一种似乎向后兼容的方式更改了<code>A</code>类： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ _x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,   ,        get x() { return this._x; }; set x(val) { return this._x = val; }; method() { console.log(this._x); } }</span></span></code> </pre> <br><p> 对于<code>[[Set]]</code>语义，这实际上是向后兼容的更改，但对于<code>[[Define]]</code>不是。 现在，对<code>b.method()</code>的调用将输出到控制台<code>1</code>而不是<code>2</code> 。 发生这种情况是因为<code>Object.defineProperty</code>重新定义了属性描述符，因此，不会调用类<code>A</code> getter / setter方法。 实际上，在子类中，我们<em>掩盖了</em>父类<em>的</em> <code>x</code>属性，类似于我们如何在词汇范围内做到这一点： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p> 的确，在这种情况下，具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>no-shadowed-variable</code></a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>no-shadow</code></a>规则的短绒将拯救我们，但是有人做出<code>no-shadowed-class-field</code>的可能性趋于零。 </p><br><blockquote> 顺便说一句，我将为俄罗斯带<code>shadowed</code>术语获得成功表示感激。 </blockquote><p> 尽管有上述所有内容，但我并不是新语义的不可接受的反对者（尽管我更喜欢另一种），因为它有其积极的方面。 但是，不幸的是，这些优点并没有超过最重要的缺点-我们使用<code>[[Set]]</code>语义已经很多年了，因为默认情况下在<code>babel6</code>和<code>TypeScript</code>使用了<code>[[Set]]</code>语义。 </p><br><blockquote> 没错，值得注意的是，在<code>babel7</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">默认值已更改</a> 。 </blockquote><p> 有关此主题的更多原始讨论可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读。 </p><br><h2 id="privatnye-polya"> 私人领域 </h2><br><p> 现在，我们将继续讨论这一最具争议的部分。 有争议的是： </p><br><ol><li> 尽管事实上该功能已在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chrome Canary中</a>实现，并且默认情况下已启用公共字段，但私有字段仍处于滞后状态； </li><li> 尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">私有字段</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始prozal</a>已与当前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字段</a>合并，但仍在创建请求以分离这两个功能（例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">one</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2，3</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4</a> ）； </li><li> 尽管有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三阶段，</a>甚至一些委员会成员（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">艾伦•维尔夫斯-布罗克</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Allen Wirfs-Brock）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">凯文•史密斯</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kevin Smith</a> ））都表示了自己的<strong>看法</strong> ，并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提出了其他选择</a> ; </li><li> 这错过了一个创下记录数量的记录- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">当前版本库中的</a> <strong>129个</strong> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本中的</a> <strong>96个</strong> ，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BigInt版本中</a>则为<strong>126个</strong> ，记录持有人大多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">持负面评论</a> ; </li><li> 我不得不创建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单独的线程</a> ，试图以某种方式总结针对它的所有主张。 </li><li> 我不得不写一个<a href="">单独的常见问题</a> ，涵盖这部分 <br><blockquote> 但是，由于争论不力，出现了这样的讨论（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二</a> ） <br></blockquote></li><li> 我个人花了很长时间（有时是工作时间）来弄清所有事情，甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到解释</a>为什么他会那样或提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合适的选择</a> 。 </li><li> 最后，我决定写这篇评论文章。 </li></ol><br><p> 专用字段声明如下： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; }</code> </pre> <br><p> 并访问它们如下： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv); } }</code> </pre> <br><p> 我什至不会提出这样一个问题：其背后的思维模型不是很直观（ <code>this.#priv !== this['#priv']</code> ），不使用已经保留的<code>private</code> / <code>protected</code>单词（这必将引起额外的痛苦）对于TypeScript开发人员而言），目前尚不清楚如何将其扩展为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他访问修饰符</a> ，而且语法本身也不是很漂亮。 尽管所有这些都是促使我进行更深入研究和参与讨论的原始原因。 </p><br><p> 所有这些都与语法有关，其中主观审美偏好非常强烈。 一个人可以忍受它，并随着时间的推移习惯它。 如果不是一件事：存在一个非常重要的语义问题... </p><br><h3 id="cemantika-weakmap"> 语义<code>WeakMap</code> </h3><br><p> 让我们看一下现有主张的背后是什么。 我们可以使用封装而不使用新的语法来重写上面的示例，但是保留当前语法的语义： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privatesForA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { privatesForA.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv); } }</code> </pre> <br><blockquote> 顺便说一句，在这种语义的基础上，一个委员会成员甚至构建了一个小型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实用程序库</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a>允许您现在使用私有状态，以表明该功能被委员会高估了。 格式化的代码仅占用27行。 </blockquote><p> 总的来说，一切都很好，我们得到了<code>hard-private</code> ，它不能以任何方式从外部代码获取/拦截/跟踪，同时我们可以访问同一类的另一个实例的私有字段，例如： </p><br><pre> <code class="javascript hljs">isEquals(obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).id === privatesForA.get(obj).id; }</code> </pre> <br><p> 嗯，这非常方便，除了以下事实外，除了封装本身之外，此语义还包括<code>brand-checking</code> （您不能用谷歌搜索它是什么-您不太可能找到相关信息）。 <br>  <code>brand-checking</code>与“ <code>duck-typing</code> ”相反，因为它不检查对象的公共接口，而是检查对象是使用可信代码构建的事实。 <br> 实际上，这种检查具有一定的范围-它主要与在具有受信任地址的单个地址空间中调用不受信任代码的安全性以及不进行序列化而直接交换对象的能力相关。 </p><br><blockquote> 尽管有些工程师认为这是正确封装的必要部分。 </blockquote><p> 尽管这是一个非常奇怪的机会，但根据我的经验，这与<code></code>模式（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简短</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">较长的</a>描述），计算机科学领域的领域<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宣传</a>和科学工作密切相关， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">马克·塞缪尔·米勒</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mark Samuel Miller</a> ）也是该委员会的成员（也是委员会成员） ，在大多数开发人员的实践中，这种情况几乎不会发生。 </p><br><blockquote> 顺便说一句，当我重写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vm2以</a>满足自己的需求时，我仍然遇到了麻烦（尽管当时我不知道那是什么）。 </blockquote><br><h3 id="problema-brand-checking">  <code>brand-checking</code>问题 </h3><br><p> 如前所述， <code>brand-checking</code>与<code>duck-typing</code>相反。 实际上，这意味着拥有以下代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> brands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { brands.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); } method() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } brandCheckedMethod() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!brands.has(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">'Brand-check failed'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method()); } }</code> </pre> <br><p> 只能使用<code>A</code>类的实例调用<code>brandCheckedMethod</code> <code>A</code>即使目标是保留此类不变性的对象，此方法也会引发异常： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duckTypedObj = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: A.prototype.method.bind(duckTypedObj), <span class="hljs-attr"><span class="hljs-attr">brandCheckedMethod</span></span>: A.prototype.brandCheckedMethod.bind(duckTypedObj), }; duckTypedObj.method(); <span class="hljs-comment"><span class="hljs-comment">//        1 duckTypedObj.brandCheckedMethod(); //     </span></span></code> </pre> <br><p> 显然，此示例是完全综合的，在我们考虑<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Proxy</code></a>之前，像这样使用<code>duckTypedObj</code>值得怀疑。 <br> 元编程是非常重要的代理使用方案之一。 为了使代理能够完成所有必要的有用工作，使用代理包装的对象的方法必须在代理的上下文中而不是在目标的上下文中执行，即： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(a, { get(target, p, receiver) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, p, receiver); doSomethingUseful(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, retval, target, p, receiver); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> property === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) ? property.bind(proxy) : property; } });</code> </pre> <br><p> 调用<code>proxy.method();</code> 在调用<code>proxy.brandCheckedMethod();</code>将完成代理中声明的有用工作并返回<code>1</code> <code>proxy.brandCheckedMethod();</code> 而不是从代理执行两次有用的工作，它会引发异常，因为<code>a !== proxy</code> ，这意味着未通过<code>brand-check</code> 。 </p><br><p> 是的，我们可以在实际目标（而不是代理）的上下文中执行方法/函数，并且在某些情况下，这已经足够（例如，实现<code></code>模式），但是对于所有情况，这还不够（例如，实现反应性： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MobX 5</a>已经使用了代理）为此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vue.js</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Aurelia正在</a>针对将来的版本尝试这种方法。 </p><br><p> 通常，只要需要明确进行<code>brand-check</code> ，这就不成问题-开发人员只需要有意识地决定要进行哪种折衷以及是否需要进行折衷，此外，在进行明确的<code>brand-check</code>的情况下<code>brand-check</code>您可以采用以下方式实施该错误不会抛出给受信任的代理。 </p><br><p> 不幸的是，当前的做法剥夺了我们这种灵活性： </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; method() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv; <span class="hljs-comment"><span class="hljs-comment">//    brand-check   } }</span></span></code> </pre> <br><p> 如果未在使用构造函数<code>A</code>构造的对象的上下文中调用此<code>method</code>它将始终引发异常<code>A</code> 最糟糕的是， <code>brand-check</code>在这里是隐式的，并且与其他功能（封装）混合在一起。 </p><br><p> 尽管<code></code>几乎是所有代码所必需的，但<code>brand-check</code>范围相当狭窄。 当开发人员只打算隐藏实现细节时，将它们组合为一种语法将导致以下事实：在用户代码中会出现许多无意的<code>brand-check</code> 。 <br> 而用于推广此目标的口号是<code># is the new _</code>只会加剧局势。 </p><br><blockquote> 您还可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关现有代理如何破坏代理</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细讨论</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Aurelia开发人员之一</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作者Vue.js在讨论中发表了讲话</a> 。 <br><br> 另外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的评论</a> （其中更详细地描述了不同代理场景之间的差异）可能对某人来说很有趣。 总体而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整个讨论都涉及私有领域和膜的联系</a> 。 </blockquote><br><h1 id="alternativy"> 替代品 </h1><br><p> 如果没有其他选择，所有这些讨论将毫无意义。 不幸的是，甚至没有一个替代品进入<strong>阶段1</strong> ，结果甚至没有机会得到足够的锻炼。 但是，我将在此处列出以某种方式解决上述问题的替代方案。 </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>Symbol.private-</strong></a>委员会的候补百忧解之一。 <br><ol><li> 它解决了上述所有问题（尽管可能有其自身的问题，但是鉴于缺乏积极的工作，因此很难找到它们） </li><li> 由于缺少集成的<code>brand-check</code> ，膜模式存在问题（尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这</a> +提供了适当的解决方案）以及缺乏方便的语法，因此再次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在委员会</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上次会议上</a>被撤回 </li><li> 方便的语法可以建立在实际语法的基础上，如我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>所示 </li></ol></li><li>  <a href=""><strong>1.1类</strong></a> -同一作者的早期posozal </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>使用<em>私有</em>作为对象</strong></a> </li></ol><br><h1 id="vmesto-zaklyucheniya"> 而不是结论 </h1><br><p> 用文章的语气，似乎我谴责了委员会，但事实并非如此。 在我看来，多年来（取决于起点，甚至可能是几十年），委员会致力于JS封装，行业中的许多事情已经改变，外观可能会模糊，从而导致错误的优先级排序。 </p><br><p> 此外，我们作为一个社区， <strong>推动tc39</strong>迫使他们更快地发布功能，同时在prozos的早期阶段提供很少的反馈，只有在几乎不能改变的时候才使我们愤慨。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">据认为</a> ，在这种情况下，该过程完全失败了。 </p><br><p> 将其投入脑海并与一些代表交谈后，我决定尽我所能防止类似情况的再次发生-但我可以做些什么（写一篇评论文章，使<code>babel</code>以及所有内容都错过了<code>stage1</code>的实现）。 </p><br><p> 但是最重​​要的是反馈-所以我想请您参加这项小型调查。 反过来，我将尝试将其传达给委员会。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428119/">https://habr.com/ru/post/zh-CN428119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428109/index.html">企业墙</a></li>
<li><a href="../zh-CN428111/index.html">Erlang中任意精度的算术</a></li>
<li><a href="../zh-CN428113/index.html">关于贝塞尔曲线，Arduino速度和一个有趣的站点，或者我如何度过周末的问题</a></li>
<li><a href="../zh-CN428115/index.html">电子商务的网络开发：2019年的5种技术趋势</a></li>
<li><a href="../zh-CN428117/index.html">Google在协作云中提供免费的张量处理器</a></li>
<li><a href="../zh-CN428121/index.html">斯坦·德拉普金（Stan Drapkin）。 .NET中的高级密码陷阱</a></li>
<li><a href="../zh-CN428123/index.html">安全周41：好消息</a></li>
<li><a href="../zh-CN428125/index.html">谁是产品分析人员，为什么团队需要它们？</a></li>
<li><a href="../zh-CN428127/index.html">Nginx缓存：一切都是新的-被遗忘的很旧</a></li>
<li><a href="../zh-CN428129/index.html">简单的模糊逻辑将燃气轮机的“从过去”粘合在一起</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>