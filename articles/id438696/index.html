<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏼 👩🏿‍🤝‍👨🏽 🤜🏻 Perangkat kompiler Swift. Bagian 3 💃🏽 😮 🏇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus mempelajari kompiler Swift. Bagian ini didedikasikan untuk Bahasa Swift Intermediate. 


 Jika Anda belum melihat yang sebelumnya, saya sar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perangkat kompiler Swift. Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/438696/"><img src="https://habrastorage.org/webt/w6/d3/5f/w6d35fpnglkxq8suebz-fhsl2de.png"><br><p>  Kami terus mempelajari kompiler Swift.  Bagian ini didedikasikan untuk Bahasa Swift Intermediate. </p><br><p>  Jika Anda belum melihat yang sebelumnya, saya sarankan Anda mengikuti tautan dan membaca: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambaran umum komponen</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parsing file sumber</a> . <a name="habracut"></a></li></ul><br><h1 id="silgen">  Silgen </h1><br><p>  Langkah selanjutnya adalah mengubah AST yang diketik menjadi SIL mentah.  Swift Intermediate Language (SIL) adalah representasi perantara yang dibuat khusus untuk Swift.  Deskripsi semua instruksi dapat ditemukan dalam <a href="">dokumentasi</a> . </p><br><p>  SIL memiliki bentuk SSA.  Static Single Assignment (SSA) - Representasi kode di mana setiap variabel hanya diberi nilai satu kali.  Itu dibuat dari kode biasa dengan menambahkan variabel tambahan.  Misalnya, menggunakan sufiks numerik yang menunjukkan versi variabel setelah setiap penugasan. </p><br><p>  Berkat formulir ini, kompiler lebih mudah mengoptimalkan kode.  Di bawah ini adalah contoh pada pseudo-code.  Jelas, baris pertama tidak perlu: </p><br><pre><code class="plaintext hljs">a = 1 a = 2 b = a</code> </pre> <br><p>  Tapi ini hanya untuk kita.  Untuk mengajarkan kompiler untuk menentukan ini, kita harus menulis algoritma non-trivial.  Tetapi dengan SSA, ini jauh lebih mudah.  Sekarang, bahkan untuk kompiler sederhana, akan jelas bahwa nilai variabel <strong>a1</strong> tidak digunakan, dan baris ini dapat dihapus: </p><br><pre> <code class="plaintext hljs">a1 = 1 a2 = 2 b1 = a2</code> </pre> <br><p>  SIL memungkinkan Anda untuk menerapkan optimasi dan pemeriksaan khusus ke kode Swift yang akan sulit atau tidak mungkin untuk diselesaikan pada fase AST. </p><br><h3 id="ispolzovanie-generatora-sil">  Menggunakan SIL Generator </h3><br><p>  Untuk menghasilkan SIL, gunakan <strong>flag -emit-silgen</strong> : </p><br><pre> <code class="plaintext hljs">swiftc -emit-silgen main.swift</code> </pre> <br><p>  Hasil dari perintah: </p><br><pre> <code class="plaintext hljs">sil_stage raw import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %8 %4 = metatype $@thin Int.Type // user: %7 %5 = integer_literal $Builtin.Int2048, 16 // user: %7 // function_ref Int.init(_builtinIntegerLiteral:) %6 = function_ref @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %7 %7 = apply %6(%5, %4) : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int // user: %8 store %7 to [trivial] %3 : $*Int // id: %8 %9 = integer_literal $Builtin.Int32, 0 // user: %10 %10 = struct $Int32 (%9 : $Builtin.Int32) // user: %11 return %10 : $Int32 // id: %11 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  SIL, seperti LLVM IR, dapat di-output sebagai kode sumber.  Anda dapat menemukan di dalamnya bahwa pada tahap ini impor modul Swift Builtin, Swift dan SwiftShims telah ditambahkan. </p><br><p>  Terlepas dari kenyataan bahwa kode Swift dapat ditulis langsung dalam lingkup global, SILGen menghasilkan fungsi utama - titik masuk ke program.  Semua kode terletak di dalamnya, kecuali untuk menyatakan konstanta, karena bersifat global dan harus dapat diakses di mana saja. </p><br><p>  Sebagian besar garis memiliki struktur yang serupa.  Di sebelah kiri adalah pseudo-register di mana hasil instruksi disimpan.  Berikutnya - instruksi itu sendiri dan parameternya, dan pada akhirnya - sebuah komentar yang menunjukkan register yang akan digunakan register ini. </p><br><p>  Misalnya, bilangan bulat tipe Int2048 dan nilai 16. dibuat pada baris ini.Literal ini disimpan dalam register kelima dan akan digunakan untuk menghitung nilai ketujuh: </p><br><pre> <code class="plaintext hljs">%5 = integer_literal $Builtin.Int2048, 16 // user: %7</code> </pre> <br><p>  Deklarasi fungsi dimulai dengan kata kunci sil.  Berikut ini adalah nama dengan @ awalan, konvensi pemanggilan, parameter, tipe pengembalian, dan kode fungsi.  Untuk initializer <strong>Int.init (_builtinIntegerLiteral :),</strong> tentu saja tidak ditentukan, karena fungsi ini dari modul lain, dan hanya perlu dideklarasikan, tetapi tidak didefinisikan.  Tanda dolar menunjukkan awal dari indikasi jenis: </p><br><pre> <code class="plaintext hljs">// Int.init(_builtinIntegerLiteral:) sil [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konvensi panggilan</a> menunjukkan cara memanggil fungsi dengan benar.  Ini diperlukan untuk menghasilkan kode mesin.  Penjelasan rinci tentang prinsip-prinsip ini berada di luar cakupan artikel ini. </p><br><p>  Nama inisialisasi, serta nama struktur, kelas, metode, protokol, terdistorsi (nama mangling).  Ini memecahkan beberapa masalah sekaligus. </p><br><p>  Pertama, memungkinkan menggunakan nama yang sama di modul yang berbeda dan entitas bersarang.  Misalnya, untuk metode pertama <strong>fff</strong> , nama <strong>S4main3AAAV3fffSiyF digunakan</strong> , dan untuk yang kedua, <strong>S4main3BBBVVffffSiyF digunakan</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff() -&gt; Int { return 8 } } struct BBB { func fff() -&gt; Int { return 8 } }</code> </pre> <br><p>  <strong>S</strong> berarti Swift, 4 adalah jumlah karakter dalam nama modul, dan 3 adalah dalam nama kelas.  Dalam initializer literal, <strong>Si</strong> menunjukkan tipe standar Swift.Int. </p><br><p>  Kedua, nama dan tipe argumen fungsi ditambahkan ke namanya.  Ini memungkinkan penggunaan kelebihan.  Misalnya, untuk metode pertama, <strong>S4main3AAAV3fff3iiiS2i_tF</strong> dihasilkan, dan untuk yang kedua - <strong>S4main3AAAV3fff3dddSiSd_tF</strong> : </p><br><pre> <code class="plaintext hljs">struct AAA { func fff(iii internalName: Int) -&gt; Int { return 8 } func fff(ddd internalName: Double) -&gt; Int { return 8 } }</code> </pre> <br><p>  Setelah nama parameter, jenis nilai kembali ditunjukkan, diikuti oleh jenis parameter.  Namun, nama internal mereka tidak ditunjukkan.  Sayangnya, tidak ada dokumentasi tentang nama mangling di Swift, dan implementasinya dapat berubah sewaktu-waktu. </p><br><p>  Nama fungsi diikuti oleh definisinya.  Ini terdiri dari satu atau lebih blok dasar.  Blok dasar adalah urutan instruksi dengan satu titik masuk, satu titik keluar, yang tidak mengandung instruksi atau ketentuan cabang untuk keluar awal. </p><br><p>  Fungsi utama memiliki satu unit dasar, yang mengambil semua parameter yang diteruskan ke fungsi sebagai input dan berisi semua kodenya, karena tidak ada cabang di dalamnya: </p><br><pre> <code class="plaintext hljs">bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):</code> </pre> <br><p>  Kita dapat mengasumsikan bahwa setiap ruang lingkup yang dibatasi oleh kawat gigi adalah unit dasar yang terpisah.  Misalkan kode berisi cabang: </p><br><pre> <code class="plaintext hljs">// before if 2 &gt; 5 { // true } else { // false } // after</code> </pre> <br><p>  Dalam hal ini, setidaknya 4 blok dasar akan dihasilkan untuk: </p><br><ul><li>  kode sebelum bercabang, </li><li>  kasus ketika ekspresi itu benar </li><li>  kasus ketika ekspresi salah </li><li>  kode setelah bercabang. </li></ul><br><p>  <strong>cond_br</strong> - instruksi untuk lompatan bersyarat.  Jika nilai pseudo-register% 14 benar, maka transisi ke blok <strong>bb1 dilakukan</strong> .  Jika tidak, maka di <strong>bb2</strong> .  br - lompatan tanpa syarat yang memulai eksekusi dari blok dasar yang ditentukan: </p><br><pre> <code class="plaintext hljs">// before cond_br %14, bb1, bb2 // id: %15 bb1: // true br bb3 // id: %21 bb2: // Preds: bb0 // false br bb3 // id: %27 bb3: // Preds: bb2 bb1 // after</code> </pre> <br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File Implementasi SILGen</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File SIL Header</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File Implementasi SIL</a> , </li><li>  <a href="">Dokumentasi SIL</a> . </li></ul><br><h1 id="sil-guaranteed-transformations">  Transformasi dijamin SIL </h1><br><p>  Representasi perantara mentah yang diperoleh pada tahap terakhir dianalisis untuk kebenaran dan diubah menjadi kanonik: fungsi yang ditandai transparan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inline</a> (pemanggilan fungsi diganti oleh tubuhnya), nilai-nilai ekspresi konstan dihitung, fungsi diperiksa bahwa fungsi yang mengembalikan nilai-nilai lakukan ini di semua cabang kode dan sebagainya. </p><br><p>  Konversi ini wajib dan dilakukan bahkan jika optimasi kode dinonaktifkan. </p><br><h3 id="generaciya-kanonichnogo-sil">  Canon SIL Generation </h3><br><p>  Untuk menghasilkan SIL kanonik, <strong>flag -emit-sil</strong> digunakan: </p><br><pre> <code class="plaintext hljs">swiftc -emit-sil main.swift</code> </pre> <br><p>  Hasil dari perintah: </p><br><pre> <code class="plaintext hljs">sil_stage canonical import Builtin import Swift import SwiftShims let x: Int // x sil_global hidden [let] @$S4main1xSivp : $Int // main sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 { bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): alloc_global @$S4main1xSivp // id: %2 %3 = global_addr @$S4main1xSivp : $*Int // user: %6 %4 = integer_literal $Builtin.Int64, 16 // user: %5 %5 = struct $Int (%4 : $Builtin.Int64) // user: %6 store %5 to %3 : $*Int // id: %6 %7 = integer_literal $Builtin.Int32, 0 // user: %8 %8 = struct $Int32 (%7 : $Builtin.Int32) // user: %9 return %8 : $Int32 // id: %9 } // end sil function 'main' // Int.init(_builtinIntegerLiteral:) sil public_external [transparent] [serialized] @$SSi22_builtinIntegerLiteralSiBi2048__tcfC : $@convention(method) (Builtin.Int2048, @thin Int.Type) -&gt; Int { // %0 // user: %2 bb0(%0 : $Builtin.Int2048, %1 : $@thin Int.Type): %2 = builtin "s_to_s_checked_trunc_Int2048_Int64"(%0 : $Builtin.Int2048) : $(Builtin.Int64, Builtin.Int1) // user: %3 %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0 // user: %4 %4 = struct $Int (%3 : $Builtin.Int64) // user: %5 return %4 : $Int // id: %5 } // end sil function '$SSi22_builtinIntegerLiteralSiBi2048__tcfC'</code> </pre> <br><p>  Ada beberapa perubahan dalam contoh sederhana.  Untuk melihat karya pengoptimal yang sebenarnya, Anda perlu sedikit menyulitkan kode.  Misalnya, tambahkan tambahan: </p><br><pre> <code class="plaintext hljs">let x = 16 + 8</code> </pre> <br><p>  Dalam SIL mentahnya, Anda dapat menemukan penambahan literal ini: </p><br><pre> <code class="plaintext hljs">%13 = function_ref @$SSi1poiyS2i_SitFZ : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %14 %14 = apply %13(%8, %12, %4) : $@convention(method) (Int, Int, @thin Int.Type) -&gt; Int // user: %15</code> </pre> <br><p>  Tetapi dalam kanonik itu tidak ada lagi.  Sebagai gantinya, nilai konstan 24 digunakan: </p><br><pre> <code class="plaintext hljs">%4 = integer_literal $Builtin.Int64, 24 // user: %5</code> </pre> <br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIL Optimizer Wajib</a> </li></ul><br><h1 id="sil-optimization">  Optimasi Sil </h1><br><p>  Transformasi Swift-spesifik tambahan diterapkan jika optimisasi diaktifkan.  Diantaranya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesialisasi generik</a> (mengoptimalkan kode generik untuk jenis parameter tertentu), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">devirtualization</a> (mengganti panggilan dinamis dengan yang statis), inlining, <a href="">optimasi ARC,</a> dan banyak lagi.  Penjelasan tentang teknik ini tidak cocok dengan artikel yang sudah terlalu banyak ditumbuhi. </p><br><p>  Kode Sumber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tajuk Pengoptimal SIL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File Implementasi SIL Optimizer</a> </li></ul><br><p>  Karena SIL adalah fitur Swift, saya tidak menunjukkan contoh implementasi saat ini.  Kami akan kembali ke kompiler tanda kurung di bagian berikutnya ketika kami akan terlibat dalam generasi IR LLVM. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438696/">https://habr.com/ru/post/id438696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438682/index.html">Peluncuran Jubilee dari astronot Iran</a></li>
<li><a href="../id438688/index.html">PCIe 5.0 bus siap untuk commissioning</a></li>
<li><a href="../id438690/index.html">Jika modul CRT Pascal dalam JavaScript</a></li>
<li><a href="../id438692/index.html">Piring terbang inersia. Dorong semuanya</a></li>
<li><a href="../id438694/index.html">Bagaimana proses dukungan situs telah berubah selama dua puluh tahun terakhir</a></li>
<li><a href="../id438698/index.html">Tragedi sistemd</a></li>
<li><a href="../id438700/index.html">Peta kecelakaan</a></li>
<li><a href="../id438708/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 350 (28 Januari - 3 Februari 2019)</a></li>
<li><a href="../id438710/index.html">Frontend Weekly Digest (28 Jan - 3 Feb 2019)</a></li>
<li><a href="../id438714/index.html">Veeam Backup & Replication 9.5 Pembaruan 4 Tinjauan Umum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>