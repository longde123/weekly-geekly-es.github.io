<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèø üèê üìº Wie aus linearer Zeit Windows in O (n¬≤) wird üë≥üèø üö° üçû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich hatte vor kurzem mehrere Minuten Versp√§tung auf meiner Workstation. Nach der Untersuchung stellte sich heraus, dass die Ursache des Problems eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie aus linearer Zeit Windows in O (n¬≤) wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479498/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png" alt="Bild"></div><br>  Ich hatte vor kurzem mehrere Minuten Versp√§tung auf meiner Workstation.  Nach der Untersuchung stellte sich heraus, dass die Ursache des Problems eine Sperre war, die f√ºnf Minuten dauern konnte, w√§hrend der die Quelle der Sperre im Grunde genommen in einem Zyklus von neun Anweisungen drehte. <br><br>  Es ist sehr wichtig f√ºr mich, gute √úberschriften f√ºr meine Posts auszuw√§hlen, aber ich erinnerte mich sofort, dass der entsprechende Name "48 Cores sind durch neun Anweisungen blockiert" <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">bereits</a> von einem Post vor weniger als einem Monat √ºbernommen wurde.  Die Anzahl der blockierten Prozessoren ist unterschiedlich und der Zyklus ist etwas l√§nger, aber in der Tat f√ºhrt dies dazu, dass Sie Deja Vu erleben.  Daher wollte ich, w√§hrend ich das neu entdeckte Problem erl√§utere, dar√ºber nachdenken, <em>warum dies die ganze Zeit passiert</em> . <br><br><h2>  Warum passiert das? </h2><br>  Grob gesagt ergeben sich solche Probleme aus einer Beobachtung, die ich <em>Dawsons erstes Gesetz zum Rechnen nennen werde:</em> <a href="https://twitter.com/BruceDawson0xB/status/1120381406700429312" rel="nofollow">O (n <sup>2</sup> ) ist ein Magnet f√ºr Algorithmen, die sich nicht gut skalieren lassen</a> : Sie sind schnell genug, um in Produktion zu gehen, aber langsam genug, um alles zu verderben. wenn sie dort ankommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/017/fb8/bea017fb89b90af6566d8ad77298efb9.png"></div><br>  <i>O (n <sup>2</sup> ) in Aktion - Daten aus meinem Fall</i> <br><a name="habracut"></a><br>  Was ist los?  Der Entwickler schreibt den Code und verwendet den O (n <sup>2</sup> ) -Algorithmus.  Vielleicht merkt er das nicht, oder der Algorithmus wird <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">aufgrund eines Fehlers</a> zu O (n <sup>2</sup> ), oder der Entwickler wei√ü, dass er O (n <sup>2</sup> ) ist, aber er denkt, dass es niemals wichtig sein wird.  Unter Laborbedingungen ist die Codegeschwindigkeit akzeptabel und f√ºr die meisten Benutzer in der realen Welt akzeptabel. Dann erstellt jemand <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">7.000 Prozesse</a> mit aktiviertem App Verifier oder erstellt eine <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">Bin√§rdatei mit 180.000 CFG-Elementen</a> oder sammelt eine so gro√üe DLL, dass sie <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">st√§ndig vorhanden ist Es wird eine einfach verkn√ºpfte Liste durchsucht</a> , die den gesamten Prozessor erfasst.  Als ich an der Startzeit des Valve Source 2-Motors arbeitete, fand ich <em>viele</em> O (n <sup>2</sup> ) -Algorithmen, von denen jeder etwa 30 Sekunden zur Startzeit des Motors beitrug, dh, dieses Problem tritt bei sehr unterschiedlichen Entwicklern auf. <br><br>  <em>O (n <sup>2</sup> ) ist ein Magnet f√ºr Algorithmen, die nicht gut skalieren: Sie sind schnell genug, um in Produktion zu gehen, aber langsam genug, um alles zu verderben, wenn sie dort ankommen.</em> <br><br>  Genau. <br><br>  Beispielsweise wird die <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">Erstellung von App Verifier-Protokolldateinamen</a> f√ºr jeden ausgef√ºhrten Prozess <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">in linearer Zeit</a> ausgef√ºhrt. Dies ist normal, bis Sie feststellen, dass dies zu O (n <sup>2</sup> ) f√ºhrt, wenn viele Prozesse ausgef√ºhrt werden.  Manchmal ist es nicht einmal offensichtlich, dass es verschachtelte Schleifen gibt, oder <em>formal ist</em> es nicht O (n <sup>2</sup> ), oder es ist nicht offensichtlich, dass die Schleifen so lange laufen k√∂nnen, dass sie die Geschwindigkeit erheblich beeinflussen k√∂nnen ... <br><br>  Nutzen Sie diese Gelegenheit, denken Sie beim Schreiben von Code dar√ºber nach, √ºberwachen Sie, wie die Leistung unter hohen Lasten skaliert wird, und untersuchen Sie verd√§chtige Codeabschnitte, wenn Sie ein Profil f√ºr solch hohe Lasten erstellen.  Oder √ºberlasse es mir, damit ich danach suchen und Artikel in meinem Blog schreiben kann. <br><br><h2>  Kehren wir zu unseren √ºblichen Beschwerden zur√ºck </h2><br>  Wie √ºblich habe ich an meiner veralteten, aber immer noch leistungsstarken Workstation mit 48 logischen Prozessoren und 96 GB RAM gearbeitet.  Ich habe <em>Ninja Chrome eingef√ºhrt</em> , um Chromium zu bauen, aber ... nichts ist passiert.  Ich habe nachgesehen und 20 Sekunden gewartet, aber die Montage hat nie begonnen.  Deshalb bin ich nat√ºrlich zu <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>UIforETW gewechselt</em></a> , um die <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/" rel="nofollow"><em>ETW-</em></a> Spur aufzuzeichnen.  Genauer gesagt habe ich es versucht.  Beim Versuch, die Trace-Aufzeichnung zu starten, <em>friert UIforETW ein</em> .  Zum ersten Mal in meiner Praxis verwendete ein K√§fer Schutzma√ünahmen, um mich daran zu hindern, ihn zu erforschen! <br><br>  Nach ein oder zwei Minuten begann die Montage von Chromium, und <em>UIforETW</em> startete die Ablaufverfolgung, aber es begann zu sp√§t und ich hatte nicht die geringste Information dar√ºber, was passiert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/76e/b86/48576eb86c46f3254d1b891d180cc25e.png"></div><br>  <i>UIforETW-Optionen mit ausgew√§hltem Circular Buffer Tracing</i> <br><br>  Als dasselbe ein paar Tage sp√§ter <em>passierte, war UIforETW</em> wieder nicht in der Lage, irgendetwas zu tun.  Dieses Mal habe ich die Spur verlassen, um in kreisf√∂rmigen Speicherpuffern zu arbeiten, um auf die Tatsache vorbereitet zu sein, dass der Hang zum dritten Mal auftreten w√ºrde.  Dies verringerte jedoch die Geschwindigkeit meiner Build-Tools erheblich, sodass ich nach einigen Stunden aufgab. <br><br>  Dann wiederholte sich diese Situation <em>erneut</em> .  Dieses Mal habe ich das von Microsoft - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>wprui</em></a> erstellte ETW - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>Traceprotokollierungstool ausgef√ºhrt</em></a> und konnte mit der Aufzeichnung beginnen.  Ungef√§hr 40 Sekunden sp√§ter begann die Montage und ich bekam eine Spur! <br><br><h2>  Kann ich jetzt mit der Untersuchung beginnen? </h2><br>  Fr√ºher bemerkte ich im "Task-Manager", dass <em>WinMgmt.exe</em> w√§hrend dieser <em>Einfrierungen ausgef√ºhrt wurde</em> .  Als ich mir die CPU-Auslastungsdaten in WPA <em>ansah,</em> war ich √ºberzeugt, dass nach mehr als vierzig Sekunden, in denen <em>WinMgmt.exe</em> fast der einzige Arbeitsprozess war, mein Computer nach dem <em>Herunterfahren von WinMgmt.exe</em> zum Leben <em>erweckt</em> wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/cd4/35d/02acd435d1b3dec571ae9ebb5b56b67a.png"></div><br>  <i>Wir warten auf das Erwachen von Prozessen, nachdem WinMgmt.exe abgeschlossen ist</i> <br><br>  All dies ist ziemlich verd√§chtig, aber meine weisen Leser wissen, dass "danach" nicht "aufgrund" bedeutet und dass Beweise erforderlich sind. <br><br>  Wie beim <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">letzten Mal habe</a> ich den Moment des Entsperrens im Diagramm angen√§hert, die Kontextwechsel nach <em>Einschaltzeit</em> sortiert und nach dem ersten Schalter mit einem langen Wert f√ºr " <em>Zeit seit letztem"</em> gesucht (der angibt, wie lange der Thread nicht ausgef√ºhrt wurde).  Nachdem ich ein Dutzend Threads verpasst hatte, bei denen es sich nur um kurze Ausfallzeiten handelte, fand ich den ersten von vielen, der 41,57 Sekunden wartete.  Der schlafende Thread hat <em>WinMgmt.exe</em> nicht <em>aufgeweckt</em> , aber ich fand schnell heraus, dass er mit dem Thread aufgewacht ist, der <em>WinMgmt.exe</em> einen Bruchteil einer Millisekunde zuvor <em>aufgeweckt hat</em> . <br><br><blockquote>  Eine Erl√§uterung der Diagramme zur CPU-Auslastung (pr√§zise) und der Konzepte f√ºr vorbereitende Threads / neue Threads finden Sie in <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">diesem Lernprogramm</a> oder in <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">dieser Dokumentation</a> . </blockquote><br>  Im Screenshot mit den <em>Inhaltsumschaltdaten</em> enth√§lt Zeile 17 den Stream <em>72.748 (WinMgmt.exe)</em> , der den Stream <em>74.156 (svchost.exe)</em> aktiviert <em>.</em>  In Zeile 19 aktiviert der Thread <em>74.156 (svchost.exe) den</em> Thread <em>58.704 (svchost.exe)</em> , der auf 41,57 Sekunden gewartet hat.  Dies ist der erste Faden, der nach einem langen Schlaf aufwacht und von diesem die Kette der Aktivierung von Fl√ºssen fortsetzt.  Gerade aktivierte Threads werden in der Spalte " <em>Neue Thread-</em> <em>ID" angezeigt.</em> Gehen Sie einige Zeilen nach unten und sehen Sie sie in der <em>Spalte "Thread-ID bereitstellen"</em> , um einen anderen Thread zu aktivieren.  Die Namen und Prozess-IDs helfen Ihnen, den Kontext zu verstehen.  Zeile 17 ist den Zeilen 18 und 19 zugeordnet, Zeile 19 ist 20 zugeordnet, die der Zeile 23 zugeordnet ist, die der Zeile 27 zugeordnet ist, und so weiter;  Jeder Thread wird durch den vorherigen Thread in der Kette aktiviert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png"></div><br>  <i>Das Monster erwacht - lange, leere F√§den werden lebendig</i> <br><br>  41.57 ist eine lange Zeit, um einen Thread zu blockieren, aber in Wirklichkeit wurden Hunderte von Threads blockiert und sie wurden <em>viel</em> l√§nger blockiert.  Der einzige Grund daf√ºr, dass der Wert f√ºr " <em>Zeit seit dem letzten Mal"</em> ungef√§hr 41,5 Sekunden betr√§gt, ist, dass die L√§nge der Ablaufverfolgung vor dem Aufl√∂sen des Hangs behoben wurde. <br><br>  Es scheint, dass die Ergebnisse mit der Theorie <em>√ºbereinstimmen</em> , dass sich das Problem in <em>WinMgmt.exe befindet</em> , aber sie beweisen es nicht.  Mein Selbstvertrauen nahm zu, als ich mir <em>svchost.exe (3024)</em> unter <em>Trace-&gt; System Configuration-&gt; Services ansah</em> und feststellte, dass es sich um einen <em>Winmgmt-</em> Dienst handelt, aber ich brauchte noch mehr Sicherheit. <br><br>  Nachdem ich ein bisschen weiter gew√ºhlt hatte (in der Zeit vorw√§rts und r√ºckw√§rts gewandert), entschied ich, dass die Interaktionen zu kompliziert sind, um sie im Detail zu analysieren, insbesondere ohne <em>Streamnamen</em> , die darauf hindeuten k√∂nnten, was 25 verschiedene Threads in <em>svchost.exe (3024)</em> tun. <br><br><h2>  Beweis! </h2><br>  Dann habe ich mich entschieden, <em>WinMgmt.exe</em> schuldbeweis anders <em>anzusprechen</em> .  Vielleicht hat es sich gelohnt, damit anzufangen, aber es w√§re zu einfach.  Ich habe die Befehlszeile <em>WinMgmt.exe</em> aus der <em>Prozesstabelle</em> in WPA genommen und sie manuell gestartet.  Der Befehl hat die Form: <br><br><blockquote>  winmgmt.exe / verifyrepository </blockquote><br>  und es dauerte ungef√§hr f√ºnf Minuten, um fertig zu sein.  W√§hrend es funktionierte (und ich viel Zeit hatte), stellte ich fest, dass ich den ETW-Trace nicht √ºber <em>UIforETW starten konnte</em> .  Solche Beweise waren besser als jede komplizierte Analyse, die ich durchf√ºhren konnte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/c6f/d64/1a0c6fd64820226eddd120b5e9ab2ab7.png"></div><br>  <i>Konfiguration, um nur lange ruhende Threads anzuzeigen</i> <br><br>  Dann habe ich den Repro erneut ausgef√ºhrt, wobei die Ablaufverfolgung bereits ausgef√ºhrt wurde.  Nach der Analyse der Ablaufverfolgung entdeckte ich mehr als <em>hundert</em> Prozesse, deren Threads l√§nger als <em>f√ºnf Minuten</em> blockiert waren <em>!</em> <br><br><h2>  Und nochmal auf den Punkt ... </h2><br>  Aus Gewohnheit schaute ich mir noch einmal die CPU-Auslastungsdaten (Sampled) an, um <em>festzustellen,</em> auf welche Weise <em>WinMgmt.exe Zeit</em> verschwendete.  Ich habe schnell herausgefunden, dass 96,5% der Samples in <em>repdrvfs.dll! CPageCache :: Read () enthalten sind</em> und vier verschiedene Stacks aufgerufen haben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/7d9/5f1/5447d95f1b431681cdd83ad42df7e731.png"></div><br>  <i>Vier Wege, die mich zu CPageCache :: Read f√ºhrten</i> <br><br>  Hier wird ein Baum mit vollst√§ndigen Stapeln f√ºr diese Funktion angezeigt, haupts√§chlich f√ºr Personen von Microsoft, die dieses Problem untersuchen m√∂chten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e6/6b3/519/0e66b35191db016e98ded6eb08445569.png"></div><br>  <i>Vollst√§ndige Stapel, die zu CPageCache :: Read f√ºhren</i> <br><br>  Ich habe eine Adressenspalte hinzugef√ºgt und festgestellt, dass sich 95,3% der Stichproben in einem Zyklus von neun Anweisungen befanden (Stichproben gingen immer nur in sieben von neun Anweisungen ein (wenn Sie wissen m√∂chten, warum, siehe <a href="https://travisdowns.github.io/blog/2019/08/20/interrupts.html" rel="nofollow">hier</a> ), aber der Debugger zeigte die volle Gr√∂√üe des Zyklus an). : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/8e6/04a/ecf8e604adbd110fdfaf77bb87dd378a.png"></div><br>  <i>Proben nach Adresse - sieben sehr ‚Äûhei√üe‚Äú Adressen</i> <br><br>  Dann habe ich <em>winmgmt.exe / verifyrepository</em> manuell gestartet und <em>gleichzeitig</em> <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">CPU-</a> <em>Z√§hlerdaten</em> <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">√ºber die ausgef√ºhrten Verzweigungsanweisungen gesammelt</a> .  Daraus konnte ich ungef√§hr herausfinden, wie oft die Schleife lief.  Dies war wahrscheinlich nicht notwendig, aber ich wollte sicherstellen, dass die Schleife viele Male ausgef√ºhrt wurde und nicht langsam (aus irgendeinem Grund).  Ich fand es sehr cool, dass ich es einfach machen kann, nur eine <a href="" rel="nofollow">winzige √Ñnderung</a> an der Batch-Datei vornehmen.  Ich fand heraus, dass <em>WinMgmt.exe</em> ungef√§hr eine Verzweigungsanweisung pro Zyklus ausf√ºhrte, das hei√üt, der Zyklus (der, wie ich bereits wusste, den gr√∂√üten Teil der CPU-Zeit in Anspruch nahm) war extrem schnell und die Verlangsamung lag an der Tatsache, dass er Hunderte von Millionen lief mal. <br><br><h2>  Xperf-Verz√∂gerung </h2><br>  Aus Gr√ºnden der Akribie habe ich mich entschlossen, <em>herauszufinden,</em> warum <em>UIforETW</em> w√§hrend dieses Vorfalls nicht mit der Verfolgung <em>beginnen</em> konnte.  Es <em>stellte sich</em> heraus, dass <em>UIforETW xperf</em> <em>ausf√ºhrte</em> , aber <em>xperf</em> in diesem Aufrufstapel 41,5 Sekunden (tats√§chlich l√§nger) im Leerlauf war: <br><br><blockquote>  xperf.exe! wmain <br>  xperf.exe! CStopTrace :: Execute <br>  perfctrl.dll! LoggingSession :: EnumLoggers <br>  perfctrl.dll! LoggingSession :: LoggingSession <br>  perfctrl.dll! LoggingSession :: CreateProviderList <br>  perfctrl.dll! GetProviderInfoCache <br>  perfctrl.dll! CProviderInfoCache :: CProviderInfoCache <br>  tdh.dll! TdhfEnumerateProviders <br>  tdh.dll! TdhpWbemConnect <br>  wbemprox.dll! CLocator :: ConnectServer <br>  wbemprox.dll! CDCOMTrans :: DoActualConnection </blockquote><br>  Kurz gesagt, <em>xperf</em> wird von <em>Wbem aufgerufen</em> und daher von diesem Problem blockiert.  <em>xperf</em> versucht, die Ablaufverfolgung vor dem Starten zu stoppen, da ich dieses Verhalten hinzugef√ºgt habe, um den <a href="https://github.com/google/UIforETW/commit/092fa4d3c30137eca658a86d58fc8230ced56c7c" rel="nofollow">Start der Ablaufverfolgung fehlertoleranter zu gestalten</a> .  Ich vermute, dass immer noch ein Hang auftritt, wei√ü es aber nicht genau. <br><br><h2>  Wir erstellen Graphen von rechnerischer Komplexit√§t </h2><br>  Ich habe festgestellt, dass <em>WinMgmt.exe</em> das <em>Verzeichnis</em> <em>c: \ windows \ System32 \ wbem \ Repository</em> durchsucht, das sich auf meinem Computer auf 1,9 GB befindet. <em>Daher</em> habe ich bei der Arbeit und auf Twitter gefragt, wie viel dieses Verzeichnis zum Abrufen von Datenpunkten ben√∂tigt.  Ich habe auch Leute gebeten, die Laufzeit von <em>winmgmt.exe / verifyrepository</em> zu <em>korrigieren,</em> und mit dem <em>Planen</em> begonnen.  Obwohl diese Tests auf v√∂llig unterschiedlichen Rechnern mit unterschiedlichen CPU-Geschwindigkeiten durchgef√ºhrt wurden, stellte sich heraus, dass das Diagramm ziemlich klar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/dd8/23d/539dd823d7fb9b33df39dc61f9e183dd.png"></div><br>  <i>Die Beziehung zwischen der Quadratwurzel der Zeit und der Gr√∂√üe des Repositorys</i> <br><br>  Dieses Diagramm des Verh√§ltnisses von sqrt (Zeit) zur Repository-Gr√∂√üe ist unglaublich ideal f√ºr Daten, die von sechs verschiedenen Computern empfangen werden, und es ist dennoch real.  Offensichtlich hat die <em>VerifyRepository-</em> Funktion die Leistung von O (n <sup>2</sup> ).  Wenn n die Gr√∂√üe des Repository-Verzeichnisses in <a href="https://randomascii.wordpress.com/2016/02/13/base-ten-for-almost-everything/" rel="nofollow">GB ist</a> , dauert <em>VerifyRepository</em> ca. 1,6 * n <sup>2</sup> Minuten.  Dies ist eine gute grobe Sch√§tzung f√ºr alle Werte - von einem Sekundenbruchteil bis zu zehn Minuten. <br><br><h2>  Relevanz </h2><br>  Entweder habe ich Gl√ºck oder ich bin nur wachsam, weil seit ein paar Wochen niemand mehr auf dieses Problem gesto√üen ist - ich dachte, mit meinem Auto passieren seltsame Dinge.  Aber pl√∂tzlich h√∂rte ich verd√§chtig √§hnliche Beschwerden von Kollegen.  Einer von ihnen verf√ºgte √ºber ein 2,6-GB-Repository, dessen √úberpr√ºfung zehn Minuten in Anspruch nahm.  Das Problem betraf einige unserer <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">CI-</a> Entwickler und in unterschiedlichem Ma√üe auch andere Personen.  Meine Kollegen wissen normalerweise, dass ich im Falle von Problemen mit der Leistung von Windows-Computern das sagen muss. Es gibt jedoch wahrscheinlich viele andere Google-Mitarbeiter, die unter Windows arbeiten und durch diesen Fehler verhindert werden, aber sie erkennen dies nicht. <br><br>  Zum Gl√ºck habe ich bereits angefangen, mit unserer IT-Abteilung zu arbeiten.  Ich habe das Skript gefunden, mit dem <em>WinMgmt</em> gestartet <em>wurde,</em> und festgestellt, dass es st√ºndlich ausgef√ºhrt wird.  Dies bedeutete, dass auf meinem <em>Computer</em> 10% der Zeit <em>WinMgmt.exe / verifyrepository ausgef√ºhrt</em> wurde und einige meiner Kollegen √ºber 16% der Zeit verf√ºgten.  Es besteht eine relativ hohe Wahrscheinlichkeit, dass sich die Montage um zehn Minuten verz√∂gert. <br><br>  Als die Berichte eintrafen, war der Fix bereits auf dem Weg zur Produktion.  Das Skript war optional und die verursachten Probleme auf keinen Fall wert. Daher bestand die L√∂sung darin, den Aufruf zu deaktivieren. <br><br><h2>  Zusammenfassung </h2><br>  <em>winmgmt.exe / verifyrepository</em> enth√§lt einen Zyklus von neun Befehlen, deren Anzahl der Ausf√ºhrungsiterationen proportional zum Quadrat der Gr√∂√üe des <em>wbem-Repositorys ist</em> .  Aus diesem Grund kann die Ausf√ºhrung des Befehls bis zu zehn Minuten dauern, obwohl sie in der Realit√§t in wenigen Sekunden ausgef√ºhrt werden sollte.  Das ist schlecht f√ºr sich. <br><br>  Noch schlimmer ist, dass das Team w√§hrend des Betriebs eine WMI-Sperre ( <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page" rel="nofollow">Windows Management Instrumentation</a> ) durchf√ºhrt, sodass alle Prozesse, die WMI-Vorg√§nge ausf√ºhren, einfrieren. <br><br><h2>  Erstaunliche R√§tsel </h2><br>  Das Skript, <em>das winmgmt.exe / verifyrepository</em> st√ºndlich ausf√ºhrte, tat dies viele Jahre lang, aber problematisches Verhalten trat erst vor ein bis zwei Monaten auf.  Dies bedeutet vermutlich, dass das wbem-Repository in letzter Zeit viel gr√∂√üer geworden ist.  Verz√∂gerungen bei 0,5 GB sind leicht zu √ºbersehen, ab 1,0 GB k√∂nnen sie jedoch bereits anstrengend sein.  Wie <a href="https://twitter.com/itoleck/status/1192647636085592069" rel="nofollow">auf Twitter vorgeschlagen, habe</a> ich strings.exe f√ºr die Datei objects.data ausgef√ºhrt.  Viele der gebr√§uchlichsten Zeichenfolgen enthalten polmkr im Namen, aber ich wei√ü nicht, was das bedeutet. <br><br>  Ich <a href="https://twitter.com/BruceDawson0xB/status/1189979046135750657" rel="nofollow">habe auf Twitter einen Fehlerbericht ver√∂ffentlicht</a> , der zun√§chst <a href="https://twitter.com/djammmer/status/1192634563421495297" rel="nofollow">einige Bewegungen des WMI-Teams verursachte</a> , dann jedoch keine Antworten mehr erhielt. Daher wei√ü ich nicht, wie es jetzt aussieht. <br><br>  Ich w√ºrde gerne eine L√∂sung f√ºr das Leistungsproblem finden, und ich m√∂chte, dass unsere IT-Abteilung in der Lage ist, das Problem zu finden und zu beheben, das unsere wbem-Repositorys so gro√ü macht.  Derzeit hat die IT-Abteilung jedoch zugesagt, den Befehl / verifyrepository nicht mehr st√ºndlich auszuf√ºhren, um die schlimmsten Symptome zu vermeiden. <br><br><h2>  Referenzen </h2><br><ul><li>  Eine allgemeine Liste von ETW-Tutorials, Untersuchungen und Dokumentationen finden Sie hier: <a href="https://tinyurl.com/etwcentral" rel="nofollow">https://tinyurl.com/etwcentral</a> </li><li>  Das Tutorial zur CPU-Auslastung (Sampled) (um herauszufinden, wof√ºr die CPU-Zeit aufgewendet wird) und die Dokumentation finden Sie <a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/" rel="nofollow">hier.</a> </li><li>  Das Lernprogramm zur CPU-Auslastung (Pr√§zise) (aus Gr√ºnden, aus denen Threads nicht ausgef√ºhrt werden k√∂nnen) und die Dokumentation finden Sie <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">hier.</a> </li><li>  Links zu einzelnen Artikeln finden Sie im Hauptteil des Beitrags. Sie finden sie auch in meiner Kategorie " <a href="https://randomascii.wordpress.com/category/investigative-reporting/" rel="nofollow">Berichterstattung untersuchen"</a> </li><li>  Andere Geschichten √ºber O (n <sup>2</sup> ) -Algorithmen k√∂nnen auf <a href="https://accidentallyquadratic.tumblr.com/" rel="nofollow">Accidentally Quadratic</a> nachgelesen werden </li></ul><br>  Eine Diskussion des Artikels √ºber Reddit ist <a href="https://www.reddit.com/r/programming/comments/e87dpb/on2_again_now_in_wmi/" rel="nofollow">hier</a> , eine Diskussion √ºber Hacker-News ist <a href="https://news.ycombinator.com/item%3Fid%3D21743424" rel="nofollow">hier</a> , ein Thread auf Twitter ist <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">hier</a> und m√∂glicherweise <a href="https://twitter.com/BruceDawson0xB/status/1203922370957721600" rel="nofollow">hier</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479498/">https://habr.com/ru/post/de479498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479482/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479486/index.html">Heterogene Programmierung und oneAPI Toolkit. Der improvisierte Vortrag von Intel-Experten beantwortet Ihre Fragen</a></li>
<li><a href="../de479488/index.html">Von einem Laptop - ein Heimserver mit redundanter Stromversorgung f√ºr den Mikrotik-Router</a></li>
<li><a href="../de479492/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 3</a></li>
<li><a href="../de479496/index.html">Analysieren von WTF-Aufgaben in JavaScript</a></li>
<li><a href="../de479502/index.html">Wie √ºberlebt man die schwerste Eiszeit der Erdgeschichte?</a></li>
<li><a href="../de479504/index.html">Erstellen Sie einen auf Raspberry Pi basierenden RDP Thin Client</a></li>
<li><a href="../de479508/index.html">PostgreSQL Antipatterns: sch√§dliche JOINs und ORs</a></li>
<li><a href="../de479510/index.html">PocketBook X Test - ein riesiges 10,3-Zoll-Leseger√§t mit einem E-Ink-Carta-Mobius-Bildschirm und einem Metallgeh√§use</a></li>
<li><a href="../de479512/index.html">MVCC in PostgreSQL-4. Schnappsch√ºsse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>