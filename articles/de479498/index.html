<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏿 🏐 📼 Wie aus linearer Zeit Windows in O (n²) wird 👳🏿 🚡 🍞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich hatte vor kurzem mehrere Minuten Verspätung auf meiner Workstation. Nach der Untersuchung stellte sich heraus, dass die Ursache des Problems eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie aus linearer Zeit Windows in O (n²) wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479498/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png" alt="Bild"></div><br>  Ich hatte vor kurzem mehrere Minuten Verspätung auf meiner Workstation.  Nach der Untersuchung stellte sich heraus, dass die Ursache des Problems eine Sperre war, die fünf Minuten dauern konnte, während der die Quelle der Sperre im Grunde genommen in einem Zyklus von neun Anweisungen drehte. <br><br>  Es ist sehr wichtig für mich, gute Überschriften für meine Posts auszuwählen, aber ich erinnerte mich sofort, dass der entsprechende Name "48 Cores sind durch neun Anweisungen blockiert" <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">bereits</a> von einem Post vor weniger als einem Monat übernommen wurde.  Die Anzahl der blockierten Prozessoren ist unterschiedlich und der Zyklus ist etwas länger, aber in der Tat führt dies dazu, dass Sie Deja Vu erleben.  Daher wollte ich, während ich das neu entdeckte Problem erläutere, darüber nachdenken, <em>warum dies die ganze Zeit passiert</em> . <br><br><h2>  Warum passiert das? </h2><br>  Grob gesagt ergeben sich solche Probleme aus einer Beobachtung, die ich <em>Dawsons erstes Gesetz zum Rechnen nennen werde:</em> <a href="https://twitter.com/BruceDawson0xB/status/1120381406700429312" rel="nofollow">O (n <sup>2</sup> ) ist ein Magnet für Algorithmen, die sich nicht gut skalieren lassen</a> : Sie sind schnell genug, um in Produktion zu gehen, aber langsam genug, um alles zu verderben. wenn sie dort ankommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/017/fb8/bea017fb89b90af6566d8ad77298efb9.png"></div><br>  <i>O (n <sup>2</sup> ) in Aktion - Daten aus meinem Fall</i> <br><a name="habracut"></a><br>  Was ist los?  Der Entwickler schreibt den Code und verwendet den O (n <sup>2</sup> ) -Algorithmus.  Vielleicht merkt er das nicht, oder der Algorithmus wird <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">aufgrund eines Fehlers</a> zu O (n <sup>2</sup> ), oder der Entwickler weiß, dass er O (n <sup>2</sup> ) ist, aber er denkt, dass es niemals wichtig sein wird.  Unter Laborbedingungen ist die Codegeschwindigkeit akzeptabel und für die meisten Benutzer in der realen Welt akzeptabel. Dann erstellt jemand <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">7.000 Prozesse</a> mit aktiviertem App Verifier oder erstellt eine <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">Binärdatei mit 180.000 CFG-Elementen</a> oder sammelt eine so große DLL, dass sie <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">ständig vorhanden ist Es wird eine einfach verknüpfte Liste durchsucht</a> , die den gesamten Prozessor erfasst.  Als ich an der Startzeit des Valve Source 2-Motors arbeitete, fand ich <em>viele</em> O (n <sup>2</sup> ) -Algorithmen, von denen jeder etwa 30 Sekunden zur Startzeit des Motors beitrug, dh, dieses Problem tritt bei sehr unterschiedlichen Entwicklern auf. <br><br>  <em>O (n <sup>2</sup> ) ist ein Magnet für Algorithmen, die nicht gut skalieren: Sie sind schnell genug, um in Produktion zu gehen, aber langsam genug, um alles zu verderben, wenn sie dort ankommen.</em> <br><br>  Genau. <br><br>  Beispielsweise wird die <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">Erstellung von App Verifier-Protokolldateinamen</a> für jeden ausgeführten Prozess <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">in linearer Zeit</a> ausgeführt. Dies ist normal, bis Sie feststellen, dass dies zu O (n <sup>2</sup> ) führt, wenn viele Prozesse ausgeführt werden.  Manchmal ist es nicht einmal offensichtlich, dass es verschachtelte Schleifen gibt, oder <em>formal ist</em> es nicht O (n <sup>2</sup> ), oder es ist nicht offensichtlich, dass die Schleifen so lange laufen können, dass sie die Geschwindigkeit erheblich beeinflussen können ... <br><br>  Nutzen Sie diese Gelegenheit, denken Sie beim Schreiben von Code darüber nach, überwachen Sie, wie die Leistung unter hohen Lasten skaliert wird, und untersuchen Sie verdächtige Codeabschnitte, wenn Sie ein Profil für solch hohe Lasten erstellen.  Oder überlasse es mir, damit ich danach suchen und Artikel in meinem Blog schreiben kann. <br><br><h2>  Kehren wir zu unseren üblichen Beschwerden zurück </h2><br>  Wie üblich habe ich an meiner veralteten, aber immer noch leistungsstarken Workstation mit 48 logischen Prozessoren und 96 GB RAM gearbeitet.  Ich habe <em>Ninja Chrome eingeführt</em> , um Chromium zu bauen, aber ... nichts ist passiert.  Ich habe nachgesehen und 20 Sekunden gewartet, aber die Montage hat nie begonnen.  Deshalb bin ich natürlich zu <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>UIforETW gewechselt</em></a> , um die <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/" rel="nofollow"><em>ETW-</em></a> Spur aufzuzeichnen.  Genauer gesagt habe ich es versucht.  Beim Versuch, die Trace-Aufzeichnung zu starten, <em>friert UIforETW ein</em> .  Zum ersten Mal in meiner Praxis verwendete ein Käfer Schutzmaßnahmen, um mich daran zu hindern, ihn zu erforschen! <br><br>  Nach ein oder zwei Minuten begann die Montage von Chromium, und <em>UIforETW</em> startete die Ablaufverfolgung, aber es begann zu spät und ich hatte nicht die geringste Information darüber, was passiert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/76e/b86/48576eb86c46f3254d1b891d180cc25e.png"></div><br>  <i>UIforETW-Optionen mit ausgewähltem Circular Buffer Tracing</i> <br><br>  Als dasselbe ein paar Tage später <em>passierte, war UIforETW</em> wieder nicht in der Lage, irgendetwas zu tun.  Dieses Mal habe ich die Spur verlassen, um in kreisförmigen Speicherpuffern zu arbeiten, um auf die Tatsache vorbereitet zu sein, dass der Hang zum dritten Mal auftreten würde.  Dies verringerte jedoch die Geschwindigkeit meiner Build-Tools erheblich, sodass ich nach einigen Stunden aufgab. <br><br>  Dann wiederholte sich diese Situation <em>erneut</em> .  Dieses Mal habe ich das von Microsoft - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>wprui</em></a> erstellte ETW - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>Traceprotokollierungstool ausgeführt</em></a> und konnte mit der Aufzeichnung beginnen.  Ungefähr 40 Sekunden später begann die Montage und ich bekam eine Spur! <br><br><h2>  Kann ich jetzt mit der Untersuchung beginnen? </h2><br>  Früher bemerkte ich im "Task-Manager", dass <em>WinMgmt.exe</em> während dieser <em>Einfrierungen ausgeführt wurde</em> .  Als ich mir die CPU-Auslastungsdaten in WPA <em>ansah,</em> war ich überzeugt, dass nach mehr als vierzig Sekunden, in denen <em>WinMgmt.exe</em> fast der einzige Arbeitsprozess war, mein Computer nach dem <em>Herunterfahren von WinMgmt.exe</em> zum Leben <em>erweckt</em> wurde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/cd4/35d/02acd435d1b3dec571ae9ebb5b56b67a.png"></div><br>  <i>Wir warten auf das Erwachen von Prozessen, nachdem WinMgmt.exe abgeschlossen ist</i> <br><br>  All dies ist ziemlich verdächtig, aber meine weisen Leser wissen, dass "danach" nicht "aufgrund" bedeutet und dass Beweise erforderlich sind. <br><br>  Wie beim <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">letzten Mal habe</a> ich den Moment des Entsperrens im Diagramm angenähert, die Kontextwechsel nach <em>Einschaltzeit</em> sortiert und nach dem ersten Schalter mit einem langen Wert für " <em>Zeit seit letztem"</em> gesucht (der angibt, wie lange der Thread nicht ausgeführt wurde).  Nachdem ich ein Dutzend Threads verpasst hatte, bei denen es sich nur um kurze Ausfallzeiten handelte, fand ich den ersten von vielen, der 41,57 Sekunden wartete.  Der schlafende Thread hat <em>WinMgmt.exe</em> nicht <em>aufgeweckt</em> , aber ich fand schnell heraus, dass er mit dem Thread aufgewacht ist, der <em>WinMgmt.exe</em> einen Bruchteil einer Millisekunde zuvor <em>aufgeweckt hat</em> . <br><br><blockquote>  Eine Erläuterung der Diagramme zur CPU-Auslastung (präzise) und der Konzepte für vorbereitende Threads / neue Threads finden Sie in <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">diesem Lernprogramm</a> oder in <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">dieser Dokumentation</a> . </blockquote><br>  Im Screenshot mit den <em>Inhaltsumschaltdaten</em> enthält Zeile 17 den Stream <em>72.748 (WinMgmt.exe)</em> , der den Stream <em>74.156 (svchost.exe)</em> aktiviert <em>.</em>  In Zeile 19 aktiviert der Thread <em>74.156 (svchost.exe) den</em> Thread <em>58.704 (svchost.exe)</em> , der auf 41,57 Sekunden gewartet hat.  Dies ist der erste Faden, der nach einem langen Schlaf aufwacht und von diesem die Kette der Aktivierung von Flüssen fortsetzt.  Gerade aktivierte Threads werden in der Spalte " <em>Neue Thread-</em> <em>ID" angezeigt.</em> Gehen Sie einige Zeilen nach unten und sehen Sie sie in der <em>Spalte "Thread-ID bereitstellen"</em> , um einen anderen Thread zu aktivieren.  Die Namen und Prozess-IDs helfen Ihnen, den Kontext zu verstehen.  Zeile 17 ist den Zeilen 18 und 19 zugeordnet, Zeile 19 ist 20 zugeordnet, die der Zeile 23 zugeordnet ist, die der Zeile 27 zugeordnet ist, und so weiter;  Jeder Thread wird durch den vorherigen Thread in der Kette aktiviert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png"></div><br>  <i>Das Monster erwacht - lange, leere Fäden werden lebendig</i> <br><br>  41.57 ist eine lange Zeit, um einen Thread zu blockieren, aber in Wirklichkeit wurden Hunderte von Threads blockiert und sie wurden <em>viel</em> länger blockiert.  Der einzige Grund dafür, dass der Wert für " <em>Zeit seit dem letzten Mal"</em> ungefähr 41,5 Sekunden beträgt, ist, dass die Länge der Ablaufverfolgung vor dem Auflösen des Hangs behoben wurde. <br><br>  Es scheint, dass die Ergebnisse mit der Theorie <em>übereinstimmen</em> , dass sich das Problem in <em>WinMgmt.exe befindet</em> , aber sie beweisen es nicht.  Mein Selbstvertrauen nahm zu, als ich mir <em>svchost.exe (3024)</em> unter <em>Trace-&gt; System Configuration-&gt; Services ansah</em> und feststellte, dass es sich um einen <em>Winmgmt-</em> Dienst handelt, aber ich brauchte noch mehr Sicherheit. <br><br>  Nachdem ich ein bisschen weiter gewühlt hatte (in der Zeit vorwärts und rückwärts gewandert), entschied ich, dass die Interaktionen zu kompliziert sind, um sie im Detail zu analysieren, insbesondere ohne <em>Streamnamen</em> , die darauf hindeuten könnten, was 25 verschiedene Threads in <em>svchost.exe (3024)</em> tun. <br><br><h2>  Beweis! </h2><br>  Dann habe ich mich entschieden, <em>WinMgmt.exe</em> schuldbeweis anders <em>anzusprechen</em> .  Vielleicht hat es sich gelohnt, damit anzufangen, aber es wäre zu einfach.  Ich habe die Befehlszeile <em>WinMgmt.exe</em> aus der <em>Prozesstabelle</em> in WPA genommen und sie manuell gestartet.  Der Befehl hat die Form: <br><br><blockquote>  winmgmt.exe / verifyrepository </blockquote><br>  und es dauerte ungefähr fünf Minuten, um fertig zu sein.  Während es funktionierte (und ich viel Zeit hatte), stellte ich fest, dass ich den ETW-Trace nicht über <em>UIforETW starten konnte</em> .  Solche Beweise waren besser als jede komplizierte Analyse, die ich durchführen konnte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/c6f/d64/1a0c6fd64820226eddd120b5e9ab2ab7.png"></div><br>  <i>Konfiguration, um nur lange ruhende Threads anzuzeigen</i> <br><br>  Dann habe ich den Repro erneut ausgeführt, wobei die Ablaufverfolgung bereits ausgeführt wurde.  Nach der Analyse der Ablaufverfolgung entdeckte ich mehr als <em>hundert</em> Prozesse, deren Threads länger als <em>fünf Minuten</em> blockiert waren <em>!</em> <br><br><h2>  Und nochmal auf den Punkt ... </h2><br>  Aus Gewohnheit schaute ich mir noch einmal die CPU-Auslastungsdaten (Sampled) an, um <em>festzustellen,</em> auf welche Weise <em>WinMgmt.exe Zeit</em> verschwendete.  Ich habe schnell herausgefunden, dass 96,5% der Samples in <em>repdrvfs.dll! CPageCache :: Read () enthalten sind</em> und vier verschiedene Stacks aufgerufen haben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/7d9/5f1/5447d95f1b431681cdd83ad42df7e731.png"></div><br>  <i>Vier Wege, die mich zu CPageCache :: Read führten</i> <br><br>  Hier wird ein Baum mit vollständigen Stapeln für diese Funktion angezeigt, hauptsächlich für Personen von Microsoft, die dieses Problem untersuchen möchten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e6/6b3/519/0e66b35191db016e98ded6eb08445569.png"></div><br>  <i>Vollständige Stapel, die zu CPageCache :: Read führen</i> <br><br>  Ich habe eine Adressenspalte hinzugefügt und festgestellt, dass sich 95,3% der Stichproben in einem Zyklus von neun Anweisungen befanden (Stichproben gingen immer nur in sieben von neun Anweisungen ein (wenn Sie wissen möchten, warum, siehe <a href="https://travisdowns.github.io/blog/2019/08/20/interrupts.html" rel="nofollow">hier</a> ), aber der Debugger zeigte die volle Größe des Zyklus an). : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/8e6/04a/ecf8e604adbd110fdfaf77bb87dd378a.png"></div><br>  <i>Proben nach Adresse - sieben sehr „heiße“ Adressen</i> <br><br>  Dann habe ich <em>winmgmt.exe / verifyrepository</em> manuell gestartet und <em>gleichzeitig</em> <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">CPU-</a> <em>Zählerdaten</em> <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">über die ausgeführten Verzweigungsanweisungen gesammelt</a> .  Daraus konnte ich ungefähr herausfinden, wie oft die Schleife lief.  Dies war wahrscheinlich nicht notwendig, aber ich wollte sicherstellen, dass die Schleife viele Male ausgeführt wurde und nicht langsam (aus irgendeinem Grund).  Ich fand es sehr cool, dass ich es einfach machen kann, nur eine <a href="" rel="nofollow">winzige Änderung</a> an der Batch-Datei vornehmen.  Ich fand heraus, dass <em>WinMgmt.exe</em> ungefähr eine Verzweigungsanweisung pro Zyklus ausführte, das heißt, der Zyklus (der, wie ich bereits wusste, den größten Teil der CPU-Zeit in Anspruch nahm) war extrem schnell und die Verlangsamung lag an der Tatsache, dass er Hunderte von Millionen lief mal. <br><br><h2>  Xperf-Verzögerung </h2><br>  Aus Gründen der Akribie habe ich mich entschlossen, <em>herauszufinden,</em> warum <em>UIforETW</em> während dieses Vorfalls nicht mit der Verfolgung <em>beginnen</em> konnte.  Es <em>stellte sich</em> heraus, dass <em>UIforETW xperf</em> <em>ausführte</em> , aber <em>xperf</em> in diesem Aufrufstapel 41,5 Sekunden (tatsächlich länger) im Leerlauf war: <br><br><blockquote>  xperf.exe! wmain <br>  xperf.exe! CStopTrace :: Execute <br>  perfctrl.dll! LoggingSession :: EnumLoggers <br>  perfctrl.dll! LoggingSession :: LoggingSession <br>  perfctrl.dll! LoggingSession :: CreateProviderList <br>  perfctrl.dll! GetProviderInfoCache <br>  perfctrl.dll! CProviderInfoCache :: CProviderInfoCache <br>  tdh.dll! TdhfEnumerateProviders <br>  tdh.dll! TdhpWbemConnect <br>  wbemprox.dll! CLocator :: ConnectServer <br>  wbemprox.dll! CDCOMTrans :: DoActualConnection </blockquote><br>  Kurz gesagt, <em>xperf</em> wird von <em>Wbem aufgerufen</em> und daher von diesem Problem blockiert.  <em>xperf</em> versucht, die Ablaufverfolgung vor dem Starten zu stoppen, da ich dieses Verhalten hinzugefügt habe, um den <a href="https://github.com/google/UIforETW/commit/092fa4d3c30137eca658a86d58fc8230ced56c7c" rel="nofollow">Start der Ablaufverfolgung fehlertoleranter zu gestalten</a> .  Ich vermute, dass immer noch ein Hang auftritt, weiß es aber nicht genau. <br><br><h2>  Wir erstellen Graphen von rechnerischer Komplexität </h2><br>  Ich habe festgestellt, dass <em>WinMgmt.exe</em> das <em>Verzeichnis</em> <em>c: \ windows \ System32 \ wbem \ Repository</em> durchsucht, das sich auf meinem Computer auf 1,9 GB befindet. <em>Daher</em> habe ich bei der Arbeit und auf Twitter gefragt, wie viel dieses Verzeichnis zum Abrufen von Datenpunkten benötigt.  Ich habe auch Leute gebeten, die Laufzeit von <em>winmgmt.exe / verifyrepository</em> zu <em>korrigieren,</em> und mit dem <em>Planen</em> begonnen.  Obwohl diese Tests auf völlig unterschiedlichen Rechnern mit unterschiedlichen CPU-Geschwindigkeiten durchgeführt wurden, stellte sich heraus, dass das Diagramm ziemlich klar ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/dd8/23d/539dd823d7fb9b33df39dc61f9e183dd.png"></div><br>  <i>Die Beziehung zwischen der Quadratwurzel der Zeit und der Größe des Repositorys</i> <br><br>  Dieses Diagramm des Verhältnisses von sqrt (Zeit) zur Repository-Größe ist unglaublich ideal für Daten, die von sechs verschiedenen Computern empfangen werden, und es ist dennoch real.  Offensichtlich hat die <em>VerifyRepository-</em> Funktion die Leistung von O (n <sup>2</sup> ).  Wenn n die Größe des Repository-Verzeichnisses in <a href="https://randomascii.wordpress.com/2016/02/13/base-ten-for-almost-everything/" rel="nofollow">GB ist</a> , dauert <em>VerifyRepository</em> ca. 1,6 * n <sup>2</sup> Minuten.  Dies ist eine gute grobe Schätzung für alle Werte - von einem Sekundenbruchteil bis zu zehn Minuten. <br><br><h2>  Relevanz </h2><br>  Entweder habe ich Glück oder ich bin nur wachsam, weil seit ein paar Wochen niemand mehr auf dieses Problem gestoßen ist - ich dachte, mit meinem Auto passieren seltsame Dinge.  Aber plötzlich hörte ich verdächtig ähnliche Beschwerden von Kollegen.  Einer von ihnen verfügte über ein 2,6-GB-Repository, dessen Überprüfung zehn Minuten in Anspruch nahm.  Das Problem betraf einige unserer <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">CI-</a> Entwickler und in unterschiedlichem Maße auch andere Personen.  Meine Kollegen wissen normalerweise, dass ich im Falle von Problemen mit der Leistung von Windows-Computern das sagen muss. Es gibt jedoch wahrscheinlich viele andere Google-Mitarbeiter, die unter Windows arbeiten und durch diesen Fehler verhindert werden, aber sie erkennen dies nicht. <br><br>  Zum Glück habe ich bereits angefangen, mit unserer IT-Abteilung zu arbeiten.  Ich habe das Skript gefunden, mit dem <em>WinMgmt</em> gestartet <em>wurde,</em> und festgestellt, dass es stündlich ausgeführt wird.  Dies bedeutete, dass auf meinem <em>Computer</em> 10% der Zeit <em>WinMgmt.exe / verifyrepository ausgeführt</em> wurde und einige meiner Kollegen über 16% der Zeit verfügten.  Es besteht eine relativ hohe Wahrscheinlichkeit, dass sich die Montage um zehn Minuten verzögert. <br><br>  Als die Berichte eintrafen, war der Fix bereits auf dem Weg zur Produktion.  Das Skript war optional und die verursachten Probleme auf keinen Fall wert. Daher bestand die Lösung darin, den Aufruf zu deaktivieren. <br><br><h2>  Zusammenfassung </h2><br>  <em>winmgmt.exe / verifyrepository</em> enthält einen Zyklus von neun Befehlen, deren Anzahl der Ausführungsiterationen proportional zum Quadrat der Größe des <em>wbem-Repositorys ist</em> .  Aus diesem Grund kann die Ausführung des Befehls bis zu zehn Minuten dauern, obwohl sie in der Realität in wenigen Sekunden ausgeführt werden sollte.  Das ist schlecht für sich. <br><br>  Noch schlimmer ist, dass das Team während des Betriebs eine WMI-Sperre ( <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page" rel="nofollow">Windows Management Instrumentation</a> ) durchführt, sodass alle Prozesse, die WMI-Vorgänge ausführen, einfrieren. <br><br><h2>  Erstaunliche Rätsel </h2><br>  Das Skript, <em>das winmgmt.exe / verifyrepository</em> stündlich ausführte, tat dies viele Jahre lang, aber problematisches Verhalten trat erst vor ein bis zwei Monaten auf.  Dies bedeutet vermutlich, dass das wbem-Repository in letzter Zeit viel größer geworden ist.  Verzögerungen bei 0,5 GB sind leicht zu übersehen, ab 1,0 GB können sie jedoch bereits anstrengend sein.  Wie <a href="https://twitter.com/itoleck/status/1192647636085592069" rel="nofollow">auf Twitter vorgeschlagen, habe</a> ich strings.exe für die Datei objects.data ausgeführt.  Viele der gebräuchlichsten Zeichenfolgen enthalten polmkr im Namen, aber ich weiß nicht, was das bedeutet. <br><br>  Ich <a href="https://twitter.com/BruceDawson0xB/status/1189979046135750657" rel="nofollow">habe auf Twitter einen Fehlerbericht veröffentlicht</a> , der zunächst <a href="https://twitter.com/djammmer/status/1192634563421495297" rel="nofollow">einige Bewegungen des WMI-Teams verursachte</a> , dann jedoch keine Antworten mehr erhielt. Daher weiß ich nicht, wie es jetzt aussieht. <br><br>  Ich würde gerne eine Lösung für das Leistungsproblem finden, und ich möchte, dass unsere IT-Abteilung in der Lage ist, das Problem zu finden und zu beheben, das unsere wbem-Repositorys so groß macht.  Derzeit hat die IT-Abteilung jedoch zugesagt, den Befehl / verifyrepository nicht mehr stündlich auszuführen, um die schlimmsten Symptome zu vermeiden. <br><br><h2>  Referenzen </h2><br><ul><li>  Eine allgemeine Liste von ETW-Tutorials, Untersuchungen und Dokumentationen finden Sie hier: <a href="https://tinyurl.com/etwcentral" rel="nofollow">https://tinyurl.com/etwcentral</a> </li><li>  Das Tutorial zur CPU-Auslastung (Sampled) (um herauszufinden, wofür die CPU-Zeit aufgewendet wird) und die Dokumentation finden Sie <a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/" rel="nofollow">hier.</a> </li><li>  Das Lernprogramm zur CPU-Auslastung (Präzise) (aus Gründen, aus denen Threads nicht ausgeführt werden können) und die Dokumentation finden Sie <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">hier.</a> </li><li>  Links zu einzelnen Artikeln finden Sie im Hauptteil des Beitrags. Sie finden sie auch in meiner Kategorie " <a href="https://randomascii.wordpress.com/category/investigative-reporting/" rel="nofollow">Berichterstattung untersuchen"</a> </li><li>  Andere Geschichten über O (n <sup>2</sup> ) -Algorithmen können auf <a href="https://accidentallyquadratic.tumblr.com/" rel="nofollow">Accidentally Quadratic</a> nachgelesen werden </li></ul><br>  Eine Diskussion des Artikels über Reddit ist <a href="https://www.reddit.com/r/programming/comments/e87dpb/on2_again_now_in_wmi/" rel="nofollow">hier</a> , eine Diskussion über Hacker-News ist <a href="https://news.ycombinator.com/item%3Fid%3D21743424" rel="nofollow">hier</a> , ein Thread auf Twitter ist <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">hier</a> und möglicherweise <a href="https://twitter.com/BruceDawson0xB/status/1203922370957721600" rel="nofollow">hier</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479498/">https://habr.com/ru/post/de479498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479482/index.html">SARIF SDK und seine Fehler</a></li>
<li><a href="../de479486/index.html">Heterogene Programmierung und oneAPI Toolkit. Der improvisierte Vortrag von Intel-Experten beantwortet Ihre Fragen</a></li>
<li><a href="../de479488/index.html">Von einem Laptop - ein Heimserver mit redundanter Stromversorgung für den Mikrotik-Router</a></li>
<li><a href="../de479492/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 3</a></li>
<li><a href="../de479496/index.html">Analysieren von WTF-Aufgaben in JavaScript</a></li>
<li><a href="../de479502/index.html">Wie überlebt man die schwerste Eiszeit der Erdgeschichte?</a></li>
<li><a href="../de479504/index.html">Erstellen Sie einen auf Raspberry Pi basierenden RDP Thin Client</a></li>
<li><a href="../de479508/index.html">PostgreSQL Antipatterns: schädliche JOINs und ORs</a></li>
<li><a href="../de479510/index.html">PocketBook X Test - ein riesiges 10,3-Zoll-Lesegerät mit einem E-Ink-Carta-Mobius-Bildschirm und einem Metallgehäuse</a></li>
<li><a href="../de479512/index.html">MVCC in PostgreSQL-4. Schnappschüsse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>