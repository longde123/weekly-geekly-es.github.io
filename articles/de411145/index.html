<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏻 🛰️ 🔧 Meine kleinen Relais: Brainfuck Computer ist Realität 👩🏿‍💼 👩🏼‍🍳 🤸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Genau ein Jahr ist seit der letzten Veröffentlichung vergangen und ich dachte, dass der erste April ein großartiger Tag für die jährliche Zusammenfass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine kleinen Relais: Brainfuck Computer ist Realität</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411145/"><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/m0/ly/sf/m0lysfg74dvrhabcw-sbs1lld7g.jpeg"></a> <br>  Genau ein Jahr ist seit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der letzten Veröffentlichung vergangen</a> und ich dachte, dass der erste April ein großartiger Tag für die jährliche Zusammenfassung meiner drei verrückten Computerprojekte ist.  Zu dieser Zeit existierte das Projekt nur auf dem Papier, aber jetzt ist es definitiv Realität geworden. </p><br><p>  Klingelnde Relaisblöcke, die schnellsten Relaisberechnungen der Welt (dies ist jedoch nicht genau), Nachbearbeitung, Vakuumanzeigen und blinkende LEDs. </p><a name="habracut"></a><br><h1 id="istoricheskaya-spravka">  Historischer Hintergrund </h1><br><p><img src="https://habrastorage.org/webt/kh/qa/4m/khqa4myljg149ffbe7kjbmlmh_q.jpeg"><br>  <em>Abbildung 1: Ein Band von Wojciechowskis "Radio-Electronic Toys", 1979, von meinem Leben und mir selbst geschlagen.</em> </p><br><p>  Es war einmal, als alles groß war und ich klein war (ein Jahr wie dieses im Jahr 2002), mein Vater gab mir Wojciechowskis Buch Radio-Electronic Toys.  Damals hatte ich keinen Computer, aber ich hörte überhaupt nichts über das Internet, und ein Buch, das vielen bekannt war, erwies sich als ein Lagerhaus für unterhaltsame elektronische Geräte.  Darunter befanden sich eine Beschreibung eines elektronischen Computers und eine einfache Modellschaltung an Telefonrelais.  Dieses Modell, das ich 2008 in meinem zweiten Jahr an der Universität hatte, habe ich für einen Bericht über die Geschichte der Computer zusammengestellt. </p><br><p><img src="https://habrastorage.org/webt/cn/1w/-3/cn1w-35bc5xkah3gs2f8hgr8fgc.jpeg"><br>  <em>Abbildung 2: RCM - 4-Bit-ALU</em> </p><br><p>  Zu dieser Zeit erkundete ich bereits die Weiten des Internets und war mir der Existenz sowohl des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Harry Porter-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Relaiscomputers als</a> auch des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Relaiscomputers Nummer 2</a> und des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuse-Relaiscomputers</a> bewusst - ich dachte darüber nach, eine eigene Einheit zu bauen. </p><br><p>  Für diejenigen, die sich nicht bewusst sind, was andere haben, empfehle ich, meine Videoüberprüfung von hausgemachten Relay-Computern anzusehen.  Im Laufe des Jahres ist es etwas veraltet, hat aber nicht aufgehört, weniger interessant zu sein: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/whk8NKAdsB8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Im selben Jahr 2008 entschied ich mich im Unterricht über die theoretischen Grundlagen der Elektrotechnik für die Hauptkomponente - ein Reed-Relais.  In einem der Labors war ich überrascht, auf der Wellenform zu beobachten, wie das Baby RES55 bei einer Frequenz von 50 Hz arbeitete.  Dies machte einen bleibenden Eindruck auf mich und ich begann, Reedschalter anzusammeln. </p><br><h1 id="proshlo-10-let">  10 Jahre sind vergangen .... </h1><br><p>  Und nach einem Jahrzehnt bewegt sich das Projekt mit großer Geschwindigkeit zur Veröffentlichung.  Alles bewegte sich von einem toten Punkt im November 2016, als die aktuelle Architektur geboren wurde.  Leider habe ich mich entschlossen, alle Leiterplatten selbst herzustellen. Infolgedessen verwandelte sich ein ganzer Quadratmeter doppelseitiger Leiterplatte in ein schwarzes Loch und saugte mehrere hundert Mannstunden Freizeit in sich auf, was für einen Mitarbeiter etwa sechs Monate entspricht.  Von April bis November 2k17 passierte praktisch nichts. </p><br><h1 id="infografika">  Infografiken </h1><br><p><img src="https://habrastorage.org/webt/sl/is/nf/slisnf0apkc-ncrszkk55oxehxu.jpeg"></p><br><p>  Die Architektur der Maschine entspricht der Turingmaschine.  Es gibt ein Band mit Daten - RAM für 64 Kiloslov (16-Bit-Wort).  RAM - Cache - Chips von einer Art Matte.  Motherboards für Intel Pentium.  Informationen zur Authentizität finden Sie im Abschnitt ... Authentizität.  Mikroschaltungs-RAM wird in den meisten mir bekannten hausgemachten Relais-Computern verwendet. </p><br><p>  Das zentrale Element ist ein 16-Bit-Paralleladdierer.  Er ist für die Berechnung der Nummer der nächsten Anweisung verantwortlich und arbeitet mit Daten und einem Zeiger darauf. <br>  An den Eingängen des Addierers befinden sich ein temporäres 16-Bit-Register und ein 12-Bit-Befehlsregister.  12 Bits werden auch an die hohen 4 Bits des Addierers gesendet, was "volle" 16 Bits ergibt.  Es ist wichtig, dass der Addierer beim Addieren und Subtrahieren einer 12-Bit-Zahl korrekt funktioniert. </p><br><p>  Der Nachteil liegt auf der Hand: Zu einem Zeitpunkt können wir nur 2 ^ 12 Anweisungen vorwärts oder rückwärts springen oder den Zeiger oder die Daten um diesen Wert ändern.  Die erste - Sie müssen beim Schreiben von Programmen berücksichtigen, die zweite - Sie können den Vorgang jederzeit wiederholen. </p><br><p>  Die Subtraktion erfolgt im zusätzlichen Code.  Die parallele Übertragung bietet eine konstante Rechenverzögerung - nur 3 in Reihe stehende Relais.  Dies ist nicht mehr als 2 ms. </p><br><p>  Das IP-Register und das AP-Register sowie der RAM-Eingang sind über Latches mit dem Ausgang des Addierers verbunden. </p><br><h2 id="vychisleniya">  Berechnungen </h2><br><p>  Die Hauptoperationen bestehen aus genau zwei Teilen.  In einem Fall arbeiten wir mit der Berechnung eines neuen Zeigerwerts, im anderen mit einem neuen Datenwert. </p><br><p>  Jede steigende Flanke startet die Berechnung einer neuen Befehlsnummer.  Im Wesentlichen ist IP ++ fertig.  Nach der Berechnung wird IP dem Adresseneingang der Speicherkarte zugeführt und über den Datenbus tritt der Befehl in das Befehlsregister ein.  Die hohen 4 Bits bestimmen den zukünftigen Befehl, die niedrigen 12 sind höchstwahrscheinlich ungleich Null und in Zukunft wird der Addierer die Zahl im temporären Register genau um diesen Wert ändern. </p><br><p>  Jede fallende Flanke beginnt den Vorgang. </p><br><p>  Bei Operationen mit AP- und IP-Registern sieht die Reihenfolge der Aktionen folgendermaßen aus: </p><br><ol><li>  Über den Adressbus wird der Inhalt des IP (AP) -Registers in das temporäre Register kopiert; </li><li>  Temporäre Register und Befehlsregister werden dem Eingang des Addierers zugeführt.  Nach 2 ms ist die Antwort am Ausgang des Addierers fertig. </li><li>  Die Antwort wird im IP- oder AP-Register aufgezeichnet. </li></ol><br><p>  Es gibt einige Funktionen.  Bei AP + BIAS- und AP-BIAS-Befehlen ist dies genau der Fall, bei bedingten Befehlen, wenn beispielsweise IP = (* AP == 0?) IP + 1: IP + -BIAS, müssen wir den aktuellen Datenzellenwert noch auf den Datenbus hochladen und entfernen Informationen von einem Nulldetektor. </p><br><p>  Bei <em>AP + BIAS- und</em> AP-BIAS-Vorgängen unterscheidet sich die Reihenfolge geringfügig. </p><br><ol><li>  Über den Datenbus wird der aktuelle Wert der Speicherzelle in das temporäre Register geschrieben. </li><li>  Temporäre Register und Befehlsregister werden dem Eingang des Addierers zugeführt.  Nach 2 ms ist die Antwort am Ausgang des Addierers fertig. </li><li>  Das AP-Register wird weiterhin dem Eingang der Speicherkarte zugeführt.  Die Antwort des Addierers wird direkt in den Speicher geschrieben. </li></ol><br><p>  Berechnungen erfolgen immer im 16-Bit-Modus.  Das Null-Flag des bedingten Zweigs ist jedoch definiert als: </p><br><pre><code class="cpp hljs">Z = ((<span class="hljs-number"><span class="hljs-number">16b</span></span>it?) *AP : (*AP) &amp; <span class="hljs-number"><span class="hljs-number">0x00FF</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) ;</code> </pre> <br><h1 id="konstrukciya">  Bau </h1><br><p>  Seit dem letzten Mal hat sich nichts geändert. </p><br><h2 id="modul">  Modul </h2><br><p><img src="https://habrastorage.org/webt/h1/9b/9m/h19b9mwdk162l0g8x5iwtbweypo.jpeg"><br>  <em>Abbildung 3: Computermodul.</em>  <em>Von links nach rechts: D-Flip-Flop-Modul, Diodenmodul, 2AND / 2XOR-Modul</em> </p><br><p>  Im Kern befindet sich ein kleines 40x64mm Modul.  Jedes Modul ist eine Leiterplatte mit 4 Relais, auf der eine einfache logische Operation implementiert ist.  Es gibt einen Anschluss für 16 Kontakte (es gibt Module für 12 und 14 Kontakte) und bis zu 4 LEDs.  Alle Größen sind streng festgelegt. </p><br><p><img src="https://habrastorage.org/webt/an/jz/uo/anjzuocj0hnbubswwexxtukvn_e.jpeg"><br>  <em>Abbildung 4: Module während der Montage</em> </p><br><p>  Zum Beispiel: </p><br><ol><li>  2AND / 2XOR-Modul - 2 unabhängige logische Operationen - 2AND und 2XOR.  Im Addiererblock werden 32 Teile verwendet, zwei Module pro Bit.  Zuerst wurden alle 4 LEDs gelötet, aber die Schaltung des Moduls ist so, dass zwei Relais an jedem Modul parallel geschaltet sind. Um den vom Gerät verbrauchten Strom zu reduzieren, wurde die Hälfte der LEDs entfernt. </li><li>  D-Trigger-Modul - 64 Teile gehen an zwei Registerblöcke.  Davon sind 60 Trigger ohne Aktivierungssignal. </li><li>  Diodenmodul - nur 8 Dioden auf der Platine zur Implementierung einer Diode mit mehreren Eingängen ODER.  Ein schmutziger Hack, der es jedoch ermöglicht, sowohl an einem Relais (ich habe jetzt noch ungefähr 400 Relais in Reserve) als auch pünktlich zu speichern - im Vergleich zu einem Relais wird das Signal sofort an den Ausgang eines solchen Logikelements übertragen. </li><li>  Modul 2 &amp; - Dies ist der Grundstein.  Tatsächlich gibt es 4 Relais mit einem Schaltkontakt, um absolut jede Logikschaltung zu implementieren.  Sie werden in einer unbekannten Menge zu Logikblöcken gehen. </li><li>  Universal 2AND / 2OR, das so hergestellt ist, dass nahezu jede logische Funktion implementiert werden kann - 4AND, 4OR, 4AND-NOT, 4OR-NOT und so weiter.  Es wird auch in einer unbekannten Menge zum Logikblock gehen. </li></ol><br><p>  Wie gesagt - nachdem ich viel Zeit mit der Herstellung hausgemachter Leiterplatten verschwendet hatte, flippte ich aus und bestellte bei den Chinesen einen kompletten Satz Leiterplatten.  In der ersten Woche habe ich die ersten Module zusammengestellt.  Und einen Monat später waren alle Module für den Addiererblock fertig. </p><br><p><img src="https://habrastorage.org/webt/xn/72/gz/xn72gzk6fnala_kjqcga1ycq-cc.jpeg"><br>  <em>Abbildung 5: Addiererblock</em> </p><br><h2 id="blok">  Blockieren </h2><br><p>  32 Module mit 8 Modulen in 4 Reihen werden zu einem Funktionsblock zusammengefasst.  Insgesamt gibt es 5 Blöcke (im schlimmsten Fall 6): </p><br><ol><li>  Der Addiererblock ist ein 16-Bit-Volladdierer.  Zwei 16-Bit-Eingänge für Zahlen, 1 Null-Bit-Übertragungsleitung, zwei Ausgänge.  Zum einen die Summieroperation, zum anderen das XOR zwischen den Eingängen.  Es kann als eigenständige Operation verwendet werden. </li><li>  IP / AP-Registerblock - Zwei unabhängige 16-Bit-Register ohne Aktivierungssignal.  Die Ergebnisse von Q und ~ Q werden direkt verwendet und durch Latches an die folgende Stelle geleitet.  Es war möglich, 4 Relais zu löten, aber um das Relais zu schonen, wurde die Funktionalität auf externe Verriegelungen übertragen. </li><li>  Registerblock TMP / CMD - Hier gibt es drei Register.  Eines ist ein temporäres 16-Bit-Register.  Genau das gleiche wie IP oder AP.  Der zweite ist 12-Bit, sein Ausgang ist über einen Latch mit dem Eingang des Addierers verbunden.  Das dritte ist 4-Bit mit einem integrierten Aktivierungssignal.  Es wird verwendet, um den aktuellen Befehl zu speichern. </li><li>  Logikblöcke - 2 Stück.  Oder drei.  Das Schema ist noch unbekannt.  Vorläufige Berechnungen zeigen, dass 64 Module ausreichen (GOTO: Memory Board). </li></ol><br><p>  An der Basis jedes Blocks beträgt die Basisplatine 200 x 150 mm ohne Verkabelung.  Alles, was darauf steht, sind 32 Anschlüsse und Vierkantstifte, die für die Runduminstallation von unten herausragen. </p><br><p><img src="https://habrastorage.org/webt/s_/pn/tl/s_pntl-inevaow8u_8bnzg-710k.jpeg"><br>  <em>Abbildung 6: Grundplatte und Korb</em> </p><br><p>  Die Module, die einfach so im Stecker herausragen, sind unzuverlässig.  Sie werden hier und da hängen, vom Zittern abweichen und in jeder Hinsicht die Zuverlässigkeit der Struktur verringern.  Um sie zu reparieren, habe ich spezielle Körbe mit Rillen gezeichnet und gedruckt.  Die Module werden sicherlich nirgendwo hingehen - sie haben eine Zugfahrt nach Moskau und zurück ohne Probleme überstanden. </p><br><p>  Der Korb hätte einfacher gezeichnet werden können - mit einer Schicht von 0,32 mm würde er etwas mehr als 10 Stunden drucken.  Drei Körbe sind mit PLA-Kunststoff bedruckt, zwei weitere mit HIPS.  Letzteres verzieht sich aufgrund des Fehlens eines Gehäuses für meinen Drucker beim Drucken merklich. </p><br><p>  Möglicherweise stellen Sie fest, dass der Addiererblock keine Ohren zum Anbringen hat.  Der Korb für ihn wurde gleich zum ersten Mal gedruckt.  Dann werde ich entweder diese Ohren andocken oder einen neuen Korb drucken. <br><img src="https://habrastorage.org/webt/y3/es/a5/y3esa50tcletmcbmu5zn5nhxhrk.jpeg"><br>  <em>Abbildung 7: Addiererblock und Logikblock.</em> </p><br><h2 id="montazh-nakrutkoy">  Drahtwickel </h2><br><p>  Auf der Basisplatine warten wir auf 600 Schlussfolgerungen, die miteinander verbunden werden müssen.  Glücklicherweise ist es notwendig, nicht nur alles, sondern nur fast alles zu verbinden.  Einfacher geht es nicht. </p><br><p>  Wir nehmen ein Spezialwerkzeug, eine Drahtspule und ein Bein nach dem anderen und wickeln den Anschlussplan auf. </p><br><p><img src="https://habrastorage.org/webt/wj/ak/gv/wjakgvtczgj932i6vpb77xjpb_e.jpeg"><br>  <em>Abbildung 8: Zusammenfassung des Addiererblocks</em> </p><br><p>  Dies ist nur der Anfang der Arbeit.  Nun, als Anfang.  Zuerst gab es leises Entsetzen - die Drähte lagen willkürlich, einige Jumper sind lang, andere zu lang ... Nachdem ich etwas besser gelernt hatte als zuvor, entfernte ich die meisten Jumper und drehte sie erneut - ich begann, die Jumper mit einer Schnur zu dehnen.  Die Drähte hängen also nicht heraus und das Ergebnis sieht viel besser aus.  Ich habe versucht, so zu setzen, dass die Drähte nicht auf die Ecken nicht ihrer Stifte drückten.  Infolgedessen kein einziger Stromkreis.  Vom ersten Versuch an gab es nur irdene Linien. </p><br><p><img src="https://habrastorage.org/webt/bq/6t/e3/bq6te3y4th4_ahzqaa12kto6llw.jpeg"><br>  <em>Abbildung 9: Zusammenfassung des Addiererblocks.</em>  <em>Endergebnis</em> </p><br><p>  Im Moment ist es nicht ganz einfach, aber für das erste Board ein sehr gutes Ergebnis, denke ich.  Bis jetzt habe ich nicht gelernt, wie man Draht zur Spule oder ein Kurvenwerkzeug oder Hände legt ... </p><br><p>  Beim Kameraden  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">UA3MQJ</a> enthält einen <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführlichen Artikel</a></strong> zu dieser Installationsmethode. </p><br><p>  Zusätzlich zum Addiererblock wird ein Registerblock benötigt.  Vielmehr zwei Blockregister.  Noch ein paar Monate - und weitere 64 Module werden zusammengebaut und getestet.  Es bleibt die Grundplatte aufzuwickeln. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ctT1eXD5qDE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wie war das? </p><br><h1 id="indikatornye-moduli">  Anzeigemodule </h1><br><p><img src="https://habrastorage.org/webt/pq/u-/2i/pqu-2ianoeafpk1aubms_sevths.jpeg"><br>  <em>Abbildung 10: Anzeigemodul</em> </p><br><p>  Der aktuelle Status der Prozessorregister muss auf etwas angezeigt werden, und ich habe entschieden, dass die Vakuumanzeigen genau richtig sind.  Auf der Platine 100x100mm (für 10 Stück dieser Größe können Sie bei den Chinesen für 5 US-Dollar bestellen) befinden sich 6 IV-6-Anzeigen, K155TM8-Trigger und ein Mikrocontroller.  Die Anzeige hier ist dynamisch. </p><br><p>  Es gibt auch einen 16-Bit-Eingang zum direkten Lesen des Status des Registers und einen UART-Port zum Empfangen von Befehlen von der Speicherkarte. </p><br><p>  Jetzt kann die Firmware den Status des 16-Bit-Ports lesen und im HEX-Format auf der Anzeige anzeigen.  Insgesamt benötige ich 4 solcher Module.  Drei zeigen den aktuellen Status der Register an - IP, AP und CMD des Registers, um eine bequemere Visualisierung der aktuell gespeicherten Werte zu erhalten.  Viertens - zeigt die Gesamtzahl der ausgeführten Anweisungen an. </p><br><h1 id="zaschelka">  Verriegelung </h1><br><p><img src="https://habrastorage.org/webt/tt/u8/s6/ttu8s6chfwlltkbgkzbsbrldz0k.jpeg"><br>  <em>Abbildung 11: Verriegelungsmodul</em> </p><br><p>  Das Latch-Modul besteht aus 8 RES43-Relais.  Im Inneren befinden sich zwei Kontakte.  Links und rechts sind LEDs, die den aktuellen Status des Ein- und Ausgangs anzeigen. </p><br><p>  Die Größe des Riegels beträgt 100x100mm.  Die benötigte Menge beträgt 8 Stück.  Zwei sind fertig, es bleiben noch sechs zu sammeln. </p><br><h1 id="plata-pamyati">  Speicherkarte </h1><br><p><img src="https://habrastorage.org/webt/ou/zw/vt/ouzwvtghdzcjmuywgdroiiovasi.jpeg"><br>  <em>Abbildung 12: Speicherkarte.</em>  <em>Gesamtansicht</em> </p><br><p>  Der größte Block, der hauptsächlich zwei 64 KByte statische RAM-Chips und Übereinstimmungsschemata für Adresseneingänge und einen Datenport enthält.  Auf der Platine befindet sich der Mikrocontroller ATmega1280.  Er hat zwei wichtige Aufgaben: </p><br><ol><li>  Herunterladen des Programms und der Anfangsdaten in den RAM.  Die kompilierte Binärdatei muss gespeichert werden.  Dazu kann über UART oder Telnet (über WLAN) eine Verbindung zur Speicherkarte hergestellt und die ausführbare Datei heruntergeladen werden.  MK liest den Header und legt Abschnitte mit Code und Daten im RAM an.  Ich bin völlig zu faul, um dies mit den Kippschaltern und Tasten zu tun - ein Brainfuck-Programm, das etwas komplizierteres machen kann HelloWorld enthält Tausende von Anweisungen.  In dieser Hinsicht gibt es ein paar Trumpfkarten im Nest, aber ein anderes Mal darüber. </li><li>  Es implementiert Befehle zum Lesen und Schreiben von Daten von der Konsole.  Ja ja Anweisungen. ""  und "," werden mit MK implementiert.  Vielmehr informiert die Relaislogik den MK, dass es nun notwendig ist, den Status des Datenbusses an die Konsole zu übertragen oder umgekehrt, um den Wert von der Konsole an den Datenbus auszugeben.  Tatsächlich arbeitet MK in UART als Parallelschnittstellenkonverter.  Ja, es ist durchaus möglich, etwas Besonderes auszuführen.  Chip und ich werde darüber nachdenken. </li></ol><br><p>  Ich habe immer noch nicht entschieden, was ich mit dem 16-Bit-Modus machen soll.  Natürlich sind die meisten Programme unter dem 8-Bit-Brainfuck geschrieben und alles ist einfach - wir lesen und schreiben das Low-Byte.  Und was soll ich im 16-Bit-Modus tun?  Das ganze Wort oder auch nur das Low-Byte anzeigen? </p><br><p>  Zusätzlich zu den Hauptaufgaben hat MK eine Reihe von Nebenaufgaben, auf die Sie im Prinzip verzichten können, die jedoch auf die Benutzerfreundlichkeit der Maschine abzielen: </p><br><ol><li>  MK ist für die Anzeige eines kleinen Speicherbereichs auf einer 32 x 16 Pixel großen LED-Matrix verantwortlich.  Er tut dies, während der Adressbus und der Datenbus nicht von der Hauptlogik belegt sind.  Hier bin ich mir nicht sicher, ob für MK im Allgemeinen Zeit im Bus sein wird, daher muss die Frage überprüft werden.  Aber in der Kopfzeile des Programms gibt es eine Startadresse für die Anzeige und ich werde versuchen, es zum Laufen zu bringen.  Die Anzeige ist dynamisch.  In einem Taktzyklus werden zwei Datenspalten gleichzeitig ausgegeben. </li><li>  Wenn das Flag des geschützten Speichermodus in der Binärdatei aktiviert ist, generiert der MK bei dem Versuch, einen Datenabschnitt auszuführen oder in den Speicherabschnitt zu schreiben, eine Ausnahme "Segmentierungsfehler".  So können wir sicherstellen, dass das Programm nicht dahin geht, wo es nicht sein sollte.  Das Lesen des Speicherabschnitts ist nicht verboten. </li><li>  Wenn das Code-Steuerflag aktiviert ist, aktiviert MK den Simulator und führt darin dieselben Anweisungen wie der Computer aus, wobei die erwarteten und empfangenen Ergebnisse verglichen werden.  Wenn das Ergebnis anders ist, wird die Ausnahme "Maschinenfehler" ausgelöst.  Dies bedeutet, dass bei den Berechnungen ein Fehler aufgetreten ist und möglicherweise ein Modul ausfällt.  Oder auch wir haben die Taktfrequenz angehoben und die Relais haben keine Zeit mehr zum Berechnen.  Nur mit Hilfe dieser Funktionalität werde ich versuchen, das Maximum aus dem Auto herauszuholen - während dieser Zeit muss etwas den korrekten Betrieb kontrollieren. </li></ol><br><p>  Es gibt immer noch eine temporäre, aber immer noch wichtige Funktion der Speicherplatine - sie emuliert einen Logikblock, während er nicht vorhanden ist.  Auf der Speicherplatine befinden sich Eingangs- und Ausgangsleitungen, und wir können die erforderlichen Signale an die Blöcke liefern.  Wenn Sie also alle Steuerleitungen mit der Speicherplatine verbinden und ein Programm schreiben, das die erforderliche Befehlsfolge ausgibt, wird dies in kürzester Zeit geschehen: </p><br><ol><li>  Führen Sie die ersten Programme zur Ausführung aus. </li><li>  Debug-Algorithmen und Schaltungen des Logikblocks, die die Wahrscheinlichkeit einer fehlerfreien Montage und eines fehlerfreien Betriebs später erhöhen. </li></ol><br><p>  Wenn dann die erforderlichen Module der Logikblöcke gesammelt werden, werden alle Funktionen schrittweise "auf Eisen" übertragen.  Wenn MK nicht mehr für die Logik verantwortlich ist, gilt das Projekt als abgeschlossen. </p><br><h1 id="autentichnost">  Authentizität </h1><br><p>  Das Projekt war ursprünglich nicht als reines Relais ohne Verwendung von Transistoren und Mikroschaltungen konzipiert.  Einerseits stellt sich heraus, dass der Computer hybride ist und an Strahlungsbeständigkeit verliert, andererseits haben die meisten Relaiscomputer eine ähnliche Krankheit.  Die endgültige Version der Maschine verwendet einen Speicherchip und einen Mikrocontroller.  Ferritspeicher wird in einem anderen, bereits „silikonfreien“ Projekt verwendet. </p><br><p>  Um die Wirkung von Nicht-Kanonen zu kompensieren, habe ich eine elektronische Schreibmaschine „Robotron S6130“ bekommen. </p><br><p><img src="https://habrastorage.org/webt/7q/sc/qp/7qscqpvy4fjdknrgucm0ryum5im.jpeg"><br>  <em>Abbildung 13: Elektronische Schreibmaschine vom Typ Kamille.</em> </p><br><p>  Leider ging die Maschine in einem schäbigen Zustand zu mir.  Es wurde für eine lange Zeit in der Buchhaltung verwendet, aber am Ende wurde aufgegeben, um in herrlicher Isolation zu sterben. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bmlq4-TQYF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ich empfehle eine einzigartige Bewertung dieses Monsters. </p><br><p>  Direkt ist die Mechanik in gutem Zustand, aber die Prozessorplatine, auf der ein Paar D-0,25 NiCd-Batterien stand, war stark beansprucht.  Sie leckten sicher und überfluteten alles mit Elektrolyt. </p><br><p>  Ich möchte es wiederherstellen und als Eingabe- / Ausgabeterminal für den Computer verwenden. Zusätzlich zur Fehlfunktion des elektronischen Teils verfügt das Gerät jedoch über ein russisches Gänseblümchen (Laufwerk mit Buchstaben) und russische Schlüssel.  Der zweite wird durch Aufkleber entschieden, der erste ist zu suchen und hier habe ich noch kein Glück.  Über die Tatsache, dass eine Patrone mit einem Farbband erforderlich ist, schweige ich im Allgemeinen.  Zumindest habe ich Papier für sie .. </p><br><p>  Wenn die Elektronik entscheidet, dass sie unwiederbringlich verloren geht, werde ich versuchen, einen Spender zu finden, oder ich werde eine neue elektronische Füllung entwickeln.  Es ist nicht die schwierigste Aufgabe, ein Kontrollbrett zu einer Handvoll Shagoviks zu machen.  Es wird schwieriger sein, ein Handbuch aus dem Deutschen zu übersetzen und TK zu verstehen.  Natürlich verdient diese Maschine einen separaten Artikel über die Ergebnisse der Wiederbelebung.  Gegen sie hat bisher die Priorität der geleisteten Arbeit. </p><br><h1 id="testy">  Tests </h1><br><p>  Alle, die bis zu diesem Ort gelesen haben, erhalten eine Belohnung in Form von knackenden und summenden Relaisblöcken. </p><br><p>  Versuchen wir zunächst, eine Rechteckwelle über eine Transistorkaskade an den Relaiseingang anzulegen: </p><br><p><img src="https://habrastorage.org/webt/aa/9s/ob/aa9sobefi3g2phsqmkudkq9cafw.jpeg"><br>  <em>Abbildung 14: Hochgeschwindigkeitstest des Reedschalters RES55.</em>  <em>Ein gelbes Signal befindet sich an der Spule, ein blaues an den Kontakten</em> </p><br><p>  Da der Eingang des Oszilloskops eine bestimmte Kapazität hat und der Relaiskontakt nach dem Öffnen in der Luft bleibt und die Selbstentladung beginnt, sehen wir den entgegengesetzten Exponenten.  Bei einer Frequenz von 1,7 kHz!  Für das Relais!  Für ein kleines Reed-Relais!  Normaler Stillstand bei 20 Hz oder etwas höher.  Bei einer Nennfrequenz von 100 Hz betragen die ansteigenden und abfallenden Flanken jeweils ca. 600 μs.  Hier sind sie so klein (200 Mikrosekunden), weil die Energie der vorherigen zum Zeitpunkt des nächsten Einschaltens noch in der Spule verbleibt. </p><br><p>  Wir legen Spannung an die Blöcke an, schneiden die Schalter von sowjetischen Messgeräten zu den Eingängen. </p><br><p><img src="https://habrastorage.org/webt/yx/zv/pa/yxzvpakpbgnygfzcnkxcvllaxvq.jpeg"><br>  <em>Abbildung 15: Addiererblock und Registerblock in Betrieb</em> </p><br><p>  Es zählt!  Cool. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zqWaLdvAkPY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  So sah es von der Szene aus.  Zuerst wollte ich die Switches für 16-Bit neu gestalten.  Verbinden Sie die Anzeigen sowohl mit dem Eingang als auch mit dem Ausgang, aber ... ich konnte nicht widerstehen. </p><br><p>  Nun, da alles funktioniert und sich herausstellt, dass das Relais wahnsinnige Geschwindigkeiten erreichen kann, führen wir den Mäander zur Übertragungsleitung: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8WnqqeKWtjw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Und wir schneiden 500Hz.  Der Addierer kommt zurecht, obwohl der Ton nicht gesagt werden kann.  Eigentlich ist der Klang klar, aber das Kondensatormikrofon denkt anders.  Soweit ich weiß, ist dies der schnellste Relaisaddierer der Welt. </p><br><h1 id="prodolzhenie-sleduet">  Fortsetzung folgt </h1><br><p><img src="https://habrastorage.org/webt/3v/et/il/3vetilfxdaaga8060ahosnruc34.jpeg"><br>  <em>Abbildung 16: Entwerfen eines Computerrahmens</em> </p><br><p>  Allmählich werden die fehlenden sechs Riegelstücke gesammelt und der Rahmen der zukünftigen Maschine wird entworfen.  Die Zeichnung enthält sechs Blöcke, falls 64 Module für die Logik nicht ausreichen.  Und wenn genug genug ist, bleibt der Platz unter dem unteren Mittelblock leer. </p><br><p>  Gleichzeitig schreibe ich Firmware für eine Speicherkarte, damit diese einen fehlenden Logikblock ersetzen kann.  Im Sommer kann der Computer sein erstes Programm ausführen. </p><br><h2 id="tri-kompyutera">  Drei Computer ??? </h2><br><p>  Ja, drei.  Der erste ist der aktuelle BrainfuckPC.  Der zweite ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pneumatischer</a> Computer mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codenamen FluidicPC</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Über das dritte strahlungsresistente zukünftige Monster können Sie bereits Referenzen im Internet finden, aber ich möchte nicht zwischen Projekten sprühen und zuerst möchte ich das aktuelle beenden - ich mache noch keine Ankündigung darauf.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/fn/l2/xu/fnl2xu1n17czsdx6lbs5u2yzkmi.jpeg"><br>  <em>Abbildung 17: Schaltdekatrons A101, A102 und A103</em> <br>  Obwohl Sie auf diesem Bild bereits erraten können, was besprochen wird. </p></div></div><br><h2 id="zacheeeem">  WARUM ???? </h2><br><img src="https://habrastorage.org/files/1fb/f24/c16/1fbf24c164974f8fabba8e7e03e5856b.jpg"><br><br><h2 id="ssylki">  Referenzen </h2><br><p>  Das gesamte Projekt ist weiterhin vollständig offen.  Daher die wichtigsten Links für das Projekt: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository mit Schaltplänen und Leiterplattenlayouts</a> .  Es gibt auch Firmware für das Anzeigemodul und die Speicherkarte </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf dieser Seite veröffentliche</a> ich wöchentlich und nicht sehr Berichte darüber, was getan wurde.  Jetzt lesen Sie einen Artikel, der etwas mehr als vollständig aus diesen Notizen besteht.  Mit Übersetzung, Kommentaren und Ergänzungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler und Emulator</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de411145/">https://habr.com/ru/post/de411145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de411135/index.html">Parameter</a></li>
<li><a href="../de411137/index.html">VTC - Satellitenkommunikationszentrum (Wladiwostok)</a></li>
<li><a href="../de411139/index.html">Das Rätsel um die Neutronenlebensdauer wird komplizierter und dunkle Materie ist immer noch nicht sichtbar</a></li>
<li><a href="../de411141/index.html">"Smart Home" auf Arduino zur Abwechslung</a></li>
<li><a href="../de411143/index.html">Programmierung moderner Mikrocontroller: Vorlesung 1</a></li>
<li><a href="../de411147/index.html">Riesige Flecken von Riesenplaneten</a></li>
<li><a href="../de411149/index.html">TRIZ-Prognose dezentraler Systeme und der cyber-physischen Gesellschaft von 2035</a></li>
<li><a href="../de411151/index.html">iMX6ULL. Übergang zu Prozessormodulen</a></li>
<li><a href="../de411153/index.html">Neun Bürokratiekreise: Wie ein Flughafen in Denver versucht, eine Raumhafenlizenz zu bekommen</a></li>
<li><a href="../de411155/index.html">Ersetzen Sie gewohnheitsmäßige Antibiotika durch synthetische Moleküle von IBM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>