<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôåÔ∏è ü§ì üç§ Wireshark 3.x: Code-Analyse unter macOS und Fehler√ºberpr√ºfung üèâ üë©üèª üöµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Wireshark Foundation hat die endg√ºltige stabile Version des beliebten Netzwerkverkehrsanalysators Wireshark 3.0.0 ver√∂ffentlicht. Die neue Version...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wireshark 3.x: Code-Analyse unter macOS und Fehler√ºberpr√ºfung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/447156/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/b08/9a1/e5db089a18a6e0f13aaf26e7f0c5fb91.png" alt="Bild 1"></div><br>  Die Wireshark Foundation hat die endg√ºltige stabile Version des beliebten Netzwerkverkehrsanalysators Wireshark 3.0.0 ver√∂ffentlicht.  Die neue Version behebt mehrere Fehler. Es ist jetzt m√∂glich, die neuen Protokolle zu analysieren. Au√üerdem wird der Treiber auf Npcap WinPcap ersetzt.  Hier endet das Zitieren der Ank√ºndigung und unser Hinweis zu Fehlern im Projekt beginnt.  Die Projektautoren haben definitiv nicht ihr Bestes gegeben, um Fehler vor der Ver√∂ffentlichung zu beheben. <br><br>  Sammeln wir jetzt Hotfixes, um ein Motiv f√ºr eine neue Version zu geben :). <br><br><h2>  Einf√ºhrung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wireshark</a> ist ein bekanntes Tool zur Erfassung und Analyse des Netzwerkverkehrs.  Das Programm funktioniert mit den meisten bekannten Protokollen, verf√ºgt √ºber eine intuitive und logische grafische Oberfl√§che, ein leistungsstarkes Filtersystem.  Wireshark ist plattform√ºbergreifend und funktioniert unter folgenden Betriebssystemen wie Windows, Linux, MacOS, Solaris, FreeBSD, NetBSD und vielen anderen. <br><br>  F√ºr die Quellcode-Analyse haben wir den statischen Code-Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> verwendet.  Um den Quellcode zu analysieren, mussten wir zuerst das Projekt in einem Betriebssystem kompilieren.  Die Auswahl war nicht nur aufgrund des plattform√ºbergreifenden Charakters des Projekts, sondern auch aufgrund des Analysators gro√ü.  Ich habe macOS f√ºr die Analyse ausgew√§hlt.  Sie k√∂nnen den Analyzer auch unter Windows und Linux ausf√ºhren. <br><a name="habracut"></a><br>  Ich m√∂chte besonders auf die Codequalit√§t aufmerksam machen.  Leider kann ich keine gro√üen Punkte geben.  Es ist eine subjektive Einsch√§tzung, aber da wir regelm√§√üig viele Projekte √ºberpr√ºfen, habe ich einen Bezugsrahmen.  Was in diesem Fall auff√§llt, ist eine gro√üe Anzahl von PVS-Studio-Warnungen f√ºr eine kleine Menge Code.  Insgesamt wurden f√ºr dieses Projekt mehr als 3500 Warnungen aller Ebenen ausgel√∂st.  Dies ist typisch f√ºr Projekte, bei denen im Allgemeinen keine statischen Analysewerkzeuge verwendet werden, auch keine kostenlosen.  Ein weiterer Faktor, der auf die Projektqualit√§t hinweist, sind wiederholte Fehler, die vom Analyseger√§t erkannt werden.  Ich werde keine Codebeispiele vom gleichen Typ zitieren, w√§hrend einige √§hnliche Fehler an Hunderten von Stellen auftreten. <br><br>  Solche Einf√ºgungen verbessern auch nicht die Codequalit√§t: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Input file: packet-acse-template.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 1 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./asn1/acse/packet-acse-template.c"</span></span></span></span></code> </pre> <br>  Es gibt mehr als 1000 von ihnen im gesamten Projekt.  Solche Einf√ºgungen erschweren es dem Analysator, ausgegebene Warnungen mit den entsprechenden Dateien abzugleichen.  Nun, ich denke, durchschnittliche Entwickler werden keinen Kick davon bekommen, solchen Code zu pflegen. <br><br><h2>  Tippfehler </h2><br>  <b>Warnung 1</b> <br><br>  V641 Die Gr√∂√üe des zugewiesenen Speicherpuffers ist kein Vielfaches der Elementgr√∂√üe.  mate_setup.c 100 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> mate_cfg_gog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gogcfg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mate_config* mc, gchar* name)</span></span></span><span class="hljs-function"> </span></span>{ mate_cfg_gog* cfg = (mate_cfg_gog *)g_malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mate_cfg_gop)); .... }</code> </pre> <br>  Es gibt zwei Arten von Strukturen: <i>mate_cfg_gog</i> und <i>mate_cfg_gop.</i> Sie sind sehr √§hnlich, aber nicht gleich.  H√∂chstwahrscheinlich sind in diesem Code Fragmentfunktionen verwechselt, was mit potenziellen Fehlern im Programm behaftet ist, wenn √ºber einen Zeiger auf den Speicher zugegriffen wird. <br><br>  Hier sind die Fragmente gemischter Datenstrukturen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gog</span></span></span><span class="hljs-class"> {</span></span> gchar* name; GHashTable* items; guint last_id; GPtrArray* transforms; LoAL* keys; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">gop_tree_mode_t</span></span> gop_tree_mode; gboolean show_times; .... } mate_cfg_gog; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gop</span></span></span><span class="hljs-class"> {</span></span> gchar* name; guint last_id; GHashTable* items; GPtrArray* transforms; gchar* on_pdu; AVPL* key; AVPL* start; AVPL* stop; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> idle_timeout; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lifetime; gboolean drop_unassigned; <span class="hljs-keyword"><span class="hljs-keyword">gop_pdu_tree_t</span></span> pdu_tree_mode; gboolean show_times; .... } mate_cfg_gop;</code> </pre> <br>  <b>Warnung 2</b> <br><br>  V519 Der Variablen 'HDR_TCP.dest_port' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 495, 496. text_import.c 496 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_current_packet</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... HDR_TCP.source_port =isOutbound ? g_htons(hdr_dest_port):g_htons(hdr_src_port); HDR_TCP.dest_port = isOutbound ? g_htons(hdr_src_port) :g_htons(hdr_dest_port); HDR_TCP.dest_port = g_htons(hdr_dest_port); .... }</code> </pre> <br>  In der letzten Zeile wird der Wert (der gerade ausgewertet wurde) der Variablen <i>HDR_TCP.dest_port</i> neu geschrieben. <br><br><h2>  Logische Fehler </h2><br>  In diesem Abschnitt werde ich einige Beispiele f√ºr Fehler in bedingten Operatoren anf√ºhren, die sich alle vollst√§ndig voneinander unterscheiden. <br><br>  <b>Warnung 1</b> <br><br>  V547 Der Ausdruck 'direction == 0' ist immer falsch.  packet-adb.c 291 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_RECV 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_SENT 0 static void save_command(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( service_data &amp;&amp; service_data-&gt;remote_id == 0 &amp;&amp; direction == P2P_DIR_RECV) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (direction == P2P_DIR_SENT) { service_data-&gt;remote_id = arg1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// unreachable code } else { service_data-&gt;remote_id = arg0; } .... } .... }</span></span></span></span></code> </pre> <br>  Im externen Zustand wird die <i>Richtungsvariable</i> mit der Konstanten <i>P2P_DIR_RECV</i> verglichen <i>.</i>  Gem√§√ü den mit dem AND-Operator geschriebenen Ausdr√ºcken unterscheidet sich der Wert der variablen <i>Richtung</i> beim Erreichen der inneren Bedingung definitiv von einer anderen Konstanten <i>P2P_DIR_SENT</i> . <br><br>  <b>Warnung 2</b> <br><br>  V590 √úberpr√ºfen Sie die '(Typ == 0x1) ||  (Typ! = 0x4) 'Ausdruck.  Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler.  packet-fcsb3.c 686 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_fc_sbccs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((type == FC_SBCCS_IU_CMD_HDR) || (type != FC_SBCCS_IU_CMD_DATA)) { .... }</code> </pre> <br>  Der Fehler dieses Codefragments besteht darin, dass das Ergebnis der Bedingung nur von einem Ausdruck abh√§ngt: <br><br><pre> <code class="cpp hljs">(type != FC_SBCCS_IU_CMD_DATA)</code> </pre> <br>  <b>Warnung 3</b> <br><br>  V590 √úberpr√ºfen Sie diesen Ausdruck.  Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler.  snort-config.c 40 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhiteSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *accumulated_offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Skip any leading whitespace */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (source[offset] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; source[offset] == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { offset++; } *accumulated_offset += offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source + offset; }</code> </pre> <br>  Das Ergebnis des bedingten Operators h√§ngt nur von diesem Teil des Ausdrucks ab <i>(Quelle [Offset] == ‚Äã‚Äã'')</i> .  Die Pr√ºfung <i>(Quelle [Offset]! = '\ 0')</i> ist redundant und kann sicher entfernt werden.  Es ist nicht der eigentliche Fehler, aber redundanter Code erschwert das Lesen und Verstehen des Codes des Programms. Daher ist es besser, ihn zu vereinfachen. <br><br>  <b>Warnung 4</b> <br><br>  V547 Der Ausdruck 'eras_pos! = NULL' ist immer wahr.  reedsolomon.c 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eras_dec_rs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dtype data[NN], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eras_pos[NN-KK], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> no_eras)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;count;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos!= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) eras_pos[i] = INDEX_TO_POS(loc[i]); } } .... }</code> </pre> <br>  Vielleicht haben wir es mit einer redundanten Pr√ºfung zu tun, wahrscheinlich mit einem Tippfehler, und eine andere Sache muss in einer der Bedingungen des <i>if-</i> Blocks √ºberpr√ºft werden. <br><br><h2>  Seltsame Behauptungen </h2><br>  <b>Warnung 1</b> <br><br>  V547 Ausdruck 'sub_dissectors! = NULL' ist immer wahr.  capture_dissectors.c 129 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capture_dissector_add_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sub_dissectors = (struct capture_dissector_table*)g_hash_table_lookup(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sub_dissectors == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"OOPS: Subdissector \"%s\" not found ... \n"</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getenv(<span class="hljs-string"><span class="hljs-string">"WIRESHARK_ABORT_ON_DISSECTOR_BUG"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } g_assert(sub_dissectors != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Die Pr√ºfung des <i>g_assert-</i> Zeigers ist hier redundant, da der Zeiger bereits zuvor gepr√ºft wurde.  Vielleicht war nur <i>g_assert</i> in dieser Funktion und ein Entwickler hat vergessen, sie zu entfernen, aber vielleicht h√§tte hier ein Strukturfeld √ºberpr√ºft werden sollen. <br><br>  <b>Warnung 2</b> <br><br>  V547 Der Ausdruck 'i &lt;count' ist immer wahr.  packet-netflow.c 10363 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_v9_v10_template_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... count = tmplt_p-&gt;field_count[fields_type]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmplt_p-&gt;fields_p[fields_type] != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { DISSECTOR_ASSERT (i &lt; count); <span class="hljs-comment"><span class="hljs-comment">// &lt;= tmplt_p-&gt;fields_p[fields_type][i].type = type; tmplt_p-&gt;fields_p[fields_type][i].length = length; tmplt_p-&gt;fields_p[fields_type][i].pen = pen; tmplt_p-&gt;fields_p[fields_type][i].pen_str = pen_str; if (length != VARIABLE_LENGTH) {/ tmplt_p-&gt;length += length; } } .... } .... }</span></span></code> </pre> <br>  Es ist nicht ganz klar, warum <i>Assert</i> , das die Bedingung aus der Schleife dupliziert, in der Funktion stattfindet.  Der Schleifenz√§hler √§ndert sich im K√∂rper nicht. <br><br><h2>  Fehler mit Zeigern </h2><br>  <b>Warnung 1</b> <br><br>  V595 Der Zeiger 'si-&gt; conv' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2135, 2144. packet-smb2.c 2135 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_smb2_fid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... g_hash_table_insert(si-&gt;conv-&gt;fids, sfi, sfi); <span class="hljs-comment"><span class="hljs-comment">// &lt;= si-&gt;file = sfi; if (si-&gt;saved) { si-&gt;saved-&gt;file = sfi; si-&gt;saved-&gt;policy_hnd = policy_hnd; } if (si-&gt;conv) { // &lt;= eo_file_info = (.... *)g_hash_table_lookup(si-&gt;conv-&gt;files,&amp;policy_hnd); .... } .... }</span></span></code> </pre> <br>  Der Zeiger <i>si-&gt; conv</i> wird einige Zeilen vor seiner Pr√ºfung auf null dereferenziert. <br><br>  <b>Warnung 2</b> <br><br>  V774 Der 'Protos'-Zeiger wurde verwendet, nachdem der Speicher freigegeben wurde.  Paket-k12.c 311 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k12_update_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** err)</span></span></span><span class="hljs-function"> </span></span>{ gchar** protos; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_protos; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! (h-&gt;handles[i] = find_dissector(protos[i])) ) { h-&gt;handles[i] = data_handle; h-&gt;handles[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; g_strfreev(protos); *err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } } .... }</code> </pre> <br>  <i>protos</i> ist eine Reihe von Zeichenfolgen.  Bei der Behandlung eines Sonderfalls im Programm wird dieses Array zuerst von der Funktion <i>g_strfreev gel√∂scht</i> , und dann wird eine Zeichenfolge dieses Arrays in der Fehlermeldung verwendet.  H√∂chstwahrscheinlich sollten diese Zeilen vertauscht werden: <br><br><pre> <code class="cpp hljs">*err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); g_strfreev(protos);</code> </pre> <br><h2>  Speicherlecks </h2><br>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2436 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsetypedefunion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmpstr[BASE_BUFFER_SIZE], *ptmpstr; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(num_pointers--){ g_snprintf(tmpstr, BASE_BUFFER_SIZE, <span class="hljs-string"><span class="hljs-string">"%s_%s"</span></span>, ptmpstr, <span class="hljs-string"><span class="hljs-string">"unique"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"static int\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"...."</span></span>, tmpstr); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"{\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" ...."</span></span>, ptmpstr, ti-&gt;str); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" return offset;\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); ptmpstr=g_strdup(tmpstr); } .... }</code> </pre> <br>  Nach der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>g_strdup</i></a> m√ºssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>irgendwann die</i></a> Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>g_free</i></a> aufrufen.  Dies wird im angegebenen Codeausschnitt nicht ausgef√ºhrt, und bei jeder Iteration wird ein neuer Teil des Speichers in der Schleife zugewiesen.  Hier kommen mehrere Speicherlecks. <br><br>  Einige andere Warnungen f√ºr √§hnliche Codefragmente: <br><br><ul><li>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2447 </li><li>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2713 </li><li>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2728 </li><li>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2732 </li><li>  V773 Dem Zeiger 'ptmpstr' wurden zweimal Werte zugewiesen, ohne den Speicher freizugeben.  Ein Speicherverlust ist m√∂glich.  idl2wrs.c 2745 </li></ul><br>  Leider gibt es im Code viele andere √§hnliche F√§lle, in denen Speicher freigegeben wird. <br><br><h2>  Verschiedenes </h2><br>  <b>Warnung 1</b> <br><br>  V535 Die Variable 'i' wird f√ºr diese Schleife und f√ºr die √§u√üere Schleife verwendet.  √úberpr√ºfen Sie die Zeilen: 7716, 7798. packet-opa-mad.c 7798 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Parse GetVFInfo MAD from the Performance Admin class. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_GetVFInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; records; i++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= line 7716 .... for (i = 0; i &lt; PM_UTIL_BUCKETS; i++) { // &lt;= line 7748 GetVFInfo_Util_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; } .... for (i = 0; i &lt; PM_ERR_BUCKETS; i++) { // &lt;= line 7798 GetVFInfo_Error_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; .... } .... } .... }</span></span></code> </pre> <br>  In einer sehr langen Funktion √§ndern Entwickler mutig den Wert des Schleifenz√§hlers, sogar einige Male.  Wir k√∂nnen nicht sicher sagen, ob es sich um einen Fehler handelt oder nicht, es gibt jedoch ungef√§hr 10 solcher Schleifen im Projekt. <br><br>  <b>Warnung 2</b> <br><br>  V763 Der Parameter 'item' wird vor seiner Verwendung immer im Funktionsk√∂rper neu geschrieben.  packet-cdma2k.c 1324 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cdma2k_message_ORDER_IND</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proto_item *item, ....)</span></span></span><span class="hljs-function"> </span></span>{ guint16 addRecLen = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordq = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rejectedtype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; guint16 l_offset = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rsc_mode_ind = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordertype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; proto_tree *subtree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, *subtree1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; item = proto_tree_add_item(tree,hf_cdma2k_OrderIndMsg, tvb, ....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= subtree = proto_item_add_subtree(item, ett_cdma2k_subtree1); .... }</span></span></code> </pre> <br>  Der von der Funktion verwendete Elementzeiger wird sofort um einen anderen Wert ge√§ndert.  Es ist sehr verd√§chtig.  Dar√ºber hinaus enth√§lt der Code mehrere Dutzend solcher Stellen, sodass es schwierig ist zu entscheiden, ob es sich um einen Fehler handelt oder nicht.  Ich bin in einem anderen gro√üen Projekt auf √§hnlichen Code gesto√üen, dieser Code war dort korrekt, niemand hat es einfach gewagt, die Benutzeroberfl√§che der Funktion zu √§ndern. <br><br>  <b>Warnung 3</b> <br><br>  V762 M√∂glicherweise wurde eine virtuelle Funktion falsch √ºberschrieben.  Siehe drittes Argument der Funktion 'headerData' in der abgeleiteten Klasse 'PacketListModel' und der Basisklasse 'QAbstractItemModel'.  packet_list_model.h 48 <br><br><pre> <code class="cpp hljs">QVariant QAbstractItemModel::headerData(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> section, Qt::Orientation orientation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role = Qt::DisplayRole) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= class PacketListModel : public QAbstractItemModel { Q_OBJECT public: .... QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole | Qt::ToolTipRole) const; // &lt;= .... };</span></span></code> </pre> <br>  Der Analysator hat die ung√ºltige √úberladung der Funktion <i>headerData festgestellt</i> .  Funktionen haben unterschiedliche Standardwerte f√ºr den Rollenparameter.  Dies kann zu einem falschen Verhalten f√ºhren, das nicht von einem Programmierer erwartet wird. <br><br>  <b>Warnung 4</b> <br><br>  V610 Undefiniertes Verhalten.  √úberpr√ºfen Sie den Schaltoperator '&gt;&gt;'.  Der rechte Operand ('bitshift' = [0..64]) ist gr√∂√üer oder gleich der L√§nge des heraufgestuften linken Operanden in Bit.  proto.c 10941 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_item_add_bitmask_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || len &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) g_assert_not_reached(); bitshift = (<span class="hljs-number"><span class="hljs-number">8</span></span> - (guint)len)*<span class="hljs-number"><span class="hljs-number">8</span></span>; available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift; .... }</code> </pre> <br>  Eine 64-Bit-Verschiebung f√ºhrt zu einem undefinierten Verhalten gem√§√ü Sprachstandard. <br><br>  H√∂chstwahrscheinlich sollte der richtige Code folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitshift == <span class="hljs-number"><span class="hljs-number">64</span></span>) available_bits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift;</code> </pre> <br><h2>  Fazit </h2><br>  Es mag den Anschein haben, dass diese √úberpr√ºfung nur wenige Fehler aufweist, aber im vollst√§ndigen Bericht wiederholen sich die betrachteten F√§lle Dutzende und Hunderte Male.  Dar√ºber hinaus sind PVS-Studio-Warn√ºberpr√ºfungen demonstrativer Natur.  Sie stellen einen Beitrag zur Qualit√§t von Open Source-Projekten dar, einmalige √úberpr√ºfungen sind jedoch hinsichtlich der statischen Analysemethode am ineffizientesten. <br><br>  Sie k√∂nnen den vollst√§ndigen Bericht selbst abrufen und analysieren.  Dazu m√ºssen Sie nur den PVS-Studio-Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> und ausf√ºhren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447156/">https://habr.com/ru/post/de447156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447146/index.html">EKI Industrial Unmanaged Switches</a></li>
<li><a href="../de447148/index.html">Die (un) offizielle Habr-Anwendung - HabrApp 2.0: Zugriff</a></li>
<li><a href="../de447150/index.html">Chatten Sie auf der Website und in der Ausgabe von Yandex</a></li>
<li><a href="../de447152/index.html">Plattform√ºbergreifendes .NET UI Toolkit Release AvaloniaUI 0.8</a></li>
<li><a href="../de447154/index.html">Technische Schulden, die zu einer Unternehmenskrise f√ºhren</a></li>
<li><a href="../de447158/index.html">Wireshark 3.x: MacOS-Code-Analyse und Fehler√ºberpr√ºfung</a></li>
<li><a href="../de447160/index.html">Platz f√ºr Kinder. Ein paar Ideen zum Cosmonautics Day</a></li>
<li><a href="../de447162/index.html">Kaufen Sie kein ERP</a></li>
<li><a href="../de447164/index.html">Wie kann man die Vorteile eines Laptops und eines Desktop-Computers kombinieren? Analyse von Problemen und L√∂sungen (Teil 2)</a></li>
<li><a href="../de447166/index.html">Helpdesk in 3 Stunden. Automatisieren Sie einfache Gesch√§ftsprozesse in PowerApps, Flow und Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>