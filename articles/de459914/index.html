<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¥ üë∂ üßëüèæ‚Äçü§ù‚Äçüßëüèæ SQL Index Manager - ein kostenloses Tool zum Defragmentieren und Verwalten von Indizes üòù üëæ üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit vielen Jahren als SQL Server-DBA t√§tig, Serveradministration und anschlie√üend Leistungsoptimierung. Im Allgemeinen wollte ich in meiner Freizeit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL Index Manager - ein kostenloses Tool zum Defragmentieren und Verwalten von Indizes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459914/">  Seit vielen Jahren als SQL Server-DBA t√§tig, Serveradministration und anschlie√üend Leistungsoptimierung.  Im Allgemeinen wollte ich in meiner Freizeit etwas N√ºtzliches f√ºr das Universum und unsere Kollegen tun.  Am Ende haben wir also ein kleines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Source</a> Index-Wartungstool f√ºr SQL Server und Azure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/8b0/98e/5468b098eea90eb287427b56021c6962.png" alt="SQL Index Manager"><br><br><a name="habracut"></a><h3>  Idee </h3><br>  Wenn Sie an ihren Priorit√§ten arbeiten, √§hneln die Leute manchmal einer Fingerbatterie - es gibt genug Motivationsladung f√ºr nur einen Blitz, und dann ist es soweit.  Und bis vor kurzem war ich keine Ausnahme von dieser Beobachtung des Lebens.  Oft besuchten mich Ideen, um etwas Eigenes zu kreieren, aber die Priorit√§ten √§nderten sich und nichts wurde zum Ende gebracht. <br><br>  Einen ziemlich starken Einfluss auf meine Motivation und berufliche Entwicklung hatte die Arbeit in der Kharkov-Firma Devart, die sich mit der Erstellung von Software f√ºr die Entwicklung und Verwaltung von SQL Server-, MySQL- und Oracle-Datenbanken befasste. <br><br>  Bevor ich zu ihnen kam, hatte ich wenig Ahnung von den Besonderheiten der Erstellung meines eigenen Produkts, aber bereits im Prozess habe ich viel Wissen √ºber die interne Struktur von SQL Server gewonnen.  Nachdem ich mehr als ein Jahr lang Metadatenabfragen in ihren Produktlinien optimiert hatte, begann ich allm√§hlich zu verstehen, welche Funktionen auf dem Markt mehr gefragt sind als alle anderen. <br><br>  Zu einem bestimmten Zeitpunkt entstand die Idee, ein neues Nischenprodukt zu schaffen, aber aufgrund der Umst√§nde setzte sich diese Idee nicht durch.  Zu diesem Zeitpunkt gab es f√ºr das neue Projekt nicht gen√ºgend freie Ressourcen innerhalb des Unternehmens, unbeschadet des Kerngesch√§fts. <br><br>  Bereits als er an einem neuen Ort arbeitete und versuchte, das Projekt alleine zu machen, musste er st√§ndig Kompromisse eingehen.  Die urspr√ºngliche Idee, ein gro√ües Produkt mit zahlreichen Funktionen zu versehen, wurde schnell zunichte gemacht und schrittweise in eine andere Richtung umgewandelt - die geplante Funktionalit√§t in separate Mini-Tools aufzuteilen und diese unabh√§ngig voneinander zu implementieren. <br><br>  Als Ergebnis wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>SQL Index Manager</b></a> geboren - ein kostenloses Tool zur Indexpflege f√ºr SQL Server und Azure.  Die Hauptidee war, kommerzielle Alternativen von RedGate und Devart als Grundlage zu nehmen und zu versuchen, ihre Funktionalit√§t zu verbessern.  Sowohl Anf√§ngern als auch erfahrenen Benutzern die M√∂glichkeit zu bieten, Indizes bequem zu analysieren und zu pflegen. <br><br><h3>  Implementierung </h3><br>  Mit anderen Worten, alles klingt immer einfach ... Ich nahm einen und sah mir ein paar motivierende Vidosiks an, stand im Regal und fing an, ein cooles Produkt herzustellen.  In der Praxis ist jedoch nicht alles so rosig, da es bei der Arbeit mit der Systemtabellenfunktion sys.dm_db_index_physical_stats viele Fallstricke gibt und in Kombination der einzige Ort, an dem Sie relevante Informationen zur Indexfragmentierung erhalten k√∂nnen. <br><br>  Von den ersten Tagen der Entwicklung an gab es eine gro√üartige Gelegenheit, einen trostlosen Weg zwischen den Standardschemata zu finden und die bereits debuggte Logik der Arbeit konkurrierender Anwendungen zu kopieren, w√§hrend ein kleiner Gag hinzugef√ºgt wurde.  Nachdem ich die Anfragen nach Metadaten analysiert hatte, wollte ich etwas Optimierteres tun, das aufgrund der B√ºrokratie gro√üer Unternehmen niemals in ihren Produkten aufgetaucht w√§re. <br><br>  Bei der Analyse des RedGate SQL Index Managers (1.1.9.1378 - $ 155) k√∂nnen Sie feststellen, dass die Anwendung einen sehr einfachen Ansatz verwendet: Mit einer Abfrage erhalten wir eine Liste der Benutzertabellen und -ansichten, und nach der zweiten Abfrage wird eine Liste aller Indizes in der ausgew√§hlten Datenbank zur√ºckgegeben. <br><br><pre><code class="1c hljs">SELECT objects.name AS tableOrViewName , objects.object_id AS tableOrViewId , schemas.name AS schemaName , CAST(ISNULL(lobs.NumLobs, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS BIT) AS ContainsLobs , o.is_memory_optimized FROM sys.objects AS objects JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id LEFT JOIN ( SELECT object_id , COUNT(*) AS NumLobs FROM sys.columns WITH (NOLOCK) WHERE system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY object_id ) AS lobs ON objects.object_id = lobs.object_id LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id WHERE objects.type = 'U' OR objects.type = 'V' SELECT i.object_id AS tableOrViewId , i.name AS indexName , i.index_id AS indexId , i.allow_page_locks AS allowPageLocks , p.partition_number AS partitionNumber , CAST((c.numPartitions - <span class="hljs-number"><span class="hljs-number">1</span></span>) AS BIT) AS belongsToPartitionedIndex FROM sys.indexes AS i JOIN sys.partitions AS p ON p.index_id = i.index_id AND p.object_id = i.object_id JOIN ( SELECT COUNT(*) AS numPartitions , object_id , index_id FROM sys.partitions GROUP BY object_id , index_id ) AS c ON c.index_id = i.index_id AND c.object_id = i.object_id WHERE i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -- ignore heaps AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Dann wird in einem Zyklus f√ºr jeden Abschnitt des Index eine Anforderung gesendet, um seine Gr√∂√üe und seinen Fragmentierungsgrad zu bestimmen.  Am Ende des Scans werden Indizes, die weniger als den Eintragsschwellenwert wiegen, auf dem Client verworfen. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">2</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">3</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Bei der Analyse der Logik dieser Anwendung k√∂nnen Sie viele M√§ngel feststellen.  Wenn Sie beispielsweise Fehler bei Kleinigkeiten feststellen, wird vor dem Senden einer Anforderung nicht √ºberpr√ºft, ob der aktuelle Abschnitt Zeichenfolgen enth√§lt, um leere Abschnitte vom Scannen auszuschlie√üen. <br><br>  Das Problem ist jedoch in einem anderen Aspekt am akutesten: Die Anzahl der Serveranforderungen entspricht ungef√§hr der Gesamtzahl der Zeilen von sys.partitions.  Angesichts der Tatsache, dass echte Datenbanken Zehntausende von Abschnitten enthalten k√∂nnen, kann diese Nuance zu einer gro√üen Anzahl √§hnlicher Anforderungen an den Server f√ºhren.  In einer Situation, in der die Datenbank entfernt ist, wird die Scan-Zeit aufgrund erh√∂hter Netzwerkverz√∂gerungen f√ºr jede, selbst die einfachste Anforderung, noch l√§nger. <br><br>  Im Gegensatz zu RedGate empf√§ngt ein √§hnliches Produkt, das in Devart entwickelt wurde - dbForge Index Manager f√ºr SQL Server (1.10.38 - 99 US-Dollar) - Informationen in einer gro√üen Abfrage und zeigt dann alles auf dem Client an: <br><br><pre> <code class="1c hljs">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name] , o.name AS parent_name , o.[type] AS parent_type , i.name , i.type_desc , s.avg_fragmentation_in_percent , s.page_count , p.partition_number , p.[rows] , ISNULL(lob.is_lob_legacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob_legacy , ISNULL(lob.is_lob, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob , CASE WHEN ds.[type] = 'PS' THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS is_partitioned FROM sys.dm_db_index_physical_stats(DB_ID(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) s JOIN sys.partitions p ON s.[object_id] = p.[object_id] AND s.index_id = p.index_id AND s.partition_number = p.partition_number JOIN sys.indexes i ON i.[object_id] = s.[object_id] AND i.index_id = s.index_id LEFT JOIN ( SELECT c.[object_id] , index_id = ISNULL(i.index_id, <span class="hljs-number"><span class="hljs-number">1</span></span>) , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) , is_lob = MAX(CASE WHEN c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) FROM sys.columns c LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id] AND c.column_id = i.column_id AND i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> WHERE c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY c.[object_id], i.index_id ) lob ON lob.[object_id] = i.[object_id] AND lob.index_id = i.index_id JOIN sys.objects o ON o.[object_id] = i.[object_id] JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id WHERE i.[type] IN (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.index_level = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.alloc_unit_type_desc = 'IN_ROW_DATA' AND o.[type] IN ('U', 'V')</code> </pre> <br>  Wir haben es geschafft, das Hauptproblem mit dem Schleier der gleichen Art von Abfragen in einem Konkurrenzprodukt zu beseitigen, aber die Nachteile dieser Implementierung sind, dass keine zus√§tzlichen Parameter an die Funktion sys.dm_db_index_physical_stats √ºbergeben werden, die das Scannen offensichtlich unn√∂tiger Indizes einschr√§nken k√∂nnen.  Tats√§chlich f√ºhrt dies dazu, dass Informationen zu allen Indizes im System und zus√§tzliche Festplattenlasten in der Scanphase abgerufen werden. <br><br>  Es ist wichtig zu beachten, dass die aus sys.dm_db_index_physical_stats erhaltenen Daten nicht dauerhaft im Pufferpool zwischengespeichert werden. Daher war die Minimierung der physischen Messwerte beim Abrufen von Informationen zur Indexfragmentierung eine der vorrangigen Aufgaben w√§hrend der Entwicklung. <br><br>  Nach mehreren Experimenten stellte sich heraus, dass beide Ans√§tze kombiniert wurden, wobei der Scan in zwei Teile geteilt wurde.  Zun√§chst bestimmt eine gro√üe Abfrage die Gr√∂√üe der Abschnitte, wobei diejenigen vorgefiltert werden, die nicht im Filterbereich liegen: <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#AllocationUnits (ContainerID, ReservedPages, UsedPages) SELECT [container_id] , SUM([total_pages]) , SUM([used_pages]) FROM sys.allocation_units WITH(NOLOCK) GROUP BY [container_id] HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span></span></code> </pre> <br>  Als n√§chstes erhalten wir nur die Abschnitte, die Daten enthalten, um unn√∂tige Lesevorg√§nge aus leeren Indizes zu vermeiden. <br><br><pre> <code class="1c hljs">SELECT [object_id] , [index_id] , [partition_id] , [partition_number] , [rows] , [data_compression] INTO <span class="hljs-meta"><span class="hljs-meta">#Partitions FROM sys.partitions WITH(NOLOCK) WHERE [object_id] &gt; 255 AND [rows] &gt; 0 AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span></span></code> </pre> <br>  Abh√§ngig von den Einstellungen werden nur die Indextypen abgerufen, die der Benutzer analysieren m√∂chte (die Arbeit mit Heaps, Cluster- / Nicht-Cluster-Indizes und Spaltenindikatoren wird unterst√ºtzt). <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Indexes SELECT ObjectID = i.[object_id] , IndexID = i.index_id , IndexName = i.[name] , PagesCount = a.ReservedPages , UnusedPagesCount = a.ReservedPages - a.UsedPages , PartitionNumber = p.[partition_number] , RowsCount = ISNULL(p.[rows], 0) , IndexType = i.[type] , IsAllowPageLocks = i.[allow_page_locks] , DataSpaceID = i.[data_space_id] , DataCompression = p.[data_compression] , IsUnique = i.[is_unique] , IsPK = i.[is_primary_key] , FillFactorValue = i.[fill_factor] , IsFiltered = i.[has_filter] FROM #AllocationUnits a JOIN #Partitions p ON a.ContainerID = p.[partition_id] JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id] AND p.[index_id] = i.[index_id] WHERE i.[type] IN (0, 1, 2, 5, 6) AND i.[object_id] &gt; 255</span></span></code> </pre> <br>  Danach beginnt ein wenig Magie: F√ºr alle kleinen Indizes bestimmen wir den Fragmentierungsgrad, indem wir wiederholt die Funktion sys.dm_db_index_physical_stats mit einer vollst√§ndigen Angabe aller Parameter aufrufen. <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation) SELECT i.ObjectID , i.IndexID , i.PartitionNumber , r.[avg_fragmentation_in_percent] FROM #Indexes i CROSS APPLY sys.dm_db_index_physical_stats(@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, 'LIMITED') r WHERE i.PagesCount &lt;= @PreDescribeSize AND r.[index_level] = 0 AND r.[alloc_unit_type_desc] = 'IN_ROW_DATA' AND i.IndexType IN (0, 1, 2)</span></span></code> </pre> <br>  Als n√§chstes geben wir alle m√∂glichen Informationen an den Client zur√ºck und filtern die √ºbersch√ºssigen Daten heraus: <br><br><pre> <code class="1c hljs">SELECT i.ObjectID , i.IndexID , i.IndexName , ObjectName = o.[name] , SchemaName = s.[name] , i.PagesCount , i.UnusedPagesCount , i.PartitionNumber , i.RowsCount , i.IndexType , i.IsAllowPageLocks , u.TotalWrites , u.TotalReads , u.TotalSeeks , u.TotalScans , u.TotalLookups , u.LastUsage , i.DataCompression , f.Fragmentation , IndexStats = STATS_DATE(i.ObjectID, i.IndexID) , IsLobLegacy = ISNULL(lob.IsLobLegacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsLob = ISNULL(lob.IsLob, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsSparse = CAST(CASE WHEN p.ObjectID IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">0</span></span> ELSE <span class="hljs-number"><span class="hljs-number">1</span></span> END AS BIT) , IsPartitioned = CAST(CASE WHEN dds.[data_space_id] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS BIT) , FileGroupName = fg.[name] , i.IsUnique , i.IsPK , i.FillFactorValue , i.IsFiltered , a.IndexColumns , a.IncludedColumns FROM <span class="hljs-meta"><span class="hljs-meta">#Indexes i JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id] LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID AND a.IndexID = i.IndexID LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID AND f.IndexID = i.IndexID AND f.PartitionNumber = i.PartitionNumber LEFT JOIN ( SELECT ObjectID = [object_id] , IndexID = [index_id] , TotalWrites = NULLIF([user_updates], 0) , TotalReads = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0) , TotalSeeks = NULLIF([user_seeks], 0) , TotalScans = NULLIF([user_scans], 0) , TotalLookups = NULLIF([user_lookups], 0) , LastUsage = ( SELECT MAX(dt) FROM ( VALUES ([last_user_seek]) , ([last_user_scan]) , ([last_user_lookup]) , ([last_user_update]) ) t(dt) ) FROM sys.dm_db_index_usage_stats WITH(NOLOCK) WHERE [database_id] = @DBID ) u ON i.ObjectID = u.ObjectID AND i.IndexID = u.IndexID LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID AND lob.IndexID = i.IndexID LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) ON i.DataSpaceID = dds.[partition_scheme_id] AND i.PartitionNumber = dds.[destination_id] JOIN sys.filegroups fg WITH(NOLOCK) ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id] WHERE o.[type] IN ('V', 'U') AND ( f.Fragmentation &gt;= @Fragmentation OR i.PagesCount &gt; @PreDescribeSize OR i.IndexType IN (5, 6) )</span></span></code> </pre> <br>  Danach bestimmen Punktabfragen den Fragmentierungsgrad f√ºr gro√üe Indizes. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1044198770</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1552724584</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">0</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Aufgrund dieses Ansatzes konnten beim Generieren von Abfragen die Probleme mit der Scanleistung gel√∂st werden, die in den Anwendungen der Wettbewerber auftraten.  Dies konnte abgeschlossen werden, aber im Verlauf der Entwicklung tauchten nach und nach neue Ideen auf, die es erm√∂glichten, den Anwendungsbereich Ihres Produkts zu erweitern. <br><br>  Zun√§chst wurde die Unterst√ºtzung f√ºr die Arbeit mit WAIT_AT_LOW_PRIORITY implementiert, dann wurde es m√∂glich, DATA_COMPRESSION und FILL_FACTOR zum Neuerstellen von Indizes zu verwenden. <br><br><img src="https://habrastorage.org/webt/kd/em/xj/kdemxjo8sj0hxa4y_omvv3dph6a.png" alt="SQL Index Manager-Einstellungen"><br><br>  Die Anwendung war mit zuvor ungeplanten Funktionen wie der Wartung von Spaltenspeichern leicht √ºberwachsen: <br><br><pre> <code class="1c hljs">SELECT * FROM ( SELECT IndexID = [index_id] , PartitionNumber = [partition_number] , PagesCount = SUM([size_in_bytes]) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , Fragmentation = CAST(ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>. / SUM([size_in_bytes]) AS FLOAT) FROM sys.fn_column_store_row_groups(@ObjectID) GROUP BY [index_id] , [partition_number] ) t WHERE Fragmentation &gt;= @Fragmentation AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</code> </pre> <br>  Oder die M√∂glichkeit, nicht gruppierte Indizes basierend auf Informationen aus dm_db_missing_index zu erstellen: <br><br><pre> <code class="1c hljs">SELECT ObjectID = d.[object_id] , UserImpact = gs.[avg_user_impact] , TotalReads = gs.[user_seeks] + gs.[user_scans] , TotalSeeks = gs.[user_seeks] , TotalScans = gs.[user_scans] , LastUsage = ISNULL(gs.[last_user_scan], gs.[last_user_seek]) , IndexColumns = CASE WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] + ', ' + d.[inequality_columns] WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] ELSE d.[inequality_columns] END , IncludedColumns = d.[included_columns] FROM sys.dm_db_missing_index_groups g WITH(NOLOCK) JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) ON gs.[group_handle] = g.[index_group_handle] JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) ON g.[index_handle] = d.[index_handle] WHERE d.[database_id] = DB_ID()</code> </pre> <br><h3>  Zusammenfassung </h3><br>  Nach sechs Monaten aktiver Entwicklungsphase bin ich froh, dass die Pl√§ne dort nicht enden, da ich dieses Produkt weiterentwickeln m√∂chte.  Der n√§chste Schritt besteht darin, Funktionen f√ºr die Suche nach doppelten oder nicht verwendeten Indizes hinzuzuf√ºgen und die vollst√§ndige Unterst√ºtzung f√ºr die Bereitstellung von Statistiken in SQL Server zu implementieren. <br><br>  Aufgrund der Tatsache, dass es viele kostenpflichtige L√∂sungen auf dem Markt gibt, m√∂chte ich glauben, dass dieses Produkt aufgrund der freien Positionierung, einer optimierten Metadatenbeschreibung und des Vorhandenseins verschiedener n√ºtzlicher Kleinigkeiten f√ºr jemanden definitiv f√ºr allt√§gliche Aufgaben n√ºtzlich sein wird. <br><br>  Die aktuelle Version der Anwendung kann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>GitHub</b></a> heruntergeladen werden.  Quellen befinden sich am selben Ort. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459914/">https://habr.com/ru/post/de459914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459898/index.html">Der Plan ist in die Wirtschaft zur√ºckgekehrt</a></li>
<li><a href="../de459900/index.html">Visualisierung einer Spalte aus einem DataFrame mithilfe der Seaborn-Bibliothek</a></li>
<li><a href="../de459902/index.html">Interaktive Karte der russischen Regionen f√ºr Anf√§nger. Fehler, die ich gemacht habe und die du nicht machen darfst</a></li>
<li><a href="../de459906/index.html">Tic Tac Toe, Teil 3: R√ºckg√§ngig / Wiederherstellen mit Befehlsspeicher</a></li>
<li><a href="../de459910/index.html">Situation: Unternehmen haben es nicht eilig, Dienste f√ºr Sprachassistenten zu entwickeln - was sind die Risiken?</a></li>
<li><a href="../de459918/index.html">Probleml√∂sung mit pwnable.kr 03 - bof. Puffer√ºberlauf auf Stapel</a></li>
<li><a href="../de459922/index.html">Entfernen von hochfrequenten Ger√§uschen aus den Signalen von Schwingungssensoren w√§hrend der Schwingungsdiagnose von Lagern</a></li>
<li><a href="../de459924/index.html">Vollst√§ndiger Reaktionstestzyklus. Auto.ru-Bericht</a></li>
<li><a href="../de459928/index.html">Der Weg des Sch√ºlers zur Entwicklung mobiler Apps</a></li>
<li><a href="../de459930/index.html">Python-Importautomatisierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>