<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçâ üìè üë©üèæ‚Äçüè´ Sketch + Node.js: menghasilkan ikon untuk banyak platform dan merek. Bagian 2 üïì üß¢ üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua artikel tentang membuat alat yang dapat mengekspor semua ikon yang ditempatkan dalam file sketsa: dalam format yang berbeda, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sketch + Node.js: menghasilkan ikon untuk banyak platform dan merek. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/442886/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Ini adalah bagian kedua artikel tentang membuat alat yang dapat mengekspor semua ikon yang ditempatkan dalam file sketsa: dalam format yang berbeda, untuk platform yang berbeda, dengan kemungkinan pengujian A / B dari setiap ikon. <br><br>  Anda dapat membaca bagian pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari tautan</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Terakhir kali, kami menyiapkan file Sketsa yang berisi semua ikon dengan gaya yang tepat dan dengan nama yang benar.  Sekarang giliran menulis kode. <br><br>  Cukuplah untuk mengatakan bahwa kami melalui trial and error.  Setelah pemimpin tim kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nihil Verma</a> , yang meletakkan dasar-dasar naskah, mengembangkan kode sumber utama, saya memulai proses yang membutuhkan setidaknya tiga fase refactoring dan banyak modifikasi.  Untuk alasan ini, saya tidak akan membahas detail pembuatan skrip dan fokus pada cara kerjanya hari ini, dalam bentuk akhirnya. <br><a name="habracut"></a><br><h2>  Buat skrip </h2><br>  Skrip build yang ditulis di Node.js cukup mudah dalam pekerjaannya: dengan mengimpor dependensi, mendeklarasikan daftar file Sketch untuk diproses (ini adalah daftar merek, yang masing-masing memiliki daftar file yang terkait dengannya) dan memastikan Sketch diinstal pada klien , skrip memproses merek pada gilirannya, melakukan serangkaian tindakan dengan masing-masing. <br><br><ol><li>  Mengambil token desain yang sesuai untuk merek (kami membutuhkan nilai warna). <br></li><li>  File Sketsa terkait merek Clones, unzip mereka, mengekstraksi file JSON internal, dan memproses beberapa nilai internal mereka (lebih lanjut tentang ini nanti). <br></li><li>  Membaca metadata yang diperlukan dari file JSON ini ( <i>document.json</i> , <i>meta.json</i> dan <i>halaman / pageUniqueID.json</i> ).  Kami tertarik pada daftar gaya umum dan sumber daya / ikon yang terkandung dalam file. <br></li><li>  Setelah beberapa manipulasi dengan file JSON, itu menciptakan kembali arsip dan, menggunakan file Sketch (dikloning dan diperbarui), mengekspor dan membuat file output akhir untuk tiga platform (iOS, Android, Mobile Web). <br></li></ol><br>  Bagian-bagian yang relevan dari skrip build dapat ditemukan di sini: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; {   // get the design tokens for the brand   const brandTokens = getDesignTokens(brand);    // prepare the Sketch files (unzipped) and get a list of them   const sketchUnzipFolders = await prepareSketchFiles({     brand,     sketchFileNames: SKETCH_FILES[brand],     sketchFolder: SKETCH_FOLDER_PATH,     sketchTempFolder: SKETCH_TEMP_PATH   });   // get the Sketch metadata   const sketchMetadata = getSketchMetadata(sketchUnzipFolders);   const sketchDataSharedStyles = sketchMetadata.sharedStyles;   const sketchDataAssets = sketchMetadata.assetsMetadata;   generateAssetsPDF({     platform: 'ios',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsSVGDynamicMobileWeb({     platform: 'mw',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsVectorDrawableDynamicAndroid({     platform: 'android',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   }); }); }</code> </pre> <br>  Bahkan, kode pipa jauh lebih rumit.  Alasan untuk kompleksitas ini terletak pada fungsi <code>prepareSketchFiles</code> , <code>getSketchMetadata</code> dan fungsi <code>generateAssets[format][platform]</code> <code>getSketchMetadata</code> .  Di bawah ini saya akan mencoba menggambarkannya secara lebih rinci. <br><br><h2>  Mempersiapkan File Sketsa </h2><br>  Langkah pertama dalam proses perakitan adalah persiapan file Sketch, yang nantinya akan digunakan untuk mengekspor sumber daya untuk berbagai platform. <br><br>  File yang terkait dengan merek tertentu (misalnya, dalam kasus Blendr, ini adalah <i>icons_common.sketch</i> dan <i>file icons_blendr.sketch</i> ) dikloning ke folder sementara (lebih tepatnya, ke dalam subfolder bernama setelah merek diproses) dan membuka ritsleting. <br><br>  Kemudian file JSON diproses.  Awalan ditambahkan ke nama sumber daya yang tunduk pada pengujian A / B - dengan demikian, saat mengekspor, mereka akan disimpan dalam subfolder dengan nama yang telah ditentukan (sesuai dengan nama unik percobaan).  Anda dapat memahami apakah sumber daya tunduk pada pengujian A / B dengan nama halaman tempat penyimpanannya: jika ada, nama tersebut akan berisi awalan " <i>XP_</i> ". <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br><br>  Dalam contoh di atas, sumber daya yang diekspor akan disimpan dalam subfolder dari " <i>this__is_an_experiment</i> " dengan nama file dari bentuk " <i>icon-name [variant-name] .ext</i> ". <br><br><h2>  Membaca Sketsa Metadata </h2><br>  Langkah penting kedua adalah mengekstrak semua metadata yang diperlukan dari file Sketch, atau lebih tepatnya, dari file JSON internal.  Seperti yang kita lihat di atas, ini adalah dua file utama ( <i>document.json</i> dan <i>meta.json</i> ) dan file <i>halaman</i> ( <i>halaman / pageUniqueId.json</i> ). <br><br>  File <i>document.json</i> digunakan untuk mendapatkan daftar gaya umum yang muncul di bawah properti objek <i>layerStyles</i> : <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": {  "_class": "sharedStyleContainer",  "objects": [    {      "_class": "sharedStyle",      "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4",      "name": "features/feature-like",      "value": {        "_class": "style",        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.10588235408067703,              "green": 0.4000000059604645,              "red": 1            },            "fillType": 0,            "noiseIndex": 0,            "noiseIntensity": 0,            "patternFillType": 1,            "patternTileScale": 1          }        ],        "blur": {...},        "startMarkerType": 0,        "endMarkerType": 0,        "miterLimit": 10,        "windingRule": 1      }    },    ...</code> </pre> <br>  Kami menyimpan informasi dasar tentang setiap gaya dalam objek format nilai kunci.  Ini akan digunakan nanti ketika kita perlu mengekstrak nama gaya berdasarkan ID unik (properti <code>do_objectID</code> di Sketch): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = {  name: object.name,  isFill: _.get(object, 'value.fills[0].color') !== undefined,  isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br>  Sekarang kita pergi ke file <i>meta.json</i> dan mendapatkan daftar halaman.  Kami tertarik pada <code>unique-id</code> dan <code>name</code> <code>unique-id</code> mereka: <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": {  "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": {    "name": "Icons",    "artboards": {      "3275987C-CE1B-4369-B789-06366EDA4C98": {        "name": "badge-feature-like"      },      "C6992142-8439-45E7-A346-FC35FA01440F": {        "name": "badge-feature-crush"      },      ...      "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": {        "name": "tabbar-livestream"      }      ...    }  },  "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": {    "name": "XP_this__is_an_experiment",    "artboards": {      "31A812E8-D960-499F-A10F-C2006DDAEB65": {        "name": "this__is_an_experiment/tabbar-livestream[variant1]"      },      "20F03053-ED77-486B-9770-32E6BA73A0B8": {        "name": "this__is_an_experiment/tabbar-livestream[variant2]"      },      "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": {        "name": "this__is_an_experiment/tabbar-livestream[control]"      }    }  },</code> </pre> <br>  Kemudian kita membaca file JSON yang sesuai dengan setiap halaman di folder <i>halaman</i> (saya ulangi bahwa nama file dalam bentuk <i>[pageUniqueId] .json</i> ) dan mempelajari sumber daya yang tersimpan di halaman ini (mereka terlihat seperti lapisan).  Dengan demikian, kita mendapatkan <b>nama</b> , <b>lebar / tinggi</b> setiap ikon, Sketsa <b>metadata</b> untuk ikon lapisan ini, dan jika kita berurusan dengan halaman <b>percobaan</b> , maka nama <b>uji A / B</b> dan <b>varian</b> ikon ini. <br><br>  <i>Catatan</i> : objek page.json memiliki perangkat yang sangat kompleks, jadi saya tidak akan memikirkannya.  Jika Anda tertarik dengan apa yang ada di dalamnya, saya menyarankan Anda untuk membuat file Sketsa kosong yang baru, menambahkan beberapa konten ke dalamnya dan menyimpannya;  kemudian ganti ekstensi untuk ZIP, unzip dan periksa salah satu file di folder halaman. <br><br>  Dalam proses pemrosesan artboards, kami juga akan membuat <b>daftar eksperimen</b> (dan sumber daya terkait).  Kita akan membutuhkannya untuk menentukan variasi ikon mana yang digunakan dalam percobaan mana - nama variasi ikon dilampirkan pada objek "dasar". <br><br>  Untuk setiap file Sketsa <code>assetsMetadata</code> merek yang sedang diproses, kami membuat objek <code>assetsMetadata</code> yang terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": {  "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977",  ...sketch_artboard_properties,  "name": "navigation-bar-edit",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  "layers": [    {      "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4",      "name": "Path",      ...sketch_layer_properties,      "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5",      "style": {        ...        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.8784313725490196,              "green": 0.8784313725490196,              "red": 0.8784313725490196            },          }        ],        "miterLimit": 10,        "startMarkerType": 0,        "windingRule": 1      },    },  ],  ... }, "experiment-name/navigation-bar-edit[variant]": {  "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7",  ...sketch_artboard_properties,  "name": "experiment-name/navigation-bar-edit[variant]",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  ...</code> </pre> <br>  Seperti yang Anda lihat, dalam percobaan, ikon tunggal (dalam hal ini, <i>bilah-bilah navigasi</i> ) dapat berhubungan dengan banyak sumber.  Pada saat yang sama, ikon yang sama dapat muncul dengan nama yang sama di file Sketsa lain yang terkait dengan merek.  <b>Ini sangat berguna</b> : kami menggunakan trik ini untuk mengkompilasi serangkaian ikon yang umum, dan kemudian mengidentifikasi opsi spesifik sesuai dengan merek.  Itulah sebabnya kami mendeklarasikan file Sketsa yang terkait dengan merek tertentu sebagai array: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Dalam hal ini, ketertiban sangat penting mendasar.  Bahkan, dalam fungsi <code>getSketchMetadata</code> dipanggil oleh skrip, kami tidak mengembalikan objek <code>assetsMetadata</code> satu per satu sebagai file daftar.  Sebaliknya, kami melakukan penggabungan objek yang mendalam - kami menggabungkannya dan mengembalikan objek <code>assetsMetadata</code> tunggal. <br><br>  Secara umum, ini tidak lebih dari penggabungan "logis" file Sketch dan sumber dayanya ke dalam satu file.  Namun, logikanya tidak sesederhana kelihatannya.  Berikut adalah diagram yang kami buat dalam upaya untuk mencari tahu apa yang terjadi ketika ikon dengan nama yang sama (dan mungkin dikenakan pengujian A / B) dalam file yang berbeda dikaitkan dengan merek yang sama: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br><br><h2>  Pembuatan file siap pakai dalam berbagai format untuk platform berbeda </h2><br>  Tahap terakhir dari proses kami adalah secara langsung membuat file ikon dalam berbagai format untuk platform yang berbeda (PDF untuk iOS, SVG / JSX untuk Web dan VectorDrawable untuk Android). <br><br>  Seperti yang dapat Anda lihat dari jumlah parameter yang diteruskan ke fungsi <code>generateAssets[format][platform]</code> hasilAsset, bagian dari pipa ini adalah yang paling kompleks.  Di sinilah proses mulai putus dan berubah tergantung pada platform.  Di bawah ini Anda akan melihat alur logis skrip secara keseluruhan dan bagaimana bagian yang terkait dengan pembuatan sumber daya dibagi menjadi tiga proses yang serupa tetapi berbeda: <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Untuk membuat sumber daya siap pakai dengan warna yang benar sesuai dengan merek yang sedang diproses, kita perlu melakukan beberapa manipulasi lagi dengan file JSON.  Kami melewati semua lapisan yang menerapkan gaya umum, dan mengganti nilai warna dengan warna dari token desain merek. <br><br>  Untuk menghasilkan file untuk Android, Anda perlu melakukan tindakan tambahan (kira-kira nanti): kami mengubah properti <code>fill-rule</code> dari setiap lapisan dari <code>even-odd</code> menjadi <code>non-zero</code> (ini dikendalikan oleh properti <code>windingRule</code> dari objek JSON, di mana 1 berarti "aneh / genap" , dan 0 adalah "tidak sama dengan nol"). <br><br>  Setelah melakukan manipulasi ini, kami mengemas file JSON kembali ke file Sketch standar untuk memproses dan mengekspor sumber daya dengan properti yang diperbarui (file yang diklon dan diperbarui adalah file Sketsa biasa, mereka dapat dibuka, dilihat, diedit, disimpan, dll. ) <br><br>  Setelah itu, kami menggunakan SketchTool (dibungkus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan Node</a> ) untuk secara otomatis mengekspor semua sumber daya dalam format yang sesuai untuk platform.  Untuk setiap file yang terkait dengan merek (atau lebih tepatnya, versi yang diklon dan diperbarui), kami menjalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg --scales=1 --output=${destinationFolder} --overwriting`);</code> </pre> <br>  Seperti yang Anda duga, perintah ini mengekspor sumber daya ke folder tujuan dalam format tertentu, opsional menggunakan penskalaan (kami menjaga skala asli untuk saat ini).  Kuncinya di sini adalah opsi <code>-overwriting</code> : sama seperti kita melakukan penggabungan yang mendalam dari objek <code>assetsMetadata</code> (sesuai dengan file sketsa "logis"), ketika mengekspor kita menggabungkan banyak file ke dalam satu direktori (terkait dengan merek / platform).  Ini berarti bahwa jika sumber daya - diidentifikasi dengan nama lapisan - sudah ada di file Sketch sebelumnya, itu akan ditimpa selama ekspor berikutnya.  Sekali lagi, ini tidak lebih dari operasi penggabungan normal. <br><br>  Namun, dalam contoh ini, beberapa sumber daya bisa berubah menjadi "hantu".  Ini terjadi ketika ikon dalam file mengalami pengujian A / B, tetapi ditimpa dalam file berikutnya.  Kemudian file varian diekspor ke folder tujuan, memiliki tautan yang sesuai dengan sumber daya dalam objek <code>assetsMetadata</code> (dengan kunci dan properti mereka), tetapi tidak terkait dengan sumber daya dasar apa pun (karena penggabungan mendalam dari objek <code>assetsMetadata</code> ).  File seperti itu akan dihapus nanti, sebelum menyelesaikan proses. <br><br><hr><br>  Seperti yang telah disebutkan, platform yang berbeda membutuhkan format output yang berbeda.  File iOS sesuai dengan PDF, dan kami dapat langsung mengekspornya menggunakan perintah SketchTool.  File JSX diperlukan untuk Mobile Web, dan VectorDrawable untuk Android.  Untuk alasan ini, kami mengekspor sumber daya dalam format SVG ke folder sementara dan setelah itu kami memprosesnya. <br><br><h2>  PDF untuk iOS </h2><br>  Anehnya, PDF adalah satu-satunya (?) Format yang didukung Xcode dan OS / iOS untuk mengimpor dan merender sumber daya vektor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah penjelasan singkat</a> tentang pilihan Apple). <br><br>  Karena kita dapat langsung mengekspor ke PDF melalui SketchTool, tidak diperlukan langkah-langkah tambahan: cukup simpan file langsung ke folder tujuan, dan hanya itu. <br><br><h2>  Bereaksi / File Web JSX </h2><br>  Dalam kasus Web, kami menggunakan Node perpustakaan SVGR, yang memungkinkan Anda untuk mengkonversi SVG ke komponen Bereaksi.  Namun, kami ingin melakukan sesuatu secara tiba-tiba: ‚Äúsecara dinamis mewarnai‚Äù ikon saat runtime (warna diambil dari token).  Untuk melakukan ini, sebelum mengonversi, kami mengubah nilai <code>fill</code> untuk vektor yang gaya umum sebelumnya diterapkan ke nilai dari token yang sesuai dengan gaya ini. <br><br>  Jadi jika file <i>badge-feature-like.svg yang</i> diekspor dari Sketch terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) -&lt;a href="http://www.bohemiancoding.com/sketch"&gt; http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt;  &lt;g id="badge-feature-like"&gt;    &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt;    &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt;  &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  maka ikon sumber daya terakhir / <i>badge-feature-like.js</i> akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return (  &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt;    &lt;g fill="none" fillRule="evenodd"&gt;      &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt;      &lt;path fill="#FFF" d="M80.4061668,..." /&gt;    &lt;/g&gt;  &lt;/svg&gt; ); };</code> </pre> <br>  Seperti yang Anda lihat, kami mengganti warna <code>fill</code> statis dengan warna dinamis yang mengambil nilai dari token (mereka dapat dibuat tersedia untuk komponen <code>&lt;Icon/&gt;</code> Bereaksi melalui API Konteks, tetapi ini adalah cerita yang berbeda). <br><br>  Penggantian ini dimungkinkan berkat metadata Sketsa untuk aset <code>assetsMetadata</code> objek: melalui lapisan secara rekursif, Anda dapat membuat pemilih DOM (untuk contoh di atas, <code>#Icons</code> <code>#badge-feature-like #circle</code> ) dan menggunakannya untuk mencari simpul di pohon SVG dan mengganti nilainya. <code>fill</code> atribut (untuk ini kita perlu perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cheerio</a> ). <br><br><h2>  File VectorDrawable untuk Android </h2><br>  Android mendukung grafik vektor menggunakan format vektor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VectorDrawable</a> kustom.  Biasanya mengkonversi dari SVG ke VectorDrawable dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langsung di Android Studio</a> .  Namun, kami ingin mengotomasi proses sepenuhnya, jadi kami mencari cara untuk mengonversi menggunakan kode. <br><br>  Setelah mempelajari berbagai alat dan perpustakaan, kami memutuskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">svg2vectordrawable</a> .  Itu tidak hanya didukung secara aktif (dalam hal apapun, lebih aktif daripada orang lain), tetapi juga lebih fungsional daripada yang lain. <br><br>  Kenyataannya adalah bahwa VectorDrawable dan SVG tidak sama dalam fungsinya: beberapa fungsi SVG (misalnya, gradien radial dan sorotan kompleks) tidak didukung oleh VectorDrawable, sementara yang lain mulai didukung baru-baru ini (dimulai dengan Android API 24).  Salah satu masalah yang muncul dari ini adalah bahwa versi yang lebih lama (hingga 24) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mendukung nilai genap-genap atribut aturan-isi</a> .  Namun, kami di Badoo membutuhkan dukungan untuk Android 5 dan di atasnya.  Itulah sebabnya, pada salah satu tahap sebelumnya, kami <code>fill</code> setiap vektor pada file Sketch menjadi <code>non-zero</code> . <br><br>  Pada prinsipnya, desainer dapat melakukan tindakan ini secara manual: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  Tapi ini mudah dilupakan dan dibuat kesalahan.  Oleh karena itu, kami memutuskan untuk menambahkan langkah tambahan ke proses untuk Android, di mana semua vektor di JSON secara otomatis dikonversi ke <code>non-zero</code> .  Hal ini dilakukan agar ketika mengekspor ikon ke SVG mereka sudah dalam format yang diperlukan, dan setiap objek yang dibuat VectorDrawable didukung oleh perangkat di Android 5. <br><br>  File <i>badge-feature-like.xml jadi</i> terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path  android:fillColor="?color_feature_liked_you"  android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path  android:fillColor="#FFFFFF"  android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Dalam file VectorDrawable, kami menyisipkan nama variabel untuk warna <code>fill</code> , yang dikaitkan dengan token desain melalui gaya umum di aplikasi Android. <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br><br>  Perlu dicatat bahwa Android Studio memiliki persyaratan ketat untuk mengatur sumber daya: tidak ada subfolder dan huruf kapital dalam nama!  Jadi kami harus membuat format baru untuk nama ikon: dalam hal sumber daya yang akan diuji, mereka terlihat seperti ini: <code>ic_icon-name__experiment-name__variant-name</code> . <br><br><h2>  Kamus JSON sebagai Perpustakaan Sumber Daya </h2><br>  Setelah file sumber daya disimpan dalam format final, hanya mengumpulkan semua meta-informasi yang diperoleh selama perakitan dan menyimpannya ke dalam "kamus" untuk digunakan ketika sumber daya diimpor dan digunakan oleh basis kode berbagai platform. <br><br>  Setelah mengekstraksi daftar datar ikon dari objek <code>assetsMetadata</code> kita memeriksanya, memeriksa masing-masing: <br><br><ul><li>  Apakah ini sumber daya reguler (misalnya, <code>tabbar-livestream</code> );  jika demikian, biarkan saja; <br></li><li>  jika ini merupakan opsi untuk pengujian A / B (misalnya, <i>percobaan / tabbar-streaming langsung [varian]</i> ), kami mengaitkan namanya, jalur, nama uji A / B dan varian dengan properti <code>abtests</code> <br>  sumber daya dasar (dalam kasus kami adalah <i>tabbar-livestream</i> ), setelah itu kami menghapus catatan tentang opsi dari daftar / objek (hanya elemen "basis" yang penting); <br></li><li>  jika itu adalah "hantu", maka hapus file dan hapus entri dari daftar / objek. <br></li></ul><br>  Setelah menyelesaikan proses ini, kamus akan berisi daftar semua ikon dasar (dan tes A / B mereka, jika ada), dan hanya mereka.  Informasi tentang masing-masing dari mereka termasuk nama, ukuran, jalur dan, jika ikon tunduk pada pengujian A / B, informasi tentang berbagai pilihannya. <br><br>  Kamus disimpan dalam format JSON di folder tujuan untuk <i>merek</i> dan <i>platform</i> .  Di sini, misalnya, adalah file <i>assets.json yang</i> dihasilkan untuk aplikasi Blendr untuk Mobile Web: <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": {    "badge-feature-like": {    "assetname": "badge-feature-like",    "path": "assets/badge-feature-like.jsx",    "width": 64,    "height": 64,    "source": "icons_common"  },  "navigation-bar-edit": {    "assetname": "navigation-bar-edit",    "path": "assets/navigation-bar-edit.jsx",    "width": 48,    "height": 48,    "source": "icons_common"  },  "tabbar-livestream": {    "assetname": "tabbar-livestream",    "path": "assets/tabbar-livestream.jsx",    "width": 128,    "height": 128,    "source": "icons_blendr",    "abtest": {      "this__is_an_experiment": {        "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx",        "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx",        "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx"      },      "a_second-experiment": {        "control": "assets/a_second-experiment/tabbar-livestream__control.jsx",        "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx"      }    }  },  ... } }</code> </pre> <br>  Sekarang yang tersisa adalah mengemas semua folder <i>aset</i> ke dalam arsip ZIP agar lebih mudah diunduh. <br><br><h2>  Ringkasan </h2><br>  Proses yang dijelaskan dalam artikel, dari mengkloning dan memanipulasi file Sketch hingga mengekspor dan mengkonversi sumber daya ke format yang didukung oleh platform dan menyimpan informasi meta yang dikumpulkan di perpustakaan sumber daya, diulangi dengan setiap merek yang diumumkan dalam skrip build. <br><br>  Berikut ini adalah tangkapan layar yang memperlihatkan tampilan folder <i>src</i> dan <i>dist</i> setelah proses selesai: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br><br>  Pada tahap ini, menggunakan satu perintah sederhana, Anda dapat mengunggah semua sumber daya (JSON, ZIP dan file sumber daya) ke penyimpanan jarak jauh dan membuatnya tersedia untuk semua platform untuk diunduh dan digunakan dalam basis kode. <br><br>  Bagaimana tepatnya platform menerima dan memproses sumber daya (menggunakan skrip khusus yang dibuat khusus untuk tujuan ini) tidak melampaui ruang lingkup artikel ini.  Dan pertanyaan ini mungkin akan dibahas dalam salah satu posting berikut oleh salah satu kolega saya. <br><br><h2>  Kesimpulan (dan pelajaran yang didapat) </h2><br>  Saya selalu menyukai Sketch.  Selama bertahun-tahun, program ini telah menjadi alat default untuk pengembang dan perancang.  Oleh karena itu, saya sangat penasaran untuk mempelajari alat integrasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">html-sketchapp</a> dan alat serupa lainnya yang dapat kami gunakan dalam alur kerja dan saluran pipa kami. <br><br>  Saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti banyak orang lain</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selalu berjuang</a> untuk proses (ideal) seperti itu: <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  Namun, saya harus mengakui bahwa saya mulai ragu bahwa Sketch adalah alat yang cocok, terutama mengingat sistem desain.  Oleh karena itu, saya mulai melihat layanan lain, seperti Figma dengan API terbuka dan Framer X dengan integrasi yang mudah dengan React, karena saya tidak merasakan gerakan Sketch menuju integrasi dengan kode (apa pun itu). <br><br>  Jadi, proyek ini meyakinkan saya.  Tidak sepenuhnya, tetapi dalam banyak hal. <br><br>  Meskipun Sketch tidak membuka API-nya, perangkat struktur internal file-nya berfungsi sebagai semacam API ‚Äútidak resmi‚Äù.  Pembuat dapat menggunakan nama terenkripsi atau menyembunyikan kunci dalam objek JSON, tetapi sebaliknya mereka mematuhi konvensi penamaan yang jelas, mudah dibaca, dan konseptual.  Saya rasa ini bukan kecelakaan. <br><br>  Fakta bahwa file Sketsa dapat dikelola dengan cara ini telah membuka jalan bagi saya untuk banyak pengembangan dan peningkatan di masa depan: mulai dari plugin untuk memeriksa nama, stilisasi dan struktur lapisan untuk ikon hingga integrasi dengan Wiki kami dan dokumentasi sistem desain kami (mutual).  Dengan membuat aplikasi Node di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Electron</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Carlo</a> , kita dapat membuatnya lebih mudah bagi desainer untuk menyelesaikan banyak tugas rutin. <br><br>    (  ,  )   ,  Sketch-   Cosmos  ¬´ ¬ª ‚Äî      - Cosmos.   ,        (   ;    ,    ‚Äî ).    ,      ‚Äî  ,   ,  . <br><br>      ,  Sketch-  , ,    MVP-,       .    ,     ,     . , , -,  ‚Äî    ,             .  ,         . <br><br>  :       <i></i> ,      <i></i> .   ,       <i></i> . <br><br> ,    , ‚Äî   .  ,  ,       ,    (,         A/B-),            Node.js  Sketch. <br><br>   !     . <br><br><h2>  </h2><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (Mobile Web),     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (Android)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (iOS),           . <br><br> , !             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442886/">https://habr.com/ru/post/id442886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442872/index.html">Bagaimana saya menemukan telur paskah di perlindungan Android dan tidak mendapatkan pekerjaan di Google</a></li>
<li><a href="../id442876/index.html">Pemetaan kebisingan dengan KSQL, Raspberry Pi dan radio</a></li>
<li><a href="../id442880/index.html">Poin Pemeriksaan Virtual: daftar periksa pengaturan</a></li>
<li><a href="../id442882/index.html">[Video] "Piems tidak diperlukan" dan tiga ide manajemen proyek lainnya</a></li>
<li><a href="../id442884/index.html">Teknologi sudah memungkinkan Anda untuk berbicara dengan mobil sebagai pribadi</a></li>
<li><a href="../id442888/index.html">Kustomisasi pilih pada css murni</a></li>
<li><a href="../id442890/index.html">CYOD? COPE? BYOD?</a></li>
<li><a href="../id442892/index.html">Pemrograman Berorientasi Debug atau kesedihan di mata Integrator</a></li>
<li><a href="../id442896/index.html">Produksi siklus penuh aditif di perusahaan penerbangan adalah masalah untuk waktu dekat</a></li>
<li><a href="../id442898/index.html">Solusi untuk masalah bot spam yang ditambahkan ke grup telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>