<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🙆🏽 🛄 Verwenden von Fastify und Preact zum schnellen Prototypen von Webanwendungen 🤜🏻 🙇🏿 👨‍👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, möchte eine Geschichte darüber erzählen, mit welchen Technologien er schnell Pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Fastify und Preact zum schnellen Prototypen von Webanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442652/">  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, möchte eine Geschichte darüber erzählen, mit welchen Technologien er schnell Prototypen von Webanwendungen entwickelt.  Diese Technologien umfassen die Bibliotheken Fastify und Preact.  Er benutzt auch die htm Bibliothek.  Es lässt sich leicht in Preact integrieren und dient zur Beschreibung von DOM-Elementen mithilfe intuitiver Konstrukte, die an JSX erinnern.  Gleichzeitig wird kein Transpiler wie Babel benötigt, um damit zu arbeiten.  Nachdem der Autor des Materials die Prototyping-Entwicklungswerkzeuge und -methoden für die Arbeit damit demonstriert hat, wird er zeigen, wie solche Anwendungen in Docker-Container gepackt werden.  Dies macht es einfach, Anwendungen allen Interessierten zu demonstrieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/iq/mq/4a/iqmq4a-j0p_qnlayhqdbmbb2au4.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Starten Sie</font> </h2><br>  Ich bin vor einigen Wochen zur Verwendung der oben genannten Technologien gekommen, als ich eine sehr einfache Prototyp-Webanwendung erstellen musste, um gemeinsam mit meinen Kollegen einige Annahmen zu testen. <br><br>  Mein Experiment war äußerst erfolgreich.  Ich konnte sehr schnell einen Prototyp erstellen, meine Kollegen konnten bequem damit experimentieren, sie konnten schnell ihre Eindrücke darüber ausdrücken.  Gleichzeitig konnten sie das Projekt testen, selbst wenn Node.js und NPM nicht auf ihren Computern installiert waren. <br><br>  All dies führte mich zu der Idee, Material über meinen Ansatz zum Rapid Prototyping von Webanwendungen zu schreiben.  Es ist möglich, dass dieser Ansatz für andere nützlich ist.  Für diejenigen, die bereits mit Fastify und Preact vertraut sind, werde ich sofort das Wichtigste skizzieren, damit sie meine Ideen sofort in die Praxis umsetzen können. <br><br><h2>  <font color="#3AC1EF">Hauptideen</font> </h2><br>  Wenn Sie bereits mit Fastify und Preact vertraut sind und lernen möchten, wie Sie die Entwicklung von Projekten auf der Grundlage dieser Technologien organisieren können, sind Sie buchstäblich ein paar Schritte von dem entfernt, was Sie möchten.  Wir sprechen nämlich über die folgenden Befehle: <br><br><pre><code class="plaintext hljs">git clone https://github.com/lmammino/fastify-preact-htm-boilerplate.git my-new-project cd my-new-project rm -rf .git npm install</code> </pre> <br>  Natürlich können Sie den Namen des Projekts, <code>my-new-project</code> , in den Namen Ihres Projekts ändern. <br><br>  Nachdem Sie alles installiert haben, was Sie benötigen, können Sie mit der Arbeit am Projekt beginnen.  Wir sprechen nämlich über Folgendes: <br><br><ul><li>  Der Ordner <code>src/ui</code> enthält Dateien des Client-Teils der Anwendung (hier werden Preact und htm verwendet). </li><li>  Der Ordner <code>src/server</code> enthält Dateien, die sich auf die Serverseite der Anwendung beziehen (hier wird Fastify verwendet). </li></ul><br>  Durch Bearbeiten der entsprechenden Dateien können Sie das Projekt ausführen: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Danach können Sie es testen, indem Sie im Browser zur Adresse <code>localhost:3000</code> . <br><br>  Und noch etwas.  Wenn Ihnen meine Entwicklung gefallen hat, bin ich für den Star auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> sehr dankbar. <br><br>  Schauen wir uns nun die hier verwendeten Technologien und die Funktionen der Arbeit mit ihnen an. <br><br><h2>  <font color="#3AC1EF">Fastify</font> </h2><br>  Fastify ist ein schnelles und wirtschaftliches Webframework für Node.js.  Dieses Projekt wurde ursprünglich von zwei Programmierern erstellt.  Jetzt hat das Team derer, die daran arbeiten, 10 Leute, mehr als 130 Leute helfen bei der Entwicklung des Projekts, er hat fast 10.000 Sterne auf GitHub gesammelt. <br><br>  Fastify wurde von Node.js Frameworks wie Express und Hapi beeinflusst, die es schon seit geraumer Zeit gibt.  Es war ursprünglich auf Produktivität, den Komfort von Programmierern und die Erweiterung seiner Fähigkeiten mit Hilfe von Plugins ausgerichtet.  Dies ist übrigens eine meiner Lieblingsfunktionen von Fastify. <br><br>  Wenn Sie mit dem Fastify-Framework nicht vertraut sind oder es besser kennenlernen möchten, kann ich seine offizielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> empfehlen. <br><br>  Es sollte beachtet werden, dass ich mit Fastify verwandt bin.  Ich bin Mitglied des Hauptentwicklungsteams und beschäftige mich hauptsächlich mit der Unterstützung des Projektstandorts und der Arbeit an dessen Dokumentation. <br><br><h2>  <font color="#3AC1EF">Vorbereiten</font> </h2><br>  Preact ist eine Bibliothek zur Entwicklung von Benutzeroberflächen für Webprojekte, die von einer Person als kompakter und schneller Ersatz für React erstellt wurde.  Dieses Projekt erwies sich als recht erfolgreich, jetzt ist ein ganzes Entwicklerteam damit beschäftigt, auf GitHub erzielte er mehr als 20.000 Sterne. <br><br>  Einer der Gründe, warum ich Preact mag, ist, dass diese Bibliothek eine erweiterbare Ebene zur Beschreibung der visuellen Komponenten der Anwendung hat.  Unter normalen Umständen kann diese Bibliothek mit JSX in Kombination mit Babel zum Übersetzen des Codes verwendet werden. Wenn Sie Babel jedoch nicht installieren und den Anwendungserstellungsprozess konfigurieren möchten, können Sie Preact beispielsweise zusammen mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">htm-</a> Bibliothek verwenden, die Vorlagenliterale verwendet und keine benötigt Transpilation beim Starten von Projekten, in denen es in modernen Browsern verwendet wird. <br><br>  In diesem Artikel werden wir die htm-Bibliothek verwenden und in Kürze einige Beispiele betrachten. <br><br><h2>  <font color="#3AC1EF">Projektübersicht</font> </h2><br>  Hier betrachten wir den gesamten Prozess der Erstellung eines Projekts.  Unser Ziel wird es sein, eine einfache Webanwendung zu entwickeln, die Informationen zur Uhrzeit auf dem Server zum Zeitpunkt des Starts anzeigt.  Hier, um klarer zu machen, wonach wir streben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/9fe/c12/4d89fec1291d3ab9b66f7673af992d06.png"></div><br>  <i><font color="#999999">Anwendung im Browser</font></i> <br><br>  Dies ist eine Single Page Application (SPA), in der Preact und htm als Client-Teil verwendet werden und Fastify zum Erstellen einer API zum Empfangen von Serverzeit verwendet wird. <br><br>  Ein aufmerksamer Leser könnte bemerken, dass die in der vorherigen Abbildung gezeigte Seite ein hübsches Favicon-Symbol hat.  Es stimmt, er ist dort sehr klein, also werde ich die Aufgabe für diejenigen erleichtern, die sich die Augen brechen und versuchen, etwas auszumachen.  Hier ist eine vergrößerte Version davon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaa/3a8/c3b/aaa3a8c3b25bba5f361af23d9af0f22b.jpg"></div><br>  <i><font color="#999999">Favicon</font></i> <br><br><h2>  <font color="#3AC1EF">Einrichten der Serverseite der Anwendung</font> </h2><br>  Beginnen wir mit der Erstellung eines neuen Ordners: <br><br><pre> <code class="plaintext hljs">mkdir server-time cd server-time</code> </pre> <br>  Initialisieren Sie nun das NPM-Projekt und installieren Sie Fastify: <br><br><pre> <code class="plaintext hljs">npm init -y npm i --save fastify@next fastify-static@next fastify-cli</code> </pre> <br>  Bitte beachten Sie, dass ich bei der Beschreibung einiger Abhängigkeitspakete das Konstrukt <code>@next</code> verwendet habe.  Dies geschieht, damit das Projekt die Fastify 2-Bibliothek verwendet, die sich derzeit in einem Release-Kandidatenstatus befindet, aber sehr bald zur stabilen Hauptversion wird. <br><br>  Bitte beachten Sie, dass Sie mit dem <code>fastify-cli</code> auch ein neues Projekt basierend auf Fastify erstellen können: <br><br><pre> <code class="plaintext hljs">npx fastify-cli generate server-time</code> </pre> <br>  Zum Zeitpunkt des Schreibens dieses Materials erstellt dieses Team ein Projekt, das für die Verwendung von Fastify 1.x konzipiert ist. Sehr bald nach der Veröffentlichung von Fastify 2 wird dieses Tool jedoch aktualisiert. <br><br>  Lassen Sie uns die installierten Pakete analysieren: <br><br><ul><li>  <code>fastify</code> ist eine Kernkomponente des Frameworks. </li><li>  <code>fastify-static</code> ist ein zusätzliches Plugin, mit dem Sie statische Dateien bequem mit dem Fastify-Server bereitstellen können. </li><li>  <code>fastify-cli</code> ist ein Befehlszeilenprogramm, mit dem Sie Projekte basierend auf Fastify erstellen können. </li></ul><br>  Im Moment sind wir bereit, eine API zu erstellen, die auf Fastify basiert.  <code>src/server/server.js</code> wir also den <code>src/server/server.js</code> : <br><br><pre> <code class="plaintext hljs">const path = require('path') module.exports = async function(fastify, opts) { //      `src/ui` fastify.register(require('fastify-static'), {   root: path.join(__dirname, '..', 'ui'), }) //     API fastify.get('/api/time', async (request, reply) =&gt; {   return { time: new Date().toISOString() } }) }</code> </pre> <br>  Ich glaube, dass sich der obige Code gut erklärt, aber es gibt einige interessante Details, über die es sich zu sprechen lohnt.  Dies ist besonders nützlich für diejenigen, die keine Erfahrung mit Fastify haben. <br><br>  Das erste, worauf Sie in diesem Code achten können, ist, dass hier das Schlüsselwort <code>async</code> verwendet wird.  Fastify unterstützt sowohl die Entwicklung eines asynchronen / erwarteten Stils als auch einen traditionelleren Rückrufansatz.  Was genau zu wählen ist, hängt von den Vorlieben eines bestimmten Entwicklers ab. <br><br>  Ein weiteres interessantes Detail ist, dass wir den Server hier als exportiertes Modul definieren.  Dieses Modul (im Fastify-Jargon wird dies als „Plugin“ bezeichnet) ist eine Funktion, die eine Fastify-Instanz ( <code>fastify</code> ) und eine Reihe von Optionen (Optionen) als Argument verwendet.  Innerhalb der Moduldeklaration können wir eine Instanz von <code>fastify</code> , um Plugins zu registrieren.  Genau das passiert mit dem <code>fastify-static</code> Plugin.  Wir können HTTP-Endpunkte auch mit speziellen Methoden wie <code>fastify.get</code> und <code>fastify.post</code> . <br><br>  Der hier verwendete modulare Ansatz hat seine Vorteile, obwohl er etwas ungewöhnlich aussieht.  Zunächst sollte beachtet werden, dass Sie damit mehrere Server kombinieren können.  Stellen Sie sich vor, Sie haben einen Server für ein Blog und einen anderen für ein Forum erstellt.  Sie können einfach in eine vorhandene Anwendung integriert werden, indem sie an Pfade wie <code>/blog</code> und <code>/forum</code> . <br><br>  Darüber hinaus können Sie mit diesem Ansatz Anwendungen und <code>fastify-cli</code> (z. B. Socket-Bindung) abstrahieren und die Lösung für diese Aufgabe entweder an die <code>fastify-cli</code> oder an <code>fastify-cli</code> . <br><br>  Starten Sie den Server mit dem <code>fastify</code> : <br><br><pre> <code class="plaintext hljs">node_modules/.bin/fastify start --log-level info src/server/server.js</code> </pre> <br>  Um unser Leben zu vereinfachen, können wir diesen Befehl zum <code>package.json</code> unserer Datei <code>package.json</code> : <br><br><pre> <code class="plaintext hljs">{ "scripts": {   "start": "fastify start --log-level info src/server/server.js" } }</code> </pre> <br>  Bevor wir den Server tatsächlich starten, müssen wir sicherstellen, dass sich ein Ordner befindet, in dem sich statische Ressourcen befinden.  Andernfalls <code>fastify-static</code> Fehler aus.  Erstellen Sie diesen Ordner: <br><br><pre> <code class="plaintext hljs">mkdir src/ui</code> </pre> <br>  Jetzt können wir die Anwendung mit dem Befehl <code>npm start</code> und mit dem Browser zu <code>localhost:3000/api/time</code> navigieren <code>localhost:3000/api/time</code> . <br><br>  Wenn alles richtig funktioniert, sehen Sie im Browser Folgendes: <br><br><pre> <code class="plaintext hljs">{ "time": "2019-02-17T19:32:03.354Z" }</code> </pre> <br>  An dieser Stelle können Sie eine weitere nette Funktion von Fastify schätzen.  Es liegt in der Tatsache, dass die JSON-Serialisierung für den Fall, dass eine bestimmte Route ein Objekt zurückgibt, automatisch angewendet wird. <br><br>  Jetzt ist die Arbeit an der Server-API abgeschlossen.  Lassen Sie uns ein Frontend haben. <br><br><h2>  <font color="#3AC1EF">Frontend-Setup</font> </h2><br>  Der gesamte Code unseres Projekts in Bezug auf das Frontend befindet sich im Ordner <code>src/ui</code> .  Es wird aus 5 Dateien bestehen: <br><br><ul><li>  <code>app.js</code> - Anwendungscode vorbereiten. </li><li>  <code>bootstrap.min.css</code> - CSS-Code zum Stylen der Anwendung (er wird direkt aus dem Bootstrap-Framework übernommen). </li><li>  <code>favicon.ico</code> - Favicon-Datei.  Wenn Sie eine seriöse Anwendung entwickeln, können Sie nicht auf eine gute Favicon-Datei verzichten. </li><li>  <code>index.html</code> ist die Haupt-HTML-Datei unserer einseitigen Anwendung. </li><li>  <code>preacthtm.js</code> - Code der Preact- und htm-Bibliotheken. </li></ul><br>  Legen Sie zunächst die Dateien in den Ordner ab, bei dem es sich um Stile, Bibliotheken und das Favicon-Symbol handelt: <br><br><pre> <code class="plaintext hljs">curl "https://unpkg.com/htm@2.0.0/preact/standalone.js" &gt; src/ui/preacthtm.js curl "https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" &gt; src/ui/bootstrap.min.css curl "https://github.com/lmammino/fastify-preact-htm-boilerplate/blob/master/src/ui/favicon.ico?raw=true" &gt; src/ui/favicon.ico</code> </pre> <br>  Erstellen Sie nun die Datei <code>src/ui/index.html</code> : <br><br><pre> <code class="plaintext hljs">&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;   &lt;meta charset="utf-8" /&gt;   &lt;meta     name="viewport"     content="width=device-width, initial-scale=1, shrink-to-fit=no"   /&gt;   &lt;!-- Bootstrap CSS --&gt;   &lt;link rel="stylesheet" href="/bootstrap.min.css" /&gt;   &lt;title&gt;My awesome server time&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div id="app"&gt;&lt;/div&gt;   &lt;!-- JavaScript --&gt;   &lt;script src="/preacthtm.js"&gt;&lt;/script&gt;   &lt;script src="/app.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br>  Wir haben eine ganz normale HTML-Seite vor uns, mit der wir alle Ressourcen (CSS und JS) laden und mit der Bezeichner- <code>app</code> ein leeres <code>&lt;div&gt;</code> -Element erstellen, in das wir unsere Anwendung während der Ausführung des Projekts ausgeben. <br><br>  Schauen Sie sich nun den Anwendungscode an, der sich in der <code>src/ui/app.js</code> : <br><br><pre> <code class="plaintext hljs">/*  htmPreact */ const { html, Component, render } = htmPreact class App extends Component { componentDidMount() {   this.setState({ loading: true, time: null })   fetch('/api/time')     .then(response =&gt; response.json())     .then(data =&gt; this.setState({ loading: false, time: data.time })) } render(props, state) {   return html`     &lt;div class="container mt-5"&gt;       &lt;div class="row justify-content-center"&gt;         &lt;div class="col"&gt;           &lt;h1&gt;Hello from your new App&lt;/h1&gt;           &lt;div&gt;             ${state.loading &amp;&amp;               html`                 &lt;p&gt;Loading time from server...&lt;/p&gt;               `} ${state.time &amp;&amp;               html`                 &lt;p&gt;Time from server: &lt;i&gt;&lt;font color="#999999"&gt;${state.time}&lt;/font&gt;&lt;/i&gt; &lt;/p&gt;               `}           &lt;/div&gt;           &lt;hr /&gt;           &lt;div&gt;             Have fun changing the code from this boilerplate:             &lt;ul&gt;               &lt;li&gt;UI code available at &lt;code&gt;/src/ui&lt;/code&gt;&lt;/li&gt;               &lt;li&gt;Server-side code available at &lt;code&gt;/src/server&lt;/code&gt;&lt;/li&gt;             &lt;/ul&gt;           &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   ` } } render( html`   &lt;${App} /&gt; `, document.getElementById('app') )</code> </pre> <br>  In dieser Anwendung gibt es nur eine zustandsbehaftete Komponente namens <code>App</code> .  Der Status dieser Komponente enthält 2 Variablen: <br><br><ul><li>  <code>loading</code> ist eine logische Variable, die angibt, ob zu einem bestimmten Zeitpunkt eine Anforderung an die Server-API ausgeführt wird, um Informationen zur Serverzeit abzurufen. </li><li>  <code>time</code> - Eine Zeichenfolge, die die neuesten vom Server empfangenen Zeitinformationen enthält. </li></ul><br>  Wenn Sie mit React vertraut sind, können Sie den obigen Code leicht verstehen. <br>  Mit Preact und htm können wir Komponenten erstellen, indem wir Klassen deklarieren, die die integrierte <code>Component</code> Klasse erweitern. <br><br>  In dieser Klasse können wir das Verhalten einer Komponente mithilfe von Lebenszyklusmethoden wie <code>componentDidMount()</code> und eine Methode verwenden, die sich wie eine reguläre <code>render()</code> -Methode von React verhält. <br><br>  In unserem Fall legen wir, sobald die Komponente an die Seite angehängt ist ( <code>componentDidMount()</code> -Methode), die <code>loading</code> und führen eine API-Anforderung mit <code>fetch</code> . <br>  Nachdem die Anforderung abgeschlossen ist, setzen wir den Wert der Zeitstatus-Eigenschaft und setzen die <code>loading</code> auf <code>false</code> . <br><br>  Die <code>render()</code> -Methode wird jedes Mal automatisch aufgerufen, wenn sich ein Komponentenstatus ändert oder wenn neue Eigenschaften an ihn übergeben werden.  In dieser Methode beschreiben wir die DOM-Komponente mit htm. <br><br>  Mit der HTML-Bibliothek können Sie DOM-Knoten mithilfe von markierten Vorlagenliteralen mit einem speziellen Tag - <code>html</code> - beschreiben.  In unserem Vorlagenliteral können dynamische Ausdrücke vorhanden sein, z. B. solche, mit denen wir den Status überprüfen und entscheiden, was angezeigt werden soll, wenn die Anwendung Daten vom Server lädt und wenn die Daten bereits vorhanden sind geladen. <br><br>  Es ist auch erwähnenswert, dass wir eine Instanz der Anwendung erstellen und auf einer HTML-Seite anzeigen müssen.  Dies erfolgt mit der Funktion <code>render()</code> des globalen Objekts <code>htmPreact</code> . <br><br>  Jetzt sind die Arbeiten an der Frontend-Anwendung abgeschlossen.  Sie können den Server neu starten, zu <code>localhost:3000</code> und mit dem experimentieren, was wir gerade erstellt haben.  Auf der Grundlage dieser Anwendung können Sie beispielsweise Ihre eigenen entwickeln.  Und wenn das, was Sie erstellen, interessant genug erscheint, um es jemand anderem zu zeigen, ist es wahrscheinlich hilfreich, wenn Sie Ihre Anwendung in einen Docker-Container packen. <br><br><h2>  <font color="#3AC1EF">Anwendungscontainerisierung</font> </h2><br>  Ich glaube, dass der beste Weg, anderen Ihre neuen kleinen Projekte zu zeigen, darin besteht, die Funktionen von Docker für diesen Zweck zu nutzen. <br><br>  Dank Docker kann jeder, der versucht, Ihre Anwendung zu Hause auszuführen, nicht mehr darüber nachdenken, ob er die entsprechende Version von Node.js und NPM installiert hat. Er muss den Quellcode der Anwendung nicht herunterladen, um dies durch Eingabe der richtigen Befehlsfolge zu gewährleisten , installieren Sie die Abhängigkeiten und starten Sie den Server. <br><br>  Um die Anwendung in den Docker-Container zu packen, müssen wir eine sehr einfache <code>Dockerfile</code> im Stammordner unseres Projekts erstellen: <br><br><pre> <code class="plaintext hljs">FROM node:11-alpine WORKDIR /app COPY . /app RUN npm install --production EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br>  Hier beschreiben wir folgende Aktionen: <br><br><ul><li>  Das Image wird basierend auf dem Node.js 11-Image erstellt, das auf Alpine Linux basiert. </li><li>  Alles aus dem aktuellen Ordner wird in den Ordner <code>/app</code> des Containers kopiert. </li><li>  Danach führen wir den Befehl <code>npm install</code> , um die Abhängigkeiten herunterzuladen und zu installieren.  Die Verwendung des <code>--production</code> führt dazu, dass nur die Abhängigkeiten installiert werden, die für die Bereitstellung des Projekts in der Produktion erforderlich sind.  Dies beschleunigt die Bilderstellung, wenn das Projekt viele Entwicklungsabhängigkeiten verwendet. </li><li>  Wir geben an, dass der Container eine offene Pore 3000 haben sollte, auf der der Server standardmäßig arbeitet. </li><li>  Am Ende beschreiben wir einen Befehl, <code>npm start</code> , der ausgeführt wird, wenn der Container <code>npm start</code> wird.  Sie startet die Anwendung. </li></ul><br>  Führen Sie den folgenden Befehl aus, um das Bild für den Container zu erfassen: <br><br><pre> <code class="plaintext hljs">docker build -t server-time .</code> </pre> <br>  Nach einigen Sekunden sollte das Bild fertig sein und Sie sollten in der Lage sein, den Container zu starten: <br><br><pre> <code class="plaintext hljs">docker run -it -p 3000:3000 server-time</code> </pre> <br>  Mit der <code>-p</code> können Sie die Verbindung zwischen dem Container-Port 3000 und dem lokalen Port 3000 konfigurieren. Auf diese Weise können Sie unter <code>localhost:3000</code> auf die containerisierte Anwendung zugreifen. <br>  Jetzt können Sie Ihre Bewerbung mit anderen Personen teilen.  Um es in der Docker-Umgebung auszuführen, reicht es aus, wenn Docker auf dem Computer installiert ist, die beiden oben genannten Befehle in seinem Ordner auszuführen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir darüber gesprochen, wie mit Fastify und Preact eine Umgebung für die schnelle Entwicklung von Webanwendungen erstellt werden kann.  Darüber hinaus haben wir darüber gesprochen, wie Sie die Anwendung für andere Benutzer von Docker freigeben können. <br><br>  Wie oben erwähnt, sind die vorgeschlagenen Tools für das Rapid Prototyping konzipiert. Jetzt fragen Sie sich möglicherweise, was hier für die Entwicklung realer Anwendungen fehlt.  Wenn Sie von „echten Anwendungen“ sprechen, meinen Sie höchstwahrscheinlich die folgenden Funktionen: <br><br><ul><li>  Zusammenstellung von Ressourcen des Front-End-Teils der Anwendung: Erstellung optimierter Dateien (Bundles), möglicherweise mit Webpack, Babel oder anderen Tools. </li><li>  Routing im Frontend der Anwendung. </li><li>  Server-Rendering </li><li>  Mittel zur dauerhaften Datenspeicherung. </li></ul><br>  Alle diese Möglichkeiten zur Entwicklung realer Anwendungen wurden den hier diskutierten Technologien noch nicht hinzugefügt, daher sehe ich sie vorerst als Werkzeug für die Entwicklung von Prototypen.  Ich bin sicher, wenn Ihnen das, was Sie gesehen haben, gefallen hat und Sie dies alles als Grundlage für zukünftige Anwendungen betrachten, die echte Probleme lösen, können Sie leicht das finden, was Sie benötigen, und Anwendungen erstellen, die für Fastify und Preact bereit sind Produktionsfreigabe. <br><br>  <b>Liebe Leser!</b>  Wie können Sie Webanwendungen prototypisieren? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442652/">https://habr.com/ru/post/de442652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442642/index.html">Was Sie im März lesen sollten: 22 neue Bücher für Vermarkter, Manager, Entwickler und Designer</a></li>
<li><a href="../de442644/index.html">Die meisten Nicht-Programmierkenntnisse erhöhen den Entwicklerwert</a></li>
<li><a href="../de442646/index.html">Kubernetes Networks: Ingress</a></li>
<li><a href="../de442648/index.html">Go-Zuweisungsmechanismen</a></li>
<li><a href="../de442650/index.html">Analyse und Optimierung von React-Anwendungen</a></li>
<li><a href="../de442654/index.html">Wechseln Sie zu Next.js und beschleunigen Sie das Laden der Manifold.co-Homepage um das 7,5-fache</a></li>
<li><a href="../de442658/index.html">8 Tricks für die Arbeit mit CSS: Parallaxe, Sticky Footer und andere</a></li>
<li><a href="../de442660/index.html">Mathematik versöhnt Newton mit der Quantenwelt</a></li>
<li><a href="../de442662/index.html">So sehen Sie SDDL und brechen sich nicht die Augen auf Semikolons</a></li>
<li><a href="../de442664/index.html">QIWI Kitchen 6. Februar - wie es war + Referentenpräsentationen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>