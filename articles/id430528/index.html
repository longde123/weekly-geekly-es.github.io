<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜‹ â™ï¸ ğŸï¸ Pemrograman dengan PyUSB 1.0 ğŸ‘¨ğŸ¼â€âš–ï¸ ğŸ›Œ ğŸ‘¨ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari penerjemah : 
 Ini adalah terjemahan dari manual Programming with PyUSB 1.0 
 Panduan ini ditulis oleh pengembang PyUSB, tetapi dengan cepat menj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman dengan PyUSB 1.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430528/">  <i><b>Dari penerjemah</b> :</i> <i><br></i>  <i>Ini adalah terjemahan dari manual <a href="">Programming with PyUSB 1.0</a></i> <i><br></i>  <i>Panduan ini ditulis oleh pengembang PyUSB, tetapi dengan cepat menjalankan komit, saya percaya walac adalah penulis utama.</i> <br><br><h2>  Biarkan saya memperkenalkan diri </h2><br>  <b>PyUSB 1.0</b> adalah pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python</a> yang menyediakan akses mudah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB</a> .  PyUSB menyediakan berbagai fungsi: <br><br><ul><li>  <i><b>100% ditulis dengan Python:</b></i> <br>  Tidak seperti versi 0.x yang ditulis dalam C, versi 1.0 ditulis dengan Python.  Ini memungkinkan programmer Python tanpa pengalaman C untuk lebih memahami cara kerja PyUSB. </li><li> <i><b>Netralitas Platform:</b></i> <br>  Versi 1.0 termasuk skema backend front-end.  Ini mengisolasi API dari detail implementasi khusus sistem.  Antarmuka <u>IBackend</u> menghubungkan dua lapisan ini.  PyUSB hadir dengan backend bawaan untuk libusb 0.1, libusb 1.0, dan OpenUSB.  Anda dapat menulis sendiri backend Anda jika Anda mau. </li><li>  <i><b>Portabilitas:</b></i> <br>  PyUSB harus berjalan pada platform apa pun dengan Python&gt; = 2.4, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ctypes</a> , dan setidaknya salah satu backend bawaan bawaan yang didukung. </li><li>  <i><b>Kesederhanaan:</b></i> <br>  Interaksi dengan perangkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB</a> tidak pernah semudah ini!  USB adalah protokol yang kompleks, dan PyUSB memiliki pengaturan awal yang baik untuk konfigurasi yang paling umum. </li><li>  <i><b>Dukungan gear isochronous:</b></i> <br>  PyUSB mendukung transfer isochronous jika backend yang mendasarinya mendukungnya. </li></ul><br>  Meskipun PyUSB membuat pemrograman USB tidak terlalu menyakitkan, tutorial ini mengasumsikan bahwa Anda memiliki pengetahuan minimal tentang protokol USB.  Jika Anda tidak tahu apa-apa tentang USB, saya sarankan buku <b>Lengkap USB</b> Jan Axelson yang <b>sangat baik</b> . <br><a name="habracut"></a><br><h2>  Cukup bicara, ayo tulis kodenya! </h2><br><h3>  Siapa itu siapa? </h3><br>  Untuk memulai, mari berikan deskripsi modul PyUSB.  Semua modul PyUSB berada di bawah <u>usb</u> , dengan modul-modul berikut: <br><table><tbody><tr><th>  Modul </th><th>  Deskripsi </th></tr><tr><td>  inti </td><td>  Modul USB utama. </td></tr><tr><td>  util </td><td>  Fungsi bantu. </td></tr><tr><td>  kontrol </td><td>  Permintaan manajemen standar. </td></tr><tr><td>  warisan </td><td>  Lapisan kompatibilitas versi 0.x. </td></tr><tr><td>  backend </td><td>  Subpackage yang berisi backend bawaan. </td></tr></tbody></table><br>  Misalnya, untuk mengimpor modul <u>inti</u> , masukkan berikut ini: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core &gt;&gt;&gt; dev = usb.core.find()</code> </pre> <br><h3>  Baiklah, mari kita mulai </h3><br>  Berikut ini adalah program sederhana yang mengirimkan string 'tes' ke sumber data pertama yang ditemukan (endpoint OUT): <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util <span class="hljs-comment"><span class="hljs-comment">#    dev = usb.core.find(idVendor=0xfffe, idProduct=0x0001) #   ? if dev is None: raise ValueError('Device not found') #   .  ,   #    dev.set_configuration() #    cfg = dev.get_active_configuration() intf = cfg[(0,0)] ep = usb.util.find_descriptor( intf, #     custom_match = \ lambda e: \ usb.util.endpoint_direction(e.bEndpointAddress) == \ usb.util.ENDPOINT_OUT) assert ep is not None #   ep.write('test')</span></span></code> </pre><br>  Dua baris pertama mengimpor modul paket PyUSB.  <u>usb.core</u> adalah modul utama, dan <u>usb.util</u> berisi fungsi pembantu.  Perintah berikut mencari perangkat kita dan mengembalikan instance objek jika ditemukan.  Jika tidak, kembalikan <u>Tidak Ada</u> .  Selanjutnya, kita atur konfigurasi yang akan kita gunakan.  Catatan: tidak adanya argumen berarti bahwa konfigurasi yang diinginkan diatur secara default.  Seperti yang akan Anda lihat, banyak fitur PyUSB memiliki pengaturan default untuk perangkat paling umum.  Dalam hal ini, konfigurasi pertama yang ditemukan diatur. <br><br>  Kemudian, kami mencari titik akhir di mana kami tertarik.  Kami mencarinya di dalam antarmuka pertama yang kami miliki.  Setelah kami menemukan titik ini, kami mengirim data ke sana. <br><br>  Jika kita mengetahui alamat titik akhir sebelumnya, kita cukup memanggil fungsi <u>tulis</u> dari objek perangkat: <br><br><pre> <code class="python hljs">dev.write(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'test'</span></span>)</code> </pre><br>  Di sini kita menulis string 'test' di breakpoint di alamat <i>1</i> .  Semua fungsi ini akan dibahas lebih baik di bagian berikut. <br><br><h3>  Apa yang salah </h3><br>  Setiap fungsi di PyUSB melempar pengecualian jika terjadi kesalahan.  Selain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengecualian Python standar</a> , PyUSB mendefinisikan <u>usb.core.USBError</u> untuk kesalahan terkait USB. <br><br>  Anda juga dapat menggunakan fungsi log PyUSB.  Ini menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logging</a> .  Untuk menggunakannya, tentukan <u>variabel</u> lingkungan <u>PYUSB_DEBUG</u> dengan salah satu level logging berikut: <u>kritis</u> , <u>kesalahan</u> , <u>peringatan</u> , <u>info</u> atau <u>debug</u> . <br><br>  Secara default, pesan dikirim ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sys.stderr</a> .  Jika mau, Anda dapat mengalihkan pesan log ke file dengan mendefinisikan variabel lingkungan <u>PYUSB_LOG_FILENAME</u> .  Jika nilainya adalah jalur yang benar ke file, pesan akan ditulis di sana, jika tidak maka akan dikirim ke <u>sys.stderr</u> . <br><br><h3>  Dimana kamu </h3><br>  Fungsi <u>find ()</u> dalam modul <u>inti</u> digunakan untuk menemukan dan memberi nomor perangkat yang terpasang pada sistem.  Misalnya, katakanlah perangkat kita memiliki ID vendor dengan nilai 0xfffe dan ID produk 0x0001.  Jika kami perlu menemukan perangkat ini, kami akan melakukan ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core dev = usb.core.find(idVendor=<span class="hljs-number"><span class="hljs-number">0xfffe</span></span>, idProduct=<span class="hljs-number"><span class="hljs-number">0x0001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dev <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">'Our device is not connected'</span></span>)</code> </pre><br>  Itu saja, fungsinya akan mengembalikan objek <u>usb.core.Device</u> yang mewakili perangkat kita.  Jika perangkat tidak ditemukan, itu akan mengembalikan <u>Tidak Ada</u> .  Bahkan, Anda bisa menggunakan bidang apa saja dari kelas Device <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Descriptor</a> yang Anda inginkan.  Misalnya, bagaimana jika kita ingin mencari tahu apakah ada printer USB yang terhubung ke sistem?  Sangat mudah: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   if usb.core.find(bDeviceClass=7) is None: raise ValueError('No printer found')</span></span></code> </pre><br>  7 adalah kode untuk kelas printer sesuai dengan spesifikasi USB.  Oh, tunggu, bagaimana jika saya ingin memberi nomor semua printer yang tersedia?  Tidak masalah: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     ... printers = usb.core.find(find_all=True, bDeviceClass=7) # Python 2, Python 3,     import sys sys.stdout.write('There are ' + len(printers) + ' in the system\n.')</span></span></code> </pre><br>  Apa yang terjadi  Nah, waktu untuk sedikit penjelasan ... <u>find</u> memiliki parameter bernama <u>find_all</u> dan default ke False.  Ketika itu salah <a name="orig1"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> , <u>find</u> akan mengembalikan perangkat pertama yang cocok dengan kriteria yang ditentukan (kami akan segera membicarakannya).  Jika Anda memberikan nilai <i>sebenarnya</i> ke parameter, <u>find</u> malah <u>akan</u> mengembalikan daftar semua perangkat yang cocok dengan kriteria.  Itu saja!  Sederhana bukan? <br><br>  Apakah kita sudah selesai?  Tidak!  Saya belum memberi tahu semuanya: banyak perangkat yang benar-benar memasukkan informasi kelas mereka di Antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskriptor</a> daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Descriptor</a> Perangkat.  Jadi untuk benar-benar menemukan semua printer yang terhubung ke sistem, kita harus melalui semua konfigurasi, serta semua antarmuka, dan memeriksa apakah salah satu antarmuka diatur ke bInterfaceClass 7. Jika Anda seorang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">programmer</a> seperti saya, Anda mungkin bertanya-tanya: apakah ada cara yang lebih mudah untuk menerapkannya?  Jawab: ya, benar.  Untuk memulai, mari kita lihat kode yang sudah jadi untuk menemukan semua printer yang terhubung: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find_class</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, class_)</span></span></span><span class="hljs-function">:</span></span> self._class = class_ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, device)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,   if device.bDeviceClass == self._class: return True # ,   ,   # ,     for cfg in device: # find_descriptor:  ? intf = usb.util.find_descriptor( cfg, bInterfaceClass=self._class ) if intf is not None: return True return False printers = usb.core.find(find_all=1, custom_match=find_class(7))</span></span></code> </pre><br>  Parameter <u>custom_match</u> menerima objek yang dipanggil yang menerima objek perangkat.  Ini harus mengembalikan true untuk perangkat yang sesuai dan false untuk yang tidak pantas.  Anda juga dapat menggabungkan <u>custom_match</u> dengan bidang perangkat jika Anda ingin: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,    : printers = usb.core.find(find_all=1, custom_match=find_class(7), idVendor=0xfffe)</span></span></code> </pre><br>  Di sini kami tertarik pada printer dari pemasok 0xfffe. <br><br><h3>  Jelaskan diri Anda </h3><br>  Oke, kami menemukan perangkat kami, tetapi sebelum berinteraksi dengannya, kami ingin tahu lebih banyak tentangnya.  Anda tahu, konfigurasi, antarmuka, titik akhir, jenis aliran data ... <br>  Jika Anda memiliki perangkat, Anda dapat mengakses bidang keterangan perangkat sebagai properti objek: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.bLength &gt;&gt;&gt; dev.bNumConfigurations &gt;&gt;&gt; dev.bDeviceClass &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br>  Untuk mengakses konfigurasi yang tersedia di perangkat, Anda dapat mengulangi perangkat: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cfg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dev: sys.stdout.write(str(cfg.bConfigurationValue) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br>  Dengan cara yang sama, Anda dapat mengulangi konfigurasi untuk mengakses antarmuka, serta mengulangi antarmuka untuk mengakses titik kontrol mereka.  Setiap jenis objek memiliki bidang deskriptor yang sesuai sebagai atribut.  Lihatlah sebuah contoh: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cfg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dev: sys.stdout.write(str(cfg.bConfigurationValue) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> intf <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cfg: sys.stdout.write(<span class="hljs-string"><span class="hljs-string">'\t'</span></span> + \ str(intf.bInterfaceNumber) + \ <span class="hljs-string"><span class="hljs-string">','</span></span> + \ str(intf.bAlternateSetting) + \ <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> intf: sys.stdout.write(<span class="hljs-string"><span class="hljs-string">'\t\t'</span></span> + \ str(ep.bEndpointAddress) + \ <span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br>  Anda juga dapat menggunakan indeks untuk akses acak ke deskriptor, seperti di sini: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment">#      &gt;&gt;&gt; cfg = dev[1] &gt;&gt;&gt; #      &gt;&gt;&gt; intf = cfg[(0,0)] &gt;&gt;&gt; #    &gt;&gt;&gt; ep = intf[2]</span></span></code> </pre><br>  Seperti yang Anda lihat indeks dihitung dari 0. Tapi tunggu!  Ada sesuatu yang aneh dalam cara saya mendapatkan akses ke antarmuka ... Ya, Anda benar, indeks untuk Konfigurasi mengambil serangkaian dua nilai, di mana yang pertama adalah indeks Antarmuka, dan yang kedua adalah pengaturan alternatif.  Secara umum, untuk mengakses antarmuka pertama, tetapi dengan pengaturan kedua, kita akan menulis <u>cfg [(0,1)]</u> . <br><br>  Sekarang adalah waktu untuk mempelajari cara yang ampuh untuk mencari deskriptor - fungsi <u>find_descriptor yang</u> bermanfaat.  Kami telah melihatnya dalam contoh pencarian printer.  <u>find_descriptor</u> bekerja hampir sama dengan <u>find</u> , dengan dua pengecualian: <br><br><ul><li>  <u>find_descriptor</u> menerima sebagai parameter pertama deskriptor sumber yang akan Anda cari. </li><li>  Tidak ada parameter <u>backend</u> di dalamnya <a name="orig2"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> . </li></ul><br>  Misalnya, jika kami memiliki deskriptor konfigurasi <u>cfg</u> , dan kami ingin menemukan semua pengaturan alternatif untuk antarmuka 1, kami akan melakukan ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util alt = usb.util.find_descriptor(cfg, find_all=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, bInterfaceNumber=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Perhatikan bahwa <u>find_descriptor</u> ada di modul <u>usb.util</u> .  Ini juga menerima parameter <u>custom_match yang</u> dijelaskan sebelumnya. <br><br>  <b>Kami menangani beberapa perangkat yang identik</b> <br><br>  Terkadang Anda dapat memiliki dua perangkat identik yang terhubung ke komputer.  Bagaimana Anda bisa membedakan mereka?  Objek <u>perangkat</u> datang dengan dua atribut tambahan yang bukan bagian dari spesifikasi USB, tetapi sangat berguna: atribut <u>bus</u> dan <u>alamat</u> .  Pertama-tama, perlu dikatakan bahwa atribut-atribut ini berasal dari backend, dan backend mungkin tidak mendukung mereka - dalam hal ini mereka diatur ke <u>None</u> .  Namun, atribut ini mewakili jumlah dan alamat bus perangkat dan, seperti yang Anda duga, dapat digunakan untuk membedakan antara dua perangkat dengan nilai atribut <u>idVendor</u> dan <u>idProduct yang</u> sama. <br><br><h3>  Bagaimana saya harus bekerja? </h3><br>  Setelah tersambung, perangkat USB harus dikonfigurasikan menggunakan beberapa kueri standar.  Ketika saya mulai mempelajari spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">USB</a> , saya berkecil hati oleh deskriptor, konfigurasi, antarmuka, pengaturan alternatif, jenis transfer dan semua itu ... Dan yang terburuk, Anda tidak bisa mengabaikannya: perangkat tidak bekerja tanpa mengatur konfigurasi, walaupun itu salah satu!  PyUSB berusaha membuat hidup Anda sesederhana mungkin.  Misalnya, setelah menerima objek perangkat Anda, pertama-tama, sebelum berinteraksi dengannya, Anda perlu mengirim permintaan <u>konfigurasi set_configuration</u> .  Parameter konfigurasi untuk kueri ini yang menarik minat Anda adalah <u>bConfigurationValue</u> .  Sebagian besar perangkat tidak memiliki lebih dari satu konfigurasi, dan melacak nilai konfigurasi yang digunakan adalah menjengkelkan (walaupun sebagian besar kode yang saya lihat hanya hardcoded ini).  Oleh karena itu, di PyUSB, Anda cukup mengirim permintaan <u>set_configuration</u> tanpa argumen.  Dalam hal ini, ia akan menginstal konfigurasi pertama yang ditemukan (jika perangkat Anda hanya memiliki satu, Anda tidak perlu khawatir tentang nilai konfigurasi sama sekali).  Misalnya, Anda memiliki perangkat dengan satu deskriptor konfigurasi, dan bidang bConfigurationValue-nya adalah 5 <a name="orig3"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[3]</a> , kueri selanjutnya akan bekerja sama: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.set_configuration(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  &gt;&gt;&gt; dev.set_configuration() #  ,   5 -  #  &gt;&gt;&gt; cfg = util.find_descriptor(dev, bConfigurationValue=5) &gt;&gt;&gt; cfg.set() #  &gt;&gt;&gt; cfg = util.find_descriptor(dev, bConfigurationValue=5) &gt;&gt;&gt; dev.set_configuration(cfg)</span></span></code> </pre><br>  Wow!  Anda dapat menggunakan objek <u>Konfigurasi</u> sebagai parameter untuk <u>set_configuration</u> !  Ya, ia juga memiliki metode yang <u>ditetapkan</u> untuk mengkonfigurasi dirinya dalam konfigurasi saat ini. <br><br>  Opsi lain yang perlu atau tidak perlu Anda konfigurasi adalah opsi untuk mengubah antarmuka.  Setiap perangkat hanya dapat memiliki satu konfigurasi yang diaktifkan pada satu waktu, dan setiap konfigurasi dapat memiliki lebih dari satu antarmuka, dan Anda dapat menggunakan semua antarmuka secara bersamaan.  Anda lebih memahami konsep ini jika Anda menganggap antarmuka sebagai perangkat logis.  Sebagai contoh, mari kita bayangkan sebuah printer multifungsi, yang sekaligus adalah printer dan pemindai.  Agar tidak menyulitkan (atau setidaknya membuatnya sesederhana mungkin), mari kita asumsikan bahwa dia hanya memiliki satu konfigurasi.  Karena  kami memiliki printer dan pemindai, konfigurasi memiliki 2 antarmuka: satu untuk printer dan satu untuk pemindai.  Perangkat dengan lebih dari satu antarmuka disebut perangkat komposit.  Ketika Anda menghubungkan printer multifungsi Anda ke komputer Anda, Sistem Operasi akan memuat dua driver yang berbeda: satu untuk setiap perangkat periferal "logis" yang Anda miliki <a name="orig4"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[4]</a> . <br><br>  Bagaimana dengan pengaturan antarmuka alternatif?  Untung kamu bertanya.  Antarmuka memiliki satu atau beberapa pengaturan alternatif.  Antarmuka dengan hanya satu pengaturan alternatif dianggap tidak memiliki pengaturan alternatif <a name="orig5"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[5]</a> .  Pengaturan alternatif untuk antarmuka sebagai konfigurasi untuk perangkat, yaitu, untuk setiap antarmuka Anda hanya dapat memiliki satu pengaturan alternatif aktif.  Misalnya, spesifikasi USB menyarankan bahwa perangkat tidak dapat memiliki pos pemeriksaan isochronous dalam konfigurasi alternatif utamanya <a name="orig6"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[6]</a> , sehingga perangkat streaming harus memiliki setidaknya dua pengaturan alternatif, dengan pengaturan kedua memiliki pos pemeriksaan isochronous.  Tetapi, tidak seperti konfigurasi, antarmuka dengan hanya satu konfigurasi alternatif tidak perlu dikonfigurasi <a name="orig7"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[7]</a> .  Anda memilih pengaturan antarmuka alternatif menggunakan fungsi <u>set_interface_altsetting</u> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.set_interface_altsetting(interface = <span class="hljs-number"><span class="hljs-number">0</span></span>, alternate_setting = <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  <b>Peringatan</b> <br><br>  Spesifikasi USB mengatakan bahwa perangkat diizinkan untuk mengembalikan kesalahan jika menerima permintaan SET_INTERFACE untuk antarmuka yang tidak memiliki pengaturan alternatif tambahan.  Jadi jika Anda tidak yakin bahwa antarmuka memiliki lebih dari satu pengaturan alternatif atau bahwa ia menerima permintaan SET_INTERFACE, metode paling aman adalah memanggil <u>set_interface_altsetting</u> di dalam blok coba-kecuali, seperti di sini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: dev.set_interface_altsetting(...) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> USBError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Anda juga dapat menggunakan objek <u>Antarmuka</u> sebagai parameter fungsi, <u>antarmuka</u> dan parameter pengaturan_pilihan secara otomatis diwarisi dari bidang <u>bInterfaceNumber</u> dan <u>bAlternateSetting</u> .  Contoh: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>intf = find_descriptor(...) &gt;&gt;&gt; dev.set_interface_altsetting(intf) &gt;&gt;&gt; intf.set_altsetting() <span class="hljs-comment"><span class="hljs-comment"># !       </span></span></code> </pre><br>  <b>Peringatan</b> <br><br>  Objek <u>antarmuka</u> harus milik deskriptor konfigurasi aktif. <br><br><h3>  Bicaralah padaku sayang </h3><br>  Dan sekarang saatnya bagi kita untuk memahami cara berinteraksi dengan perangkat USB.  USB memiliki empat jenis aliran data: transfer massal, transfer interupsi, transfer isochronous, dan transfer kontrol.  Saya tidak berencana untuk menjelaskan tujuan dari setiap utas dan perbedaan di antara mereka.  Oleh karena itu, saya berasumsi bahwa Anda memiliki setidaknya pengetahuan dasar aliran data USB. <br><br>  Aliran data kontrol adalah satu-satunya aliran yang strukturnya dijelaskan dalam spesifikasi, sisanya hanya mengirim dan menerima data mentah dari sudut pandang USB.  Oleh karena itu, Anda memiliki berbagai fungsi untuk bekerja dengan aliran kontrol, dan sisa aliran diproses oleh fungsi yang sama. <br><br>  Anda dapat mengakses aliran data kontrol menggunakan metode <u>ctrl_transfer</u> .  Ini digunakan baik untuk aliran keluar (keluar) dan masuk (IN).  Arah aliran ditentukan oleh parameter <u>bmRequestType</u> . <br><br>  Parameter <u>ctrl_transfer</u> hampir bersamaan dengan struktur permintaan kontrol.  Berikut ini adalah contoh cara mengatur aliran data kontrol. <a name="orig8"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[8]</a> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>msg = <span class="hljs-string"><span class="hljs-string">'test'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> dev.ctrl_transfer(<span class="hljs-number"><span class="hljs-number">0x40</span></span>, CTRL_LOOPBACK_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, msg) == len(msg) &gt;&gt;&gt; ret = dev.ctrl_transfer(<span class="hljs-number"><span class="hljs-number">0xC0</span></span>, CTRL_LOOPBACK_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(msg)) &gt;&gt;&gt; sret = <span class="hljs-string"><span class="hljs-string">''</span></span>.join([chr(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ret]) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sret == msg</code> </pre><br>  Contoh ini mengasumsikan bahwa perangkat kami mencakup dua permintaan kontrol pengguna yang bertindak seperti pipa loopback.  Apa yang Anda tulis dengan pesan <u>CTRL_LOOPBACK_WRITE</u> , Anda dapat membaca dengan pesan <u>CTRL_LOOPBACK_READ</u> . <br><br>  Empat parameter pertama - <u>bmRequestType</u> , <u>bmRequest</u> , <u>wValue</u> dan <u>wIndex</u> - adalah bidang struktur standar aliran kontrol.  Parameter kelima adalah data yang ditransfer untuk aliran data keluar atau jumlah data yang sedang dibaca dalam aliran masuk.  Data yang dikirim dapat berupa jenis urutan apa pun, yang dapat dimasukkan sebagai parameter ke input metode <u>__init__</u> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> .  Jika tidak ada data yang ditransfer, parameter harus diatur ke <u>Tidak ada</u> (atau 0 jika aliran data masuk).  Ada parameter opsional lain yang menunjukkan batas waktu operasi.  Jika Anda tidak lulus, batas waktu default akan digunakan (lebih lanjut tentang ini nanti).  Dalam aliran data keluar, nilai kembali adalah jumlah byte yang sebenarnya dikirim ke perangkat.  Dalam aliran masuk, nilai kembali adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> dengan data dibaca. <br><br>  Untuk aliran lain, Anda dapat menggunakan metode <u>menulis</u> dan <u>membaca</u> , masing-masing, untuk menulis dan membaca data.  Anda tidak perlu khawatir tentang jenis aliran - ini secara otomatis terdeteksi oleh alamat pos pemeriksaan.  Berikut adalah contoh loopback kami, asalkan kami memiliki pipa loopback di breakpoint 1: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>msg = <span class="hljs-string"><span class="hljs-string">'test'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(dev.write(<span class="hljs-number"><span class="hljs-number">1</span></span>, msg, <span class="hljs-number"><span class="hljs-number">100</span></span>)) == len(msg) &gt;&gt;&gt; ret = dev.read(<span class="hljs-number"><span class="hljs-number">0x81</span></span>, len(msg), <span class="hljs-number"><span class="hljs-number">100</span></span>) &gt;&gt;&gt; sret = <span class="hljs-string"><span class="hljs-string">''</span></span>.join([chr(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ret]) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sret == msg</code> </pre><br>  Parameter pertama dan ketiga sama untuk kedua metode - masing-masing adalah alamat pos pemeriksaan dan batas waktu.  Parameter kedua adalah data yang dikirimkan (tulis) atau jumlah byte untuk dibaca (baca).  Data yang dikembalikan akan berupa instance dari objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> untuk metode <u>baca</u> , atau jumlah byte yang ditulis untuk metode <u>tulis</u> . <br><br>  Dengan versi beta 2, alih-alih jumlah byte, Anda dapat meneruskan <u>membaca</u> atau <u>ctrl_transfer</u> objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> yang datanya akan dibaca.  Dalam hal ini, jumlah byte yang akan dibaca akan menjadi panjang array dikalikan nilai <u>array.itemsize</u> . <br><br>  Dalam <u>ctrl_transfer</u> , parameter <u>batas waktu</u> adalah opsional.  Ketika <u>batas waktu</u> dihilangkan, properti <u>Device.default_timeout digunakan</u> sebagai batas waktu operasional. <br><br><h3>  Kendalikan diri Anda </h3><br>  Selain fungsi <u>aliran</u> data, modul <u>usb.control</u> menyediakan fungsi yang mencakup permintaan kontrol USB standar, dan modul <u>usb.util</u> memiliki fungsi <u>get_string yang</u> nyaman <u>yang</u> secara khusus menampilkan deskriptor garis. <br><br><h2>  Topik tambahan </h2><br><h3>  Di belakang setiap abstraksi besar adalah realisasi yang hebat </h3><br>  Sebelumnya, hanya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libusb</a> .  Kemudian datang libusb 1.0 dan kami memiliki libusb 0.1 dan 1.0.  Setelah itu, kami menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenUSB</a> dan sekarang kami tinggal di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menara Babel dari</a> Perpustakaan USB <a name="orig9"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[9]</a> .  Bagaimana PyUSB menangani ini?  Nah, PyUSB adalah perpustakaan yang demokratis, Anda dapat memilih perpustakaan mana yang Anda inginkan.  Bahkan, Anda dapat menulis perpustakaan USB Anda sendiri dari awal dan memberi tahu PyUSB untuk menggunakannya. <br><br>  Fungsi <u>find</u> memiliki parameter lain, yang tidak saya ceritakan.  Ini adalah parameter <u>backend</u> .  Jika Anda tidak mentransfernya, salah satu backend bawaan akan digunakan.  Backend adalah objek yang diwarisi dari <u>usb.backend.IBackend</u> , yang bertanggung jawab untuk memperkenalkan sampah USB khusus sistem operasi.  Seperti yang mungkin sudah Anda duga, libusb 0.1, libusb 1.0, dan OpenUSB bawaan adalah backend. <br><br>  Anda dapat menulis backend Anda sendiri dan menggunakannya.  Hanya mewarisi dari <u>IBackend</u> dan aktifkan metode yang diperlukan.  Anda mungkin perlu melihat dokumentasi <u>usb.backend</u> untuk memahami bagaimana ini dilakukan. <br><br><h3>  Jangan egois </h3><br>  Python memiliki apa yang kita sebut <i>manajemen memori otomatis</i> .  Ini berarti bahwa mesin virtual akan memutuskan kapan untuk membongkar objek dari memori.  Di bawah tenda, PyUSB mengelola semua sumber daya tingkat rendah yang perlu Anda kerjakan (menyetujui antarmuka, menyesuaikan perangkat, dll.) Dan sebagian besar pengguna tidak perlu khawatir tentang hal ini.  Tetapi, karena sifat alami dari penghancuran objek secara otomatis oleh Python, pengguna tidak dapat memprediksi kapan sumber daya yang dialokasikan akan dirilis.  Beberapa aplikasi perlu mengalokasikan dan membebaskan sumber daya secara deterministik.  Untuk aplikasi seperti itu, modul <u>usb.util</u> menyediakan fungsi untuk berinteraksi dengan manajemen sumber daya. <br><br>  Jika Anda ingin meminta dan melepaskan antarmuka secara manual, Anda dapat menggunakan fungsi <u>claim_interface</u> dan <u>release_interface</u> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">claim_interface</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan meminta antarmuka yang ditentukan jika perangkat belum melakukannya. Jika perangkat sudah meminta antarmuka, itu tidak melakukan apa-apa. </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Release_interface</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juga </font><font style="vertical-align: inherit;">akan merilis antarmuka yang ditentukan, jika diminta. Jika antarmuka tidak diminta, itu tidak melakukan apa-apa. Anda dapat menggunakan kueri antarmuka manual untuk menyelesaikan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">masalah pemilihan konfigurasi yang</font></a><font style="vertical-align: inherit;"> dijelaskan dalam dokumentasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libusb</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda ingin membebaskan semua sumber daya yang dialokasikan oleh objek perangkat (termasuk antarmuka yang diminta), Anda dapat menggunakan fungsi </font><u><font style="vertical-align: inherit;">dispose_resources</font></u></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini membebaskan semua sumber daya yang dialokasikan dan menempatkan objek perangkat (tetapi tidak dalam perangkat keras perangkat itu sendiri) ke keadaan di mana ia dikembalikan setelah menggunakan fungsi </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definisi perpustakaan manual </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, backend adalah pembungkus di atas pustaka bersama yang mengimplementasikan API untuk mengakses USB. Secara default, backend menggunakan </font><font style="vertical-align: inherit;">fungsi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctypes </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_library ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di Linux dan Sistem Operasi mirip Unix lainnya, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_library</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mencoba menjalankan program eksternal (seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ sbin / ldconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objdump</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) untuk menemukan file perpustakaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada sistem di mana program ini hilang dan / atau cache perpustakaan dinonaktifkan, fungsi ini tidak dapat digunakan. Untuk mengatasi keterbatasan, PyUSB memungkinkan Anda untuk mengirimkan fungsi kustom find_library () ke backend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh skenario seperti itu adalah:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.backend.libusb1 &gt;&gt;&gt; &gt;&gt;&gt; backend = usb.backend.libusb1.get_backend(find_library=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">"/usr/lib/libusb-1.0.so"</span></span>) &gt;&gt;&gt; dev = usb.core.find(..., backend=backend)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhatikan bahwa find_library adalah argumen ke fungsi get_backend () di mana Anda menyediakan fungsi yang bertanggung jawab untuk menemukan perpustakaan yang tepat untuk backend. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aturan sekolah lama </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menulis aplikasi menggunakan API PyUSB lama (0. sesuatu-di sana), Anda mungkin bertanya pada diri sendiri apakah Anda perlu memperbarui kode Anda untuk menggunakan API baru. </font><font style="vertical-align: inherit;">Ya, Anda harus melakukannya, tetapi itu tidak perlu. </font><font style="vertical-align: inherit;">PyUSB 1.0 hadir dengan </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kompatibilitas </font><u><font style="vertical-align: inherit;">usb.legacy</font></u><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini termasuk API lama berdasarkan API baru. </font><font style="vertical-align: inherit;">"Yah, haruskah saya mengganti jalur </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb impor</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">dengan </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impor usb.legacy sebagai usb</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agar aplikasi saya berfungsi?", Anda bertanya. </font><font style="vertical-align: inherit;">Jawabannya adalah ya, itu akan berhasil, tetapi itu tidak perlu. </font><font style="vertical-align: inherit;">Jika Anda menjalankan aplikasi Anda tidak berubah, itu akan berfungsi karena jalur </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impor usb</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengimpor semua simbol publik dari </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb.legacy</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika Anda menemukan masalah - kemungkinan besar Anda telah menemukan bug.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tolong bantu saya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda butuh bantuan, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jangan kirimi saya email</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ada milis untuk ini. </font><font style="vertical-align: inherit;">Instruksi berlangganan dapat ditemukan di situs web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyUSB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="prim"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika saya menulis Benar atau Salah (dengan huruf kapital), maksud saya nilai yang sesuai dari bahasa Python. Dan ketika saya mengatakan true (true) atau false (false), maksud saya setiap ekspresi Python yang dianggap benar atau salah. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Kesamaan ini terjadi dalam aslinya dan membantu untuk memahami konsep benar dan salah dalam terjemahan. - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lihat dokumentasi backend khusus. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spesifikasi USB tidak memaksakan nilai spesifik pada nilai konfigurasi. Hal yang sama berlaku untuk nomor antarmuka dan pengaturan alternatif. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebenarnya, semuanya sedikit lebih rumit, tapi ini hanya penjelasan untuk kita. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya tahu ini terdengar aneh.</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini karena jika tidak ada bandwidth untuk aliran data isochronous selama konfigurasi perangkat, itu dapat berhasil dinomori. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini tidak terjadi untuk konfigurasi karena perangkat dibiarkan dalam keadaan tidak terkonfigurasi. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di PyUSB, data kontrol mengalirkan titik kontrol akses 0. Sangat sangat sangat jarang, perangkat memiliki titik kontrol kontrol alternatif (saya belum pernah bertemu dengan perangkat seperti itu). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini hanya lelucon, jangan menganggapnya serius. </font><font style="vertical-align: inherit;">Pilihan bagus lebih baik daripada tidak ada pilihan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430528/">https://habr.com/ru/post/id430528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430518/index.html">Cara merender bingkai Middle Earth: Shadow of Mordor</a></li>
<li><a href="../id430520/index.html">Memperkenalkan MongoDB Data Musim Semi</a></li>
<li><a href="../id430522/index.html">Apakah Anda memerlukan budaya perusahaan di bidang TI? Pengakuan manajer merek studio Krasnodar Plarium</a></li>
<li><a href="../id430524/index.html">Arsitektur Jaringan Saraf Tiruan</a></li>
<li><a href="../id430526/index.html">Mesin slot: dari mana asalnya di USSR dan bagaimana pengaturannya</a></li>
<li><a href="../id430530/index.html">Server tiruan untuk otomatisasi pengujian seluler</a></li>
<li><a href="../id430532/index.html">Keamanan di aplikasi iOS</a></li>
<li><a href="../id430534/index.html">Membuat templat untuk Zabbix menggunakan DVR Trassir SDK sebagai contoh</a></li>
<li><a href="../id430536/index.html">Merancang fungsi jendela diringkas menjadi satu unit dengan tingkat tumpang tindih yang diberikan</a></li>
<li><a href="../id430538/index.html">Apakah Anda membaca Scaladoc untuk metode pengumpulan yang "jelas"? Atau mengapa kemalasan tidak selalu baik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>