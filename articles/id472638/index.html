<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏼 👌🏼 📒 Bangun walker besi cor di Spring Boot dan AppCDS 👨‍👨‍👧 😮 🌐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi Berbagi Data Kelas (AppCDS) - Fitur JVM untuk mempercepat startup dan menghemat memori. Setelah muncul dalam masa pertumbuhan di HotSpot kemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bangun walker besi cor di Spring Boot dan AppCDS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472638/"><p><img src="https://habrastorage.org/webt/se/py/8z/sepy8zdhkojsr-xiqs-lwdtyegy.jpeg"></p><br><p>  <strong>Aplikasi Berbagi Data Kelas (AppCDS)</strong> - Fitur JVM untuk mempercepat startup dan menghemat memori.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Setelah muncul</a> dalam masa pertumbuhan di HotSpot kembali di JDK 1.5 (2004), untuk waktu yang lama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tetap</a> sangat terbatas, dan bahkan sebagian komersial.  Hanya dengan OpenJDK 10 (2018) itu tersedia untuk orang biasa, pada saat yang sama memperluas ruang lingkup.  Dan Java 13 yang baru-baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dirilis</a> mencoba membuat aplikasi ini lebih sederhana. </p><br><p>  Gagasan AppCDS adalah untuk "berbagi" kelas sekali dimuat antara instance dari JVM yang sama pada host yang sama.  Tampaknya ini seharusnya bagus untuk layanan microser, terutama "broiler" di Spring Boot dengan ribuan kelas pustaka mereka, karena sekarang kelas-kelas ini tidak perlu dimuat (diuraikan dan diverifikasi) pada setiap awal setiap instance JVM, dan mereka tidak akan diduplikasi dalam memori.  Ini berarti peluncuran harus menjadi lebih cepat, dan konsumsi memori harus lebih rendah.  Luar biasa, bukan? </p><br><p>  Semuanya begitu, semuanya begitu.  Tetapi jika Anda, odnokhabryanin, dulu percaya bukan pada tanda-tanda bulevar, tetapi dalam jumlah dan contoh tertentu, maka selamat datang di kat - mari kita coba mencari tahu bagaimana itu sebenarnya ... </p><a name="habracut"></a><br><h2 id="vmesto-disclaimera">  Alih-alih disclaimer </h2><br><p>  Sebelum Anda bukan panduan untuk menggunakan AppCDS, tetapi ringkasan hasil studi kecil.  Saya tertarik untuk memahami bagaimana fungsi JVM ini berlaku dalam proyek kerja saya, dan saya mencoba untuk mengevaluasinya dari sudut pandang pengembang perusahaan, menguraikan hasil dalam artikel ini.  Ini tidak termasuk topik seperti menggunakan AppCDS pada lintasan modul, mengimplementasikan AppCDS pada mesin virtual lainnya (bukan HotSpot), dan seluk-beluk menggunakan wadah.  Tetapi ada bagian teoretis untuk menjelajahi topik, serta bagian eksperimental yang ditulis sehingga Anda dapat mengulangi pengalaman itu sendiri.  Belum ada hasil yang diterapkan dalam produksi, tetapi siapa tahu besok seperti apa ... </p><br><h2 id="teoriya">  Teori </h2><br><h3 id="kratkoe-vvedenie-v-appcds">  Pengantar singkat untuk AppCDS </h3><br><p>  Kenalan dengan topik ini mungkin terjadi pada Anda di beberapa sumber, misalnya: </p><br><ul><li>  dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> oleh Nikolai Parlog (termasuk roti Java 13, tetapi tanpa Spring Boot) </li><li>  dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> oleh Volker Simonis (tanpa Java 13, tetapi dengan detail) </li><li>  dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan oleh</a> penulis baris ini (tanpa Java 13, tetapi dengan penekanan pada Spring Boot) </li></ul><br><p>  Agar tidak terlibat dalam menceritakan kembali, saya hanya akan menyoroti beberapa poin yang penting untuk artikel ini. </p><br><p>  Pertama, AppCDS adalah perpanjangan dari fitur CDS yang telah lama muncul di HotSpot, intinya adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/gi/kg/ro/gikgrobp0s_hbnr5ox8z6d1ziqc.png"></p><br><p>  Untuk menghidupkan kedua gagasan itu, Anda perlu melakukan yang berikut (secara umum): </p><br><ol><li>  Dapatkan daftar kelas yang ingin Anda bagikan di antara instance aplikasi </li><li>  Gabungkan kelas-kelas ini ke dalam arsip yang sesuai untuk pemetaan memori </li><li>  Hubungkan arsip ke setiap instance aplikasi saat startup </li></ol><br><p>  Tampaknya algoritma ini hanya 3 langkah - ambil dan lakukan.  Tapi di sini beritanya dimulai, segala macam hal. </p><br><p>  Yang buruk adalah bahwa dalam kasus terburuk, masing-masing item ini berubah menjadi setidaknya satu peluncuran JVM dengan opsi spesifiknya sendiri, yang berarti bahwa keseluruhan algoritma adalah juggling halus dari jenis opsi dan file yang sama.  Kedengarannya tidak terlalu menjanjikan, bukan? </p><br><p>  Tetapi ada kabar baik: bekerja untuk meningkatkan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini sedang berlangsung</a> , dan dengan setiap rilis Java, aplikasinya menjadi lebih mudah.  Jadi misalnya: </p><br><ul><li> Di OpenJDK <strong>10 dan 11,</strong> Anda dapat melewati langkah <strong>1</strong> jika Anda ingin hanya membagikan kelas JDK utama, karena mereka telah dikompilasi untuk kami dan dimasukkan ke dalam <code>$JAVA_HOME\lib\classlist</code> (≈1200 pcs.). </li><li>  Di OpenJDK <strong>12,</strong> Anda dapat melewati <strong>langkah 2</strong> , karena bersama dengan daftar kelas, arsip distribusi juga menyertakan arsip yang sudah jadi, yang digunakan di luar kotak dan tidak memerlukan koneksi eksplisit. </li><li>  Jika Anda ingin membagikan yang lainnya (dan biasanya hanya ingin) <br>  OpenJDK <strong>13</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyediakan</a> Arsip CDS Dinamis - arsip yang dikumpulkan selama pengoperasian aplikasi dan disimpan ketika dikelola.  Ini memungkinkan Anda untuk mengurai <strong>poin 1 dan 2</strong> menjadi satu titik yang tidak terlalu membingungkan (walaupun tidak semuanya begitu sederhana, tetapi lebih lanjut tentang itu nanti) </li></ul><br><p>  Jadi, tidak peduli apa proses mempersiapkan AppCDS, 3 langkah yang tercantum di atas selalu di belakangnya, hanya dalam beberapa kasus mereka terselubung. </p><br><p>  Seperti yang mungkin Anda perhatikan, dengan munculnya AppCDS, banyak kelas aplikasi memulai kehidupan ganda: mereka hidup secara simultan di tempat sebelumnya (paling sering file JAR) dan di arsip bersama yang baru.  Pada saat yang sama, pengembang terus mengubah / menghapus / menambah mereka di tempat yang sama, dan JVM mengambilnya dari yang baru saat bekerja.  Seseorang tidak perlu menjadi peramal untuk melihat bahaya dari situasi seperti itu: jika tidak ada yang dilakukan, cepat atau lambat salinan kelas akan menimbulkan korosi, dan kita akan mendapatkan banyak pesona dari "JAR neraka" yang khas.  Jelas bahwa JVM tidak dapat mencegah perubahan kelas, tetapi harus dapat mendeteksi perbedaan waktu.  Namun, untuk melakukan ini dengan membandingkan kelas secara berpasangan, bahkan dengan checksum, adalah sebuah ide;  itu dapat meniadakan sisa keuntungan produktivitas.  Ini mungkin mengapa insinyur JVM tidak memilih kelas individu sebagai objek perbandingan, tetapi seluruh classpath, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dinyatakan</a> dalam dokumentasi AppCDS: "Jalan setapak saat membuat arsip bersama harus sama (atau setidaknya awalan) seperti dengan peluncuran aplikasi berikutnya." </p><br><blockquote>  Perhatikan bahwa classpath yang digunakan pada waktu pembuatan arsip harus sama dengan (atau awalan) classpath yang digunakan saat run time. </blockquote><p>  Tapi ini bukan pernyataan yang jelas, karena, seperti yang Anda ingat, classpath dapat dibentuk dengan cara yang berbeda, seperti: </p><br><ul><li>  membaca file <code>.class</code> kosong dari direktori paket yang dikompilasi, <br>  mis. <code>java com.example.Main</code> </li><li>  memindai direktori dengan file JAR saat menggunakan wildcard, <br>  mis. <code>java -cp mydir/* com.example.Main</code> </li><li>  daftar eksplisit file JAR dan / atau ZIP, <br>  mis. <code>java -cp lib1.jar;lib2.jar com.example.Main</code> </li></ul><br><p>  (ini tidak termasuk fakta bahwa classpath juga dapat diatur secara berbeda, misalnya, melalui opsi JVM <code>-cp/-classpath/--class-path</code> , variabel lingkungan <code>CLASSPATH</code> atau atribut file JAR <code>Class-Path</code> akan diluncurkan) </p><br><p>  Dari metode ini, hanya satu yang didukung di AppCDS - enumerasi eksplisit file JAR.  Rupanya, para insinyur JVM HotSpot merasa bahwa membandingkan jalur kelas dalam arsip AppCDS dan dalam aplikasi yang diluncurkan akan cukup cepat dan dapat diandalkan hanya jika mereka ditentukan sejelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mungkin</a> - dengan daftar lengkap yang biasa. </p><br><blockquote>  CDS / AppCDS mendukung kelas pengarsipan hanya dari file JAR. </blockquote><p>  Penting untuk dicatat di sini bahwa pernyataan ini tidak berulang, mis.  tidak berlaku untuk file JAR di dalam file JAR (kecuali jika itu tentang CD Dinamis, lihat di bawah).  Ini berarti bahwa boneka JAR biasa yang dikeluarkan oleh Spring Boot tidak akan berfungsi begitu saja dengan AppCDS biasa, Anda harus duduk. </p><br><p>  Tangkapan lain dalam karya CDS adalah bahwa arsip bersama diproyeksikan ke memori dengan alamat tetap (biasanya mulai dari <code>0x800000000</code> ).  Ini sendiri tidak buruk, tetapi karena Address Space Layout Randomization (ASLR) diaktifkan secara default pada sebagian besar sistem operasi, rentang memori yang diperlukan mungkin terisi sebagian.  Apa yang dilakukan HotSpot JVM dalam hal ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> khusus <code>-Xshare</code> yang mendukung tiga nilai: </p><br><ul><li>  <code>-Xshare:on</code> - force CDS / AppCDS;  jika rentang sibuk, JVM keluar dengan kesalahan.  Mode ini <strong>tidak disarankan untuk digunakan dalam produksi</strong> , karena ini dapat menyebabkan crash sporadis ketika meluncurkan aplikasi. </li><li>  <code>-Xshare:off</code> - (Anda) beralih CDS / AppCDS;  menonaktifkan penggunaan data bersama sepenuhnya (termasuk arsip tertanam) </li><li>  <code>-Xshare:auto</code> - perilaku default JVM ketika itu, dalam kasus ketidakmungkinan untuk mengalokasikan rentang memori yang diperlukan, menyerah dengan tenang dan memuat kelas seperti biasa </li></ul><br><p>  Pada saat penulisan artikel ini, Oracle sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berupaya</a> untuk mengatasi masalah tersebut, tetapi nomor rilis belum ditetapkan. </p><br><p>  Opsi ini sebagian berguna bagi kita nanti, tetapi untuk sekarang mari kita lihat ... </p><br><h3 id="varianty-primeneniya-appcds">  Aplikasi AppCDS </h3><br><p>  Ada beberapa cara yang Anda bisa dengan AppCDS. <del>  merusak hidupmu </del>  mengoptimalkan kerja layanan microser.  Mereka sangat bervariasi dalam kompleksitas dan potensi keuntungan, jadi penting untuk segera memutuskan mana yang akan dibahas nanti. </p><br><p>  Yang paling sederhana adalah menggunakan bahkan AppCDS, tetapi hanya CDS - ini adalah ketika hanya kelas platform masuk ke arsip bersama (lihat "Pengantar Singkat untuk AppCDS").  Kami akan segera menghapus opsi ini, karena ketika diterapkan ke layanan microser di Boot Musim Semi itu memberi terlalu sedikit keuntungan.  Ini dapat dilihat dengan proporsi jumlah kelas bersama dalam distribusi umum mereka menggunakan contoh dari satu layanan nyata mikro (lihat segmen hijau): </p><br><p><img src="https://habrastorage.org/webt/lz/7x/9l/lz7x9lodfzwv4ihwjjifjyxsf_a.png"></p><br><p>  Lebih kompleks, tetapi menjanjikan adalah penggunaan AppCDS lengkap, yaitu, dimasukkannya kedua perpustakaan dan kelas aplikasi dalam arsip yang sama.  Ini adalah seluruh keluarga opsi yang berasal dari kombinasi jumlah aplikasi yang berpartisipasi dan jumlah instance.  Berikut ini adalah penilaian penulis subyektif tentang manfaat dan kesulitan berbagai aplikasi AppCDS. </p><br><div class="scrollable-table"><table><thead><tr><th>  Tidak. </th><th>  Aplikasi </th><th>  Contoh </th><th>  Keuntungan CPU </th><th>  Keuntungan RAM </th><th>  Kesulitan </th></tr></thead><tbody><tr><td>  1 </td><td>  Satu </td><td>  Satu </td><td>  + </td><td>  ± </td><td>  Rendah </td></tr><tr><td>  <strong>2</strong> </td><td>  <strong>Satu</strong> </td><td>  <strong>Beberapa</strong> </td><td>  <strong>++</strong> </td><td>  <strong>++</strong> </td><td>  <strong>Rendah</strong> </td></tr><tr><td>  3 </td><td>  Beberapa </td><td>  Satu per satu </td><td>  ++ </td><td>  ++ </td><td>  Tinggi </td></tr><tr><td>  4 </td><td>  Beberapa </td><td>  Beberapa </td><td>  +++ </td><td>  +++ </td><td>  Tinggi </td></tr></tbody></table></div><br><p>  Perhatikan: </p><br><ul><li>  Dalam aplikasi ke satu aplikasi dalam satu contoh (No. 1), laba memori dapat berubah menjadi nol atau bahkan negatif (terutama ketika mengukur di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawah Windows</a> ) </li><li>  Membuat arsip bersama yang benar memerlukan tindakan, kerumitannya tidak tergantung pada berapa banyak salinan yang akan diluncurkan aplikasi (bandingkan pasangan opsi No. 1-2 dan No. 3-4) </li><li>  Pada saat yang sama, transisi dari satu contoh ke beberapa, jelas, memberikan peningkatan laba untuk kedua indikator, tetapi tidak mempengaruhi kompleksitas persiapan. </li></ul><br><p>  Dalam artikel ini, kita <strong>hanya</strong> akan <strong>mencapai opsi No. 2</strong> (melalui No. 1), karena cukup sederhana untuk berkenalan dekat dengan AppCDS dan hanya untuk itu tanpa trik tambahan kita dapat menggunakan Arsip CDS Dinamis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP-350 yang</a> baru dirilis, yang ingin saya rasakan saat beraksi. </p><br><h3 id="dynamic-cds-archives">  Arsip CDS dinamis </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP-350</a> Dynamic CDS Archives, salah satu inovasi utama Java 13, dirancang untuk menyederhanakan penggunaan AppCDS.  Untuk merasakan penyederhanaan, Anda harus terlebih dahulu memahami kompleksitasnya.  Biarkan saya mengingatkan Anda bahwa algoritma aplikasi "bersih" klasik untuk AppCDS terdiri dari 3 langkah: (1) dapatkan daftar kelas bersama, (2) buat arsip dari mereka, dan (3) jalankan aplikasi dengan arsip terhubung.  Dari langkah-langkah ini, hanya yang ke-3 yang benar-benar berguna, sisanya hanya persiapan untuk itu.  Dan walaupun mendapatkan daftar kelas (langkah # 1) mungkin tampak sangat sederhana (dalam beberapa kasus ini bahkan opsional), pada kenyataannya ketika bekerja dengan aplikasi non-sepele, ternyata menjadi yang paling sulit, terutama yang berkaitan dengan Spring Boot.  Jadi JEP-350 diperlukan hanya untuk menghilangkan langkah ini, atau lebih tepatnya, mengotomatiskannya.  Idenya adalah bahwa JVM sendiri menyusun daftar kelas yang dibutuhkan aplikasi, dan kemudian dengan sendirinya membentuk apa yang disebut "dinamis" arsip dari mereka.  Setuju, kedengarannya bagus.  Tetapi yang menarik adalah bahwa sekarang menjadi tidak jelas pada titik apa untuk berhenti mengumpulkan kelas dan melanjutkan untuk menempatkannya di arsip.  Sebelumnya, di AppCDS klasik, kami memilih momen seperti itu sendiri dan bahkan bisa menyelipkan antara tindakan ini untuk mengubah sesuatu dalam daftar kelas sebelum mengubahnya menjadi arsip.  Sekarang ini terjadi secara otomatis dan hanya pada satu saat, di mana para insinyur JVM telah memilih, mungkin, satu-satunya pilihan kompromi - penutupan rutin JVM.  Ini berarti bahwa arsip tidak akan dibuat sampai aplikasi berhenti.  Solusi ini memiliki beberapa konsekuensi penting: </p><br><ul><li>  Jika terjadi crash JVM, arsip tidak akan dibuat, betapapun hebatnya daftar kelas yang terakumulasi saat itu (Anda tidak dapat mengekstraknya nanti menggunakan cara biasa). </li><li>  Arsip akan dibuat hanya dari kelas-kelas yang berhasil dimuat selama sesi aplikasi.  Untuk aplikasi web, ini berarti membuat arsip dengan memulai dan berhenti di sana tidak benar, karena banyak kelas penting tidak akan masuk ke arsip.  Penting untuk menjalankan setidaknya satu permintaan HTTP ke aplikasi (dan lebih baik menjalankannya dengan benar di semua skenario) sehingga semua kelas yang digunakan benar-benar dimuat. </li></ul><br><p>  Perbedaan penting antara arsip dinamis dan statis adalah bahwa mereka selalu merupakan "tambahan" atas arsip statis dasar, yang dapat berupa arsip yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibangun</a> dalam kit distribusi Java atau dibuat secara terpisah dengan cara 3 langkah klasik. </p><br><p>  Secara sintaksis, menggunakan Arsip CDS Dinamis diturunkan menjadi dua peluncuran JVM dengan dua opsi: </p><br><ol><li>  Percobaan dijalankan dengan opsi <code>-XX:ArchiveClassesAtExit=archive.jsa</code> , di mana akhirnya arsip dinamis akan dibuat (Anda dapat menentukan jalur dan nama apa saja) </li><li>  Peluncuran yang berguna dengan opsi <code>-XX:SharedArchiveFile=archive.jsa</code> , yang akan menggunakan arsip yang dibuat sebelumnya </li></ol><br><p>  Opsi kedua tidak berbeda dengan menghubungkan arsip statis biasa.  Tetapi jika tiba-tiba arsip statis dasar tidak berada di lokasi default (di dalam JDK), maka opsi ini juga dapat menyertakan indikasi jalur ke sana, misalnya: </p><br><pre> <code class="bash hljs">-XX:SharedArchiveFile=base.jsa:dynamic.jsa</code> </pre> <br><p>  <em>(di bawah Windows, pemisah jalur harus karakter ";")</em> </p><br><p>  Sekarang Anda cukup tahu tentang AppCDS sehingga Anda dapat melihatnya dalam tindakan. </p><br><h2 id="praktika">  Berlatih </h2><br><h3 id="podopytnyy-krolik">  Kelinci percobaan </h3><br><p>  Agar aplikasi AppCDS kami dalam praktiknya tidak terbatas pada HelloWorld biasa, kami akan mengambil sebagai dasar aplikasi nyata pada Spring Boot.  Rekan-rekan saya dan saya sering harus menonton log aplikasi pada server uji jarak jauh, dan menonton "langsung", sama seperti yang tertulis.  Untuk menggunakan ini, agregator log lengkap (seperti ELK) seringkali tidak sesuai;  mengunduh file log tanpa henti - untuk waktu yang lama, dan melihat keluaran konsol abu-abu yang tertekan sangat menyedihkan.  Oleh karena itu, saya membuat aplikasi web yang dapat menampilkan semua log secara real time langsung ke browser, mewarnai garis berdasarkan tingkat kepentingan (pada saat yang sama memformat XML), menggabungkan beberapa log menjadi satu, serta trik lainnya.  Itu disebut <strong>ANALOG</strong> (seperti "log analyzer", meskipun ini tidak benar) dan terletak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> .  Klik pada tangkapan layar untuk memperbesar: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/q3/lo/m_/q3lom_x6c9wghlerm1g9oa9-yfw.png"></a> </p><br><p>  Secara teknis, ini adalah aplikasi pada Spring Boot + Spring Integration, di bawah kap yang bekerja <code>tail</code> , <code>docker</code> dan <code>kubectl</code> (untuk mendukung log dari file, wadah Docker dan sumber daya Kubernetes, masing-masing).  Muncul dalam bentuk file JAR Spring Boot "tebal" klasik.  Dalam runtime, <strong>kelas ≈10K tergantung</strong> pada memori aplikasi, yang sebagian besar adalah kelas Spring dan JDK.  Jelas, kelas-kelas ini sangat jarang berubah, yang berarti bahwa mereka dapat dimasukkan ke dalam arsip bersama dan digunakan kembali dalam semua contoh aplikasi, menghemat memori dan CPU. </p><br><h3 id="odinochnyy-eksperiment">  Eksperimen tunggal </h3><br><p>  Sekarang mari kita terapkan pengetahuan yang ada tentang Dynamic AppCDS ke kelinci percobaan.  Karena semuanya diketahui sebagai perbandingan, kami akan memerlukan beberapa titik referensi - keadaan program yang akan kami bandingkan dengan hasil yang diperoleh selama percobaan. </p><br><h4 id="vvodnye-zamechaniya">  Kata pengantar </h4><br><ul><li>  Semua perintah lebih lanjut adalah untuk Linux.  Perbedaan untuk Windows dan macOS tidak mendasar. </li><li>  Kompilasi JIT secara nyata dapat mempengaruhi hasil dan, secara teori, untuk kemurnian percobaan, dapat dimatikan (dengan opsi <code>-Xint</code> , seperti yang dilakukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> disebutkan), tetapi demi kredibilitas maksimum diputuskan untuk tidak melakukan ini. </li><li>  Angka-angka berikut tentang waktu mulai diperoleh pada server uji cepat.  Pada mesin yang bekerja, angka yang sama, sebagai suatu peraturan, lebih sederhana, tetapi karena kami tidak tertarik pada nilai absolut, tetapi dalam peningkatan persentase, kami menganggap perbedaan ini tidak signifikan. </li><li>  Agar tidak terlalu dini memasuki kompleksitas pengukuran memori bersama, untuk saat ini kita akan menghilangkan pembacaan yang akurat dalam byte.  Sebagai gantinya, kami memperkenalkan konsep " <strong>potensi CDS,</strong> " yang dinyatakan sebagai persentase dari jumlah kelas bersama dengan jumlah total kelas yang dimuat.  Ini, tentu saja, adalah kuantitas abstrak, tetapi di sisi lain, secara langsung mempengaruhi konsumsi memori yang sebenarnya;  selain itu, definisinya tidak bergantung pada OS sama sekali, dan untuk perhitungannya, hanya log yang cukup. </li></ul><br><h4 id="referentnaya-tochka">  Titik referensi </h4><br><p>  Biarkan titik ini menjadi keadaan aplikasi yang baru diunduh, mis.  tanpa penggunaan eksplisit dari AppCDS'ov dan lainnya.  Untuk mengevaluasinya, kita perlu: </p><br><ol><li><p>  Instal OpenJDK 13 (misalnya, distribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liberica</a> domestik, tetapi bukan versi lite). <br>  Itu juga perlu ditambahkan ke variabel lingkungan PATH atau ke <code>JAVA_HOME</code> , misalnya, seperti ini: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_HOME=~/tools/jdk-13</code> </pre> <br></li><li><p>  <a href="">Unduh</a> ANALOG (pada saat penulisan, versi terbaru adalah v0.12.1). </p><br><p>  Jika perlu, Anda dapat menentukan dalam file <code>config/application.yaml</code> di <code>server.address</code> parameter nama host eksternal untuk mengakses aplikasi (secara default, <code>localhost</code> ditentukan di sana). </p><br></li><li><p>  Aktifkan pencatatan beban kelas JVM. <br>  Untuk melakukan ini, Anda dapat <code>JAVA_OPTS</code> - <code>JAVA_OPTS</code> variabel lingkungan <code>JAVA_OPTS</code> dengan nilai ini: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=-Xlog:class+load=info:file=<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/class-load.log</code> </pre> <br><p>  Opsi ini akan diteruskan ke JVM dan memberitahukannya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjaminkan</a> sumber dari setiap kelas. </p><br></li><li><p>  Jalankan uji coba: </p><br><ol><li>  Jalankan aplikasi dengan skrip <code>bin/analog</code> </li><li>  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 8083</a> di browser, tekan tombol dan daw </li><li>  Hentikan aplikasi dengan menekan <code>Ctrl+C</code> di konsol skrip <code>bin/analog</code> </li></ol><br></li><li><p>  Ambil hasilnya (dari file di <code>log/</code> direktori) </p><br><ul><li><p>  Total jumlah kelas yang dimuat (berdasarkan <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10463</code> </pre> <br></li><li><p>  Berapa banyak dari mereka yang diunduh dari arsip bersama (sesuai dengan itu): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> - class-load.log 1146</code> </pre> <br></li><li><p>  Waktu mulai rata-rata (setelah serangkaian awal; dengan <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.5225</code> </pre> <br></li></ul><br></li></ol><br><p>  Jadi, pada langkah ini, potensi CDS adalah <code>1146/10463=0,1095</code> <strong>≈11%</strong> .  Jika Anda terkejut dari mana asal kelas yang dibagi (setelah semua, kami belum memasukkan AppCDS), maka saya mengingatkan Anda bahwa mulai dari versi ke-12, JDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyertakan</a> arsip CDS yang telah selesai <code>$JAVA_HOME/lib/server/classes.jsa</code> , dibangun oleh tidak kurang dari daftar kelas siap: </p><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$JAVA_HOME</span></span>/lib/classlist | wc -l 1170</code> </pre> <br><p>  Sekarang, setelah menilai keadaan awal aplikasi, kita dapat menerapkan AppCDS untuk itu dan, sebagai perbandingan, memahami apa yang diberikannya. </p><br><h4 id="osnovnoy-opyt">  Pengalaman inti </h4><br><p>  Saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> mewariskan kepada kami, untuk membuat arsip AppCDS yang dinamis, Anda hanya perlu melakukan satu kali uji coba aplikasi dengan opsi <code>-XX:ArchiveClassesAtExit</code> .  Dari peluncuran berikutnya, arsip dapat digunakan dan menerima keuntungan.  Untuk memverifikasi ini pada kelinci percobaan yang sama (AnaLog), Anda perlu: </p><br><ol><li><p>  Tambahkan opsi yang ditentukan untuk menjalankan perintah: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:ArchiveClassesAtExit=work/classes.jsa"</span></span></code> </pre> <br></li><li><p>  Perpanjang logging: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -Xlog:cds=debug:file=log/cds.log"</span></span></code> </pre><br><p>  Opsi ini akan memaksa proses pembuatan arsip CDS untuk dicatat ketika aplikasi dihentikan. </p><br></li><li><p>  Lakukan uji coba yang sama seperti dengan titik referensi: </p><br><ol><li>  Jalankan aplikasi dengan skrip <code>bin/analog</code> </li><li>  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 8083</a> di browser, tekan tombol dan daw </li><li>  Hentikan aplikasi dengan menekan <code>Ctrl+C</code> di konsol skrip <code>bin/analog</code> <br>  Setelah itu, alas kaki yang luar biasa dengan segala macam peringatan akan jatuh ke konsol, dan file <code>log/cds.log</code> harus diisi dengan detail;  mereka belum menarik minat kita. </li></ol><br></li><li><p>  Alihkan mode peluncuran dari percobaan ke berguna: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-XX:SharedArchiveFile=work/classes.jsa -Xlog:class+load=info:file=log/class-load.log -Xlog:class+path=debug:file=log/class-path.log"</span></span></code> </pre><br><p>  Di sini kita tidak menambah variabel <code>JAVA_OPTS</code> , tetapi menimpanya dengan nilai-nilai baru yang meliputi (1) menggunakan arsip bersama, (2) sumber kelas logging dan (3) logging jalur kelas logging. </p><br></li><li><p>  Lakukan peluncuran aplikasi yang bermanfaat sesuai dengan skema dari paragraf 3. </p><br></li><li><p>  Ambil hasilnya (dari file di <code>log/</code> direktori) </p><br><ul><li><p>  Memverifikasi bahwa AppCDS benar-benar diterapkan (berdasarkan <code>class-path.log</code> ): </p><br><pre> <code class="plaintext hljs">[0.011s][info][class,path] type=BOOT [0.011s][info][class,path] Expecting BOOT path=/home/upc/tools/jdk-13/lib/modules [0.011s][info][class,path] ok [0.011s][info][class,path] type=APP [0.011s][info][class,path] Expecting -Djava.class.path=/home/upc/tmp/analog/lib/analog.jar [0.011s][info][class,path] ok</code> </pre><br><p>  Tanda <code>ok</code> setelah <code>type=BOOT</code> baris <code>type=BOOT</code> dan <code>type=APP</code> menunjukkan keberhasilan pembukaan, verifikasi, dan pemuatan arsip CDS bawaan dan yang diterapkan. </p><br></li><li><p>  Total jumlah kelas yang dimuat (berdasarkan <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10403</code> </pre><br></li><li><p>  Berapa banyak dari mereka yang diunduh dari arsip bersama (sesuai dengan itu): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> -c class-load.log 6910</code> </pre><br></li><li><p>  Waktu mulai rata-rata (setelah serangkaian mulai; dengan file <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.04167</code> </pre><br></li></ul><br></li></ol><br><p>  Tetapi pada langkah ini, potensi CDS sudah <code>6910/10403≈0,66</code> <strong>= 66%</strong> , artinya, meningkat <strong>sebesar 55%</strong> dibandingkan dengan titik referensi.  Pada saat yang sama, waktu peluncuran rata-rata berkurang sebesar <code>(4,5225-4,04167)=0,48</code> detik, mis.  mulai lebih cepat dengan <strong>≈10.6%</strong> dari nilai awal. </p><br><h4 id="analiz-rezultatov">  Analisis Hasil </h4><br><p>  <em>Judul pekerjaan dari item tersebut adalah: "Mengapa begitu sedikit?"</em> </p><br><p>  Kami, seperti, melakukan semuanya sesuai dengan instruksi, tetapi tidak semua kelas ada di arsip.  Jumlah mereka memengaruhi waktu peluncuran tidak kurang dari kekuatan komputasi mesin eksperimen, jadi kami akan berkonsentrasi pada jumlah ini. </p><br><p>  Jika Anda ingat, kami mengabaikan file <code>log/cds.log</code> dibuat saat berhenti dari aplikasi eksperimental setelah percobaan berjalan.  Dalam file HotSpot ini, JVM dengan baik hati mencatat dengan peringatan peringatan setiap kelas yang tidak muncul dalam arsip CDS.  Berikut adalah jumlah total dari tanda tersebut: </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'[warning]'</span></span> cds.log -c 3591</code> </pre><br><p>  Mempertimbangkan bahwa hanya 10K + kelas yang disebutkan dalam log <code>class-load.log</code> dan 66% dari mereka dimuat dari arsip, tidak sulit untuk memahami bahwa 3600 kelas yang terdaftar di <code>cds.log</code> adalah "hilang" 44% dari potensi CDS.  Sekarang Anda perlu mencari tahu mengapa mereka dilewati. </p><br><p>  Jika Anda melihat log cds.log, ternyata hanya ada 4 alasan unik untuk melewatkan kelas.  Berikut adalah contoh masing-masing: </p><br><pre> <code class="plaintext hljs">Skipping org/springframework/web/client/HttpClientErrorException: Not linked Pre JDK 6 class not supported by CDS: 49.0 org/jrobin/core/RrdUpdater Skipping java/util/stream/Collectors$$Lambda$554: Unsafe anonymous class Skipping ch/qos/logback/classic/LoggerContext: interface org/slf4j/ILoggerFactory is excluded</code> </pre><br><p>  Di antara semua 3591 kelas yang terlewat, alasan ini ditemukan di sini dengan frekuensi seperti ini: </p><br><p><img src="https://habrastorage.org/webt/sp/f6/6k/spf66kzmkajvdxki1xdiwjyx9lg.png"></p><br><p>  Lihatlah lebih dekat pada mereka: </p><br><ul><li><p> <code>Unsafe anonymous class</code> <br>   JVM   “”   ,       -,         . </p><br></li><li><p> <code>Not linked</code> <br>      , “”     ,  ,   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StackOverflow </a>    . , ,       “” () JAR-  ,   AppCDS.       ,     (  ). </p><br></li><li><p> <code>Pre JDK 6 class</code> <br>  ,   CDS    Java 5.        class-   ,   CDS    .    ,    ,  6,  Java,       .       -   ,      runtime- (, slf4j). </p><br></li><li><p> <code>Skipping ... : super class/interface ... is excluded</code> <br>   ,  “”     .          CDS',    .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">[warning][cds] Pre JDK 6 class not supported by CDS: 49.0 org/slf4j/spi/MDCAdapter [warning][cds] Skipping ch/qos/logback/classic/util/LogbackMDCAdapter: interface org/slf4j/spi/MDCAdapter is excluded</code> </pre><br></li></ul><br><p>  <strong>Kesimpulan</strong> </p><br><blockquote>  CDS       100%. </blockquote><p> ,     ,  ,         ,  ,     .      . </p><br><h3 id="mnozhestvennyy-eksperiment">   </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP-310</a> , AppCDS                         JDK.   .       ,     .    CDS (, ,     )       . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengkloning kelinci percobaan (jalankan AnaLog dalam beberapa kasus), kita perlu mengubah sesuatu di pengaturan; </font><font style="vertical-align: inherit;">ini akan memungkinkan proses yang diangkat tidak ke "siku". </font><font style="vertical-align: inherit;">Berkat Spring Boot, Anda dapat melakukan ini tanpa mengedit atau menyalin file apa pun; </font><font style="vertical-align: inherit;">pengaturan apa pun dapat ditimpa oleh opsi JVM. </font><font style="vertical-align: inherit;">Meneruskan opsi-opsi ini dari variabel lingkungan </font></font><code>ANALOG_OPTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan skrip peluncuran, yang dibuat dengan baik oleh Gradle.</font></font></p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"-Djavamelody.enabled=false -Dlogging.config=classpath:logging/logback-console.xml"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p>      JavaMelody,             ,        ,       .     TCP-    ;       . </p><br><p>  ,    ,   JVM      AppCDS    .         <code>JAVA_OPTS</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM Unified Logging Framework</a> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xlog:class+load=info:file=log/class-load-%p.log -Xlog:class+path=debug:file=log/class-path-%p.log"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:SharedArchiveFile=work/classes.jsa"</span></span></code> </pre><br><p>        <code>%p</code> ,    JVM      (PID).   AppCDS  ,     (         ). </p></div></div><br><h4 id="osnovnoy-opyt-1">   </h4><br><p>  ,          .                  .     : </p><br><ol><li><p>      <code>server.port</code>  <code>nodes.this.agentPort</code> ,      : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p> ,       (    ). </p><br></li><li><p>    <code>bin/analog</code> </p><br><p> <em>()</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://localhost:8091</a>  ,     </p><br></li><li><p>  PID  (  ), : </p><br><pre> <code class="bash hljs">pgrep -f analog 13792</code> </pre><br></li><li><p>      <code>pmap</code> (    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ): </p><br><pre> <code class="bash hljs">pmap -XX 13792 | sed -n -e <span class="hljs-string"><span class="hljs-string">'2p;$p'</span></span> Address Perm Offset Device Inode Size KernelPageSize MMUPageSize Rss Pss Shared_Clean Shared_Dirty Private_Clean Private_Dirty Referenced Anonymous LazyFree AnonHugePages ShmemPmdMapped Shared_Hugetlb Private_Hugetlb Swap SwapPss Locked ProtectionKey VmFlagsMapping 3186952 1548 1548 328132 325183 3256 0 10848 314028 212620 314024 0 0 0 0 0 0 0 325183 0 KB</code> </pre><br><p>           ;   . </p><br></li><li><p>   1-4     (,  ). </p><br></li></ol><br><h4 id="analiz-rezultatov-1">   </h4><br><p>    <code>pmap</code>             .        CDS'    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> .    ,  ,        PSS: </p><br><blockquote> The "proportional set size" (PSS) of a process is the count of pages it has in memory, where each page is divided by the number of processes sharing it. So if a process has 1000 pages all to itself, and 1000 shared with one other process, its PSS will be 1500. </blockquote><p>  ,   ,  “ ” .        ,      . </p><br><p>    PSS       ,    : </p><br><div class="scrollable-table"><table><thead><tr><th> Iteration: </th><th>  1 </th><th>  2 </th><th>  3 </th><th>  4 </th><th>  5 </th></tr></thead><tbody><tr><td> PSS of inst#1: </td><td> 339 088 </td><td> 313 778 </td><td> 305 517 </td><td> 301 153 </td><td> 298 604 </td></tr><tr><td> PSS of inst#2: </td><td></td><td> 314 904 </td><td> 306 567 </td><td> 302 555 </td><td> 299 919 </td></tr><tr><td> PSS of inst#3: </td><td></td><td></td><td> 314 914 </td><td> 311 008 </td><td> 308 691 </td></tr><tr><td> PSS of inst#4: </td><td></td><td></td><td></td><td> 306 563 </td><td> 304 495 </td></tr><tr><td> PSS of inst#5: </td><td></td><td></td><td></td><td></td><td> 294 686 </td></tr><tr><td> <em>Average:</em> </td><td> 339 088 </td><td> 314 341 </td><td> 308 999 </td><td> 305 320 </td><td> 301 279 </td></tr></tbody></table></div><br><p>         ,      - : </p><br><ul><li>        “”  </li><li>     , PSS   </li><li>  “” ,     PSS      </li></ul><br><p>    ,      .         AppCDS.        ,       <code>-XX:SharedArchiveFile=work/classes.jsa</code>   <code>-Xshare:off</code> ,    CDS .              ,    . </p><br><p><img src="https://habrastorage.org/webt/vq/4s/n6/vq4sn66zppmcyl5aovqj6xpkwyq.png"></p><br><p>       : </p><br><ul><li><p>  PSS  AppCDS      CDS. <br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .  ,  ,    HelloWorld- JVM   CDS   2   ,   CDS.      PSS            CDS,     .        : </p><br></li><li><p>    PSS   AppCDS    2-  ; 3-      . <br>        ,      ,    ,     .  ,        AppCDS,   ,   ,      3-    . <br>  :    ,    CDS?      : </p><br></li><li><p>    CDS/AppCDS  JVM      ,  PSS       .  ,    ,      <code>pmap</code> ,   “”   <code>sed</code> '.              : </p><br><pre> <code class="bash hljs">pmap -X `pgrep -f analog` 14981: <span class="hljs-comment"><span class="hljs-comment"># ... Address Perm Offset Device Inode Size Rss Pss ... Mapping # ... ... 7faf5e31a000 r-xp 00000000 08:03 269427 17944 14200 14200 ... libjvm.so # ... ... 7faf5f7f9000 r-xp 00000000 08:03 1447189 1948 1756 25 ... libc-2.27.so</span></span></code> </pre><br><p>       ( <code>Mapping</code> )  , “”      .       JVM  ( <code>libjvm.so</code>   ),     ( <code>libc-2.27.so</code>  ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>        : </p><br><blockquote> For the Java VM, the read-only parts of the loaded shared libraries (ie <code>libjvm.so</code> ) can be shared between all the VM instances running at the same time. This explains why, taking together, the two VM's consume less memory (ie have a smaller memory footprint) than the simple sum of their single resident set sizes when running alone. </blockquote><br></li></ul><br><p>           .     ,  , .  ,          ,         JVM     ,    Java-    .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  GeekOut: </p><br><p><img src="https://habrastorage.org/webt/wp/ia/qo/wpiaqom-2teiw_iegjacskkt3sm.png"></p><br><p> , , ,      AppCDS    , ..     Java-.   ,             JVM,  , -      . </p><br><p>       VisualVM      Metaspace    AppCDS  ,      : </p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/pt/wv/6r/ptwv6rmyk8j7f7yzgxrjkqrsvww.png"></p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/dt/jn/0m/dtjn0mdpcgykbfynjbwdma2vmqm.png"></p><br><p>   ,         128     Metaspace   AppCDS    <code>64.2 MiB / 8.96 MiB</code> <strong>≈7,2  </strong> ,   CDS .            (.  )       <code>66.4 MiB / 13.9 MiB</code> <strong>≈4,8 </strong> .      ,    AppCDS      ,       Metaspace.            Metaspace,    ,    CDS . </p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>            Spring Boot  AppCDS –  JVM,        . </p><br><ul><li>            JEP-350 Dynamic CDS Archives –    JDK 13. </li><li>    Spring Boot  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ó</a>          CDS (  ). ,           100%   -   <strong>66%</strong> .      ,      <strong>≈11%</strong> (    15%,      ). </li><li>     ,       5-     PSS (      ).  ,  AppCDS     ,   <strong>  </strong>           , <strong> 8%</strong> (PSS).       ,    CDS,     ,     .        AppCDS  <strong> </strong> . </li><li>          Metaspace,  ,         AppCDS  <strong> 5  </strong> ,   CDS. </li></ul><br><p> ,    , AppCDS,  ,    “killer feature”.           Spring Boot.   ,   ,    AppCDS      .  , ,        AppCDS   <em></em>   Spring Boot.              ,      … </p><br><p> <em>  by <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nick Fewings</a> on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unsplash</a></em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472638/">https://habr.com/ru/post/id472638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472620/index.html">Museum DataArt. Inspeksi terminal video Mera CM 7209</a></li>
<li><a href="../id472622/index.html">Rencana leveling untuk Insinyur Data profesi</a></li>
<li><a href="../id472626/index.html">Ulasan motherboard ASRock Z390 Phantom Gaming 7: persiapan untuk 9900KS</a></li>
<li><a href="../id472628/index.html">Pengkodean, shift cipher, hash kasar dan pembuatan gambar menggunakan PIL python. Pemecahan masalah dengan r0ot-mi Cryto. Bagian 1</a></li>
<li><a href="../id472636/index.html">Ikhtisar program DotNext 2019 Moskow: siapa yang akan memberi tahu Anda apa?</a></li>
<li><a href="../id472640/index.html">Apa yang saya pelajari dalam 6 tahun membantu startup tumbuh</a></li>
<li><a href="../id472642/index.html">Freelance webdev - bagaimana dan dengan siapa Anda TIDAK boleh bekerja</a></li>
<li><a href="../id472644/index.html">Magang di perusahaan internasional: bagaimana tidak mengisi wawancara dan mendapatkan penawaran yang diidamkan</a></li>
<li><a href="../id472650/index.html">Ketakutan, rasa sakit dan kebencian akan dukungan teknis</a></li>
<li><a href="../id472658/index.html">Hampir semuanya tentang masa depan HolyJS 2019 Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>