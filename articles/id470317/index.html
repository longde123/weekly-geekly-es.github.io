<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴 👨🏾‍🚒 ⛹🏻 C ++ lembar contekan singkatan dan banyak lagi. Bagian 2: "dan tidak hanya" ☢️ 👩🏽‍🍳 🧑🏿‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dan terakhir dari lembar contekan singkatan saya yang harus diketahui oleh pengembang C ++. C ++ disebutkan di sini hanya kare...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ lembar contekan singkatan dan banyak lagi. Bagian 2: "dan tidak hanya"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470317/">  Ini adalah bagian kedua dan terakhir dari lembar contekan singkatan saya yang harus diketahui oleh pengembang C ++.  C ++ disebutkan di sini hanya karena saya membuat lembar cheat terutama untuk diri saya sendiri, dan saya hanya pengembang C ++ yang sama. <br><br>  Bahkan, bagian ini berisi konsep-konsep yang ruang lingkupnya tidak terbatas pada C ++.  Jadi seleksi mungkin menarik bagi khalayak yang lebih luas. <br><br><img src="https://habrastorage.org/webt/5v/rw/tl/5vrwtlvriee907omassuau2avzq.png"><br><a name="habracut"></a><br>  Seperti pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , singkatan dikelompokkan, jika itu masuk akal.  Jika tidak masuk akal, mereka terdaftar berdasarkan abjad. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konkurensi dan operasi atom:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAS</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABA</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FAA</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RCU</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan data:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASAM</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PACELC</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DASAR</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip Pengembangan Perangkat Lunak:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KERING</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KISS</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YAGNI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NIH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTSE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GRASP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOLID</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lainnya:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SAPI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FBC, FBCP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LRU</a> <br><br><h2>  Operasi Konkurensi dan Atom <a name="Concurrency"></a></h2><br><h3>  Cas <a name="CAS"></a></h3><br>  <i>Bandingkan dan Tukar.</i>  <i>Perbandingan dengan pertukaran.</i>  Ini adalah instruksi atom dengan tiga argumen: variabel atom atau alamat memori, nilai yang diharapkan, nilai baru.  Jika dan hanya jika nilai variabel cocok dengan nilai yang diharapkan, variabel menerima nilai baru dan instruksi berhasil diselesaikan.  <i>CAS</i> hanya mengembalikan nilai Boolean (dan kemudian dapat disebut Bandingkan dan Set), atau jika gagal, <i>CAS</i> juga mengembalikan nilai saat ini dari argumen pertama. <br><br><div class="spoiler">  <b class="spoiler_title">Kode palsu</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; expected, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*addr != expected) { expected = *addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } *addr = new_value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br>  Dalam C ++, <i>CAS</i> diwakili oleh <code>std::atomic&lt;T&gt;::compare_exchange_weak</code> metode <code>std::atomic&lt;T&gt;::compare_exchange_weak</code> , <code>std::atomic&lt;T&gt;::compare_exchange_strong</code> dan fungsi bebas <code>std::atomic_compare_exchange_weak</code> , <code>std::atomic_compare_exchange_strong</code> .  Perbedaan antara <b>* lemah</b> dan <b>* kuat</b> adalah bahwa yang pertama dapat menghasilkan hasil negatif palsu.  Yaitu  jika nilainya diharapkan, mereka akan mengembalikan <code>false</code> dan tidak akan menggantinya dengan yang baru.  Alasan keberadaan <b>*</b> operasi <b>lemah</b> adalah bahwa pada beberapa arsitektur <b>* kuat</b> relatif mahal.  Dalam kebanyakan kasus, instruksi <i>CAS</i> berputar dalam satu loop (disebut loop CAS), jadi menggunakan <b>* lemah</b> sebagai ganti <b>* kuat</b> tidak akan mengubah logika, tetapi itu dapat meningkatkan kinerja. <br><br>  Instruksi <i>CAS</i> digunakan untuk mengimplementasikan primitif sinkronisasi (seperti mutex dan semaphores) dan algoritma bebas kunci.  Seringkali menyebabkan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABA</a> . <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekali (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> <br><br><h3>  ABA <a name="ABA"></a></h3><br>  <i>Masalah ABA.</i>  <i>Masalah ABA.</i>  Masalah ini muncul dalam algoritma paralel berdasarkan perbandingan dengan pertukaran (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAS</a> ), misalnya, dalam algoritma bebas kunci.  Intinya adalah bahwa thread membaca nilai variabel atom, melakukan sesuatu yang lain dan memperbarui variabel ini melalui perbandingan dengan pertukaran.  Yaitu  logika aliran adalah sebagai berikut: jika variabel masih berisi nilai sebelumnya, maka tidak ada yang berubah, semuanya dalam urutan.  Tapi ini mungkin tidak benar.  Deskripsi masalah yang lebih formal: <br><br><ul><li>  thread 1 membaca nilai variabel, sama dengan A </li><li>  utas 1 sedang dipaksa keluar, utas 2 sedang dimulai </li><li>  thread 2 mengubah nilai variabel dari A ke B, membuat banyak perubahan (mengubah beberapa nilai yang terkait dengan variabel atau hanya membebaskan memori), dan sekali lagi mengubah nilai - dari B ke A </li><li>  utas 1 melanjutkan operasi, membandingkan nilai yang diperoleh sebelumnya dengan yang sekarang dan menyimpulkan bahwa tidak ada yang berubah </li></ul><br>  Kemungkinan solusi untuk masalah ini: <br><br><ol><li>  Yang paling sederhana dan paling jelas adalah menggunakan kunci.  Ini akan menghasilkan algoritma thread-safe yang biasa dengan bagian kritis.  Tapi itu akan berhenti menjadi bebas dari kunci.  Tetapi jika datang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAS</a> dan <i>ABA</i> , maka ini kemungkinan besar bukan pilihan. </li><li>  Tambahkan label khusus ke nilai yang dibandingkan.  Misalnya, penghitung jumlah perubahan.  Di satu sisi, penghitung ini mungkin meluap, tetapi di sisi lain, prosesor x86_64 modern mendukung operasi <i>CAS</i> 128-bit.  Yaitu  ketika membandingkan pointer ke penghitung, Anda dapat memberikan hingga 64 bit, dan seseorang memperkirakan bahwa ini cukup untuk operasi algoritma yang berkelanjutan selama 10 tahun. </li><li>  Beberapa arsitektur (ARM, misalnya) menyediakan instruksi LL / SC (load linked, store conditional) yang tidak hanya memungkinkan Anda untuk mendapatkan nilai alamat saat ini dalam memori, tetapi juga untuk memahami apakah nilai ini telah berubah sejak pembacaan terakhir. </li></ol><br>  Untuk menggunakan struktur data seperti tumpukan, daftar, atau antrian, yang bebas dari penguncian, secara umum, di mana ada risiko tetap dengan pointer menggantung ke node jarak jauh, ada seluruh keluarga solusi untuk masalah <i>ABA</i> berdasarkan pada penghapusan node yang ditangguhkan.  Ini termasuk pengumpul sampah, penunjuk bahaya dan mekanisme baca-modifikasi-tulis (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RCU</a> ). <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga (Inggris)</a> <br><br><h3>  FAA <a name="FAA"></a></h3><br>  <i>Ambil dan Tambah.</i>  <i>Ahem ... dapatkan dan tambahkan (sepertinya konsep ini tidak pernah diterjemahkan ke dalam bahasa Rusia).</i>  Operasi atom dengan dua argumen: variabel atom atau alamat di memori, dan nilai yang harus diubah oleh variabel ini.  Jika arsitektur memungkinkan, operasi mengembalikan nilai sebelumnya dari variabel yang diubah (x86 memungkinkan sejak i486).  Tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAS</a> , <i>FAA</i> selalu berhasil. <br><br><div class="spoiler">  <b class="spoiler_title">Kode palsu</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">faa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> diff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = *addr; *addr = value + diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> </div></div><br>  Dalam C ++, ini diimplementasikan sebagai keluarga metode <code>std::atomic&lt;T&gt;::fetch_add</code> , <code>fetch_sub</code> , <code>fetch_and</code> , <code>fetch_or</code> , <code>fetch_xor</code> dan fungsi bebas yang sesuai <code>std::atomic_fetch_add</code> , dll. <br><br>  Sesuai instruksi atom, <i>FAA</i> digunakan dalam implementasi primitif sinkronisasi dan algoritma kunci-bebas dan struktur data. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekali (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> <br><br><h3>  RCU <a name="RCU"></a></h3><br>  <i>Baca-Salin-Perbarui.</i>  <i>Baca-modifikasi-tulis.</i>  Ini adalah mekanisme non-pemblokiran untuk menyinkronkan akses ke struktur data (tentu saja bebas-penguncian).  Ini digunakan dalam kasus di mana kecepatan membaca sangat penting.  Ini adalah contoh dari tradeoff waktu dan memori (space-time tradeoff). <br><br>  Gagasan <i>RCU</i> adalah bahwa aliran penulis tidak mengubah data di tempat, tetapi membuat salinan, membuat perubahan yang diperlukan di dalamnya dan secara atomis menukar data saat ini dan salinan yang diubah.  Pada saat yang sama, utas pembaca terus-menerus memiliki akses ke data - lama atau baru, siapa pun yang punya waktu.  Ketika tidak ada pembaca yang tersisa bekerja dengan versi yang sudah ketinggalan zaman, penulis menghapus data yang tidak lagi diperlukan, membebaskan memori. <br><br>  RCU yang sangat disederhanakan berfungsi seperti ini: <br><br><ul><li>  Banyak pembaca, satu penulis. </li><li>  Membaca dan mengubah terjadi secara bersamaan. </li><li>  Pembaca menggunakan sinkronisasi yang sangat ringan.  Bahkan, pembaca hanya perlu memberi tahu penulis pada saat memasuki bagian kritis dan pada saat meninggalkannya.  Bekerja dengan data yang disinkronkan hanya terjadi di bagian kritis. </li><li>  Penulis, segera setelah secara atomik mengganti data dengan salinan, mengumumkan permulaan dari apa yang disebut periode rahmat (grace period).  Masa tenggang berakhir ketika semua pembaca yang berada di bagian kritis pada awal periode ini meninggalkan bagian kritis mereka.  Sekarang penulis dapat dengan aman menghapus data yang sudah usang.  Tersirat bahwa semua bagian kritis terbatas, yang menjamin terbatasnya masa tenggang. </li></ul><br>  <i>RCU sangat</i> bagus untuk data yang sering dibaca dan jarang diperbarui.  Mekanisme ini secara aktif digunakan dalam kernel Linux, di mana cukup mudah untuk menentukan kapan masa tenggang berakhir. <br><br>  Kekurangan: <br><br><ul><li>  Buruk untuk menyinkronkan akses ke data yang sering diubah. </li><li>  Sulit diimplementasikan di ruang pengguna. </li><li>  Tergantung pada kemampuan untuk mengubah pointer secara atom ke alamat dalam memori, tetapi tidak semua arsitektur menyediakan kemampuan ini. </li></ul><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekali (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> <br><br><h2>  Penyimpanan data <a name="Storage"></a></h2><br><h3>  ASAM <a name="ACID"></a></h3><br>  <i>Atomicity, Konsistensi, Isolasi, Daya Tahan.</i>  <i>Atomicity, konsistensi, isolasi, daya tahan.</i>  Ini adalah seperangkat persyaratan transaksi dalam DBMS.  <i>ACID</i> menyediakan operasi DBMS yang andal dan dapat diprediksi bahkan jika terjadi kesalahan. <br><br><ul><li>  <b>Atomicity</b> memastikan bahwa transaksi selesai atau tidak melakukan apa-apa.  Keadaan perantara tidak mungkin, tidak akan seperti satu operasi transaksi berhasil, dan yang lainnya tidak.  Semua atau tidak sama sekali. </li><li>  <b>Konsistensi</b> memastikan bahwa semua data dalam database memenuhi semua aturan dan batasan yang ditentukan baik sebelum dimulainya transaksi dan setelah penyelesaiannya.  Selama pelaksanaan transaksi, konsistensi dapat dilanggar. </li><li>  <b>Isolasi</b> memastikan transaksi bersamaan tidak saling mempengaruhi.  Tidak ada transaksi yang memiliki akses ke data tidak konsisten yang diproses oleh transaksi lain. </li><li>  <b>Daya tahan</b> berarti bahwa hasil transaksi yang berhasil disimpan dalam database dan tidak dapat hilang, tidak peduli apa yang terjadi pada database segera setelah transaksi selesai. </li></ul><br>  Semua DBMS relasional utama sepenuhnya mendukung <i>ACID</i> .  Di dunia NoSQL, dukungan penuh seperti itu kemungkinan besar merupakan pengecualian. <br><br>  Baca lebih lanjut: satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kali (bahasa Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (bahasa Inggris)</a> <br><br><h3>  Cap <a name="CAP"></a></h3><br>  <i>Teorema CAP.</i>  <i>Teorema CAP.</i>  Teorema menyatakan bahwa setiap sistem terdistribusi dapat memiliki tidak lebih dari dua properti dari daftar: konsistensi data ( <b>Konsistensi</b> ), ketersediaan ( <b>Ketersediaan</b> ), ketahanan terhadap pemisahan ( <b>Toleransi partisi</b> ). <br><br><ul><li>  <b>Konsistensi</b> dalam hal ini berarti konsistensi konsisten (disederhanakan).  Yaitu  segera setelah operasi pembaruan data pada satu node selesai dengan sukses, semua node lain sudah memiliki data yang diperbarui ini.  Dengan demikian, semua node dalam keadaan konsisten.  Ini bukan konsistensi yang disyaratkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID</a> . </li><li>  <b>Ketersediaan</b> berarti bahwa setiap simpul yang gagal mengembalikan jawaban yang benar untuk setiap permintaan (baik untuk membaca dan menulis) dalam jumlah waktu yang wajar.  Tidak ada jaminan bahwa tanggapan dari node yang berbeda cocok. </li><li>  <b>Perlawanan terhadap pemisahan</b> berarti bahwa sistem akan terus bekerja dengan benar jika terjadi kehilangan jumlah pesan yang sewenang-wenang di antara simpul-simpulnya. </li></ul><br>  Karena  ketiga sifat tidak dapat dicapai, dari sudut pandang teorema <i>CAP</i> , semua sistem terdistribusi jatuh ke dalam tiga kelas: <b>CA</b> , <b>CP,</b> dan <b>AP</b> .  Sistem <b>CA</b> jelas tidak memiliki resistensi pemisahan.  Karena  dalam sebagian besar kasus, distribusi menyiratkan distribusi melalui jaringan nyata, dan dalam jaringan nyata selalu ada probabilitas nol untuk kehilangan suatu paket, maka sistem <b>CA</b> kurang menarik. <br><br>  Pilihannya adalah antara <b>CP</b> dan <b>AP</b> , yaitu antara konsistensi dan ketersediaan.  DBMS relasional tradisional yang mengikuti prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID</a> lebih memilih konsistensi.  Sementara banyak solusi NoSQL memilih aksesibilitas dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BASE</a> . <br><br>  Dalam kasus operasi normal jaringan, yaitu, ketika tidak ada pemisahan jaringan, teorema <i>CAP</i> tidak memaksakan pembatasan pada konsistensi dan ketersediaan.  Yaitu  menyumbangkan sesuatu tidak perlu. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga (Inggris)</a> <br><br><h3>  Pacelc <a name="PACELC"></a></h3><br>  <i>Teorema PACELC.</i>  <i>Teorema PACELC.</i>  Ini adalah perpanjangan dari teorema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAP</a> , yang menyatakan bahwa sistem terdistribusi dalam kasus <b>Pemisahan</b> terpaksa memilih antara <b>Ketersediaan</b> dan <b>Konsistensi</b> , dan dalam kasus operasi jaringan normal ( <b>Lain</b> ), Anda harus memilih antara <b>Latensi</b> dan <b>Konsistensi</b> ) <br><br>  Dengan demikian, jika teorema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAP</a> membedakan 2 kelas sistem yang stabil dengan pemisahan jaringan, maka <i>PACELC memiliki</i> 4 di antaranya: <b>PA / EL</b> , <b>PA / EC</b> , <b>PC / EL</b> dan <b>PC / EC</b> .  Beberapa database NoSQL dapat mengubah kelas mereka tergantung pada pengaturan. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekali (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> <br><br><h3>  DASAR <a name="BASE"></a></h3><br>  <i>Pada dasarnya Tersedia, Status lunak, Konsistensi akhirnya.</i>  <i>Ketersediaan dasar, kondisi rapuh, konsistensi dalam jangka panjang.</i>  Menurut teorema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAP</a> dalam sistem terdistribusi, sesuatu harus ditinggalkan.  Koherensi yang ketat biasanya ditinggalkan demi koherensi dalam jangka panjang.  Yang berarti bahwa dengan tidak adanya perubahan data, suatu hari sistem akan pada akhirnya mencapai kondisi yang konsisten. <br><br>  Untuk menunjukkan kompromi seperti itu, <i>BASE</i> singkatan mulai digunakan agak <i>erat</i> , dan permainan istilah kimia ternyata ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID</a> - keasaman, <i>BASE</i> - kebasaan). <br><br><ul><li>  <b>Pada dasarnya Tersedia</b> berarti bahwa sistem menjamin ketersediaan data, itu menanggapi setiap permintaan.  Tetapi jawabannya mungkin data yang lama atau tidak konsisten (atau tidak ada) </li><li>  <b>Status lunak</b> berarti keadaan sistem dapat berubah seiring waktu meskipun tidak ada permintaan untuk perubahan data.  Karena pada titik waktu mana pun, data dapat dibawa ke keadaan konsisten. </li><li>  <b>Konsistensi akhirnya</b> berarti bahwa jika data berhenti berubah, mereka tentu saja akan berakhir dalam keadaan yang konsisten.  Yaitu  permintaan yang sama untuk node yang berbeda akan menghasilkan jawaban yang sama. </li></ul><br>  Baca lebih lanjut: satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kali (bahasa Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (bahasa Inggris)</a> <br><br><h2>  Prinsip Pengembangan Perangkat Lunak <a name="Principles"></a></h2><br><h3>  KERING <a name="DRY"></a></h3><br>  <i>Jangan Ulangi Diri Anda Sendiri.</i>  <i>Jangan diulang.</i>  Ini adalah prinsip pengembangan perangkat lunak, ide utamanya adalah untuk mengurangi jumlah informasi yang digandakan dalam sistem, dan tujuannya adalah untuk mengurangi kompleksitas sistem dan meningkatkan pengelolaannya. <br><br>  Dalam buku aslinya ( <i>The Pragmatic Programmer</i> book, oleh <i>Andrew Hunt</i> dan <i>David Thomas</i> ), prinsip ini dirumuskan sebagai berikut: "Setiap pengetahuan harus memiliki representasi tunggal, konsisten, dan otoritatif dalam sistem."  Dalam hal ini, pengetahuan dipahami sebagai bagian dari area subjek atau algoritma: kode, skema database, protokol interaksi tertentu, dll. Dengan demikian, untuk membuat satu perubahan pada sistem, hanya satu "pengetahuan" yang perlu diperbarui di satu tempat. <br><br>  Contoh bodoh: klien dan server mengirimkan data terstruktur satu sama lain.  Karena  ini adalah aplikasi yang berbeda yang berjalan pada mesin yang berbeda, maka mereka berdua harus memiliki implementasi sendiri dari struktur ini.  Jika sesuatu berubah, perubahan harus dilakukan di dua tempat.  Langkah yang jelas untuk menghindari pengulangan ini adalah mengalokasikan kode umum ke pustaka yang terpisah.  Langkah selanjutnya adalah membuatnya sesuai dengan deskripsi struktur (Google Protokol Buffer, misalnya), agar tidak menulis jenis kode yang sama untuk mengakses bidang struktur. <br><br>  Duplikasi kode hanyalah kasus khusus pelanggaran <i>KERING</i> .  Dan itu tidak selalu terjadi.  Jika dua potong kode terlihat sama, tetapi masing-masing menerapkan logika bisnis mereka sendiri, <i>KERING</i> tidak rusak. <br><br>  Seperti prinsip lainnya, <i>KERING</i> adalah alat, bukan dogma.  Semakin besar sistem, semakin mudah melanggar prinsip ini.  Pertama, cita-cita itu tidak mungkin tercapai.  Dan kedua, jika secara membabi buta mengikuti <i>KERING</i> mengarah ke kode yang lebih rumit dan membuatnya lebih sulit untuk dipahami, maka lebih baik untuk meninggalkannya. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Rusia)</a> <br><br><h3>  CIUMAN <a name="KISS"></a></h3><br>  <i>Tetap Sederhana, Bodoh.</i>  <i>Buat lebih mudah (bodoh dalam hal ini bukan panggilan).</i>  Ini adalah prinsip desain yang sebagian besar sistem bekerja lebih baik jika tetap sederhana.  Prinsipnya berasal dari industri pesawat terbang dan banyak diterapkan di mana, termasuk dalam pengembangan perangkat lunak. <br><br>  Dalam kasus terakhir, <i>KISS</i> berguna baik dalam mendesain dan menulis kode secara langsung.  Arsitektur dan kode sederhana tidak hanya lebih mudah dipahami, tetapi juga lebih mudah digunakan, dipelihara, dan dikembangkan.  MapReduce tidak boleh dibodohi jika pasangan produsen-konsumen sudah cukup.  Keajaiban metaprogramming sangat rumit jika Anda dapat melakukannya dengan beberapa fungsi biasa dan mencapai tingkat kinerja yang diperlukan. <br><br>  Dengan semua ini, orang tidak boleh lupa bahwa kesederhanaan bukanlah tujuan, tetapi hanya persyaratan non-fungsional.  Hal utama adalah untuk mencapai tujuan desain / implementasi, dan disarankan untuk melakukan ini dengan cara sesederhana mungkin. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga (Inggris)</a> <br><br><h3>  YAGNI <a name="YAGNI"></a></h3><br>  <i>Anda Tidak Akan Membutuhkannya.</i>  <i>Anda tidak membutuhkannya.</i>  Ini adalah prinsip pengembangan perangkat lunak, gagasan utamanya adalah penolakan fungsi yang berlebihan, dan tujuannya adalah untuk menghemat sumber daya yang dihabiskan untuk pengembangan. <br><br>  <i>YAGNI</i> mengatakan bahwa Anda tidak perlu merancang atau mengimplementasikan fungsi yang tidak dibutuhkan saat ini.  Bahkan jika Anda yakin mereka akan dibutuhkan di masa depan.  Tidak perlu menambahkan abstraksi yang tidak perlu, manfaatnya akan muncul beberapa saat kemudian. <br><br>  Masalahnya adalah orang tidak memprediksi masa depan dengan baik.  Oleh karena itu, kemungkinan besar semua yang dilakukan "cadangan" tidak akan berguna.  Dan ternyata waktu dan uang yang dihabiskan untuk pengembangan, pengujian, dan dokumentasi seperti itu terbuang sia-sia.  Plus, perangkat lunak menjadi lebih rumit, sumber daya tambahan harus dihabiskan untuk mendukungnya lagi.  Lebih buruk lagi, ketika ternyata perlu dilakukan secara berbeda.  Uang dan waktu akan dihabiskan juga untuk koreksi. <br><br>  Prinsip <i>YAGNI agak</i> lebih radikal daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KERING</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CIUMAN</a> .  Jika mereka memecah sistem menjadi bagian-bagian yang dapat dipahami dan membuat keputusan sederhana, maka <i>YAGNI</i> hanya memotong bagian dan solusi yang tidak perlu. <br><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga (Inggris)</a> <br><br><h3>  Nih <a name="NIH"></a></h3><br>  <i>Tidak Diciptakan Di Sini.</i>  <i>Tidak ditemukan di sini.</i>  Ini adalah sindrom penolakan terhadap perkembangan orang lain, suatu posisi yang secara praktis berbatasan dengan penemuan sepeda.  Seringkali, sindrom disertai dengan keyakinan bahwa menciptakan teknologi di dalam perusahaan akan lebih cepat dan lebih murah, dan teknologi itu sendiri akan lebih memenuhi kebutuhan perusahaan.  Namun, dalam kebanyakan kasus ini bukan itu masalahnya, dan <i>NIH</i> adalah anti-pola. <br><br>  Berikut adalah beberapa kasus yang membenarkan <i>NIH</i> : <br><br><ul><li>  Kualitas solusi pihak ketiga tidak cukup tinggi, atau harganya tidak cukup rendah. </li><li>  Solusi pihak ketiga memiliki batasan lisensi. </li><li>  Menggunakan solusi pihak ketiga menciptakan ketergantungan pada pemasoknya dan dengan demikian mengancam bisnis. </li></ul><br>  Baca lebih lanjut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu (Rusia)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga (Inggris)</a> <br><br><h3>  Ftse <a name="FTSE"></a></h3><br>  <i>Teorema Dasar Rekayasa Perangkat Lunak.</i>  <i>Teorema dasar pengembangan perangkat lunak.</i>  Sebenarnya, ini bukan teorema, tidak punya bukti.  Ini adalah perkataan terkenal oleh Andrew Koenig: <br><blockquote>  Masalah apa pun dapat diselesaikan dengan menambahkan lapisan abstraksi lainnya. </blockquote>  Terkadang mereka menambah frasa ini "... kecuali untuk masalah terlalu banyak lapisan abstraksi."  Secara umum, "teorema" bukanlah hal yang serius, tetapi perlu diketahui tentang hal itu. <br><br>  Baca lebih lanjut: satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kali (bahasa Inggris)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua (bahasa Inggris)</a> <br><br><h3>  GRASP <a name="GRASP"></a></h3><br>  <i>Pola Perangkat Lunak Penugasan Tanggung Jawab Umum.</i>  <i>Template alokasi tanggung jawab umum.</i>  Sembilan pola ini dirumuskan dalam <i>Menerapkan UML dan Pola</i> oleh <i>Craig Larman</i> .  Setiap template adalah solusi khas untuk satu (tetapi lebih umum) masalah desain perangkat lunak. <br><br><ol><li>  <i>Ahli Informasi</i> .  Masalah: apa prinsip umum pembagian tanggung jawab antara objek?  Keputusan: memberikan tugas kepada seseorang yang memiliki informasi yang diperlukan untuk memenuhi kewajiban ini. </li><li>  <b>Pencipta</b>  Masalah: siapa yang harus bertanggung jawab untuk membuat objek baru?  Solusi: kelas B harus membuat instance kelas A jika satu atau lebih kondisi berikut ini benar: <br>  - kelas B agregat atau berisi instance A <br>  - B menulis A <br>  - B aktif menggunakan A <br>  - B memiliki data inisialisasi A </li><li>  <i>Kopling rendah</i>  Masalah: bagaimana cara mengurangi dampak perubahan?  Bagaimana cara meningkatkan kemungkinan penggunaan kembali?  Solusi: sebarkan tanggung jawab sehingga konektivitas rendah.  Kopling adalah ukuran seberapa kaku elemen-elemen terhubung, seberapa besar mereka bergantung satu sama lain.  Yaitu  Disarankan untuk menghubungkan objek sehingga mereka tahu tentang satu sama lain hanya minimum yang diperlukan. </li><li>  <b>Gearing tinggi</b> ( <i>Kohesi Tinggi</i> ).  Masalah: Bagaimana cara saya mengelola kompleksitas?  Solusi: sebarkan tanggung jawab agar keterlibatan tinggi tetap terjaga.  Keterlibatan tinggi berarti bahwa tanggung jawab satu elemen difokuskan pada satu bidang. </li><li>  <b>Pengendali</b>  Masalah: siapa yang harus bertanggung jawab untuk menangani acara masukan?  Solusi: tentukan kelas sebagai penanggung jawab, yang mewakili seluruh sistem atau subsistem sebagai keseluruhan (pengontrol eksternal), atau satu skrip khusus (skrip atau pengontrol sesi).  Pada saat yang sama, pengontrol tidak menerapkan reaksi terhadap peristiwa, melainkan mendelegasikan ini ke pelaksana yang relevan. </li><li>  <b>Polimorfisme</b> ( <i>Polimorfisme</i> ).  Masalah: bagaimana cara menangani berbagai perilaku berdasarkan jenis? :     ,   ,     ,       . </li><li> <b> </b> ( <i>Pure Fabrication</i> ). :       ,    ? :  ,              . </li><li> <b></b> ( <i>Indirection</i> ). :   ,        <i>Low Coupling</i> ? :          . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resistensi terhadap perubahan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variasi yang Dilindungi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Masalah: bagaimana merancang objek dan subsistem sehingga perubahan di dalamnya tidak memiliki efek yang tidak diinginkan pada elemen lain? </font><font style="vertical-align: inherit;">Solusi: temukan kemungkinan titik ketidakstabilan dan buat antarmuka yang stabil di sekitarnya, berkomunikasi hanya melalui antarmuka semacam itu.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GRASP secara</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konstan berpotongan dengan pola Gang Four dan prinsip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini normal, karena mereka semua memecahkan masalah umum - untuk menyederhanakan pembuatan perangkat lunak berkualitas tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lebih lanjut: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu (Rusia)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiga (Rusia)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PADAT </font></font><a name="SOLID"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip-prinsip SOLID. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah lima prinsip pemrograman dan desain berorientasi objek (singkatannya dibuat dari huruf pertama namanya). </font><font style="vertical-align: inherit;">Mendapatkan ketenaran berkat Robert Martin pada awal 2000-an. </font><font style="vertical-align: inherit;">Tujuan utama dari prinsip-prinsip ini adalah menciptakan perangkat lunak yang mudah dipahami, dipelihara, dan dikembangkan.</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip tanggung jawab tunggal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">single Prinsip Tanggung Jawab, SRP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Kelas atau modul seharusnya hanya memiliki satu tanggung jawab. </font><font style="vertical-align: inherit;">"Lakukan hanya satu hal, tetapi lakukan dengan baik."</font></font></li><li> <b> /</b> ( <i>Open Closed Principle, OCP</i> ).   (, , )     ,    .  :      ,              . </li><li> <b>   </b> ( <i>Liskov Substitution Principle, LSP</i> ).          ,       .  Yaitu  -        . </li><li> <b>  </b> ( <i>Interface Segregation Principle, ISP</i> ).    ,   .      ,    .  ,  ,          .             ,  . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketergantungan Inversi Prinsip</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari ketergantungan Pembalikan Prinsip, DIP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Modul tingkat atas tidak harus bergantung pada modul tingkat bawah. </font><font style="vertical-align: inherit;">Semua modul harus bergantung pada abstraksi. </font><font style="vertical-align: inherit;">Abstraksi tidak harus bergantung pada detail. </font><font style="vertical-align: inherit;">Rinciannya harus bergantung pada abstraksi. </font><font style="vertical-align: inherit;">Sebagai contoh, baik antarmuka maupun kelas konkret tidak boleh mengandung atau menerima kelas konkret lainnya sebagai argumen dari metode mereka, tetapi hanya antarmuka (dalam arti Java dan C #).</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lebih lanjut: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu (Rusia)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiga (Inggris)</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lainnya </font></font><a name="Misc"></a></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abi </font></font><a name="ABI"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka Biner Aplikasi. Antarmuka aplikasi biner.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah seperangkat konvensi yang mendefinisikan interaksi modul biner (file yang dapat dieksekusi, perpustakaan, OS). Dua modul harus dibuat sesuai dengan satu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ini adalah prasyarat untuk kompatibilitas biner mereka, dalam hal ini mereka dapat berinteraksi tanpa masalah (misalnya, file yang dapat dieksekusi dihubungkan ke perpustakaan dan dieksekusi oleh sistem operasi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah format file yang dapat dieksekusi ELF di Linux dan PE pada Windows. Setiap OS mengharapkan bahwa data yang diperlukan (sumber daya, titik masuk, dll.) Terletak di file biner sesuai dengan format yang sesuai. Jelas, ELF dan PE berbeda, karena program Linux tidak berjalan langsung di Windows dan sebaliknya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tingkat library dan executable, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat menentukan penempatan bidang dalam suatu kelas, kelas dasar dalam turunan, mekanisme untuk mengimplementasikan fungsi virtual, format frame panggilan stack, aturan untuk meneruskan argumen ke fungsi yang dipanggil, dll., Dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ tidak memiliki satu pun </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standar </font><font style="vertical-align: inherit;">, yang tidak mengherankan, karena itu tergantung pada arsitektur dan OS. Sebagai contoh, kompiler C ++ untuk banyak sistem operasi mirip Unix (Linux, FreeBSD, MacOS) pada x86_64 ikuti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System V AMD64 ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pada ARM - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM C ++ ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Visual C ++ ABI tidak dipublikasikan secara resmi, tetapi setidaknya sebagian direkayasa ulang. Sangat berbeda dari System V ABI, mereka memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aturan yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama sekali berbeda </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">untuk menyembunyikan nama</font></a><font style="vertical-align: inherit;"> (mangling) dan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meneruskan argumen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke fungsi yang dipanggil (Linux menggunakan 6 register, Windows menggunakan 4 register), dan banyak perbedaan lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan jika API dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tetap sama, dan hanya detail implementasi yang berubah, kompatibilitas biner mungkin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rusak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Misalnya, dalam C ++ 11, ada persyaratan untuk string untuk menyimpan karakter secara berurutan (seperti dalam vektor). </font><font style="vertical-align: inherit;">Karena itu, GCC 5 harus mengubah implementasi string ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan sebelumnya </font><font style="vertical-align: inherit;">), yang menyebabkan ketidakcocokan biner. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lebih lanjut: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekali (Rusia)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan semua tautan dari dua paragraf sebelumnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sapi </font></font><a name="COW"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salin Saat Menulis. </font><font style="vertical-align: inherit;">Salin saat merekam. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah mekanisme manajemen sumber daya, juga dikenal sebagai berbagi implisit dan salinan malas. </font><font style="vertical-align: inherit;">Idenya adalah bahwa ketika salinan diperlukan, sumber daya tidak benar-benar disalin, tetapi tautan ke sana dibuat. </font><font style="vertical-align: inherit;">Dan hanya ketika ada permintaan untuk perubahan - dalam aslinya atau di "copy" - hanya pada saat pembuatan salinan lengkap terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jelas: menyalin objek apa pun terjadi secara instan. </font><font style="vertical-align: inherit;">Jika objek sering disalin tetapi jarang berubah, peningkatan kinerja bisa signifikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh penggunaan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen memori proses virtual di Linux. </font><font style="vertical-align: inherit;">Ketika </font></font><code>fork()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman </font><font style="vertical-align: inherit;">dipanggil </font><font style="vertical-align: inherit;">, memori proses tidak disalin, tetapi hanya ditandai sebagai dibagikan.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Snapshots di beberapa sistem file (Btrfs, ZFS) dan database (MS SQL Server). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum C ++ 11, beberapa implementasi </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam C ++ 11, persyaratan untuk </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telah berubah (lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak jenis dalam Qt menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lebih lanjut: satu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kali (bahasa Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (bahasa Inggris)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FBC, FBCP </font></font><a name="FBC"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas Dasar Rapuh (Masalah). </font><font style="vertical-align: inherit;">Masalah kelas dasar yang rapuh. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah masalah OOP mendasar, intinya adalah bahwa perubahan kelas dasar yang benar dapat menyebabkan kesalahan pada salah satu ahli waris.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, untuk rekursi yang tak terbatas</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } virtual void method2() { // ... method1(); // &lt;--      } }; struct Derived : Base { void method1() override { method2(); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat memecahkan masalah FBC hanya dengan meninggalkan pewarisan yang mendukung komposisi, misalnya, atau memperluas antarmuka dalam terminologi Java (dalam C ++, ini akan mewarisi hanya untuk kelas dasar abstrak tanpa implementasi negara dan metode). </font><font style="vertical-align: inherit;">Dalam kasus lain, Anda hanya dapat mencoba meminimalkan kemungkinan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBCP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan tips berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Larang pewarisan atau pendefinisian ulang di tempat yang tidak diperlukan (kata kunci </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam C ++ dan Java).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahli waris tidak boleh memiliki akses ke interior kelas dasar, komunikasi hanya dapat melalui antarmuka publik. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metode pewaris hanya dapat memanggil metode virtual yang dipanggil dalam metode redefined dari kelas dasar, dan metode redefined itu sendiri. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lebih lanjut: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiga (Inggris)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LRU </font></font><a name="LRU"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paling Baru Digunakan. </font><font style="vertical-align: inherit;">Ekstrusi sudah lama tidak digunakan. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah salah satu algoritma caching (mereka juga kebijakan preemptive). </font><font style="vertical-align: inherit;">Secara umum, cache dapat dianggap sebagai penyimpanan cepat pasangan nilai kunci, salah satu karakteristik utamanya adalah rasio hit. </font><font style="vertical-align: inherit;">Semakin tinggi level ini, semakin sering nilai yang diinginkan ada di cache cepat dan semakin jarang itu harus dicari dalam penyimpanan lambat. </font><font style="vertical-align: inherit;">Tetapi karena memori tidak pernah kenyal, ukuran cache harus dibatasi. </font><font style="vertical-align: inherit;">Tugas algoritma caching adalah menentukan elemen mana yang harus dibuang dari cache yang diisi, jika perlu, untuk memaksimalkan tingkat hit. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LRU</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggantikan elemen cache mereka, yang tidak ada yang mengakses paling lama. </font><font style="vertical-align: inherit;">Ini mungkin adalah algoritma caching yang paling terkenal. </font><font style="vertical-align: inherit;">Mungkin karena kombinasi efisiensi dan kesederhanaan. </font><font style="vertical-align: inherit;">Konsumsi memori </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LRU</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah O (n), waktu akses rata-rata ke nilai adalah O (1), waktu rata-rata untuk menambahkan elemen juga O (1). </font><font style="vertical-align: inherit;">Untuk implementasi, tabel hash dan daftar tertaut ganda biasanya digunakan.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya saja</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LRU</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Queue = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;K, V&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Iterator = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Queue::iterator; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Hash = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;K, Iterator&gt;; Queue queue_; Hash hash_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> limit_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LRU(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> limit) : limit_(limit) { } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;V&gt; get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K&amp; key) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = hash_.find(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it == hash_.end()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; } it-&gt;second = reorder(it-&gt;second); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { it-&gt;second-&gt;second }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K&amp;&amp; key, V&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash_.size() &gt;= limit_) { pop(); } queue_.emplace_front(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(value)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = queue_.begin(); hash_[it-&gt;first] = it; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">Iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reorder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterator it)</span></span></span><span class="hljs-function"> </span></span>{ queue_.emplace_front(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(it-&gt;first), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(it-&gt;second)); queue_.erase(it); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue_.begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hash_.erase(queue_.back().first); queue_.pop_back(); } };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelemahan yang jelas dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LRU</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah konsumsi memori yang tinggi, karena menggunakan dua struktur elemen n masing-masing. </font><font style="vertical-align: inherit;">Selain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LRU,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada banyak algoritma caching lainnya untuk berbagai kasus: MRU (Paling Baru Digunakan), LFU (Paling Sering Digunakan), LRU Tersegmentasi, 2Q, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca lagi: satu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kali (Inggris)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua (Rusia)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiga</font></font></a> <br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika saya melewatkan sesuatu atau keliru di suatu tempat - tulis di komentar. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470317/">https://habr.com/ru/post/id470317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470303/index.html">Instal server tftp pada CentOS 8 atau RedHat 8</a></li>
<li><a href="../id470305/index.html">Mempersiapkan Sertifikasi Spring Profesional. Wadah, IOC, Kacang</a></li>
<li><a href="../id470309/index.html">Xamarin.Forms Shell</a></li>
<li><a href="../id470311/index.html">Mainan Kayu, Bagian Tujuh - 1993</a></li>
<li><a href="../id470313/index.html">Mainan Kayu, Bagian Delapan - 1994</a></li>
<li><a href="../id470321/index.html">Mainan Kayu, Bagian Sembilan - 1995</a></li>
<li><a href="../id470327/index.html">Aplikasi MATLAB / Simulink dengan peralatan yang diproduksi oleh InSys JSC</a></li>
<li><a href="../id470331/index.html">Bagaimana cara mengidentifikasi log ISI, Scopus, atau Scimago yang diindeks?</a></li>
<li><a href="../id470333/index.html">Kriteria Programmer, Manajer, MVC dan Penerimaan</a></li>
<li><a href="../id470337/index.html">Bagaimana saya bekerja selama 3 bulan di Y. Market dan berhenti</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>