<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÅ üë©üèø‚Äçüîß üó≥Ô∏è Dezenas de truques com shell Linux, o que poderia economizar seu tempo üí§ üï∑Ô∏è üöµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Primeiro de tudo, voc√™ pode ler este artigo em russo aqui . 
 Uma noite, eu estava lendo Mastering express√µes regulares de Jeffrey Friedl , percebi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dezenas de truques com shell Linux, o que poderia economizar seu tempo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>Primeiro de tudo, voc√™ pode ler este artigo em russo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</i> </li></ul><br>  Uma noite, eu estava lendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mastering express√µes regulares de Jeffrey Friedl</a> , percebi que, mesmo que voc√™ tenha toda a documenta√ß√£o e muita experi√™ncia, poderia haver muitos truques desenvolvidos por pessoas diferentes e aprisionados por eles mesmos.  Todas as pessoas s√£o diferentes.  E t√©cnicas que s√£o √≥bvias para certas pessoas podem n√£o ser √≥bvias para outras pessoas e parecer algum tipo de m√°gica estranha para terceira pessoa.  A prop√≥sito, eu j√° descrevi v√°rios momentos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui (em russo)</a> . <br><br>  Para o administrador ou o usu√°rio, a linha de comando n√£o √© apenas uma ferramenta que pode fazer tudo, mas tamb√©m uma ferramenta altamente personalizada que pode ser desenvolvida para sempre.  Recentemente, houve um artigo traduzido sobre alguns truques √∫teis na CLI.  Mas acho que o tradutor n√£o tem experi√™ncia suficiente com a CLI e n√£o seguiu os truques descritos; portanto, muitas coisas importantes podem ser perdidas ou mal interpretadas. <br><br>  Sob o corte - uma d√∫zia de truques no shell Linux da minha experi√™ncia pessoal. <br><a name="habracut"></a><br>  Nota: Todos os scripts e exemplos do artigo foram especialmente simplificados o m√°ximo poss√≠vel - portanto, talvez voc√™ consiga achar v√°rios truques completamente in√∫teis - talvez seja esse o motivo.  Mas, de qualquer forma, compartilhe suas opini√µes nos coment√°rios! <br><br><h4>  1. String dividida com expans√µes vari√°veis </h4><br>  As pessoas costumam usar <b>recortar</b> ou at√© <b>awk</b> apenas para subtrair uma parte da corda por padr√£o ou com separadores. <br>  Al√©m disso, muitas pessoas usam a opera√ß√£o de substring bash usando $ {VARIABLE: start_position: length}, que funciona muito r√°pido. <br><br>  Mas o bash fornece uma maneira poderosa de manipular as strings de texto usando #, ##,% e %% - ele √© chamado de <i>expans√µes de vari√°veis ‚Äã‚Äãdo bash</i> . <br>  Usando esta sintaxe, voc√™ pode cortar o necess√°rio pelo padr√£o sem executar comandos externos, para que ele funcione muito r√°pido. <br><br>  O exemplo abaixo mostra como obter a terceira coluna (shell) da string em que os valores s√£o separados por dois pontos "nome de usu√°rio: homedir: shell" usando <b>cut</b> ou usando expans√µes vari√°veis ‚Äã‚Äã(usamos o <u>*:</u> mask e o comando ##, que significa: cut todos os caracteres √† esquerda at√© os √∫ltimos dois pontos encontrados): <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br>  A segunda op√ß√£o n√£o inicia o processo filho ( <b>corte</b> ) e n√£o usa tubos, o que deve funcionar muito mais r√°pido.  E se voc√™ estiver usando o subsistema bash no Windows, onde os tubos mal se movem, a diferen√ßa de velocidade ser√° <u>significativa</u> . <br><br>  Vamos ver um exemplo no Ubuntu - execute nosso comando em um loop por 1000 vezes <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Resultados</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br>  A diferen√ßa √© v√°rias dezenas de vezes! <br><br>  Obviamente, o exemplo acima √© muito artificial.  No exemplo real, n√£o trabalharemos com uma string est√°tica, queremos ler um arquivo real.  E para o comando ' <b>cut</b> ', apenas redirecionamos / etc / passwd para ele.  No caso de ##, precisamos criar um loop e ler o arquivo usando o comando interno ' <b>read</b> '.  Ent√£o, quem vencer√° este caso? <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre>  Sem coment√°rios =) </div></div><br>  Mais alguns exemplos: <br><br>  Extraia o valor ap√≥s o caractere igual: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br>  Extrair texto entre colchetes: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Autocompletar bash com guia </h4><br>  O pacote bash-complete faz parte de quase todos os distribuidores Linux.  Voc√™ pode habilit√°-lo em /etc/bash.bashrc ou /etc/profile.d/bash_completion.sh, mas geralmente ele j√° est√° ativado por padr√£o.  Em geral, o preenchimento autom√°tico √© um dos primeiros momentos convenientes no shell do Linux que um novato encontra antes de tudo. <br><br>  Mas o fato de que nem todos usam todos os recursos de conclus√£o do bash e, na minha opini√£o, √© completamente in√∫til.  Por exemplo, nem todo mundo sabe que o preenchimento autom√°tico funciona n√£o apenas com nomes de arquivos, mas tamb√©m com aliases, nomes de vari√°veis, nomes de fun√ß√µes e, para alguns comandos, mesmo com argumentos.  Se voc√™ se interessar por scripts de preenchimento autom√°tico, que na verdade s√£o scripts de shell, pode at√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionar o preenchimento autom√°tico</a> para seu pr√≥prio aplicativo ou script. <br>  Mas vamos voltar aos pseud√¥nimos. <br><br>  Voc√™ n√£o precisa editar a vari√°vel PATH ou criar arquivos no diret√≥rio especificado para executar o alias.  Voc√™ s√≥ precisa adicion√°-los ao perfil ou script de inicializa√ß√£o e execut√°-los em qualquer lugar. <br><br>  Normalmente, estamos usando letras min√∫sculas para arquivos e diret√≥rios no * nix, portanto, pode ser muito confort√°vel criar aliases em mai√∫sculas - nesse caso, o bash-complete ir√° <s>adivinhar</s> seu comando quase com uma √∫nica letra: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3. Autocompletar bash com guia - parte 2 </h4><br>  Para casos mais complicados, provavelmente voc√™ gostaria de colocar seus scripts pessoais em $ HOME / bin. <br>  Mas temos fun√ß√µes no bash. <br><br>  As fun√ß√µes n√£o requerem caminho ou arquivos separados.  E a conclus√£o do bash (aten√ß√£o) tamb√©m funciona com fun√ß√µes. <br><br>  Vamos criar a fun√ß√£o LastLogin em <b>.profile</b> (n√£o esque√ßa de recarregar .profile): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>(Na verdade, n√£o √© importante o que essa fun√ß√£o est√° fazendo, √© apenas um script de exemplo que podemos colocar no script separado ou at√© no pseud√¥nimo, mas a fun√ß√£o poderia ser melhor)</i> . <br><br>  No console (observe que o nome da fun√ß√£o tem uma primeira letra mai√∫scula para acelerar a conclus√£o do bash): <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1  Dados sens√≠veis </h4><br>  Se voc√™ colocar espa√ßo antes de qualquer comando no console, ele n√£o aparecer√° no hist√≥rico de comandos; portanto, se voc√™ precisar colocar uma senha de texto sem formata√ß√£o no comando, √© uma boa maneira de usar esse recurso - veja o exemplo abaixo, <i>echo "hello 2 "</i> n√£o aparecer√° no hist√≥rico: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">√â opcional</b> <div class="spoiler_text">  Geralmente √© ativado por padr√£o, mas voc√™ pode configurar esse comportamento na seguinte vari√°vel: <br><br>  exportar HISTCONTROL = ignoreboth </div></div><br><br><h4>  4.2  Dados sens√≠veis nos argumentos da linha de comando </h4><br>  Voc√™ deseja armazenar alguns scripts de shell no git para compartilh√°-los entre servidores ou pode ser parte do script de inicializa√ß√£o do aplicativo.  E voc√™ deseja que esse script se conecte ao banco de dados ou fa√ßa qualquer outra coisa que exija credenciais. <br><br>  Obviamente, √© uma m√° id√©ia armazenar credenciais no pr√≥prio script, porque o git n√£o √© seguro. <br><br>  Geralmente voc√™ pode usar vari√°veis, que j√° foram definidas nos ambientes de destino, e seu script n√£o conter√° as senhas em si. <br><br>  Por exemplo, voc√™ pode criar um script pequeno em cada ambiente com 700 permiss√µes e cham√°-lo usando o comando <b>source</b> do script principal: <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br>  Mas n√£o √© seguro. <br><br>  Se algu√©m puder fazer login no seu host, ele poder√° executar o comando <b>ps</b> e ver seu processo sqlplus com todos os argumentos da linha de comando, incluindo senhas.  Portanto, ferramentas seguras geralmente devem poder ler senhas / chaves / dados confidenciais diretamente dos arquivos. <br><br>  Por exemplo - secure <b>ssh</b> simplesmente n√£o tem op√ß√µes para fornecer senha na linha de comando.  Mas ele pode ler a chave ssh no arquivo (e voc√™ pode definir permiss√µes seguras no arquivo de chave ssh). <br><br>  E o wget n√£o seguro tem a op√ß√£o "--password", que permite fornecer a senha na linha de comando.  E todo o tempo em que o wget estiver em execu√ß√£o, todos poder√£o executar o comando ps e ver a senha que voc√™ forneceu. <br><br>  Al√©m disso, se voc√™ possui muitos dados confidenciais e deseja control√°-los a partir do git, a √∫nica maneira √© a criptografia.  Assim, voc√™ coloca em cada ambiente de destino apenas a senha mestra e todos os outros dados que voc√™ pode criptografar e colocar no git.  E voc√™ pode trabalhar com dados criptografados na linha de comando, usando a interface CLI openssl.  Aqui est√° um exemplo para criptografar e descriptografar da linha de comando: <br><br>  O arquivo secret.key cont√©m a chave mestra - uma √∫nica linha: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br>  Vamos usar aes-256-cbc para criptografar uma string: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br>  Voc√™ pode colocar essa string criptografada em qualquer arquivo de configura√ß√£o armazenado no git ou em qualquer outro lugar - sem secret.key, √© quase imposs√≠vel descriptograf√°-lo. <br>  Para descriptografar, execute o mesmo comando, substitua -e por -d: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. O comando grep </h4><br>  Todos devem conhecer o comando grep.  E seja amig√°vel com express√µes regulares.  E muitas vezes voc√™ pode escrever algo como: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br>  Ou mesmo assim: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br>  Mas n√£o se esque√ßa que o grep tem muitas op√ß√µes maravilhosas.  Por exemplo -v, que reverte sua pesquisa e mostra todas as mensagens, exceto as "informa√ß√µes": <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br>  Material adicional: <br><br>  A op√ß√£o -P √© muito √∫til, porque, por padr√£o, o grep usa "express√£o regular b√°sica" bastante desatualizada: e -P ativa o PCRE, que nem conhece o agrupamento. <br>  -i ignora mai√∫sculas e min√∫sculas. <br>  --line-buffered analisa a linha imediatamente em vez de esperar para alcan√ßar o buffer padr√£o de 4k (√∫til para tail -f | grep). <br><br>  Se voc√™ conhece bem a express√£o regular, com --only-matching / -o, voc√™ pode realmente fazer grandes coisas com o corte de texto.  Basta comparar os pr√≥ximos dois comandos para extrair o shell do myuser: <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br>  O segundo comando parece mais compilado, mas executa apenas <b>grep em</b> vez de <b>grep</b> e <b>cut</b> , portanto, levar√° menos tempo para execu√ß√£o. <br><br><h4>  6. Como reduzir o tamanho do arquivo de log </h4><br>  No * nix, se voc√™ excluir o arquivo de log atualmente usado por um aplicativo, n√£o poder√° apenas remover todos os logs, mas evitar que o aplicativo grave novos logs at√© reiniciar. <br><br>  Como o descritor de arquivo n√£o abre o nome do arquivo, mas a estrutura do iNode, o aplicativo continuar√° gravando no descritor de arquivo no arquivo, que n√£o possui entrada de diret√≥rio, e esse arquivo ser√° exclu√≠do automaticamente ap√≥s a parada do aplicativo pelo sistema de arquivos ( <i>o aplicativo pode abra e feche o arquivo de log sempre que desejar gravar algo para evitar esse problema, mas isso afeta o desempenho</i> ). <br><br>  Ent√£o, como limpar o arquivo de log sem exclu√≠-lo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br>  Ou podemos usar o comando truncate: <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br>  Mencione, que o comando <b>truncado</b> excluir√° o restante do arquivo, para que voc√™ perca os √∫ltimos eventos de log.  Veja outro exemplo de como armazenar as √∫ltimas 1000 linhas: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PS No Linux, temos rotatelog de servi√ßo padr√£o.</i>  <i>Voc√™ pode adicionar seus logs para truncar / girar automaticamente ou usar bibliotecas de logs existentes que podem fazer isso por voc√™ (como log4j em java).</i> <br><br><h4>  7. <b>Assista</b> est√° olhando para voc√™! </h4><br>  Existe uma situa√ß√£o em que voc√™ est√° aguardando a conclus√£o de algum evento.  Por exemplo, enquanto outro usu√°rio faz logon no shell (voc√™ executa continuamente <b>quem</b> comanda), ou algu√©m deve copiar o arquivo para sua m√°quina usando scp ou ftp e voc√™ est√° aguardando a conclus√£o (repetindo v√°rias dezenas de vezes). <br><br>  Nesses casos, voc√™ pode usar <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br>  Por padr√£o, ser√° executado a cada 2 segundos com a pr√©-limpeza da tela at√© Ctrl + C pressionado.  Voc√™ pode configurar com que frequ√™ncia deve ser executado. <br><br>  √â muito √∫til quando voc√™ deseja assistir a registros ao vivo. <br><br><h4>  8. Sequ√™ncia de basquete </h4><br>  Existe uma constru√ß√£o muito √∫til para criar intervalos.  Por exemplo, em vez de algo como isto: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Voc√™ pode escrever o seguinte: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Al√©m disso, voc√™ pode usar o comando <b>seq</b> para gerar intervalos formatados.  Por exemplo, podemos usar <b>seq</b> para criar valores que ser√£o ajustados automaticamente pela largura (00, 01 em vez de 0, 1): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br>  Outro exemplo com substitui√ß√£o de comando - renomeie arquivos.  Para obter o nome do arquivo sem extens√£o, estamos usando o comando ' <b>basename</b> ': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Ainda mais curto com '%': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PS Na verdade, para renomear os arquivos, voc√™ pode tentar a ferramenta ' <b>renomear</b> ', que possui muitas op√ß√µes. <br><br>  Outro exemplo - vamos criar estrutura para o novo projeto java: <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9. cauda, ‚Äã‚Äãv√°rios arquivos, v√°rios usu√°rios ... </h4><br>  <b>Mencionei o multitail</b> para ler arquivos e assistir a v√°rios logs ao vivo.  Mas n√£o √© fornecido por padr√£o, e as permiss√µes para instalar algo nem sempre est√£o dispon√≠veis. <br><br>  Mas a cauda padr√£o tamb√©m pode: <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br>  Tamb√©m vamos lembrar sobre os usu√°rios, que est√£o usando aliases 'tail -f' para assistir aos logs do aplicativo. <br>  V√°rios usu√°rios podem assistir arquivos de log simultaneamente usando 'tail -f'.  Alguns deles n√£o s√£o muito precisos com suas sess√µes.  Eles podem deixar 'tail -f' em segundo plano por algum motivo e esquec√™-lo. <br><br>  Se o aplicativo foi reiniciado, existem esses processos 'tail -f' em execu√ß√£o que est√£o assistindo ao arquivo de log inexistente podem travar por v√°rios dias ou at√© meses. <br><br>  Geralmente n√£o √© um grande problema, mas n√£o ordenadamente. <br><br>  Caso esteja usando o alias para observar o log, voc√™ pode modificar esse alias com a op√ß√£o --pid: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br>  Nesse caso, todas as <b>caudas</b> ser√£o automaticamente encerradas quando o aplicativo de destino for reiniciado. <br><br><h4>  10. Crie um arquivo com tamanho especificado </h4><br>  <b>O dd</b> foi uma das ferramentas mais populares para trabalhar com dados bin√°rios e de bloco.  Por exemplo, criar um arquivo de 1 MB preenchido com zero ser√°: <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br>  Mas eu recomendo usar <b>fallocate</b> : <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br>  Nos sistemas de arquivos que suportam a fun√ß√£o de aloca√ß√£o (xfs, ext4, Btrfs ...), o <b>fallocate</b> ser√° executado instantaneamente, ao contr√°rio da ferramenta dd.  Al√©m disso, alocar significa aloca√ß√£o real de blocos, n√£o a cria√ß√£o de um arquivo sobressalente. <br><br><h4>  11. xargs </h4><br>  Muitas pessoas conhecem o comando <b>xargs</b> popular.  Mas nem todos eles usam duas op√ß√µes a seguir, o que poderia melhorar muito o seu script. <br><br>  Primeiro - voc√™ pode obter uma lista muito longa de argumentos para processar e pode exceder o comprimento da linha de comando (por padr√£o, ~ 4 kb). <br><br>  Mas voc√™ pode limitar a execu√ß√£o usando a op√ß√£o -n, para que o <b>xargs</b> execute o comando v√°rias vezes, enviando um n√∫mero especificado de argumentos por vez: <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br>  Indo em frente.  O processamento de uma lista longa pode levar muito tempo, porque √© executado em um √∫nico encadeamento.  Mas se tivermos v√°rios n√∫cleos, podemos dizer ao <b>xargs</b> para rodar em paralelo: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  No exemplo acima, dizemos ao <b>xargs</b> para processar a lista em 3 threads;  cada thread recebe e processa 2 argumentos por execu√ß√£o.  Se voc√™ n√£o sabe quantos n√∫cleos voc√™ possui, vamos otimizar isso usando " <b>nproc</b> ": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12. dorme?  enquanto?  leia! </h4><br>  Algum tempo voc√™ precisa esperar alguns segundos.  Ou aguarde a entrada do usu√°rio com read: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br>  Mas voc√™ pode simplesmente adicionar a op√ß√£o de tempo limite para <b>ler o</b> comando, e seu script ser√° pausado por um per√≠odo especificado de segundos, mas no caso de execu√ß√£o interativa, o usu√°rio pode facilmente ignorar a espera. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br>  Ent√£o voc√™ pode simplesmente esquecer o comando de suspens√£o. <br><br>  Suspeito que nem todos os meus truques pare√ßam interessantes, mas me pareceu que uma d√∫zia √© um bom n√∫mero a ser preenchido. <br><br>  Digo adeus e serei grato por participar da pesquisa. <br><br>  Claro, sinta-se √† vontade para discutir o que foi dito acima e compartilhar seus truques legais nos coment√°rios! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444890/">https://habr.com/ru/post/pt444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444880/index.html">Uma interpreta√ß√£o multi-mundo da mec√¢nica qu√¢ntica</a></li>
<li><a href="../pt444882/index.html">Os bancos come√ßaram a bloquear contas freelancers</a></li>
<li><a href="../pt444884/index.html">Groovy deixou C√©dric Champeau</a></li>
<li><a href="../pt444886/index.html">Aplica√ß√µes de engenharia reversa ap√≥s ofusca√ß√£o</a></li>
<li><a href="../pt444888/index.html">Ingl√™s e TI: coruja inglesa em um globo russo?</a></li>
<li><a href="../pt444892/index.html">Fraudador dos EUA ganhou milh√µes de d√≥lares fingindo ser o suporte t√©cnico da Microsoft</a></li>
<li><a href="../pt444894/index.html">Lan√ßamento do Zabbix 4.2</a></li>
<li><a href="../pt444896/index.html">Reciclagem de Discos R√≠gidos como Lixo Eletr√¥nico - Solu√ß√£o Parcial da iNEMI</a></li>
<li><a href="../pt444898/index.html">Como escolher um modem de banda larga para um ve√≠culo a√©reo n√£o tripulado (UAV) ou rob√≥tica</a></li>
<li><a href="../pt444900/index.html">Valida√ß√£o de formul√°rio no Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>