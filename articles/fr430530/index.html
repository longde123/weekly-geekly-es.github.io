<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏻 👢 ❓ Serveur simulé pour l'automatisation des tests mobiles 🛌🏻 🍧 🤱🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En travaillant sur le dernier projet, j'ai été confronté au test d'une application mobile connectée au niveau de la logique métier avec différents ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serveur simulé pour l'automatisation des tests mobiles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maxilect/blog/430530/">  En travaillant sur le dernier projet, j'ai été confronté au test d'une application mobile connectée au niveau de la logique métier avec différents services tiers.  Tester ces services ne faisait pas partie de ma tâche, cependant, des problèmes avec leur API ont bloqué le travail de l'application elle-même - les tests ont échoué non pas à cause de problèmes à l'intérieur, mais à cause de l'inopérabilité de l'API, avant même d'avoir vérifié la fonctionnalité nécessaire. <br><br>  Traditionnellement, les supports sont utilisés pour tester de telles applications.  Mais ils ne fonctionnent pas toujours normalement, ce qui interfère avec le travail.  Comme solution alternative, j'ai utilisé moki.  Je veux parler de ce chemin épineux aujourd'hui. <br><br><img src="https://habrastorage.org/webt/kn/uf/vw/knufvwqxahfwy6zkqxrkgeirrga.jpeg" alt="image"><br><a name="habracut"></a><br>  Afin de ne pas toucher au code d'un vrai projet (sous NDA), pour plus de clarté, j'ai créé un simple client REST pour Android, qui permet d'envoyer des requêtes HTTP (GET / POST) à une certaine adresse avec les paramètres dont j'ai besoin.  Nous allons le tester. <br>  Le code d'application client, les répartiteurs et les tests peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">téléchargés depuis GitLab</a> . <br><br><h2>  Quelles sont les options? </h2><br>  Il y avait deux façons de se moquer dans mon cas: <br><br><ul><li>  déployer un faux serveur dans le cloud ou sur une machine distante (si nous parlons de développements confidentiels qui ne peuvent pas être transférés vers le cloud); </li><li>  lancez le faux serveur localement - directement sur le téléphone sur lequel l'application mobile est testée. </li></ul><br>  La première option n'est pas très différente du banc d'essai.  En effet, il est possible d'allouer un poste de travail dans le réseau pour le faux serveur, mais il devra être pris en charge, comme tout banc d'essai.  Et ici, il est nécessaire de rencontrer les principaux pièges de cette approche.  Le poste de travail distant est mort, a cessé de répondre, quelque chose a changé - vous devez surveiller, modifier la configuration, c'est-à-dire  faire la même chose qu'avec le support d'un banc d'essai régulier.  Nous ne pouvons pas corriger la situation par nous-mêmes, et cela prendra certainement plus de temps que toute manipulation locale.  Donc, spécifiquement dans mon projet, il était plus pratique d'élever localement le faux serveur. <br><br><h2>  Choisir un faux serveur </h2><br>  Il existe de nombreux outils différents.  J'ai essayé de travailler avec plusieurs et dans presque tout le monde, j'ai rencontré certains problèmes: <br><br><ul><li>  <b>Mock-server</b> , <b>wiremock</b> - deux faux serveurs que je ne pouvais pas exécuter normalement sur Android.  Étant donné que toutes les expériences ont eu lieu dans le cadre d'un projet en direct, le temps de choix était limité.  Après avoir creusé avec eux quelques jours, j'ai renoncé à essayer. </li><li>  <b>Restmock</b> est un wrapper sur <b>okhttpmockwebserver</b> , qui sera discuté plus en détail plus tard.  Ça avait l'air bien, ça a commencé, mais le développeur de ce wrapper a caché «sous le capot» la possibilité de définir l'adresse IP et le port du faux serveur, et pour moi, c'était critique.  Restmock a commencé sur un port aléatoire.  En fouillant dans le code, j'ai vu que lorsque le serveur a été initialisé, le développeur a utilisé une méthode qui définissait le port au hasard s'il ne le recevait pas à l'entrée.  En principe, on pouvait hériter de cette méthode, mais le problème était dans le constructeur privé.  En conséquence, j'ai refusé l'emballage. </li><li>  <b>Okhttpmockwebserver</b> - après avoir essayé différents outils, je me suis arrêté sur le faux serveur, qui se réunissait normalement et a commencé localement sur l'appareil. </li></ul><br><h2>  Nous analysons le principe du travail </h2><br>  La version actuelle de okhttpmockwebserver vous permet d'implémenter plusieurs scénarios de travail: <br><br><ul><li>  <b>File d'attente de réponses</b> .  Les réponses du faux serveur sont ajoutées à la file d'attente FIFO.  Peu importe quelle API et quel chemin j'accéderai, le faux serveur lancera à tour de rôle des messages dans cette file d'attente. </li><li> <b>Le répartiteur vous</b> permet de créer des règles qui déterminent la réponse à donner.  Supposons qu'une demande provienne d'une URL contenant un chemin, par exemple / get-login /.  Sur ce serveur / get-login / mock et donne une réponse unique et prédéfinie. </li><li>  <b>Vérificateur de demande</b> .  Sur la base du scénario précédent, je peux vérifier les requêtes que l'application envoie (que dans les conditions données, une requête avec certains paramètres part vraiment).  Cependant, la réponse est sans importance, car elle est déterminée par le fonctionnement de l'API.  Ce script implémente le vérificateur de demandes. </li></ul><br>  Examinez chacun des scénarios plus en détail. <br><br><h3>  File d'attente de réponse </h3><br>  L'implémentation la plus simple du faux serveur est la file d'attente de réponses.  Avant le test, je détermine l'adresse et le port où le faux serveur sera déployé, ainsi que le fait qu'il fonctionnera sur le principe d'une file d'attente de messages - FIFO (premier entré, premier sorti). <br><br>  Ensuite, exécutez le faux serveur. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueTest</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseTest</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mActivityRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule(MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Before</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initMockServer</span></span></span><span class="hljs-class">() </span></span>{ val mockServer = MockWebServer() val ip = InetAddress.getByName(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>) val port = <span class="hljs-number"><span class="hljs-number">8080</span></span> mockServer.enqueue(MockResponse().setBody(<span class="hljs-string"><span class="hljs-string">"1st message"</span></span>)) mockServer.enqueue(MockResponse().setBody(<span class="hljs-string"><span class="hljs-string">"2nd message"</span></span>)) mockServer.enqueue(MockResponse().setBody(<span class="hljs-string"><span class="hljs-string">"3rd message"</span></span>)) mockServer.start(ip, port) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queueTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ sendGetRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/getMessage"</span></span>) assertResponseMessage(<span class="hljs-string"><span class="hljs-string">"1st message"</span></span>) returnFromResponseActivity() sendPostRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/getMessage"</span></span>) assertResponseMessage(<span class="hljs-string"><span class="hljs-string">"2nd message"</span></span>) returnFromResponseActivity() sendGetRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/getMessage"</span></span>) assertResponseMessage(<span class="hljs-string"><span class="hljs-string">"3rd message"</span></span>) returnFromResponseActivity() } }</code> </pre> <br>  Les tests sont écrits à l'aide du framework Espresso, conçu pour effectuer des actions dans les applications mobiles.  Dans cet exemple, je sélectionne les types de demande et les envoie à tour de rôle. <br>  Après avoir commencé le test, le faux serveur lui donne des réponses conformément à la file d'attente prescrite et le test réussit sans erreur. <br><br><h3>  Implémentation de Dispatcher </h3><br>  Un répartiteur est un ensemble de règles selon lesquelles un faux serveur fonctionne.  Pour plus de commodité, j'ai créé trois répartiteurs différents: SimpleDispatcher, OtherParamsDispatcher et ListingDispatcher. <br><br><h4>  Simpledispatcher </h4><br>  Okhttpmockwebserver fournit la classe <code>Dispatcher()</code> pour implémenter le répartiteur.  Vous pouvez en hériter en remplaçant la fonction de <code>dispatch</code> à votre manière. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleDispatcher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: RecordedRequest)</span></span></span><span class="hljs-function">: MockResponse </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.method == <span class="hljs-string"><span class="hljs-string">"GET"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">": "</span></span>It was a GET request<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.method == <span class="hljs-string"><span class="hljs-string">"POST"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">": "</span></span>It was a POST request<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) } }</code> </pre><br>  La logique de cet exemple est simple: si un GET arrive, je renvoie un message qu'il s'agit d'une demande GET.  Si POST, je renvoie un message sur la demande POST.  Dans d'autres situations, je renvoie une demande vide. <br><br>  <code>SimpleDispatcher</code> apparaît dans le test - un objet de la classe <code>SimpleDispatcher</code> , que j'ai décrit ci-dessus.  De plus, comme dans l'exemple précédent, le serveur simulé est lancé, mais cette fois, une sorte de règle pour travailler avec ce serveur simulé est indiquée - le même répartiteur. <br><br>  Les sources de test avec <code>SimpleDispatcher</code> peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le référentiel</a> . <br><br><h4>  AutreParamsDispatcher </h4><br>  En remplaçant la fonction de <code>dispatch</code> , je peux repousser d'autres paramètres de demande pour envoyer des réponses: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherParamsDispatcher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: RecordedRequest)</span></span></span><span class="hljs-function">: MockResponse </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> when { request.path.contains(<span class="hljs-string"><span class="hljs-string">"?queryKey=value"</span></span>) -&gt; MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">": "</span></span>It was a GET request with query parameter queryKey equals value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) request.body.toString().contains(<span class="hljs-string"><span class="hljs-string">"\"bodyKey\":\"value\""</span></span>) -&gt; MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">": "</span></span>It was a POST request with body parameter bodyKey equals value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) request.headers.toString().contains(<span class="hljs-string"><span class="hljs-string">"header: value"</span></span>) -&gt; MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">": "</span></span>It was some request with header equals value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">200</span></span>).setBody(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ Wrong response }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) } } }</code> </pre><br>  Dans ce cas, je démontre plusieurs options pour les conditions. <br><br>  Tout d'abord, vous pouvez transmettre des paramètres à l'API dans la barre d'adresse.  Par conséquent, je peux mettre une condition sur l'entrée de n'importe quel bundle dans le chemin, par exemple, <code>“?queryKey=value”</code> . <br>  Deuxièmement, cette classe vous permet d'entrer dans le corps du corps des requêtes POST ou PUT.  Par exemple, vous pouvez utiliser <code>contains</code> en exécutant d'abord <code>toString()</code> .  Dans mon exemple, la condition est déclenchée lorsqu'une requête POST contenant <code>“bodyKey”:”value”</code> .  De même, je peux valider l'en- <code>header : value</code> la demande (en- <code>header : value</code> ). <br><br>  Pour des exemples de tests, je recommande de se référer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">au référentiel</a> . <br><br><h4>  ListingDispatcher </h4><br>  Si nécessaire, vous pouvez implémenter une logique plus complexe - ListingDispatcher.  De la même manière, je remplace la fonction de <code>dispatch</code> .  Cependant, maintenant dans la classe, j'ai défini l'ensemble par défaut de <code>stubsList</code> ( <code>stubsList</code> ) - mok pour différentes occasions. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListingDispatcher</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stubsList: ArrayList&lt;RequestClass&gt; = defaultRequests() <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: RecordedRequest)</span></span></span><span class="hljs-function">: MockResponse </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { stubsList.first { it.matcher(request.path, request.body.toString()) }.response() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: NoSuchElementException) { Log.e(<span class="hljs-string"><span class="hljs-string">"Unexisting request path ="</span></span>, request.path) MockResponse().setResponseCode(<span class="hljs-number"><span class="hljs-number">404</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultRequests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: ArrayList&lt;RequestClass&gt; </span></span>{ val allStubs = ArrayList&lt;RequestClass&gt;() allStubs.add(RequestClass(<span class="hljs-string"><span class="hljs-string">"/get"</span></span>, <span class="hljs-string"><span class="hljs-string">"queryParam=value"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>Request url starts with /get url and contains queryParam=value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)) allStubs.add(RequestClass(<span class="hljs-string"><span class="hljs-string">"/post"</span></span>, <span class="hljs-string"><span class="hljs-string">"queryParam=value"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>Request url starts with /post url and contains queryParam=value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)) allStubs.add(RequestClass(<span class="hljs-string"><span class="hljs-string">"/post"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"\"bodyParam\":\"value\""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>Request url starts with /post url and body contains bodyParam:value<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allStubs } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMockStub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub: RequestClass)</span></span></span><span class="hljs-function"> </span></span>{ val valuesToRemove = ArrayList&lt;RequestClass&gt;() stubsList.forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.path.contains(stub.path)&amp;&amp;it.query.contains(stub.query)&amp;&amp;it.body.contains(stub.body)) valuesToRemove.add(it) } stubsList.removeAll(valuesToRemove) stubsList.add(stub) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMockStub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub: RequestClass)</span></span></span><span class="hljs-function"> </span></span>{ stubsList.add(stub) } }</code> </pre><br>  Pour ce faire, j'ai créé une classe ouverte <code>RequestClass</code> , dont tous les champs sont vides par défaut.  Pour cette classe, je définis une fonction de <code>response</code> qui crée un objet <code>MockResponse</code> (renvoyant une réponse 200 ou un autre <code>responseText</code> ), et une fonction de correspondance qui retourne <code>true</code> ou <code>false</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">open class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val path:String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val query: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val body:String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val responseText: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">open fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: MockResponse </span></span>= MockResponse() .setResponseCode(code) .setBody(responseText) <span class="hljs-function"><span class="hljs-function">open fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(apiCall: String, apiBody: String)</span></span></span><span class="hljs-function">: Boolean </span></span>= apiCall.startsWith(path)&amp;&amp;apiCall.contains(query)&amp;&amp;apiBody.contains(body) }</code> </pre><br>  Par conséquent, je peux créer des combinaisons de conditions plus complexes pour les talons.  Cette conception m'a semblé plus flexible, bien que le principe de base soit très simple. <br><br>  Mais surtout dans cette approche, j'ai aimé pouvoir remplacer certains stubs sur le pouce, s'il est nécessaire de changer quelque chose dans la réponse du serveur simulé lors d'un test.  Lorsque vous testez de grands projets, ce problème se produit assez souvent, par exemple, lors de la vérification de certains scénarios spécifiques. <br>  Le remplacement peut être effectué comme suit: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMockStub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub: RequestClass)</span></span></span><span class="hljs-function"> </span></span>{ val valuesToRemove = ArrayList&lt;RequestClass&gt;() stubsList.forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.path.contains(stub.path)&amp;&amp;it.query.contains(stub.query)&amp;&amp;it.body.contains(stub.body)) valuesToRemove.add(it) } stubsList.removeAll(valuesToRemove) stubsList.add(stub) }</code> </pre><br>  Avec cette implémentation du répartiteur, les tests restent simples.  Je démarre également le faux serveur, sélectionnez uniquement <code>ListingDispatcher</code> . <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListingDispatcherTest</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseTest</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mActivityRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule(MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dispatcher</span></span></span><span class="hljs-class"> </span></span>= ListingDispatcher() <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initMockServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val mockServer = MockWebServer() val ip = InetAddress.getByName(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>) val port = <span class="hljs-number"><span class="hljs-number">8080</span></span> mockServer.setDispatcher(dispatcher) mockServer.start(ip, port) } . . . }</code> </pre><br>  Par souci d'expérience, j'ai remplacé le talon par POST: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postReplacedStubTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val params: HashMap&lt;String, String&gt; = hashMapOf(<span class="hljs-string"><span class="hljs-string">"bodyParam"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) replacePostStub() sendPostRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/post"</span></span>, params = params) assertResponseMessage(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>Post request stub has been replaced<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre><br>  Pour ce faire, a appelé la fonction <code>replacePostStub</code> partir d'un <code>dispatcher</code> régulier et a ajouté une nouvelle <code>response</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePostStub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dispatcher.replaceMockStub(RequestClass(<span class="hljs-string"><span class="hljs-string">"/post"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"\"bodyParam\":\"value\""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>Post request stub has been replaced<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)) }</code> </pre><br>  Dans le test ci-dessus, je vérifie que le talon a été remplacé. <br>  Ensuite, j'ai ajouté un nouveau stub, qui n'était pas par défaut. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewStubTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ addSomeStub() sendGetRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/some_specific_url"</span></span>) assertResponseMessage(<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>U have got specific message<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSomeStub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dispatcher.addMockStub(RequestClass(<span class="hljs-string"><span class="hljs-string">"/some_specific_url"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"{ "</span></span>message<span class="hljs-string"><span class="hljs-string">" : "</span></span>U have got specific message<span class="hljs-string"><span class="hljs-string">" }"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)) }</code> </pre><br><h3>  Vérificateur de demande </h3><br>  Le dernier cas - Request verifier - ne prévoit pas l'espionnage, mais vérifie les demandes envoyées par l'application.  Pour ce faire, je démarre simplement le faux serveur en implémentant le répartiteur afin que l'application renvoie au moins quelque chose. <br>  Lors de l'envoi d'une demande à partir d'un test, elle arrive au serveur factice.  Grâce à lui, je peux accéder aux paramètres de la demande à l'aide de <code>takeRequest()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestVerifierTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val params: HashMap&lt;String, String&gt; = hashMapOf(<span class="hljs-string"><span class="hljs-string">"bodyKey"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) val headers: HashMap&lt;String, String&gt; = hashMapOf(<span class="hljs-string"><span class="hljs-string">"header"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) sendPostRequest(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/post"</span></span>, headers = headers, params = params) val request = mockServer.takeRequest() assertEquals(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, request.method) assertEquals(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, request.getHeader(<span class="hljs-string"><span class="hljs-string">"header"</span></span>)) assertTrue(request.body.toString().contains(<span class="hljs-string"><span class="hljs-string">"\"bodyKey\":\"value\""</span></span>)) assertTrue(request.path.startsWith(<span class="hljs-string"><span class="hljs-string">"/post"</span></span>)) }</code> </pre><br>  Ci-dessus, j'ai montré le test avec un exemple simple.  Exactement la même approche peut être utilisée pour JSON complexe, y compris pour vérifier la structure entière de la demande (vous pouvez comparer au niveau JSON ou analyser JSON en objets et vérifier l'égalité au niveau objet). <br><br><h2>  Résumé </h2><br>  En général, j'ai aimé l'outil (okhttpmockwebserver), et je l'utilise sur un grand projet.  Bien sûr, il y a quelques petites choses que j'aimerais changer. <br>  Par exemple, je n'aime pas que vous ayez à frapper l'adresse locale (localhost: 8080 dans notre exemple) dans les configs de votre application;  peut-être que je peux toujours trouver un moyen de tout configurer pour que le faux serveur réponde lorsqu'il essaie d'envoyer une demande à n'importe quelle adresse. <br>  De plus, je n'ai pas la possibilité de rediriger les demandes - lorsque le faux serveur envoie une demande supplémentaire, s'il n'a pas de talon approprié.  Il n'y a pas une telle approche dans ce faux serveur.  Cependant, il n’a même pas été mis en œuvre, car pour le moment le projet «combat» n’a pas une telle tâche. <br><br>  Auteur de l'article: Ruslan Abdulin <br><br>  PS Nous publions nos articles sur plusieurs sites du Runet.  Abonnez-vous à nos pages sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaînes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VK</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FB</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telegram</a> pour découvrir toutes nos publications et autres actualités Maxilect. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430530/">https://habr.com/ru/post/fr430530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430520/index.html">Présentation de Spring Data MongoDB</a></li>
<li><a href="../fr430522/index.html">Avez-vous besoin d'une culture d'entreprise en informatique? Confession du chef de marque du studio Krasnodar Plarium</a></li>
<li><a href="../fr430524/index.html">Architecture de réseau de neurones</a></li>
<li><a href="../fr430526/index.html">Machines à sous: d'où viennent-elles en URSS et comment sont-elles arrangées</a></li>
<li><a href="../fr430528/index.html">Programmation avec PyUSB 1.0</a></li>
<li><a href="../fr430532/index.html">Sécurité dans les applications iOS</a></li>
<li><a href="../fr430534/index.html">Création d'un modèle pour Zabbix en utilisant le DVR Trassir SDK comme exemple</a></li>
<li><a href="../fr430536/index.html">Conception de fonctions de fenêtre résumées en une unité avec un niveau donné de chevauchement</a></li>
<li><a href="../fr430538/index.html">Lisez-vous Scaladoc pour les méthodes de collecte «évidentes»? Ou pourquoi la paresse n'est pas toujours bonne</a></li>
<li><a href="../fr430542/index.html">Webinaire ouvert «Infrastructure en tant que code»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>