<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅱️ 📱 👨🏻‍🎤 Pembuatan Kode di Uber 👨‍👧‍👧 🚺 🐖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita masing-masing mengerjakan tugas. Semua orang menulis kode boilerplate. Mengapa Bukankah lebih baik untuk mengotomatisasi proses ini dan hanya bek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan Kode di Uber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/413603/">  Kita masing-masing mengerjakan tugas.  Semua orang menulis kode boilerplate.  Mengapa  Bukankah lebih baik untuk mengotomatisasi proses ini dan hanya bekerja pada tugas yang menarik?  Baca artikel ini jika Anda ingin komputer melakukan pekerjaan seperti itu untuk Anda. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/144/cb5/052/144cb5052ca1830f2aac609dc3cc93c0.jpg" alt="gambar"></a> <br><br>  <i>Artikel ini didasarkan pada transkrip dari laporan oleh Zack Sweers, pengembang aplikasi seluler Uber, yang berbicara pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV</a> pada 2017.</i> <i><br></i> <br><a name="habracut"></a>  Uber memiliki sekitar 300 pengembang aplikasi seluler.  Saya bekerja di tim yang disebut "platform seluler".  Pekerjaan tim saya adalah menyederhanakan dan meningkatkan proses pengembangan aplikasi seluler sebanyak mungkin.  Kami terutama bekerja pada kerangka kerja internal, perpustakaan, arsitektur, dan sebagainya.  Karena staf yang besar, kami harus melakukan proyek skala besar yang akan dibutuhkan oleh teknisi kami di masa depan.  Mungkin besok, atau mungkin bulan depan atau bahkan setahun. <br><br><h3>  Pembuatan kode untuk otomatisasi </h3><br>  Saya ingin menunjukkan nilai dari proses pembuatan kode, serta mempertimbangkan beberapa contoh praktis.  Prosesnya sendiri terlihat seperti ini: <br><br><pre><code class="hljs python">FileSpec.builder(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Presentation"</span></span>) .addComment(<span class="hljs-string"><span class="hljs-string">"Code generating your way to happiness."</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addMember</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"%S"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"Zac Sweers"</span></span></span></span><span class="hljs-class"><span class="hljs-params">)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useSiteTarget</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FILE)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Ini adalah contoh penggunaan Kotlin Poet.  Kotlin Poet adalah perpustakaan dengan API yang bagus yang menghasilkan kode Kotlin.  Jadi apa yang kita lihat di sini? <br><br><ol><li>  <b>FileSpec.builder</b> membuat file yang disebut " <b>Presentation</b> ". </li><li>  <b>.addComment ()</b> - Menambahkan komentar ke kode yang dihasilkan. </li><li>  <b>.addAnnotation ()</b> - Menambahkan anotasi tipe <b>Author</b> . </li><li>  <b>.addMember ()</b> - menambahkan variabel " <b>nama</b> " dengan parameter, dalam kasus kami adalah " <b>Zac Sweers</b> ".  <b>% S</b> - tipe parameter. </li><li>  <b>.useSiteTarget ()</b> - Menginstal SiteTarget. </li><li>  <b>.build ()</b> - melengkapi deskripsi kode yang akan dihasilkan. </li></ol><br>  Setelah pembuatan kode, berikut ini diperoleh: <br><br><pre> <code class="hljs pgsql">Presentation.kt // Code generating your way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> happiness. @file:Author(<span class="hljs-type"><span class="hljs-type">name</span></span> = "Zac Sweers")</code> </pre> <br>  Hasil pembuatan kode adalah file dengan nama, komentar, anotasi, dan nama penulis.  Pertanyaan segera muncul: "Mengapa saya perlu membuat kode ini jika saya bisa melakukannya dalam beberapa langkah sederhana?"  Ya, Anda benar, tetapi bagaimana jika saya memerlukan ribuan file ini dengan opsi konfigurasi yang berbeda?  Apa yang terjadi jika kita mulai mengubah nilai dalam kode ini?  Bagaimana jika kita memiliki banyak presentasi?  Bagaimana jika kita memiliki banyak konferensi? <br><br><pre> <code class="hljs pgsql">conferences .flatMap { it.presentations } .onEach { (presentationName, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, author) -&gt; FileSpec.builder("", presentationName) .addComment(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) .addMember("name", "%S", author) .useSiteTarget(FILE) .build()) .build() }</code> </pre><br>  Sebagai hasilnya, kita akan sampai pada kesimpulan bahwa tidak mungkin untuk mempertahankan sejumlah file secara manual - perlu untuk diotomatisasi.  Oleh karena itu, keuntungan pertama pembuatan kode adalah menghilangkan pekerjaan rutin. <br><br><h3>  Pembuatan kode bebas kesalahan </h3><br>  Keuntungan penting kedua dari otomatisasi adalah operasi bebas kesalahan.  Semua orang membuat kesalahan.  Ini sering terjadi terutama ketika kita melakukan hal yang sama.  Komputer, sebaliknya, melakukan pekerjaan seperti itu dengan sempurna. <br><br>  Pertimbangkan contoh sederhana.  Ada kelas Person: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String)</code> </pre><br>  Misalkan kita ingin menambahkan serialisasi ke dalam JSON.  Kami akan melakukan ini menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Moshi</b></a> , karena cukup sederhana dan bagus untuk demonstrasi.  Buat PersonJsonAdapter dan mewarisi dari JsonAdapter dengan parameter tipe Person: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { }</code> </pre><br>  Selanjutnya, kami menerapkan metode fromJson.  Ini menyediakan pembaca untuk membaca informasi yang akhirnya akan dikembalikan ke Orang.  Lalu kami mengisi kolom dengan nama depan dan belakang dan mendapatkan nilai Person yang baru: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Selanjutnya, kita melihat data dalam format JSON, periksa dan masukkan di bidang yang diperlukan: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Akankah ini berhasil?  Ya, tetapi ada nuansa: objek yang kita baca harus terkandung di dalam JSON.  Untuk memfilter data berlebih yang mungkin berasal dari server, tambahkan baris kode lain: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reader.skipValue() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Pada titik ini, kami berhasil menghindari area kode rutin.  Dalam contoh ini, hanya dua bidang nilai.  Namun, kode ini memiliki banyak bagian berbeda di mana Anda mungkin tiba-tiba mogok.  Tiba-tiba kami membuat kesalahan dalam kode? <br><br>  Pertimbangkan contoh lain: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> country: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> licensePlate: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> address: Address) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numStars: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Correctness</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confidence: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>)</code> </pre><br>  Jika Anda memiliki setidaknya satu masalah setiap 10 model atau lebih, maka ini berarti Anda pasti akan mengalami kesulitan di bidang ini.  Dan ini adalah kasus ketika pembuatan kode benar-benar dapat membantu Anda.  Jika ada banyak kelas, Anda tidak akan dapat bekerja tanpa otomatisasi, karena semua orang mengizinkan kesalahan ketik.  Dengan bantuan pembuatan kode, semua tugas akan dilakukan secara otomatis dan tanpa kesalahan. <br><br>  Ada manfaat lain untuk pembuatan kode.  Misalnya, ini memberikan informasi tentang kode atau memberi tahu Anda jika ada masalah.  Pembuatan kode akan bermanfaat selama fase pengujian.  Jika Anda menggunakan kode yang dihasilkan, Anda dapat melihat bagaimana kode kerja akan benar-benar terlihat.  Anda bahkan dapat menjalankan pembuatan kode selama pengujian untuk menyederhanakan pekerjaan Anda. <br><br>  Kesimpulan: perlu mempertimbangkan pembuatan kode sebagai solusi yang mungkin untuk menghilangkan kesalahan. <br><br>  Sekarang mari kita lihat alat perangkat lunak yang membantu pembuatan kode. <br><br><h3>  Alat-alatnya </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Perpustakaan JavaPoet</b></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>KotlinPoet</b></a> untuk Java dan Kotlin, masing-masing.  Ini adalah standar pembuatan kode. </li><li>  Polaisasi.  Contoh templating untuk Java yang populer adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Apache Velocity</b></a> , dan untuk iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Handlebars</b></a> . </li><li>  <b>SPI</b> - Antarmuka Prosesor Layanan.  Itu dibangun ke Jawa dan memungkinkan Anda untuk membuat dan menerapkan antarmuka dan kemudian mendeklarasikannya dalam JAR.  Saat program dijalankan, Anda bisa mendapatkan semua implementasi antarmuka yang siap pakai. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Compile Testing</b></a> adalah pustaka dari Google yang membantu dengan pengujian kompilasi.  Dalam hal pembuatan kode, ini berarti: "Inilah yang saya harapkan, tetapi inilah yang akhirnya saya dapatkan."  Kompilasi akan dimulai di memori, dan kemudian sistem akan memberi tahu Anda apakah proses ini selesai atau kesalahan apa yang terjadi.  Jika kompilasi telah selesai, Anda akan diminta untuk membandingkan hasilnya dengan harapan Anda.  Perbandingan didasarkan pada kode yang dikompilasi, jadi jangan khawatir tentang hal-hal seperti pemformatan kode atau apa pun. </li></ol><br><h3>  Alat Pembuat Kode </h3><br>  Ada dua alat utama untuk membangun kode: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Pemrosesan Anotasi</b></a> - Anda dapat menulis anotasi dalam kode dan meminta program untuk informasi tambahan tentangnya.  Kompiler akan memberikan informasi bahkan sebelum selesai bekerja dengan kode sumber. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Gradle</b></a> adalah sistem rakitan aplikasi dengan banyak kait (kait - intersepsi panggilan fungsi) dalam siklus masa pakai perakitan kode.  Ini banyak digunakan dalam pengembangan Android.  Ini juga memungkinkan Anda untuk menerapkan pembuatan kode ke kode sumber, yang independen dari sumber saat ini. </li></ol><br>  Sekarang perhatikan beberapa contoh. <br><br><h3>  Pisau mentega </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Butter Knife</b></a> adalah perpustakaan yang dikembangkan oleh Jake Wharton.  Dia adalah tokoh terkenal di komunitas pengembang.  Perpustakaan sangat populer di kalangan pengembang Android karena membantu menghindari sejumlah besar pekerjaan rutin yang dihadapi hampir semua orang. <br><br>  Biasanya kami menginisialisasi tampilan dengan cara ini: <br><br><pre> <code class="java hljs">TextView title; ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ title = findViewById(R.id.title); icon = findViewById(R.id.icon); }</code> </pre><br>  Dengan Butterknife, akan terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Dan kita dapat dengan mudah menambahkan sejumlah tampilan, sementara metode onCreate tidak akan menumbuhkan kode boilerplate: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.text) TextView text; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.button) Button button; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.next) Button next; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.back) Button back; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.open) Button open; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Alih-alih melakukan pengikatan secara manual ini setiap kali, Anda cukup menambahkan anotasi @BindView ke bidang ini, serta pengidentifikasi (ID) yang ditugaskan kepadanya. <br><br>  Hal paling keren dari Butter Knife adalah ia akan menganalisis kode dan menghasilkan semua bagian yang serupa dengan Anda.  Ini juga memiliki skalabilitas yang sangat baik untuk data baru.  Karena itu, jika data baru muncul, tidak perlu menerapkan onCreate lagi atau melacak sesuatu secara manual.  Perpustakaan ini juga bagus untuk menghapus data. <br><br>  Jadi, seperti apa sistem ini dari dalam?  Tampilan dicari oleh pengenalan kode, dan proses ini dilakukan pada tahap pemrosesan anotasi. <br><br>  Kami memiliki bidang ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title;</code> </pre><br>  Dilihat oleh data ini, mereka digunakan dalam FooActivity tertentu: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(R.id.title) TextView title;</span></span></code> </pre><br>  Dia memiliki maknanya sendiri (R.id.title), yang bertindak sebagai target.  Harap dicatat bahwa selama pemrosesan data objek ini menjadi nilai konstan di dalam sistem: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(2131361859) TextView title;</span></span></code> </pre><br>  Ini normal.  Lagipula inilah yang harus diakses oleh Knife Butter.  Ada komponen TextView sebagai tipe.  Bidang itu sendiri disebut judul.  Jika, misalnya, kami membuat kelas kontainer dari data ini, kami mendapatkan sesuatu seperti ini: <br><br><pre> <code class="java hljs">ViewBinding( target = <span class="hljs-string"><span class="hljs-string">"FooActivity"</span></span>, id = <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, name = <span class="hljs-string"><span class="hljs-string">"title"</span></span>, type = <span class="hljs-string"><span class="hljs-string">"field"</span></span>, viewType = TextView.class )</code> </pre><br>  Jadi, semua data ini dapat dengan mudah diperoleh selama pemrosesan mereka.  Ini juga sangat mirip dengan apa yang dilakukan Butter Knife di dalam sistem. <br><br>  Akibatnya, kelas ini dihasilkan di sini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unbinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FooActivity target; <span class="hljs-meta"><span class="hljs-meta">@UiThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FooActivity target, View source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; target.title = Utils.findRequiredViewAsType(source, <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, <span class="hljs-comment"><span class="hljs-comment">// R.id.title "field 'title'", TextView.class); } }</span></span></code> </pre><br>  Di sini kita melihat bahwa semua data ini dikumpulkan bersama.  Sebagai hasilnya, kami memiliki kelas target ViewBinding dari perpustakaan java Underscore.  Di dalam, sistem ini diatur sedemikian rupa sehingga setiap kali Anda membuat turunan kelas, ia segera melakukan semua pengikatan ini dengan informasi (kode) yang Anda hasilkan.  Dan semua ini sebelumnya dihasilkan secara statis selama pemrosesan anotasi, yang berarti secara teknis benar. <br><br>  Mari kita kembali ke saluran perangkat lunak kami: <br><br><img src="https://habrastorage.org/webt/t3/d3/jv/t3d3jv5bxgx5q3occc3ldovxfjm.png"><br><br>  Selama pemrosesan anotasi, sistem membaca anotasi ini dan menghasilkan kelas ViewBinding.  Dan kemudian selama metode bind, kita melakukan pencarian yang identik untuk kelas yang sama dengan cara yang sederhana: kita mengambil namanya dan menambahkan ViewBinding pada akhirnya.  Dengan sendirinya, bagian dengan ViewBinding selama pemrosesan ditimpa dalam area yang ditentukan menggunakan JavaPoet. <br><br><h3>  Rxbindings </h3><br>  RxBindings sendiri tidak bertanggung jawab untuk pembuatan kode.  Itu tidak menangani anotasi dan bukan plugin Gradle.  Ini adalah perpustakaan biasa.  Ini menyediakan pabrik statis berdasarkan prinsip pemrograman reaktif untuk API Android.  Ini berarti bahwa, misalnya, jika Anda telah menetapkan OnClickListener, maka metode klik akan muncul yang akan mengembalikan aliran peristiwa (Dapat Diamati).  Karena berfungsi sebagai jembatan (pola desain). <br><br>  Tetapi sebenarnya ada pembuatan kode di RxBinding: <br><br><img src="https://habrastorage.org/webt/ju/ty/bv/jutybv1ayxqhcfrs9l4virsivb8.png"><br><br>  Dalam direktori ini disebut buildSrc ada tugas Gradle yang disebut KotlinGenTask.  Ini berarti bahwa semua ini sebenarnya dibuat oleh pembuatan kode.  RxBinding memiliki implementasi Java.  Dia juga memiliki artefak Kotlin yang berisi fungsi ekstensi untuk semua jenis target.  Dan semua ini sangat ketat tunduk pada aturan.  Misalnya, Anda dapat membuat semua fungsi ekstensi Kotlin, dan Anda tidak harus mengontrolnya satu per satu. <br><br>  Seperti apa bentuknya? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Berikut ini adalah metode RxBinding yang benar-benar klasik.  Objek yang dapat diamati dikembalikan di sini.  Metode ini disebut klik.  Bekerja dengan acara klik terjadi "di bawah tenda".  Kami menghilangkan fragmen kode tambahan untuk menjaga keterbacaan contoh.  Di Kotlin, tampilannya seperti ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;Object&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Fungsi ekstensi ini mengembalikan objek yang bisa diamati.  Dalam struktur internal program, program ini secara langsung memanggil antarmuka Java biasa untuk kita.  Di Kotlin, Anda harus mengubahnya ke tipe Unit: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Artinya, di Jawa, tampilannya seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Dan begitu juga kode Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Kami memiliki kelas RxView yang berisi metode ini.  Kita dapat mengganti potongan data terkait dalam atribut target, dalam atribut nama dengan nama metode dan dalam tipe yang kita kembangkan, serta dalam tipe nilai pengembalian.  Semua informasi ini akan cukup untuk mulai menulis metode ini: <br><br><pre> <code class="hljs pgsql">BindingMethod( target = "RxView", <span class="hljs-type"><span class="hljs-type">name</span></span> = "clicks", <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, returnType = "Observable&lt;Unit&gt;" )</code> </pre><br>  Sekarang kita dapat langsung mengganti fragmen-fragmen ini ke dalam kode Kotlin yang dihasilkan di dalam program.  Inilah hasilnya: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br><h3>  Gen layanan </h3><br>  Kami sedang mengerjakan Service Gen di Uber.  Jika Anda bekerja di perusahaan dan berurusan dengan karakteristik umum dan antarmuka perangkat lunak umum untuk sisi backend dan klien, maka terlepas dari apakah Anda sedang mengembangkan aplikasi Android, iOS atau web, tidak masuk akal untuk secara manual membuat model dan layanan untuk kerja tim. <br><br>  Kami menggunakan pustaka <a href=""><b>AutoValue</b></a> Google untuk model objek.  Ia memproses anotasi, menganalisis data, dan menghasilkan kode hash dua baris, metode equals (), dan implementasi lainnya.  Dia juga bertanggung jawab untuk mendukung ekstensi. <br><br>  Kami memiliki objek tipe Rider: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Kami memiliki garis dengan ID, nama depan, nama belakang dan alamat.  Untuk bekerja dengan jaringan, kami menggunakan pustaka Retrofit dan OkHttp, dan JSON sebagai format data.  Kami juga menggunakan RxJava untuk pemrograman reaktif.  Seperti inilah tampilan layanan API kami: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rider"</span></span></span><span class="hljs-meta">)</span></span> Rider getRider() }</code> </pre><br>  Kita dapat menulis semua ini secara manual, jika kita mau.  Dan untuk jangka waktu yang lama, kami melakukannya.  Tetapi butuh banyak waktu.  Pada akhirnya, biayanya banyak dalam hal waktu dan uang. <br><br><h3>  Apa dan bagaimana Uber lakukan hari ini </h3><br>  Tugas terakhir tim saya adalah membuat editor teks dari awal.  Kami memutuskan untuk tidak lagi menulis kode secara manual yang kemudian mengenai jaringan, jadi kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Thrift</b></a> .  Itu adalah sesuatu seperti bahasa pemrograman dan protokol pada saat yang bersamaan.  Uber menggunakan barang bekas sebagai bahasa untuk spesifikasi teknis. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string uuid; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string firstName; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string lastName; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> <span class="hljs-type"><span class="hljs-type">Address</span></span> address; }</code> </pre><br>  Dalam hemat, kami mendefinisikan kontrak API antara backend dan sisi klien, dan kemudian hanya menghasilkan kode yang sesuai.  Kami menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>hemat</b></a> untuk mengurai data, dan JavaPoet untuk pembuatan kode.  Pada akhirnya, kami membuat implementasi menggunakan AutoValue: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Kami melakukan semua pekerjaan di JSON.  Ada ekstensi yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>AutoValue Moshi</b></a> , yang dapat ditambahkan ke kelas AutoValue menggunakan metode jsonAdapter statis: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonAdapter&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Moshi moshi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoValue_Rider.JsonAdapter(moshi); } }</code> </pre> <br>  Thrift juga membantu dalam pengembangan layanan: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() }</code> </pre><br>  Kami juga harus menambahkan beberapa metadata di sini untuk memberi tahu kami hasil akhir yang ingin kami capai: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() (path=<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) }</code> </pre><br>  Setelah pembuatan kode, kami akan menerima layanan kami: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) <span class="hljs-function"><span class="hljs-function">Single&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Tapi ini hanya salah satu hasil yang mungkin.  Satu model.  Seperti yang kita ketahui dari pengalaman, tidak ada yang pernah menggunakan hanya satu model.  Kami memiliki banyak model yang menghasilkan kode untuk layanan kami: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// And 6000 more</span></span></code> </pre><br>  Saat ini kami memiliki sekitar 5-6 aplikasi.  Dan mereka memiliki banyak layanan.  Dan semua orang melewati pipa perangkat lunak yang sama.  Menulis semua ini dengan tangan akan gila. <br><br>  Dalam serialisasi di JSON, "adaptor" tidak perlu terdaftar di Moshi, dan jika Anda menggunakan JSON, maka Anda tidak perlu mendaftar di JSON.  Juga diragukan untuk menyarankan karyawan untuk melakukan deserialisasi dengan menulis ulang kode melalui grafik DI. <br><br>  Tapi kami bekerja dengan Java, jadi kami bisa menggunakan pola Factory, yang kami hasilkan melalui perpustakaan <b>Fractory</b> .  Kami dapat membuat ini karena kami tahu tentang jenis ini sebelum kompilasi terjadi.  Fractory menghasilkan adaptor seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelsAdapterFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonAdapter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JsonAdapter&lt;?&gt; create(Type type, Set&lt;? extends Annotation&gt; annotations, Moshi moshi) { Class&lt;?&gt; rawType = Types.getRawType(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Rider.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rider.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(City.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> City.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Vehicle.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vehicle.adapter(moshi); } <span class="hljs-comment"><span class="hljs-comment">// Etc etc return null; } }</span></span></code> </pre><br>  Kode yang dihasilkan tidak terlihat sangat bagus.  Jika sakit mata, dapat ditulis ulang secara manual. <br><br>  Di sini Anda dapat melihat jenis yang disebutkan sebelumnya dengan nama layanan.  Sistem akan secara otomatis menentukan adaptor mana yang akan dipilih dan memanggil mereka.  Tapi di sini kita dihadapkan dengan masalah lain.  Kami memiliki 6000 adapter ini.  Bahkan jika Anda membaginya di dalam template yang sama, model "Eats" atau "Driver" akan jatuh ke dalam model "Rider" atau akan ada dalam aplikasinya.  Kode akan terentang.  Setelah titik tertentu, itu bahkan tidak dapat masuk ke file .dex.  Karena itu, Anda perlu memisahkan adaptor: <br><br><img src="https://habrastorage.org/webt/ds/ul/tg/dsultg8mrgkboye3dvwmfcepdou.png"><br><br>  Pada akhirnya, kami akan menganalisis kode terlebih dahulu dan membuat proyek yang berfungsi untuk itu, seperti di Gradle: <br><br><img src="https://habrastorage.org/webt/-4/pj/fz/-4pjfzwuq-cwmdl8lil_cia4-pi.png"><br><br>  Dalam struktur internal, dependensi ini menjadi dependensi Gradle.  Elemen yang menggunakan aplikasi Rider sekarang bergantung padanya.  Dengan itu, mereka akan membentuk model yang mereka butuhkan.  Akibatnya, tugas kita akan terpecahkan, dan semua ini akan diatur oleh sistem perakitan kode di dalam program. <br><br>  Tapi di sini kita dihadapkan dengan masalah lain: sekarang kita memiliki n-number model pabrik.  Semuanya dikompilasi menjadi berbagai objek: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GiftCardModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PricingModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DriverModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EATSModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaymentsModelFactory</code> </pre><br>  Dalam proses pemrosesan anotasi, tidak mungkin untuk hanya membaca anotasi untuk dependensi eksternal dan melakukan pembuatan kode tambahan hanya pada mereka. <br><br>  Solusi: kami memiliki beberapa dukungan di perpustakaan Fractory, yang membantu kami dalam satu cara yang rumit.  Itu terkandung dalam proses pengikatan data.  Kami memperkenalkan metadata menggunakan parameter classpath di arsip Java untuk penyimpanan lebih lanjut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory // -&gt; <span class="hljs-type"><span class="hljs-type">json</span></span> // -&gt; ridermodelfactory-fractory.bin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyAppGlobalFactory // Delegates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> discovered fractories</code> </pre><br>  Sekarang, setiap kali Anda perlu menggunakannya dalam aplikasi, kita masuk ke filter direktori classpath dengan file-file ini, dan kemudian kita ekstrak dari sana dalam format JSON untuk mengetahui dependensi mana yang tersedia. <br><br><h3>  Bagaimana semuanya cocok </h3><br><br><img src="https://habrastorage.org/webt/ih/nj/7i/ihnj7i5j631gcjbkgt-8u64h7l8.jpeg"><br><br>  Kami memiliki barang <b>bekas</b> .  Data dari sana pergi ke <b>Hemat</b> dan melewati parsing.  Mereka kemudian pergi melalui program pembuatan kode yang kita sebut <b>Jenga</b> .  Ini menghasilkan file dalam format Java.  Semua ini terjadi bahkan sebelum tahap awal pemrosesan atau sebelum kompilasi.  Dan selama proses kompilasi, anotasi diproses.  Sekarang <b>giliran AutoValue untuk</b> menghasilkan implementasi.  Itu juga memanggil <b>AutoValue Moshi</b> untuk memberikan dukungan JSON.  <b>Fractory</b> juga <b>terlibat</b> .  Semuanya terjadi selama proses kompilasi.  Proses ini didahului oleh komponen untuk membuat proyek itu sendiri, yang terutama menghasilkan sub proyek <b>Gradle</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang setelah Anda melihat gambaran lengkapnya, Anda mulai memperhatikan alat-alat yang disebutkan sebelumnya. </font><font style="vertical-align: inherit;">Jadi, misalnya, ada Gradle, membuat templat, AutoValue, JavaPoet untuk pembuatan kode. </font><font style="vertical-align: inherit;">Semua alat tidak hanya berguna sendiri, tetapi juga dalam kombinasi satu sama lain.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kontra pembuatan kode </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk menceritakan tentang jebakan. </font><font style="vertical-align: inherit;">Minus yang paling jelas adalah membengkak kode dan kehilangan kendali. </font><font style="vertical-align: inherit;">Misalnya, Belati membutuhkan sekitar 10% dari semua kode dalam aplikasi. </font><font style="vertical-align: inherit;">Model menempati bagian yang jauh lebih besar - sekitar 25%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Uber, kami mencoba menyelesaikan masalah dengan membuang kode yang tidak perlu. </font><font style="vertical-align: inherit;">Kami harus melakukan beberapa analisis statistik kode dan memahami bidang mana yang benar-benar terlibat dalam pekerjaan. </font><font style="vertical-align: inherit;">Ketika kita mengetahuinya, kita dapat membuat beberapa transformasi dan melihat apa yang terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berharap dapat mengurangi jumlah model yang dihasilkan sekitar 40%. </font><font style="vertical-align: inherit;">Ini akan membantu mempercepat instalasi dan pengoperasian aplikasi, serta menghemat uang kita.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagaimana pembuatan kode memengaruhi jadwal pengembangan proyek </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan kode, tentu saja, mempercepat pengembangan, tetapi waktunya tergantung pada alat yang digunakan tim. </font><font style="vertical-align: inherit;">Misalnya, jika Anda bekerja di Gradle, kemungkinan besar Anda melakukannya dengan kecepatan yang terukur. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa Gradle menghasilkan model sekali sehari, dan tidak ketika pengembang menginginkannya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelajari lebih lanjut tentang pengembangan di Uber dan perusahaan top lainnya. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada 28 September, Konferensi Internasional Pengembang Mobile ke-5 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBLT DEV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dimulai di Moskow </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">800 peserta, pembicara top, kuis dan teka-teki bagi mereka yang tertarik dengan pengembangan Android dan iOS. </font><font style="vertical-align: inherit;">Penyelenggara konferensi adalah e-Legion dan RAEC. </font><font style="vertical-align: inherit;">Anda dapat menjadi peserta atau mitra MBLT DEV 2018 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">di situs web konferensi</font></a><font style="vertical-align: inherit;"> .</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://"><img src="https://habrastorage.org/webt/yr/u2/x0/yru2x0-bqpghfoa6zqfrkyluuhq.jpeg"></a> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laporkan video </font></font></h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GpMR_Zjnn_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413603/">https://habr.com/ru/post/id413603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413591/index.html">Robotika Industri - 57 tahun! Ingat dari mana datangnya hitungan</a></li>
<li><a href="../id413593/index.html">Terus menaklukkan dasar laut. Microsoft dan proyek pusat data subsea Natick 2-nya</a></li>
<li><a href="../id413597/index.html">“Last resort” atau mengapa Database First Design diperlukan</a></li>
<li><a href="../id413599/index.html">Ada S.L.O.N.a di beberapa bagian. Memperkenalkan ITAM dan tidak tersedak</a></li>
<li><a href="../id413601/index.html">Apakah pusat data Microsoft memanaskan laut di sekitar</a></li>
<li><a href="../id413605/index.html">Tanya Ethan: Apa yang terjadi ketika sebuah bintang melewati tata surya?</a></li>
<li><a href="../id413607/index.html">Intisari Fintech: mata uang digital tidak mengancam sistem keuangan Federasi Rusia; PayPal menemukan berapa banyak pengeluaran gamer untuk permainan</a></li>
<li><a href="../id413609/index.html">Sindrom penipu: apa itu dan bagaimana cara menghilangkannya</a></li>
<li><a href="../id413611/index.html">Bagaimana CCTV menyerang Positive Hack Days: kontes CAMBreaker</a></li>
<li><a href="../id413613/index.html">Pesawat ruang angkasa ini akan datang lebih dekat ke Matahari daripada apa pun yang datang sebelumnya dan tidak akan meleleh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>