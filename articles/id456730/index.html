<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏽 🙏🏽 🤾🏼 Pesan "{Anda Tidak Tahu JS} Jenis dan Konstruksi Grammar" 🤝 ⏏️ ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa pun pengalaman pemrograman JavaScript yang Anda miliki, kemungkinan besar Anda tidak sepenuhnya memahami bahasa tersebut. Panduan ringkas ini meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pesan "{Anda Tidak Tahu JS} Jenis dan Konstruksi Grammar"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456730/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/un/r1/ll/unr1llifhhvkguhuc2sq4tll6ly.jpeg" align="left" alt="gambar"></a>  Apa pun pengalaman pemrograman JavaScript yang Anda miliki, kemungkinan besar Anda tidak sepenuhnya memahami bahasa tersebut.  Panduan ringkas ini mengeksplorasi jenis-jenis lebih dalam dari semua buku yang ada: Anda akan mempelajari cara kerja jenis, tentang masalah konversi mereka, dan mempelajari cara menggunakan fitur baru. <br><br>  Seperti buku-buku lain dalam seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“You Don't Know JS”</a> , ini menunjukkan aspek-aspek non-sepele dari bahasa yang lebih disukai oleh para programmer JavaScript untuk menjauh dari (atau menganggap bahwa mereka tidak ada).  Berbekal pengetahuan ini, Anda akan mencapai penguasaan JavaScript yang sebenarnya. <br><a name="habracut"></a><br><h3>  Kutipan.  Kesetaraan itu ketat dan tidak ketat. </h3><br>  Kesetaraan non-ketat diperiksa oleh operator ==, dan kesetaraan ketat oleh operator ===.  Kedua operator digunakan untuk membandingkan dua nilai untuk "kesetaraan", tetapi pilihan bentuk (ketat / tidak ketat) mengarah pada perbedaan perilaku yang sangat penting, terutama dalam bagaimana keputusan dibuat atas kesetaraan. <br><br>  Ada kesalahpahaman umum mengenai dua operator ini: "== memeriksa persamaan nilai, dan === memeriksa persamaan nilai dan tipe."  Kedengarannya masuk akal <br>  tapi tidak akurat.  Banyak buku dan blog JavaScript yang memiliki reputasi baik mengatakan hal itu, tetapi sayangnya semuanya salah. <br><br>  Deskripsi yang benar adalah: "== memungkinkan konversi tipe saat memeriksa kesetaraan, dan === melarang konversi tipe." <br><br><h3>  Kinerja Verifikasi Kesetaraan </h3><br>  Berhentilah dan pikirkan perbedaan penjelasan pertama (tidak akurat) dari penjelasan kedua (tepat). <br>  Dalam penjelasan pertama, tampak jelas bahwa operator === melakukan lebih banyak pekerjaan daripada == karena ia juga perlu memeriksa jenisnya. <br><br>  Dalam penjelasan kedua, operator == melakukan lebih banyak pekerjaan, karena dengan tipe yang berbeda ia harus melalui konversi tipe. <br><br>  Jangan jatuh ke dalam perangkap yang banyak jatuh ke dalam.  Jangan berpikir bahwa ini entah bagaimana akan mempengaruhi kecepatan program, dan == akan lebih lambat ===.  Meskipun konversi membutuhkan waktu, ini membutuhkan hitungan mikrodetik (ya, sepersejuta detik). <br><br>  Jika Anda membandingkan dua nilai dari tipe yang sama, == dan === menggunakan algoritma yang sama, jadi jika Anda tidak memperhitungkan perbedaan kecil dalam implementasi mesin, mereka harus melakukan <br>  dan pekerjaan yang sama. <br><br>  Jika Anda membandingkan dua nilai dari tipe yang berbeda, kinerja bukanlah faktor penting.  Anda harus bertanya pada diri sendiri sesuatu yang lain: jika saya membandingkan dua nilai, apakah saya ingin jenis konversi terjadi atau tidak? <br><br>  Jika Anda memerlukan konversi, gunakan persamaan == non-ketat, dan jika konversi tidak diinginkan, gunakan persamaan = = ketat. <br><br><blockquote>  Kedua operator, == dan ===, memeriksa jenis operan mereka.  Perbedaannya adalah bagaimana mereka merespons tipe ketidakcocokan. </blockquote><br><h3>  Pemeriksaan kesetaraan abstrak </h3><br>  Perilaku operator == didefinisikan dalam bagian 11.9.3 dari spesifikasi ES5 (“Algoritma Pemeriksa Kesetaraan Abstrak”).  Berikut ini adalah algoritme yang terperinci tetapi sederhana, dengan daftar eksplisit dari semua kemungkinan kombinasi jenis dan metode konversi tipe (jika perlu) yang harus diterapkan dalam setiap kombinasi. <br><br><blockquote> Ketika seseorang mengutuk konversi tipe (implisit) sebagai terlalu kompleks dan mengandung terlalu banyak cacat untuk penggunaan praktis yang bermanfaat, ia mengutuk aturan "cek kesetaraan abstrak".  Biasanya dikatakan bahwa mekanisme ini terlalu rumit dan tidak wajar untuk dipelajari dan digunakan secara praktis, dan itu membuat kesalahan dalam program JS daripada menyederhanakan pembacaan kode. <br><br>  Saya percaya bahwa ini adalah asumsi yang salah - Anda pembaca adalah pengembang yang kompeten yang menulis algoritma, yaitu kode (dan juga membaca dan memahaminya), sepanjang hari.  Untuk alasan ini, saya akan mencoba menjelaskan "tes kesetaraan abstrak" dengan kata-kata sederhana.  Namun, saya juga merekomendasikan membaca bagian 11.9.3 dari spesifikasi ES5.  Saya pikir itu akan mengejutkan Anda betapa logis semuanya ada di sana. </blockquote><br>  Bahkan, bagian pertama (11.9.3.1) menyatakan bahwa jika dua nilai yang dibandingkan memiliki tipe yang sama, mereka dibandingkan dengan cara yang sederhana dan alami.  Sebagai contoh, 42 hanya 42, dan string "abc" hanya "abc". <br><br>  Beberapa pengecualian kecil yang perlu diingat: <br><br><ul><li>  Nilai NaN tidak pernah sama dengan dirinya sendiri (lihat bab 2). </li><li>  +0 dan -0 sama satu sama lain (lihat bab 2). </li></ul><br>  Bagian terakhir di bagian 11.9.3.1 dikhususkan untuk uji ketat == kesetaraan dengan objek (termasuk fungsi dan array).  Dua nilai tersebut sama <i>hanya</i> jika keduanya merujuk ke nilai yang <i>sama</i> persis.  Tidak ada konversi jenis yang dilakukan. <br><br><blockquote>  Pemeriksaan kesetaraan yang ketat === didefinisikan secara identik ke 11.9.3.1, termasuk ketentuan untuk dua nilai objek.  Fakta ini sangat sedikit diketahui, tetapi == dan === berperilaku sama persis ketika membandingkan dua objek! </blockquote><br>  Sisa dari algoritme dalam 11.9.3 menunjukkan bahwa kesetaraan tidak-ketat == dapat digunakan untuk membandingkan dua jenis nilai yang berbeda, satu atau keduanya akan membutuhkan <br>  konversi implisit.  Sebagai hasil dari konversi, penunjukan dikonversi ke satu jenis, setelah itu mereka dapat langsung dibandingkan untuk kesetaraan dengan identitas sederhana <br>  nilai-nilai. <br><br><blockquote>  Operasi pemeriksaan ketimpangan yang lemah! = Ditentukan persis seperti yang diharapkan;  pada kenyataannya, operasi == sepenuhnya dilaksanakan, diikuti oleh perhitungan <br>  penolakan hasil.  Hal yang sama berlaku untuk operasi pengecekan ketimpangan secara ketat! ==. </blockquote><br><h3>  Perbandingan: string dan angka </h3><br>  Untuk menunjukkan konversi ==, pertama buat contoh string dan angka, yang dilakukan sebelumnya dalam bab ini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; a === b; <span class="hljs-comment"><span class="hljs-comment">// false a == b; // true</span></span></code> </pre> <br>  Seperti yang diharapkan, centang a === b gagal karena konversi tidak diizinkan, dan nilai 42 dan "42" berbeda. <br><br>  Namun, dalam perbandingan kedua a == b, kesetaraan tidak ketat digunakan;  ini berarti bahwa jika jenisnya berbeda, algoritma perbandingan akan melakukan konversi implisit dari salah satu <br>  atau keduanya. <br><br>  Tetapi konversi seperti apa yang dilakukan di sini?  Akankah nilai a, yaitu, 42, menjadi string, atau akankah nilai b "42" menjadi angka?  Spesifikasi ES5 dalam bagian 11.9.3.4–5 mengatakan: <br><br><ol><li>  Jika Tipe (x) bertipe Number, dan Tipe (y) bertipe String, kembalikan hasil perbandingan x == ToNumber (y). </li><li>  Jika Tipe (x) bertipe String dan Tipe (y) bertipe Number, kembalikan hasil perbandingan ToNumber (x) == y. </li></ol><br><blockquote>  Dalam spesifikasi, nama formal dari tipe Number dan String digunakan, sedangkan dalam buku untuk tipe primitif, notasi number dan string biasanya digunakan.  Jangan bingung kasus simbol Angka dalam spesifikasi dengan fungsi Nomor () bawaan.  Untuk keperluan kita, kasus karakter atas nama jenis tidak memainkan peran - mereka memiliki arti yang sama. </blockquote><br>  Spesifikasi mengatakan bahwa nilai "42" dikonversi ke angka untuk perbandingan.  Tentang bagaimana konversi dilakukan, sudah dijelaskan sebelumnya, dan secara khusus ketika menggambarkan ToNumber operasi abstrak.  Dalam hal ini, cukup jelas <br>  bahwa dua nilai yang dihasilkan dari 42 adalah sama. <br><br><h3>  Perbandingan: apa pun dengan boolean </h3><br>  Salah satu perangkap paling berbahaya dalam konversi implisit dari tipe == ditemui ketika mencoba untuk langsung membandingkan nilai dengan true atau false. <br><br>  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; a == b; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Tunggu, apa yang terjadi di sini?  Kita tahu bahwa "42" adalah arti sebenarnya (lihat sebelumnya dalam bab ini).  Bagaimana hasilnya dibandingkan dengan benar dengan pernyataan kesetaraan == <br>  tidak memberikan yang benar? <br><br>  Alasannya sederhana dan licik secara licik.  Sangat mudah untuk salah paham, banyak pengembang JS tidak berusaha untuk memahaminya sepenuhnya. <br><br>  Sekali lagi kami mengutip spesifikasinya, bagian 11.9.3.6–7: <br><br><ol><li>  Jika Tipe (x) adalah tipe Boolean, kembalikan hasil perbandingan ToNumber (x) == y. </li><li>  Jika Tipe (y) adalah tipe Boolean, kembalikan hasil perbandingan x == ToNumber (y). </li></ol><br>  Mari kita lihat apa yang ada di sini.  Langkah pertama: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Jenis (x) benar-benar milik tipe Boolean, sehingga operasi ToNumber (x) dilakukan, yang mengkonversi true menjadi 1. Sekarang kondisi 1 == "42" dihitung.  Jenisnya masih berbeda, oleh karena itu (hampir secara rekursif) algoritme berulang;  seperti pada kasus sebelumnya, "42" dikonversi menjadi 42, dan kondisi 1 == 42 jelas salah. <br><br>  Jika Anda menukar operan, hasilnya akan tetap sama: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; x == y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Kali ini, Tipe (y) adalah tipe Boolean, jadi ToNumber (y) memberikan 0. Kondisi "42" == 0 secara rekursif berubah menjadi 42 == 0, yang, tentu saja, salah. <br><br>  Dengan kata lain, nilai "42" bukanlah == benar atau == salah.  Pada pandangan pertama, pernyataan ini tampaknya sama sekali tidak terpikirkan.  Bagaimana makna tidak benar atau salah? <br><br>  Tapi ini masalahnya!  Anda mengajukan pertanyaan yang salah.  Meskipun sebenarnya itu bukan kesalahan Anda, itu adalah otak yang menipu Anda. <br><br>  Nilai "42" memang benar, tetapi konstruksi "42" == true tidak melakukan tes boolean / transform sama sekali, apa pun yang dikatakan otak Anda.  "42" tidak dikonversi ke boolean (true);  sebaliknya, true dikonversi ke 1, dan kemudian "42" dikonversi menjadi 42. <br><br>  Suka atau tidak, ToBoolean sama sekali tidak digunakan di sini, jadi kebenaran atau kepalsuan "42" sama sekali tidak penting untuk operasi ==!  Penting untuk memahami bagaimana algoritma perbandingan == berperilaku di semua kombinasi jenis yang berbeda.  Jika nilai boolean di satu sisi, maka selalu dikonversi ke angka terlebih dahulu. <br><br>  Jika ini terasa aneh bagi Anda, Anda tidak sendirian.  Secara pribadi, saya sarankan tidak pernah, dalam keadaan apa pun, untuk menggunakan == true atau == false.  Tidak pernah. <br><br>  Tetapi ingat bahwa saya hanya berbicara tentang == di sini.  Konstruksi === true dan === false tidak mengizinkan konversi tipe, sehingga mereka terlindung dari konversi ToNumber yang disembunyikan. <br><br>  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  (  !): if (a == true) { // .. } //   (  !): if (a === true) { // .. } //   ( ): if (a) { // .. } //  ( ): if (!!a) { // .. } //   ( ): if (Boolean( a )) { // .. }</span></span></code> </pre> <br>  Jika Anda menghindari == benar atau == salah (longgar persamaan dengan boolean) dalam kode Anda, Anda tidak perlu khawatir tentang perangkap kebenaran / kepalsuan ini. <br><br><h3>  Perbandingan: null dengan undefined </h3><br>  Contoh lain dari konversi implisit terjadi ketika Anda menggunakan lax == kesetaraan antara nilai null dan undefined.  Sekali lagi, saya akan mengutip spesifikasi ES5, <br>  bagian 11.9.3.2–3: <br><br><ol><li>  Jika x berisi nol dan y berisi tidak terdefinisi, kembalikan true. </li><li>  Jika x berisi tidak terdefinisi dan y berisi nol, kembalikan benar. </li></ol><br>  Tidak ada dan tidak terdefinisi jika dibandingkan dengan operator yang tidak ketat == sama satu sama lain (yaitu, mereka dikonversi satu sama lain), dan tidak ada nilai lain dalam keseluruhan bahasa. <br><br>  Bagi kami, ini berarti bahwa nol dan tidak terdefinisi dapat dianggap tidak dapat dibedakan untuk tujuan perbandingan, jika Anda menggunakan operator pengujian kesetaraan yang tidak ketat ==, yang memungkinkan konversi implisit satu sama lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b; a == b; <span class="hljs-comment"><span class="hljs-comment">// true a == null; // true b == null; // true a == false; // false b == false; // false a == ""; // false b == ""; // false a == 0; // false b == 0; // false</span></span></code> </pre> <br>  Konversi antara nol dan tidak terdefinisi aman dan dapat diprediksi, dan tidak ada nilai lain yang dapat memberikan positif palsu untuk cek semacam itu.  Saya sarankan menggunakan konversi ini sehingga nol dan tidak terdefinisi tidak berbeda dalam program dan ditafsirkan sebagai nilai tunggal. <br><br>  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Pemeriksaan a == null hanya lulus jika doSomething () mengembalikan nol atau tidak terdefinisi dan gagal untuk nilai lainnya (termasuk 0, false, dan ""). <br><br>  Bentuk eksplisit cek ini, yang melarang konversi jenis apa pun, terlihat (menurut saya) jauh lebih jelek dan mungkin bekerja sedikit kurang efisien! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || a === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. }</span></span></code> </pre> <br>  Saya percaya bahwa bentuk == null adalah contoh lain dari situasi di mana konversi implisit membuatnya lebih mudah untuk membaca kode, tetapi apakah itu andal dan aman. <br><br><h3>  Perbandingan: objek dan non-objek </h3><br>  Jika objek / fungsi / array dibandingkan dengan skalar primitif sederhana (string, angka atau boolean), spesifikasi ES5 mengatakan yang berikut (bagian 11.9.3.8–9): <br><br><ol><li>  Jika Tipe (x) adalah tipe String atau Angka, dan Tipe (y) adalah tipe Objek, kembalikan hasil perbandingan x == ToPrimitive (y). </li><li>  Jika Tipe (x) adalah tipe Objek dan Tipe (y) adalah tipe String atau Angka, kembalikan hasil perbandingan ToPrimitive (x) == y. </li></ol><br><blockquote>  Anda mungkin memperhatikan bahwa di bagian spesifikasi ini hanya String dan Number yang disebutkan, tetapi tidak Boolean.  Faktanya adalah bahwa, sebagaimana disebutkan di atas, bagian 11.9.3.6–7 memastikan bahwa setiap operan Boolean pertama kali direpresentasikan sebagai Number. </blockquote><br>  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">42</span></span> ]; a == b; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Untuk nilai [42], operasi abstrak ToPrimitive disebut (lihat "Operasi abstrak"), yang memberikan hasil "42".  Sejak saat ini, kondisi sederhana "42" == 42 tetap, yang, seperti yang telah kami ketahui, berubah menjadi 42 == 42, sehingga a dan b sama hingga mengetik konversi. <br><br><blockquote>  Seperti yang Anda harapkan, semua fitur operasi ToPrimitive abstrak yang dibahas sebelumnya dalam bab ini ((toString (), valueOf ()) juga berlaku dalam kasus ini. Ini bisa sangat berguna jika Anda memiliki struktur data yang kompleks dan ingin mendefinisikan metode khusus valueOf () untuknya, yang harus memberikan nilai sederhana untuk keperluan pemeriksaan kesetaraan. </blockquote><br>  Bab 3 memeriksa "membongkar" pembungkus objek di sekitar nilai primitif (seperti dalam String baru ("abc"), misalnya), menghasilkan kembalinya primitif yang mendasarinya <br>  nilai ("abc").  Perilaku ini terkait dengan transformasi ToPrimitive dalam algoritma ==: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `new String( a )` a === b; // false a == b; // true</span></span></code> </pre> <br>  a == b benar karena b dikonversi (atau "dibongkar") oleh operasi ToPrimitive ke basis sederhana nilai skalar primitif "abc", yang cocok dengan nilai dari a. <br><br>  Ada beberapa nilai yang tidak demikian karena aturan utama lainnya dalam algoritma ==.  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>( a ); <span class="hljs-comment"><span class="hljs-comment">//  ,  `Object()` a == b; // false var c = undefined; var d = Object( c ); //  ,  `Object()` c == d; // false var e = NaN; var f = Object( e ); //  ,  `new Number( e )` e == f; // false</span></span></code> </pre> <br>  Nilai-nilai nol dan tidak terdefinisi tidak dapat dikemas (mereka tidak memiliki pembungkus objek yang setara), jadi Object (null) tidak berbeda secara mendasar dari Object (): kedua panggilan membuat yang biasa <br>  objek ny. <br><br>  NaN dapat dipaket dalam Number objek wrapper yang sama, tetapi ketika == menyebabkan pembongkaran, perbandingan NaN == NaN gagal, karena nilai NaN tidak pernah sama dengan dirinya sendiri (lihat bab 2). <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>JavaScript</b> <br><br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456730/">https://habr.com/ru/post/id456730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456712/index.html">Pencatatan lalu lintas selektif untuk layanan SOAP</a></li>
<li><a href="../id456714/index.html">Memahami angka floating point (bagian 0)</a></li>
<li><a href="../id456716/index.html">Bukan data yang sangat besar</a></li>
<li><a href="../id456722/index.html">Resep PostgreSQL: Penjadwal Tugas Asinkron</a></li>
<li><a href="../id456724/index.html">5 cara yang sangat sederhana untuk mempercepat aplikasi VueJS Anda secara signifikan</a></li>
<li><a href="../id456732/index.html">Untuk menjadi seorang mentor</a></li>
<li><a href="../id456736/index.html">Resep PostgreSQL: cURL: dapatkan, kirim dan ... email</a></li>
<li><a href="../id456738/index.html">Jaringan saraf dan pembelajaran mendalam, bab 1: menggunakan jaringan saraf untuk mengenali angka tulisan tangan</a></li>
<li><a href="../id456740/index.html">Perendaman dalam jaringan saraf convolutional. Bagian 5/1 - 9</a></li>
<li><a href="../id456744/index.html">10 masalah yang saya pecahkan dengan pengingat pada ponsel cerdas saya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>