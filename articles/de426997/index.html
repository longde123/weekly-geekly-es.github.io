<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô†Ô∏è üë∏üèª ‚ùÑÔ∏è So erstellen Sie benutzerdefinierte Formen mit MaterialShapeDrawable üìò üóÑÔ∏è üöæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0 f√ºhrte mehrere neue Konzepte ein. Eine davon ist die besondere Ber√ºcksichtigung der geometrischen Formen von Schnittstellenelement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So erstellen Sie benutzerdefinierte Formen mit MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="Bild"><br><br><p>  Material Design 2.0 f√ºhrte mehrere neue Konzepte ein.  Eine davon ist die besondere Ber√ºcksichtigung der geometrischen Formen von Schnittstellenelementen.  Und es gibt eine einfache M√∂glichkeit, sch√∂ne benutzerdefinierte Formen zu erstellen.  Es hei√üt MaterialShapeDrawable.  Mal sehen, wie n√ºtzlich und einfach es zu bedienen ist. </p><a name="habracut"></a><br><p>  Es gibt verschiedene M√∂glichkeiten, dem Bildschirm einer Android-Anwendung grafische Elemente hinzuzuf√ºgen.  Am einfachsten ist es, Bitmaps im Webp- oder PNG-Format zu importieren.  Eine weitere Option ist die Verwendung von VectorDrawable, mit der Sie das Bild auf die gew√ºnschte Gr√∂√üe strecken k√∂nnen.  Eine andere M√∂glichkeit, dem Bildschirm Grafiken hinzuzuf√ºgen, ist die Verwendung von ShapeDrawable.  Letztere sind der einfachste Weg, einen einfachen Hintergrund hinzuzuf√ºgen oder sogar ein Symbol zu erstellen.  Mit ShapeDrawable erstellte Bilder sind unabh√§ngig von der Pixeldichte auf dem Bildschirm.  Sie k√∂nnen in einer XML-Datei beschrieben werden, Teil einer anderen Grafikressource sein (z. B. StateListDrawable) und sind im Android SDK ab API v.1 vorhanden. </p><br><p>  Um das Erscheinungsbild einer Figur zu √§ndern, k√∂nnen Sie verschiedene ShapeDrawable-Eigenschaften √§ndern: den Namen der Figur, die F√ºllfarbe (oder den Farbverlauf) und die Rahmenfarbe der Figur.  F√ºr Rechtecke k√∂nnen Sie auch den Radius der Ecken festlegen.  Mit diesen Eigenschaften k√∂nnen Sie Grafiken erstellen, die als einzelne Bilder auf dem Bildschirm, Teilern, Schaltfl√§chenhintergr√ºnden oder f√ºr andere Zwecke verwendet werden.  Wenn die Anwendung die API v.21 + und ShapeDrawable als Hintergrund f√ºr Elemente mit H√∂he verwendet, hat der Schatten unter diesen Elementen auch die richtige Form: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="Bild"></p><br><p>  ShapeDrawable ist ein praktisches Tool, das seine Arbeit fast immer gut erledigt. Mit dem Aufkommen von Material Design 2.0 ben√∂tigen Entwickler jedoch etwas Flexibleres.  Das neue Designsystem f√∂rdert die Verwendung verschiedener Formen, um deren Bedeutung, Zustand und individuellen Anwendungsstil hervorzuheben.  Ich habe oben geschrieben, dass es mehrere M√∂glichkeiten gibt, das Gew√ºnschte zu tun, aber die einfachste davon ist nicht mehr relevant.  Bedeutet dies, dass wir anfangen m√ºssen, Vektorgrafiken zu verwenden, und dadurch die F√§higkeit verlieren, Schatten f√ºr Schnittstellenelemente mit H√∂he "frei" zu erzeugen?  Oder lohnt es sich, wieder Rasterbilder zu verwenden und grafische Ressourcen f√ºr sechs m√∂gliche Pixeldichten auf dem Bildschirm zu erstellen?  Gl√ºcklicherweise ist mit dem Aufkommen von Material Design 2.0 eine v√∂llig neue Komponentenbibliothek erschienen. </p><br><p>  Diese Bibliothek wurde erstellt, um das Erscheinungsbild und Verhalten von Material Design UI-Komponenten auf allen Versionen von Android und anderen Plattformen zu vereinheitlichen (es gibt Versionen dieser Bibliothek f√ºr iOS, das Web und f√ºr Flutter).  Die Komponentenbibliothek implementiert viele Funktionen f√ºr das neue Materialdesign.  Beispielsweise enth√§lt es die BottomAppBar-Komponente mit dem erwarteten Verhalten.  Unter anderen Komponenten und Dienstprogrammen gibt es die MaterialShapeDrawable-Klasse.  Meiner Meinung nach ist dies ein notwendiges Werkzeug zur L√∂sung der Aufgaben, die das neue Designsystem f√ºr Entwickler darstellt. </p><br><p> Obwohl MaterialShapeDrawable in der Version 1.0.0 der Bibliothek immer noch als experimentell angesehen wird, kann es verwendet werden, um coole Effekte in der Anwendung zu erstellen.  In der MaterialShapeDrawable-Klasse k√∂nnen Sie eine Form beschreiben, indem Sie das Erscheinungsbild ihrer Seiten und jeden ihrer Winkel angeben.  Diese angegebenen Eigenschaften k√∂nnen von einem Interpolator gesteuert werden, mit dem sie animiert werden k√∂nnen. </p><br><p>  Um Ihr eigenes MaterialShapeDrawable zu erstellen, k√∂nnen Sie den Konstruktor verwenden, an den Sie in den Parametern ein Objekt vom Typ ShapePathModel √ºbergeben m√ºssen.  Es speichert Informationen zu jeder Seite und jeder Ecke der Figur in den Klassen EdgeTreatment und CornerTreatment (es gibt immer genau vier Seiten und Winkel, dies beeintr√§chtigt jedoch nicht die Beschreibung fast jeder Figur mit ihrer Hilfe).  Sie k√∂nnen Beschreibungen f√ºr jede Seite und Ecke pers√∂nlich angeben oder sie f√ºr die gesamte Figur auf einmal festlegen, indem Sie eine Methode aufrufen. </p><br><p>  Die Bibliothek verf√ºgt bereits √ºber mehrere gebrauchsfertige Beschreibungen der Behandlung der Seiten und Winkel, die die meisten Neuerungen hinsichtlich der Form der in Material Design 2.0 eingef√ºhrten Komponenten enthalten.  Bereits vorhanden: RoundedCornerTreatment - f√ºr abgerundete Ecken, CutCornerTreatment - f√ºr abgeschnittene Ecken, TriangleEdgeTreatment - zum Schneiden oder Hinzuf√ºgen eines Dreiecks zur Seite.  Um ihre Arbeit zu demonstrieren, gibt es ein einfaches Beispiel: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Es wird so aussehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="Bild"></p><br><p>  Nat√ºrlich k√∂nnen Sie einfach Ihre eigenen Beschreibungen von Gesichtern und Winkeln erstellen.  Die Form wird immer f√ºr das obere linke Element festgelegt, und Drawable f√ºhrt die Rotations- / Reflexionsoperationen aus, um die fertige Form zu erhalten.  Es gibt ein kleines Beispiel, um dies zu demonstrieren: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Wenn dieses MaterialShapeDrawable als Hintergrund verwendet wird, sieht das Ergebnis folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="Bild"></p><br><p>  Das bottomappbar-Paket der neuen Material Component Library verf√ºgt √ºber eine BottomAppBarTopEdgeTreatment.  Es beschreibt den Ausschnitt in der BottomAppBar f√ºr die Schaltfl√§che FloatingActionButton.  Die Oberseite kann je nach Position und Gr√∂√üe der Schaltfl√§che animiert werden.  Ich rate Ihnen, den Code dieser Klassen zu lesen, um mit eigenen Augen zu sehen, dass MaterialShapeDrawable sehr flexibel zu verwenden ist und fast alles damit gemacht werden kann. </p><br><p>  Wenn wir √ºber das √ºbliche ShapeDrawable sprechen, gibt es ein weiteres erw√§hnenswertes Detail - die F√§higkeit, einen Schatten der Form zu werfen, die der Kontur entspricht.  Da Sie jetzt mit MaterialShapeDrawable Konturen sehr ungew√∂hnlicher Formen erstellen k√∂nnen, w√§re es eine Entt√§uschung, die Form des Schattens nicht an die Form des Bildes anzupassen, insbesondere wenn diese Schatten in Matarial Design 2.0 √ºberall zu sehen sind.  MaterialShapeDrawable berechnet auch das Erscheinungsbild des Schattens.  Mit der Eigenschaft shadowEnabled k√∂nnen Sie den Schatten aktivieren, der genau der Kontur der Figur selbst folgt. Au√üerdem k√∂nnen Sie den Radius, die H√∂he und die Farbe des Schattens bestimmen.  Klingt zu gut um wahr zu sein?  Leider ja.  Wenn Sie den Schatten von MaterialShapeDrawable verwenden, erhalten Sie einen normalen Schatten (gezeichnet von der setShadowLayer () -Methode der Paint-Klasse, die zum Zeichnen von Schatten auf den Text erstellt wurde), jedoch auf die R√§nder der UI-Komponente zugeschnitten, in der das Ergebnis angezeigt wird: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="Bild"></p><br><p>  Beachten Sie, dass MaterialShapeDrawable wie seine API immer noch als experimentell angesehen wird und sich in Zukunft m√∂glicherweise √§ndern wird.  Es ist auch erw√§hnenswert, dass der Code f√ºr die neue Materialkomponentenbibliothek ge√∂ffnet ist. Daher ist es sehr willkommen, Tickets in einem Bug-Tracker zu erstellen oder sogar Anfragen zur Behebung bekannter Probleme abzurufen.  Wenn Sie diese Zeilen lesen, unterscheidet sich die API im Hauptzweig der Bibliothek bereits geringf√ºgig (z. B. wird ShapeAppearanceModel anstelle von ShapePathModel verwendet), was auf aktive Arbeit hinweist.  Eine der vielversprechenden Funktionen in der n√§chsten Version ist m√∂glicherweise die M√∂glichkeit, die Standardseiten / -winkel f√ºr das gesamte Anwendungsthema zu bestimmen.  Weitere Informationen hierzu finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> oder in den Bibliotheksquellen. </p><br><blockquote>  <em>Vom √úbersetzer:</em> <br>  <em>Es ist cool, dass es Tools gibt, die dem √ºblichen ShapeDrawable neue Funktionen hinzuf√ºgen und dabei helfen, nicht die einfachsten Grafiken zu erstellen.</em>  <em>Dies erm√∂glicht es dem Entwickler, den Designer nicht f√ºr jede Kleinigkeit zu ziehen, sondern das Problem selbst zu l√∂sen, und ben√∂tigt erheblich weniger Zeit.</em>  <em>Wir warten auf die n√§chsten Versionen der Material Components-Bibliothek, um in der Praxis neue Wege zur L√∂sung bestehender Probleme zu finden.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426997/">https://habr.com/ru/post/de426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426985/index.html">Kubebox und andere Konsolen-Shells f√ºr Kubernetes</a></li>
<li><a href="../de426987/index.html">Lerne OpenGL. Lektion 6.3 - Bildbasierte Beleuchtung. Diffuse Bestrahlung</a></li>
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426993/index.html">Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
<li><a href="../de426999/index.html">Den Trends folgen oder sich in Richtung RxJava und LiveData bewegen</a></li>
<li><a href="../de427003/index.html">Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung</a></li>
<li><a href="../de427005/index.html">KI-Entwickler - der Beruf der Million√§re?</a></li>
<li><a href="../de427009/index.html">"Gehen" eines Elektrons: Manipulationen mit einer Ladung innerhalb der Struktur unges√§ttigter Bindungen</a></li>
<li><a href="../de427011/index.html">Meine "Hallo Welt!" auf FPGA oder der n√§chsten Version von UART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>