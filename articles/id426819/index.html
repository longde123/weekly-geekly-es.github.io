<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌊 👊🏾 📖 Aplikasi reaktif tanpa Redux / NgRx 👷🏼 👷🏼 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan menganalisis secara rinci aplikasi sudut reaktif ( repositori github ), yang sepenuhnya ditulis pada strategi OnPush . Aplikasi lai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi reaktif tanpa Redux / NgRx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426819/"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Hari ini kita akan menganalisis secara rinci aplikasi sudut reaktif ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori github</a> ), yang sepenuhnya ditulis pada strategi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OnPush</a> .  Aplikasi lain menggunakan formulir reaktif, yang cukup khas untuk aplikasi perusahaan. <br><br>  Kami tidak akan menggunakan Flux, Redux, NgRx dan sebagai gantinya mengambil keuntungan dari kapabilitas yang sudah tersedia di Scripteks, Angular dan RxJS.  Faktanya adalah bahwa alat-alat ini bukan peluru perak dan dapat menambah kompleksitas yang tidak perlu bahkan untuk aplikasi sederhana.  Kami sejujurnya diperingatkan tentang hal ini oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu penulis Flux</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis Redux</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis NgRx</a> . <br><br>  Tetapi alat ini memberikan aplikasi kami fitur yang sangat bagus: <br><br><ul><li>  Alur data yang dapat diprediksi; </li><li>  Mendukung OnPush dengan desain; </li><li>  Kekekalan data, kurangnya akumulasi efek samping dan hal-hal menyenangkan lainnya. </li></ul><br>  Kami akan mencoba untuk mendapatkan karakteristik yang sama, tetapi tanpa memperkenalkan kompleksitas tambahan. <br><br>  Seperti yang akan Anda lihat di akhir artikel, ini adalah tugas yang cukup sederhana - jika Anda menghapus rincian Angular dan OnPush dari artikel tersebut, maka hanya ada beberapa ide sederhana. <br><a name="habracut"></a><br>  Artikel ini tidak menawarkan pola universal baru, tetapi hanya berbagi dengan pembaca beberapa ide yang, untuk semua kesederhanaannya, untuk beberapa alasan tidak langsung terlintas dalam pikiran.  Juga, solusi yang dikembangkan tidak bertentangan atau menggantikan Flux / Redux / NgRx.  Mereka dapat terhubung, jika ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">benar-benar diperlukan</a> . <br><br>  <i>Untuk membaca artikel dengan nyaman, diperlukan pemahaman tentang istilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen cerdas, presentasi, dan wadah</a> .</i> <br><br><h2>  Rencana aksi </h2><br>  Logika aplikasi, serta urutan penyajian materi, dapat dijelaskan dalam bentuk langkah-langkah berikut: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pisahkan data untuk membaca (GET) dan menulis (PUT / POST)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Muat status sebagai aliran dalam komponen wadah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendistribusikan Status ke hierarki komponen OnPush</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beri tahu Angular tentang perubahan komponen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengeditan data terenkapsulasi</a> </li></ol><br>  Untuk mengimplementasikan OnPush, kita perlu menguraikan semua cara untuk menjalankan deteksi perubahan di Angular.  Hanya ada empat metode seperti itu, dan kami akan mempertimbangkannya secara berurutan di seluruh artikel. <br><br>  Jadi ayo pergi. <br><br><a name="backend"></a><h2>  Bagikan data untuk membaca dan menulis </h2><br>  Biasanya, aplikasi frontend dan backend menggunakan kontrak yang diketik (jika tidak mengapa naskah sama sekali?). <br><br>  Proyek demo yang kami pertimbangkan tidak memiliki backend nyata, tetapi berisi file deskripsi yang sudah disiapkan sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">swagger.json</a> .  Berdasarkan itu, kontrak naskah dihasilkan oleh utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sw2dts</a> . <br><br>  Kontrak yang dihasilkan memiliki dua sifat penting. <br><br>  Pertama, membaca dan menulis dilakukan dengan menggunakan kontrak yang berbeda.  Kami menggunakan konvensi kecil dan merujuk untuk membaca kontrak dengan suffix "State", dan menulis kontrak dengan suffix "Model". <br><br>  Dengan memisahkan kontrak dengan cara ini, kami membagikan aliran data dalam aplikasi.  Dari atas ke bawah, status hanya baca disebarkan melalui hierarki komponen.  Untuk memodifikasi data, sebuah model dibuat yang awalnya diisi dengan data dari negara, tetapi ada sebagai objek yang terpisah.  Pada akhir pengeditan, model dikirim ke backend sebagai perintah. <br><br>  Poin penting kedua adalah bahwa semua bidang Negara ditandai dengan pengubah hanya baca.  Jadi kami mendapatkan dukungan kekebalan di tingkat naskah.  Sekarang kita tidak akan dapat mengubah status kode secara tidak sengaja atau mengikatnya menggunakan [(ngModel)] - saat mengompilasi aplikasi dalam mode AOT, kita akan mendapatkan kesalahan. <br><br><a name="container"></a><h2>  Muat status sebagai aliran dalam komponen wadah </h2><br>  Untuk memuat dan menginisialisasi keadaan, kami akan menggunakan layanan sudut biasa.  Mereka akan bertanggung jawab atas skenario berikut: <br><br><ul><li>  Contoh klasik memuat melalui HttpClient menggunakan parameter id yang diperoleh oleh komponen dari router. </li><li>  Menginisialisasi keadaan kosong saat membuat entitas baru.  Misalnya, jika bidang memiliki nilai default atau untuk menginisialisasi, Anda perlu meminta data tambahan dari backend. </li><li>  Mem-boot ulang keadaan yang sudah dimuat setelah pengguna melakukan operasi yang mengubah data ke backend. </li><li>  Status boot ulang dengan pemberitahuan push, misalnya, saat mengedit data bersama.  Dalam hal ini, layanan menggabungkan negara bagian dan negara bagian yang diperoleh dari backend. </li></ul><br>  Dalam aplikasi demo, kami akan mempertimbangkan dua skenario pertama sebagai yang paling umum.  Juga, skenario ini sederhana dan memungkinkan layanan untuk diimplementasikan sebagai objek stateless sederhana dan tidak terganggu oleh kompleksitas, yang bukan subjek dari artikel khusus ini. <br><br>  Contoh layanan dapat ditemukan dalam file <a href="">some-entitas.service.ts</a> . <br><br>  Tetap mendapatkan layanan melalui DI dalam komponen kontainer dan status muatan.  Ini biasanya dilakukan seperti ini: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  Tetapi dengan pendekatan ini, dua masalah muncul: <br><br><ul><li>  Anda harus berhenti berlangganan secara manual dari langganan yang dibuat, jika tidak akan terjadi kebocoran memori. </li><li>  Jika Anda mengganti komponen ke strategi OnPush, itu akan berhenti merespons pemuatan data. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pipa Async</a> datang untuk menyelamatkan.  Dia mendengarkan langsung ke Observable dan berhenti berlangganan darinya bila perlu.  Juga, ketika menggunakan pipa async, Angular secara otomatis memicu deteksi perubahan setiap kali Observable mempublikasikan nilai baru. <br><br>  Contoh menggunakan pipa async dapat ditemukan dalam template untuk <a href="">komponen some-entitas.component</a> . <br><br>  Dan dalam kode komponen, kami menghapus logika berulang ke operator RxJS kustom, menambahkan skrip untuk membuat keadaan kosong, menggabungkan kedua sumber negara menjadi satu aliran dengan operator gabungan dan membuat formulir untuk mengedit, yang akan kita bahas nanti: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  Ini semua yang harus dilakukan dalam komponen wadah.  Dan kami menempatkan celengan sebagai cara pertama untuk memanggil deteksi perubahan pada komponen OnPush - pipa async.  Ini akan bermanfaat bagi kita lebih dari sekali. <br><br><a name="presentation"></a><h2>  Mendistribusikan Status ke hierarki komponen OnPush </h2><br>  Saat Anda perlu menampilkan status kompleks, kami membuat hierarki komponen kecil - ini adalah cara kami menangani kompleksitas. <br><br>  Sebagai aturan, komponen dibagi ke dalam hierarki yang mirip dengan hirarki data, dan setiap komponen menerima sepotong datanya sendiri melalui parameter Input untuk menampilkannya dalam templat. <br><br>  Karena kita akan mengimplementasikan semua komponen sebagai OnPush, mari kita menyimpang sejenak dan membahas apa itu dan bagaimana Angular bekerja dengan komponen OnPush.  Jika Anda sudah tahu materi ini - silakan gulir ke bagian akhir. <br><br>  Selama kompilasi aplikasi, Angular menghasilkan detektor perubahan kelas khusus untuk setiap komponen, yang "mengingat" semua binding yang digunakan dalam templat komponen.  Pada waktu berjalan, kelas yang dihasilkan mulai memeriksa ekspresi yang tersimpan dengan setiap loop deteksi perubahan.  Jika centang menunjukkan bahwa hasil dari ekspresi apa pun telah berubah, maka Angular menggambar ulang komponen. <br><br>  Secara default, Angular tidak tahu apa-apa tentang komponen kami dan tidak dapat menentukan komponen mana yang akan terpengaruh, misalnya, setTimeout yang baru saja dipicu atau permintaan AJAX yang telah berakhir.  Oleh karena itu, ia terpaksa memeriksa seluruh aplikasi secara harfiah untuk setiap peristiwa di dalam aplikasi - bahkan jendela gulir sederhana berulang kali memicu deteksi perubahan untuk seluruh hierarki komponen aplikasi. <br><br>  Di sinilah letak sumber masalah kinerja potensial - semakin kompleks templat komponen, semakin sulit pemeriksaan detektor perubahan.  Dan jika ada banyak komponen dan pemeriksaan sering dijalankan, maka perubahan deteksi mulai membutuhkan waktu yang cukup lama. <br><br>  Apa yang harus dilakukan <br><br>  Jika komponen tidak tergantung pada efek global (omong-omong, lebih baik untuk merancang komponen dengan cara ini), maka keadaan internalnya ditentukan oleh: <br><br><ul><li>  Parameter input ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@</a> Input); </li><li>  Peristiwa yang terjadi di komponen itu sendiri ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@Output</a> ). </li></ul><br>  Kami akan menunda titik kedua untuk saat ini dan menganggap bahwa keadaan komponen kami hanya bergantung pada parameter Input. <br><br>  Jika semua parameter Input komponen adalah objek yang tidak dapat diubah, maka kita dapat menandai komponen sebagai OnPush.  Kemudian, sebelum menjalankan deteksi perubahan, Angular akan memeriksa apakah tautan ke parameter Input komponen telah berubah sejak pemeriksaan sebelumnya.  Dan, jika mereka tidak berubah, maka Angular akan melewatkan deteksi perubahan untuk komponen itu sendiri dan semua komponen anaknya. <br><br>  Jadi, jika kita membangun seluruh aplikasi kita sesuai dengan strategi OnPush, kita akan menghilangkan seluruh kelas masalah kinerja dari awal. <br><br>  Karena Status dalam aplikasi kita sudah tidak dapat diubah, objek yang tidak dapat diubah juga ditransfer ke parameter Input komponen anak.  Artinya, kami siap mengaktifkan OnPush untuk komponen anak dan mereka akan merespons perubahan status. <br>  Sebagai contoh, ini adalah <a href="">komponen</a> <a href="">readonly-info.component</a> dan <a href="">nested-items.component</a> <br><br>  Sekarang mari kita lihat bagaimana menerapkan perubahan dalam keadaan komponen dalam paradigma OnPush. <br><br><a name="output"></a><h2>  Bicaralah dengan Angular tentang kondisi Anda </h2><br>  Status presentasi - ini adalah parameter yang bertanggung jawab untuk penampilan komponen: memuat indikator, tanda visibilitas elemen atau aksesibilitas ke pengguna dari satu atau tindakan lain, terpaku dari tiga bidang ke satu baris, nama lengkap pengguna, dll. <br><br>  Setiap kali status presentasi suatu komponen berubah, kita harus memberi tahu Angular agar dapat menampilkan perubahan pada UI. <br><br>  Bergantung pada apa sumber status komponen, ada beberapa cara untuk memberi tahu Angular. <br><br><h4>  Keadaan presentasi, dihitung berdasarkan parameter Input </h4><br>  Ini adalah opsi termudah.  Kami menempatkan logika perhitungan status presentasi di kait ngOnChanges.  Ubah deteksi akan mulai dengan mengubah @ Input-parameter.  Dalam demo, ini hanya <a href="">baca-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Semuanya sangat sederhana, tetapi ada satu hal yang harus diperhatikan. <br><br>  Jika keadaan presentasi komponen kompleks, dan terutama jika beberapa bidangnya dihitung berdasarkan yang lain, juga dihitung oleh parameter Input, letakkan status komponen dalam kelas yang terpisah, buat tidak berubah dan buat kembali ngOnChanges setiap kali dimulai.  Dalam proyek demo, contohnya adalah kelas <a href="">ReadonlyInfoComponentTraits</a> .  Dengan menggunakan pendekatan ini, Anda melindungi diri dari kebutuhan untuk menyinkronkan data dependen ketika itu berubah. <br><br>  Pada saat yang sama, ada baiknya mempertimbangkan: mungkin komponen memiliki keadaan yang sulit karena fakta bahwa ada terlalu banyak logika di dalamnya.  Contoh khas adalah upaya dalam satu komponen agar sesuai dengan representasi untuk pengguna yang berbeda yang memiliki cara kerja yang sangat berbeda dengan sistem. <br><br><h4>  Komponen Acara Asli </h4><br>  Untuk komunikasi antara komponen aplikasi, kami menggunakan acara Output.  Ini juga merupakan cara ketiga untuk menjalankan deteksi perubahan.  Angular beranggapan bahwa jika suatu komponen menghasilkan suatu peristiwa, maka sesuatu dapat berubah dalam keadaannya.  Oleh karena itu, Angular mendengarkan semua peristiwa Output Komponen dan memicu deteksi perubahan ketika mereka terjadi. <br><br>  Dalam proyek demo, ini sepenuhnya sintetik, tetapi contohnya adalah komponen <a href="">submit-button.component</a> , yang melempar acara <i>FormSaved</i> .  Komponen wadah berlangganan ke acara ini dan menampilkan peringatan dengan pemberitahuan. <br><br>  Gunakan acara Output untuk tujuan yang dimaksudkan, yaitu, membuatnya untuk komunikasi dengan komponen induk, dan bukan untuk memicu deteksi perubahan.  Kalau tidak, kemungkinan, setelah berbulan-bulan dan bertahun-tahun, tidak ingat mengapa acara ini tidak perlu bagi siapa pun di sini, dan menghapusnya, merusak segalanya. <br><br><h4>  Perubahan komponen pintar </h4><br>  Kadang-kadang keadaan komponen ditentukan oleh logika kompleks: panggilan layanan yang tidak serempak, menghubungkan ke soket web, memeriksa berjalan melalui setInterval, tetapi Anda tidak pernah tahu apa lagi.  Komponen semacam itu disebut komponen pintar. <br><br>  Secara umum, komponen yang kurang pintar dalam aplikasi yang bukan komponen wadah, semakin mudah untuk hidup.  Tetapi kadang-kadang Anda tidak dapat melakukannya tanpa mereka. <br><br>  Cara paling sederhana untuk mengaitkan keadaan komponen cerdas dengan deteksi perubahan adalah dengan mengubahnya menjadi Observable dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pipa async yang</a> sudah dibahas di atas.  Misalnya, jika sumber perubahan adalah panggilan layanan atau status formulir reaktif, maka ini adalah Observable yang sudah jadi.  Jika keadaan terbentuk dari sesuatu yang lebih kompleks, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fromPromise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">websocket</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">timer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interval</a> dari komposisi RxJS.  Atau hasilkan aliran sendiri menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subjek</a> . <br><br><h4>  Jika tidak ada opsi yang cocok </h4><br>  Dalam kasus di mana tidak ada dari tiga metode yang sudah dipelajari yang cocok, kami masih memiliki opsi antipeluru - menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ChangeDetectorRef</a> secara langsung.  Kita berbicara tentang metode detectChanges dan markForCheck dari kelas ini. <br><br>  Dokumentasi yang komprehensif menjawab semua pertanyaan, jadi kami tidak akan memikirkannya.  Tetapi perhatikan bahwa penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ChangeDetectorRef</a> harus dibatasi pada kasus di mana Anda memahami dengan jelas apa yang Anda lakukan, karena ini masih merupakan dapur internal Angular. <br><br>  Selama ini kami hanya menemukan beberapa kasus di mana metode ini mungkin diperlukan: <br><br><ol><li>  Pekerjaan manual dengan deteksi perubahan - digunakan dalam implementasi komponen tingkat rendah dan hanya "Anda jelas mengerti apa yang Anda lakukan". </li><li>  Hubungan kompleks antara komponen - misalnya, ketika Anda perlu membuat tautan ke komponen dalam templat dan meneruskannya sebagai parameter ke komponen lain yang terletak lebih tinggi dalam hierarki atau bahkan di cabang lain dari hierarki komponen.  Kedengarannya rumit?  Begitulah.  Dan lebih baik untuk hanya memperbaiki kode seperti itu, karena itu akan membawa rasa sakit tidak hanya dengan deteksi perubahan. </li><li>  Kekhasan perilaku Angular itu sendiri - misalnya, saat menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ControlValueAccessor</a> kustom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> Anda mungkin menemukan bahwa nilai kontrol diubah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh Angular secara tidak sinkron</a> dan perubahan tidak diterapkan ke siklus deteksi perubahan yang diinginkan. </li></ol><br>  Sebagai contoh penggunaan dalam aplikasi demo, ada kelas dasar <a href="">OnPushControlValueAccessor</a> , yang memecahkan masalah yang dijelaskan dalam paragraf terakhir.  Juga dalam proyek ini ada pewaris kelas ini - kustom <a href="">radio-button.component</a> . <br><br>  Sekarang kita telah membahas keempat cara untuk menjalankan deteksi perubahan dan opsi implementasi OnPush untuk ketiga jenis komponen: wadah, cerdas, presentasi.  Kami melewati titik akhir - mengedit data dengan formulir reaktif. <br><br><a name="form"></a><h2>  Pengeditan data terenkapsulasi </h2><br>  Bentuk reaktif memiliki sejumlah keterbatasan, tetapi tetap ini adalah salah satu hal terbaik yang terjadi di ekosistem Angular. <br><br>  Pertama-tama, mereka merangkum bekerja dengan baik dengan negara dan menyediakan semua alat yang diperlukan untuk menanggapi perubahan secara reaktif. <br><br>  Bahkan, bentuk reaktif adalah semacam toko mini yang merangkum pekerjaan dengan negara: data dan status dinonaktifkan / valid / tertunda. <br><br>  Tetap bagi kami untuk mendukung enkapsulasi ini sebanyak mungkin dan menghindari pencampuran logika presentasi dan logika bentuk. <br><br>  Dalam aplikasi demo, Anda dapat melihat <a href="">kelas formulir individual</a> yang merangkum spesifik pekerjaan mereka: validasi, membuat formGroup anak, bekerja dengan keadaan dinonaktifkan bidang input. <br><br>  Kami membuat formulir root dalam komponen wadah pada saat waktu dimuat, dan dengan setiap negara reboot, formulir dibuat kembali.  Ini bukan prasyarat, tetapi dengan cara ini kita dapat yakin bahwa tidak ada akumulasi efek dalam bentuk logika yang tersisa dari keadaan dimuat sebelumnya. <br><br>  Di dalam formulir itu sendiri, kami membangun kontrol dan "mendorong" data yang berasal dari mereka, mengubahnya dari kontrak Negara ke kontrak Model.  Struktur formulir, sejauh mungkin, cocok dengan kontrak model.  Akibatnya, properti nilai dari formulir memberi kami model yang siap pakai untuk mengirim ke backend. <br><br>  Jika di masa depan kondisi struktur model atau perubahan, kita akan mendapatkan kesalahan kompilasi naskah tepat di tempat kita perlu menambahkan / menghapus bidang, yang sangat nyaman. <br><br>  Juga, jika keadaan dan objek model memiliki struktur yang benar-benar identik, pengetikan struktural yang digunakan dalam naskah ketik menghilangkan kebutuhan untuk membangun pemetaan yang tidak bermakna satu sama lain. <br><br>  Total, bentuk logika diisolasi dari logika presentasi dalam komponen dan hidup "dengan sendirinya", tanpa meningkatkan kompleksitas aliran data aplikasi kita secara keseluruhan. <br><br>  Itu hampir semuanya.  Ada kasus perbatasan yang tersisa ketika kami tidak dapat mengisolasi logika formulir dari aplikasi lainnya: <br><br><ol><li>  Perubahan bentuk yang mengarah ke perubahan status presentasi - misalnya, visibilitas blok data tergantung pada nilai yang dimasukkan.  Kami menerapkannya dalam komponen dengan berlangganan untuk membentuk acara.  Anda dapat melakukan ini melalui sifat-sifat abadi yang dibahas sebelumnya. </li><li>  Jika Anda memerlukan validator asinkron yang memanggil backend, kami membuat AsyncValidatorFn dalam komponen dan meneruskannya ke konstruktor formulir, bukan layanan. </li></ol><br>  Dengan demikian, semua "batas" logika tetap di tempat yang paling menonjol - dalam komponen. <br><br><h2>  Kesimpulan </h2><br>  Mari kita simpulkan apa yang kita dapatkan dan poin lain apa yang ada untuk studi dan pengembangan. <br><br>  Pertama-tama, pengembangan strategi OnPush memaksa kita untuk hati-hati merancang aliran data aplikasi, karena sekarang kita mendikte aturan permainan ke Angular, dan bukan dia. <br><br>  Ada dua konsekuensi dari situasi ini. <br><br>  Pertama, kami mendapatkan kontrol yang menyenangkan atas aplikasi tersebut.  Tidak ada lagi sihir yang “entah bagaimana berhasil”.  Anda jelas mengetahui apa yang terjadi pada waktu tertentu dalam aplikasi Anda.  Intuisi secara bertahap berkembang, yang memungkinkan Anda untuk memahami alasan bug yang ditemukan, bahkan sebelum Anda membuka kode. <br><br>  Kedua, sekarang kita harus menghabiskan lebih banyak waktu merancang aplikasi, tetapi hasilnya akan selalu menjadi yang paling "langsung", dan karena itu, solusi paling sederhana.  Ini jelas membawa ke nol kemungkinan situasi di mana, ketika aplikasi tumbuh, itu menjadi rakasa kompleksitas yang sangat besar, para pengembang telah kehilangan kendali atas kompleksitas ini dan pengembangan sekarang lebih mirip ritual mistis. <br><br>  Kompleksitas yang terkontrol dan tidak adanya "sihir" mengurangi kemungkinan timbulnya seluruh kelas masalah, misalnya, dari pembaruan data siklus atau akumulasi efek samping.  Sebagai gantinya, kami menghadapi masalah yang sudah terlihat selama pengembangan, ketika aplikasi tidak berfungsi.  Dan terpaksa, Anda harus membuat aplikasi berfungsi sederhana dan jelas. <br><br>  Kami juga menyebutkan efek yang baik pada kinerja.  Sekarang, menggunakan alat yang sangat sederhana, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">profiler.timeChangeDetection</a> , kita dapat memeriksa kapan saja bahwa aplikasi kita masih dalam kondisi yang baik. <br><br>  Juga sekarang adalah dosa untuk tidak mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menonaktifkan NgZone</a> .  Pertama, ini memungkinkan Anda untuk tidak memuat seluruh pustaka saat startup aplikasi.  Kedua, itu akan menghapus cukup banyak sihir dari aplikasi Anda. <br><br>  Di situlah kita mengakhiri cerita kita. <br><br>  Kami akan menghubungi Anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426819/">https://habr.com/ru/post/id426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426809/index.html">Zeev Surasky: Masa Depan Zend Engine dan Zend Framework</a></li>
<li><a href="../id426811/index.html">Parkour, tarian dan pekerjaan konstruksi dari Boston Dynamics</a></li>
<li><a href="../id426813/index.html">? Skype telah menjadi sangat membosankan ... dan produk yang memungkinkan Anda mendapatkan akses penuh ke sistem Anda? Apakah ada harapan?</a></li>
<li><a href="../id426815/index.html">Bagaimana cara mendapatkan hibah pengembangan proyek jika Anda seorang siswa yang miskin? Dan apakah itu sepadan</a></li>
<li><a href="../id426817/index.html">CommuniGate Pro Private Key dan Web API</a></li>
<li><a href="../id426821/index.html">Cara mengatur CI / CD pada suatu proyek: dari mengatur tugas hingga mengatur pipa penempatan</a></li>
<li><a href="../id426825/index.html">Beberapa tips untuk freelancer</a></li>
<li><a href="../id426831/index.html">Percakapan yang tidak menyenangkan, herpetologis dan kejutan lengkap</a></li>
<li><a href="../id426835/index.html">Analisis komparatif dan terperinci tentang plugin caching untuk WordPress</a></li>
<li><a href="../id426837/index.html">Penyiaran video di situs Anda yang berfungsi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>