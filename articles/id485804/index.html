<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋 🎌 👩‍❤️‍👨 Dan lagi, CAPTCHA atau nginx juga tahu cara menyulam 😃 🤰🏿 🐽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Saya pergi ke Habr dan menemukan dalam draf sebuah artikel yang tidak dipublikasikan tentang captcha, saya ingin meresmikan dan menerb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dan lagi, CAPTCHA atau nginx juga tahu cara menyulam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485804/"><h2>  Pendahuluan </h2><br><p>  Saya pergi ke Habr dan menemukan dalam draf sebuah <a href="https://postgres.men/web/nginx/nginx-fast-captcha/">artikel yang</a> tidak dipublikasikan tentang captcha, saya ingin meresmikan dan menerbitkannya, tetapi memutuskan untuk menulis artikel baru dengan sedikit mengubah mekanisme dan alat yang digunakan.  Menurut pendapat saya itu akan berguna untuk membaca artikel lama, itu tidak akan lebih buruk. </p><br><p>  Tujuan utama dari penulisan artikel baru adalah bukan untuk menunjukkan mekanisme kerja lain, seberapa banyak untuk menunjukkan kemampuan nginx yang kadang-kadang benar-benar dilupakan, menganggapnya sebagai server proxy dangkal. </p><a name="habracut"></a><br><h2>  Ketentuan </h2><br><p>  Untuk mencegah bot mengunduh file, tes "captcha" digunakan. </p><br><p>  Saat membentuk formulir untuk lompatan file, gambar dengan kode dan distorsi tertentu dibuat untuk mempersulit pengenalan otomatisnya.  Ada juga penyimpanan untuk memperbaiki pasangan kode + kunci untuk verifikasi. </p><br><p>  Setelah konfirmasi formulir untuk mengunduh file dan memeriksa captcha untuk korespondensi kode, pengguna diberikan file atau tautan satu kali unik ke file yang dihasilkan.  Keunikan tautan juga dikendalikan oleh backend.  Pasangan kunci + kode juga dihapus untuk mencegah penggunaannya kembali. </p><br><p>  Ada proksi yang mengalihkan semua permintaan ke backend. </p><br><h2>  Masalahnya </h2><br><p> Pembuatan gambar yang kompleks adalah operasi yang membutuhkan banyak sumber daya, dan mengingat bahwa tidak semua kode yang ditampilkan digunakan.  Hal ini diperlukan untuk membuat mekanisme tertentu untuk melakukan cache gambar yang tidak digunakan agar dapat menampilkannya kepada pengguna lain. </p><br><p>  Kode dan kunci diperiksa oleh backend, tetapi ada kesulitan dengan mentransfer file besar melalui backend, satu kali tautan juga memerlukan pemeriksaan di tingkat backend, saya ingin menyingkirkan beban tambahan pada mereka. </p><br><h2>  Solusi </h2><br><h3>  Pilih fungsionalitas </h3><br><p>  Sebenarnya, captcha itu sendiri terdiri dari gambar dan kunci tertentu yang sesuai dengan kode pada gambar yang disimpan di backend.  Gambar tidak terlalu besar, dan kami menerjemahkannya ke Base64 dan memberikan salah satu bentuk: </p><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hidden"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"key"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ KEY }}"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Atau JSON: </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{ KEY }}"</span></span> } }</code> </pre> <br><p>  Jika kita memiliki sepotong formulir yang sedang dibentuk, maka kita dapat menggunakan <a href="http_ssi_module.html">SSI</a> untuk memasukkannya ke badan halaman, untuk ini kita mengaktifkan mode yang sesuai dalam konfigurasi nginx pada proxy: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ssi</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br><p>  Dan dalam kode halaman formulir kami masukkan: </p><br><pre> <code class="xml hljs">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"download"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"get"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/x/captcha/generate"--&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre><br><p>  Dengan demikian, kami telah mengalokasikan fungsi pemetaan captcha ke <i>lokasi</i> atau metode yang terpisah.  Sekarang Anda bisa melakukan caching. </p><br><blockquote>  Ya, mekanisme <i>Server Side Include (SSI)</i> hampir terlupakan, tetapi modul nginx untuknya lebih hidup daripada semua yang hidup dan bekerja dengan sangat cepat.  Dan omong-omong, jika proxy_pass_cache <i>cache</i> seluruh halaman, hasil dari <i>virtual</i> tidak akan di-cache, tetapi akan dieksekusi setiap kali diminta.  Ini memungkinkan Anda untuk membuat sisipan menjadi dinamis. </blockquote><br><h3>  CAPTCHA CAPTCHA </h3><br><p>  Untuk mengimplementasikan caching, kita perlu sesuatu yang cukup acak dan dikendalikan oleh jumlah opsi, variabel <i>$ request_id</i> cocok untuk peran ini - itu cukup acak dan heksadesimal, yaitu, dengan memilih bagian tertentu dari variabel ini, Anda dapat membatasi jumlah elemen cache hingga 16 ^ n, di mana n - jumlah karakter yang perlu kita ambil dari variabel.  Jadi: </p><br><p>  Tentukan zona cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>;</code> </pre> <br><p>  Penting untuk menentukan nilai n yang kita pilih, masing-masing, parameternya bergantung pada ini: </p><br><ul><li>  level = 1: 2 </li><li>  max_size = 128m </li><li>  keys_zone = captcha: 10m </li></ul><br><p>  Jadi itu sudah cukup untuk semuanya, tetapi tidak ada yang berlebihan.  Selanjutnya, kami menentukan kunci cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } ...</code> </pre> <br><p>  <i>Variabel $ captcha_salt</i> masih berguna bagi kami, tetapi sekarang ia melindungi terhadap kemungkinan persimpangan kunci.  Saya memilih n sebagai 4, yang berarti 16 ^ 4 slot cache, dengan rata-rata <i>2kb</i> dialokasikan untuk setiap slot dari total ukuran cache ( <i>max_size = 128m</i> ), yang seharusnya cukup, jika tidak, Anda perlu menaikkan ukuran maksimum. </p><br><p>  Membuat <i>lokasi yang</i> sesuai </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; }</code> </pre> <br><p>  Respons backend "baik" akan di-cache hampir selamanya, sisanya tidak akan di-cache.  Dan ya, Anda dapat langsung menyoroti fungsi bekerja dengan captcha di layanan terpisah. </p><br><blockquote>  Omong-omong, mekanisme serupa dapat digunakan untuk menghasilkan dinamika semu ketika pengguna menekan F5 dan setiap kali "gambar" acak baru ditampilkan kepadanya.  Dalam hal ini, backend praktis tidak dimuat. </blockquote><br><p>  Kita juga perlu mengatur ulang cache yang sesuai saat memeriksa formulir, jadi backend, antara lain, harus memberikan nilai <i>cache_key</i> untuk meneruskannya kembali ke formulir sebagai bidang <i>tersembunyi</i> .  Sayangnya, direktif <i>proxy_cache_purge</i> hanya tersedia dalam versi komersial.  Tidak masalah, ada modul <a href="https://github.com/FRiCKLE/ngx_cache_purge">cache_purge</a> pihak <a href="https://github.com/FRiCKLE/ngx_cache_purge">ketiga</a> , yang mungkin sedikit lebih sederhana, tetapi cukup bagi kita.  Jadi, <i>lokasi</i> pembilasan cache: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/cache/purge { internal; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_cache_key</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Ini memiliki arahan <i>internal</i> , karena kita tidak akan menggunakannya untuk umum.  Dan untuk memanggil <i>lokasi</i> ini <i>,</i> kita akan menggunakan arahan <i>cermin</i> dari modul <a href="http_mirror_module.html">http_mirror_module</a> : </p><br><p>  Artinya, kami membuat permintaan paralel untuk mereset cache dengan kunci variabel <i>$ arg_cache_key</i> , yang dikirimkan dalam formulir.  Selanjutnya, cukup proksi permintaan ke backend kami di mana sisa pemrosesan dilakukan. </p><br><h3>  Cara Optimasi Berduri </h3><br><p>  Di sini, sebenarnya, saya ingin mengembangkan sebuah topik: bagaimana memisahkan verifikasi kode captcha dan pengembalian file.  Cara mencegah cache agar tidak dicuci dengan permintaan yang salah.  Kemudian untuk mengoptimalkan lebih banyak dan lebih banyak, tetapi semuanya bermuara pada kenyataan bahwa secara umum kita tidak lagi membutuhkan backend ... sama sekali ... karena kita sudah memiliki segalanya. </p><br><p>  Tugas yang tetap dengan server dalam hal verifikasi captcha sebenarnya memeriksa kode kunci + dan menghapus pasangan ini dari repositori.  Memeriksa kode kunci + dapat berupa perbandingan sederhana dari jumlah md5 dengan kunci.  Untuk ini, sebuah modul sudah cukup bagi kami: <a href="http_secure_link_module.html">http_secure_link_module</a> .  Artinya, kuncinya dapat direpresentasikan sebagai rumus: </p><br> <code>key = md5_baseurl( salt + code )</code> <br> <p>  Pada saat yang sama, mengikat slot cache (kunci cache) tidak akan merugikan kami, kami menambahkannya: </p><br> <code>key = md5_baseurl( salt + code + cache_key )</code> <br> <p>  Kami memiliki garam - ini adalah variabel <i>$ captcha_salt</i> (jadi berguna), tetapi menjaga garam di dua tempat backend dan proxy buruk, jadi mari kita lakukan ini: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Dan biarkan backend pergi ke proxy untuk mendapatkan garam. </p><br><p>  Pertanyaannya tetap pada repositori, tempat kami menyimpan pasangan kunci + kode yang perlu dibersihkan.  Untuk melakukan ini, mekanisme caching yang telah kami implementasikan cocok untuk kami.  Satu-satunya hal adalah bahwa kita tidak memproses hasil <i>cache_purge dengan cara apa pun</i> , tetapi hanya mencerminkan permintaan untuk itu, tetapi ini dapat diperbaiki.  Dan ya, itu dibenarkan menggunakan kunci cache saat membuat kunci captcha. </p><br><h3>  Pemeriksaan kode </h3><br><p>  Tulis ulang unduhan file <i>lokasi</i> : </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; }</code> </pre> <br><p>  Saya melewati parameter yang diperlukan dengan header.  Ini opsional, tetapi lebih nyaman bagi saya.  Kami proksi pemrosesan ke lokasi lokal dari cek captcha.  Selain itu, <i>konteks = unduhan</i> dilewati, sehingga dalam handler kita dapat menghasilkan satu atau hasil lain bergantung padanya.  Dalam hal ini, pawang dapat kembali kepada kami: </p><br><ul><li>  403 - kesalahan verifikasi kode.  Sebenarnya, oleh karena itu, <i>proxy_intercept_errors diaktifkan</i> dan lokasi dideklarasikan untuk pengalihan jika terjadi kesalahan; </li><li>  404 - kesalahan pembersihan cache.  Modul <i>cache_purge</i> jika tidak ada dalam cache dengan kunci yang mengembalikan 404; </li><li>  200 + <i>Accel-Redirect</i> - di <i>lokasi</i> unggahan file, kalau-kalau cek captcha baik-baik saja.  Dalam kasus kami, ini akan menjadi <i>X-Accel-Redirect: / store / file</i> </li></ul><br><blockquote>  Jika <i>error_page</i> dapat menangani kode <i>2XX</i> , maka orang dapat melakukannya sendiri.  Kalau tidak, Anda harus menggunakan mekanisme <i>Accel-Redirect</i> .  Jika Anda benar-benar ingin, Anda dapat memisahkan penangan kesalahan 403 dan 404; </blockquote><br><p>  Membuat kesalahan <i>lokasi</i> sederhana: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; }</code> </pre> <br><p>  Anda dapat mengembalikan apa pun di lokasi ini, tergantung pada kebutuhan Anda. </p><br><p>  Kami membuat lokasi unggahan file: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; }</code> </pre> <br><p>  Pertama, penting bahwa itu <i>internal</i> - ini berarti Anda tidak akan dapat mengunduh file langsung melalui itu, hanya melalui pengalihan.  Itu juga dapat dimodifikasi tergantung pada kebutuhan dan tidak memberikan file lokal, tetapi untuk proksi permintaan untuk layanan penyimpanan file. </p><br><p>  Lokasi berikut yang kami miliki untuk verifikasi captcha: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; }</code> </pre> <br><p>  Ini memiliki 2 blok: verifikasi kode dan proksi lebih lanjut untuk menghapus cache.  Pada saat yang sama, jika pemeriksaan kode tidak lulus, maka segera kembali 403 (teks tidak penting, karena tidak digunakan lebih lanjut). </p><br><p>  Proxy ke <i>/ x / captcha / purge</i> akan mengembalikan 2 pilihan jawaban: </p><br><ul><li>  200 + <i>Accel-Redirect</i> - setelah pembilasan cache berhasil.  Redirect akan ke <i>X-Accel-Redirect: / x / captcha / check / ok</i> ; </li><li>  404 - jika tidak ada yang dibersihkan.  Hasil ini akan diteruskan ke <i>/ unduh di atas</i> dan akan diproses di dalamnya <i>error_page</i> ; </li></ul><br><p>  Penangan terpisah untuk respons positif dari <i>/ x / captcha / purge</i> dibuat karena fakta bahwa pertama-tama kita perlu mencapai tingkat proxy yang lebih tinggi, dan bukan antara <i>/ unduh</i> dan <i>/ x / captcha / check</i> .  Kedua, akan menyenangkan untuk memberikan jawaban positif Anda mengenai konteksnya. </p><br><p>  Mari kita mulai dengan penangan respons positif: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; }</code> </pre> <br><p>  Sebenarnya, tergantung pada nilai variabel <i>$ http_x_context</i> (header <i>X-Context</i> ), kita dapat menentukan <i>Accel-Redirect yang</i> akan merespons dengan <i>/ x / captcha / check</i> .  Ini berarti Anda dapat menggunakan mekanisme ini di tempat lain selain mengunduh file. </p><br><p>  Menghapus cache cukup sederhana: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; }</code> </pre> <br><p>  Secara umum, itu saja, pada akhirnya kami mendapat konfigurasi nginx berikut: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>; <span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; } }</code> </pre> <br><p>  Apa yang harus Anda perhatikan: <br></p><ul><li>  Accel-Redirect hanya berfungsi ketika status responsnya 2XX.  Benar, sayangnya, tidak ada yang ditulis tentang ini di mana pun, dan penganut nginx tidak setuju; </li><li>  <i>Lokasi</i> pribadi tutup <i>memungkinkan 127.0.0.1;</i>  <i>tolak semua;</i>  baik <i>internal;</i>  , tergantung pada apakah kita sampai ke <i>lokasi</i> ini melalui <i>proxy_pass</i> , atau melalui <i>Accel-Redirect</i> ; </li><li>  Semua <i>lokasi yang</i> terkait dengan captcha disorot di <i>/ x / capcha / ...</i> sehingga dimungkinkan untuk membentuk layanan mikro; </li></ul><br><p>  Untuk lebih jelasnya, saya juga menggambar diagram karya: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/245/8bc/6c8/2458bc6c8defdbbf6f6f0bcfccb0f05a.png" alt="gambar"><br><h2>  Ringkasan </h2><br><p>  Akibatnya, dari backend kita hanya perlu secara langsung menghasilkan gambar dan kode untuk itu.  Nginx dapat dengan mudah menangani sisanya.  Tentu saja, ini adalah operasi logis yang relatif sederhana, namun demikian, ini akan secara signifikan mempercepat pekerjaan dan mengurangi beban di backend.  Dan faktanya, kami tidak menggunakan mekanisme yang tidak biasa, tetapi hanya: </p><br><ul><li>  proxy_cache; </li><li>  Pengalihan-Accel </li><li>  error_page; </li><li>  secure_link </li><li>  cache_purge; </li></ul><br><p>  Sisanya adalah konstruksi rantai logis yang benar. </p><br><p>  Kami juga menghapus repositori backend sementara untuk kode dan tautan satu kali.  Namun, mereka membuat elemen wajib dari sistem nginx, meningkatkan bobot fungsionalnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485804/">https://habr.com/ru/post/id485804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485786/index.html">Pekerjaan rumah aritmatika</a></li>
<li><a href="../id485790/index.html">Wawancara: harapan vs kenyataan</a></li>
<li><a href="../id485792/index.html">Ivan Lilekvist dan Kim Dotkom, sebuah wawancara besar: kisah Megaupload, ekstradisi ke Amerika Serikat, kebebasan, bitcoin. Bagian 2</a></li>
<li><a href="../id485794/index.html">Apakah Anda mengembangkan .NET Core? Ayo pergi ke Ubuntu, saya sudah menyiapkan semuanya</a></li>
<li><a href="../id485800/index.html">Digitalisasi vs. Otomasi</a></li>
<li><a href="../id485806/index.html">Coronavirus: dari SARS hingga 2019-nCoV</a></li>
<li><a href="../id485810/index.html">Elixir menghubungkan waktu kompilasi</a></li>
<li><a href="../id485812/index.html">7 tahapan pengujian evolusi di sebuah perusahaan</a></li>
<li><a href="../id485820/index.html">Orang yang Sangat Diserang: Cari tahu siapa target utama penjahat cyber di perusahaan Anda.</a></li>
<li><a href="../id485824/index.html">Cara membuat bot yang mengubah foto menjadi komik. Bagian tiga. Server + GPU hosting gratis tanpa server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>