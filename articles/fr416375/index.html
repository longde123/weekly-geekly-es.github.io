<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîô üåô üëö Bases de JavaScript pour les d√©butants üîÆ üòù ‚ôøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mat√©riel, dont nous publions la traduction aujourd'hui, est d√©di√© aux bases de JavaScript et est destin√© aux programmeurs d√©butants. Il peut √™tre c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases de JavaScript pour les d√©butants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416375/">  Le mat√©riel, dont nous publions la traduction aujourd'hui, est d√©di√© aux bases de JavaScript et est destin√© aux programmeurs d√©butants.  Il peut √™tre consid√©r√© comme une petite r√©f√©rence aux constructions de base de JS.  Ici, en particulier, nous parlerons du syst√®me de type de donn√©es, des variables, des tableaux, des fonctions, des prototypes d'objets et de certaines autres caract√©ristiques du langage. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/my/cj/zq/mycjzqfpfohnkk9vnefgsl915vm.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Types de donn√©es primitifs</font> </h2><br>  Les types de donn√©es primitifs suivants sont disponibles en JavaScript: <code>number</code> , <code>boolean</code> , <code>string</code> , <code>undefined</code> , <code>null</code> .  Il convient de noter tout de suite que, lorsque vous travaillez avec des types de donn√©es primitifs, par exemple, avec des litt√©raux de cha√Æne, nous, m√™me sans effectuer une conversion explicite, serons en mesure d'acc√©der √† leurs m√©thodes et propri√©t√©s.  Le point ici est que lorsque vous essayez d'effectuer de telles op√©rations, les litt√©raux sont automatiquement √©quip√©s du wrapper d'objet appropri√©. <br><br><h3>  <font color="#3AC1EF">‚ñç Num√©ros</font> </h3><br>  JavaScript n'a qu'un seul type de nombre - ce sont les nombres √† virgule flottante double pr√©cision.  Cela conduit au fait que les r√©sultats du calcul de certaines expressions sont arithm√©tiquement incorrects.  Vous savez peut-√™tre d√©j√† qu'en JS la valeur de l'expression <code>0.1 + 0.2</code> pas <code>0.3</code> .  En m√™me temps, lorsque vous travaillez avec des entiers, de tels probl√®mes ne sont pas observ√©s, c'est-√†-dire <code>1 + 2 === 3</code> . <br><br>  JavaScript a un objet <code>Number</code> , qui est un wrapper d'objet pour les valeurs num√©riques.  Les objets de type <code>Number</code> peuvent √™tre cr√©√©s soit √† l'aide d'une commande de la forme <code>var a = new Number(10)</code> , soit vous pouvez compter sur le comportement automatique du syst√®me d√©crit ci-dessus.  Cela, en particulier, vous permet d'appeler des m√©thodes stock√©es dans <code>Number.prototype</code> telles <code>Number.prototype</code> sont appliqu√©es aux litt√©raux num√©riques: <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">123</span></span>).toString();  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> (<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span></code> </pre> <br>  Il existe des fonctions globales con√ßues pour convertir les valeurs d'autres types en type num√©rique.  C'est <code>parseInt()</code> , <code>parseFloat()</code> et la construction <code>Number()</code> , qui dans ce cas agit comme une fonction normale qui effectue la conversion de type: <br><br><pre> <code class="hljs julia">parseInt(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)       //<span class="hljs-number"><span class="hljs-number">1</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)    //<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>) //<span class="hljs-number"><span class="hljs-number">1.234</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)         //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>)     //<span class="hljs-number"><span class="hljs-number">1.234</span></span></code> </pre> <br>  Si, au cours de l'op√©ration avec des nombres, quelque chose est obtenu qui n'est pas un nombre (lors de certains calculs ou lorsque vous essayez de convertir quelque chose en nombre), JavaScript ne g√©n√©rera pas d'erreur, mais pr√©sentera le r√©sultat d'une telle op√©ration comme la valeur <code>NaN</code> (Not-a-Number, pas un nombre).  Afin de v√©rifier si une certaine valeur est <code>NaN</code> , vous pouvez utiliser la fonction <code>isNaN()</code> . <br><br>  Les op√©rations arithm√©tiques JS fonctionnent de mani√®re assez famili√®re, mais vous devez faire attention au fait que l'op√©rateur <code>+</code> peut effectuer l'ajout de nombres et la concat√©nation de cha√Ænes. <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>      //<span class="hljs-number"><span class="hljs-number">2</span></span> "1" + "1"  //"11" <span class="hljs-number"><span class="hljs-number">1</span></span> + "1"    //"11"</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçCha√Ænes</font> </h3><br>  Les cha√Ænes JavaScript sont des cha√Ænes de caract√®res Unicode.  Les litt√©raux de cha√Æne sont cr√©√©s en entourant le texte √† placer entre guillemets doubles ( <code>""</code> ) ou simples ( <code>''</code> ).  Comme d√©j√† mentionn√©, lorsque nous travaillons avec des litt√©raux de cha√Æne, nous pouvons compter sur l'encapsuleur d'objet correspondant, dont le prototype a de nombreuses m√©thodes utiles, parmi lesquelles <code>substring()</code> , <code>indexOf()</code> , <code>concat()</code> . <br><br><pre> <code class="hljs pgsql">"text".substring(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) //ex "text".indexOf(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)   //<span class="hljs-number"><span class="hljs-number">2</span></span> "text".concat(" end") //<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Les cha√Ænes, comme les autres valeurs primitives, sont immuables.  Par exemple, la m√©thode <code>concat()</code> ne modifie pas une cha√Æne existante, mais en cr√©e une nouvelle. <br><br><h3>  <font color="#3AC1EF">‚ñçValeurs logiques</font> </h3><br>  Le type de donn√©es logique dans JS est repr√©sent√© par deux valeurs - <code>true</code> et <code>false</code> .  Le langage peut convertir automatiquement diverses valeurs en un type de donn√©es logique.  Ainsi, false, en plus de la valeur logique <code>false</code> , sont les valeurs <code>null</code> , <code>undefined</code> , <code>''</code> (cha√Æne vide), <code>0</code> et <code>NaN</code> .  Tout le reste, y compris les objets, repr√©sente de v√©ritables significations.  Au cours des op√©rations logiques, tout ce qui est consid√©r√© comme vrai est converti en <code>true</code> et tout ce qui est consid√©r√© comme faux est converti en <code>false</code> .  Jetez un ≈ìil √† l'exemple suivant.  Conform√©ment aux principes ci-dessus, une cha√Æne vide sera convertie en <code>false</code> et √† la suite de cette ex√©cution de code, la cha√Æne <code>This is false</code> arrivera √† la console. <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">text</span></span>) { console.log("This is true"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log("This is false"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Les objets</font> </h2><br>  Les objets sont des structures dynamiques constitu√©es de paires cl√©-valeur.  Les valeurs peuvent avoir des types de donn√©es primitifs, peuvent √™tre des objets ou des fonctions. <br><br>  Les objets sont plus faciles √† cr√©er √† l'aide de la syntaxe litt√©rale de l'objet: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span>, <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre> <br>  Les propri√©t√©s d'un objet peuvent √™tre lues, ajout√©es, modifi√©es et supprim√©es √† tout moment.  Voici comment proc√©der: <br><br><ul><li>  Propri√©t√©s de lecture: <code>object.name, object[expression]</code> . </li><li>  √âcriture de donn√©es dans les propri√©t√©s (si la propri√©t√© en cours d'acc√®s n'existe pas, une nouvelle propri√©t√© avec la cl√© sp√©cifi√©e est ajout√©e): <code>object.name = value</code> , <code>object[expression] = value</code> . </li><li>  Suppression de propri√©t√©s: <code>delete object.name</code> , <code>delete object[expression]</code> . </li></ul><br>  Voici quelques exemples: <br><br><pre> <code class="hljs ruby">let obj = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   delete object.message; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  </code> </pre> <br>  Les objets du langage sont impl√©ment√©s sous forme de tables de hachage.  Une simple table de hachage peut √™tre cr√©√©e √† l'aide de la commande <code>Object.create(null)</code> : <br><br><pre> <code class="hljs pgsql">let french = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); french["yes"] = "oui"; french["no"]  = "non"; french["yes"];//"oui"</code> </pre> <br>  Si l'objet doit √™tre rendu immuable, vous pouvez utiliser la commande <code>Object.freeze()</code> . <br><br>  Pour parcourir toutes les propri√©t√©s d'un objet, vous pouvez utiliser la commande <code>Object.keys()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //   } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçComparaison des valeurs des types et objets primitifs</font> </h3><br>  Dans le travail pratique avec des valeurs primitives, vous pouvez, comme d√©j√† mentionn√©, les percevoir comme des objets qui ont des propri√©t√©s et des m√©thodes, bien qu'ils ne soient pas des objets.  Les valeurs primitives sont immuables, la structure interne des objets peut changer. <br><br><h2>  <font color="#3AC1EF">Variables</font> </h2><br>  En JavaScript, les variables peuvent √™tre d√©clar√©es √† l'aide des mots cl√©s <code>var</code> , <code>let</code> et <code>const</code> . <br><br>  En utilisant le mot-cl√© <code>var</code> , vous pouvez d√©clarer une variable et, si n√©cessaire, l'initialiser avec une certaine valeur.  Si la variable n'est pas initialis√©e, sa valeur n'est <code>undefined</code> .  Les variables d√©clar√©es √† l'aide du mot cl√© <code>var</code> ont une port√©e fonctionnelle. <br><br>  Le mot cl√© <code>let</code> est tr√®s similaire √† <code>var</code> , la diff√©rence est que les variables d√©clar√©es avec le mot cl√© <code>let</code> ont une port√©e de bloc. <br><br>  Les variables d√©clar√©es √† l'aide du mot cl√© <code>const</code> ont √©galement une port√©e de bloc qui, √©tant donn√© que les valeurs de ces variables ne peuvent pas √™tre modifi√©es, sera plus correctement appel√©e ¬´constantes¬ª.  Le mot-cl√© <code>const</code> , qui ¬´fige¬ª la valeur d'une variable d√©clar√©e en l'utilisant, peut √™tre compar√© √† la m√©thode <code>Object.freeze()</code> , qui ¬´fige¬ª les objets. <br><br>  Si une variable est d√©clar√©e en dehors d'une fonction, sa port√©e est globale. <br><br><h2>  <font color="#3AC1EF">Tableaux</font> </h2><br>  Les tableaux en JavaScript sont impl√©ment√©s √† l'aide d'objets.  Par cons√©quent, lorsque nous parlons de tableaux, nous discutons en fait d'objets similaires aux tableaux.  Vous pouvez travailler avec des √©l√©ments de tableau √† l'aide de leurs indices.  Les indices num√©riques sont convertis en cha√Ænes et utilis√©s comme noms pour acc√©der aux valeurs des √©l√©ments du tableau.  Par exemple, une construction de la forme <code>arr[1]</code> similaire √† une construction de la forme <code>arr['1']</code> , et les deux donneront acc√®s √† la m√™me valeur: <code>arr[1] === arr['1']</code> .  Conform√©ment √† ce qui pr√©c√®de, un tableau simple d√©clar√© par la commande <code>let arr = ['A', 'B', 'C']</code> est repr√©sent√© comme un objet de la forme suivante: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span> }</code> </pre> <br>  La suppression d'√©l√©ments de tableau √† l'aide de la commande de <code>delete</code> laisse des trous.  Pour √©viter ce probl√®me, vous pouvez utiliser la commande <code>splice()</code> , mais elle fonctionne lentement, car, apr√®s la suppression d'un √©l√©ment, elle d√©place les √©l√©ments restants du tableau, les d√©calant en fait au d√©but du tableau, vers la gauche. <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; delete arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; console.log(arr); // [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-type"><span class="hljs-type">empty</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>] console.log(arr.length); // <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Les m√©thodes de tableau facilitent l'impl√©mentation de structures de donn√©es telles que les piles et les files d'attente: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  let stack = []; stack.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] stack.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let last = stack.pop();  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] console.log(last);       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  let queue = []; queue.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] queue.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let first = queue.shift();/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/[2] console.log(first);      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Les fonctions</font> </h2><br>  Les fonctions en JavaScript sont des objets.  Les fonctions peuvent √™tre attribu√©es √† des variables, stock√©es dans des objets ou des tableaux, transmises en tant qu'arguments √† d'autres fonctions et renvoy√©es par d'autres fonctions. <br><br>  Il existe trois fa√ßons de d√©clarer des fonctions: <br><br><ul><li>  D√©claration de fonction classique (d√©claration de fonction ou d√©claration de fonction). </li><li>  L'utilisation d'expressions fonctionnelles (Function Expression), √©galement appel√©es litt√©raux fonctionnels (Function Literal). </li><li>  Utilisation de la syntaxe des fonctions fl√©ch√©es (fonction fl√®che). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç D√©claration de fonction classique</font> </h3><br>  Avec cette approche de d√©claration de fonctions, les r√®gles suivantes s'appliquent: <br><br><ul><li>  La fonction est le premier mot-cl√© d'une ligne de d√©claration de <code>function</code> . </li><li>  Un nom doit √™tre attribu√© aux fonctions. </li><li>  La fonction peut √™tre utilis√©e dans le code avant sa d√©claration en raison du m√©canisme qui place la d√©claration de la fonction au sommet de la port√©e dans laquelle elle est d√©clar√©e. </li></ul><br>  Voici √† quoi ressemble une d√©claration de fonction classique: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Expressions fonctionnelles</font> </h3><br>  Lors de l'utilisation d'expressions fonctionnelles, les √©l√©ments suivants doivent √™tre pris en compte: <br><br><ul><li>  Le mot cl√© de <code>function</code> n'est plus le premier mot d'une ligne de d√©claration de fonction. </li><li>  Un nom de fonction est facultatif.  Il est possible d'utiliser √† la fois des expressions fonctionnelles anonymes et nomm√©es. </li><li>  Les commandes pour appeler de telles fonctions doivent suivre les commandes pour leur d√©claration. </li><li>  Une telle fonction peut √™tre lanc√©e imm√©diatement apr√®s la d√©claration en utilisant la syntaxe de IIFE (Immediateely Invoked Function Expression - imm√©diatement appel√©e expression de fonction). </li></ul><br>  L'expression fonctionnelle ressemble √† ceci: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fonctions fl√®ches</font> </h3><br>  Les fonctions fl√©ch√©es, en fait, peuvent √™tre consid√©r√©es comme du ¬´sucre syntaxique¬ª pour cr√©er des expressions fonctionnelles anonymes.  Il convient de noter que ces fonctions n'ont pas leurs propres entit√©s <code>this</code> et <code>arguments</code> .  La d√©claration de la fonction fl√®che ressemble √† ceci: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = () = &gt; {};</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fa√ßons d'appeler des fonctions</font> </h3><br>  Les fonctions peuvent √™tre appel√©es de diff√©rentes mani√®res. <br><br><h4>  Appel de fonction normale </h4><br><pre> <code class="hljs lisp">doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Appel de fonction sous la forme d'une m√©thode objet </h4><br><pre> <code class="hljs markdown">theObject.doSomething(arguments) theObject[<span class="hljs-string"><span class="hljs-string">"doSomething"</span></span>](<span class="hljs-link"><span class="hljs-link">arguments</span></span>)</code> </pre> <br><h4>  Appel de fonction constructeur </h4><br><pre> <code class="hljs lisp">new doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Appel d'une fonction √† l'aide de la m√©thode apply () </h4><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.apply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[arguments]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.call</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>)</code> </pre> <br><h4>  Appel d'une fonction √† l'aide de la m√©thode bind () </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomethingWithObject = doSomething.bind(theObject); doSomethingWithObject();</code> </pre> <br>  Les fonctions peuvent √™tre appel√©es avec plus ou moins d'arguments que le nombre de param√®tres sp√©cifi√©s lors de leur d√©claration.  Au cours du travail de la fonction, les arguments "suppl√©mentaires" seront simplement ignor√©s (bien que la fonction y aura acc√®s), les param√®tres manquants obtiendront la valeur <code>undefined</code> . <br><br>  Les fonctions ont deux pseudo-param√®tres: <code>this</code> et <code>arguments</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Mot-cl√© ceci</font> </h3><br>  Le <code>this</code> repr√©sente le contexte d'une fonction.  La valeur qu'il pointe d√©pend de la fa√ßon dont la fonction a √©t√© appel√©e.  Voici les significations du mot <code>this</code> cl√© <code>this</code> fonction de la fa√ßon dont la fonction est appel√©e (elles sont d√©crites ci-dessus avec des exemples de code, dont les constructions sont utilis√©es ici): <br><br><ul><li>  L'appel de fonction habituel est <code>window</code> / <code>undefined</code> . </li><li>  Un appel de fonction sous la forme d'une m√©thode objet est <code>theObject</code> . </li><li>  Un appel de fonction sous la forme d'un constructeur est un nouvel objet. </li><li>  Appel d'une fonction √† l'aide de la m√©thode <code>apply()</code> - <code>theObject</code> . </li><li>  Appel d'une fonction √† l'aide de la m√©thode <code>bind()</code> - <code>theObject</code> . </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Arguments des mots cl√©s</font> </h3><br>  Le mot-cl√© <code>arguments</code> est un pseudo-param√®tre qui donne acc√®s √† tous les arguments utilis√©s pour appeler la fonction.  Il ressemble √† un tableau, mais pas √† un tableau.  En particulier, il n'a pas de m√©thodes de tableau. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reduceToSum(total, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum(){ let args = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Une alternative au mot-cl√© <code>arguments</code> est la nouvelle syntaxe pour les param√®tres restants.  Dans l'exemple suivant, <code>args</code> est un tableau contenant tout ce qui a √©t√© transmis √† la fonction lors de son appel. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3>  <font color="#3AC1EF">ReturnRetour op√©rateur</font> </h3><br>  Une fonction qui n'a pas de <code>return</code> retour renverra <code>undefined</code> .  En utilisant le mot-cl√© <code>return</code> , faites attention au fonctionnement du m√©canisme d'insertion automatique des points-virgules.  Par exemple, la fonction suivante renverra non pas un objet vide, mais une valeur <code>undefined</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } } getObject()</code> </pre> <br>  Afin d'√©viter un probl√®me similaire, le crochet ouvrant doit √™tre plac√© sur la m√™me ligne que la <code>return</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Typage dynamique</font> </h2><br>  JavaScript est un langage de frappe dynamique.  Cela signifie que des valeurs sp√©cifiques ont des types, mais pas des variables.  Pendant l'ex√©cution du programme, des valeurs de diff√©rents types peuvent √™tre √©crites dans la m√™me variable.  Voici un exemple de fonction qui fonctionne avec des valeurs de diff√©rents types: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ console.log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } log(<span class="hljs-number"><span class="hljs-number">1</span></span>); log("text"); log({message : "text"});</code> </pre> <br>  Pour conna√Ætre le type de donn√©es stock√©es dans une variable, vous pouvez utiliser l'op√©rateur <code>typeof()</code> : <br><br><pre> <code class="hljs lua">let n = <span class="hljs-number"><span class="hljs-number">1</span></span>; typeof(n);   //number let s = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; typeof(s);   //<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> let fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}; typeof(fn);  //<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mod√®le d'ex√©cution monothread</font> </h2><br>  Le runtime JavaScript est monothread.  Cela s'exprime notamment par l'impossibilit√© d'ex√©cuter simultan√©ment deux fonctions (si l'on ne tient pas compte des possibilit√©s d'ex√©cution de code asynchrone, que nous n'abordons pas ici).  Le runtime a une soi-disant file d'attente d'√©v√©nements, qui stocke une liste de t√¢ches qui doivent √™tre trait√©es.  Par cons√©quent, pour un sch√©ma d'ex√©cution JS √† un seul thread, le probl√®me des verrous de ressources mutuelles n'est pas typique, par cons√©quent, le m√©canisme de verrouillage n'est pas n√©cessaire ici.  Cependant, le code entrant dans la file d'attente d'√©v√©nements doit s'ex√©cuter rapidement.  En cas de surcharge de travail, dans l'application du navigateur, le thread principal, la page de l'application ne r√©pondra pas aux actions de l'utilisateur et le navigateur proposera de fermer cette page. <br><br><h2>  <font color="#3AC1EF">Gestion des exceptions</font> </h2><br>  JavaScript dispose d'un m√©canisme de gestion des exceptions.  Il fonctionne selon un principe assez habituel pour de tels m√©canismes: le code qui peut provoquer une erreur est ex√©cut√© √† l'aide de la construction <code>try/catch</code> .  Le code lui-m√™me est dans le bloc <code>try</code> , les erreurs sont trait√©es dans le <code>catch</code> . <br><br>  Il est int√©ressant de noter que parfois JavaScript, en cas d'urgence, ne produit pas de messages d'erreur.  Cela est d√ª au fait que JS n'a commis aucune erreur avant l'adoption de la norme ECMAScript 3. <br><br>  Par exemple, dans le fragment de code suivant, une tentative de modification d'un objet ¬´fig√©¬ª √©chouera, mais aucune exception ne sera lev√©e. <br><br><pre> <code class="hljs pgsql">let obj = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({}); obj.message = "text";</code> </pre> <br>  Certaines des erreurs JS "silencieuses" apparaissent en mode strict, vous pouvez l'activer en utilisant la construction <code>"use strict";</code>  . <br><br><h2>  <font color="#3AC1EF">Syst√®me prototype</font> </h2><br>  La base de ces m√©canismes JS comme les fonctions constructeurs, la commande <code>Object.create()</code> , le mot <code>class</code> cl√© <code>class</code> , est bas√©e sur un syst√®me prototype. <br>  Prenons l'exemple suivant: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specializedService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(service); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(specializedService.__proto__ === service); <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Ici, pour cr√©er un objet <code>Object.create()</code> , dont le prototype √©tait de cr√©er un objet de <code>service</code> , la commande <code>Object.create()</code> √©t√© utilis√©e.  En cons√©quence, il s'av√®re que la m√©thode <code>doSomething()</code> peut √™tre appel√©e en acc√©dant √† l'objet <code>doSomething()</code> .  En outre, cela signifie que la propri√©t√© <code>__proto__</code> de l'objet <code>specializedService</code> pointe vers un objet de <code>service</code> . <br><br>  Cr√©ez maintenant un objet similaire en utilisant le mot <code>class</code> cl√© <code>class</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ doSomething(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ } let specializedService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>(); console.log(specializedService.__proto__ === <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>.prototype);</code> </pre> <br>  Les m√©thodes d√©clar√©es dans la classe <code>Service</code> seront ajout√©es √† l'objet <code>Service.prototype</code> .  Les instances de la classe <code>Service</code> auront le m√™me prototype ( <code>Service.prototype</code> ).  Toutes les instances d√©l√©gueront des appels de m√©thode √† l'objet <code>Service.prototype</code> .  Par cons√©quent, il s'av√®re que les m√©thodes ne sont d√©clar√©es qu'une seule fois, dans <code>Service.prototype</code> , apr√®s quoi elles sont "h√©rit√©es" par toutes les instances de la classe. <br><br><h3>  <font color="#3AC1EF">‚ñç Cha√Æne prototype</font> </h3><br>  Les objets peuvent √™tre ¬´h√©ritiers¬ª d'autres objets.  Chaque objet poss√®de un prototype dont les m√©thodes sont √† sa disposition.  Si vous essayez d'acc√©der √† une propri√©t√© qui n'est pas dans l'objet lui-m√™me, JavaScript commencera √† la rechercher dans la cha√Æne de prototypes.  Ce processus se poursuivra jusqu'√† ce que la propri√©t√© soit trouv√©e ou jusqu'√† ce que la recherche atteigne la fin de la cha√Æne. <br><br><h2>  <font color="#3AC1EF">√Ä propos de la programmation fonctionnelle en JavaScript</font> </h2><br>  En JavaScript, les fonctions sont des objets de premi√®re classe; le langage prend en charge le m√©canisme de fermeture.  Cela ouvre la voie √† l'impl√©mentation de techniques de programmation fonctionnelle dans JS.  En particulier, nous parlons de la possibilit√© d'utiliser des fonctions d'ordre sup√©rieur. <br><br>  Une fermeture est une fonction interne qui a acc√®s aux variables d√©clar√©es √† l'int√©rieur de la fonction parent, m√™me apr√®s l'ex√©cution de la fonction parent. <br><br>  Une fonction d'ordre sup√©rieur est une fonction qui peut prendre d'autres fonctions comme arguments, renvoyer des fonctions ou faire les deux. <br><br>  La programmation fonctionnelle dans JS est couverte dans de nombreuses publications.  Si vous √™tes int√©ress√©, voici quelques documents sur ce sujet consacr√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aux fonctions de premi√®re classe</a> , √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composition</a> , aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©corateurs</a> , aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fermetures</a> et √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lisibilit√© du code</a> √©crit dans un style fonctionnel. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  La puissance de JavaScript r√©side dans sa simplicit√©.  La compr√©hension des m√©canismes de base du langage permet au programmeur utilisant JS d'appliquer plus efficacement ces m√©canismes et jette les bases de sa croissance professionnelle. <br><br>  <b>Chers lecteurs!</b>  Selon vous, quelles sont les caract√©ristiques de JavaScript que la plupart des d√©butants provoquent? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416375/">https://habr.com/ru/post/fr416375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416363/index.html">Ouverture officielle de Taobao en Russie</a></li>
<li><a href="../fr416365/index.html">Collection de souhaits et vote pour les nouvelles fonctionnalit√©s du navigateur Vivaldi</a></li>
<li><a href="../fr416367/index.html">Nous commen√ßons ReactOS avec BTRFS de la section</a></li>
<li><a href="../fr416369/index.html">√Ä peu pr√®s compliqu√©. Partie 2, cr√©ation d'une ¬´maison intelligente¬ª sans fil. Bas√© sur la technologie Linux, les logiciels Z-Wave et MajorDoMo</a></li>
<li><a href="../fr416371/index.html">Lampe de camping analogique</a></li>
<li><a href="../fr416377/index.html">Nous devenons des assistants en programmation. Partie 1</a></li>
<li><a href="../fr416379/index.html">Neurobugurt. Comment nous avons appris au r√©seau neuronal √† inventer des m√®mes un an plus t√¥t que Stanford</a></li>
<li><a href="../fr416381/index.html">Rapport du Club de Rome 2018, chapitre 3.13: philanthropie, investissement, crowdsourcing et blockchain</a></li>
<li><a href="../fr416385/index.html">Si la corr√©lation ressort √† 100%, alors quelque part une erreur s'est gliss√©e quelque part: l'exp√©rience de stage chez Rambler Group</a></li>
<li><a href="../fr416387/index.html">Shrimp: redimensionnez et partagez des images HTTP dans C ++ moderne avec ImageMagic ++, SObjectizer et RESTinio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>