<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌸 🕺🏽 📒 Verwenden der Oracle-Datenbank für die technische Marktanalyse 🚾 ♦️ 🚈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit Oracle-Datenbank-, PL / SQL-, SQL-, MATCH_RECOGNIZE-, MODEL-Klausel-, Aggregat- und Pipeline-Funktionen. 

 Die techni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden der Oracle-Datenbank für die technische Marktanalyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455050/"> Dieser Artikel befasst sich mit Oracle-Datenbank-, PL / SQL-, SQL-, MATCH_RECOGNIZE-, MODEL-Klausel-, Aggregat- und Pipeline-Funktionen. <br><br>  Die technische Analyse (TA) der Märkte wurde als Funktionsbereich verwendet.  Zuerst eine kleine, oberflächliche Einführung zum Handel mit Märkten, dann Berechnungen. <br><br>  Technische Analyse - eine Reihe von Tools zur Vorhersage wahrscheinlicher Preisänderungen auf der Grundlage von Mustern vergangener Preisänderungen.  Theoretisch ist die technische Analyse in jedem Markt anwendbar.  Die am weitesten verbreitete technische Analyse war jedoch in hochliquiden freien Märkten, beispielsweise an Börsen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/iz/zq/yvizzqt9vdlwyfbdtpsupx4anhq.jpeg" alt="Bild"></div><br>  Viele SQL-Anweisungen, -Prozeduren und -Diagramme wurden entwickelt.  Teil - unten, vollständiger Code - auf GitHub unter dem Link am Ende des Artikels. <br><a name="habracut"></a><br>  Technische Marktindikatoren (TIRs) - zusätzliche Diagramme für Preisdiagramme, <em>die auf der Grundlage der Umrechnung der im Basispreisdiagramm enthaltenen Werte erstellt wurden</em> .  In der Regel handelt es sich dabei um verschiedene Arten der Mittelwertbildung (der nächste Punkt des Diagramms wird als Durchschnittswert einer bestimmten Anzahl vorheriger Preiswerte berechnet, z. B. als gleitender Durchschnitt), Beziehungen (der nächste Punkt ist das Ergebnis des Vergleichs einer bestimmten Anzahl früherer Preise - deren Differenz, Ableitung einer Änderung über einen Zeitraum) oder Verzögerungen ( Verzögerungen).  Die Indikatoren zeigen deutlich einige nicht offensichtliche Informationen, die in der Statistik der Preisänderungen enthalten sind, und können Empfehlungen zu Handelsaufträgen bilden - KAUFEN / VERKAUFEN.  Indikatoren haben mindestens einen variablen Parameter, von dessen Wert sich das Ergebnis ändert.  <em>Um echte Transaktionen zu eröffnen, werden in der Regel nach Ermessen des Händlers mehrere Indikatoren zusammen mit zusätzlichen Informationen verwendet.</em> <br><br>  Einer der Grundsätze der Technischen Analyse lautet „Geschichte wiederholt sich“: Marktteilnehmer verhalten sich unter ähnlichen Umständen ungefähr gleich und bilden eine ähnliche Dynamik von Preisänderungen.  Und es ist natürlich anzunehmen, dass das Marktverhalten in der Zukunft hauptsächlich die in der Vergangenheit auftretenden Muster wiederholen wird.  Nach dieser Aussage kann der Anleger aus den möglichen TIR-Parametern diejenigen auswählen, die sich in den vergangenen Perioden als am besten erwiesen haben. <br><br>  In diesem Artikel wird ein Diagramm der Handelsleistung erstellt, wenn jeder Indikator für den Wert des TIR-Parameters verwendet wird. Dies erfolgt in einer zweidimensionalen Darstellung.  Tatsächlich werde ich jedoch eine dreidimensionale Darstellung einbauen, um auch die Auswirkung der Verzögerung bei der Ausführung der Bestellung auf das Ergebnis zu bewerten. Der Parameter ist also die X-Achse (Abszisse), die Verzögerung ist die Y-Achse (Ordinate), das Ergebnis ist die Z-Achse (Anwendung).  Dies ist ein Versuch, den Effekt des „Schlupfes“ zu bewerten, der leider immer auftritt.  Anstelle eines echten „Schlupfes“ entlang der Y-Achse verschiebe ich die Ausführung des Kauf- / Verkaufsauftrags um einen Zeitraum von 1 bis 5 Zeiträumen. <br><br>  Wenn in diesem Diagramm ein globales Maximum hervorgehoben ist und das Diagramm selbst wie ein Hut aussieht (im Allgemeinen wird es als „Normalverteilung“ bezeichnet, es wird jedoch eine strikte Symmetrie um die vertikale Achse vorausgesetzt), sind auch der Kegel und die Pyramide geeignet - dies bedeutet, dass Sie einen bestimmten Parameterwert dafür auswählen können , die das höchste Ergebnis anzeigen, und mit diesem Indikator können Sie versuchen, zu handeln.  Wenn das Leistungsdiagramm je nach Parameter einer „Palisade“ ähnelt, ist es unmöglich, den optimalen Parameterwert auszuwählen, und es macht keinen Sinn, diese <abbr title="Technischer Marktindikator">TIR</abbr> im Handel zu verwenden. <br><br>  <em>Wir können sagen, dass ich in diesem Artikel nur den „Trefferprozentsatz“ der Indikatoren berechne.</em>  <em>Das Problem, zu bewerten, wie viel man "verdienen" kann, habe ich nicht gewagt.</em> <br><br>  <strong>Der erfolgreiche Abschluss des beschriebenen Tests ist einer der notwendigen, aber nicht ausreichenden Faktoren für einen effektiven Handel.</strong> <br><br>  Zur Information ... Im Gegensatz zur Technischen Analyse bezeichnet die Fundamentalanalyse (FA) Methoden zur Vorhersage des Marktwerts (Tauschwerts) von Instrumenten auf der Grundlage der Analyse von Finanz- und Produktionsleistungsindikatoren. <br>  Der „innere Wert“ der <abbr title="Fundamentalanalyse">FA</abbr> stimmt in den meisten Fällen nicht mit dem Aktienkurs des Unternehmens überein, der durch das Verhältnis von Angebot und Nachfrage an der Börse bestimmt wird.  Anleger, die die <abbr title="Fundamentalanalyse">FA</abbr> für ihre Aktivitäten nutzen, sind hauptsächlich an Situationen interessiert, in denen der "innere Wert" der Aktien des Unternehmens den Preis der Aktien an der Börse übersteigt.  Solche Aktien gelten als unterbewertet, was bedeutet, dass ihr Preis steigen wird, und sie sind potenzielle Anlageziele. <br><br>  Einer der bekanntesten Investoren, die Fundamental Analysis verwenden, ist Warren Buffett. <br><br>  Schauen Sie sich den Trailer an: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=SqE8fnvmV1Y</a> <br><br>  Wir haben also zwei diametral entgegengesetzte Ansätze - <abbr title="Technische Analyse">TA</abbr> und <abbr title="Fundamentalanalyse">FA</abbr> . <br>  <abbr title="Fundamentalanalyse">FA</abbr> interessiert in der Regel langfristige Anleger, TA - kurz- und mittelfristig und wird für spekulative Transaktionen verwendet, wenn das Thema des Handels des Händlers nicht interessiert ist. <br><br>  Und die Ziele dieses Artikels sind zwei ... <br><br>  Zusätzlich zu den oben beschriebenen Diskussionen über <abbr title="Technische Analyse">TA</abbr> und <abbr title="Fundamentalanalyse">FA</abbr> <em>wollte</em> ich <em>die Fähigkeiten von Oracle Database untersuchen und zeigen, um Berechnungen technischer Marktindikatoren durchzuführen</em> . <br>  Ich präsentiere diese Möglichkeiten dem Urteil der Leser. <br><br>  Wenn Sie meine Berechnungen wiederholen möchten, laden Sie den Code von GitHub unter dem Link unten im Artikel herunter.  Code überprüft auf Version 12.2.0.1. <br><br>  Erstellen Sie zuerst freigegebene Objekte.  Das erste sind die Tabellen und die Ansicht.  In derselben Datei befindet sich ein Transaktionsmodellierungspaket. <br><br>  Der zweite Schritt ist die Erstellung von Funktionen, die die Berechnung von <abbr title="Technischer Marktindikator">TIR durchführen</abbr> . <br><br>  Der dritte Schritt sind die Berechnungen. <br><br>  Alle Funktionen zur Berechnung aller <abbr title="Technischer Marktindikator">TIRs</abbr> geben einen Cursor mit den folgenden Feldern zurück: STOCK_NAME, ADATE, ACLOSE (Tagesschlusskurs), AACTION (Verkaufs- / Kaufauftrag) <br><br>  Das Paket enthält drei tabellarische Modellierungsfunktionen, die einen Eingabecursor aus den oben beschriebenen <abbr title="Technischer Marktindikator">TIR-</abbr> Berechnungsfunktionen übernehmen: Offset (Verzögerung bei der Auftragsausführung, Verzögerung) und Anfangskapital, standardmäßig 1000 USD.  Paketfunktionen werden folgendermaßen aufgerufen: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.TRADE_LOG (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.CALC_ACTIONS (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Dabei ist XXXXXXXX der Name des <abbr title="Technischer Marktindikator">TIR</abbr> . <br><br>  <strong>Alle Funktionen berechnen das Ergebnis des Handels, sofern der Gewinn vollständig reinvestiert wird, ohne Transaktionskosten und Steuern sowie ohne Inflation und Diskontierung.</strong> <br><br>  Die erste Funktion <code>TRADE_LOG</code> bildet das Transaktionsprotokoll eines vereinfachten Händlers.  Mit dieser Funktion können Sie die gesamte Transaktionskette verfolgen.  Befindet sich der Anleger am Ende des Zeitraums in Wertpapieren, simuliert die Funktion zur Berechnung des Währungssaldos (Finanzergebnis) den Verkauf aller Wertpapiere zum letzten Schlusskurs und bildet die entsprechende Marke im Feld IN_STOCK. <br><br>  Die zweite Funktion <code>CALC_ACTIONS</code> gibt dieselben Spalten wie der aufgerufene <abbr title="Technischer Marktindikator">TIR-</abbr> Berechnungscursor zurück und fügt die folgenden Spalten hinzu: <code>AACTION_LAG</code> (Auftrag mit Offset), <code>BALANCE_CURRENCY</code> (Kontostand des Händlers in bar), <code>BALANCE_STOCK</code> (Anzahl der Instrumente in offenen Positionen).  Abhängig vom Wert des Feldes <code>AACTION_LAG</code> wird ein Kauf oder Verkauf zu einem Schlusskurs simuliert und dementsprechend der Saldo in der Währung und die Anzahl der offenen Positionen geändert. <br><br>  In der letzten Zeile jedes Instruments sehen Sie das Handelsergebnis für jedes Instrument sowie in der vorherigen Funktion. Wenn sich der Anleger in Wertpapieren befindet, wird ein Verkauf simuliert, um den Saldo in Fremdwährung zu berechnen <br><br>  Die dritte Funktion <code>CALC_ACTIONS_TOTALS</code> macht dasselbe wie die zweite, gibt jedoch nur die letzte Zeile zurück - das Ergebnis des Handels für jedes Instrument.  Es wird bei der Modellierung verwendet. <br><br><h3>  Daten herunterladen </h3><br>  Für solche Märkte und Indizes werden Berechnungen durchgeführt: S &amp; P500, NYSE, Brent, BTCUSD, EURUSD. <br>  Die ersten 4 wurden von Yahoo Finance heruntergeladen, die letzten von einer anderen Quelle.  Die Berechnungsergebnisse für Kurse aus anderen Quellen können variieren. <br><br>  Bitte beachten Sie, dass die Zeiträume der Kurse jedes Instruments unterschiedlich sind, nämlich: <br><br><ul><li>  S &amp; P500 - 03/01/1950 ... 29/01/2019, 69 Jahre alt; </li><li>  NYSE - 31/12/1965 ... 22/03/2019, 54 Jahre alt; </li><li>  Brent - 17/05/1991 ... 06/02/2019, 28 Jahre alt; </li><li>  BTCUSD - 16/07/2010 ... 29/01/2019, 9 Jahre alt; </li><li>  EURUSD - 16/02/2001 ... 27/05/2019, 18 Jahre alt. </li></ul><br>  Daher ist es unmöglich, die erzielte Rentabilität von Instrumenten miteinander zu vergleichen, aber es ist möglich, die Rentabilität jedes Instruments anhand verschiedener Indikatoren zu vergleichen. <br><br>  Die Download-Datei (SQL * Loader) kann auch von GitHub unter dem Link am Ende des Artikels abgerufen werden. <br><br><h3>  Gleitende Durchschnitte </h3><br>  Es gibt mindestens drei Haupttypen von gleitenden Durchschnitten: <br><br><ul><li>  linear (einfacher gleitender Durchschnitt, SMA), </li><li>  Exponentieller gleitender Durchschnitt (EMA) und </li><li>  linear gewichtet (Weighted Moving Average, WMA). </li></ul><br>  Sie unterscheiden sich in den Gewichten ihrer Bestandteile.  Bei einem linearen gleitenden Durchschnitt sind die Gewichte gleich, bei exponentiellen und linear gewichteten Gewichten nehmen sie ab, wenn sich die Komponente weiter vom rechten Rand des Fensters entfernt - exponentiell oder linear. <br><br>  Der lineare gleitende Durchschnitt ist am einfachsten zu berechnen.  In Oracle ist dies die Funktion <code>avg (VALUE) over (partition by STOCK_NAME order by ADATE rows between 9 preceding and current row)</code> - ein gleitender Durchschnitt mit einem Mittelungsfenster von 10 Werten. <br><br>  Der lineare gleitende Durchschnitt hat Nachteile.  Erstens reagieren solche Durchschnittswerte langsam auf Marktumkehrungen.  Da viele Werte gemittelt werden, von denen jeder das gleiche Gewicht hat, erfolgt die durchschnittliche Antwort häufig mehrere Zeiträume nach einer Umkehrung des Vermögenspreises. <br><br>  Auch der lineare gleitende Durchschnitt ist nicht sehr effektiv, da er zweimal auf das Signal reagiert: als der Indikator das Schiebefenster betrat und es verließ.  Der Rest reagiert nur auf die Eingabe des Indikators und entfernt ihn reibungslos aus der Berechnung, wenn Sie sich vom rechten Rand des Fensters nach links bewegen. <br><br>  Bei der Berechnung der <abbr title="Technischer Marktindikator">TIR</abbr> werden alle drei Arten von gleitenden Durchschnitten verwendet.  Für exponentielle und linear gewichtete in diesem Artikel werden die Aggregatfunktionen <code>EMA</code> und <code>WMA</code> entwickelt, die in analytischer Form verwendet werden.  Zusätzlich können diese gleitenden Durchschnitte durch Rekursion oder Modell (Ausdruck <code>MODEL</code> ) berechnet werden. <br><br>  Eine Berechnung von EMA und WMA ohne Rekursion oder Modelka nur durch Analyse in der Oracle-Datenbank ist offensichtlich unmöglich. <br><br>  Aber immer noch Vorbehalte gegen gleitende Durchschnitte: <br><br><ul><li>  Je kürzer die Mittelungsperiode ist und je empfindlicher das Verfahren auf Windungen reagiert, desto mehr gibt es falsche Signale. </li><li>  Je kürzer die Mittelungsperiode ist, desto mehr Signale werden erzeugt, desto größer ist der Transaktionsaufwand, der sehr bedeutend werden kann. </li></ul><br><h2>  Technische Marktindikatoren </h2><br>  Für fast jeden Indikator werden verschiedene Berechnungsmethoden angegeben: CALC - Berechnung mit PL / SQL-Code, SIMP - Berechnung durch einen Operator oder RECU - Berechnung durch Rekursion, AGRF - Berechnung mit der Aggregatfunktion, MODE - Berechnung nach Modell. <br><br>  Es gibt Gründe für die Entwicklung mehrerer Methoden.  Erstens können Sie durch Berechnen des <abbr title="Technischer Marktindikator">TIR</abbr> mit mehreren Methoden und Vergleichen der Indikatoren bei gleichen Indikatoren sicher sein, dass die Berechnungen korrekt durchgeführt wurden (unter Berücksichtigung der verschiedenen Methoden zum Runden und Verarbeiten der NULL- und "0" -Werte).  In diesem Artikel werde ich die Hashes von Stichproben verschiedener Methoden vergleichen, sodass die Übereinstimmung mit Bits und die gleiche Verarbeitung durch alle Algorithmen garantiert ist. <br><br>  Ich glaube, dass Oracle mit der Entwicklung von <abbr title="Technischer Marktindikator">TIR</abbr> mit der SIMP-Methode beginnen muss - Berechnung durch einen Bediener.  Wenn dies erledigt ist, hat der Orakeloid einen Plan- und Berechnungsalgorithmus im Kopf und kann leicht in PL / SQL oder in eine andere prozedurale Sprache übertragen werden. <br><br>  Ich stelle fest, dass die CALC-Berechnungsmethode für PL / SQL hier schneller ist als die SIMP-Methode (mit einem Operator), wenn die gesamte Berechnung in einem Durchgang entlang des Cursors durchgeführt werden kann.  Wenn Sie jedoch für die Berechnung temporäre Tabellen oder Sammlungen erstellen müssen oder mehr als 1 Cursor übergeben müssen, wird sich die Methode mit einem Operator meiner Meinung nach als schneller und weniger ressourcenintensiv herausstellen. <br><br>  Für alle Methoden, einschließlich der SIMP-Methode („one operator“), werde ich die Operatoren in Funktionen einfügen, damit die Berechnung mit einem Parameter aufgerufen werden kann, um den optimalen Wert auszuwählen. <br><br>  Die Berechnungen werden für sieben <abbr title="Technischer Marktindikator">TIRs durchgeführt</abbr> : Moving Average Intersection (EMASIMPLE), Goldene und tödliche Kreuze (CROSSES), Balance-Volumen (OBV), Keltner-Kanal (KELTNER), Preis- und Volumentrend (PVT), Indikator für die Bewegungsfreiheit der Arme (EMV) ), Commodity Channel Index (CCI). <br><br>  Für die sieben Indikatoren dieser beiden Artikel gibt es einen Parameter „Mittelung der Fenstergröße“ und den zweiten Parameter - Verschiebung (Verzögerung).  Die Verschiebung gibt an, wie viele Balken Sie benötigen, um die Ausführung des Kauf- / Verkaufsauftrags zu verschieben - wie viele Balken, um den Schlusskurs zu verschieben (alle Bestellungen werden zum Schlusskurs des Balkens ausgeführt).  Dies ist ähnlich wie "Schlupf", aber es ist nicht genau "Schlupf".  Slippage ist normalerweise nicht zugunsten des Kunden, und unsere Verzögerung kann sich sowohl als nicht zugunsten des Kunden als auch zugunsten des Kunden herausstellen.  Die Verwendung der Modellierung mit einer Verzögerung von 1 bis 5 Balken für einige Indikatoren zeigt jedoch, dass ein Schlupf einen signifikanten Einfluss auf das Ergebnis hat.  Und für einige Indikatoren sind Verzögerung und Schlupf nicht so wichtig. <br><br>  Die Methoden SIMP ("Einzeloperator") und RECU ("Rekursion") <code>MATCH_RECOGNIZE</code> aktiv den Ausdruck <code>MATCH_RECOGNIZE</code> , um das <code>MATCH_RECOGNIZE</code> / VERKAUFEN basierend auf dem Ein- / Ausstieg des berechneten <abbr title="Technischer Marktindikator">TIR</abbr> in den angegebenen Bereich oder dessen Verhalten relativ zu seinem gleitenden Durchschnitt zu generieren. <br><br>  <em>Detaillierte Beschreibungen aller <abbr title="Technischer Marktindikator">TIRs</abbr> finden Sie auf Wikipedia oder in Robert Colbys Buch Encyclopedia of Technical Market Indicators.</em> <br><br><h3>  Der Schnittpunkt des exponentiellen gleitenden Durchschnitts </h3><br>  Die Methode zum Schneiden exponentieller gleitender Durchschnitte ist die einfachste <abbr title="Technischer Marktindikator">TIR</abbr> . <br><br>  Die Methode beinhaltet: Kaufen (Eröffnen einer Long-Position), wenn der Preiswert seinen exponentiellen gleitenden Bottom-Up-Durchschnitt (ESA) überschreitet;  Verkaufen (Schließen einer Long-Position), wenn der Preis sein ESS von oben nach unten überschreitet. <br><br>  Short-Positionen sowie der Margin-Handel im Allgemeinen werden in diesem Artikel nicht berücksichtigt. <br><br>  In Zukunft kann dieser Indikator als Standard für den Vergleich mit anderen verwendet werden.  Ein Vergleich mit dieser <abbr title="Technischer Marktindikator">TIR ist</abbr> besser als ein Vergleich mit der Buy and Hold-Strategie, da diese Strategie in fallenden Märkten nicht rentabel ist. <br><br>  Der einzige <abbr title="Technischer Marktindikator">TIR-</abbr> Parameter ist die Länge des gleitenden Durchschnitts. <br><br>  Berechnung mit PL / SQL <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_CALC (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">pipelined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; EMA number; prev_EMA number; prev_TYPICAL_PRICE number; retval HABR_MARKETINDEXES_RESULT_T := HABR_MARKETINDEXES_RESULT_T (null, null, null, null, null, null, null, null, null); prev_STOCK_NAME varchar2(256); l_alpha number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> l_alpha := <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>); for c1 in (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> retval.ADATE := c1.ADATE; retval.ACLOSE := c1.ACLOSE; if prev_STOCK_NAME is null or prev_STOCK_NAME &lt;&gt; c1.STOCK_NAME then retval.STOCK_NAME := c1.STOCK_NAME; EMA := c1.TYPICAL_PRICE; prev_EMA := null; else EMA := round (c1.TYPICAL_PRICE * l_alpha + EMA * (1 - l_alpha), 20); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; if prev_TYPICAL_PRICE &lt; prev_EMA and c1.TYPICAL_PRICE &gt; EMA then retval.AACTION := 'BUY'; elsif prev_TYPICAL_PRICE &gt; prev_EMA and c1.TYPICAL_PRICE &lt; EMA then retval.AACTION := 'SELL'; else retval.AACTION := null; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; retval.IND_VALUE := EMA; pipe row (retval); prev_STOCK_NAME := c1.STOCK_NAME; prev_EMA := EMA; prev_TYPICAL_PRICE := c1.TYPICAL_PRICE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  Berechnung durch einen rekursiven Operator <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_RECU (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 (STOCK_NAME, ADATE, TYPICAL_PRICE, EMA, ACLOSE, RN) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (TYPICAL_PRICE, <span class="hljs-number"><span class="hljs-number">20</span></span>), ACLOSE, RN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> RN = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.STOCK_NAME , b.ADATE , b.TYPICAL_PRICE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (b.TYPICAL_PRICE * <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>) + a.EMA * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-number"><span class="hljs-number">20</span></span>) , b.ACLOSE , b.RN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 a, LOAD_YAHOO_V b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.RN = a.RN + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.STOCK_NAME = a.STOCK_NAME) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, AACTION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 match_recognize (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> classifier() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AACTION all <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> per <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> unmatched <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> pattern (BUY+ | SELL+) <span class="hljs-keyword"><span class="hljs-keyword">define</span></span> BUY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &lt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA) , SELL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &gt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA) ) MR; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  Berechnung mit dem Ausdruck MODELL <br><div class="spoiler">  <b class="spoiler_title">Funktionstext HABR_MARKETINDEXES_EMASIMPLE_F_MODE</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_MODE (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dimension</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (STOCK_NAME, RN) <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> (ADATE, TYPICAL_PRICE, ACLOSE, to_number(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EMA) <span class="hljs-keyword"><span class="hljs-keyword">rules</span></span> (EMA[<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (TYPICAL_PRICE [cv(), cv()] * <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>) + nvl(EMA [cv(), cv() - <span class="hljs-number"><span class="hljs-number">1</span></span>], TYPICAL_PRICE [cv(), cv()]) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-number"><span class="hljs-number">20</span></span>))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE , TYPICAL_PRICE, LAG (TYPICAL_PRICE) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PREV_TYPICAL_PRICE , EMA, lag (EMA) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PREV_EMA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> prev_TYPICAL_PRICE &lt; prev_EMA <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'BUY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> prev_TYPICAL_PRICE &gt; prev_EMA <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'SELL'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2 <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME, ADATE; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><br>  Berechnung mit der Aggregatfunktion <br><div class="spoiler">  <b class="spoiler_title">Der Text der EMA-Aggregatfunktion und der Funktion HABR_MARKETINDEXES_EMASIMPLE_F_AGRF</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EMA_DATA_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (AVALUE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, AVERAGING_WINDOW <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EMA_IMPL_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ( l_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, l_ema <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateInitialize (sctx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateIterate (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_DATA_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateMerge (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T, ctx2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateTerminate (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_IMPL_T, returnValue <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, flags <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">body</span></span> EMA_IMPL_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateInitialize (sctx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sctx := EMA_IMPL_T (<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateIterate (self in out EMA_IMPL_T, value in EMA_DATA_T) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value.AVALUE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l_window_width <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> l_window_width := value.AVERAGING_WINDOW; self.l_ema := value.AVALUE; else self.l_ema := round (value.AVALUE * 2 / (l_window_width + 1) + self.l_ema * (1 - 2 / (l_window_width + 1)), 20); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateMerge(self in out EMA_IMPL_T, ctx2 in EMA_IMPL_T) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ODCIConst.Error; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateTerminate(self in EMA_IMPL_T, returnValue out number, flags in number) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> returnValue := self.l_ema; return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> EMA (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> EMA_DATA_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">aggregate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EMA_IMPL_T; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, ACLOSE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (EMA (EMA_DATA_T (TYPICAL_PRICE, p_averaging_window_width)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE), <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EMA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, AACTION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 match_recognize (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> classifier() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AACTION all <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> per <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> unmatched <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> pattern (BUY+ | SELL+) <span class="hljs-keyword"><span class="hljs-keyword">define</span></span> BUY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &lt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA) , SELL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &gt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA) ) MR; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div><br><br>  Vergleichen Sie die Berechnungsergebnisse mit einem Parameter: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN_VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ALG, dbms_sqlhash.gethash (<span class="hljs-keyword"><span class="hljs-keyword">COLUMN_VALUE</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RECORDSET_HASH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (sys.odcivarchar2list (<span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_RECU (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_MODE (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (15)) order by 1, 2'</span></span>));</code> </pre> <br>  Alle Hashes müssen für alle vier Methoden übereinstimmen. <br><br>  Wenn die Hashes nicht übereinstimmen, können Sie mit diesem Operator genau herausfinden, wo sich die Diskrepanz gebildet hat (ersetzen Sie die Namen der Funktionen, die Sie vergleichen möchten): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span> (a.STOCK_NAME, b.STOCK_NAME) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> STOCK_NAME, <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span> (a.ADATE, b.ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ADATE , a.ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_ACLOSE, b.ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_CLOSE , a.IND_VALUE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_EMA, b.IND_VALUE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_EMA , a.AACTION <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_AACTION, b.AACTION <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (<span class="hljs-number"><span class="hljs-number">15</span></span>)) a <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (<span class="hljs-number"><span class="hljs-number">15</span></span>)) b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a.STOCK_NAME = b.STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.ADATE = b.ADATE <span class="hljs-comment"><span class="hljs-comment">--where sys_op_map_nonnull (a.ACLOSE) &lt;&gt; sys_op_map_nonnull (b.ACLOSE) -- or sys_op_map_nonnull (a.IND_VALUE) &lt;&gt; sys_op_map_nonnull (b.IND_VALUE) -- or sys_op_map_nonnull (a.AACTION) &lt;&gt; sys_op_map_nonnull (b.AACTION) order by 1, 2; ;</span></span></code> </pre> <br>  <b>Auswahl der Parameter</b> <br><br>  Das <abbr title="Technischer Marktindikator">TIR</abbr> selbst verwendet einen Parameter, für diesen und für alle anderen <abbr title="Technischer Marktindikator">TIRs ändere</abbr> ich ihn im Bereich von 1 bis 200, aber um ein dreidimensionales Bild für die Abhängigkeit und auch für die Verzögerung zu berechnen, werden wir einen zweiten Parameter einführen, der von 1 bis 5 variiert. <br><br>  Der Operator öffnet 200 * 5 = 1000 Cursor, sodass Oracle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OPEN_CURSORS</a> möglicherweise geändert werden muss <br><br>  Die folgende Abfrage führt das kartesische Produkt einer Tabelle mit Zahlen von 1 bis 200 mit einer Tabelle mit Zahlen von 1 bis 5 aus, und Cartesian multipliziert all dies durch Aufrufen der Tabellenfunktion <code>HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS</code> . <br><br>  Nach einigen weiteren Manipulationen in MATLAB erhalten wir eine 200 * 5-Matrix, wobei in den Matrixzellen für jeden Wert jedes der beiden Parameter ein Gesamtkapitalwert angegeben wird.  Als nächstes erstellen wir in MATLAB ein dreidimensionales Bild. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">rollback</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> INDICATOR_NAME = <span class="hljs-string"><span class="hljs-string">'HABR_MARKETINDEXES_EMASIMPLE_F_CALC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS (INDICATOR_NAME, PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TP1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;AVERAGING_INTERVAL) , TP2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;LAG_MODELLING_DEPTH) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-comment"><span class="hljs-comment">--+ parallel(8) 'HABR_MARKETINDEXES_EMASIMPLE_F_CALC', PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK from TP1 cross join TP2 cross join table (HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (cursor (select STOCK_NAME, ADATE, ACLOSE, AACTION from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (PARM1))), PARM2)) ; commit;</span></span></code> PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">rollback</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> INDICATOR_NAME = <span class="hljs-string"><span class="hljs-string">'HABR_MARKETINDEXES_EMASIMPLE_F_CALC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS (INDICATOR_NAME, PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TP1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;AVERAGING_INTERVAL) , TP2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;LAG_MODELLING_DEPTH) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-comment"><span class="hljs-comment">--+ parallel(8) 'HABR_MARKETINDEXES_EMASIMPLE_F_CALC', PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK from TP1 cross join TP2 cross join table (HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (cursor (select STOCK_NAME, ADATE, ACLOSE, AACTION from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (PARM1))), PARM2)) ; commit;</span></span></code> </pre> <br>  Alle Berechnungen in diesem Artikel werden langsam durchgeführt, bis zu 20 Minuten. Dies ist auf das Öffnen einer großen Anzahl von Cursorn zurückzuführen. <br><br>  Ich habe auch eine schnellere Simulationsmethode mit einem Cursor entwickelt, ohne 1000 Cursor zu öffnen, aber sie ist so umfangreich, dass sie die Hälfte des Artikels in Anspruch nehmen würde.  Deshalb werde ich ihn nicht hierher bringen. <br><br>  Das Ergebnis der Modellierung des Schnittpunkts des gleitenden Durchschnitts (alle Diagramme sind anklickbar): <br> <a href=""><img src="https://habrastorage.org/webt/my/i8/1f/myi81fz9phsezv_f_igu2eic4ie.jpeg"><br></a> <br><br>  Die zweite Zeile der Diagramme ist dieselbe wie die erste Zeile, aber die Diagramme sind leicht gedreht. Diagramme mit unterschiedlichen Verzögerungen sind nacheinander angeordnet.  Auf diese Weise können Sie die Auswirkung der Verzögerung auf das Ergebnis bewerten. <br><br>  Im Allgemeinen reagiert der Indikator nicht sehr empfindlich auf Verzögerungen.  Für die Märkte S &amp; P500 und NYSE muss der <abbr title="Technischer Marktindikator">TIR-</abbr> Parameter ausgewählt werden, je mehr, desto besser.  Für den Brent-Markt sind es rund 25. In den beiden anderen Märkten besteht keine Korrelation zwischen der Rentabilität und dem Parameter. <br><br><h3>  Tödliche und goldene Kreuze </h3><br>  In der Implementierung unter Oracle ist dieser Indikator dem vorherigen sehr ähnlich, nur dass hier zwei gleitende Durchschnitte verwendet werden und nicht einer.  Daher werde ich nur eine Berechnungsoption geben. <br><br>  Das Wiki beschreibt den Ichimoku-Indikator.  Dies ist ein komplexer Indikator.  "Kreuze" sind einer der Bestandteile.  Aber der Indikator ist im Wiki schlecht beschrieben, insbesondere ist zu beachten, dass die Linien Tenkan und Kijun in völlig unterschiedlichen Worten beschrieben werden, obwohl es tatsächlich dasselbe ist, aber mit unterschiedlichen Zeiträumen. <br><br>  Im Buch von Robert Colby wird dieser Indikator ebenfalls nicht beschrieben. <br><br>  Japanische Analysten nennen den Schnittpunkt von Durchschnittswerten, wenn der kurzfristige Durchschnitt den langfristigen von unten nach oben kreuzt, das Goldene Kreuz (Goldenes Kreuz) und die entgegengesetzte Situation, wenn der kurzfristige gleitende Durchschnitt den langfristigen von oben nach unten kreuzt - das Tote Kreuz. <br><br>  Der Autor bemerkte, dass dieser Indikator im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Futures for American Oil bildete ein„ tödliches Kreuz ““ beschrieben wurde</a> und begann, seine Beschreibung und Verwendung zu googeln. <br><br>  Dieser Indikator wird an der Börse als ernst angesehen, auch weil er selten Signale gibt. <br><br>  Am häufigsten werden gleitende Durchschnittswerte für 50 und 200 Perioden verwendet. <br><br>  Bei der Modellierung der folgenden Leistung nehmen wir den Zeitraum des langen gleitenden Durchschnitts gleich der Vierfachperiode des kurzen gleitenden Durchschnitts und simulieren die Länge des kurzen von 1 bis 200 Tagen (für den langen Zeitraum 4 bis 800 Tage). <br><br>  Code zur Berechnung auf GitHub. <br><br> <a href=""><img src="https://habrastorage.org/webt/7s/1a/c_/7s1ac_u_9vclmx2xelqzod7jvyi.png"></a> <br><br>  Der Indikator reagiert nicht sehr empfindlich auf Verzögerungen.  Für den S &amp; P500-Markt gibt es Höchstwerte bei 48 (192 für eine lange SS) und 98 Tagen (392 für eine lange SS).  Beachten Sie, dass das erste Maximum sehr nahe an den Zahlen 50x200 liegt.  Es ist davon auszugehen, dass Sie, wenn Sie diese Parameter 1 und 2 weniger als andere Marktteilnehmer wählen, versuchen können, sie allein mit diesem Indikator zu schlagen. <br><br>  Es gibt 4 Hochs an der NYSE.  In den Märkten Brent und BTCUSD funktioniert der Indikator nicht. <br>  Auch für den EURUSD-Markt sollte der Parameter für eine kurze SS etwas weniger als 50 gewählt werden.  Der Indikator liefert jedoch keinen Gewinn auf diesem Markt.  Es kann nur als zusätzlicher Indikator verwendet werden. <br><br><h3>  Ausgleichsvolumen, Gleichgewichtsvolumen, On-Balance-Volumen (OBV) </h3><br>  Der OBV-Indikator ist ein kumuliertes gleitendes durchschnittliches Handelsvolumen mit einem Pluszeichen bei einem wachsenden Markt und einem Minuszeichen bei einem fallenden Markt. <br><br>  Hier verwenden wir diese Methode zur Interpretation des Werts von Indikatoren: Kaufen, wenn der OBV seinen gleitenden Durchschnitt von unten nach oben überschreitet, verkaufen, wenn der OBV seinen gleitenden Durchschnitt von oben nach unten überschreitet. <br><br>  Mehr auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> oder Colby <br><br> <a href=""><img src="https://habrastorage.org/webt/rl/w1/fa/rlw1farsmtyjs7duejp1eao6e1u.png"></a> <br><br>  Auf dem S &amp; P500-Markt reagiert der Indikator sehr empfindlich auf Verzögerungen (Verzögerungen). Sie können jedoch versuchen, einen Parameter nach dem Prinzip „Je mehr desto besser“ zu wählen, um eine gewisse Rentabilität zu erzielen.  An der NYSE kann keine Rentabilität erreicht werden.  Auf dem Brent-Markt können Sie einen Parameterwert zwischen 20 und 100 auswählen. Auf dem BTCUSD-Markt gibt es keine klare lineare Beziehung, aber die Auswahl eines Parameterwerts von weniger als 40 ist unpraktisch.  Für den EURUSD-Markt muss der Wert des Parameters „je mehr desto besser“ gewählt werden, aber die Rentabilität kann nicht erreicht werden. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keltner-Kanal </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besteht aus zwei Bändern oberhalb und unterhalb des gleitenden Durchschnittspreises, deren Breite als Bruchteil der durchschnittlichen Preisänderung für den Zeitraum bestimmt wird. </font><font style="vertical-align: inherit;">Der Preis ist ein typischer Preis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mittellinie der Indikatorlinie ist ein einfacher gleitender Durchschnitt des typischen Preises. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oberen und unteren Linien des Indikators sind von der Mittellinie um einen Betrag getrennt, der dem einfachen gleitenden Durchschnitt der täglichen Handelsspanne entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unseren Berechnungen wird das </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR-</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signal </font><font style="vertical-align: inherit;">wie folgt gebildet: Kaufen, wenn der Preis die obere Linie überschreitet, Verkaufen, wenn der Preis die untere Linie überschreitet.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/_h/25/ls/_h25lsxaqle9wda7rehrzncb4ei.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Hochs für die Märkte S &amp; P500 und NYSE. </font><font style="vertical-align: inherit;">Auf dem Brent-Markt besteht keine Abhängigkeit des Ergebnisses vom Parameter, und der gesamte Handel ist ratlos. </font><font style="vertical-align: inherit;">Es gibt Hochs auf dem BTCUSD-Markt, aber enge, und es ist schwierig, in diese hineinzukommen. </font><font style="vertical-align: inherit;">Auf dem EURUSD-Markt ist die Abhängigkeit des Ergebnisses vom Parameter</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preis- und Volumentrend, Preis- und Volumentrend, Preis - Volumentrend, PVT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert des PVT-Indikators repräsentiert die kumulierte Summe des Produkts des aktuellen Handelsvolumens durch den gegenüber der Vorperiode verringerten Preisanstieg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden hier Handelssignale wie folgt generieren: Kaufen, wenn der PVT seinen gleitenden Durchschnitt von unten nach oben überschreitet, Verkaufen, wenn der PVT seinen gleitenden Durchschnitt von oben nach unten überschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Colby fand nicht. </font><font style="vertical-align: inherit;">Für den S &amp; P500, den Wert des Parameters „je größer desto besser“, besteht fast keine Abhängigkeit von der NYSE, für Brent gibt es ein Maximum im Bereich von 50, für BTCUSD ist der Indikator nur mit minimalen Verzögerungen von 1-2 und mit minimalen Parameterwerten von bis zu 50 wirksam Für EURUSD nimmt die Abhängigkeit zu.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/d9/5q/ay/d95qay3lujgc3dplp4rgkorrgyq.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leichtigkeit der Bewegung, Leichtigkeit der Waffen Bewegungswert, EMV </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMV ist ein numerischer Ausdruck dafür, wie leicht sich ein Preis in einem Markt ändert. </font><font style="vertical-align: inherit;">Je stärker die Preisänderung und je geringer der Umsatz, desto leichter steigt oder fällt der Markt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier bilden wir die Handelsaufträge wie folgt: Kaufen, wenn der gleitende Durchschnitt EMV über Null steigt, Verkaufen, wenn der gleitende Durchschnitt EMV unter Null fällt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Colby. </font><font style="vertical-align: inherit;">Auf den S &amp; P- und NYSE-Märkten gibt es Hochs, auf dem Brent-Markt ist der Indikator in einer Vielzahl von Parameterwerten wirksam. </font><font style="vertical-align: inherit;">Auf den BTCUSD- und EURUSD-Märkten ist der Indikator unwirksam.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/3o/9r/yk/3o9ryk2ufl7fh-xi7t755zughpq.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warenkanalindex, CCI </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCI ist ein Indikator, der auf der Analyse der aktuellen Änderung der Preisabweichung von ihrem Durchschnittswert für einen bestimmten Zeitraum und dem durchschnittlichen Absolutwert dieses Parameters basiert. </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR gilt</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für alle Finanzmärkte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Handelsaufträge wie folgt bilden: Kaufen, wenn der CCI über 100 steigt, Verkaufen, wenn der CCI unter 100 fällt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Colby. </font><font style="vertical-align: inherit;">In den Märkten S &amp; P500, NYSE, Brent besteht keine Abhängigkeit des Handelsergebnisses vom Wert des Parameters. Es besteht eine Abhängigkeit vom BTCUSD-Markt (zwei deutliche Höchststände), und Sie können versuchen, ihn im realen Handel zu fangen. Auf dem EURUSD-Markt wird der Indikator für das Ergebnis nicht bringen. </font><b><font style="vertical-align: inherit;">Quellen auf </font></b><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Github</font></a></b><b><font style="vertical-align: inherit;"> verfügbar</font></b></font><br><br> <a href=""><img src="https://habrastorage.org/webt/vr/uc/ob/vrucob8honvqk0dsynnz5t7zqtw.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie gemeinsame Objekte, laden Sie Daten hoch, entweder meine (wie ich bereits sagte, alle Märkte außer den letzten stammen von Yahoo Finance), oder erstellen Sie eigene Funktionen zum Berechnen, Berechnen von Handelsleistungsdaten (wie bereits erwähnt, Berechnen jedes Indikators für bis zu 20 Minuten) . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die allgemeine Schlussfolgerung bezüglich der </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwendung nur eines Gewinnindikators ist unmöglich. Unterschiedliche Indikatoren sind in verschiedenen Märkten unterschiedlich wirksam. Die Möglichkeit, mit mehreren gut abgestimmten Indikatoren und zusätzlichen externen Informationen Gewinne zu erzielen, ist nicht ausgeschlossen.</font></font><br><br>  Optional: <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurden drei weitere Indikatoren analysiert, die nicht im Artikel enthalten sind. </font><font style="vertical-align: inherit;">Aber sie konnten kein Ergebnis erzielen. </font><font style="vertical-align: inherit;">Vielleicht wird ihr Studium fortgesetzt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist </font><font style="vertical-align: inherit;">sehr praktisch </font><font style="vertical-align: inherit;">, Berechnungen und komplexe Modellierungen von </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR-</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Finanzaktivitäten im Allgemeinen in Oracle Database </font><font style="vertical-align: inherit;">durchzuführen </font><font style="vertical-align: inherit;">.</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455050/">https://habr.com/ru/post/de455050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455032/index.html">Kein Fehler, sondern ein Merkmal: eine Untersuchung der Motilität und Gehirnaktivität einer Person mit Polydaktylie</a></li>
<li><a href="../de455038/index.html">Wie Plesk die KubeCon besucht hat</a></li>
<li><a href="../de455040/index.html">Verbesserung der Arbeit von Wi-Fi. Teil 2. Ausstattungsmerkmale</a></li>
<li><a href="../de455042/index.html">Kotlin DSL, Fixtures und elegante UI-Tests in Android</a></li>
<li><a href="../de455046/index.html">N + 7 nützliche Bücher</a></li>
<li><a href="../de455052/index.html">Sommer DIYorDIE Meetup 16. Juni</a></li>
<li><a href="../de455056/index.html">Primitive Grafiken für Lazy, Oldfags und Lazy Oldfags</a></li>
<li><a href="../de455058/index.html">Berechnete Handlung oder Rollenspielinfektion</a></li>
<li><a href="../de455060/index.html">Homer oder die erste OpenSource. Teil 1</a></li>
<li><a href="../de455062/index.html">Fälle erfolgreicher (und nicht so) Experimente mit Yandex.Navigator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>