<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∏ üï∫üèΩ üìí Verwenden der Oracle-Datenbank f√ºr die technische Marktanalyse üöæ ‚ô¶Ô∏è üöà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit Oracle-Datenbank-, PL / SQL-, SQL-, MATCH_RECOGNIZE-, MODEL-Klausel-, Aggregat- und Pipeline-Funktionen. 

 Die techni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden der Oracle-Datenbank f√ºr die technische Marktanalyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455050/"> Dieser Artikel befasst sich mit Oracle-Datenbank-, PL / SQL-, SQL-, MATCH_RECOGNIZE-, MODEL-Klausel-, Aggregat- und Pipeline-Funktionen. <br><br>  Die technische Analyse (TA) der M√§rkte wurde als Funktionsbereich verwendet.  Zuerst eine kleine, oberfl√§chliche Einf√ºhrung zum Handel mit M√§rkten, dann Berechnungen. <br><br>  Technische Analyse - eine Reihe von Tools zur Vorhersage wahrscheinlicher Preis√§nderungen auf der Grundlage von Mustern vergangener Preis√§nderungen.  Theoretisch ist die technische Analyse in jedem Markt anwendbar.  Die am weitesten verbreitete technische Analyse war jedoch in hochliquiden freien M√§rkten, beispielsweise an B√∂rsen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/iz/zq/yvizzqt9vdlwyfbdtpsupx4anhq.jpeg" alt="Bild"></div><br>  Viele SQL-Anweisungen, -Prozeduren und -Diagramme wurden entwickelt.  Teil - unten, vollst√§ndiger Code - auf GitHub unter dem Link am Ende des Artikels. <br><a name="habracut"></a><br>  Technische Marktindikatoren (TIRs) - zus√§tzliche Diagramme f√ºr Preisdiagramme, <em>die auf der Grundlage der Umrechnung der im Basispreisdiagramm enthaltenen Werte erstellt wurden</em> .  In der Regel handelt es sich dabei um verschiedene Arten der Mittelwertbildung (der n√§chste Punkt des Diagramms wird als Durchschnittswert einer bestimmten Anzahl vorheriger Preiswerte berechnet, z. B. als gleitender Durchschnitt), Beziehungen (der n√§chste Punkt ist das Ergebnis des Vergleichs einer bestimmten Anzahl fr√ºherer Preise - deren Differenz, Ableitung einer √Ñnderung √ºber einen Zeitraum) oder Verz√∂gerungen ( Verz√∂gerungen).  Die Indikatoren zeigen deutlich einige nicht offensichtliche Informationen, die in der Statistik der Preis√§nderungen enthalten sind, und k√∂nnen Empfehlungen zu Handelsauftr√§gen bilden - KAUFEN / VERKAUFEN.  Indikatoren haben mindestens einen variablen Parameter, von dessen Wert sich das Ergebnis √§ndert.  <em>Um echte Transaktionen zu er√∂ffnen, werden in der Regel nach Ermessen des H√§ndlers mehrere Indikatoren zusammen mit zus√§tzlichen Informationen verwendet.</em> <br><br>  Einer der Grunds√§tze der Technischen Analyse lautet ‚ÄûGeschichte wiederholt sich‚Äú: Marktteilnehmer verhalten sich unter √§hnlichen Umst√§nden ungef√§hr gleich und bilden eine √§hnliche Dynamik von Preis√§nderungen.  Und es ist nat√ºrlich anzunehmen, dass das Marktverhalten in der Zukunft haupts√§chlich die in der Vergangenheit auftretenden Muster wiederholen wird.  Nach dieser Aussage kann der Anleger aus den m√∂glichen TIR-Parametern diejenigen ausw√§hlen, die sich in den vergangenen Perioden als am besten erwiesen haben. <br><br>  In diesem Artikel wird ein Diagramm der Handelsleistung erstellt, wenn jeder Indikator f√ºr den Wert des TIR-Parameters verwendet wird. Dies erfolgt in einer zweidimensionalen Darstellung.  Tats√§chlich werde ich jedoch eine dreidimensionale Darstellung einbauen, um auch die Auswirkung der Verz√∂gerung bei der Ausf√ºhrung der Bestellung auf das Ergebnis zu bewerten. Der Parameter ist also die X-Achse (Abszisse), die Verz√∂gerung ist die Y-Achse (Ordinate), das Ergebnis ist die Z-Achse (Anwendung).  Dies ist ein Versuch, den Effekt des ‚ÄûSchlupfes‚Äú zu bewerten, der leider immer auftritt.  Anstelle eines echten ‚ÄûSchlupfes‚Äú entlang der Y-Achse verschiebe ich die Ausf√ºhrung des Kauf- / Verkaufsauftrags um einen Zeitraum von 1 bis 5 Zeitr√§umen. <br><br>  Wenn in diesem Diagramm ein globales Maximum hervorgehoben ist und das Diagramm selbst wie ein Hut aussieht (im Allgemeinen wird es als ‚ÄûNormalverteilung‚Äú bezeichnet, es wird jedoch eine strikte Symmetrie um die vertikale Achse vorausgesetzt), sind auch der Kegel und die Pyramide geeignet - dies bedeutet, dass Sie einen bestimmten Parameterwert daf√ºr ausw√§hlen k√∂nnen , die das h√∂chste Ergebnis anzeigen, und mit diesem Indikator k√∂nnen Sie versuchen, zu handeln.  Wenn das Leistungsdiagramm je nach Parameter einer ‚ÄûPalisade‚Äú √§hnelt, ist es unm√∂glich, den optimalen Parameterwert auszuw√§hlen, und es macht keinen Sinn, diese <abbr title="Technischer Marktindikator">TIR</abbr> im Handel zu verwenden. <br><br>  <em>Wir k√∂nnen sagen, dass ich in diesem Artikel nur den ‚ÄûTrefferprozentsatz‚Äú der Indikatoren berechne.</em>  <em>Das Problem, zu bewerten, wie viel man "verdienen" kann, habe ich nicht gewagt.</em> <br><br>  <strong>Der erfolgreiche Abschluss des beschriebenen Tests ist einer der notwendigen, aber nicht ausreichenden Faktoren f√ºr einen effektiven Handel.</strong> <br><br>  Zur Information ... Im Gegensatz zur Technischen Analyse bezeichnet die Fundamentalanalyse (FA) Methoden zur Vorhersage des Marktwerts (Tauschwerts) von Instrumenten auf der Grundlage der Analyse von Finanz- und Produktionsleistungsindikatoren. <br>  Der ‚Äûinnere Wert‚Äú der <abbr title="Fundamentalanalyse">FA</abbr> stimmt in den meisten F√§llen nicht mit dem Aktienkurs des Unternehmens √ºberein, der durch das Verh√§ltnis von Angebot und Nachfrage an der B√∂rse bestimmt wird.  Anleger, die die <abbr title="Fundamentalanalyse">FA</abbr> f√ºr ihre Aktivit√§ten nutzen, sind haupts√§chlich an Situationen interessiert, in denen der "innere Wert" der Aktien des Unternehmens den Preis der Aktien an der B√∂rse √ºbersteigt.  Solche Aktien gelten als unterbewertet, was bedeutet, dass ihr Preis steigen wird, und sie sind potenzielle Anlageziele. <br><br>  Einer der bekanntesten Investoren, die Fundamental Analysis verwenden, ist Warren Buffett. <br><br>  Schauen Sie sich den Trailer an: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=SqE8fnvmV1Y</a> <br><br>  Wir haben also zwei diametral entgegengesetzte Ans√§tze - <abbr title="Technische Analyse">TA</abbr> und <abbr title="Fundamentalanalyse">FA</abbr> . <br>  <abbr title="Fundamentalanalyse">FA</abbr> interessiert in der Regel langfristige Anleger, TA - kurz- und mittelfristig und wird f√ºr spekulative Transaktionen verwendet, wenn das Thema des Handels des H√§ndlers nicht interessiert ist. <br><br>  Und die Ziele dieses Artikels sind zwei ... <br><br>  Zus√§tzlich zu den oben beschriebenen Diskussionen √ºber <abbr title="Technische Analyse">TA</abbr> und <abbr title="Fundamentalanalyse">FA</abbr> <em>wollte</em> ich <em>die F√§higkeiten von Oracle Database untersuchen und zeigen, um Berechnungen technischer Marktindikatoren durchzuf√ºhren</em> . <br>  Ich pr√§sentiere diese M√∂glichkeiten dem Urteil der Leser. <br><br>  Wenn Sie meine Berechnungen wiederholen m√∂chten, laden Sie den Code von GitHub unter dem Link unten im Artikel herunter.  Code √ºberpr√ºft auf Version 12.2.0.1. <br><br>  Erstellen Sie zuerst freigegebene Objekte.  Das erste sind die Tabellen und die Ansicht.  In derselben Datei befindet sich ein Transaktionsmodellierungspaket. <br><br>  Der zweite Schritt ist die Erstellung von Funktionen, die die Berechnung von <abbr title="Technischer Marktindikator">TIR durchf√ºhren</abbr> . <br><br>  Der dritte Schritt sind die Berechnungen. <br><br>  Alle Funktionen zur Berechnung aller <abbr title="Technischer Marktindikator">TIRs</abbr> geben einen Cursor mit den folgenden Feldern zur√ºck: STOCK_NAME, ADATE, ACLOSE (Tagesschlusskurs), AACTION (Verkaufs- / Kaufauftrag) <br><br>  Das Paket enth√§lt drei tabellarische Modellierungsfunktionen, die einen Eingabecursor aus den oben beschriebenen <abbr title="Technischer Marktindikator">TIR-</abbr> Berechnungsfunktionen √ºbernehmen: Offset (Verz√∂gerung bei der Auftragsausf√ºhrung, Verz√∂gerung) und Anfangskapital, standardm√§√üig 1000 USD.  Paketfunktionen werden folgenderma√üen aufgerufen: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.TRADE_LOG (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.CALC_ACTIONS (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (<span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE, AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_XXXXXXXX_F_CALC (<span class="hljs-number"><span class="hljs-number">10</span></span>))), p_lag =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Dabei ist XXXXXXXX der Name des <abbr title="Technischer Marktindikator">TIR</abbr> . <br><br>  <strong>Alle Funktionen berechnen das Ergebnis des Handels, sofern der Gewinn vollst√§ndig reinvestiert wird, ohne Transaktionskosten und Steuern sowie ohne Inflation und Diskontierung.</strong> <br><br>  Die erste Funktion <code>TRADE_LOG</code> bildet das Transaktionsprotokoll eines vereinfachten H√§ndlers.  Mit dieser Funktion k√∂nnen Sie die gesamte Transaktionskette verfolgen.  Befindet sich der Anleger am Ende des Zeitraums in Wertpapieren, simuliert die Funktion zur Berechnung des W√§hrungssaldos (Finanzergebnis) den Verkauf aller Wertpapiere zum letzten Schlusskurs und bildet die entsprechende Marke im Feld IN_STOCK. <br><br>  Die zweite Funktion <code>CALC_ACTIONS</code> gibt dieselben Spalten wie der aufgerufene <abbr title="Technischer Marktindikator">TIR-</abbr> Berechnungscursor zur√ºck und f√ºgt die folgenden Spalten hinzu: <code>AACTION_LAG</code> (Auftrag mit Offset), <code>BALANCE_CURRENCY</code> (Kontostand des H√§ndlers in bar), <code>BALANCE_STOCK</code> (Anzahl der Instrumente in offenen Positionen).  Abh√§ngig vom Wert des Feldes <code>AACTION_LAG</code> wird ein Kauf oder Verkauf zu einem Schlusskurs simuliert und dementsprechend der Saldo in der W√§hrung und die Anzahl der offenen Positionen ge√§ndert. <br><br>  In der letzten Zeile jedes Instruments sehen Sie das Handelsergebnis f√ºr jedes Instrument sowie in der vorherigen Funktion. Wenn sich der Anleger in Wertpapieren befindet, wird ein Verkauf simuliert, um den Saldo in Fremdw√§hrung zu berechnen <br><br>  Die dritte Funktion <code>CALC_ACTIONS_TOTALS</code> macht dasselbe wie die zweite, gibt jedoch nur die letzte Zeile zur√ºck - das Ergebnis des Handels f√ºr jedes Instrument.  Es wird bei der Modellierung verwendet. <br><br><h3>  Daten herunterladen </h3><br>  F√ºr solche M√§rkte und Indizes werden Berechnungen durchgef√ºhrt: S &amp; P500, NYSE, Brent, BTCUSD, EURUSD. <br>  Die ersten 4 wurden von Yahoo Finance heruntergeladen, die letzten von einer anderen Quelle.  Die Berechnungsergebnisse f√ºr Kurse aus anderen Quellen k√∂nnen variieren. <br><br>  Bitte beachten Sie, dass die Zeitr√§ume der Kurse jedes Instruments unterschiedlich sind, n√§mlich: <br><br><ul><li>  S &amp; P500 - 03/01/1950 ... 29/01/2019, 69 Jahre alt; </li><li>  NYSE - 31/12/1965 ... 22/03/2019, 54 Jahre alt; </li><li>  Brent - 17/05/1991 ... 06/02/2019, 28 Jahre alt; </li><li>  BTCUSD - 16/07/2010 ... 29/01/2019, 9 Jahre alt; </li><li>  EURUSD - 16/02/2001 ... 27/05/2019, 18 Jahre alt. </li></ul><br>  Daher ist es unm√∂glich, die erzielte Rentabilit√§t von Instrumenten miteinander zu vergleichen, aber es ist m√∂glich, die Rentabilit√§t jedes Instruments anhand verschiedener Indikatoren zu vergleichen. <br><br>  Die Download-Datei (SQL * Loader) kann auch von GitHub unter dem Link am Ende des Artikels abgerufen werden. <br><br><h3>  Gleitende Durchschnitte </h3><br>  Es gibt mindestens drei Haupttypen von gleitenden Durchschnitten: <br><br><ul><li>  linear (einfacher gleitender Durchschnitt, SMA), </li><li>  Exponentieller gleitender Durchschnitt (EMA) und </li><li>  linear gewichtet (Weighted Moving Average, WMA). </li></ul><br>  Sie unterscheiden sich in den Gewichten ihrer Bestandteile.  Bei einem linearen gleitenden Durchschnitt sind die Gewichte gleich, bei exponentiellen und linear gewichteten Gewichten nehmen sie ab, wenn sich die Komponente weiter vom rechten Rand des Fensters entfernt - exponentiell oder linear. <br><br>  Der lineare gleitende Durchschnitt ist am einfachsten zu berechnen.  In Oracle ist dies die Funktion <code>avg (VALUE) over (partition by STOCK_NAME order by ADATE rows between 9 preceding and current row)</code> - ein gleitender Durchschnitt mit einem Mittelungsfenster von 10 Werten. <br><br>  Der lineare gleitende Durchschnitt hat Nachteile.  Erstens reagieren solche Durchschnittswerte langsam auf Marktumkehrungen.  Da viele Werte gemittelt werden, von denen jeder das gleiche Gewicht hat, erfolgt die durchschnittliche Antwort h√§ufig mehrere Zeitr√§ume nach einer Umkehrung des Verm√∂genspreises. <br><br>  Auch der lineare gleitende Durchschnitt ist nicht sehr effektiv, da er zweimal auf das Signal reagiert: als der Indikator das Schiebefenster betrat und es verlie√ü.  Der Rest reagiert nur auf die Eingabe des Indikators und entfernt ihn reibungslos aus der Berechnung, wenn Sie sich vom rechten Rand des Fensters nach links bewegen. <br><br>  Bei der Berechnung der <abbr title="Technischer Marktindikator">TIR</abbr> werden alle drei Arten von gleitenden Durchschnitten verwendet.  F√ºr exponentielle und linear gewichtete in diesem Artikel werden die Aggregatfunktionen <code>EMA</code> und <code>WMA</code> entwickelt, die in analytischer Form verwendet werden.  Zus√§tzlich k√∂nnen diese gleitenden Durchschnitte durch Rekursion oder Modell (Ausdruck <code>MODEL</code> ) berechnet werden. <br><br>  Eine Berechnung von EMA und WMA ohne Rekursion oder Modelka nur durch Analyse in der Oracle-Datenbank ist offensichtlich unm√∂glich. <br><br>  Aber immer noch Vorbehalte gegen gleitende Durchschnitte: <br><br><ul><li>  Je k√ºrzer die Mittelungsperiode ist und je empfindlicher das Verfahren auf Windungen reagiert, desto mehr gibt es falsche Signale. </li><li>  Je k√ºrzer die Mittelungsperiode ist, desto mehr Signale werden erzeugt, desto gr√∂√üer ist der Transaktionsaufwand, der sehr bedeutend werden kann. </li></ul><br><h2>  Technische Marktindikatoren </h2><br>  F√ºr fast jeden Indikator werden verschiedene Berechnungsmethoden angegeben: CALC - Berechnung mit PL / SQL-Code, SIMP - Berechnung durch einen Operator oder RECU - Berechnung durch Rekursion, AGRF - Berechnung mit der Aggregatfunktion, MODE - Berechnung nach Modell. <br><br>  Es gibt Gr√ºnde f√ºr die Entwicklung mehrerer Methoden.  Erstens k√∂nnen Sie durch Berechnen des <abbr title="Technischer Marktindikator">TIR</abbr> mit mehreren Methoden und Vergleichen der Indikatoren bei gleichen Indikatoren sicher sein, dass die Berechnungen korrekt durchgef√ºhrt wurden (unter Ber√ºcksichtigung der verschiedenen Methoden zum Runden und Verarbeiten der NULL- und "0" -Werte).  In diesem Artikel werde ich die Hashes von Stichproben verschiedener Methoden vergleichen, sodass die √úbereinstimmung mit Bits und die gleiche Verarbeitung durch alle Algorithmen garantiert ist. <br><br>  Ich glaube, dass Oracle mit der Entwicklung von <abbr title="Technischer Marktindikator">TIR</abbr> mit der SIMP-Methode beginnen muss - Berechnung durch einen Bediener.  Wenn dies erledigt ist, hat der Orakeloid einen Plan- und Berechnungsalgorithmus im Kopf und kann leicht in PL / SQL oder in eine andere prozedurale Sprache √ºbertragen werden. <br><br>  Ich stelle fest, dass die CALC-Berechnungsmethode f√ºr PL / SQL hier schneller ist als die SIMP-Methode (mit einem Operator), wenn die gesamte Berechnung in einem Durchgang entlang des Cursors durchgef√ºhrt werden kann.  Wenn Sie jedoch f√ºr die Berechnung tempor√§re Tabellen oder Sammlungen erstellen m√ºssen oder mehr als 1 Cursor √ºbergeben m√ºssen, wird sich die Methode mit einem Operator meiner Meinung nach als schneller und weniger ressourcenintensiv herausstellen. <br><br>  F√ºr alle Methoden, einschlie√ülich der SIMP-Methode (‚Äûone operator‚Äú), werde ich die Operatoren in Funktionen einf√ºgen, damit die Berechnung mit einem Parameter aufgerufen werden kann, um den optimalen Wert auszuw√§hlen. <br><br>  Die Berechnungen werden f√ºr sieben <abbr title="Technischer Marktindikator">TIRs durchgef√ºhrt</abbr> : Moving Average Intersection (EMASIMPLE), Goldene und t√∂dliche Kreuze (CROSSES), Balance-Volumen (OBV), Keltner-Kanal (KELTNER), Preis- und Volumentrend (PVT), Indikator f√ºr die Bewegungsfreiheit der Arme (EMV) ), Commodity Channel Index (CCI). <br><br>  F√ºr die sieben Indikatoren dieser beiden Artikel gibt es einen Parameter ‚ÄûMittelung der Fenstergr√∂√üe‚Äú und den zweiten Parameter - Verschiebung (Verz√∂gerung).  Die Verschiebung gibt an, wie viele Balken Sie ben√∂tigen, um die Ausf√ºhrung des Kauf- / Verkaufsauftrags zu verschieben - wie viele Balken, um den Schlusskurs zu verschieben (alle Bestellungen werden zum Schlusskurs des Balkens ausgef√ºhrt).  Dies ist √§hnlich wie "Schlupf", aber es ist nicht genau "Schlupf".  Slippage ist normalerweise nicht zugunsten des Kunden, und unsere Verz√∂gerung kann sich sowohl als nicht zugunsten des Kunden als auch zugunsten des Kunden herausstellen.  Die Verwendung der Modellierung mit einer Verz√∂gerung von 1 bis 5 Balken f√ºr einige Indikatoren zeigt jedoch, dass ein Schlupf einen signifikanten Einfluss auf das Ergebnis hat.  Und f√ºr einige Indikatoren sind Verz√∂gerung und Schlupf nicht so wichtig. <br><br>  Die Methoden SIMP ("Einzeloperator") und RECU ("Rekursion") <code>MATCH_RECOGNIZE</code> aktiv den Ausdruck <code>MATCH_RECOGNIZE</code> , um das <code>MATCH_RECOGNIZE</code> / VERKAUFEN basierend auf dem Ein- / Ausstieg des berechneten <abbr title="Technischer Marktindikator">TIR</abbr> in den angegebenen Bereich oder dessen Verhalten relativ zu seinem gleitenden Durchschnitt zu generieren. <br><br>  <em>Detaillierte Beschreibungen aller <abbr title="Technischer Marktindikator">TIRs</abbr> finden Sie auf Wikipedia oder in Robert Colbys Buch Encyclopedia of Technical Market Indicators.</em> <br><br><h3>  Der Schnittpunkt des exponentiellen gleitenden Durchschnitts </h3><br>  Die Methode zum Schneiden exponentieller gleitender Durchschnitte ist die einfachste <abbr title="Technischer Marktindikator">TIR</abbr> . <br><br>  Die Methode beinhaltet: Kaufen (Er√∂ffnen einer Long-Position), wenn der Preiswert seinen exponentiellen gleitenden Bottom-Up-Durchschnitt (ESA) √ºberschreitet;  Verkaufen (Schlie√üen einer Long-Position), wenn der Preis sein ESS von oben nach unten √ºberschreitet. <br><br>  Short-Positionen sowie der Margin-Handel im Allgemeinen werden in diesem Artikel nicht ber√ºcksichtigt. <br><br>  In Zukunft kann dieser Indikator als Standard f√ºr den Vergleich mit anderen verwendet werden.  Ein Vergleich mit dieser <abbr title="Technischer Marktindikator">TIR ist</abbr> besser als ein Vergleich mit der Buy and Hold-Strategie, da diese Strategie in fallenden M√§rkten nicht rentabel ist. <br><br>  Der einzige <abbr title="Technischer Marktindikator">TIR-</abbr> Parameter ist die L√§nge des gleitenden Durchschnitts. <br><br>  Berechnung mit PL / SQL <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_CALC (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">pipelined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; EMA number; prev_EMA number; prev_TYPICAL_PRICE number; retval HABR_MARKETINDEXES_RESULT_T := HABR_MARKETINDEXES_RESULT_T (null, null, null, null, null, null, null, null, null); prev_STOCK_NAME varchar2(256); l_alpha number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> l_alpha := <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>); for c1 in (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> retval.ADATE := c1.ADATE; retval.ACLOSE := c1.ACLOSE; if prev_STOCK_NAME is null or prev_STOCK_NAME &lt;&gt; c1.STOCK_NAME then retval.STOCK_NAME := c1.STOCK_NAME; EMA := c1.TYPICAL_PRICE; prev_EMA := null; else EMA := round (c1.TYPICAL_PRICE * l_alpha + EMA * (1 - l_alpha), 20); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; if prev_TYPICAL_PRICE &lt; prev_EMA and c1.TYPICAL_PRICE &gt; EMA then retval.AACTION := 'BUY'; elsif prev_TYPICAL_PRICE &gt; prev_EMA and c1.TYPICAL_PRICE &lt; EMA then retval.AACTION := 'SELL'; else retval.AACTION := null; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; retval.IND_VALUE := EMA; pipe row (retval); prev_STOCK_NAME := c1.STOCK_NAME; prev_EMA := EMA; prev_TYPICAL_PRICE := c1.TYPICAL_PRICE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  Berechnung durch einen rekursiven Operator <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_RECU (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 (STOCK_NAME, ADATE, TYPICAL_PRICE, EMA, ACLOSE, RN) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (TYPICAL_PRICE, <span class="hljs-number"><span class="hljs-number">20</span></span>), ACLOSE, RN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> RN = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.STOCK_NAME , b.ADATE , b.TYPICAL_PRICE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (b.TYPICAL_PRICE * <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>) + a.EMA * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-number"><span class="hljs-number">20</span></span>) , b.ACLOSE , b.RN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 a, LOAD_YAHOO_V b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.RN = a.RN + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.STOCK_NAME = a.STOCK_NAME) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, AACTION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 match_recognize (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> classifier() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AACTION all <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> per <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> unmatched <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> pattern (BUY+ | SELL+) <span class="hljs-keyword"><span class="hljs-keyword">define</span></span> BUY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &lt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA) , SELL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &gt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA) ) MR; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  Berechnung mit dem Ausdruck MODELL <br><div class="spoiler">  <b class="spoiler_title">Funktionstext HABR_MARKETINDEXES_EMASIMPLE_F_MODE</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_MODE (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dimension</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (STOCK_NAME, RN) <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> (ADATE, TYPICAL_PRICE, ACLOSE, to_number(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EMA) <span class="hljs-keyword"><span class="hljs-keyword">rules</span></span> (EMA[<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (TYPICAL_PRICE [cv(), cv()] * <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>) + nvl(EMA [cv(), cv() - <span class="hljs-number"><span class="hljs-number">1</span></span>], TYPICAL_PRICE [cv(), cv()]) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> / (p_averaging_window_width + <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-number"><span class="hljs-number">20</span></span>))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, ACLOSE , TYPICAL_PRICE, LAG (TYPICAL_PRICE) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PREV_TYPICAL_PRICE , EMA, lag (EMA) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PREV_EMA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> prev_TYPICAL_PRICE &lt; prev_EMA <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'BUY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> prev_TYPICAL_PRICE &gt; prev_EMA <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'SELL'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2 <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME, ADATE; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><br>  Berechnung mit der Aggregatfunktion <br><div class="spoiler">  <b class="spoiler_title">Der Text der EMA-Aggregatfunktion und der Funktion HABR_MARKETINDEXES_EMASIMPLE_F_AGRF</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EMA_DATA_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (AVALUE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, AVERAGING_WINDOW <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EMA_IMPL_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ( l_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, l_ema <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateInitialize (sctx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateIterate (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_DATA_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateMerge (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T, ctx2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateTerminate (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> EMA_IMPL_T, returnValue <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, flags <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">body</span></span> EMA_IMPL_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ODCIAggregateInitialize (sctx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> EMA_IMPL_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sctx := EMA_IMPL_T (<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateIterate (self in out EMA_IMPL_T, value in EMA_DATA_T) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value.AVALUE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l_window_width <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> l_window_width := value.AVERAGING_WINDOW; self.l_ema := value.AVALUE; else self.l_ema := round (value.AVALUE * 2 / (l_window_width + 1) + self.l_ema * (1 - 2 / (l_window_width + 1)), 20); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateMerge(self in out EMA_IMPL_T, ctx2 in EMA_IMPL_T) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ODCIConst.Error; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; member function ODCIAggregateTerminate(self in EMA_IMPL_T, returnValue out number, flags in number) return number is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> returnValue := self.l_ema; return ODCIConst.Success; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> EMA (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> EMA_DATA_T) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">aggregate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EMA_IMPL_T; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (p_averaging_window_width <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HABR_MARKETINDEXES_RESULT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> l_result HABR_MARKETINDEXES_RESULT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> STOCK_NAME, ADATE, TYPICAL_PRICE, ACLOSE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (EMA (EMA_DATA_T (TYPICAL_PRICE, p_averaging_window_width)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE), <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EMA <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOAD_YAHOO_V) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> HABR_MARKETINDEXES_RESULT_T (STOCK_NAME, ADATE, ACLOSE, EMA, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, AACTION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 match_recognize (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ADATE <span class="hljs-keyword"><span class="hljs-keyword">measures</span></span> classifier() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AACTION all <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> per <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> unmatched <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> pattern (BUY+ | SELL+) <span class="hljs-keyword"><span class="hljs-keyword">define</span></span> BUY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &lt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &gt; EMA) , SELL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (prev (TYPICAL_PRICE) &gt; prev (EMA) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TYPICAL_PRICE &lt; EMA) ) MR; return l_result; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div><br><br>  Vergleichen Sie die Berechnungsergebnisse mit einem Parameter: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN_VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ALG, dbms_sqlhash.gethash (<span class="hljs-keyword"><span class="hljs-keyword">COLUMN_VALUE</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RECORDSET_HASH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (sys.odcivarchar2list (<span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_RECU (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_MODE (15)) order by 1, 2'</span></span> , <span class="hljs-string"><span class="hljs-string">'select * from table (HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (15)) order by 1, 2'</span></span>));</code> </pre> <br>  Alle Hashes m√ºssen f√ºr alle vier Methoden √ºbereinstimmen. <br><br>  Wenn die Hashes nicht √ºbereinstimmen, k√∂nnen Sie mit diesem Operator genau herausfinden, wo sich die Diskrepanz gebildet hat (ersetzen Sie die Namen der Funktionen, die Sie vergleichen m√∂chten): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span> (a.STOCK_NAME, b.STOCK_NAME) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> STOCK_NAME, <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span> (a.ADATE, b.ADATE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ADATE , a.ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_ACLOSE, b.ACLOSE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_CLOSE , a.IND_VALUE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_EMA, b.IND_VALUE <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_EMA , a.AACTION <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CALC_AACTION, b.AACTION <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AGRF_AACTION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (<span class="hljs-number"><span class="hljs-number">15</span></span>)) a <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (HABR_MARKETINDEXES_EMASIMPLE_F_AGRF (<span class="hljs-number"><span class="hljs-number">15</span></span>)) b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a.STOCK_NAME = b.STOCK_NAME <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.ADATE = b.ADATE <span class="hljs-comment"><span class="hljs-comment">--where sys_op_map_nonnull (a.ACLOSE) &lt;&gt; sys_op_map_nonnull (b.ACLOSE) -- or sys_op_map_nonnull (a.IND_VALUE) &lt;&gt; sys_op_map_nonnull (b.IND_VALUE) -- or sys_op_map_nonnull (a.AACTION) &lt;&gt; sys_op_map_nonnull (b.AACTION) order by 1, 2; ;</span></span></code> </pre> <br>  <b>Auswahl der Parameter</b> <br><br>  Das <abbr title="Technischer Marktindikator">TIR</abbr> selbst verwendet einen Parameter, f√ºr diesen und f√ºr alle anderen <abbr title="Technischer Marktindikator">TIRs √§ndere</abbr> ich ihn im Bereich von 1 bis 200, aber um ein dreidimensionales Bild f√ºr die Abh√§ngigkeit und auch f√ºr die Verz√∂gerung zu berechnen, werden wir einen zweiten Parameter einf√ºhren, der von 1 bis 5 variiert. <br><br>  Der Operator √∂ffnet 200 * 5 = 1000 Cursor, sodass Oracle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OPEN_CURSORS</a> m√∂glicherweise ge√§ndert werden muss <br><br>  Die folgende Abfrage f√ºhrt das kartesische Produkt einer Tabelle mit Zahlen von 1 bis 200 mit einer Tabelle mit Zahlen von 1 bis 5 aus, und Cartesian multipliziert all dies durch Aufrufen der Tabellenfunktion <code>HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS</code> . <br><br>  Nach einigen weiteren Manipulationen in MATLAB erhalten wir eine 200 * 5-Matrix, wobei in den Matrixzellen f√ºr jeden Wert jedes der beiden Parameter ein Gesamtkapitalwert angegeben wird.  Als n√§chstes erstellen wir in MATLAB ein dreidimensionales Bild. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">rollback</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> INDICATOR_NAME = <span class="hljs-string"><span class="hljs-string">'HABR_MARKETINDEXES_EMASIMPLE_F_CALC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS (INDICATOR_NAME, PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TP1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;AVERAGING_INTERVAL) , TP2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;LAG_MODELLING_DEPTH) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-comment"><span class="hljs-comment">--+ parallel(8) 'HABR_MARKETINDEXES_EMASIMPLE_F_CALC', PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK from TP1 cross join TP2 cross join table (HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (cursor (select STOCK_NAME, ADATE, ACLOSE, AACTION from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (PARM1))), PARM2)) ; commit;</span></span></code> PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">rollback</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> INDICATOR_NAME = <span class="hljs-string"><span class="hljs-string">'HABR_MARKETINDEXES_EMASIMPLE_F_CALC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> HABR_MARKETINDEXES_PARMSEL_RESULTS (INDICATOR_NAME, PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TP1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;AVERAGING_INTERVAL) , TP2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PARM2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= &amp;&amp;LAG_MODELLING_DEPTH) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-comment"><span class="hljs-comment">--+ parallel(8) 'HABR_MARKETINDEXES_EMASIMPLE_F_CALC', PARM1, PARM2, STOCK_NAME, ADATE_MIN, ADATE_MAX, DEALS_COUNT, BALANCE_RESULT, DEALS_PROFIT_AMOUNT, DEALS_LOSS_AMOUNT, DEALS_PROFIT_COUNT, DEALS_LOSS_COUNT, IN_STOCK from TP1 cross join TP2 cross join table (HABR_TRADEMODELLING_P.CALC_ACTIONS_TOTALS (cursor (select STOCK_NAME, ADATE, ACLOSE, AACTION from table (HABR_MARKETINDEXES_EMASIMPLE_F_CALC (PARM1))), PARM2)) ; commit;</span></span></code> </pre> <br>  Alle Berechnungen in diesem Artikel werden langsam durchgef√ºhrt, bis zu 20 Minuten. Dies ist auf das √ñffnen einer gro√üen Anzahl von Cursorn zur√ºckzuf√ºhren. <br><br>  Ich habe auch eine schnellere Simulationsmethode mit einem Cursor entwickelt, ohne 1000 Cursor zu √∂ffnen, aber sie ist so umfangreich, dass sie die H√§lfte des Artikels in Anspruch nehmen w√ºrde.  Deshalb werde ich ihn nicht hierher bringen. <br><br>  Das Ergebnis der Modellierung des Schnittpunkts des gleitenden Durchschnitts (alle Diagramme sind anklickbar): <br> <a href=""><img src="https://habrastorage.org/webt/my/i8/1f/myi81fz9phsezv_f_igu2eic4ie.jpeg"><br></a> <br><br>  Die zweite Zeile der Diagramme ist dieselbe wie die erste Zeile, aber die Diagramme sind leicht gedreht. Diagramme mit unterschiedlichen Verz√∂gerungen sind nacheinander angeordnet.  Auf diese Weise k√∂nnen Sie die Auswirkung der Verz√∂gerung auf das Ergebnis bewerten. <br><br>  Im Allgemeinen reagiert der Indikator nicht sehr empfindlich auf Verz√∂gerungen.  F√ºr die M√§rkte S &amp; P500 und NYSE muss der <abbr title="Technischer Marktindikator">TIR-</abbr> Parameter ausgew√§hlt werden, je mehr, desto besser.  F√ºr den Brent-Markt sind es rund 25. In den beiden anderen M√§rkten besteht keine Korrelation zwischen der Rentabilit√§t und dem Parameter. <br><br><h3>  T√∂dliche und goldene Kreuze </h3><br>  In der Implementierung unter Oracle ist dieser Indikator dem vorherigen sehr √§hnlich, nur dass hier zwei gleitende Durchschnitte verwendet werden und nicht einer.  Daher werde ich nur eine Berechnungsoption geben. <br><br>  Das Wiki beschreibt den Ichimoku-Indikator.  Dies ist ein komplexer Indikator.  "Kreuze" sind einer der Bestandteile.  Aber der Indikator ist im Wiki schlecht beschrieben, insbesondere ist zu beachten, dass die Linien Tenkan und Kijun in v√∂llig unterschiedlichen Worten beschrieben werden, obwohl es tats√§chlich dasselbe ist, aber mit unterschiedlichen Zeitr√§umen. <br><br>  Im Buch von Robert Colby wird dieser Indikator ebenfalls nicht beschrieben. <br><br>  Japanische Analysten nennen den Schnittpunkt von Durchschnittswerten, wenn der kurzfristige Durchschnitt den langfristigen von unten nach oben kreuzt, das Goldene Kreuz (Goldenes Kreuz) und die entgegengesetzte Situation, wenn der kurzfristige gleitende Durchschnitt den langfristigen von oben nach unten kreuzt - das Tote Kreuz. <br><br>  Der Autor bemerkte, dass dieser Indikator im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûFutures for American Oil bildete ein‚Äû t√∂dliches Kreuz ‚Äú‚Äú beschrieben wurde</a> und begann, seine Beschreibung und Verwendung zu googeln. <br><br>  Dieser Indikator wird an der B√∂rse als ernst angesehen, auch weil er selten Signale gibt. <br><br>  Am h√§ufigsten werden gleitende Durchschnittswerte f√ºr 50 und 200 Perioden verwendet. <br><br>  Bei der Modellierung der folgenden Leistung nehmen wir den Zeitraum des langen gleitenden Durchschnitts gleich der Vierfachperiode des kurzen gleitenden Durchschnitts und simulieren die L√§nge des kurzen von 1 bis 200 Tagen (f√ºr den langen Zeitraum 4 bis 800 Tage). <br><br>  Code zur Berechnung auf GitHub. <br><br> <a href=""><img src="https://habrastorage.org/webt/7s/1a/c_/7s1ac_u_9vclmx2xelqzod7jvyi.png"></a> <br><br>  Der Indikator reagiert nicht sehr empfindlich auf Verz√∂gerungen.  F√ºr den S &amp; P500-Markt gibt es H√∂chstwerte bei 48 (192 f√ºr eine lange SS) und 98 Tagen (392 f√ºr eine lange SS).  Beachten Sie, dass das erste Maximum sehr nahe an den Zahlen 50x200 liegt.  Es ist davon auszugehen, dass Sie, wenn Sie diese Parameter 1 und 2 weniger als andere Marktteilnehmer w√§hlen, versuchen k√∂nnen, sie allein mit diesem Indikator zu schlagen. <br><br>  Es gibt 4 Hochs an der NYSE.  In den M√§rkten Brent und BTCUSD funktioniert der Indikator nicht. <br>  Auch f√ºr den EURUSD-Markt sollte der Parameter f√ºr eine kurze SS etwas weniger als 50 gew√§hlt werden.  Der Indikator liefert jedoch keinen Gewinn auf diesem Markt.  Es kann nur als zus√§tzlicher Indikator verwendet werden. <br><br><h3>  Ausgleichsvolumen, Gleichgewichtsvolumen, On-Balance-Volumen (OBV) </h3><br>  Der OBV-Indikator ist ein kumuliertes gleitendes durchschnittliches Handelsvolumen mit einem Pluszeichen bei einem wachsenden Markt und einem Minuszeichen bei einem fallenden Markt. <br><br>  Hier verwenden wir diese Methode zur Interpretation des Werts von Indikatoren: Kaufen, wenn der OBV seinen gleitenden Durchschnitt von unten nach oben √ºberschreitet, verkaufen, wenn der OBV seinen gleitenden Durchschnitt von oben nach unten √ºberschreitet. <br><br>  Mehr auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> oder Colby <br><br> <a href=""><img src="https://habrastorage.org/webt/rl/w1/fa/rlw1farsmtyjs7duejp1eao6e1u.png"></a> <br><br>  Auf dem S &amp; P500-Markt reagiert der Indikator sehr empfindlich auf Verz√∂gerungen (Verz√∂gerungen). Sie k√∂nnen jedoch versuchen, einen Parameter nach dem Prinzip ‚ÄûJe mehr desto besser‚Äú zu w√§hlen, um eine gewisse Rentabilit√§t zu erzielen.  An der NYSE kann keine Rentabilit√§t erreicht werden.  Auf dem Brent-Markt k√∂nnen Sie einen Parameterwert zwischen 20 und 100 ausw√§hlen. Auf dem BTCUSD-Markt gibt es keine klare lineare Beziehung, aber die Auswahl eines Parameterwerts von weniger als 40 ist unpraktisch.  F√ºr den EURUSD-Markt muss der Wert des Parameters ‚Äûje mehr desto besser‚Äú gew√§hlt werden, aber die Rentabilit√§t kann nicht erreicht werden. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keltner-Kanal </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besteht aus zwei B√§ndern oberhalb und unterhalb des gleitenden Durchschnittspreises, deren Breite als Bruchteil der durchschnittlichen Preis√§nderung f√ºr den Zeitraum bestimmt wird. </font><font style="vertical-align: inherit;">Der Preis ist ein typischer Preis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Mittellinie der Indikatorlinie ist ein einfacher gleitender Durchschnitt des typischen Preises. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oberen und unteren Linien des Indikators sind von der Mittellinie um einen Betrag getrennt, der dem einfachen gleitenden Durchschnitt der t√§glichen Handelsspanne entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unseren Berechnungen wird das </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR-</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signal </font><font style="vertical-align: inherit;">wie folgt gebildet: Kaufen, wenn der Preis die obere Linie √ºberschreitet, Verkaufen, wenn der Preis die untere Linie √ºberschreitet.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/_h/25/ls/_h25lsxaqle9wda7rehrzncb4ei.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Hochs f√ºr die M√§rkte S &amp; P500 und NYSE. </font><font style="vertical-align: inherit;">Auf dem Brent-Markt besteht keine Abh√§ngigkeit des Ergebnisses vom Parameter, und der gesamte Handel ist ratlos. </font><font style="vertical-align: inherit;">Es gibt Hochs auf dem BTCUSD-Markt, aber enge, und es ist schwierig, in diese hineinzukommen. </font><font style="vertical-align: inherit;">Auf dem EURUSD-Markt ist die Abh√§ngigkeit des Ergebnisses vom Parameter</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preis- und Volumentrend, Preis- und Volumentrend, Preis - Volumentrend, PVT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert des PVT-Indikators repr√§sentiert die kumulierte Summe des Produkts des aktuellen Handelsvolumens durch den gegen√ºber der Vorperiode verringerten Preisanstieg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden hier Handelssignale wie folgt generieren: Kaufen, wenn der PVT seinen gleitenden Durchschnitt von unten nach oben √ºberschreitet, Verkaufen, wenn der PVT seinen gleitenden Durchschnitt von oben nach unten √ºberschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Colby fand nicht. </font><font style="vertical-align: inherit;">F√ºr den S &amp; P500, den Wert des Parameters ‚Äûje gr√∂√üer desto besser‚Äú, besteht fast keine Abh√§ngigkeit von der NYSE, f√ºr Brent gibt es ein Maximum im Bereich von 50, f√ºr BTCUSD ist der Indikator nur mit minimalen Verz√∂gerungen von 1-2 und mit minimalen Parameterwerten von bis zu 50 wirksam F√ºr EURUSD nimmt die Abh√§ngigkeit zu.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/d9/5q/ay/d95qay3lujgc3dplp4rgkorrgyq.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leichtigkeit der Bewegung, Leichtigkeit der Waffen Bewegungswert, EMV </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EMV ist ein numerischer Ausdruck daf√ºr, wie leicht sich ein Preis in einem Markt √§ndert. </font><font style="vertical-align: inherit;">Je st√§rker die Preis√§nderung und je geringer der Umsatz, desto leichter steigt oder f√§llt der Markt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier bilden wir die Handelsauftr√§ge wie folgt: Kaufen, wenn der gleitende Durchschnitt EMV √ºber Null steigt, Verkaufen, wenn der gleitende Durchschnitt EMV unter Null f√§llt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Colby. </font><font style="vertical-align: inherit;">Auf den S &amp; P- und NYSE-M√§rkten gibt es Hochs, auf dem Brent-Markt ist der Indikator in einer Vielzahl von Parameterwerten wirksam. </font><font style="vertical-align: inherit;">Auf den BTCUSD- und EURUSD-M√§rkten ist der Indikator unwirksam.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/3o/9r/yk/3o9ryk2ufl7fh-xi7t755zughpq.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warenkanalindex, CCI </font></font></h3><br> <abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCI ist ein Indikator, der auf der Analyse der aktuellen √Ñnderung der Preisabweichung von ihrem Durchschnittswert f√ºr einen bestimmten Zeitraum und dem durchschnittlichen Absolutwert dieses Parameters basiert. </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR gilt</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr alle Finanzm√§rkte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Handelsauftr√§ge wie folgt bilden: Kaufen, wenn der CCI √ºber 100 steigt, Verkaufen, wenn der CCI unter 100 f√§llt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehr auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Colby. </font><font style="vertical-align: inherit;">In den M√§rkten S &amp; P500, NYSE, Brent besteht keine Abh√§ngigkeit des Handelsergebnisses vom Wert des Parameters. Es besteht eine Abh√§ngigkeit vom BTCUSD-Markt (zwei deutliche H√∂chstst√§nde), und Sie k√∂nnen versuchen, ihn im realen Handel zu fangen. Auf dem EURUSD-Markt wird der Indikator f√ºr das Ergebnis nicht bringen. </font><b><font style="vertical-align: inherit;">Quellen auf </font></b><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Github</font></a></b><b><font style="vertical-align: inherit;"> verf√ºgbar</font></b></font><br><br> <a href=""><img src="https://habrastorage.org/webt/vr/uc/ob/vrucob8honvqk0dsynnz5t7zqtw.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie gemeinsame Objekte, laden Sie Daten hoch, entweder meine (wie ich bereits sagte, alle M√§rkte au√üer den letzten stammen von Yahoo Finance), oder erstellen Sie eigene Funktionen zum Berechnen, Berechnen von Handelsleistungsdaten (wie bereits erw√§hnt, Berechnen jedes Indikators f√ºr bis zu 20 Minuten) . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die allgemeine Schlussfolgerung bez√ºglich der </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwendung nur eines Gewinnindikators ist unm√∂glich. Unterschiedliche Indikatoren sind in verschiedenen M√§rkten unterschiedlich wirksam. Die M√∂glichkeit, mit mehreren gut abgestimmten Indikatoren und zus√§tzlichen externen Informationen Gewinne zu erzielen, ist nicht ausgeschlossen.</font></font><br><br>  Optional: <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurden drei weitere Indikatoren analysiert, die nicht im Artikel enthalten sind. </font><font style="vertical-align: inherit;">Aber sie konnten kein Ergebnis erzielen. </font><font style="vertical-align: inherit;">Vielleicht wird ihr Studium fortgesetzt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist </font><font style="vertical-align: inherit;">sehr praktisch </font><font style="vertical-align: inherit;">, Berechnungen und komplexe Modellierungen von </font></font><abbr title="Technischer Marktindikator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIR-</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Finanzaktivit√§ten im Allgemeinen in Oracle Database </font><font style="vertical-align: inherit;">durchzuf√ºhren </font><font style="vertical-align: inherit;">.</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455050/">https://habr.com/ru/post/de455050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455032/index.html">Kein Fehler, sondern ein Merkmal: eine Untersuchung der Motilit√§t und Gehirnaktivit√§t einer Person mit Polydaktylie</a></li>
<li><a href="../de455038/index.html">Wie Plesk die KubeCon besucht hat</a></li>
<li><a href="../de455040/index.html">Verbesserung der Arbeit von Wi-Fi. Teil 2. Ausstattungsmerkmale</a></li>
<li><a href="../de455042/index.html">Kotlin DSL, Fixtures und elegante UI-Tests in Android</a></li>
<li><a href="../de455046/index.html">N + 7 n√ºtzliche B√ºcher</a></li>
<li><a href="../de455052/index.html">Sommer DIYorDIE Meetup 16. Juni</a></li>
<li><a href="../de455056/index.html">Primitive Grafiken f√ºr Lazy, Oldfags und Lazy Oldfags</a></li>
<li><a href="../de455058/index.html">Berechnete Handlung oder Rollenspielinfektion</a></li>
<li><a href="../de455060/index.html">Homer oder die erste OpenSource. Teil 1</a></li>
<li><a href="../de455062/index.html">F√§lle erfolgreicher (und nicht so) Experimente mit Yandex.Navigator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>