<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌄 👐🏻 🧒🏼 Wie der optimierende Compiler funktioniert 🧕🏼 🏅 📯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Optimierung von Compilern ist die Basis moderner Software: Sie ermöglichen es Programmierern, Code in einer Sprache zu schreiben, die sie verstehe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie der optimierende Compiler funktioniert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/477062/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/uq/bo/ucuqbo4tluzynnptop1pdmdvjhc.jpeg"></div><br>  Die Optimierung von Compilern ist die Basis moderner Software: Sie ermöglichen es Programmierern, Code in einer Sprache zu schreiben, die sie verstehen, und ihn dann in Code umzuwandeln, der von Geräten effizient ausgeführt werden kann.  Die Aufgabe der Optimierung von Compilern besteht darin, die Funktionsweise des von Ihnen geschriebenen Eingabeprogramms zu verstehen und ein Ausgabeprogramm zu erstellen, das dasselbe nur schneller ausführt. <br><br>  In diesem Artikel werden einige der grundlegenden Inferenztechniken zur Optimierung von Compilern vorgestellt: Entwerfen eines Programms, mit dem der Compiler problemlos arbeiten kann;  Welche Reduzierungen können in Ihrem Programm vorgenommen werden und wie können Sie sie verwenden, um es zu reduzieren und zu beschleunigen? <br><a name="habracut"></a><br>  Programmoptimierer können überall ausgeführt werden: im Rahmen eines umfangreichen Kompilierungsprozesses ( <a href="https://www.lightbend.com/blog/scala-inliner-optimizer">Scala Optimizer</a> );  als separates Programm, das nach dem Compiler und vor der Ausführung gestartet wird ( <a href="https://www.guardsquare.com/en/products/proguard">Proguard</a> );  oder als Teil einer Laufzeitumgebung, die ein Programm während seiner Ausführung optimiert ( <a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/">JVM JIT-Compiler</a> ).  Die Einschränkungen bei der Arbeit von Optimierern variieren je nach Situation, aber sie haben eine Aufgabe: das Eingabeprogramm zu nehmen und es in das Ausgabeprogramm umzuwandeln, was dasselbe tut, aber schneller. <br><br>  Zunächst werden einige Beispiele für Optimierungen des Programmentwurfs vorgestellt, damit Sie verstehen, was Optimierer normalerweise tun und wie sie manuell ausgeführt werden.  Anschließend werden verschiedene Möglichkeiten zur Präsentation von Programmen betrachtet und schließlich die Algorithmen und Techniken analysiert, mit denen Sie Programme analysieren und dann kleiner und schneller machen können. <br><br><h2>  Programmentwurf </h2><br>  Alle Beispiele werden in Java gegeben.  Diese Sprache ist sehr verbreitet und wird zu einem relativ einfachen Assembler kompiliert - <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java Bytecode</a> .  Wir werden also eine gute Grundlage schaffen, dank derer wir Kompilierungsoptimierungstechniken anhand realer, ausführbarer Beispiele untersuchen können.  Alle unten beschriebenen Techniken sind in fast allen anderen Programmiersprachen anwendbar. <br><br>  Betrachten Sie zunächst einen Programmentwurf.  Es enthält verschiedene Logik, registriert das Standardergebnis innerhalb des Prozesses und gibt das berechnete Ergebnis zurück.  Das Programm selbst ist nicht sinnvoll, wird jedoch als Beispiel dafür verwendet, was unter Beibehaltung des vorhandenen Verhaltens optimiert werden kann: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; Logger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); total += ackermann(multiplied, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); total += d1 * multiplied; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } <span class="hljs-comment"><span class="hljs-comment">// https://en.wikipedia.org/wiki/Ackermann_function static int ackermann(int m, int n){ if (m == 0) return n + 1; else if (n == 0) return ackermann(m - 1, 1); else return ackermann(m - 1, ackermann(m, n - 1)); } interface Logger{ public Logger log(Object a); } static class PrintLogger implements Logger{ public PrintLogger log(Object a){ System.out.println(a); return this; } } static class ErrLogger implements Logger{ public ErrLogger log(Object a){ System.err.println(a); return this; } }</span></span></code> </pre> <br>  Im Moment gehen wir davon aus, dass dieses Programm alles ist, was wir haben, kein anderer Teil des Codes nennt es.  Es gibt einfach Daten in <code>main</code> , führt sie aus und gibt das Ergebnis zurück.  Nun optimieren wir dieses Programm. <br><br><h2>  Optimierungsbeispiele </h2><br><h4>  Typguss und Inlining </h4><br>  Möglicherweise haben Sie bemerkt, dass die <code>logger</code> Variable einen ungenauen Typ hat: Trotz der <code>Logger</code> Bezeichnung können wir aufgrund des Codes den Schluss ziehen, dass es sich um eine bestimmte Unterklasse handelt - <code>PrintLogger</code> : <br><br><pre> <code class="java hljs">- Logger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); + PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger();</code> </pre> <br>  Jetzt wissen wir, dass <code>PrintLogger</code> , und wir wissen, dass der Aufruf von <code>logger.log</code> eine einzige Implementierung haben kann.  Sie können inline: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.logcount(); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count);</code> </pre> <br>  Dadurch wird das Programm reduziert, indem die nicht verwendete <code>ErrLogger</code> Klasse entfernt wird, die nicht verwendet wird, und indem verschiedene Methoden des <code>public Logger</code> <code>log</code> gelöscht werden, da wir es an einer einzigen Stelle des Aufrufs <code>ErrLogger</code> . <br><br><h2>  Koagulationskonstanten </h2><br>  Während der Programmausführung ändern sich <code>count</code> und <code>total</code> , aber <code>multiplied</code> nicht: Sie beginnt bei <code>0</code> und wird jedes Mal durch <code>multiplied = multiplied * count</code> , wobei sie gleich <code>0</code> bleibt.  Sie können es also im gesamten Programm durch <code>0</code> ersetzen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>; PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; - multiplied *= count; - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count); + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); - total += ackermann(multiplied, n); + total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); - total += d1 * multiplied; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; }</code> </pre> <br>  Als Ergebnis sehen wir, dass <code>d1 * multiplied</code> immer <code>0</code> , was bedeutet, dass <code>total += d1 * multiplied</code> nichts bewirkt und gelöscht werden kann: <br><br><pre> <code class="java hljs">- total += d1 * multiplied</code> </pre><br><h4>  Entfernung des toten Codes </h4><br>  Nachdem Sie <code>multiplied</code> gefaltet haben und festgestellt haben, dass <code>total += d1 * multiplied</code> nichts bewirkt, können Sie die Definition von <code>int d1</code> entfernen: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d1 = ackermann(n, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Dies ist nicht mehr Teil des Programms, und da es sich bei <code>ackermann</code> um eine reine Funktion handelt, hat die Deinstallation keine Auswirkungen auf das Ergebnis des Programms. <br><br>  In ähnlicher <code>logger.log</code> wird der <code>logger</code> selbst nach dem Inlining von <code>logger.log</code> nicht mehr verwendet und kann entfernt werden: <br><br><pre> <code class="java hljs">- PrintLogger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintLogger();</code> </pre><br><h4>  Astentfernung </h4><br>  Nun hängt der erste bedingte Übergang in unserem Zyklus von <code>0 &lt; 100</code> .  Da dies immer zutrifft, können Sie einfach die Bedingung entfernen: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) System.out.println(count); + System.out.println(count);</code> </pre> <br>  Jeder bedingte Übergang, der immer wahr ist, kann in den Hauptteil der Bedingung integriert werden. Bei Übergängen, die immer falsch sind, können Sie die Bedingung zusammen mit ihrem Hauptteil löschen. <br><br><h4>  Teilberechnung </h4><br>  Nun analysieren wir die drei verbleibenden Anrufe bei <code>ackermann</code> : <br><br><pre> <code class="java hljs"> total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count);</code> </pre><br><ul><li>  Der erste hat zwei konstante Argumente.  Die Funktion ist rein und nach vorläufiger Berechnung sollte <code>ackermann(2, 2)</code> gleich <code>7.</code> </li><li>  Der zweite Aufruf hat ein konstantes Argument <code>0</code> und ein unbekanntes <code>n</code> .  Sie können es an die Definition von <code>ackermann</code> , und es stellt sich heraus, dass die Funktion immer <code>n + 1.</code> zurückgibt, wenn <code>m</code> <code>0</code> ist <code>n + 1.</code> <br></li><li>  Beim dritten Aufruf sind beide Argumente unbekannt: <code>n</code> und <code>count</code> .  Lassen wir sie vorerst an Ort und Stelle. <br></li></ul><br>  Vorausgesetzt, der Anruf bei <code>ackermann</code> ist wie folgt definiert: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Sie können es vereinfachen, um: <br><br><pre> <code class="java hljs">- total += ackermann(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); + total += <span class="hljs-number"><span class="hljs-number">7</span></span> - total += ackermann(<span class="hljs-number"><span class="hljs-number">0</span></span>, n); + total += n + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count);</code> </pre><br><h4>  Verspätete Planung </h4><br>  Die Definition von <code>d2</code> nur im <code>if (count % 2 == 0)</code> bedingten <code>if (count % 2 == 0)</code> .  Da die <code>ackermann</code> Berechnung sauber ist, können Sie diesen Aufruf an einen bedingten <code>ackermann</code> weiterleiten, sodass er erst verarbeitet wird, wenn er verwendet wird: <br><br><pre> <code class="java hljs">- <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); - <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) total += d2; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); + total += d2; + }</code> </pre> <br>  Dadurch wird die Hälfte der Aufrufe von <code>ackermann(n, count)</code> vermieden und die Programmausführung beschleunigt. <br><br>  Zum Vergleich: Die Funktion <code>System.out.println</code> ist nicht sauber. <code>System.out.println</code> bedeutet, dass sie nicht innerhalb oder außerhalb von bedingten Sprüngen übertragen werden kann, ohne die Semantik des Programms zu ändern. <br><br><h2>  Optimiertes Ergebnis </h2><br>  Nachdem wir alle Optimierungen gesammelt haben, erhalten wir den folgenden Quellcode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; System.out.println(count); total += <span class="hljs-number"><span class="hljs-number">7</span></span>; total += n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { total += d2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d2 = ackermann(n, count); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Obwohl wir manuell optimiert haben, kann dies alles automatisch erfolgen.  Das folgende ist das dekompilierte Ergebnis des Prototyp-Optimierers, den ich für JVM-Programme geschrieben habe: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo.PrintLogger(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var3; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; var2 &lt; var0; var2 = var3) { System.out.println(var3 = <span class="hljs-number"><span class="hljs-number">1</span></span> + var2); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var10000 = var3 % <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var7 = var1 + <span class="hljs-number"><span class="hljs-number">7</span></span> + var0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; var1 = var10000 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? var7 + ackermann(var0, var3) : var7; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann__I__TI1__I</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>, var0 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : ackermann__I__TI1__I(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>);); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var1 == <span class="hljs-number"><span class="hljs-number">0</span></span> ? ackermann__I__TI1__I(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>) : ackermann(var0 - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(var0, var1 - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintLogger</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Der dekompilierte Code unterscheidet sich geringfügig von der manuell optimierten Version.  Etwas, das der Compiler nicht optimieren konnte (zum Beispiel ein nicht verwendeter Aufruf von <code>new PrintLogger</code> ), aber etwas wurde etwas anders gemacht (zum Beispiel sind <code>ackermann</code> und <code>ackermann__I__TI1__I</code> ).  Im Übrigen hat der automatische Optimierer das Gleiche getan wie ich, indem er die darin eingebettete Logik verwendet hat. <br><br>  Es stellt sich die Frage: Wie? <br><br><h2>  Zwischenansichten </h2><br>  Wenn Sie versuchen, Ihr eigenes Optimierungsprogramm zu erstellen, ist die erste Frage möglicherweise die wichtigste: Was ist ein „Programm“? <br><br>  Zweifellos sind Sie es gewohnt, Programme als Quellcode zu schreiben und zu ändern.  Sie haben sie definitiv in Form von kompilierten Binärdateien ausgeführt, vielleicht sogar die Binärdateien debuggt.  Möglicherweise sind Sie auf Programme in Form eines <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Syntaxbaums</a> , eines <a href="https://en.wikipedia.org/wiki/Three-address_code">Codes mit drei Adressen</a> , eines <a href="https://en.wikipedia.org/wiki/A-normal_form">A-Normalen</a> , eines <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation Passing-Stils</a> oder einer <a href="https://ru.wikipedia.org/wiki/SSA">einzelnen statischen Zuweisung gestoßen</a> . <br><br>  Es gibt einen ganzen Zoo mit verschiedenen Darstellungen von Programmen.  Hier werden die wichtigsten Möglichkeiten zur Darstellung eines „Programms“ im Optimierer erläutert. <br><br><h2>  Quellcode </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Nicht kompilierter Quellcode ist auch eine Darstellung Ihres Programms.  Es ist relativ kompakt, für Menschen lesbar, hat aber zwei Nachteile: <br><br><ul><li>  Der Quellcode enthält alle Details der Namen und Formatierungen, die für den Programmierer wichtig, für den Computer jedoch unbrauchbar sind. <br></li><li>  Fehlerhafte Programme in Form von Quellcode sind viel zahlreicher als korrekte. Während der Optimierung müssen Sie sicherstellen, dass Ihr Programm vom richtigen Eingabequellcode in den richtigen Ausgabequellcode konvertiert wird. <br></li></ul><br>  Diese Faktoren erschweren es dem Optimierer, mit dem Programm in Form von Quellcode zu arbeiten.  Ja, Sie <i>können ein</i> solches Programm beispielsweise mit <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">regulären Ausdrücken</a> konvertieren, um Muster <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">zu</a> identifizieren und zu ersetzen.  Der erste von zwei Faktoren macht es jedoch schwierig, Muster mit einer Fülle von irrelevanten Details zuverlässig zu identifizieren.  Und der zweite Faktor erhöht die Wahrscheinlichkeit, verwirrt zu werden und ein falsches Programm zu erhalten, erheblich. <br><br>  Diese Einschränkungen sind für Programmkonverter akzeptabel, die unter menschlicher Aufsicht ausgeführt werden, z. B. wenn Sie <a href="https://github.com/facebook/codemod">Codemod</a> zum Umgestalten und Transformieren der Codebasis verwenden können.  Sie können den Quellcode jedoch nicht als primäres Modell eines automatisierten Optimierers verwenden. <br><br><h2>  Abstrakte Syntaxbäume </h2><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) )</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/019/324/e0101932411807ddb7abb9c120033f58.png"><br><br>  Abstract Syntax Trees (AST) ist ein weiteres gängiges Zwischenformat.  Sie befinden sich im nächsten Schritt der Abstraktionsleiter im Vergleich zum Quellcode.  In der Regel verwirft AST alle Formatierungen, Einrückungen und Kommentare des Quellcodes, behält jedoch die Namen lokaler Variablen bei, die in abstrakteren Darstellungen verworfen werden. <br><br>  Wie der Quellcode leidet AST unter der Möglichkeit, unnötige Informationen zu codieren, die die tatsächliche Semantik des Programms nicht beeinflussen.  Beispielsweise sind die folgenden zwei Codefragmente semantisch identisch.  Sie unterscheiden sich nur in den Namen der lokalen Variablen, haben aber immer noch unterschiedliche ASTs: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermannA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannA(q - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannA(q - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermannA(q, p - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } Block( Assign(<span class="hljs-string"><span class="hljs-string">"p"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>)), Assign(<span class="hljs-string"><span class="hljs-string">"q"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>)), IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"q"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"p"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) ) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermannB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannB(s - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermannB(s - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermannB(s, r - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } Block( Assign(<span class="hljs-string"><span class="hljs-string">"r"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"n"</span></span>)), Assign(<span class="hljs-string"><span class="hljs-string">"s"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"m"</span></span>)), IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"+"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = IfElse( cond = BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"=="</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">0</span></span>)), then = Return(Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> = Return( Call( <span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>)), Call(<span class="hljs-string"><span class="hljs-string">"ackermann"</span></span>, Ident(<span class="hljs-string"><span class="hljs-string">"s"</span></span>), BinOp(Ident(<span class="hljs-string"><span class="hljs-string">"r"</span></span>), <span class="hljs-string"><span class="hljs-string">"-"</span></span>, Literal(<span class="hljs-number"><span class="hljs-number">1</span></span>))) ) ) ) ) )</code> </pre> <br>  Der entscheidende Punkt ist, dass ASTs zwar eine Baumstruktur haben, aber Knoten enthalten, die sich semantisch nicht wie Bäume verhalten: Die Werte von <code>Ident("r")</code> und <code>Ident("s")</code> nicht durch den Inhalt ihrer Teilbäume bestimmt, sondern durch die vorgelagerten <code>Assign("r", ...)</code> Knoten <code>Assign("r", ...)</code> und <code>Assign("s", ...)</code> .  Tatsächlich gibt es zusätzliche semantische Beziehungen zwischen <code>Ident</code> und <code>Assign</code> , die genauso wichtig sind wie Kanten in der AST-Baumstruktur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a17/62a/9a0/a1762a9a0a21d0b0e4fac6afb4f23335.png"><br><br>  Diese Verbindungen bilden eine verallgemeinerte Graphstruktur, einschließlich Zyklen bei rekursiven Definitionen von Funktionen. <br><br><h2>  Bytecode </h2><br>  Da wir Java als Hauptsprache gewählt haben, werden kompilierte Programme als Java-Bytecode in .class-Dateien gespeichert. <br><br>  Erinnern Sie sich an unsere <code>ackermann</code> Funktion: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ackermann</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ackermann(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, ackermann(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Es kompiliert zu diesem Bytecode: <br><br><pre> <code class="java hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">14</span></span>: isub <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">22</span></span>: isub <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">26</span></span>: isub <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn</code> </pre> <br>  Die Java Virtual Machine (JVM), auf der der Java-Bytecode ausgeführt wird, ist eine Maschine mit einer Kombination aus Stapel und Registern: Es gibt einen Stapel von Operanden (STACK), in denen Werte bearbeitet werden, und ein Array lokaler Variablen (LOCALS), in denen diese Werte gespeichert werden können.  Die Funktion beginnt mit N Parametern in den ersten N Slots lokaler Variablen.  Während der Ausführung verschiebt die Funktion die Daten auf den Stapel, bearbeitet sie, setzt sie in die Variablen zurück und ruft <code>return</code> auf, um den Wert vom Operandenstapel an den Aufrufer zurückzugeben. <br><br>  Wenn Sie den obigen Bytecode mit Anmerkungen versehen, um Werte darzustellen, die zwischen dem Stapel und der lokalen Variablentabelle verschoben werden, sieht dies folgendermaßen aus: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| |v4| <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |v4|a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v4|v6| <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Hier habe <code>a1</code> mit <code>a0</code> und <code>a1</code> der Funktion die Argumente präsentiert, die in der Tabelle LOCALS ganz am Anfang der Funktion gespeichert sind.  <code>1</code> repräsentiert Konstanten, die über <code>iconst_1</code> geladen wurden und von <code>v1</code> bis <code>v7</code> berechnete Zwischenwerte.  Es gibt drei <code>ireturn</code> , die <code>v1</code> , <code>v3</code> und <code>v7</code> .  Diese Funktion definiert keine anderen lokalen Variablen, daher speichert das LOCALS-Array nur Eingabeargumente. <br><br>  Wir haben oben zwei Optionen für unsere Funktion gesehen - <code>ackermannA</code> und <code>ackermannB</code> .  Also schauen sie im Bytecode: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>: istore_2 |a0|a1|a1| | <span class="hljs-number"><span class="hljs-number">2</span></span>: iload_0 |a0|a1|a1| |a0| <span class="hljs-number"><span class="hljs-number">3</span></span>: istore_3 |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">5</span></span>: ifne <span class="hljs-number"><span class="hljs-number">12</span></span> |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_2 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: iconst_1 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">10</span></span>: iadd |a0|a1|a1|a0| |v1| <span class="hljs-number"><span class="hljs-number">11</span></span>: ireturn |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_2 |a0|a1|a1|a0| |a1| <span class="hljs-number"><span class="hljs-number">13</span></span>: ifne <span class="hljs-number"><span class="hljs-number">24</span></span> |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">16</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">17</span></span>: iconst_1 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">18</span></span>: isub |a0|a1|a1|a0| |v2| <span class="hljs-number"><span class="hljs-number">19</span></span>: iconst_1 |a0|a1|a1|a0| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">20</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v3| <span class="hljs-number"><span class="hljs-number">23</span></span>: ireturn |a0|a1|a1|a0| | <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_3 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1|a1|a0| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1|a1|a0| |v4| <span class="hljs-number"><span class="hljs-number">27</span></span>: iload_3 |a0|a1|a1|a0| |v4|a0| <span class="hljs-number"><span class="hljs-number">28</span></span>: iload_2 |a0|a1|a1|a0| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">29</span></span>: iconst_1 |a0|a1|a1|a0| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">30</span></span>: isub |a0|a1|a1|a0| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">31</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v4|v6| <span class="hljs-number"><span class="hljs-number">34</span></span>: invokestatic ackermannA:(II)I |a0|a1|a1|a0| |v7| <span class="hljs-number"><span class="hljs-number">37</span></span>: ireturn |a0|a1|a1|a0| |</code> </pre> <br>  Da der Quellcode zwei Argumente akzeptiert und in lokale Variablen einfügt, verfügt der Bytecode über die entsprechenden Anweisungen, um die Argumentwerte aus den LOCAL-Indizes 0 und 1 zu laden und unter den Indizes 2 und 3 zu speichern. Der Bytecode interessiert sich jedoch nicht für die Namen Ihrer lokalen Variablen: Er funktioniert mit von ihnen ausschließlich wie bei Indizes im LOCALS-Array.  Daher haben <code>ackermannA</code> und <code>ackermannB</code> identische Bytecodes.  Das ist logisch, weil sie semantisch äquivalent sind! <br><br>  <code>ackermannA</code> und <code>ackermannB</code> werden jedoch nicht in denselben Bytecode wie der ursprüngliche <code>ackermann</code> kompiliert: Obwohl der Bytecode von den Namen lokaler Variablen abstrahiert wird, wird er vom Laden und Speichern in / aus diesen Variablen immer noch nicht vollständig abstrahiert.  Für uns ist es immer noch wichtig, wie sich die Werte entlang LOCALS und STACK bewegen, obwohl sie das tatsächliche Verhalten des Programms nicht beeinflussen. <br><br>  Neben der fehlenden Abstraktion vom Laden / Speichern hat der Bytecode einen weiteren Nachteil: Wie die meisten linearen Assembler ist er hinsichtlich seiner Kompaktheit sehr optimiert und kann bei Optimierungen sehr schwierig zu modifizieren sein. <br><br>  Schauen wir uns zur Verdeutlichung den Bytecode der ursprünglichen <code>ackermann</code> Funktion an: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| |v4| <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |v4|a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |v4|a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |v4|a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v4|v6| <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Nehmen wir eine grobe Änderung vor: Lassen Sie den Funktionsaufruf <code>30: invokestatic ackermann:(II)I</code> verwende sein erstes Argument nicht.  Und dann kann dieser Aufruf durch den entsprechenden Aufruf <code>30: invokestatic ackermann2:(I)I</code> , der nur ein Argument <code>30: invokestatic ackermann2:(I)I</code> .  Dies ist eine übliche Optimierung, die es ermöglicht, mithilfe der "Entfernung toten Codes" jeden Code zu <code>30: invokestatic ackermann:(II)I</code> der zur Berechnung des ersten Arguments <code>30: invokestatic ackermann:(II)I</code> <br><br>  Dazu müssen wir nicht nur die Anweisung <code>30</code> ersetzen, sondern auch die Liste der Anweisungen betrachten und verstehen, wo das erste Argument berechnet wird ( <code>v4</code> in <code>STACK</code> ), und es auch löschen.  Wir kehren von den Anweisungen <code>30</code> bis <code>22</code> und von <code>22</code> bis <code>21</code> und <code>20</code> .  Die endgültige Version: <br><br><pre> <code class="java hljs"> BYTECODE LOCALS STACK |a0|a1| | <span class="hljs-number"><span class="hljs-number">0</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>: ifne <span class="hljs-number"><span class="hljs-number">8</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">4</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">5</span></span>: iconst_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">6</span></span>: iadd |a0|a1| |v1| <span class="hljs-number"><span class="hljs-number">7</span></span>: ireturn |a0|a1| | <span class="hljs-number"><span class="hljs-number">8</span></span>: iload_1 |a0|a1| |a1| <span class="hljs-number"><span class="hljs-number">9</span></span>: ifne <span class="hljs-number"><span class="hljs-number">20</span></span> |a0|a1| | <span class="hljs-number"><span class="hljs-number">12</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">13</span></span>: iconst_1 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">14</span></span>: isub |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">15</span></span>: iconst_1 |a0|a1| |v2| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">16</span></span>: invokestatic ackermann:(II)I |a0|a1| |v3| <span class="hljs-number"><span class="hljs-number">19</span></span>: ireturn |a0|a1| | - <span class="hljs-number"><span class="hljs-number">20</span></span>: iload_0 |a0|a1| | - <span class="hljs-number"><span class="hljs-number">21</span></span>: iconst_1 |a0|a1| | - <span class="hljs-number"><span class="hljs-number">22</span></span>: isub |a0|a1| | <span class="hljs-number"><span class="hljs-number">23</span></span>: iload_0 |a0|a1| |a0| <span class="hljs-number"><span class="hljs-number">24</span></span>: iload_1 |a0|a1| |a0|a1| <span class="hljs-number"><span class="hljs-number">25</span></span>: iconst_1 |a0|a1| |a0|a1| <span class="hljs-number"><span class="hljs-number">1</span></span>| <span class="hljs-number"><span class="hljs-number">26</span></span>: isub |a0|a1| |a0|v5| <span class="hljs-number"><span class="hljs-number">27</span></span>: invokestatic ackermann:(II)I |a0|a1| |v6| - <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann:(II)I |a0|a1| |v7| + <span class="hljs-number"><span class="hljs-number">30</span></span>: invokestatic ackermann2:(I)I |a0|a1| |v7| <span class="hljs-number"><span class="hljs-number">33</span></span>: ireturn |a0|a1| |</code> </pre> <br>  Wir können immer noch eine so einfache Änderung an einer einfachen <code>ackermann</code> Funktion vornehmen.  Bei den großen Funktionen, die in realen Projekten verwendet werden, wird es jedoch viel schwieriger sein, zahlreiche miteinander verbundene Änderungen vorzunehmen.  Im Allgemeinen kann jede kleine semantische Änderung an Ihrem Programm zahlreiche Änderungen im gesamten Bytecode erforderlich machen. <br><br>  Möglicherweise stellen Sie fest, dass wir die oben beschriebene Änderung durch Analysieren der Werte in LOCALS und STACK vorgenommen haben: Wir haben beobachtet, wie <code>v4</code> von Anweisung <code>22</code> an Anweisung <code>30</code> wird und <code>22</code> Daten zu <code>a0</code> und <code>1</code> , die von den Anweisungen <code>21</code> und <code>20</code> .  Diese Werte werden nach dem Prinzip des Graphen zwischen LOCALS und STACK übertragen: von der Anweisung zur Berechnung des Wertes bis zum Ort seiner weiteren Verwendung. <br><br>  Wie die <code>Ident</code> / <code>Assign</code> Paare in unseren ASTs bilden die Werte, die zwischen LOCALS und STACK übergeben werden, eine Grafik zwischen den Berechnungspunkten der Werte und den Verwendungspunkten.  Warum arbeiten wir nicht direkt mit dem Diagramm? <br><br><h2>  Datenflussdiagramme </h2><br>  Datenflussdiagramme sind die nächste Abstraktionsebene nach dem Bytecode.  Wenn wir unseren Syntaxbaum um <code>Ident</code> / <code>Assign</code> Beziehungen erweitern oder verfolgen, wie der Bytecode Werte zwischen LOCALS und STACK verschiebt, können wir ein Diagramm erstellen.  Für die <code>ackermann</code> Funktion sieht es so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/217/5f7/5ad2175f73cf13fa7e47fb521a9aab1a.png"><br><br>  Im Gegensatz zum AST- oder Java-Stack-Bytecode-Bytecode verwenden Datenflussdiagramme nicht das Konzept einer „lokalen Variablen“. Stattdessen enthält das Diagramm direkte Verbindungen zwischen jedem Wert und dem Ort, an dem er verwendet wird.  Bei der Analyse von Bytecode ist es häufig erforderlich, LOCALS und STACK abstrakt zu interpretieren, um zu verstehen, wie sich die Werte bewegen.  Bei der AST-Analyse wird der Baum verfolgt und mit einer Symboltabelle gearbeitet, die <code>Assign</code> / <code>Ident</code> Assoziationen enthält.  Das Analysieren von Datenflussgraphen ist häufig eine direkte Verfolgung von Übergängen - die reine Idee, Werte zu verschieben, ohne die Hüllen eines Programms zu präsentieren. <br><br>  <code>ackermann</code> auch einfacher zu bearbeiten als linearer Bytecode: Wenn Sie einen Knoten durch einen <code>ackermann</code> Aufruf durch einen <code>ackermann</code> Aufruf ersetzen und eines der Argumente <code>ackermann2</code> wird lediglich der Diagrammknoten (grün markiert) geändert und einer der Eingabelinks zusammen mit den Transitknoten (rot markiert) gelöscht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/c2d/90d/b70c2d90d886bd7c90cdfbb3cb03b42d.png"><br><br>  Wie Sie sehen können, führt eine kleine Änderung im Programm (Ersetzen von <code>ackermann(int n, int m)</code> durch <code>ackermann2(int m)</code> ) zu einer relativ lokalisierten Änderung im Datenstromdiagramm. <br><br>  Im Allgemeinen ist das Arbeiten mit Diagrammen viel einfacher als mit linearem Bytecode oder AST: Sie sind einfach zu analysieren und zu ändern. <br><br>  Diese Beschreibung von Diagrammen enthält nicht viele Details: Zusätzlich zur tatsächlichen physischen Darstellung des Diagramms gibt es viele andere Möglichkeiten zur Modellierung des Zustands und der Flusssteuerung, die schwieriger zu handhaben sind und über den Umfang des Artikels hinausgehen.  Ich habe auch eine Reihe von Details zum Transformieren von Diagrammen weggelassen, z. B. Hinzufügen und Entfernen von Verknüpfungen, Vorwärts- und Rückwärtsübergängen, horizontalen und vertikalen Übergängen (in Breite und Tiefe) usw. Wenn Sie Algorithmen studiert haben, sollte Ihnen dies alles bekannt sein . <br><br>  Schließlich haben wir die Konvertierungsalgorithmen von linearem Bytecode zu Grafik und dann von Grafik zurück zu Bytecode weggelassen.  Dies ist an sich eine interessante Aufgabe, aber wir überlassen sie Ihnen für ein unabhängiges Studium. <br><br><h2>  Analyse </h2><br>  Nachdem wir die Idee des Programms erhalten haben, müssen wir es analysieren: Finden Sie einige Fakten heraus, mit denen Sie das Programm transformieren können, ohne sein Verhalten zu ändern.  Viele der oben diskutierten Optimierungen basieren auf der Analyse des Programms: <br><br><ul><li>  Konstante Faltung: Arbeitet das Ergebnis des Ausdrucks mit einem bekannten konstanten Wert?  Ist die Ausdrucksberechnung rein? <br></li><li>  Typumwandlung und Inlining: Ist ein Methodenaufruftyp ein Typ mit einer einzelnen Implementierung der aufgerufenen Methode? <br></li><li>  :     ? <br></li><li>   :    «»?    -     ?  ? <br></li><li>  :  ,        ? <br></li></ul><br>       ,    ,      ,      .       , ,   ,       . <br><br> , , ,  —      ,       .              . <br><br><h2>   (Inference Lattice) </h2><br>    ,       .  , «»  -    : <br><br><ul><li>   <code>Integer</code> ? <code>String</code> ? <code>Array[Float]</code> ? <code>PrintLogger</code> ? <br></li><li>  <code>CharSequence</code> ?      <code>String</code> ,     -  <code>StringBuilder</code> ? <br></li><li>   <code>Any</code> ,     ,    ? <br></li></ul><br>             : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/4b1/b4d/2584b1b4d5769ebd78d1dcd84e4f686a.png"><br><br>        :   ,    <code>"hello"</code>   <code>String</code> ,    <code>String</code>   <code>CharSequence</code> .        <code>"hello"</code> ,      (Singleton Type) — .    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/416/872/547/416872547323d84b9b682852ea1f4dcc.png"><br><br>       ,  ,      .   ,   .   ,        , , <code>String</code>  <code>StringBuilder</code> ,    ,       : <code>CharSequence</code> .   ,    <code>0</code> ,  <code>1</code> ,  <code>2</code> ,    ,   <code>Integer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/79c/cc2/76a79ccc288b609397bdc4013a33f7b5.png"><br><br>      , ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/112/0ef/4791120ef75231854b348596b49ab700.png"><br><br>   ,    ,        .  ,     . <br><br><h2>  count </h2><br>      <code>main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) logger.log(count); count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ...; }</code> </pre> <br>      <code>ackermann</code> ,    <code>count</code> , <code>multiplied</code>  <code>logger</code> .     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/383/aa5/a19/383aa5a19df21ddbbe6f13555fb4ea1d.png"><br><br>  ,  <code>count</code>   <code>0</code>  <code>block0</code> .      <code>block1</code> ,   ,    <code>count &lt; n</code> :  ,    <code>block3</code>  <code>return</code> ,    <code>block2</code> ,   <code>count</code>  <code>1</code>     <code>count</code> ,    <code>block1</code>   .      ,  <code>&lt;</code>   <code>false</code> ,     <code>block3</code>   . <br><br>   ? <br><br><ul><li>   <code>block0</code> .  ,  <code>count = 0.</code> <br></li><li>   <code>block1</code> ,   ,   <code>n</code> (  ,      <code>Integer</code> ),     ,   <code>if</code> .   <code>block2</code>  <code>block3.</code> </li><li>  <code>block3</code> ,   ,    <code>block1b</code> ,      <code>block2</code> ,   ,     <code>block1c</code> .  ,  <code>block2</code>  <code>count</code> ,    1      <code>count.</code> </li><li>  ,  <code>count</code>    <code>0</code>  <code>1</code> :        <code>count</code>  <code>Integer.</code> </li><li>  :   <code>block1</code>   <code>n</code>  <code>count</code>  <code>Integer</code> . <br></li><li>    <code>block2</code> ,  <code>count</code>   <code>Integer + 1 -&gt; Integer</code> .   ,  <code>count</code>  <code>Integer</code> ,    . <br></li></ul><br><h2>  multiplied </h2><br>      ,   <code>multiplied</code> : <br><br><ul><li>   <code>block0</code> .  ,  <code>multiplied</code>   <code>0.</code> <br></li><li>   <code>block1</code> ,     ,      .   <code>block2</code>  <code>block3</code> (  ). <br></li><li>  <code>block2</code> ,    <code>block2</code> ( <code>0</code> )  <code>count</code> (    <code>Integer</code> ).  <code>0 * Integer -&gt; 0</code> ,   <code>multiplied</code>   <code>0.</code> <br></li><li>    <code>block1</code>  <code>block2</code> . <code>multiplied</code>     <code>0</code> ,    . <br></li></ul><br>  <code>multiplied</code>   <code>0</code> ,  , : <br><br><ul><li> <code>multiplied &lt; 100</code>    <code>true.</code> <br></li><li> <code>if (multiplied &lt; 100) logger.log(count);</code>    <code>logger.log(count)</code> . <br></li><li>    ,    <code>multiplied</code> ,     ,      <code>0</code> . <br></li></ul><br>    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9f/5f2/e95/e9f5f2e95c4dc3bfc64d54834c2a19ea.png"><br><br>     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/625/fdb/fd4625fdb669e5d9e0c4d28a71e67f85.png"><br><br>       : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ logger.log(count); count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ...; }</code> </pre> <br>       ,      ,   ,  ,      . <br><br>  <code>multiplied -&gt; 0</code>      , ,   .  ,     ,      .         ,           . <br><br>     ,       .  : <br><br><ul><li>              . <br></li><li>        . <br></li><li>             . <br></li><li>        :        . <br></li></ul><br>        <code>count</code> ,   <code>multiplied</code> .    ,  <code>multiplied</code>   <code>count</code> ,  <code>count</code>    <code>multiplied</code> .        ,      . <br><br>  ,   —  :       ,      .  ,      ( )      .          . <br><br>         <code>while</code> ,    ,    <code>O(  )</code> .     (,       )    ,     ,    . <br><br>           ,    . <br><br><h2>    </h2><br>        ,        .      ,   ,                 ,    ,           . <br><br><h2>    </h2><br>       .    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> called(n, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">called</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; }</code> </pre> <br>         : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45a/a32/471/45aa32471c28271c2755e5494a590891.png"><br><br>    <code>main</code> : <br><br><ul><li>  <code>main(n)</code> <br><ul><li>  <code>called(n, 0)</code> <br><ul><li>  <code>x * y</code>  <code>x = n</code>  <code>y = 0</code> </li><li> <code>n * 0</code>  <code>0</code> </li></ul></li><li> <code>called(n, 0)</code>  <code>0</code> </li></ul></li><li> <code>main(n)</code>  <code>0</code> <br></li></ul><br>        ,    ,     .              . <br><br>  ,  <code>called(n, 0)</code>  <code>0</code> ,         : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e8/484/17d/3e848417db361dae9f39425ddeed1a13.png"><br><br>    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>     :  A  B,  C,  D,  D     C, B, D  A.    A  B  B  A,   A   A,    ,     ! <br><br><h2>    </h2><br>    ,    Java: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>   <code>n</code>    <code>int</code> ,      <code>Any</code> :     .  ,  <code>factorial</code>  <code>int</code> ( <code>Integer</code>   ).        <code>factorial</code> ,      <code>factorial</code>      <code>factorial</code> ,      !         ? <br><br><h2>   Bottom </h2><br>        <code>Bottom</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abe/520/44e/abe52044e569bfe201c2d0f6998761ec.png"><br><br>   «   ,  ,      ».  <code>Bottom</code>      <code>factorial</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50b/347/73b/50b34773b36ec9470e3bdb03efaec5eb.png"><br><br><ul><li>   <code>block0</code> . <code>n</code>   <code>Integer</code> , <code>1</code>  <code>1</code> ,   <code>n == 1</code>  ,      <code>true</code>  <code>false</code> . <br></li><li>  <code>true</code>  : <code>return</code>  <code>1</code> . <br></li><li>   <code>false</code>  <code>n - 1</code>  <code>n</code>   <code>Integer</code> . <br></li><li> <code>factorial</code> —   ,      <code>Bottom</code> . <br></li><li> <code>*</code>  <code>n: Integer</code>  <code>factorial</code> : <code>Bottom</code>   <code>Bottom</code> . <br></li><li> <code>return</code>  <code>Bottom</code> . </li><li>   <code>factorial</code>  <code>1</code>  <code>Bottom</code> ,           <code>1</code> . <br></li><li>  <code>1</code>      <code>factorial</code> ,      <code>Bottom</code> . <br></li><li> <code>Integer * 1</code>  <code>Integer</code> . <br></li><li> <code>return</code>   <code>Integer</code> . </li><li> <code>factorial</code>   <code>Integer</code>  <code>1</code> ,        <code>Integer</code> . <br></li><li> <i></i>    <code>factorial</code> ,      <code>Integer</code> .  <code>*</code>  <code>n: Integer</code>  <code>factorial: Integer</code> ,    <code>Integer</code> ,     . <br></li></ul><br>     <code>factorial</code>   <code>Integer</code> ,   ,        . <br><br>     ,        .           <code>Bottom</code> ,     ,                   . <br><br>     <code>*</code>  : <br><br><ol><li> <code>(n: Integer) * (factorial: Bottom)</code> <br> </li><li> <code>(n: Integer) * (factorial: 1)</code> <br> </li><li> <code>(n: Integer) * (factorial: Integer)</code> <br> </li></ol><br>        <code>multiplied</code>  ,        <code>O(  )</code> .            , , . <br><br><h2>     </h2><br>     —   ,     «  ».      ,        (« »),  ,        (« »).     . <br><br>        <code>main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>, total = <span class="hljs-number"><span class="hljs-number">0</span></span>, multiplied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (multiplied &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) count += <span class="hljs-number"><span class="hljs-number">1</span></span>; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; multiplied *= <span class="hljs-number"><span class="hljs-number">2</span></span>; total += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>     ,       <code>if (multiplied &gt; 100)</code>   <code>multiplied *= count</code>  <code>multiplied *= 2</code> .        . <br><br><h2>       </h2><br>   ,       : <br><br><ul><li> <code>multiplied &gt; 100</code>    <code>true</code> ,  <code>count += 1</code>     («»). <br></li><li> <code>total</code>    ,       («»). <br></li></ul><br>  ,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>   ,     . <br><br>      : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f1/2a1/af5/0f12a1af57586674b9e1a7fb1ae13c86.png"><br><br>    ,    ,    :   <code>block0</code> ,   <code>block1</code> ,    ,    <code>block1b</code> ,    ,    <code>block1c</code> ,   ,      <code>return</code>  <code>block3</code> . <br><br><h2>      </h2><br>        ,     <code>multiplied -&gt; 0</code> ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92a/1dd/f90/92a1ddf903dcc52cc9966220c56db876.png"><br><br>  Folgendes ist passiert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/1ef/09c/9061ef09c209275be5158a8b3184a5bc.png"><br><br>  ,     <code>block1b</code> ( <code>0 &gt; 100</code> )    <code>true</code> .   <code>false</code>   <code>block1c</code> <i></i>     (   <code>if</code> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/21e/8e4/58721e8e43fb326379c796593f9bd2a7.png"><br><br> ,   « » <code>total</code>  <code>&gt;</code> ,  - ,         ,    .   ,       <code>return</code> ,   <i></i>    : <code>&gt;</code> , <code>100</code> , <code>0</code>  <code>block1b</code> , <code>total</code> , <code>0</code> ,  <code>+ 1</code> ,   <code>total</code>  <code>block0</code>  <code>block2</code> .  Folgendes ist passiert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55b/508/e16/55b508e164d0c4421aa525dcab56e122.png"><br><br>      «» : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(count &lt; n){ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre><br><h2>  Fazit </h2><br>          : <br><br><ul><li>    -. <br></li><li> ,         . <br></li><li>   ,               .           . <br></li><li>   : «»      «»   , , . <br></li><li>      :   ,      . <br></li><li>         ,         . <br></li></ul><br>  ,         ,       . <br><br>        ,     .     .    ,    : <br><br><ul><li> <a href="https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X">Engineering a Compiler by Keith D Cooper &amp; Linda Torczon</a> <br></li><li> <a href="https://www.researchgate.net/profile/Cliff_Click/publication/2394127_Combining_Analyses_Combining_Optimizations/links/0a85e537233956f6dd000000.pdf">Combining Analyses, Combining Optimizations by Cliff Noel Click Jr.</a> <br></li><li> <a href="https://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204">Advanced Compiler Design and Implementation by Steven Muchnick</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477062/">https://habr.com/ru/post/de477062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477050/index.html">Black Friday 2019 für Videoüberwachung und Wolken.</a></li>
<li><a href="../de477052/index.html">Reactor, WebFlux, Kotlin Coroutines oder Asynchrony anhand eines einfachen Beispiels</a></li>
<li><a href="../de477054/index.html">Webasto kündigt modulares Fahrzeugbatteriesystem an</a></li>
<li><a href="../de477058/index.html">Enterprise Agile Russia bei der Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../de477060/index.html">DataArt wird einen offenen Vortrag von Andrei Terekhov, Leiter der Abteilung für Systemprogrammierung, Matmekh, St. Petersburg State University, halten</a></li>
<li><a href="../de477072/index.html">Kundenentwicklung oder wie man ein Produkt ohne Fehler einführt?</a></li>
<li><a href="../de477074/index.html">Ariadnes Faden: Wie man sich in JSR-133 verliebt. Yandex-Bericht</a></li>
<li><a href="../de477078/index.html">WebStorm 2019.3: schnellerer Start, verbesserte Unterstützung für Vue.js und andere Verbesserungen</a></li>
<li><a href="../de477082/index.html">US-Kongress gegen Zuckerberg: Welche Behauptungen erheben die Aufsichtsbehörden gegen eine stabile Waage von Facebook</a></li>
<li><a href="../de477084/index.html">Das Gehirn der Firma. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>