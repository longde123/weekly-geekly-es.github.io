<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬆️ 🍠 👨🏽‍🎨 Partage Pinterest: comment nous avons dimensionné notre parc MySQL ⛳️ 🗿 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Khabrovites! Félicitations à tous le jour de la programmation et partagez la traduction de l'article, qui a été spécialement préparé pour les é...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partage Pinterest: comment nous avons dimensionné notre parc MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467389/">  <i>Salut, Khabrovites!</i>  <i>Félicitations à tous le jour de la programmation et partagez la traduction de l'article, qui a été spécialement préparé pour les étudiants du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"High Load Architect"</a> .</i> <br><br><img src="https://habrastorage.org/webt/3o/s-/k6/3os-k6l2f122mbs6d1lufcif6ke.png"><br><br>  <b><i>"Sharding.</i></b>  <b><i>Ou ne pas éclater.</i></b>  <b><i>Sans essayer. "</i></b> <b><i><br></i></b>  <b><i>- Yoda</i></b> <br><br>  Aujourd'hui, nous allons plonger dans la séparation des données entre plusieurs serveurs MySQL.  Nous avons terminé le sharding début 2012, et ce système est toujours utilisé pour stocker nos données de base. <a name="habracut"></a><br><br>  Avant de discuter de la façon de partager des données, apprenons à mieux les connaître.  Installez une belle lumière, obtenez des fraises au chocolat, souvenez-vous des citations de Star Trek ... <br><br>  Pinterest est un moteur de recherche pour tout ce qui vous intéresse.  En termes de données, Pinterest est le plus grand graphique des intérêts humains dans le monde.  Il contient plus de 50 milliards de broches qui ont été enregistrées par les utilisateurs sur plus d'un milliard de cartes.  Les gens gardent des épingles pour eux-mêmes et, comme d'autres épingles, s'abonnent à d'autres épingles, tableaux et intérêts, consultent le flux d'accueil de tous les épingles, tableaux et intérêts auxquels ils sont abonnés.  Super!  Rendons-le maintenant évolutif! <br><br><h3>  Croissance douloureuse </h3><br>  En 2011, nous avons commencé à prendre de l'ampleur.  Selon certaines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">estimations</a> , nous avons progressé plus rapidement que n'importe quelle startup connue à l'époque.  Vers septembre 2011, chaque composant de notre infrastructure était surchargé.  Nous avions plusieurs technologies NoSQL à notre disposition, et toutes ont échoué de manière catastrophique.  Nous avions également de nombreux esclaves MySQL, que nous avions l'habitude de lire, ce qui provoquait de nombreuses erreurs extraordinaires, en particulier lors de la mise en cache.  Nous avons reconstruit l'ensemble de notre modèle de stockage.  Pour travailler efficacement, nous avons soigneusement abordé le développement des exigences. <br><br><h3>  Prérequis </h3><br><ul><li>  L'ensemble du système doit être très stable, facile à utiliser et évoluer de la taille d'une petite boîte à la taille de la lune à mesure que le site se développe. </li><li>  Tout le contenu généré par le pinner doit être disponible sur le site à tout moment. </li><li>  Le système doit prendre en charge la demande de N broches sur la carte dans un ordre déterministe (par exemple, dans l'ordre inverse de l'heure de création ou dans l'ordre spécifié par l'utilisateur).  Il en va de même pour les broches similaires, leurs broches, etc. </li><li> Par souci de simplicité, vous devez vous efforcer d'obtenir des mises à jour de toutes les manières possibles.  Pour obtenir la cohérence nécessaire, des jouets supplémentaires, tels qu'un journal des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions</a> distribué, seront nécessaires.  C'est amusant et (pas trop) facile! </li></ul><br><h3>  Philosophie de l'architecture et des notes </h3><br>  Comme nous voulions que ces données s'étendent sur plusieurs bases de données, nous ne pouvions pas utiliser uniquement une jointure, des clés étrangères et des index pour collecter toutes les données, bien qu'elles puissent être utilisées pour des sous-requêtes qui ne s'étendent pas sur la base de données. <br><br>  Nous devions également maintenir l'équilibrage de charge sur les données.  Nous avons décidé que le déplacement de données, élément par élément, rendrait le système inutilement complexe et provoquerait de nombreuses erreurs.  Si nous devions déplacer des données, il était préférable de déplacer le nœud virtuel entier vers un autre nœud physique. <br><br>  Pour que notre implémentation soit rapidement mise en circulation, nous avions besoin de la solution la plus simple et la plus pratique et de nœuds très stables dans notre plate-forme de données distribuées. <br>  Toutes les données ont dû être répliquées sur la machine esclave pour créer une sauvegarde, avec une haute disponibilité et un vidage sur S3 pour MapReduce.  Nous interagissons avec le maître uniquement sur la production.  En production, vous ne voudrez pas écrire ou lire en esclave.  Slave lag, et cela provoque d'étranges bugs.  Si le partage est effectué, il est inutile d'interagir avec un esclave en production. <br><br>  Enfin, nous avons besoin d'un bon moyen de générer des identificateurs uniques universels (UUID) pour tous nos objets. <br><br><h3>  Comment nous avons fait le sharding </h3><br>  Ce que nous allions créer devait répondre aux exigences, fonctionner de manière stable, en général, être réalisable et maintenable.  C'est pourquoi nous avons choisi la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">technologie</a> MySQL déjà assez mature comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">technologie</a> sous-jacente.  Nous nous méfions intentionnellement des nouvelles technologies de mise à l'échelle automatique MongoDB, Cassandra et Membase, car elles étaient suffisamment éloignées de la maturité (et dans notre cas, elles se sont cassées de manière impressionnante!). <br><blockquote>  De plus: je recommande toujours les startups pour éviter de nouvelles choses bizarres - essayez simplement d'utiliser MySQL.  Faites-moi confiance.  Je peux le prouver avec des cicatrices. </blockquote>  MySQL - la technologie est éprouvée, stable et simple - cela fonctionne.  Non seulement nous l'utilisons, mais il est populaire dans d'autres entreprises avec des balances encore plus impressionnantes.  MySQL répond pleinement à notre besoin de rationaliser les requêtes de données, de sélectionner des plages de données spécifiques et des transactions au niveau des lignes.  En fait, dans son arsenal, il y a beaucoup plus de possibilités, mais nous n'en avons pas tous besoin.  Mais MySQL est une solution «en boîte», donc les données ont dû être partagées.  Voici notre solution: <br>  Nous avons commencé avec huit serveurs EC2, une instance de MySQL sur chacun: <br><br><img src="https://habrastorage.org/webt/e0/d0/o0/e0d0o0fijurp6mabuvbwecacnfi.png"><br><br>  Chaque serveur maître-maître MySQL est répliqué sur l'hôte de sauvegarde en cas de défaillance principale.  Nos serveurs de production lisent ou écrivent uniquement au maître.  Je vous recommande de faire de même.  Cela simplifie considérablement et évite les erreurs avec des retards de réplication. <br><br>  Chaque entité MySQL possède de nombreuses bases de données: <br><br><img src="https://habrastorage.org/webt/zf/vl/sx/zfvlsxbhhh6uict7kf9ly6f2y9m.png"><br><br>  Notez que chaque base de données porte un nom unique: db00000, db00001 à dbNNNNN.  Chaque base de données est un fragment de nos données.  Nous avons pris une décision architecturale, sur la base de laquelle seule une partie des données tombe dans le fragment, et cela ne va jamais au-delà de ce fragment.  Cependant, vous pouvez obtenir plus de capacité en déplaçant des fragments vers d'autres machines (nous en parlerons plus tard). <br><br>  Nous travaillons avec une table de configuration qui indique quelles machines ont des fragments: <br><br><pre><code class="bash hljs">[{“range”: (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”}, {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”}, ... {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]</code> </pre> <br>  Cette configuration ne change que lorsque nous devons déplacer des fragments ou remplacer l'hôte.  Si le <code>master</code> meurt, nous pouvons utiliser l' <code>slave</code> existant, puis en prendre un nouveau.  La configuration se trouve dans <a href="">ZooKeeper</a> et, lorsqu'elle est mise à jour, est envoyée aux services qui desservent le fragment MySQL. <br><br>  Chaque fragment a le même ensemble de tables: <code>pins</code> , <code>boards</code> , <code>users_has_pins</code> , <code>users_likes_pins</code> , <code>pin_liked_by_user</code> , etc.  J'en parlerai un peu plus tard. <br><br>  Comment distribuons-nous les données pour ces fragments? <br><br>  Nous créons un ID 64 bits qui contient l'ID du fragment, le type de données qu'il contient et l'endroit où ces données se trouvent dans la table (ID local).  L'ID de fragment se compose de 16 bits, l'ID de type est de 10 bits et l'ID local de 36 bits.  Les mathématiciens avancés remarqueront qu'il n'y a que 62 bits.  Mon expérience passée en tant que compilateur et développeur de circuits imprimés m'a appris que les bits de sauvegarde valent leur pesant d'or.  Donc, nous avons deux de ces bits (mis à zéro). <br><br><pre> <code class="bash hljs">ID = (shard ID &lt;&lt; 46) | (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ID &lt;&lt; 36) | (<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> ID&lt;&lt;0)</code> </pre> <br>  Prenons cette épingle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.pinterest.com/pin/241294492511762325/</a> , analysons son ID 241294492511762325: <br><br><pre> <code class="bash hljs">Shard ID = (241294492511762325 &gt;&gt; 46) &amp; 0xFFFF = 3429 Type ID = (241294492511762325 &gt;&gt; 36) &amp; 0x3FF = 1 Local ID = (241294492511762325 &gt;&gt; 0) &amp; 0xFFFFFFFFF = 7075733</code> </pre> <br>  Ainsi, l'objet épingle vit dans un éclat de 3429.  Son type est «1» (c'est-à-dire «Pin») et il est en ligne 7075733 dans le tableau des broches.  Par exemple, imaginons que ce fragment se trouve dans MySQL012A.  Nous pouvons y accéder comme suit: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”MySQL012A”) conn.execute(“SELECT data FROM db03429.pins <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> local_id=7075733”)</code> </pre> <br><br>  Il existe deux types de données: les objets et les mappages.  Les objets contiennent des parties, telles que des données de broche. <br><br><h4>  Tables d'objets </h4><br>  Les tables d'objets telles que les broches, les utilisateurs, les tableaux et les commentaires ont un ID (ID local, avec une clé primaire augmentant automatiquement) et un blob qui contient JSON avec toutes les données d'objet. <br><br><pre> <code class="bash hljs">CREATE TABLE pins ( local_id INT PRIMARY KEY AUTO_INCREMENT, data TEXT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ENGINE=InnoDB;</code> </pre> <br>  Par exemple, les objets d'épingle ressemblent à ceci: <br><br><pre> <code class="bash hljs">{“details”: “New Star Wars character”, “link”: “http://webpage.com/asdf”, “user_id”: 241294629943640797, “board_id”: 241294561224164665, …}</code> </pre> <br>  Pour créer une nouvelle épingle, nous collectons toutes les données et créons un blob JSON.  Ensuite, nous sélectionnons l'ID de fragment (nous préférons choisir le même ID de fragment que la carte sur laquelle il est placé, mais ce n'est pas nécessaire).  Pour le type de broche 1. Nous nous connectons à cette base de données et insérons JSON dans la table des broches.  MySQL renverra un ID local automatiquement augmenté.  Nous avons maintenant un fragment, un type et un nouvel identifiant local, nous pouvons donc compiler un identifiant 64 bits complet! <br><br>  Pour éditer la broche, nous lisons-modifions-écrivons JSON en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transaction MySQL</a> : <br><br><pre> <code class="bash hljs">&gt; BEGIN &gt; SELECT blob FROM db03429.pins WHERE local_id=7075733 FOR UPDATE [Modify the json blob] &gt; UPDATE db03429.pins SET blob=<span class="hljs-string"><span class="hljs-string">'&lt;modified blob&gt;'</span></span> WHERE local_id=7075733 &gt; COMMIT</code> </pre> <br>  Pour supprimer une épingle, vous pouvez supprimer sa ligne dans MySQL.  Cependant, il est préférable d'ajouter le champ <i>«actif»</i> dans JSON et de le définir sur <i>«faux»</i> , ainsi que de filtrer les résultats côté client. <br><br><h4>  Tables de correspondance </h4><br>  La table de mappage relie un objet à un autre, par exemple une carte avec des broches dessus.  La table MySQL pour les mappages contient trois colonnes: 64 bits pour l'ID "de", 64 bits pour l'ID "où" et l'ID de séquence.  Dans ce triple (d'où, où, séquence) il y a des clés d'index, et elles sont sur le fragment de l'identifiant "de". <br><br><pre> <code class="bash hljs">CREATE TABLE board_has_pins ( board_id INT, pin_id INT, sequence INT, INDEX(board_id, pin_id, sequence) ) ENGINE=InnoDB;</code> </pre> <br>  Les tables de mappage sont unidirectionnelles, par exemple, comme la table <code>board_has_pins</code> .  Si vous avez besoin de la direction opposée, vous aurez besoin d'une table <code>pin_owned_by_board</code> distincte.  L'ID de séquence définit la séquence (nos ID ne peuvent pas être comparés entre les fragments, car les nouveaux ID locaux sont différents).  Habituellement, nous insérons de nouvelles broches sur une nouvelle carte avec un ID de séquence égal au temps dans unix (horodatage unix).  N'importe quel nombre peut être dans la séquence, mais le temps unix est un bon moyen de stocker séquentiellement de nouveaux matériaux, car cet indicateur augmente de façon monotone.  Vous pouvez consulter les données de la table de mappage: <br><br><pre> <code class="bash hljs">SELECT pin_id FROM board_has_pins WHERE board_id=241294561224164665 ORDER BY sequence LIMIT 50 OFFSET 150</code> </pre> <br>  Cela vous donnera plus de 50 pin_id, que vous pouvez ensuite utiliser pour rechercher des objets pin. <br>  Ce que nous venons de faire est une jointure de couche d'application (board_id -&gt; pin_id -&gt; pin objects).  L'une des propriétés étonnantes des connexions au niveau de l'application est que vous pouvez mettre l'image en cache séparément de l'objet.  Nous stockons pin_id dans le cache de l'objet pin dans le cluster memcache, mais nous enregistrons board_id dans pin_id dans le cluster redis.  Cela nous permet de choisir la bonne technologie qui convient le mieux à l'objet mis en cache. <br><br><h3>  Augmenter la capacité </h3><br>  Il existe trois façons principales d'augmenter la capacité de notre système.  Le moyen le plus simple de mettre à jour la machine (pour augmenter l'espace, mettre des disques durs plus rapides, plus de RAM). <br>  La prochaine façon d'augmenter la capacité est d'ouvrir de nouvelles gammes.  Initialement, nous avons créé un total de 4096 fragments, malgré le fait que l'ID de fragment était composé de 16 bits (un total de 64 000 fragments).  De nouveaux objets ne peuvent être créés que dans ces premiers fragments 4k.  À un moment donné, nous avons décidé de créer de nouveaux serveurs MySQL avec des fragments de 4096 à 8191 et avons commencé à les remplir. <br><br>  La dernière façon d'augmenter notre capacité est de déplacer des fragments vers de nouvelles machines.  Si nous voulons augmenter la capacité de MySQL001A (avec des fragments de 0 à 511), nous créons une nouvelle paire maître-maître avec les noms maximum possibles suivants (disons MySQL009A et B) et commençons la réplication à partir de MySQL001A. <br><br><img src="https://habrastorage.org/webt/d2/uf/gd/d2ufgd1tttsa6tmxvpywfzgqugs.png"><br><br>  Dès que la réplication est terminée, nous changeons notre configuration de sorte que dans MySQL001A il n'y a que des fragments de 0 à 255, et dans MySQL009A de 256 à 511. Maintenant, chaque serveur ne doit traiter que la moitié des fragments qu'il a traités auparavant. <br><br><img src="https://habrastorage.org/webt/4f/cp/do/4fcpdo2g16molbdkkfbf8xvujbi.png"><br><br><h3>  Quelques fonctionnalités intéressantes </h3><br>  Ceux qui avaient déjà des systèmes pour générer de nouveaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UUID</a> comprendront que dans ce système, nous les obtenons gratuitement!  Lorsque vous créez un nouvel objet et l'insérez dans la table des objets, il renvoie un nouvel identifiant local.  Cet ID local, combiné avec l'ID de fragment et l'ID de type, vous donne un UUID. <br><br>  Ceux d'entre vous qui ont effectué des ALTER pour ajouter plus de colonnes aux tables MySQL savent qu'ils peuvent fonctionner extrêmement lentement et devenir un gros problème.  Notre approche ne nécessite aucune modification de niveau MySQL.  Sur Pinterest, nous n'avons probablement fait qu'un seul ALTER au cours des trois dernières années.  Pour ajouter de nouveaux champs aux objets, dites simplement à vos services qu'il existe plusieurs nouveaux champs dans le schéma JSON.  Vous pouvez modifier la valeur par défaut afin que lors de la désérialisation de JSON d'un objet sans nouveau champ, vous obteniez la valeur par défaut.  Si vous avez besoin d'une table de mappage, créez une nouvelle table de mappage et commencez à la remplir quand vous le souhaitez.  Et une fois terminé, vous pouvez envoyer! <br><br><h3>  Éclat de mod </h3><br>  C'est presque comme une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">équipe de mods</a> , mais complètement différent. <br><br>  Certains objets doivent être trouvés sans ID.  Par exemple, si un utilisateur se connecte avec un compte Facebook, nous devons mapper l'ID Facebook à l'ID Pinterest.  Pour nous, les identifiants Facebook ne sont que des bits, nous les stockons donc dans un système de partition séparé appelé mod shard. <br><br>  D'autres exemples incluent les adresses IP, le nom d'utilisateur et l'adresse e-mail. <br>  Mod Shard est très similaire au système de partitionnement décrit dans la section précédente, à la seule différence que vous pouvez rechercher des données à l'aide de données d'entrée arbitraires.  Cette entrée est hachée et modifiée en fonction du nombre total de fragments dans le système.  En conséquence, un fragment sera obtenu sur lequel les données seront ou sont déjà situées.  Par exemple: <br><br><pre> <code class="bash hljs">shard = md5(“1.2.3.4<span class="hljs-string"><span class="hljs-string">") % 4096</span></span></code> </pre> <br>  Dans ce cas, le fragment sera égal à 1524. Nous traitons le fichier de configuration correspondant à l'ID de fragment: <br><br><pre> <code class="bash hljs">[{“range”: (0, 511), “master”: “msdb001a”, “slave”: “msdb001b”}, {“range”: (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”}, {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”}, …]</code> </pre> <br>  Ainsi, afin de trouver des données sur l'adresse IP 1.2.3.4, nous devrons procéder comme suit: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”msdb003a”) conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip=<span class="hljs-string"><span class="hljs-string">'1.2.3.4'</span></span>”)</code> </pre> <br>  Vous perdez de bonnes propriétés de l'ID de fragment, telles que la localité spatiale.  Vous devrez commencer par tous les fragments créés au tout début et créer la clé vous-même (elle ne sera pas générée automatiquement).  Il est toujours préférable de représenter les objets sur votre système avec des ID immuables.  Ainsi, vous n'avez pas besoin de mettre à jour de nombreux liens lorsque, par exemple, l'utilisateur change son "nom d'utilisateur". <br><br><h3>  Dernières pensées </h3><br>  Ce système fonctionne sur Pinterest depuis 3,5 ans et devrait y rester pour toujours.  Son implémentation était relativement simple, mais sa mise en service et le déplacement de toutes les données de vieilles machines étaient difficiles.  Si vous rencontrez un problème lorsque vous venez de créer un nouveau fragment, envisagez de créer un cluster de machines de traitement de données en arrière-plan (astuce: utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyres</a> ) pour déplacer vos données avec des scripts d'anciennes bases de données vers votre nouveau fragment.  Je garantis qu'une partie des données sera perdue, peu importe vos efforts (ce sont tous des gremlins, je le jure), alors répétez le transfert de données encore et encore jusqu'à ce que la quantité de nouvelles informations dans le fragment devienne très petite ou pas du tout. <br><br>  Tous les efforts ont été faits pour ce système.  Mais il n'apporte en aucune façon atomicité, isolement ou cohérence.  Ouah!  Ça sonne mal!  Mais ne vous inquiétez pas.  Vous vous sentirez sûrement excellent sans eux.  Vous pouvez toujours construire ces couches avec d'autres processus / systèmes, si nécessaire, mais par défaut et sans frais, vous obtenez déjà beaucoup: la capacité de travail.  Fiabilité obtenue grâce à la simplicité et fonctionne même rapidement! <br><br>  Mais qu'en est-il de la tolérance aux pannes?  Nous avons créé un service de maintenance des fragments MySQL, enregistré la table de configuration des fragments dans ZooKeeper.  Lorsque le serveur maître tombe en panne, nous élevons la machine esclave puis relevons la machine qui la remplacera (toujours à jour).  À ce jour, nous n'utilisons pas de traitement automatique des pannes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467389/">https://habr.com/ru/post/fr467389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467377/index.html">Trois d'affilée: les 10 meilleurs rapports de Mobius 2019 Piter</a></li>
<li><a href="../fr467381/index.html">LED à plusieurs étages, lumières intelligentes et ampoules pour 18 roubles</a></li>
<li><a href="../fr467383/index.html">«Le manager doit continuer à coder»: entretien avec Stephen Chin</a></li>
<li><a href="../fr467385/index.html">Une sélection de questions techniques psychologiques et atypiques issues d'entretiens avec des développeurs Java</a></li>
<li><a href="../fr467387/index.html">Solutions pour travailler avec le feedback et l'expérience client: des petits services aux plateformes lourdes</a></li>
<li><a href="../fr467391/index.html">Yandex présente RPKI</a></li>
<li><a href="../fr467393/index.html">NX Bootcamp démarre en octobre</a></li>
<li><a href="../fr467395/index.html">Habr Weekly # 18 / Nouveaux gadgets Apple, un smartphone entièrement modulaire, le village des programmeurs en Biélorussie, le phénomène XY</a></li>
<li><a href="../fr467399/index.html">Vous ne pouvez pas interdire d'apporter: comment mettre en œuvre le concept BYOD et ne pas nuire à la sécurité des informations</a></li>
<li><a href="../fr467401/index.html">Comparaison de Tesla Model S et Porsche Taycan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>