<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 👕 ⛏️ 像Horizo​​n Zero Dawn一样实现物理上正确的体积云 ✍️ ☎️ 🤟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="以前，游戏中的云是使用普通的2D子图形绘制的，该子图形始终沿相机的方向旋转，但是近年来，新的视频卡模型使您可以绘制物理上正确的云，而不会造成明显的性能损失。 据认为，游戏中大量的云将工作室Guerrilla Games和游戏Horizo​​n Zero Dawn一起带来了。 当然，这种云以前就可以渲...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>像Horizo​​n Zero Dawn一样实现物理上正确的体积云</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/"> 以前，游戏中的云是使用普通的2D子图形绘制的，该子图形始终沿相机的方向旋转，但是近年来，新的视频卡模型使您可以绘制物理上正确的云，而不会造成明显的性能损失。 据认为，游戏中大量的云将工作室Guerrilla Games和游戏Horizo​​n Zero Dawn一起带来了。 当然，这种云以前就可以渲染，但是工作室为源资源和所使用的算法形成了类似于行业标准的东西，现在任何体积云的实现都以某种方式符合该标准。 <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br> 渲染云的整个过程非常好地分为多个阶段，需要注意的是，即使对其中之一进行错误的实现也会导致这样的后果，即不清楚错误在哪里以及如何解决它，因此建议每次对结果进行控制结论。 <br><br><h2> 色调映射，sRGB </h2><br> 在开始照明工作之前，重要的是要做两件事： <br><br><ol><li> 在屏幕上显示最终图像之前，请至少应用最简单的色调映射： <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br> 这是必需的，因为计算出的颜色值将远大于1。 <br></li><li> 确保要绘制并显示在屏幕上的最终帧缓冲区为sRGB格式。 如果激活sRGB模式存在问题，则可以在着色器中手动完成转换： <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br> 该公式适用于大多数情况，但并非100％（取决于监视器）。 务必始终在最后完成sRGB转换。 </li></ol><br><h2> 照明模式 </h2><br> 考虑一个充满不同密度的部分透明物质的空间。 当光线穿过这种物质时，它会受到四种影响：吸收，散射，放大散射和自辐射。 后者发生在物质的化学过程中，在此不受影响。 <br><br> 假设有一束光线从A点穿过物质到达B点： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>吸收性</b> <br><br> 穿过物质的光会被该物质吸收。 未吸收的光份额可以通过以下公式得出： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  -吸收后残留的光 <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  。 <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  -在AB段上相隔一段距离 <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg"> 来自A。 <br><br>  <b>散布</b> <br><br> 一部分光在物质粒子的影响下改变其方向。 不变方向的光的比例可以通过以下公式找到： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  -在一点散射后没有改变方向的光的比例 <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  。 <br><br> 吸收和分散必须结合起来： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br> 功能介绍 <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg"> 称为衰减或消光。 功能 <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  -传递函数。 它显示了从点A到点B剩余的光量。 <br><br> 至于 <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  ： <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  ，其中C是某个常数，对于RGB中的每个通道，其值可能不同， <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg"> 是该点的介质密度 <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  。 <br><br> 现在，让任务复杂化。 光线从点A移到点B，并在移动过程中熄灭。 在点X，一部分光沿不同方向散射，其中一个方向对应于观察者在点O。接下来，一部分散射光从点X移到点O，然后再次衰减。 我们感兴趣的AXO光之路。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br> 从A到X的光损失我们知道： <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  ，就像我们知道从X到O的光损失-这 <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  。 但是，朝观察者方向散射的那部分光呢？ <br><br>  <b>放大色散</b> <br><br> 如果在普通散射的情况下光强度降低，那么在放大散射的情况下，光强度由于在相邻区域中发生的光散射而增加。 可以通过以下公式找到来自邻近区域的总光量： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg"> 表示将积分覆盖球体， <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  -相位功能 <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  -来自方向的光 <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  。 <br><br> 从各个方向计算光是非常困难的，但是，我们知道光的原始部分是由我们的原始AB光束承载的。 该公式可以大大简化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  -光束和观察者光束之间的角度（即AXO角）， <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  -光强度的初始值。 总结以上所有内容，我们得出以下公式： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  -入光 <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  -到达观察者的光。 <br><br> 我们使任务复杂化了一点。 假设光是由定向光发出的，即 太阳： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br> 一切都与前面的情况相同，但是多次。 来自点A1的光在点X1处朝向观察者O散射，来自点A2的光在点X2处朝向观察者O点散射，等等。 我们看到到达观察者的光等于总和： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br> 或更精确的积分表达式： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br> 请务必在此处了解 <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  ，即 该段被分为无数个长度为零的段。 <br><br><h2> 天空 </h2><br> 稍微简化一下，穿过​​大气层的阳光只受到散射，即 <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br> 甚至不是一种散射，而是两种：瑞利散射和Mi散射。 第一种是由空气分子引起的，第二种是由水的气溶胶引起的。 <br><br> 从点A到点B的光线穿过的空气（或气溶胶）的总密度： <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  -缩放高度，h-当前高度。 <br><br> 一个简单的整体解决方案是： <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br> 其中dh是获取高度样本的步长。 <br><br> 现在看一下该图，并使用“照明模型”上一部分中得出的公式： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br> 观察者从O到O'。 我们要收集到达点X1，X2，...，Xn的所有光，这些光在其中散射，然后到达观察者： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg"> 太阳发出的光的强度， <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  -点的高度 <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ; 在天空的情况下，常数C起作用 <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg"> 表示为 <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  。 <br><br> 积分的解可以如下： <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br> 该公式对于瑞利散射和米氏散射均有效。 结果，每个散射的光值简单地相加： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>瑞利分散</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  （包含每个RGB通道的值） <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br> 结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>弥散</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  （所有RGB通道的值都相同） <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br> 结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br> 每段样本数 <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg"> 在细分市场上 <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg"> 您可以参加32岁或以上。 地球半径为6371000 m，大气为100000 m。 <br><br> 如何处理所有这些： <br><br><ol><li> 在屏幕的每个像素中，我们计算观察者V的方向 </li><li> 我们采用观察者O的位置等于{0，6371000，0} </li><li> 我们发现 <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg"> 射线从点O开始与V的方向相交的结果，球体的中心在点{0,0,0}，半径为6471000 </li><li> 线段 <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg"> 分成相等长度的32个部分 </li><li> 对于每个部分，我们计算瑞利散射和米氏散射，并添加所有内容。 而且，要计算 <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg"> 我们还需要分割细分 <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg"> 每种情况下32个相等的地块。 <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg"> 可以通过变量读取，该变量的值在循环的每个步骤中都会增加。 </li></ol><br> 最终结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2> 云模型 </h2><br> 我们将需要3D噪声中的几种类型。 第一个是Perlin潜伏的分形布朗运动（fBm）噪声： <br><br>  2D切片的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br> 第二个是Voronoi掩盖的fBm噪声。 <br><br>  2D切片的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br> 要获得Vorley的掩盖fBm噪声，您需要反转Voronoj的掩盖fBm噪声。 但是，我根据自己的判断略微更改了值的范围： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br> 结果立即类似于云结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br> 对于云，您需要获得两个特殊的纹理。 第一个大小为128x128x128，负责低频噪声，第二个大小为32x32x32，负责高频噪声。 每个纹理仅使用一个R8格式的通道。 在一些示例中，将R8G8B8A8的4个通道用于第一个纹理，将R8G8B8的三个通道用于第二个纹理，然后在着色器中混合这些通道。 我不明白这一点，因为可以提前进行混合，从而在缓存一致性方面获得更大的成功。 <br><br> 为了进行混合以及在某些地方，将使用remap（）函数，该函数将值从一个范围缩放到另一个范围： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br> 让我们开始准备低频噪声的纹理： <br>  R通道-佩林的fBm噪声 <br>  G通道-平铺的fBm Vorley噪声 <br>  B通道-fBm Worley噪声较小，规模较小 <br>  A通道-规模更小的Varley可调节的fBm噪声 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br> 混合是通过以下方式完成的： <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  2D切片的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br> 现在准备带有高频噪声的纹理： <br>  R通道-平铺的fBm Vorley噪声 <br>  G通道-较小比例的fBm Vorley噪声 <br>  B通道-规模更小的Varley taylivaya fBm噪声 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  2D切片的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br> 我们还需要一个2D纹理-天气图，该图将根据空间坐标确定云的存在，密度和形状。 由艺术家绘画以微调云层。 在我借出的版本中，天气图颜色通道的解释可能有所不同，如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  R通道-低空云层覆盖 <br>  G通道-高空云层 <br>  B通道-最大云层高度 <br>  A通道-云密度 <br><br> 现在我们准备创建一个函数，该函数将根据3D空间的坐标返回云的密度。 <br><br> 在入口处，坐标为km的空间点 <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br> 立即将偏移量添加到风中 <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br> 获取天气图值 <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> 我们得到高度的百分比（从0到1） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br> 在下面添加一小部分云： <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> 根据天气地图的B通道，我们将密度随着高度增加而线性减小到0： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> 合并结果： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br> 再次在下面添加云的舍入： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br> 还要在顶部添加云的舍入： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> 我们将结果结合起来，在这里我们添加了气象图上的密度影响和通过gui设置的密度影响： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br> 结合来自纹理的低频和高频噪声： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br> 在我阅读的所有文档中，合并以不同的方式进行，但是我喜欢此选项。 <br><br> 我们确定覆盖范围（被云占据的天空的百分比），这是通过gui设置的，还使用了天气图的R通道和G通道： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br> 计算最终密度： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br> 整个功能： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br> 该功能究竟应该是什么是一个悬而未决的问题，因为忽略设置参数时云遵循的定律，您将获得非常不寻常的美观结果。 这完全取决于应用程序。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2> 整合性 </h2><br> 地球大气分为内部和外部两层，可以在这两层之间放置云。 这些层可以用球体表示，也可以用平面表示。 我定居在领域。 对于第一层，我取球面半径为6415 km，对于第二层，我取球半径为6435 km。 地球半径四舍五入为6400公里。 一些参数将取决于大气“阴天”部分（20 km）的条件厚度。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br> 与天空不同，云是不透明的，集成不仅需要获取颜色，还需要获取alpha通道的值。 首先，您需要一个函数，该函数返回云的总密度，来自太阳的光线将通过该密度。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br> 没有人引起注意，但是实践表明，根本不需要考虑光束的整个路径，只需要最大的间隙即可。 我们假设截断段以上的云根本不存在。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br> 此外，我们在不影响性能的情况下可以完成的密度样本数量非常有限。 游击队游戏做了6。此外，在其中一个演示中，开发人员说，它们将这些样本分散在圆锥体中，最后一个样本与其他样本的距离特别远，可以覆盖尽可能多的空间。 所产生的误差和噪声仍将在相邻样本的背景下被消除，相反，这将提高准确性。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br> 最后，我确定了位于同一条线上的4个样本，但后者的步数增加了6倍。 步长为20 km * 0.01，即200 m。 <br><br> 该功能非常简单： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br> 现在，您可以继续进行更困难的部分。 我们确定地球表面的观察者在点{0，6400,0}处，并找到观察光束与半径为6415 km且中心为{0,0,0}的球面的交点-我们获得了起点S。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br> 下面是该函数的基本版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br> 步长定义为20 km / 64。 在观察者光束严格垂直的情况下，我们将制作64个样本。 但是，当此方向更水平时，样本将稍大，因此循环中没有64个步长，但有128个有余量。 <br><br> 首先，我们假设最终的颜色是黑色，透明度是统一的。 在每一步中，我们将增加颜色值并降低透明度值。 如果透明度接近0，则可以预先退出循环： <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; … <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); … return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties。衰减-除了C外，什么也没有 <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg"> 和ufmProperties。衰减2是C在 <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  。  ufmProperties.sunIntensity-太阳的辐射强度。  sunColor-太阳的颜色。 <br><br> 结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br> 立即发现缺陷-严重的阴影。 但是现在我们将纠正太阳附近缺少放大照明的问题。 发生这种情况是因为我们没有添加相位函数。 为了计算穿过云层的光的散射，我们使用了Hengy-Greenstein函数的相位，该函数在1941年打开，用于空间气体簇中的类似计算： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br> 这里应该做题题。 根据规范照明模型，相位函数应为1。 但是，实际上，获得的结果并不适合任何人，每个人都使用两个相位函数，甚至以特殊方式组合其值。 我还专注于两个阶段的函数，但我只是将它们的值相加。 第一阶段功能的g接近1，可让您在太阳附近进行明亮的照明。 第二阶段函数的g接近0.5，可让您逐渐降低整个天球的照明度。 <br><br> 更新的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy，ufmProperties.eccentrisy2是g值 <br><br> 结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br> 现在，您可以使用太多阴影开始战斗。 之所以存在，是因为我们没有考虑现实生活中来自周围云层和天空的光线。 <br><br> 我这样解决了这个问题： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br> 其中environmentColor是沿观察光束方向的天空颜色，ufmProperties.ambient是调整参数。 <br><br> 结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br> 它仍然是解决最后一个问题。 在现实生活中，视角越水平，我们看到的雾或霾就越多，使我们无法看到非常遥远的物体。 这也需要反映在代码中。 我采用了通常的凝视角和指数函数的余弦值。 基于此，计算出一定的混合系数，该系数允许在所得颜色和背景颜色之间进行线性插值。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog-用于手动配置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br> 摘要功能： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br> 演示视频： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 优化和可能的改进 </h2><br> 在实现基本的渲染算法之后，下一个问题是它的工作速度太慢。 我的版本在radeon rx 480上产生了25 fps的全高清图像。游击游戏自己提出了以下两种解决问题的方法。 <br><br>  <b>我们画出真正可见的东西</b> <br><br> 屏幕分为大小为16x16像素的图块。 首先，绘制通常的3D环境。 事实证明，大部分天空都被群山或大物体覆盖。 因此，您仅需要在云没有被任何东西阻挡的那些图块中执行计算。 <br><br>  <b>重投影</b> <br><br> 事实证明，当相机静止不动时，通常无法更新云。 但是，如果摄像机已经移动，这并不意味着我们需要更新整个屏幕。 一切都已绘制完毕，您只需要根据新坐标重建图像即可。 通过投影和查看当前帧和先前帧的矩阵在新坐标上找到旧坐标称为投影。 因此，在摄像机移动的情况下，我们只需根据新坐标传递颜色即可。 如果这些坐标表示屏幕外，则必须如实地重绘云。 <br><br>  <b>部分更新</b> <br><br> 我不喜欢重新投影的想法，因为在相机急转弯时，可能会发现必须在屏幕的三分之一处渲染云，这可能会导致延迟。 我不知道游击队游戏是如何处理的，但是至少在“地平线零黎明”中，当控制操纵杆时，摄像机可以平稳移动，并且急剧跳动不会有问题。 因此，作为实验，我想出了自己的方法。 云是在三次面的5个面上绘制的，因为 底部对我们不感兴趣。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三次方图的侧面的降低的分辨率等于屏幕高度的1/3。立方贴图的每个面都分为8x8的图块。每个面上的每一帧仅使用每个图块中的64个像素之一进行更新。这会在突然变化时产生明显的伪像，但是因为云是很静态的，那么这种技巧是看不见的。结果，radeon RX 480的火山全高清输出为500 fps，opengl为330 fps。 Radeon HD 5700系列在opengl下可产生全高清的109 fps（vulkan不支持）。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Mip级别</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当访问带有噪点的纹理时，只能在最初的样本中从零Mip级别获取数据，然后我们制作的样本越远，Mip级别就可以越大。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高云</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了模拟整合期间游击游戏中卷云高度和卷积云的存在，最新的样本不是由我所谈到的3D纹理生成的，而是由特殊的2D纹理生成的。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卷曲噪声卷曲噪声中的其他</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个纹理用于​​创建吹云的效果。</font><font style="vertical-align: inherit;">需要这些纹理来移动原始坐标。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神光</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种在戏剧中捕捉的光线是在后处理中实现的。</font><font style="vertical-align: inherit;">首先，在太阳周围绘制明亮的照明，在该照明下不会被云遮挡。</font><font style="vertical-align: inherit;">然后，该背光必须径向偏离太阳。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，您需要应用径向平滑。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，还有更多的改进和细微之处，但是我没有全部检查，因此我无法自信地说出来。但是，您可以自己熟悉它们。我认为最强的是Frostbite引擎的云文档。</font></font><br><br><h2> 有用的链接 </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459948/">https://habr.com/ru/post/zh-CN459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459924/index.html">完整的React测试周期。 Auto.ru报告</a></li>
<li><a href="../zh-CN459928/index.html">学生的移动应用开发之路</a></li>
<li><a href="../zh-CN459930/index.html">Python导入自动化</a></li>
<li><a href="../zh-CN459934/index.html">＃306移动开发人员的有趣材料摘要（7月8日至14日）</a></li>
<li><a href="../zh-CN459936/index.html">使用Visual Studio的9种技巧</a></li>
<li><a href="../zh-CN459952/index.html">关于备份和存储的一点经验</a></li>
<li><a href="../zh-CN459954/index.html">为什么最大的IT公司之一加入CNCF-开发云基础架构的基金</a></li>
<li><a href="../zh-CN459956/index.html">由于不及时去看牙医而导致牙齿完全没有植入</a></li>
<li><a href="../zh-CN459958/index.html">从Hydra会议解析任务-负载平衡和内存中存储</a></li>
<li><a href="../zh-CN459960/index.html">从构思到发布。 详细的市场前端经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>