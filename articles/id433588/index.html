<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìõ üèÜ ‚ûø Kinerja luar biasa dari algoritma C ++ 17 paralel. Mitos atau Realitas? üëéüèº üôÉ üîÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat malam 

 Dari kursus kami "Pengembang C ++" kami menawarkan kepada Anda sebuah studi kecil dan menarik tentang algoritma paralel. 

 Ayo pergi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kinerja luar biasa dari algoritma C ++ 17 paralel. Mitos atau Realitas?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433588/">  Selamat malam <br><br>  Dari kursus kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang C ++" kami</a> menawarkan kepada Anda sebuah studi kecil dan menarik tentang algoritma paralel. <br><br>  Ayo pergi. <br><br>  Dengan munculnya algoritma paralel di C ++ 17, Anda dapat dengan mudah memperbarui kode "komputasi" dan mendapatkan manfaat dari eksekusi paralel.  Pada artikel ini, saya ingin mempertimbangkan algoritma STL, yang secara alami mengungkapkan ide komputasi independen.  Bisakah kita mengharapkan akselerasi 10x dengan prosesor 10-inti?  Atau mungkin lebih?  Atau kurang?  Mari kita bicarakan. <br><br>  <b>Pengantar Algoritma Paralel</b> <br><br><img src="https://habrastorage.org/webt/9g/6q/pm/9g6qpm5cnalmrub2fcrgwsuxw0y.png"><a name="habracut"></a><br><br>  C ++ 17 menawarkan pengaturan kebijakan eksekusi untuk sebagian besar algoritma: <br><br><ul><li> sequenced_policy - jenis kebijakan eksekusi, digunakan sebagai tipe unik untuk menghilangkan kelebihan algoritma paralel dan persyaratan bahwa paralelisasi eksekusi algoritma paralel tidak mungkin: objek global terkait adalah <code>std::execution::seq</code> ; </li><li>  parallel_policy - jenis kebijakan eksekusi yang digunakan sebagai tipe unik untuk menghilangkan kelebihan algoritma paralel dan menunjukkan bahwa paralelisasi eksekusi algoritma paralel dimungkinkan: objek global yang sesuai adalah <code>std::execution::par</code> ; </li><li>  parallel_un berikutnyaenced_policy - jenis kebijakan eksekusi yang digunakan sebagai tipe unik untuk menghilangkan kelebihan algoritma paralel dan untuk mengindikasikan bahwa paralelisasi dan vektorisasi eksekusi algoritma paralel dimungkinkan: objek global yang sesuai adalah <code>std::execution::par_unseq</code> ; </li></ul><br>  Secara singkat: <br><br><ul><li>  gunakan <code>std::execution::seq</code> untuk eksekusi berurutan dari algoritma; </li><li>  gunakan <code>std::execution::par</code> untuk mengeksekusi algoritma secara paralel (biasanya menggunakan beberapa implementasi Thread Pool (thread pool)); </li><li>  gunakan <code>std::execution::par_unseq</code> untuk eksekusi paralel dari algoritma dengan kemampuan untuk menggunakan perintah vektor (misalnya, SSE, AVX). </li></ul><br>  Sebagai contoh cepat, panggil <code>std::sort</code> paralel: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::execution::par, myVec.begin(), myVec.end()); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^^^^^^^^^^ //  </span></span></code> </pre> <br>  Perhatikan betapa mudahnya menambahkan parameter eksekusi paralel ke algoritme!  Tetapi apakah peningkatan kinerja yang signifikan akan tercapai?  Apakah ini akan meningkatkan kecepatan?  Atau adakah perlambatan? <br><br>  <b><code>std::transform</code> paralel <code>std::transform</code></b> <br><br>  Pada artikel ini, saya ingin memperhatikan algoritma <code>std::transform</code> , yang berpotensi menjadi dasar untuk metode paralel lainnya (bersama dengan <code>std::transform_reduce</code> , <code>for_each</code> , <code>scan</code> , <code>sort</code> ...). <br><br>  Kode pengujian kami akan dibuat sesuai dengan templat berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(execution_policy, <span class="hljs-comment"><span class="hljs-comment">// par, seq, par_unseq inVec.begin(), inVec.end(), outVec.begin(), ElementOperation);</span></span></code> </pre> <br>  Misalkan fungsi <code>ElementOperation</code> tidak memiliki metode sinkronisasi, dalam hal ini kode memiliki potensi eksekusi paralel atau bahkan vektorisasi.  Setiap perhitungan elemen independen, urutannya tidak penting, sehingga implementasi dapat menghasilkan beberapa utas (mungkin dalam kumpulan utas) untuk pemrosesan elemen independen. <br><br>  Saya ingin bereksperimen dengan hal-hal berikut: <br><br><ul><li>  ukuran bidang vektor besar atau kecil; </li><li>  konversi sederhana yang menghabiskan sebagian besar waktu mengakses memori; </li><li>  lebih banyak operasi aritmatika (ALU); </li><li>  ALU dalam skenario yang lebih realistis. </li></ul><br>  Seperti yang Anda lihat, saya ingin tidak hanya menguji jumlah elemen yang "baik" untuk menggunakan algoritma paralel, tetapi juga operasi ALU yang menggunakan prosesor. <br>  Algoritma lain, seperti pengurutan, akumulasi (dalam bentuk std :: mengurangi) juga menawarkan eksekusi paralel, tetapi juga membutuhkan lebih banyak pekerjaan untuk menghitung hasilnya.  Karena itu, kami akan mempertimbangkan mereka sebagai kandidat untuk artikel lain. <br><br>  Catatan Benchmark <br><br>  Untuk pengujian saya, saya menggunakan Visual Studio 2017, 15,8 - karena ini adalah satu-satunya implementasi dalam implementasi kompiler populer / STL saat ini (November, 2018) (GCC di jalan!).  Selain itu, saya hanya fokus pada <code>execution::par</code> , karena <code>execution::par_unseq</code> tidak tersedia di MSVC (kerjanya mirip dengan <code>execution::par</code> ). <br><br>  Ada dua komputer: <br><br><ul><li>  i7 8700 - PC, Windows 10, i7 8700 - 3,2 GHz, 6 core / 12 utas (Hyperthreading); </li><li>  i7 4720 - Laptop, Windows 10, i7 4720, 2.6 GHz, 4 core / 8 utas (Hyperthreading). </li></ul><br>  Kode dikompilasi dalam x64, Rilis lebih lanjut, auto-vektorisasi diaktifkan secara default, saya juga menyertakan serangkaian perintah yang diperluas (SSE2) dan OpenMP (2.0). <br><br>  Kode ini ada di github saya: <a href="">github / fenbf / ParSTLTests / TransformTests / TransformTests.cpp</a> <br><br>  Untuk OpenMP (2.0), saya menggunakan paralelisme hanya untuk loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for for (int i = 0; ...)</span></span></code> </pre> <br>  Saya menjalankan kode 5 kali dan melihat hasil minimum. <br><br>  <i><b>Peringatan</b> : Hasil hanya mencerminkan pengamatan kasar, periksa sistem / konfigurasi Anda sebelum digunakan dalam produksi.</i>  <i>Persyaratan dan lingkungan Anda mungkin berbeda dari saya.</i> <br><br>  Anda dapat membaca lebih lanjut tentang implementasi MSVC di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos ini</a> .  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah laporan</a> terbaru Bill O'Neill dengan CppCon 2018 (Bill menerapkan Parallel STL di MSVC). <br><br>  Baiklah, mari kita mulai dengan contoh-contoh sederhana! <br><br>  <b>Konversi sederhana</b> <br><br>  Pertimbangkan kasus ketika Anda menerapkan operasi yang sangat sederhana ke vektor input.  Ini bisa berupa penyalinan atau penggandaan elemen. <br><br>  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::execution::par, vec.begin(), vec.end(), out.begin(), [](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; } );</code> </pre><br>  Komputer saya memiliki 6 atau 4 core ... dapatkah saya mengharapkan eksekusi berurutan lebih cepat 4,6x?  Inilah hasil saya (waktu dalam milidetik): <br><br><table><tbody><tr><th>  Operasi </th><th>  Ukuran vektor </th><th>  i7 4720 (4 core) </th><th>  i7 8700 (6 core) </th></tr><tr><td>  eksekusi :: seq </td><td>  10rb </td><td>  0,002763 </td><td>  0,001924 </td></tr><tr><td>  eksekusi :: par </td><td>  10rb </td><td>  0,009869 </td><td>  0,008983 </td></tr><tr><td>  paralel openmp untuk </td><td>  10rb </td><td>  0,003158 </td><td>  0,002246 </td></tr><tr><td>  eksekusi :: seq </td><td>  100rb </td><td>  0,051318 </td><td>  0,028872 </td></tr><tr><td>  eksekusi :: par </td><td>  100rb </td><td>  0,043028 </td><td>  0,025664 </td></tr><tr><td>  paralel openmp untuk </td><td>  100rb </td><td>  0,022501 </td><td>  0,009624 </td></tr><tr><td>  eksekusi :: seq </td><td>  1000rb </td><td>  1.69508 </td><td>  0,52419 </td></tr><tr><td>  eksekusi :: par </td><td>  1000rb </td><td>  1.65561 </td><td>  0,359619 </td></tr><tr><td>  paralel openmp untuk </td><td>  1000rb </td><td>  1.50678 </td><td>  0,344863 </td></tr></tbody></table><br>  Pada mesin yang lebih cepat, kita dapat melihat bahwa dibutuhkan sekitar 1 juta elemen untuk melihat peningkatan kinerja.  Di sisi lain, di laptop saya semua implementasi paralel lebih lambat. <br><br>  Dengan demikian, sulit untuk melihat peningkatan kinerja yang signifikan menggunakan transformasi tersebut, bahkan dengan peningkatan jumlah elemen. <br><br>  Kenapa begitu? <br><br>  Karena operasinya elementer, inti prosesor dapat memanggilnya hampir secara instan, hanya menggunakan beberapa siklus.  Namun, core prosesor menghabiskan lebih banyak waktu menunggu memori utama.  Jadi, dalam hal ini, sebagian besar mereka akan menunggu, bukan membuat perhitungan. <br><br>  <i>Membaca dan menulis variabel dalam memori membutuhkan sekitar 2-3 siklus jika di-cache, dan beberapa ratus siklus jika tidak di-cache.</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.agner.org/optimize/optimizing_cpp.pdf</a> <br><br>  Secara kasar Anda dapat mencatat bahwa jika algoritme Anda bergantung pada memori, maka Anda seharusnya tidak mengharapkan peningkatan kinerja dengan komputasi paralel. <br><br>  <b>Lebih banyak perhitungan</b> <br><br>  Karena bandwidth memori sangat penting dan dapat memengaruhi kecepatan hal-hal ... mari kita tingkatkan jumlah komputasi yang memengaruhi setiap elemen. <br><br>  Idenya adalah bahwa lebih baik menggunakan siklus prosesor daripada membuang-buang waktu menunggu memori. <br><br>  Untuk mulai dengan, saya menggunakan fungsi trigonometri, misalnya, <code>sqrt(sin*cos)</code> (ini adalah perhitungan bersyarat dalam bentuk yang tidak optimal, hanya untuk menempati prosesor). <br><br>  Kami menggunakan <code>sqrt</code> , <code>sin</code> dan <code>cos</code> , yang dapat mengambil ~ 20 per <code>sqrt</code> dan ~ 100 per fungsi trigonometri.  Jumlah perhitungan ini dapat mencakup penundaan akses memori. <br><br>  Untuk informasi lebih lanjut tentang keterlambatan tim, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Perf</a> sangat baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh Agner Fogh</a> . <br><br>  Berikut ini adalah kode benchmark: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::execution::par, vec.begin(), vec.end(), out.begin(), [](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(v)*<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(v)); } );</code> </pre> <br>  Dan sekarang apa?  Bisakah kita mengandalkan peningkatan kinerja dari upaya sebelumnya? <br><br>  Berikut ini beberapa hasil (waktu dalam milidetik): <br><br><table><tbody><tr><th>  Operasi </th><th>  Ukuran vektor </th><th>  i7 4720 (4 core) </th><th>  i7 8700 (6 core) </th></tr><tr><td>  eksekusi :: seq </td><td>  10rb </td><td>  0,105005 </td><td>  0,070577 </td></tr><tr><td>  eksekusi :: par </td><td>  10rb </td><td>  0,055661 </td><td>  0,03176 </td></tr><tr><td>  paralel openmp untuk </td><td>  10rb </td><td>  0,096321 </td><td>  0,024702 </td></tr><tr><td>  eksekusi :: seq </td><td>  100rb </td><td>  1.08755 </td><td>  0,707048 </td></tr><tr><td>  eksekusi :: par </td><td>  100rb </td><td>  0,259354 </td><td>  0,17195 </td></tr><tr><td>  paralel openmp untuk </td><td>  100rb </td><td>  0,898465 </td><td>  0,189915 </td></tr><tr><td>  eksekusi :: seq </td><td>  1000rb </td><td>  10.5159 </td><td>  7.16254 </td></tr><tr><td>  eksekusi :: par </td><td>  1000rb </td><td>  2.44472 </td><td>  1.10099 </td></tr><tr><td>  paralel openmp untuk </td><td>  1000rb </td><td>  4.78681 </td><td>  1.89017 </td></tr></tbody></table><br>  Akhirnya, kami melihat angka yang bagus :) <br><br>  Untuk 1000 elemen (tidak ditampilkan di sini), waktu perhitungan paralel dan berurutan serupa, oleh karena itu untuk lebih dari 1000 elemen kita melihat peningkatan dalam versi paralel. <br><br>  Untuk 100 ribu elemen, hasil pada komputer yang lebih cepat hampir 9 kali lebih baik daripada versi serial (sama untuk versi OpenMP). <br><br>  Dalam versi terbesar sejuta elemen, hasilnya 5 atau 8 kali lebih cepat. <br>  Untuk perhitungan seperti itu, saya mencapai akselerasi "linear", tergantung pada jumlah core prosesor.  Yang diharapkan. <br><br>  <b>Fresnel dan vektor tiga dimensi</b> <br><br>  Pada bagian di atas, saya menggunakan perhitungan "diciptakan", tetapi bagaimana dengan kode asli? <br>  Mari kita pecahkan persamaan Fresnel yang menggambarkan pantulan dan kelengkungan cahaya dari permukaan yang halus dan rata.  Ini adalah metode populer untuk menghasilkan pencahayaan realistis dalam game 3D. <br><br><img src="https://habrastorage.org/webt/on/wm/7u/onwm7uw4puyphebsmkehma2jxfa.png"><br><br><img src="https://habrastorage.org/webt/7z/kq/2j/7zkq2jp8qisjnpc6y_gmgvhpupk.jpeg"><br>  <i>Foto dari <a href="">Wikimedia</a></i> <br><br>  Sebagai contoh yang baik, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi dan implementasi ini</a> . <br><br>  <b>Tentang menggunakan perpustakaan GLM</b> <br><br>  Alih-alih membuat implementasi saya sendiri, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan glm</a> .  Saya sering menggunakannya di proyek OpenGl saya. <br><br>  Perpustakaan mudah diakses melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Conan Package Manager</a> , jadi saya akan menggunakannya juga.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> ke paket. <br><br>  File Conan: <br><br><pre> <code class="bash hljs">[requires] glm/0.9.9.1@g-truc/stable [generators] visual_studio</code> </pre><br>  dan baris perintah untuk menginstal perpustakaan (ini menghasilkan file alat peraga yang dapat saya gunakan dalam proyek Visual Studio): <br><br><pre> <code class="bash hljs">conan install . -s build_type=Release -<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> build_release_x64 -s arch=x86_64</code> </pre> <br>  Pustaka terdiri dari tajuk, jadi Anda bisa mengunduhnya secara manual jika mau. <br><br>  <b>Kode aktual dan tolok ukur</b> <br><br>  Saya mengadaptasi kode untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glm</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scratchapixel.com</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    https://www.scratchapixel.com float fresnel(const glm::vec4 &amp;I, const glm::vec4 &amp;N, const float ior) { float cosi = std::clamp(glm::dot(I, N), -1.0f, 1.0f); float etai = 1, etat = ior; if (cosi &gt; 0) { std::swap(etai, etat); } //  sini     float sint = etai / etat * sqrtf(std::max(0.f, 1 - cosi * cosi)); //    if (sint &gt;= 1) return 1.0f; float cost = sqrtf(std::max(0.f, 1 - sint * sint)); cosi = fabsf(cosi); float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); return (Rs * Rs + Rp * Rp) / 2.0f; }</span></span></code> </pre> <br>  Kode menggunakan beberapa instruksi matematis, produk skalar, perkalian, pembagian, sehingga prosesor memiliki sesuatu untuk dilakukan.  Alih-alih vektor ganda, kami menggunakan vektor 4 elemen untuk meningkatkan jumlah memori yang digunakan. <br><br>  Benchmark: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::execution::par, vec.begin(), vec.end(), vecNormals.begin(), <span class="hljs-comment"><span class="hljs-comment">//   vecFresnelTerms.begin(), //  [](const glm::vec4&amp; v, const glm::vec4&amp; n) { return fresnel(v, n, 1.0f); } );</span></span></code> </pre> <br>  Dan inilah hasilnya (waktu dalam milidetik): <br><br><table><tbody><tr><th>  Operasi </th><th>  Ukuran vektor </th><th>  i7 4720 (4 core) </th><th>  i7 8700 (6 core) </th></tr><tr><td>  eksekusi :: seq </td><td>  1rb </td><td>  0,032764 </td><td>  0,016361 </td></tr><tr><td>  eksekusi :: par </td><td>  1rb </td><td>  0,031186 </td><td>  0,028551 </td></tr><tr><td>  paralel openmp untuk </td><td>  1rb </td><td>  0,005526 </td><td>  0,007699 </td></tr><tr><td>  eksekusi :: seq </td><td>  10rb </td><td>  0,246722 </td><td>  0,169383 </td></tr><tr><td>  eksekusi :: par </td><td>  10rb </td><td>  0,090794 </td><td>  0,067048 </td></tr><tr><td>  paralel openmp untuk </td><td>  10rb </td><td>  0,049739 </td><td>  0,029835 </td></tr><tr><td>  eksekusi :: seq </td><td>  100rb </td><td>  2.49722 </td><td>  1.69768 </td></tr><tr><td>  eksekusi :: par </td><td>  100rb </td><td>  0,530157 </td><td>  0,283268 </td></tr><tr><td>  paralel openmp untuk </td><td>  100rb </td><td>  0,495024 </td><td>  0,291609 </td></tr><tr><td>  eksekusi :: seq </td><td>  1000rb </td><td>  25/08/28 </td><td>  16.9457 </td></tr><tr><td>  eksekusi :: par </td><td>  1000rb </td><td>  5.15235 </td><td>  2.33768 </td></tr><tr><td>  paralel openmp untuk </td><td>  1000rb </td><td>  5.11801 </td><td>  2.95908 </td></tr></tbody></table><br>  Dengan komputasi "nyata", kami melihat bahwa algoritma paralel memberikan kinerja yang baik.  Untuk operasi seperti itu pada dua mesin Windows saya, saya mencapai akselerasi dengan ketergantungan hampir linier pada jumlah core. <br><br>  Untuk semua tes, saya juga menunjukkan hasil dari OpenMP dan dua implementasi: MSVC dan OpenMP bekerja dengan cara yang sama. <br><br>  <b>Kesimpulan</b> <br><br>  Pada artikel ini, saya melihat tiga kasus menggunakan komputasi paralel dan algoritma paralel.  Mengganti algoritma standar dengan std :: eksekusi :: versi par mungkin tampak sangat menggoda, tetapi ini tidak selalu layak dilakukan!  Setiap operasi yang Anda gunakan di dalam algoritma dapat bekerja secara berbeda dan lebih tergantung pada prosesor atau memori.  Karena itu, pertimbangkan setiap perubahan secara terpisah. <br><br>  Hal yang perlu diingat: <br><br><ul><li>  eksekusi paralel, biasanya, melakukan lebih dari sekuensial, karena perpustakaan harus mempersiapkan eksekusi paralel; </li><li>  tidak hanya jumlah elemen yang penting, tetapi juga jumlah instruksi yang digunakan prosesor; </li><li>  lebih baik mengambil tugas yang independen satu sama lain dan sumber daya bersama lainnya; </li><li>  algoritma paralel menawarkan cara mudah untuk membagi pekerjaan menjadi utas yang terpisah; </li><li>  jika operasi Anda bergantung pada memori, Anda seharusnya tidak mengharapkan peningkatan kinerja, dan dalam beberapa kasus, algoritme mungkin lebih lambat; </li><li>  untuk mendapatkan peningkatan kinerja yang layak, selalu mengukur timing dari setiap masalah, dalam beberapa kasus hasilnya mungkin sangat berbeda. </li></ul><br>  Terima kasih khusus kepada JFT untuk membantu artikel ini! <br><br>  Perhatikan juga sumber saya yang lain tentang algoritma paralel: <br><br><ul><li>  Bab baru-baru ini di buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ 17 In Detail saya</a> tentang Parallel Algorithms; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STL Paralel Dan Sistem File: File Word Count Contoh</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh algoritma paralel dari C ++ 17</a> . </li></ul><br>  Lihatlah artikel lain yang terkait dengan Algoritma Paralel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Meningkatkan Kinerja dengan Intel Parallel STL dan C ++ 17 Algoritma Paralel</a> <br><br>  AKHIR <br><br>  Kami menunggu komentar dan pertanyaan yang dapat Anda tinggalkan di sini atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">guru</a> kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pintu terbuka</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433588/">https://habr.com/ru/post/id433588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433576/index.html">Panduan untuk gerakan IT St Petersburg</a></li>
<li><a href="../id433578/index.html">"Ketika seni terhubung dengan kerajinan tangan": penerbit media online tentang teknologi, AI, dan kehidupan</a></li>
<li><a href="../id433580/index.html">Roskomnadzor berencana untuk memperkenalkan sistem kunci baru senilai 20 miliar rubel</a></li>
<li><a href="../id433582/index.html">Bagaimana jika pembagian keuntungan 30/70 berhenti menjadi standar pengembang game?</a></li>
<li><a href="../id433586/index.html">Bagaimana kami tidak memenangkan hackathon</a></li>
<li><a href="../id433592/index.html">Informasi: Yandex.Phone</a></li>
<li><a href="../id433596/index.html">Kesalahan Magellan: Buffer overrun atau ekspedisi keliling dunia menggunakan SQLite FTS</a></li>
<li><a href="../id433598/index.html">Bagaimana LLVM mengoptimalkan fungsi</a></li>
<li><a href="../id433600/index.html">Pixel 3 mempelajari cara menentukan kedalaman di foto</a></li>
<li><a href="../id433602/index.html">Kesederhanaan matematis mungkin mendasari kecepatan evolusi.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>