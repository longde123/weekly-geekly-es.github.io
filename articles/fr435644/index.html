<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 👩🏻‍🎤 👩🏿‍🏫 Zoo AFL Phasers 🌒 🌁 👩🏻‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a eu plusieurs articles sur le Habré qui ont soulevé le sujet de l'American Fuzzy Lop (AFL) ( 1 , 2 ). Mais dans cet article, nous ne parlerons p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zoo AFL Phasers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/435644/"><img src="https://habrastorage.org/webt/l4/vc/qr/l4vcqrdnz0vgsseyssmztrfrvdg.jpeg" alt="image"><br><br>  Il y a eu plusieurs articles sur le Habré qui ont soulevé le sujet de l'American Fuzzy Lop (AFL) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> ).  Mais dans cet article, nous ne parlerons pas de l'AFL classique, mais des utilitaires auxiliaires pour lui et de ses modifications, qui, à notre avis, peuvent améliorer considérablement la qualité du fuzzing.  Si vous souhaitez apprendre à mettre à niveau AFL et rechercher des vulnérabilités plus rapides et plus nombreuses, bienvenue dans la coupe! <br><a name="habracut"></a><br><h1>  Qu'est-ce que l'AFL et pourquoi est-ce si bon </h1><br>  AFL - Fuzzer guidé par la couverture ou fuzzer basé sur la rétroaction.  Vous pouvez en savoir plus sur ces concepts à partir d'un article aussi cool que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fuzzing: Art, Science et Engineering</a> .  Si nous résumons les informations sur AFL, nous pouvons dire ce qui suit: <br><ul><li>  Outillage d'un exécutable pour collecter des informations de couverture </li><li>  Mute l'entrée pour maximiser la couverture </li><li>  Répète l'étape précédente pour rechercher les plantages du programme. <ul><li>  En pratique, très efficace <ul><li>  Très simple d'utilisation </li></ul></li></ul></li></ul><br><br>  Graphiquement, cela peut être représenté comme suit: <br><br><img src="https://habrastorage.org/webt/iq/5z/au/iq5zaub6qftefx3x_q5te6d6guo.png" alt="image"><br><br>  Si vous ne savez pas ce qu'est l'AFL, alors pour commencer, nous vous recommandons: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Page officielle du projet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-training</a> - une brève excursion en AFL </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-demo</a> - une démonstration simple de la façon de flou un programme C ++ en utilisant AFL </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-cve</a> - Collection de vulnérabilités découvertes à l'aide d'AFL (non mis à jour depuis 2017) </li><li>  Le fait que l'AFL ajoute au programme lors de son assemblage peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </li><li>  Quelques conseils utiles pour fuzzer les applications réseau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </li></ol><br>  Au moment de la rédaction, la dernière version d'AFL était la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.52b</a> .  Fazzer se développe activement, et au fil du temps, certains développements tiers sont inclus dans la branche principale d'AFL et deviennent hors de propos par eux-mêmes.  Il existe actuellement plusieurs outils auxiliaires utiles qui peuvent être identifiés - ils sont répertoriés dans la section suivante. <br><br><div class="spoiler">  <b class="spoiler_title">Compétition Rode0day</b> <div class="spoiler_text">  Par ailleurs, il convient de mentionner la compétition mensuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rode0day</a> , où il y a une concurrence entre les phaseurs qui trouveront des vulnérabilités plus rapidement et plus dans des cas pré-préparés avec accès au code source et sans lui.  Et dans l'ensemble est une confrontation de diverses modifications et fourches AFL. <br></div></div><br>  Cependant, certains utilisateurs de l'AFL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notent</a> que l'auteur du phaseur Michal Zalewski a marqué une campagne pour soutenir son idée, car les derniers changements sont datés du 5 novembre 2017.  Cela serait lié à son départ de Google et à de nouveaux projets.  À cet égard, les gens ont commencé à collecter et à créer indépendamment des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctifs pour la</a> dernière version actuelle 2.52b. <br><br><img src="https://habrastorage.org/webt/fy/00/xa/fy00xat3cumh3iq9a5biou30czi.png" alt="image"><br><br>  Il existe également différentes options et dérivés d'AFL qui permettent de fuzzer Python, Go, Rust, OCaml, GCJ Java, les appels système du noyau ou même des machines virtuelles entières. <br><br><div class="spoiler">  <b class="spoiler_title">AFL pour d'autres PL</b> <div class="spoiler_text"><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">python-afl</a> - pour Python. <br>  - <a href="">afl.rs</a> - pour fuzzer un programme dans Rust <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-fuzz-js</a> - afl-fuzz pour javascript. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">java-afl</a> - AFL fuzzing pour Java <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kelinci</a> - un autre phaser pour Java avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur ce sujet <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javan-warty-pig</a> - Fuzzer de type AFL pour JVM. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-swift</a> - pour fuzzer un programme sur swift <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ocamlopt-afl</a> - pour OCaml. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sharpfuzz</a> - basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl</a> pour .net fuzzer. <br></div></div><br><h1>  Outils auxiliaires </h1><br>  Dans cette section, nous avons sélectionné divers scripts et outils pour travailler avec AFL et les avons divisés en plusieurs catégories: <br><br>  <u>Traitement de kresh</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-utils</a> - un ensemble d'utilitaires pour le traitement / l'analyse automatique des plantages et la minimisation des cas de test. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-crash-analyzer</a> - Un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur de crash</a> AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fuzzer-utils</a> - un ensemble de scripts pour analyser les résultats. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">atriage</a> est un outil de triage simple. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-kit</a> - Réécrit en python afl-cmin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AFLize</a> est un outil qui génère automatiquement des builds de paquets Debian adaptés aux afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-fid</a> - un ensemble d'outils pour travailler avec les données d'entrée. </li></ul><br>  <u>Couverture du code</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-cov</a> - Fournit des données de couverture lisibles par l'homme. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">count-afl-calls</a> - Score de rapport.  Le script compte le nombre de blocs instrumentés dans le binaire. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-sancov</a> - comme afl-cov, mais utilise un désinfectant Clang. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">covnavi</a> est un script d'analyse et de couverture de code du groupe Cisco Talos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LAF LLVM Passes</a> est un ensemble de correctifs pour afl qui modifient le code pour faciliter le passage des branches par les branches </li></ul><br>  <u>Plusieurs scripts pour minimiser les cas de test</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-pytmin</a> est un wrapper pour afl-tmin qui essaie d'accélérer le processus de réduction du scénario de test en utilisant plusieurs cœurs de processeur. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-ddmin-mod</a> - une variation de afl-tmin basée sur l'algorithme ddmin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">halfempty</a> est un utilitaire basé sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parallélisation</a> rapide pour minimiser les cas de test de Tavis Ormandy. </li></ul><br>  <u>Pour un démarrage distribué</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disfuzz-afl</a> - fuzzing distribué pour afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AFLDFF</a> est un cadre pour le fuzzing distribué avec AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-launch</a> est un outil pour lancer de nombreuses instances afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-mèreship</a> - Gérez et lancez plusieurs fuzzers AFL synchronisés sur le cloud AWS. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-in-the-cloud</a> est un autre script pour exécuter afl dans AWS. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VU_BSc_project</a> - Test Fuzz des bibliothèques open source avec libFuzzer et AFL. </li></ul><br>  En outre, un très bon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Mise à l'échelle d'AFL sur une machine à 256 threads»</a> a récemment été publié sur ce sujet, qui décrit le lancement d'AFL sur 256 threads. <br><br>  <u>Déploiement, gestion, suivi, reporting</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-other-arch</a> - un ensemble de correctifs et de scripts pour ajouter facilement la prise en charge de diverses architectures (non x86) dans AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-trivia</a> - quelques petits scripts pour simplifier la gestion de l'AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-monitor</a> - un script pour surveiller le fonctionnement de l'AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-manager</a> - un serveur web python pour gérer multi-afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-tools</a> - image docker avec afl-latest, afl-dyninst et Triforce-afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-remote</a> - un serveur Web pour la gestion à distance des instances afl. </li></ul><br><h1>  Modifications AFL </h1><br>  AFL a grandement influencé la communauté de recherche de vulnérabilités et l'industrie du fuzzing elle-même.  Et il n'est pas surprenant qu'au fil du temps, diverses modifications inspirées de l'AFL d'origine aient commencé à apparaître sur la base de son idée.  Dans cette section, nous les examinerons.  Chacune de ces modifications a ses avantages ainsi que ses inconvénients par rapport à la version AFL d'origine dans différentes situations. <br><br>  Dites simplement que s'il y a des problèmes avec l'installation ou si vous ne voulez pas passer de temps - presque toute modification peut être trouvée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub.docker.com</a> <br><br>  Pourquoi? <br><br><ul><li>  Augmentez la vitesse et / ou la couverture du code <br><ul><li>  Des algorithmes </li><li>  L'environnement <br><ul><li>  OS </li><li>  Le fer </li></ul><br></li></ul><br></li><li>  Travailler dans des conditions sans code source <br><ul><li>  Émulation de code </li><li>  Instrumentation de code <br><ul><li>  Statique </li><li>  Dynamique </li></ul><br></li></ul><br></li></ul><br>  <u>Modes AFL intégrés</u> <br><br>  Avant de passer à la discussion des différentes modifications et fourches AFL, il est nécessaire de parler de deux modes importants qui étaient autrefois également des modifications, et qui sont finalement devenus des modes intégrés.  Il s'agit du mode Syzygy et du mode Qemu. <br><br>  Mode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Syzygy</a> - est le mode de fonctionnement dans instrument instrument.exe <pre><code class="bash hljs">instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe</code> </pre>  Pour ce mode, il est nécessaire: Réécrire statiquement les binaires PE32 avec AFL, des symboles sont requis, Nécessite un dev supplémentaire pour rendre le noyau WinAFL conscient. <br><br>  Mode Qemu - Comment cela fonctionne sous QEMU peut être trouvé ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Internals of AFL fuzzer - QEMU Instrumentation"</a> .  La prise en charge de l'utilisation des binaires à l'aide de QEMU est apparue dans l'AFL en amont à partir de la version 1.31b.  Le mode afl qemu fonctionne avec la fonctionnalité supplémentaire d'instrumentation de code binaire dans le moteur de traduction binaire qemu tcg (petit générateur de code).  Pour ce faire, afl dispose d'un script de construction qemu qui télécharge le code source d'une version spécifique (2.10.0) de qemu, leur impose plusieurs petits correctifs et les compile pour une architecture donnée.  Après cela, le fichier afl-qemu-trace est renvoyé, qui est en fait une émulation en mode utilisateur (émulation de fichiers exécutables ELF uniquement).  Grâce à cela, vous pouvez utiliser le fuzzing avec des commentaires sur les binaires elf, et pour un tas d'architectures différentes prises en charge par qemu.  De plus, vous obtenez tous les outils cool d'Afl, en commençant par un écran pratique avec des informations sur la session en cours et en terminant par des choses avancées comme afl-analyse.  Mais gardez à l'esprit que vous bénéficiez également de restrictions qemu.  De plus, par exemple, si le fichier est compilé par une chaîne d'outils qui utilise les fonctionnalités matérielles SoC, sur lesquelles le binaire est lancé et qui n'est pas pris en charge par qemu, le fuzzing s'arrête dès qu'une instruction spécifique est rencontrée, ou, par exemple, un MMIO spécifique est utilisé. <br><br>  Il existe également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> fourchette intéressante du mode qemu, où la vitesse a été augmentée 3x-4x fois en raison de l'instrumentation du code TCG et de la mise en cache. <br><br>  <u>Fourches</u> <br><br>  L'apparition des fourches AFL est principalement associée à des changements, à des améliorations des algorithmes de fonctionnement des AFL classiques eux-mêmes. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-cygwin</a> est une tentative de portage d'AFL classique vers Windows à l'aide de Cygwin.  Malheureusement, cette tentative est assez floue, lente et le développement peut être considéré comme abandonné. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AFLFast</a> (étend AFL avec Power Schedules) - l'une des premières fourches d'AFL, toutes sortes d'heuristiques ont été ajoutées, grâce auxquelles elle pourrait aller plus loin dans un court laps de temps. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FairFuzz</a> est une extension AFL dont le but est d'essayer de passer plus de temps sur des branches plus rares. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AFLGo</a> est une extension pour AFL, qui est principalement destinée à la réalisation ciblée de certaines sections de code, plutôt qu'à la couverture générale du code de programme.  Cela peut être utilisé pour tester des correctifs ou des sections de code nouvellement ajoutées. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PerfFuzz</a> est une extension AFL qui recherche des cas de test qui pourraient ralentir le programme autant que possible. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pythia</a> est une extension pour AFL qui vise à ajouter des éléments de prédiction au processus de phasage en ce qui concerne la difficulté de découvrir de nouveaux chemins. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angora</a> est l'un des flous les plus récents, écrits en rouille.  Utilise ses nouvelles stratégies de mutation et pour augmenter la couverture. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Neuzz</a> - une tentative de fuzz en utilisant des réseaux de neurones. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UnTracer-AFL</a> - intégration afl avec UnTracer, pour un traçage efficace. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qsym</a> - Moteur d'exécution concolique pratique conçu pour le fuzzing hybride.  En fait, c'est un moteur d'exécution de symboles (les principaux composants sont implémentés comme un plug-in intel pin), qui, en combinaison avec afl, implémente le fuzzing hybride.  Il s'agit d'une nouvelle évolution du sujet de fuzzing basé sur les commentaires et mérite une discussion séparée.  Son principal mérite est qu'il peut très rapidement (par rapport au reste) effectuer une exécution concolique.  Cela se produit en raison de l'exécution native des commandes sans présentation intermédiaire du code, en se débarrassant du mécanisme d'instantané et d'un certain nombre d'heuristiques.  Il utilise l'ancienne broche Intel (en raison d'un certain nombre de problèmes de support entre libz3 et d'autres DBT) et peut actuellement fonctionner avec les architectures elf x86 et x86_64. </li></ul><br>  Il convient de noter qu'il existe un grand nombre de travaux universitaires liés à la mise en œuvre de nouvelles approches, techniques de fuzzing, où l'AFL est utilisé et modifié.  En plus du livre blanc, rien d'autre n'est disponible, nous n'avons donc même pas mentionné de telles implémentations.  Si vous êtes intéressé, alors ils sont faciles à google.  Par exemple, ce dernier est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CollAFL: Path Sensitive Fuzzing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EnFuzz</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Smart Greybox Fuzzing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ML</a> for afl. <br><br>  <u>Modifications basées sur Qemu</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TriforceAFL</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fuzzing</a> AFL / QEMU avec émulation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système</a> complète.  Fourche de nccgroup.  Permet de flouiller l'ensemble du système d'exploitation en mode qemu.  Implémenté via une instruction spéciale (aflCall (0f 24)), qui a été ajoutée au processeur QEMU x64.  Malheureusement, il n'est plus pris en charge, la dernière version d'AFL en elle est 2.06b. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TriforceLinuxSyscallFuzzer</a> - Fuzzing des appels système Linux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-qai</a> est un petit projet de démonstration avec QEMU Augmented Instrumentation (qai). </li></ul><br><br>  <u>Modification basée sur KLEE</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kleefl</a> - pour générer des cas de test au moyen d'une exécution symbolique (très lent sur les grands programmes). <br><br>  <u>Modifications basées sur Unicorn</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-unicorn</a> - vous permet de fuzz des morceaux de code, en les émulant sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur Unicorn</a> .  Nous avons également utilisé avec succès cette variation AFL dans notre pratique, à savoir dans les sections de code d'un RTOS, qui a été exécuté sur SOC, et il était impossible d'utiliser le mode QEMU.  Il est conseillé d'utiliser cette modification lorsqu'il n'y a pas de sources (vous ne pouvez pas assembler de binaires autonomes pour l'analyse de l'analyseur) et que le programme n'accepte pas directement les données d'entrée (par exemple, elles sont cryptées ou représentent des échantillons de signaux comme dans un binaire CGC), vous pouvez alors les utiliser inverser et trouver les lieux-fonctions proposés où ces données sont traitées dans un format convenable pour le fuzzer et qui peuvent être fuzzées.  Il s'agit de la modification AFL la plus courante.  En ce sens que cela vous permet de tout flou.  Autrement dit, cela ne dépend pas de l'architecture, de la disponibilité des codes source, du format des données d'entrée et du format du binaire lui-même (l'exemple le plus frappant est juste du métal nu - juste des morceaux de code de la mémoire du contrôleur).  Le chercheur examine au préalable ce binar même et écrit un fuzzer qui émule l'état à l'entrée de la procédure de l'analyseur, par exemple.  On peut voir que, contrairement à l'AFL, vous devez faire une sorte de recherche sur le binaire.  Pour le micrologiciel nu, comme le Wi-Fi ou la bande de base, il y a simplement un certain nombre d'inconvénients que vous devez garder à l'esprit: <br><br><ol><li>  Il est nécessaire de localiser en quelque sorte les contrôles de somme de contrôle. </li><li>  Il faut garder à l'esprit que l'état du fuzzer est l'état de la mémoire qui a été stockée dans le vidage de la mémoire, cela peut empêcher la réalisation de certains chemins pour le fuzzer. </li><li>  Il n'y a pas d'assainissement des accès à la mémoire dynamique, mais elle peut être implémentée manuellement (également après avoir déployé des efforts), et cela dépendra de RTOS (elle doit également être étudiée au préalable). </li><li>  L'interaction entre les tâches RTOS n'est pas émulée - vous pouvez également empêcher Fuzzer de trouver certains chemins. </li></ol><br>  Un exemple de travail avec cette modification est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«afl-unicorn: Fuzzing Arbitrary Binary Code»</a> et <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Afl-unicorn: Part 2 - Fuzzing the 'Unfuzzable'»</a> . <br><br>  Avant de passer aux modifications basées sur les frameworks d'instrumentation binaire dynamique (DBI), nous rappelons immédiatement que DynamoRIO affiche la vitesse la plus élevée de ces frameworks, puis DynInst, et enfin PIN. <br><br>  <u>Modifications du code PIN</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aflpin</a> - AFL avec Intel PIN Instrumentation. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl_pin_mode</a> - Une autre instrumentation AFL implémentée via Intel PIN. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-pin</a> - AFL avec PINtool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NaFl</a> - Un clone (du noyau de base) de fuzzer AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PinAFL</a> - l'auteur de l'outil a essayé de transférer AFL vers Windows pour fuzzing des binaires déjà compilés.  Apparemment, on a fait plus sur le ventilateur en une soirée, puis le projet ne se développe pas.  Le référentiel ne contient pas de sources, uniquement des binaires collectés et des instructions de démarrage.  La version AFL sur laquelle cet outil est basé n'est pas spécifiée et ne prend en charge que les applications 32 bits. </li></ul><br>  Comme vous pouvez le voir, il existe de nombreuses modifications différentes, mais dans la pratique, elles ne sont pas très utiles dans la vie réelle. <br><br>  <u>Modifications basées sur Dyninst</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-dyninst</a> - American Fuzzy Lop + Dyninst == AFL blackbox fuzzing.  La caractéristique de cette version est que le programme initialement étudié (sans code source) est instrumenté statiquement (instrumentation binaire statique, réécriture binaire statique) en utilisant DynInst, puis flou par l'AFL classique, qui pense que le programme a été construit en utilisant afl-gcc / afl -g ++ / afl-as;) Au final, cela nous donne l'opportunité de travailler sans code source et avec de très bonnes performances - Il était à une vitesse de 0,25x par rapport à une compilation native.  Il y a un avantage significatif par rapport à QEMU, qui est la capacité d'instrumenter des bibliothèques liées dynamiquement.  Alors que QEMU ne peut instrumenter que le fichier exécutable principal lié statiquement aux bibliothèques.  Malheureusement, cela ne concerne désormais que le système d'exploitation Linux.  Pour prendre en charge Windows, des modifications sont nécessaires dans DynInst lui-même et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail y</a> est en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours</a> . <br><br>  Vous pouvez également faire attention à une telle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fourche</a> où elle a été bien pompée sur diverses capacités (prise en charge des architectures AARCH64 et PPC) et la vitesse;) <br><br>  <u>Modifications basées sur DynamoRIO</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">drAFL</a> - AFL + DynamoRIO = fuzzing sans source sous Linux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-dr</a> - une autre mise en œuvre sur la base de DynamoRIO qui est déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peint en</a> détail dans les espaces ouverts de Habr. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afl-dynamorio</a> - modification de vanhauser-thc (un ventilateur pour pomper et stabiliser AFL).  il dit à propos de cette version: "exécutez AFL avec DynamoRIO lorsque afl-dyninst normal plante le mode binaire et qemu -Q n'est pas une option."  D'agréable, le support pour ARM et AARCH64 est ajouté ici.  Concernant les performances: DynamoRIO est environ ~ 10 plus lent que Qemu, ~ 25 plus lent que dyninst - cependant, ~ 10 plus rapide que Pintool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinAFL</a> est le fork le plus célèbre d'af pour Windows.  (DynamoRIO, ont également le mode syzygy).  L'apparition de cette modification n'était qu'une question de temps, car le désir d'essayer AFL sous Windows sur des applications pour lesquelles il n'y a pas de code source est apparu pour beaucoup.  Pour le moment, l'outil est activement développé, et malgré l'utilisation de la base de code AFL légèrement en retard (2.43b au moment de la rédaction), plusieurs vulnérabilités ont déjà été trouvées avec celui-ci (CVE-2016-7212, CVE-2017-0073, CVE-2017- 0190, CVE-2017-11816).  Il convient de noter que les principaux développeurs sont des spécialistes de l'équipe Google Zero Project et de l'équipe MSRC Vulnerabilities and Mitigations, ce qui donne des raisons d'espérer un développement actif du projet.  Pour implémenter le flou, les développeurs sont passés de la compilation de l'instrumentation temporelle à l'utilisation de l'instrumentation dynamique (basée sur DynamoRIO), ce qui devrait ralentir l'exécution du logiciel à l'étude, mais la surcharge résultante (deux fois) est comparable à l'AFL classique en mode binaire.  Les développeurs ont également résolu le problème d'un long démarrage du processus, le qualifiant de mode de fuzzing persistant, ils sélectionnent la fonction qui doit être fuzzée (par décalage dans le fichier ou par nom si la fonction est présentée dans la table d'exportation) et l'instrumentation de telle manière qu'elle puisse être appelée dans une boucle, lançant ainsi plusieurs échantillons de données d'entrée sans redémarrer le processus.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> intéressant est récemment paru dans lequel les chercheurs ont montré comment ils avaient trouvé ~ 50 vulnérabilités avec ~ 50 jours d'utilisation de winafl.  De plus, presque avant la publication de l'article dans WinAFL, le mode Intel PT a également été ajouté (plus d'informations à ce sujet plus tard) - les détails sont <a href="">ici</a> . </li></ul><br>  Un lecteur avancé / sophistiqué peut noter qu'il y a des modifications avec tous les cadres d'instrumentation populaires, à l'exception de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frida</a> - c'est le cas.  La seule mention de l'utilisation de Frida avec AFL n'a été trouvée que dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chizpurfle: Un Fuzzer Android Gray-Box pour les personnalisations des services des fournisseurs</a> .  La version d'AFL avec Frida était vraiment utile car Frida supporte bien un certain nombre d'architectures RISC. <br><br>  De nombreux chercheurs attendent également avec impatience la sortie du cadre Scorpio DBI du créateur de Capstone, Unicorne, Keystone.  Sur la base de ce cadre, les auteurs eux-mêmes ont déjà réalisé un fuzzer (Darko) et, selon eux, l'ont utilisé avec succès pour fuzzer des appareils embarqués.  Pour plus d'informations, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Digging Deep: Find 0days in Embedded Systems with Code Coverage Guided Fuzzing</a> . <br><br>  <u>Modifications basées sur les capacités matérielles du processeur</u> <br><br>  En ce qui concerne les modifications AFL avec prise en charge des capacités matérielles du processeur, cela indique principalement la possibilité de fuzzing le code du noyau, et deuxièmement, une vitesse de fuzzing plus élevée pour les applications sans code source. <br><br>  Et, bien sûr, nous parlons tout d'abord de capacités matérielles du processeur comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel PT</a> (Processor Tracing).  Qui est disponible à partir de la 6ème génération de processeurs (c'est-à-dire vers 2015).  Naturellement, pour utiliser les fuzzers suivants, vous aurez besoin d'un matériel avec le support Intel PT approprié. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinAFL-IntelPT</a> est une modification WinAFL tierce dans laquelle la technologie Intel PT est déjà utilisée à la place de DynamoRIO. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kAFL</a> est un développement académique visant à résoudre le problème guidé par la couverture pour le phasing du noyau d'une manière indépendante du système d'exploitation.  Ce qui est résolu en utilisant l'hyperviseur et la technologie Intel PT.  Vous pouvez en savoir plus sur leur livre blanc <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«kAFL: Fuzzing de rétroaction assistée par matériel pour les noyaux OS»</a> . </li></ul><br><h1>  Conclusion </h1><br>  Comme vous l'avez peut-être remarqué, ce sujet se développe activement.  En même temps, il y a beaucoup d'espace pour la créativité pour créer une nouvelle modification intéressante et utile d'AFL. <br><br>  Merci pour votre attention et votre fuzzing réussi! <br><br>  <b>Co-auteur:</b> Nikita Knizhov <br><br>  <i>PS Merci à toute l'équipe du centre de recherche pour leur aide dans la préparation de ce matériel, sans leur expérience et leur aide, il serait impossible de préparer une telle chose.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435644/">https://habr.com/ru/post/fr435644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435630/index.html">Réseau IB dans le cloud: 5 tendances de 2019</a></li>
<li><a href="../fr435636/index.html">Comment apprendre avec l'apprentissage automatique par des experts de Dota 2</a></li>
<li><a href="../fr435638/index.html">A propos du bonheur des développeurs et où le trouver</a></li>
<li><a href="../fr435640/index.html">Le condensé des événements pour les professionnels des RH dans le domaine des TI pour janvier 2019</a></li>
<li><a href="../fr435642/index.html">Pentax Auto 110: "dans quel poing est l'appareil photo?"</a></li>
<li><a href="../fr435646/index.html">NB-IoT, Internet des objets à bande étroite. Informations générales, caractéristiques technologiques</a></li>
<li><a href="../fr435648/index.html">Bot génère des tutoriels à partir d'articles de Wikipedia</a></li>
<li><a href="../fr435650/index.html">Comment intégrer une bibliothèque C dans un framework Swift</a></li>
<li><a href="../fr435652/index.html">Comment ne pas mots de passe dans les scripts Python</a></li>
<li><a href="../fr435654/index.html">Pièges des propriétés CSS personnalisées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>