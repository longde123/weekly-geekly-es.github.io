<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏾 🛡️ 👂 Boost.Spirit，或将“ Spirituality”添加到列表过滤器 😬 💺 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 我仍然是ISPsystem开发人员，我的名字仍然是Dmitry Smirnov。 在过去（相当长的一段时间）里，我无法决定下一个出版物的主题，因为在过去几个月与Boost.Asio合作的过程中积累了很多材料。 甚至在抛硬币似乎更容易的那一刻，一项任务也改变了一切。 有必要开发一种工具，使前端...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Boost.Spirit，或将“ Spirituality”添加到列表过滤器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/472004/"><p><img src="https://habrastorage.org/webt/qv/yu/6-/qvyu6-kaqci3ha5ivctj0nvbwco.png" alt="图片"></p><br><p> 大家好 我仍然是ISPsystem开发人员，我的名字仍然是Dmitry Smirnov。 在过去（相当长的一段时间）里，我无法决定下一个出版物的主题，因为在过去几个月与Boost.Asio合作的过程中积累了很多材料。 甚至在抛硬币似乎更容易的那一刻，一项任务也改变了一切。 有必要开发一种工具，使前端可以过滤请求列表中的数据。 来自后端的列表本身是一个普通的json_array。 欢迎来到凯特，最近几天都有跌宕起伏。 </p><a name="habracut"></a><br><h3 id="diskleymer"> 免责声明 </h3><br><p> 我必须马上说，作者上一次“感觉”十年前的上下文无关语法。 那时，它似乎是一种相当含糊且不必要的工具，但在解决问题的那一天，我就了解了Boost.Spirit库。 </p><br><h3 id="zadacha"> 挑战赛 </h3><br><p> 需要进行如下查询： </p><br><pre><code class="cpp hljs">(string_field CP value AND int_field NOT LT <span class="hljs-number"><span class="hljs-number">150</span></span>) OR bool_field EQ <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p> 进入某种结构，该结构将检查json对象并报告其是否满足要求。 </p><br><h3 id="pervye-shagi"> 第一步 </h3><br><p> 首先，您需要确定未来过滤器的接口。 必须从数组中删除不必要的对象，因此必须将其与STL算法结合使用，尤其是std :: remove_if。 </p><br><p> 函子将是完美的，它将直接根据前端的请求进行构建。 由于该项目使用nlohmann :: json，因此设计将非常优雅： </p><br><pre> <code class="cpp hljs">filter = <span class="hljs-string"><span class="hljs-string">"(string_field CP value AND int_field NOT LT 150) OR bool_field EQ true"</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end());</code> </pre> <br><p> 为了方便使用过滤器，我选择将条件拆分为二叉树。 最低顶点应包含比较运算符，但其余顶点应为逻辑运算符。 这是上面的过滤器在爆炸状态下的外观： </p><br><p><img src="https://habrastorage.org/webt/if/yc/zk/ifyczkjiznmiebrxvof3oxgnur4.jpeg" alt="筛选树"></p><br><p> 结果是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AST的</a>一种形式，如果可以这样称呼的话。 既然即将出现的逻辑图景已经成形，那么最有趣，最可怕的时刻已经来临。 这必须写在...关于精神... </p><br><h3 id="znakomstvo"> 熟人 </h3><br><p> 最困难的问题出现了：从哪里开始？ 与Asio不同，阅读Spirit标头并没有给出任何明确的线索，换句话说，存在“某种魔术”。 随后，对boost官方文档中的示例进行了研究，并研究了网络上的各种示例，经过一段时间后，它们不仅取得了成果，而且使解决方案尽可能接近我的需求： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AST计算器</a> </p><br><p> 让我们看一下示例中显示的语法： </p><br><div class="spoiler">  <b class="spoiler_title">语法计算器</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArithmeticGrammar1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, ASTNodePtr(), qi::space_type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Iterator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator; ArithmeticGrammar1() : ArithmeticGrammar1::base_type(start) { start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1]; factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)]; group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; start &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator, ASTNodePtr(), qi::space_type&gt; start, group, product, factor; };</code> </pre> </div></div><br><p> 语法是从基本qi ::语法继承的。  <em>ASTNodePtr（）</em>不是一个显而易见的方法，但是将预期结果的对象传递到语法对象中的方法非常方便。 </p><br><div class="spoiler">  <b class="spoiler_title">AST节点计算器</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASTNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ASTNode() {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ASTNodePtr = ASTNode*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OperatorNode</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ASTNode { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OperatorNode(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASTNodePtr &amp;right) : left(left) , right(right) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() + right-&gt;evaluate(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Operator == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;evaluate() * right-&gt;evaluate(); } ~OperatorNode() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> right; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ASTNodePtr left, right; <span class="hljs-comment"><span class="hljs-comment">//  }; class ConstantNode : public ASTNode { public: ConstantNode(double value) : value(value) {} double evaluate() { return value; } private: double value; };</span></span></code> </pre> </div></div><br><p> 使用Boost.Phoenix库，您可以在解析期间从一个或多个非终端创建一个现成的AST节点，并直接写入结果。 让我们仔细看一下计算器的组成： </p><br><pre> <code class="cpp hljs">start = (product &gt;&gt; <span class="hljs-string"><span class="hljs-string">'+'</span></span> &gt;&gt; start)[qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'+'</span></span>&gt;&gt; (qi::_1, qi::_2)] | product[qi::_val = qi::_1];</code> </pre> <br><p>  start-开始分析句子。 起点。 它可以通过乘积与开始之和表示，也可以通过乘积来表示。 </p><br><p> 注意每个表达式的方括号中的操作。 如果解析成功，并且所有内容都匹配，则应执行此操作。  <em>qi :: _ val</em>实际上是<em>增强::精神:: qi :: _ val</em>是一个占位符。 在其帮助下，答案将记录在结果中。 在启动的情况下，这将是一个OperatorNode对象，其第一个参数将是解析乘积的结果，第二个参数是解析开始的结果。 </p><br><p> 我们进一步看。 假设我们遇到第二种选择，开始不是一个和，而是一个乘积。 他如何表达？ </p><br><pre> <code class="cpp hljs">product = (factor &gt;&gt; <span class="hljs-string"><span class="hljs-string">'*'</span></span> &gt;&gt; product) [qi::_val = phx::new_&lt;OperatorNode&lt;<span class="hljs-string"><span class="hljs-string">'*'</span></span>&gt;&gt; (qi::_1, qi::_2)] | factor[qi::_val = qi::_1];</code> </pre> <br><p> 重复前一张图片，差异最小。 再次遇到某种表达式，再次在结果中写入OperatorNode对象，或者只是某种因数。 让我们看看。 </p><br><pre> <code class="cpp hljs">factor = group[qi::_val = qi::_1] | qi::int_[qi::_val = phx::new_&lt;ConstantNode&gt;(qi::_1)];</code> </pre> <br><p> 当我们沿着最短的路径前进时，我们假设遇到了int。 现在，如果我们用伪代码描述前面的所有步骤，我们将得到如下扩展形式： </p><br><pre> <code class="cpp hljs">factor1 = ConstantNode(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,    factor2 = ConstantNode(3) product = OperatorNode&lt;'*'&gt;(factor1, factor2) start = product</span></span></code> </pre> <br><p> 从顶部开始的每个节点（最低的节点除外，此处本质上是整数）通过后续节点表示。 唯一调用根元素上的validate <em>（）</em>方法解决了整个问题，太好了！ </p><br><p> 然后<em>qi :: space_type</em>引起您的注意-此参数是解析时忽略的元素列表。 这仍然会在我身上发挥作用:-)。 </p><br><p> 此处引人注目的是通过简单地通过乘积（*）表示非结束起始（仅包含+）来优先于乘法进行加法的方法。 在我的语法变体中，由于确定“与”将优先于“或”，因此我只在正确的位置替换所需的逻辑运算符。 如果很难在编写数学运算符时犯错误，那么文本逻辑运算符就是一个完全不同的故事。 希望解决至少部分可能的问题，例如寄存器。 为此，Spirit具有内置类型<em>qi :: no_case</em> </p><br><p> 此外，除了数字以外，我还需要这些字段的名称，因此我们添加了相应的非终结符，而不是内置的<em>qi :: int_</em> spirit： </p><br><pre> <code class="cpp hljs">field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>);</code> </pre> <br><p> 我们在这里得到了这样一个简单的表达式（到目前为止还没有语义运算）： </p><br><pre> <code class="plaintext hljs">start = product &gt;&gt; qi::no_case["OR"] &gt;&gt; start | product; product = factor &gt;&gt; qi::no_case["AND"] &gt;&gt; product | factor; factor = group | field; group %= '(' &gt;&gt; start &gt;&gt; ')';</code> </pre> <br><p> 现在，一切就绪，可以解析最简单的句子<em>“ field And field2”</em> 。 我们开始了，……什么都没有。 </p><br><p> 问题出在一个意想不到的地方： <em>qi :: space_type</em>不仅会忽略空格， <em>还会</em>在解析之前将其从句子中删除，并且初始过滤器表达式已经以以下形式解析： </p><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"fieldAndfield2"</span></span> \\        ,    <span class="hljs-string"><span class="hljs-string">"(5 * 5) + 11 "</span></span> \\  <span class="hljs-string"><span class="hljs-string">"(5*5)+11"</span></span></code> </pre> <br><p> 这仅仅是一个领域。 因此，您需要一些队长： </p><br><pre> <code class="cpp hljs">skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . ,    ,   ,  ,  C++ . start = product &gt;&gt; skipper &gt;&gt; qi::no_case["OR"] &gt;&gt; skipper &gt;&gt; start | product; ...</span></span></code> </pre> <br><p> 在分析完字段之后，就可以学习如何从表达式中获取值，并了解如何根据该值对字段进行验证。 可以通过以下操作来表示所有比较选项： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operator</span></span></span><span class="hljs-class"> {</span></span> EQ, <span class="hljs-comment"><span class="hljs-comment">//  LT, //  GT, //  CP //  (  ) }; unary = qi::no_case["NOT"]; // ,         </span></span></code> </pre> <br><p> 值本身以这样的非终结符表示： </p><br><pre> <code class="cpp hljs">value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. "</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>);</code> </pre> <br><p> 现在谈到这种获取价值的方法所带来的问题。  Spirit将以<em>boost :: variant &lt;int，double，bool，std :: string&gt;</em>的形式返回它，并且当需要将其与某些数据进行比较时，将需要一些技巧来获取所需类型的值。 这是我来到的选项： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = boost::variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueGetter</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::static_visitor&lt;Json&gt; { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-function">Json </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } };</code> </pre> <br><p> 为什么吸气剂会返回Json对象？ 因此，当在过滤过程中比较值时，我将避免必须弄清楚比较所经历的数据类型，而将所有工作留给json库。 </p><br><p> 终点线。 匹配者本人的描述。 我们将使用与计算器相同的示例。 首先，我们需要一个抽象，并将其传递到语法中，Spirit会用我们将其填充： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractMatcher() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       }; using MatcherPtr = std::shared_ptr&lt;AbstractMatcher&gt;;</span></span></code> </pre> <br><p> 其他逻辑节点是主要过滤器节点： </p><br><div class="spoiler">  <b class="spoiler_title">逻辑节点</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logic</span></span></span><span class="hljs-class"> {</span></span> AND, OR }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Logic Operator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogicNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogicNode(MatcherPtr &amp;left, MatcherPtr &amp;right) : m_left(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(left)) , m_right(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(right)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Operator) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::AND: m_evaluator = &amp;LogicNode::And; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Logic::OR: m_evaluator = &amp;LogicNode::Or; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, object); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MatcherPtr m_left; MatcherPtr m_right; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(LogicNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">And</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) &amp;&amp; m_right-&gt;evaluate(object); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Or</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_left-&gt;evaluate(object) || m_right-&gt;evaluate(object); } };</code> </pre> </div></div><br><p> 最后，最底层的节点 </p><br><div class="spoiler">  <b class="spoiler_title">价值比较</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractMatcher { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ObjectNode(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> field, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValueType &amp;value, boost::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; &amp;unary, Operator oper) : m_field(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(field)) , m_json_value(boost::apply_visitor(ValueGetter(), value)) , m_reject(unary.has_value()) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (oper) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::EQ: m_evaluator = &amp;ObjectNode::Equal; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LT: m_evaluator = &amp;ObjectNode::LesserThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::GT: m_evaluator = &amp;ObjectNode::GreaterThan; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::CP: m_evaluator = &amp;ObjectNode::Substr; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;object)</span></span></span><span class="hljs-function"> final </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;value = object.at(m_field); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke(m_evaluator, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_reject ? !result : result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EvaluateType = <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(ObjectNode::*)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json &amp;); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_field; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Json m_json_value; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_reject; EvaluateType m_evaluator = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json == m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LesserThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &lt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json &gt; m_json_value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Substr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Json &amp;json)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Str(json).find(Str(m_json_value)) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos; } };</code> </pre> </div></div><br><p> 剩下的只是将它们放在一起： </p><br><div class="spoiler">  <b class="spoiler_title">杰森过滤器</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonFilterGrammar</span></span></span><span class="hljs-class"> :</span></span> qi::grammar&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator, MatcherPtr()&gt; { JsonFilterGrammar() : JsonFilterGrammar::base_type(expression) { skipper = +qi::lit(<span class="hljs-string"><span class="hljs-string">' '</span></span>); unary = qi::no_case[<span class="hljs-string"><span class="hljs-string">"NOT"</span></span>]; compare.add (<span class="hljs-string"><span class="hljs-string">"eq"</span></span>, Operator::EQ) (<span class="hljs-string"><span class="hljs-string">"lt"</span></span>, Operator::LT) (<span class="hljs-string"><span class="hljs-string">"gt"</span></span>, Operator::GT) (<span class="hljs-string"><span class="hljs-string">"cp"</span></span>, Operator::CP); expression = (product &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"OR"</span></span>] &gt;&gt; skipper &gt;&gt; expression) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::OR&gt;&gt;()(qi::_1, qi::_2)] | product[qi::_val = qi::_1]; product = (term &gt;&gt; skipper &gt;&gt; qi::no_case[<span class="hljs-string"><span class="hljs-string">"AND"</span></span>] &gt;&gt; skipper &gt;&gt; product) [qi::_val = make_shared_&lt;LogicNode&lt;Logic::AND&gt;&gt;()(qi::_1, qi::_2)]| term[qi::_val = qi::_1]; term = group[qi::_val = qi::_1] | (field &gt;&gt; -(skipper &gt;&gt; unary)&gt;&gt; skipper &gt;&gt; qi::no_case[compare] &gt;&gt; skipper &gt;&gt; value) [qi::_val = make_shared_&lt;ObjectNode&gt;()(qi::_1, qi::_4, qi::_2, qi::_3)]; field = qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_"</span></span>) &gt;&gt; *qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z_0-9"</span></span>); value = qi::double_ | qi::int_ | qi::bool_ | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>) &gt;&gt; +qi::char_(<span class="hljs-string"><span class="hljs-string">"a-zA-Z0-9_. \u20BD€$¥-"</span></span>) &gt;&gt; qi::lit(<span class="hljs-string"><span class="hljs-string">"'"</span></span>); group %= <span class="hljs-string"><span class="hljs-string">'('</span></span> &gt;&gt; expression &gt;&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span>; } qi::rule&lt;Iterator&gt; skipper; qi::rule&lt;Iterator, MatcherPtr()&gt; product, term, expression, group; qi::rule&lt;Iterator, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()&gt; field, unary, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; qi::rule&lt;Iterator, ValueType()&gt; value; qi::symbols&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, Operator&gt; compare; <span class="hljs-comment"><span class="hljs-comment">//      enum };</span></span></code> </pre> </div></div><br><p> 仅此而已。 现在，获取完成的过滤器已成为相当简单的操作： </p><br><pre> <code class="cpp hljs">MatcherPtr matcher; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; JsonFilterGrammar grammar; qi::parse(filter.begin(), filter.end(), grammar, matcher); <span class="hljs-comment"><span class="hljs-comment">//     matcher   .</span></span></code> </pre> <br><p> 我将省略将语法包装在函子中的过程（我认为这对任何人都不会很有趣）。 我们将使用最简单的示例来更好地考虑实际使用的工具： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filter = <span class="hljs-string"><span class="hljs-string">"int not LT 15"</span></span>; Json json{ {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>}}, {{<span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}} }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; json.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(json.begin(), json.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::not_fn(JsonFilter{filter})), json.end()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json.dump() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p> 这是输出： </p><br><pre> <code class="bash hljs">[{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:10},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:11},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:9}] [{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:20},{<span class="hljs-string"><span class="hljs-string">"int"</span></span>:30}]</code> </pre> <br><p> 亲爱的读者，我希望您也对和我一样了解灵的基本知识感兴趣。 然后我留下来。 待会儿见。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472004/">https://habr.com/ru/post/zh-CN472004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471992/index.html">实施PEG的其余功能</a></li>
<li><a href="../zh-CN471994/index.html">在核心开发者Sprint上进行PEG工作</a></li>
<li><a href="../zh-CN471998/index.html">F＃10：列表</a></li>
<li><a href="../zh-CN472000/index.html">“社区制定标准至关重要”：Marchin Moskala关于Kotlin</a></li>
<li><a href="../zh-CN472002/index.html">在Gradle中重新包装包裹</a></li>
<li><a href="../zh-CN472006/index.html">为什么重新发明轮子很有用</a></li>
<li><a href="../zh-CN472012/index.html">半小时内看板</a></li>
<li><a href="../zh-CN472014/index.html">OTUS。 我们最喜欢的错误</a></li>
<li><a href="../zh-CN472018/index.html">Flask-Potion上的库控制系统，第0部分：准备所需的一切</a></li>
<li><a href="../zh-CN472020/index.html">十大：HolyJS 2019 Piter的最佳报告</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>