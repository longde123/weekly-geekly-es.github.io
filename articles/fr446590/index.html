<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♻️ 🧑🏿‍🤝‍🧑🏼 🤘 39 nouvelles fonctionnalités disponibles dans Java 12 👐🏽 🧓🏿 🧓🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Extrait d'une merveilleuse interview sur Habré: «Simon Ritter est une personne qui a travaillé sur Java depuis le tout début et continue de le faire e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>39 nouvelles fonctionnalités disponibles dans Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446590/"><blockquote>  Extrait d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">merveilleuse interview</a> sur Habré: «Simon Ritter est une personne qui a travaillé sur Java depuis le tout début et continue de le faire en tant que directeur technique adjoint d'Azul, une entreprise travaillant sur la machine virtuelle Jing Zing et l'un des meilleurs ramasseurs de déchets, C4 (Continuously Concurrent Compacting Collectionneur) » <br>  Vous trouverez ci-dessous une traduction de son article sur les nouvelles fonctionnalités de JDK 12 et certaines difficultés que vous pouvez rencontrer lors de la migration vers une nouvelle version. </blockquote><p> J'ai écrit plusieurs articles de blog qui répertorient toutes les modifications pour chacune des dernières versions de Java ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JDK 10</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JDK 11</a> ).  J'explorerai maintenant le côté obscur de JDK 12, en me concentrant sur certains des pièges qui peuvent poser des problèmes si vous souhaitez porter l'application sur cette version. </p><br><img src="https://habrastorage.org/webt/0e/rn/j0/0ernj0wwnqnwdejls6zvzjup5k8.png"><br><p><a name="habracut"></a>  JDK 12 possède le plus petit nombre de nouvelles fonctionnalités de toutes les versions Java à ce jour (j'en ai compté 109 dans JDK 10 et 90 dans JDK 11).  Ce n'est pas mal - en raison des cycles de publication, certaines versions contiendront plus de changements et d'autres moins. </p><br><p>  Je décomposerai de nouvelles fonctions en domaines logiques évidents: Java, bibliothèques, JVM et autres fonctions JDK. </p><br><h2>  Changements de langue </h2><br><p>  La fonction que je (et je suppose que beaucoup d'autres personnes) considéreront la plus visible dans JDK 12 est la nouvelle instruction switch ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 325</a> ).  Il s'agit également du premier changement de langue à utiliser comme fonction de «prévisualisation».  L'idée de «prévisualisation» a été introduite début 2018 dans le cadre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 12</a> .  Il s'agit essentiellement d'un moyen d'activer les versions bêta de nouvelles fonctionnalités à l'aide des options de ligne de commande.  En utilisant l'aperçu, il est toujours possible d'effectuer des modifications en fonction des commentaires des utilisateurs et, dans le pire des cas, de supprimer complètement une fonction si elle n'a pas été reçue correctement.  La clé des fonctions d'aperçu est qu'elles ne sont pas incluses dans la spécification Java SE.  À propos du nouveau commutateur, il y a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">très bonne traduction</a> sur Habré. <br>  Dans JDK 12, un commutateur est devenu une expression qui évalue son «contenu» pour produire un résultat.  J'expliquerai tout de suite que cela n'affecte pas la compatibilité descendante, vous n'avez donc pas besoin de changer de code utilisant Switch comme opérateur. </p><br><p>  Je vais utiliser l'exemple de JEP, car il est simple et clair: </p><br><div class="spoiler">  <b class="spoiler_title">Ancien interrupteur</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: numLetters = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: numLetters = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); }</code> </pre> </div></div><br><p>  Comme vous pouvez le voir, nous mappons le jour de la semaine au nom de la variable <code>day</code> , puis <code>numLetters</code> la valeur <code>numLetters</code> .  Maintenant que switch est un opérateur, nous pouvons effectuer l'affectation une fois (ce qui réduit considérablement la probabilité d'un code erroné) en utilisant le résultat de l'instruction switch: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY, SATURDAY -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY -&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); };</code> </pre> <br><p>  Vous remarquerez rapidement deux changements de syntaxe.  Les développeurs d'OpenJDK sont tombés sur une fonction de syntaxe peu connue appelée liste séparée par des virgules.  L'opérateur d'expression lambda <code>-&gt;</code> facilite également le retour de la valeur.  Vous pouvez toujours utiliser <code>break</code> avec une valeur si vous le voulez vraiment.  Il existe plusieurs autres détails sur cette fonctionnalité, mais il est probablement plus facile de lire JEP. </p><br><h2>  Bibliothèques </h2><br><p>  Il y a un changement que je trouve très utile.  Il en existe également plusieurs. </p><br><h3>  collecteur de départ </h3><br><p>  L'API Streams, comme d'habitude, a un nouveau collecteur, fourni par la classe utilitaire Collectors.  Un nouveau collecteur peut être obtenu en utilisant la méthode <code>teeing()</code> .  Le collecteur de départs prend trois arguments: deux collecteurs et une bifonction.  Pour comprendre le travail de ce collectionneur, je recommande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article sur Habré</a> . <br>  Pour comprendre comment il fait ça, j'ai dessiné un schéma: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/821/2db/503/8212db5034c04db49aed57dd44697b22.jpg" alt="image"><br><p>  Toutes les valeurs du flux d'entrée sont transmises à chaque collecteur.  Le résultat de chaque collecteur est transmis en tant qu'arguments à BiFunction pour générer le résultat final. </p><br><p>  Un exemple simple est le calcul de la valeur moyenne (oui, je sais qu'il existe déjà des collecteurs pour cela, comme <code>averagingInt()</code> , mais ceci est un exemple simple pour aider à comprendre le concept). </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Assume Collectors is statically imported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average = Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .collect(teeing( summingDouble(i -&gt; i), counting(), (sum, n) -&gt; sum / n) );</code> </pre> <br><p>  Le premier collecteur calcule la somme du flux d'entrée, et le second - le nombre d'éléments.  BiFunction divise la somme par le nombre d'éléments pour obtenir la valeur moyenne. </p><br><h3>  java.io </h3><br><p>  <code>InputStream skipNBytes(long n)</code> - ignore et supprime exactement n octets du flux d'entrée InputStream.  Si n est égal ou inférieur à zéro, les octets ne sont pas ignorés. </p><br><h3>  java.lang </h3><br><p>  Un nouveau package est apparu, java.lang.constant, qui fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie de l'API JVM constante, JEP 334</a> . </p><br><p>  Chaque fichier de classe Java possède un pool persistant qui stocke des opérandes pour les instructions de bytecode dans la classe.  Il est difficile pour les développeurs de manipuler les fichiers de classe en raison de problèmes de chargement des classes.  L'API JVM constante fournit des types de référence symboliques pour décrire chaque forme d'une constante (classe, constante chargeable, <code>MethodHandle</code> , constante <code>MethodHandle</code> , constante <code>MethodType</code> ). </p><br><p>  Il a également influencé plusieurs autres classes.  Toutes les classes suivantes ont désormais une méthode <code>describeConstable()</code> : </p><br><ul><li>  Classe </li><li>  Double </li><li>  Enum </li><li>  Flotter </li><li>  Entier </li><li>  Long </li><li>  String </li><li>  Methodhandle </li><li>  MethodType </li><li>  Varhandle </li></ul><br><p>  En tant que britannique, je trouve ça assez drôle.  Le terme Constable, <code>describeConstable</code> utilisé depuis le XIe siècle, et c'est ainsi que nous nous référons souvent aux policiers.  C'est aussi le nom du célèbre artiste du XVIIIe siècle, John Constable.  Cela me fait me demander si la méthode <code>describeTurner()</code> sera dans une future version.  Évidemment, dans ce cas, il s'agit d'une abréviation de la <code>Constant Table</code> , sans lien avec un avocat ou un paysagiste. </p><br><p>  Les classes suivantes incluent désormais la méthode <code>resolveConstantDesc()</code> : </p><br><ul><li>  Double </li><li>  Enum.EnumDesc </li><li>  Flotter </li><li>  Entier </li><li>  Long </li><li>  String </li></ul><br><h3>  java.lang.Character </h3><br><p>  Les classes internes ont été mises à jour pour inclure de nouveaux blocs Unicode.  J'aime toujours voir ce que les gens ont trouvé à ajouter à Unicode, voici quelques exemples: </p><br><ul><li>  Symboles d'échecs </li><li>  Numéros mayas </li><li>  Le sogdian est une langue iranienne orientale qui n'était plus utilisée au 11e siècle. </li><li>  Old Sogdian est une version plus ancienne (et, je suppose, encore plus limitée) de Sogdian </li></ul><br><h3>  java.lang.Class </h3><br><p>  <code>arrayType()</code> renvoie <code>Class</code> pour le type du tableau dont le type de composant est décrit par cette <code>Class</code> .  Cela peut être vérifié à l'aide de <code>jshell</code> : </p><br><pre> <code class="bash hljs">jshell&gt; (new String[2]).getClass().getName() <span class="hljs-variable"><span class="hljs-variable">$11</span></span> ==&gt; <span class="hljs-string"><span class="hljs-string">"[Ljava.lang.String;"</span></span> jshell&gt; (new String[2]).getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$12</span></span> ==&gt; class [[Ljava.lang.String; jshell&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$15</span></span> ==&gt; class [Ljava.lang.String;</code> </pre> <br><p>  Je ne suis pas tout à fait sûr de la signification de cette méthode, car elle ne fait qu'ajouter une <code>Class</code> au type que cette classe représente. </p><br><p>  <code>componentType()</code> , identique à <code>getComponentType()</code> .  La question se pose - pourquoi ajouter une méthode redondante? </p><br><p>  <code>descriptorString()</code> - renvoie à nouveau le même résultat que <code>getName()</code> .  Cependant, cela est nécessaire car <code>Class</code> implémente désormais l'interface <code>TypeDescriptor</code> associée à la nouvelle API JVM constante. </p><br><h3>  lava.lang.String </h3><br><p>  <code>indent()</code> - Ajoute une série d'espaces de début à une chaîne.  Si le paramètre est négatif, ce nombre d'espaces de tête sera supprimé (si possible). </p><br><p>  <code>transform()</code> - Applique la fonction fournie à une chaîne.  Le résultat peut ne pas être une chaîne. </p><br><h3>  java.lang.invoke </h3><br><p>  <code>VarHandle</code> maintenant <code>toString()</code> pour renvoyer une description compacte. </p><br><p>  <code>java.net.SecureCacheResponse</code> et <code>java.net.ssl.HttpsConnection</code> ont une nouvelle méthode, <code>getSSLSession()</code> qui renvoie <code>Optional</code> contenant la <code>SSLSession</code> utilisée dans la connexion. </p><br><h3>  java.nio.files </h3><br><p>  La classe <code>Files</code> possède une nouvelle méthode, <code>mismatch()</code> , qui recherche et renvoie la position du premier octet de non-concordance dans le contenu de deux fichiers, ou -1L s'il n'y a pas de non-concordance. </p><br><h3>  java.text </h3><br><p>  Il existe une nouvelle classe <code>CompactNumberFormat</code> .  Il s'agit d'une sous-classe de <code>NumberFormat</code> qui formate un nombre décimal sous forme compacte.  Un exemple de formulaire compact - <code>1M</code> au lieu de <code>1000000</code> , donc - nécessite deux au lieu de neuf caractères.  <code>NumberFormat</code> et <code>java.text.spi.NumberFormatProvider</code> ont été étendus pour inclure la nouvelle méthode <code>getCompactNumberInstance()</code> .  Il existe également une nouvelle énumération, <code>NumberFormatStyle</code> qui a deux significations: LONG et SHORT. </p><br><h3>  java.util.concurrent </h3><br><p>  CompletionStage comprend désormais plusieurs formulaires surchargés avec trois méthodes: </p><br><ul><li>  exceptionnellement asynchrone </li><li>  exceptionnellement </li><li>  exceptionnellementComposeAsync </li></ul><br><p>  Ces méthodes élargissent les possibilités de création d'un nouveau <code>CompletionStage</code> partir d'un existant, <code>CompletionStage</code> si l'actuel se termine par une exception.  Consultez la documentation de l'API pour plus de détails. </p><br><h3>  javax.crypto </h3><br><p>  La classe <code>Cipher</code> a une nouvelle <code>toString()</code> qui renvoie une chaîne contenant la transformation, le mode et le fournisseur <code>Cipher</code> . </p><br><h3>  javax.naming.ldap.spi </h3><br><p>  Il s'agit d'un nouveau package dans JDK 12 et il contient deux classes: <code>LdapDnsProvider</code> , qui est la classe de fournisseur pour les recherches DNS pendant les opérations LDAP, et <code>LdapDnsProviderResults</code> qui encapsule le résultat de la recherche DNS pour l'URL LDAP. </p><br><h3>  Swing </h3><br><p>  Swing est toujours en cours de mise à jour!  Oui, <code>filechooser.FileSystemView</code> dispose désormais d'une nouvelle méthode <code>getChooserShortcutPanelFiles()</code> .  Il renvoie un tableau de fichiers représentant les valeurs à afficher par défaut dans la barre de raccourcis de sélection de fichiers. </p><br><h2>  Modifications de la JVM </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 189: Shenandoah</a> : ramasseur d'ordures à faible pause </h3><br><p>  Shenandoah est un projet de recherche annoncé par Red Hat en 2014 qui se concentre sur les exigences des applications à faible latence pour la gestion de la mémoire dans la JVM.  Ses objectifs sont un temps de pause maximal de 1 à 10 ms pour un tas de plus de 20 Go ( <del>  il n'est donc pas destiné aux petites applications </del>  - comme l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un des développeurs de Shenandoah a répondu</a> , ce n'est pas le cas et il fait un excellent travail avec de petites applications).  Ce collecteur est conçu pour fonctionner en parallèle avec les threads d'application, évitez donc les problèmes que nous voyons dans la plupart des récupérateurs de place. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 344: Collections mixtes G1</a> </h3><br><p>  Cette modification vise à améliorer le comportement du collecteur G1 lorsqu'il atteint l'objectif de retard défini.  G1 divise l'espace de mémoire (ancien et ancien) en régions.  L'idée est que dans l'ancienne génération, vous n'avez pas besoin de collecter les déchets en une seule opération.  Lorsque G1 doit collecter des ordures, il sélectionne les régions qu'il définit.  C'est ce qu'on appelle un kit de collecte.  Avant JDK 12, lorsque les travaux ont commencé sur le plateau, tous les travaux devaient être achevés, essentiellement, comme une opération atomique.  Le problème était que, parfois, en raison de changements dans l'utilisation de l'espace de tas par l'application, l'ensemble de collecte s'avérait trop volumineux et prenait trop de temps à collecter, ce qui conduisait au fait que le temps de pause n'était pas atteint. </p><br><p>  Dans JDK 12, si G1 identifie cette situation, il interrompra la collecte de données à mi-chemin si cela n'affecte pas la capacité de l'application à continuer d'allouer de l'espace pour de nouveaux objets.  L'effet net de G1 sera meilleur lorsqu'un temps de pause court sera atteint. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 346: retourne rapidement la mémoire allouée inutilisée de G1</a> </h3><br><p>  Il s'agit d'une autre amélioration des performances pour G1, mais une autre est liée à la façon dont la JVM interagit avec le reste du système.  De toute évidence, la mémoire est requise pour le tas JVM et, au démarrage, il demande de la mémoire à l'allocateur de mémoire virtuelle du système d'exploitation.  Lorsque l'application démarre, il peut arriver que la quantité de mémoire requise pour le segment de mémoire diminue et qu'une partie de la mémoire allouée puisse être renvoyée au système d'exploitation pour être utilisée par d'autres applications. </p><br><p>  G1 le fait déjà, mais ne peut le faire qu'à deux endroits.  D'une part, lors d'une collection complète, et d'autre part, lors d'un des cycles parallèles.  G1 essaie de ne pas effectuer de collecte complète et avec une faible utilisation de la mémoire, il peut y avoir des périodes importantes entre les cycles de collecte.  Cela conduit au fait que G1 peut conserver une mémoire fixe pendant une longue période. </p><br><p>  Dans JDK 12, G1 essaiera périodiquement de continuer ou d'exécuter une boucle parallèle pendant que l'application est inactive pour déterminer l'utilisation globale du tas Java.  La mémoire inutilisée peut être retournée au système d'exploitation de manière plus rapide et prévisible. </p><br><p>  Le nouvel indicateur de ligne de commande <code>-XX:G1PeriodicGCInterval</code> peut être utilisé pour définir le nombre de millisecondes entre les vérifications. </p><br><p>  Cette fonctionnalité entraînera une utilisation plus conservatrice de la mémoire JVM pour les applications qui ont été inactives pendant de longues périodes. </p><br><h2>  Autres nouvelles fonctionnalités JDK </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 230: Kit de micro-analyse comparative</a> </h3><br><p>  Java Microbenchmarking Harness (JMH) a été développé par Alexey Shipilev lorsqu'il travaillait chez Oracle et fournit une plate-forme étendue pour développer des tests de performances pour les applications Java.  Alexey a fait un travail remarquable en aidant les gens à éviter de nombreuses erreurs simples qu'ils font en essayant d'analyser les performances des applications: échauffement, éviter les exceptions, etc. </p><br><p>  Maintenant, JMH peut être inclus dans OpenJDK.  Quiconque souhaite travailler sur le JDK lui-même et changer le code peut l'utiliser pour comparer les performances avant et après leurs modifications, ainsi que pour comparer les performances dans différentes versions.  Un certain nombre de tests sont inclus pour permettre les tests;  La conception de JMH est telle qu'il est facile d'ajouter de nouveaux tests là où cela est nécessaire. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 340: un port Aarch64, pas deux</a> </h3><br><p>  OpenJDK possède deux ports pour l'architecture Arm64, l'un fourni par Oracle et l'autre par Red Hat.  Comme cela n'était pas nécessaire et qu'Oracle a cessé de prendre en charge Arm pour ses binaires JDK, il a été décidé d'utiliser uniquement le port Red Hat, qui est toujours pris en charge et développé. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 341: archives CDS par défaut</a> </h3><br><p>  La classe de partage de données (CDS) était auparavant une fonctionnalité commerciale d'Oracle JDK.  Avec une transition récente effectuée dans JDK 11 pour éliminer toutes les différences fonctionnelles entre Oracle JDK et OpenJDK, il a été inclus dans OpenJDK. </p><br><p>  Pour utiliser CDS, vous avez besoin d'une archive créée pour les classes qui se chargent au démarrage de l'application.  JDK 12 pour les plates-formes 64 bits a désormais le fichier <code>classes.jsa</code> dans le répertoire <code>lib/server</code> .  Il s'agit de l'archive CDS pour les «classes par défaut».  Je suppose que cela signifie toutes les classes publiques dans les modules JDK;  Je n'ai pas trouvé de moyen de le déballer pour vérifier.  Étant donné que CDS est activé par défaut, ce qui équivaut à l'option <code>-Xshare:auto</code> sur la ligne de commande, les utilisateurs bénéficieront de temps de démarrage de l'application améliorés. </p><br><h2>  Conclusions </h2><br><p>  JDK 12 fournit un petit nombre de nouvelles fonctions et API, la <code>switch</code> étant la plus intéressante pour les développeurs.  Les utilisateurs de G1 apprécieront certainement les améliorations de performances. </p><br><p>  Avec la nouvelle version de la version, je conseillerais à tous les utilisateurs de tester leurs applications dans cette version.  Le suivi des modifications incrémentielles vous aidera à éviter les surprises si vous décidez de passer à la prochaine version du support à long terme. </p><br><p>  Nous avons des versions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JDK 12</a> gratuites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour Zulu Community Edition</a> pour vous aider avec vos tests.  Assurez-vous de les essayer. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446590/">https://habr.com/ru/post/fr446590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446576/index.html">Substitution à l'importation ou comment les hélicoptères russes ont fait quelque chose de mal</a></li>
<li><a href="../fr446578/index.html">Langage de programmation basé sur une carte postale</a></li>
<li><a href="../fr446582/index.html">Réflexions sur l'hébergement solaire pour les abeilles</a></li>
<li><a href="../fr446586/index.html">Paramètres réseau de FreeRadius via DHCP</a></li>
<li><a href="../fr446588/index.html">Vérification du code source de Roslyn</a></li>
<li><a href="../fr446592/index.html">Vérification du code source de Roslyn</a></li>
<li><a href="../fr446598/index.html">Recréation de polices CRT</a></li>
<li><a href="../fr446602/index.html">Transistor à effet de champ à courant continu maximal</a></li>
<li><a href="../fr446604/index.html">ESET: Nouveaux schémas de livraison de porte dérobée OceanLotus Cybergroup</a></li>
<li><a href="../fr446606/index.html">Vérifiez à quel point vous êtes bon en technologie additive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>