<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚ÄçüöÄ üóØÔ∏è üë©üèª‚Äçüé® Kami menggunakan otomatisasi dalam beberapa jam: TypeScript, Protractor, Jasmine ü¶Ä ü•á üíú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Nama saya Vitaliy Kotov, saya melakukan banyak pengujian otomasi dan saya menyukainya. Saya baru-baru ini berpartisipasi dalam sebuah p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menggunakan otomatisasi dalam beberapa jam: TypeScript, Protractor, Jasmine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451522/"> Halo, Habr! <br><br>  Nama saya Vitaliy Kotov, saya melakukan banyak pengujian otomasi dan saya menyukainya.  Saya baru-baru ini berpartisipasi dalam sebuah proyek untuk mengkonfigurasi otomatisasi dari awal pada tumpukan TypeScript + Protractor + Jasmine.  Bagi saya, tumpukan ini baru dan saya mencari informasi yang diperlukan di Internet. <br><br>  Saya berhasil menemukan manual yang paling berguna dan masuk akal hanya dalam bahasa Inggris.  Saya memutuskan bahwa dalam bahasa Rusia saya juga perlu melakukan ini.  Saya hanya akan memberi tahu Anda dasar-dasarnya: mengapa tumpukan itu, apa yang perlu Anda konfigurasi, dan seperti apa tes paling sederhana. <br><br>  Saya harus segera mengatakan bahwa saya jarang bekerja dengan NodeJS, npm, dan dengan JavaScript sisi server secara umum (terutama dengan TypeScript).  Jika Anda menemukan kesalahan dalam terminologi di suatu tempat atau beberapa keputusan saya dapat diperbaiki, saya akan senang mengetahuinya dalam komentar dari orang-orang yang lebih berpengalaman. <br><br>  Ngomong-ngomong, saya sudah memiliki artikel serupa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kami menggunakan otomatisasi dalam beberapa jam: PHPUnit, Selenium, Composer"</a> . <br><br><img src="https://habrastorage.org/webt/mn/rc/5t/mnrc5tzbyn3hmecryv5sj-1nuae.png"><br><a name="habracut"></a><br><h3>  Tantangan </h3><br>  Pertama-tama, mari kita cari tahu masalah apa yang sedang kita pecahkan.  Kami memiliki aplikasi web yang ditulis menggunakan AngularJS.  Ini adalah kerangka kerja JavaScript berdasarkan proyek web mana yang sering ditulis. <br><br>  Dalam artikel ini, kami tidak akan mempertimbangkan pro dan kontra dari proyek AngularJS.  Hanya beberapa kata tentang fitur proyek semacam itu dalam hal menulis tes e2e untuk mereka. <br><br>  Aspek yang agak penting dari otomatisasi pengujian adalah bekerja dengan elemen halaman, yang terjadi dengan bantuan pencari lokasi.  Locator adalah garis yang disusun berdasarkan aturan tertentu dan mengidentifikasi elemen UI: satu atau lebih. <br><br>  Untuk web, CSS dan Xpath paling sering digunakan.  Terkadang, jika ada elemen dengan ID unik di halaman tersebut, Anda dapat mencarinya.  Namun, bagi saya sepertinya WebDriver masih mengubah ID ini menjadi pencari lokasi CSS pada akhirnya dan sudah bekerja dengannya. <br><br>  Jika kita melihat kode HTML beberapa proyek AngularJS, kita akan melihat banyak atribut untuk elemen yang tidak ada dalam HTML klasik: <br><br><img src="https://habrastorage.org/webt/zg/r3/et/zgr3etoo6q7qeycuobh1tl9g1f4.png"><br><br>  Kode diambil dari halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo-busur derajat</a> . <br><br>  Semua atribut yang dimulai dengan ng- * digunakan oleh AngularJS untuk bekerja dengan UI.  Situasi yang cukup khas adalah ketika elemen selain atribut kontrol ini tidak memiliki yang lain, yang memperumit proses kompilasi pencari kualitas. <br><br>  Mereka yang telah melakukan banyak otomasi tahu tentang nilai UI semacam itu yang dapat dengan mudah ditemukan oleh pencari.  Bagaimanapun, ini jarang terjadi untuk proyek-proyek besar.  :) <br><br>  Sebenarnya, untuk proyek semacam itu, kita juga perlu mengonfigurasi otomatisasi uji.  Ayo pergi! <br><br><h3>  Apa itu apa? </h3><br>  Pertama-tama, mari kita cari tahu mengapa setiap komponen tumpukan kita diperlukan. <br><br>  <b>Busur derajat</b> adalah kerangka uji yang didasarkan pada WebDriverJS.  Dialah yang akan meluncurkan browser kami, membuat mereka membuka halaman yang diperlukan dan berinteraksi dengan elemen yang diperlukan. <br><br>  Kerangka kerja ini secara khusus dirancang untuk proyek AngularJS.  Ini memberikan cara tambahan untuk menentukan lokasi: <br><br><pre><code class="javascript hljs">element(by.model(<span class="hljs-string"><span class="hljs-string">'first'</span></span>)); element(by.binding(<span class="hljs-string"><span class="hljs-string">'latest'</span></span>)); element(by.repeater(<span class="hljs-string"><span class="hljs-string">'some'</span></span>));</code> </pre> <br>  Daftar lengkap dapat ditemukan di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual</a> . <br><br>  Metode-metode ini menyederhanakan pembuatan dan dukungan pelacak pada suatu proyek.  Namun, Anda harus memahami bahwa "di bawah tenda" semua ini dalam kasus apa pun dikonversi ke css.  Faktanya adalah bahwa protokol W3C, atas dasar di mana interaksi di WebDriver berlangsung, hanya dapat bekerja dengan satu set locator yang terbatas.  Daftar ini dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">w3.org</a> . <br><br>  <b>TypeScript</b> adalah bahasa pemrograman yang dibuat oleh Microsoft.  TypeScript berbeda dari JavaScript dalam kemampuan mengetik variabel, dukungan untuk penggunaan kelas penuh dan kemampuan untuk menghubungkan modul. <br><br>  Ditulis dalam kode TS untuk bekerja dengan mesin V8 diterjemahkan ke dalam kode JS, yang sudah dieksekusi.  Selama transformasi ini, kode diperiksa untuk kepatuhan.  Sebagai contoh, itu tidak "mengkompilasi" jika, bukannya int, string secara eksplisit diteruskan ke fungsi di suatu tempat. <br><br>  <b>Jasmine</b> adalah kerangka kerja untuk menguji kode JavaScript.  Bahkan, itu berkat dia bahwa kode JS kita berubah menjadi apa yang kita sebut tes.  Dia mengelola tes ini. <br><br>  Di bawah ini kita melihat kemampuannya. <br><br><h3>  Pengaturan perakitan dan proyek </h3><br>  Nah, kami memutuskan satu set kerangka kerja, sekarang mari kita selesaikan semua ini. <br><br>  Untuk bekerja dengan kode, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visual Studio Code</a> dari Microsoft.  Meskipun banyak yang menulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebStorm</a> atau bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intellij Idea</a> dari JetBrains. <br><br>  Saya sudah menginstal NodeJS (v11.6.0) dan NPM (6.9.0).  Jika Anda tidak memilikinya, ini bukan masalah, menginstalnya tidak akan sulit.  Semuanya dijelaskan secara cukup rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi</a> . <br><br>  Benang dapat digunakan sebagai pengganti NPM, meskipun ini tidak penting untuk proyek kecil. <br><br>  Dalam IDE kami, kami membuat proyek baru.  Kami membuat package.json di root proyek - di dalamnya kami akan menjelaskan semua paket yang kami butuhkan untuk proyek tersebut. <br><br>  Anda dapat membuatnya menggunakan perintah <i>npm init</i> .  Atau Anda cukup menyalin konten ke file. <br><br>  Awalnya, <b>package.json</b> terlihat seperti ini: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br>  Setelah itu kami menjalankan perintah <i>install npm</i> untuk menginstal semua modul yang diperlukan dan dependensinya (yah, Anda ingat gambar yang sangat jelas tentang sesuatu yang lebih berat daripada black hole ...) <br><br>  Sebagai hasilnya, kita harus memiliki direktori node_modules.  Jika dia muncul, maka semuanya berjalan sesuai rencana.  Jika tidak, ada baiknya melihat ke hasil eksekusi perintah, biasanya semuanya dijelaskan secara cukup rinci di sana. <br><br><h3>  TypeScript dan konfigurasinya </h3><br>  Untuk menginstal TypeScript, kita perlu npm: <br><br><pre> <code class="plaintext hljs">npm install -g typescript</code> </pre><br>  Pastikan sudah terpasang: <br><br><pre> <code class="plaintext hljs">$ tsc -v Version 3.4.1</code> </pre><br>  Segalanya tampak teratur. <br><br>  Sekarang kita perlu membuat konfigurasi untuk bekerja dengan TS.  Itu juga harus di root proyek dan disebut <b>tsconfig.json</b> <br><br>  Isinya akan seperti ini: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [<span class="hljs-string"><span class="hljs-string">"es6"</span></span>], <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"outDir"</span></span> : <span class="hljs-string"><span class="hljs-string">"output_js"</span></span>, <span class="hljs-string"><span class="hljs-string">"types"</span></span> : [<span class="hljs-string"><span class="hljs-string">"jasmine"</span></span>, <span class="hljs-string"><span class="hljs-string">"node"</span></span>] }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"node_modules/*"</span></span> ] }</code> </pre><br>  Singkatnya, kami menentukan yang berikut ini dalam konfigurasi ini: <br><br><ul><li>  Di mana direktori untuk meletakkan JS-code terakhir (dalam kasus kami ini adalah output_js) </li><li>  Aktifkan mode ketat </li><li>  Diindikasikan dengan kerangka kerja mana kami bekerja </li><li>  Node_modules dikecualikan dari kompilasi </li></ul><br>  TS memiliki beragam pengaturan.  Ini cukup untuk proyek kami.  Anda dapat mempelajari lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di typescriptlang.org</a> . <br><br>  Sekarang mari kita lihat bagaimana perintah <i>tsc bekerja</i> , yang akan mengubah kode TS kita menjadi kode JS.  Untuk melakukan ini, buat file check_tsc.ts sederhana dengan konten berikut: <br><br><pre> <code class="javascript hljs">saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br>  Dan kemudian jalankan perintah <i>tsc</i> (untuk ini Anda harus berada di dalam direktori proyek). <br><br>  Kita akan melihat bahwa kita memiliki direktori output_js dan file js yang serupa dengan konten berikut telah muncul di dalamnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br>  File ini sudah dapat diluncurkan menggunakan perintah node: <br><br><pre> <code class="plaintext hljs">$ node output_js/check_tsc.js Hello, world!</code> </pre><br>  Jadi, kami menulis program TypeScipt pertama kami, selamat.  Mari kita menulis tes sekarang.  :) <br><br><h3>  Konfigurasi busur derajat </h3><br>  Untuk busur derajat kita juga membutuhkan konfigurasi.  Tapi itu tidak akan lagi dalam bentuk json, tetapi dalam bentuk file-ts.  Sebut saja config.ts dan tulis kode berikut di sana: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Config } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: Config = { <span class="hljs-attr"><span class="hljs-attr">seleniumAddress</span></span>: <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:4444/wd/hub"</span></span>, <span class="hljs-attr"><span class="hljs-attr">SELENIUM_PROMISE_MANAGER</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">capabilities</span></span>: { <span class="hljs-attr"><span class="hljs-attr">browserName</span></span>: <span class="hljs-string"><span class="hljs-string">"chrome"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*chromeOptions: { args: [ "--headless", "--window-size=800,600" ] }*/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">specs</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Tests/*Test.js"</span></span>, ] };</code> </pre><br>  Dalam file ini kami menentukan yang berikut: <br><br>  Pertama, jalur ke server Selenium yang sedang berjalan.  Ini cukup sederhana untuk dijalankan, Anda hanya perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh file jar Standalone Server</a> dan driver yang diperlukan (misalnya, driver chrome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk browser Chrome</a> ).  Selanjutnya, tulis perintah berikut: <br><br><pre> <code class="plaintext hljs">java -jar -Dwebdriver.chrome.driver=/path/to/chromedriver /path/to/selenium-server-standalone.jar</code> </pre><br>  Sebagai hasilnya, kita harus melihat kesimpulan berikut: <br><br><pre> <code class="plaintext hljs">23:52:41.691 INFO [GridLauncherV3.launch] - Selenium build info: version: '3.11.0', revision: 'e59cfb3' 23:52:41.693 INFO [GridLauncherV3$1.launch] - Launching a standalone Selenium Server on port 4444 2019-05-02 23:52:41.860:INFO::main: Logging initialized @555ms to org.seleniumhq.jetty9.util.log.StdErrLog 23:52:42.149 INFO [SeleniumServer.boot] - Welcome to Selenium for Workgroups.... 23:52:42.149 INFO [SeleniumServer.boot] - Selenium Server is up and running on port 4444</code> </pre><br>  Port 4444 default.  Itu dapat diatur menggunakan parameter -port atau melalui parameter konfigurasi "seleniumArgs" =&gt; "-port". <br><br>  Jika Anda ingin lebih mudah dan lebih cepat: Anda dapat mengunduh npm paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webdriver-manager</a> . <br><br>  Dan kemudian mengelola server menggunakan perintah start, shutdown, dan sebagainya.  Tidak banyak perbedaan, hanya saja saya lebih terbiasa bekerja dengan file jar.  :) <br><br>  <b>Kedua</b> , kami mengindikasikan bahwa kami tidak ingin menggunakan manajer Janji.  Lebih lanjut tentang ini nanti. <br><br>  <b>Ketiga</b> , kami menentukan kemampuan untuk browser kami.  Saya berkomentar sebagian, misalnya, bahwa kita dapat dengan mudah meluncurkan browser dalam mode tanpa kepala.  Ini adalah fitur keren, tetapi itu tidak akan memungkinkan Anda untuk mengamati tes kami secara visual.  Sementara itu, kami baru belajar - saya ingin.  :) <br><br>  <b>Keempat</b> , kami menetapkan topeng untuk spesifikasi (tes).  Segala sesuatu yang ada di folder Tes dan berakhir dengan Test.js.  Kenapa di js, bukan ts?  Ini karena pada akhirnya, Node akan bekerja secara khusus dengan file JS, dan bukan dengan file TS.  Penting untuk tidak bingung, terutama pada awal pekerjaan. <br><br>  Sekarang buat folder Tes dan tulis tes pertama.  Dia akan melakukan hal berikut: <br><br><ul><li>  Menonaktifkan memeriksa bahwa ini adalah halaman Angular.  Tanpa ini, kami mendapatkan pesan kesalahan ini: Kesalahan saat menjalankan testForAngular.  Tentu saja, untuk halaman Angular cek ini tidak perlu dimatikan. </li><li>  Pergi ke halaman Google. </li><li>  Periksa apakah ada bidang input teks. </li><li>  Masukkan teks "busur derajat". </li><li>  Klik tombol kirim (ini memiliki pelacak yang agak rumit, karena ada dua tombol dan yang pertama tidak terlihat). </li><li>  Diharapkan bahwa URL akan berisi kata "busur derajat" - ini berarti bahwa kami melakukan segalanya dengan benar dan pencarian dimulai. </li></ul><br>  Ini kode yang saya dapat: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { browser, by, element, protractor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Search'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Open google and find a text'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//       let EC = protractor.ExpectedConditions; //    AngularJS await browser.waitForAngularEnabled(false); //   Google await browser.get('https://www.google.com/'); //    css = input[role='combobox'] let input_button = element(by.css("input[role='combobox']")); //     ( presenceOf) await browser.wait(EC.presenceOf(input_button), 5000); //     ‚Äúprotractor‚Äù await input_button.sendKeys("protractor"); //      css let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //      ( ,     input-,   ) await browser.wait(EC.presenceOf(submit_button), 5000); //     await submit_button.click(); // ,  URL    'protractor' await browser.wait(EC.urlContains('protractor'), 5000); }); });</span></span></code> </pre><br>  Dalam kode, kita melihat bahwa semuanya dimulai dengan fungsi uraikan ().  Dia datang kepada kami dari kerangka Jasmine.  Ini adalah pembungkus untuk skrip kami.  Di dalamnya, mungkin ada fungsi beforeAll () dan beforeEach () untuk melakukan manipulasi sebelum semua tes dan sebelum setiap tes.  Sebanyak fungsi yang ada () sebenarnya adalah pengujian kami.  Pada akhirnya, jika didefinisikan, afterAll () dan afterEach () akan dieksekusi untuk manipulasi setelah setiap tes dan semua tes. <br><br>  Saya tidak akan berbicara tentang semua fitur Jasmine, Anda dapat membacanya di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jasmine.github.io</a> <br><br>  Untuk menjalankan pengujian kami, pertama-tama Anda perlu mengubah kode TS menjadi kode JS, dan kemudian jalankan: <br><br><pre> <code class="plaintext hljs">$ tsc $ protractor output_js/config.js</code> </pre><br>  Tes kami dimulai - kami hebat.  :) <br><br><img src="https://habrastorage.org/webt/0f/vu/wc/0fvuwcmgrgf-pspd7vngaweq2dy.png"><br><br>  Jika tes tidak dimulai, ada baiknya memeriksa: <br><br><ul><li>  Bahwa kodenya ditulis dengan benar.  Secara umum, jika ada kesalahan kritis dalam kode, kami akan menangkapnya selama perintah tsc. </li><li>  Server Selenium itu sedang berjalan.  Untuk melakukan ini, Anda dapat membuka URL http: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">//127.0.0.1-00-00444/wd/hub</a> - harus ada antarmuka untuk sesi-sesi Selenium. </li><li>  Chrome itu dimulai secara normal dengan versi driver-chrome yang diunduh.  Untuk melakukan ini, pada halaman / hub / halaman, klik Buat Sesi dan pilih Chrome.  Jika tidak dimulai, maka Anda perlu memperbarui Chrome, atau mengunduh versi lain dari driver chrome. </li><li>  Jika semua ini gagal, Anda dapat memverifikasi bahwa perintah instal npm telah berhasil diselesaikan. </li><li>  Jika semuanya ditulis dengan benar, tetapi tetap saja tidak ada yang dimulai - cobalah untuk mencari kesalahan di google.  Ini paling sering membantu.  :) </li></ul><br><h3>  Skrip NPM </h3><br>  Untuk membuat hidup lebih mudah, Anda dapat membuat bagian dari perintah npm alias.  Sebagai contoh, saya ingin menghapus direktori dengan file JS sebelumnya dan membuatnya kembali dengan yang baru sebelum setiap tes dijalankan. <br><br>  Untuk melakukan ini, tambahkan item skrip ke package.json: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"rm -rf output_js/; tsc; protractor output_js/config.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br>  Sekarang memasukkan perintah <i>tes npm</i> , berikut ini akan terjadi: direktori output_js dengan kode lama akan dihapus, itu akan dibuat lagi dan kode JS baru akan ditulis untuk itu.  Setelah itu tes akan segera dimulai. <br><br>  Alih-alih serangkaian perintah ini, Anda dapat menentukan perintah lain yang Anda perlukan untuk bekerja.  Misalnya, Anda dapat memulai dan memadamkan server selenium di antara uji coba.  Meskipun ini, tentu saja, lebih mudah untuk mengontrol di dalam kode uji itu sendiri. <br><br><h3>  Sedikit tentang Janji </h3><br>  Pada akhirnya, saya akan berbicara sedikit tentang Promise, async / menunggu dan bagaimana penulisan tes di NodeJS berbeda dari Java atau Python yang sama. <br><br>  JavaScript adalah bahasa yang tidak sinkron.  Ini berarti bahwa kode tidak selalu dieksekusi sesuai urutan penulisan.  Ini termasuk permintaan HTTP, dan kami ingat bahwa kode itu berkomunikasi dengan Selenium Server melalui HTTP. <br><br>  Janji (biasanya disebut "janji") menyediakan cara mudah untuk mengatur kode asinkron.  Anda dapat membaca lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">learn.javascript.ru</a> . <br><br>  Bahkan, ini adalah objek yang membuat satu kode bergantung pada eksekusi kode lainnya, sehingga menjamin urutan tertentu.  Busur derajat bekerja sangat aktif dengan benda-benda ini. <br><br>  Mari kita lihat sebuah contoh.  Misalkan kita menjalankan kode berikut: <br><br><pre> <code class="java hljs">driver.findElement().getText();</code> </pre><br>  Di Jawa, kami mengharapkan kami mengembalikan objek bertipe String.  Dalam busur derajat, ini tidak begitu, kami akan mengembalikan objek Janji.  Dan seperti itu, mencetaknya dengan tujuan debug tidak akan berfungsi. <br><br>  Biasanya kita tidak perlu mencetak nilai yang dihasilkan.  Kita perlu meneruskannya ke beberapa metode lain yang sudah bekerja dengan nilai ini.  Misalnya, itu akan memeriksa teks untuk kepatuhan dengan yang diharapkan. <br><br>  Metode serupa di busur derajat juga menerima benda-benda Janji sebagai input, sehingga tidak ada masalah.  Tetapi, jika Anda masih ingin melihat nilainya, maka () akan berguna. <br><br>  Ini adalah bagaimana kami dapat mencetak teks tombol pada halaman Google (perhatikan bahwa karena ini adalah tombol, teks berada di dalam atribut nilai): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //    await browser.wait(EC.presenceOf(submit_button), 5000); //   then()   await submit_button.getAttribute("value").then((text) =&gt; { console.log(text); });</span></span></code> </pre><br>  Adapun kata kunci async / menunggu, ini adalah pendekatan yang sedikit lebih baru untuk bekerja dengan kode asinkron.  Ini memungkinkan Anda untuk menghindari neraka janji, yang sebelumnya terbentuk dalam kode karena banyaknya jumlah sarang.  Namun demikian, Anda tidak akan dapat sepenuhnya menyingkirkan Janji dan Anda harus dapat bekerja dengan mereka.  Ini dapat dimengerti dan terperinci dapat ditemukan di artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain async / tunggu dalam JavaScript: kekuatan, perangkap dan fitur penggunaan</a> . <br><br><h3>  PR </h3><br>  Sebagai pekerjaan rumah, saya sarankan menulis tes untuk halaman yang ditulis dalam AngularJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protractor-demo</a> . <br><br>  Jangan lupa untuk menghapus baris dari kode tentang mematikan halaman yang memeriksa AngularJS.  Dan pastikan untuk bekerja dengan pencari lokasi yang dirancang khusus untuk AngularJS.  Tidak ada keajaiban khusus dalam hal ini, tetapi itu cukup nyaman. <br><br><h3>  Ringkasan </h3><br>  Mari kita ambil stok.  Kami berhasil menulis tes yang berfungsi pada sekelompok TypeScript + Protractor + Jasmine.  Kami belajar bagaimana membangun proyek seperti itu, membuat konfigurasi yang diperlukan, dan menulis tes pertama. <br><br>  Sepanjang jalan, kami membahas sedikit tentang bekerja dengan JavaScript auto-test.  Sepertinya bagus untuk beberapa jam.  :) <br><br><h3>  Apa yang harus dibaca, ke mana harus mencari </h3><br>  <b>Protractor</b> memiliki manual yang cukup bagus dengan contoh JavaScript: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.protractortest.org/#/tutorial</a> <br>  <b>Jasmine</b> memiliki manual: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jasmine.github.io/pages/docs_home.html</a> <br>  <b>TypeScipt</b> telah memulai dengan baik: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html</a> <br><br>  Di Media, ada artikel bagus dalam bahasa Inggris tentang TypeScript + Protractor + Mentimun: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://medium.com/@igniteram/e2e-testing-with-protractor-cucumber-using-typescript-564575814e4a</a> <br><br>  Dan di repositori saya, saya memposting kode final dari apa yang kita bahas dalam artikel ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/KotovVitaliy/HarbProtractorJasmineJasmine</a> . <br><br>  Di Internet, Anda dapat menemukan contoh proyek yang lebih kompleks dan lebih besar di tumpukan ini. <br><br>  Terima kasih atas perhatian anda!  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451522/">https://habr.com/ru/post/id451522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451512/index.html">Cara menguraikan protokol jaringan MMORPG seluler</a></li>
<li><a href="../id451514/index.html">Berita Subgrid CSS</a></li>
<li><a href="../id451516/index.html">Pola Desain Digunakan dalam Kerangka Pegas</a></li>
<li><a href="../id451518/index.html">Situs web seluler kami yang dilucuti</a></li>
<li><a href="../id451520/index.html">VDI: Murah dan ceria</a></li>
<li><a href="../id451524/index.html">Kisah bagaimana ketel Autoplay Media Studio 8.5.3.0 pecah</a></li>
<li><a href="../id451528/index.html">‚ÄúDan begitulah‚Äù: penyedia cloud tidak menyetujui data pribadi</a></li>
<li><a href="../id451532/index.html">Berita dari dunia OpenStreetMap No. 459 (30/4/2019 - 06/05/2019)</a></li>
<li><a href="../id451534/index.html">12 prinsip animasi dalam pengembangan video game</a></li>
<li><a href="../id451538/index.html">Panduan Penskalaan Paralel Redshift Amazon dan Hasil Uji</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>