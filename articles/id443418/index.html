<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€âš–ï¸ ğŸª â˜•ï¸ Metode Pengujian Perangkat Lunak ğŸ§™ğŸ½ ğŸ˜Š ğŸ†˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Minggu depan kami meluncurkan utas baru pada kursus "Pengujian Web Otomasi" . Ini akan menjadi bahan materi hari ini. 

 Artikel ini me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Pengujian Perangkat Lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443418/"> Halo semuanya!  Minggu depan kami meluncurkan utas baru pada kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengujian Web Otomasi"</a> .  Ini akan menjadi bahan materi hari ini. <br><br>  Artikel ini membahas berbagai metode pengujian perangkat lunak, seperti pengujian unit, pengujian integrasi, pengujian fungsional, pengujian penerimaan, dll. <br><br><img src="https://habrastorage.org/webt/tc/nf/kc/tcnfkcczhmixn92gpm04au1rgdo.png"><br><br>  Ada banyak jenis tes yang dapat Anda terapkan untuk memastikan bahwa perubahan pada kode Anda dituliskan.  Tidak semua jenis pengujian identik, meskipun di sini kita melihat bagaimana praktik pengujian utama berbeda satu sama lain. <br><br>  <b>Pengujian: manual atau otomatis?</b> <br><br>  Pertama, Anda perlu memahami perbedaan antara tes manual dan otomatis.  Pengujian manual dilakukan secara langsung oleh orang yang mengklik tombol dalam aplikasi atau berinteraksi dengan perangkat lunak atau API dengan alat yang diperlukan.  Ini cukup mahal, karena membutuhkan tester untuk menginstal lingkungan pengembangan dan menjalankan tes secara manual.  Ada kemungkinan kesalahan karena faktor manusia, seperti kesalahan ketik atau melewatkan langkah-langkah dalam kasus uji. <a name="habracut"></a><br><br>  Tes otomatis, di sisi lain, dilakukan oleh mesin yang menjalankan skrip uji yang ditulis sebelumnya.  Tes tersebut dapat sangat bervariasi tergantung pada kompleksitas, dari pengujian satu metode di kelas hingga mengerjakan urutan tindakan kompleks dalam UI untuk memastikan bahwa itu berfungsi dengan benar.  Metode ini dianggap lebih dapat diandalkan, tetapi kinerjanya masih tergantung pada seberapa baik script untuk pengujian ditulis dengan baik. <br><br>  Tes otomatis adalah komponen utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Integrasi Berkelanjutan</a> dan pengiriman berkelanjutan, serta cara yang baik untuk meningkatkan skala proses QA Anda sambil menambahkan fungsionalitas baru ke aplikasi Anda.  Namun, pengujian manual masih memiliki nilai tersendiri.  Oleh karena itu, dalam artikel ini kita pasti akan berbicara tentang pengujian eksplorasi. <br><br>  <b>Berbagai jenis tes</b> <br><br>  <i><b>Tes unit</b></i> <br><br>  Tes unit dianggap level rendah, dekat dengan kode sumber aplikasi Anda.  Mereka ditujukan untuk menguji metode dan fungsi individual dalam kelas, menguji komponen dan modul yang digunakan oleh program Anda.  Tes unit secara umum tidak memerlukan biaya otomatisasi khusus dan dapat bekerja dengan sangat cepat jika Anda menggunakan server integrasi berkelanjutan. <br><br>  <i><b>Tes integrasi</b></i> <br><br>  Tes integrasi memeriksa apakah layanan dan modul yang digunakan oleh aplikasi Anda bekerja bersama dengan baik.  Sebagai contoh, mereka dapat menguji integrasi dengan database atau memastikan bahwa layanan microser berinteraksi dengan benar satu sama lain.  Tes ini berjalan dengan biaya lebih besar karena mereka membutuhkan banyak bagian aplikasi untuk bekerja secara bersamaan. <br><br>  <i><b>Tes fungsi</b></i> <br><br>  Tes fungsional didasarkan pada persyaratan bisnis untuk aplikasi tersebut.  Mereka hanya memeriksa output setelah tindakan dilakukan dan tidak memeriksa status perantara sistem selama reproduksi tindakan. <br><br>  Terkadang ada kontradiksi antara tes integrasi dan tes fungsional, seperti  mereka berdua meminta beberapa komponen yang saling berinteraksi.  Perbedaannya adalah bahwa tes integrasi hanya dapat memastikan bahwa database dapat diakses, sementara tes fungsional ingin mendapatkan nilai tertentu dari database untuk memeriksa salah satu persyaratan untuk produk akhir. <br><br>  <i><b>Tes ujung ke ujung</b></i> <br><br>  Pengujian end-to-end mensimulasikan perilaku pengguna saat berinteraksi dengan perangkat lunak.  Ini memeriksa seberapa akurat berbagai pengguna mengikuti skenario aplikasi yang dimaksud dan bisa sangat sederhana, misalnya, terlihat seperti memuat halaman web atau memasuki situs web atau, dalam kasus yang lebih rumit, mengonfirmasi alamat email, pembayaran online, dll. <br><br>  Tes ujung ke ujung sangat berguna, tetapi memproduksinya mahal, dan bisa jadi sulit untuk diotomatisasi.  Beberapa tes lintas sektor direkomendasikan, tetapi masih lebih mengandalkan pengujian tingkat rendah (unit dan tes integrasi) untuk dapat dengan cepat mengenali perubahan besar. <br><br>  <i><b>Tes penerimaan</b></i> <br><br>  Tes penerimaan adalah tes formal yang dilakukan untuk memastikan bahwa sistem memenuhi kebutuhan bisnis.  Mereka membutuhkan aplikasi untuk menjalankan dan menjalankan, dan meniru tindakan pengguna.  Pengujian penerimaan dapat melangkah lebih jauh dan mengukur kinerja sistem dan menolak perubahan terbaru jika tujuan pengembangan akhir belum tercapai. <br><br>  <i><b>Tes kinerja</b></i> <br><br>  Tes kinerja menguji perilaku suatu sistem ketika berada di bawah beban yang signifikan.  Tes ini tidak berfungsi dan dapat mengambil banyak bentuk untuk menguji keandalan, stabilitas, dan ketersediaan platform.  Misalnya, dapat memonitor waktu respons saat melakukan sejumlah besar permintaan atau mengamati bagaimana sistem berperilaku ketika berinteraksi dengan data besar. <br><br>  Tes kinerja pada dasarnya mahal untuk dilakukan, tetapi mereka dapat membantu Anda memahami faktor eksternal apa yang dapat menjatuhkan sistem Anda. <br><br>  <i><b>Pengujian asap</b></i> <br><br>  Tes asap adalah tes dasar yang menguji fungsionalitas dasar suatu aplikasi.  Mereka bekerja cukup cepat dan tujuan mereka adalah untuk memperjelas bahwa fungsi-fungsi utama sistem bekerja sebagaimana mestinya dan tidak lebih.  Pengujian semacam itu bertujuan mengidentifikasi kesalahan yang jelas. <br><br>  Tes asap dapat bermanfaat segera setelah membangun bangunan baru untuk memeriksa apakah Anda dapat menjalankan tes yang lebih mahal, atau segera setelah penerapan, untuk memastikan bahwa aplikasi berfungsi dengan baik di lingkungan yang baru. <br><br>  <b>Cara mengotomatisasi tes</b> <br><br>  Seorang penguji dapat melakukan semua tes yang disebutkan di atas secara manual, tetapi ini akan sangat mahal dan tidak produktif.  Karena orang memiliki kemampuan terbatas untuk melakukan sejumlah besar tindakan berulang sambil tetap menguji dengan andal.  Namun, mesin dapat dengan mudah mereproduksi tindakan yang sama dan memeriksa, misalnya, bahwa kombinasi nama pengguna / kata sandi akan bekerja untuk yang keseratus kalinya tanpa keluhan. <br><br>  Untuk mengotomatisasi pengujian, Anda harus terlebih dahulu menulisnya dalam beberapa bahasa pemrograman menggunakan kerangka pengujian yang sesuai untuk aplikasi Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHPUnit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mocha</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RSpec</a> adalah contoh kerangka uji yang dapat Anda gunakan untuk PHP, Javascript, dan Ruby, masing-masing.  Mereka memiliki banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur</a> untuk setiap bahasa, jadi Anda harus mengerjakan sendiri sedikit riset dan berkonsultasi dengan komunitas pengembang untuk mencari tahu kerangka mana yang terbaik untuk Anda. <br><br>  Jika pengujian Anda dapat dijalankan menggunakan skrip dari terminal, Anda dapat mengotomatiskannya menggunakan server integrasi berkelanjutan gaya Bambu atau server cloud Bitbucket Pipelines cloud.  Alat-alat ini akan memonitor repositori Anda dan menjalankan suite tes segera setelah perubahan baru didorong ke repositori utama. <br><br><img src="https://habrastorage.org/webt/ux/1g/ad/ux1gadoiynbuaj_s6k_l_oos1ow.jpeg"><br><br>  Jika Anda baru dalam pengujian, lihat panduan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi</a> berkelanjutan kami untuk membuat rangkaian pengujian pertama Anda. <br><br>  <b>Pengujian penelitian</b> <br><br>  Semakin banyak fungsi dan peningkatan ditambahkan ke kode Anda, semakin banyak kebutuhan untuk pengujian meningkat, karena pada setiap tahap Anda perlu memastikan bahwa sistem bekerja dengan benar.  Juga, itu akan diperlukan setiap kali Anda memperbaiki bug, karena itu tidak akan berlebihan untuk memastikan bahwa itu tidak kembali lagi setelah beberapa rilis.  Otomasi adalah kunci untuk memungkinkan hal ini;  tes menulis cepat atau lambat akan menjadi bagian dari praktik pengembang Anda. <br><br>  Pertanyaannya adalah, perlukah melakukan pengujian manual sama sekali dalam kasus ini?  Jawaban singkatnya adalah ya, dan itu harus difokuskan pada apa yang disebut pengujian eksplorasi, yang membantu mengidentifikasi kesalahan yang tidak jelas. <br><br>  Sesi pengujian penelitian tidak boleh melebihi dua jam dan harus memiliki ruang lingkup yang jelas untuk membantu penguji fokus pada area spesifik perangkat lunak.  Setelah memberi tahu semua penguji tentang batas-batas pengujian, tetap pada kebijaksanaan mereka tindakan yang akan mereka ambil untuk memeriksa bagaimana sistem berperilaku.  Pengujian semacam itu memang mahal, tetapi sangat berguna untuk mengidentifikasi masalah dengan antarmuka pengguna atau memverifikasi kesehatan alur kerja yang rumit bagi pengguna.  Penting untuk melakukan pengujian tersebut setiap kali fungsi baru yang radikal ditambahkan ke aplikasi untuk memahami bagaimana hal itu akan berperilaku dalam kondisi batas. <br><br>  <b>Catatan pengujian</b> <br><br>  Sebelum menyelesaikan artikel ini, saya ingin berbicara tentang tujuan pengujian.  Di satu sisi, sangat penting untuk memastikan bahwa pengguna dapat menggunakan aplikasi Anda ("Saya tidak bisa masuk", "Saya tidak bisa menyimpan data", dll.), Tetapi di sisi lain, sama pentingnya untuk memverifikasi bahwa sistem Anda Tidak rusak saat memasukkan data yang salah atau tindakan tak terduga.  Anda perlu mengantisipasi apa yang akan terjadi ketika pengguna membuat kesalahan ketik, mencoba menyimpan formulir yang tidak lengkap, atau menggunakan API yang salah.  Anda perlu memeriksa apakah salah satu pengguna dapat dengan mudah mengkompromikan data, mendapatkan akses ke sumber daya tertentu yang tidak seharusnya ia akses.  Satu set tes yang baik harus mencoba untuk memecahkan aplikasi Anda dan membantu untuk memahami batas kemampuannya <br><br>  Dan akhirnya, tes juga merupakan kode!  Jadi jangan lupa tentang mereka selama peninjauan kode, karena mereka mungkin merupakan langkah terakhir sebelum merilis produk ke pasar konsumen. <br><br>  Menurut tradisi yang sudah ada, kami menunggu komentar Anda dan mengundang semua orang ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari buka pintu</a> , yang akan diadakan pada tanggal 18 Maret oleh guru kami, insinyur otomatisasi pengujian terkemuka di Grup-IB, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mikhail Samoilov</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443418/">https://habr.com/ru/post/id443418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443406/index.html">20 kesalahan teratas saat bekerja dengan multithreading di C ++ dan cara untuk menghindarinya</a></li>
<li><a href="../id443408/index.html">Foton, kuanta, dan keadaan Fock: manipulasi tingkat kuantum dengan resonator frekuensi radio</a></li>
<li><a href="../id443412/index.html">Mengapa programmer terus menggunakan Java verbose, meskipun ada Python ringkas</a></li>
<li><a href="../id443414/index.html">Plang: ketika breakpoints tidak cukup</a></li>
<li><a href="../id443416/index.html">Winnti: serangan terhadap rantai pasokan - Pengembang game Asia berada di garis depan</a></li>
<li><a href="../id443422/index.html">Penyimpanan data fleksibel di MySQL (JSON)</a></li>
<li><a href="../id443424/index.html">Menulis ulang test case untuk junior frontend ke TypeScript dan react-hooks</a></li>
<li><a href="../id443426/index.html">Tanda hitam - bagaimana OpenShift melindungi terhadap kerentanan kontainer dengan SELinux</a></li>
<li><a href="../id443428/index.html">Palmer Lucky, "bapak" dari Oculus Rift, sedang mengembangkan sistem medan virtual untuk Pentagon</a></li>
<li><a href="../id443430/index.html">Mengapa itu buruk ketika Internet tahu segalanya tentang Anda?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>