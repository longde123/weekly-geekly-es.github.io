<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙂 ✌🏻 🥈 第12版今天发布！ （这对Wolfram语言和Mathematica来说是一个巨大的飞跃） 🛡️ 👋🏼 🖊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="快速连结 
 - 版本12之路 
 - 首先，一些数学 
 - 不确定性的演算 
 - 经典数学，基础和高级 
 - 更多关于多边形的信息 
 - 使用多面体进行计算 
 - 欧几里得风格的几何可计算 
 - 用公理理论走向超级符号化 
 -n身体问题 
 - 语言扩展和便利 
 - 更多机器学习功...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>第12版今天发布！ （这对Wolfram语言和Mathematica来说是一个巨大的飞跃）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/448394/"><hr><br><h2> 快速连结 </h2><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本12之路</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">首先，一些数学</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不确定性的演算</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经典数学，基础和高级</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多关于多边形的信息</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用多面体进行计算</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欧几里得风格的几何可计算</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用公理理论走向超级符号化</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-n身体问题</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语言扩展和便利</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多机器学习功能</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最新的神经网络</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用图像进行计算</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语音识别及更多音频</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自然语言处理</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算化学</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地理计算扩展</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">许多小的可视化增强</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加强知识库集成</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整合来自外部数据库的大数据</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-RDF，SPARQL等</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数值优化</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非线性有限元分析</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全新的复杂编译器</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用Python和其他语言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Wolfram“ Super Shell”的更多内容</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伪造Web浏览器</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独立微控制器</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Python和其他地方调用Wolfram语言</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到Unity Universe</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机器学习的模拟环境</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块链（和CryptoKitty）计算</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有普通加密</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">连接到财务数据源</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件工程和平台更新</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有很多...</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><a name="habracut"></a><br><h5>  2019年4月16日-Stephen Wolfram </h5><br><hr><a name="1"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通往版本12之路</a> </h2><br><br> 今天，我们将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">桌面平台</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram云中</a>发布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram语言</a> （和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mathematica</a> ）的第12版。 我们于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2016年8月</a>发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本11.0</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">于2017年3月</a>发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">11.1，于2017</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">年9</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">月发布了</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">11.2，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">于2018年3</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">月发布了</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">11.3</a> 。 从版本11.3到版本12.0有了很大的跳跃。 在大约103个区域中，共有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">278个全新功能</a> ，以及整个系统上的数千种不同更新： <cut></cut><br><img src="https://habrastorage.org/getpro/habr/post_images/2e8/c69/e66/2e8c69e66869f0498b9c3681066e5f79.png" alt="图片"><br><br> 在12这样的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整数版本</a> ”中，我们的目标是提供功能齐全的新区域。 但是在每个版本中，我们也希望提供我们研发工作的最新成果。 在12.0中，也许我们的一半新功能可以看作是在以前的“ .1”版本中开始的整理区域，而另一半则是在新区域中开始的整理区域。 在本文中，我将讨论两种类型的功能，但我将特别强调从11.3到12.0的新功能的细节。 <cut></cut><br><br> 我必须说，既然12.0已经完成，我为其中的多少以及自11.3起我们增加了多少而感到惊讶。 在去年10月举行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram技术会议</a>上的主题演讲中，我总结了到目前为止的工作-甚至花费了将近4个小时。 现在还有更多。 <cut></cut><br><br> 我们能够做的事情既证明了我们的研发力量，也证明了Wolfram语言作为开发环境的有效性。 这两件事当然已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建立了三十年</a> 。 但是12.0的新功能是，我们一直在让人们观看我们的幕后设计流程- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直播我300多个小时的内部设计会议</a> 。 因此，除了其他所有内容之外，我怀疑这使12.0版成为有史以来以这种方式打开的第一个主要软件版本。 <cut></cut><br><br> 好的，那么12.0中有什么新功能？ 有一些大而令人惊讶的事情-特别是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">化学</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数值不确定性</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库集成方面</a> 。 但是总的来说，很多领域都有很多东西-实际上，甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文献中心</a>的这些内容的基本摘要也已经长达19页： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/2fe/a90/6262fea90d53cb50464973cdf2ca553e.png" alt="图片"><br><br><a name="2"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">首先，一些数学</a> </h2><br><br> 尽管当今Wolfram语言（和Mathematica）的绝大部分功能不是通常认为的数学，但我们仍将巨大的研发努力推向了数学领域的前沿。 作为我们在12.0中添加的内容的第一个示例，这是一个非常丰富多彩的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ComplexPlot3D</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a9/c8a/ea6/1a9c8aea648bdff97ff36c2e9a1b85f0.png" alt="图片"><br><br> 始终可以编写Wolfram语言代码以在复杂平面上进行绘图。 但是直到现在，我们才解决了在复杂平面上自动绘制甚至强大的病理函数的过程所需的数学和算法问题。 <br><br> 几年前，我还记得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">刻苦地绘制</a>对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数函数</a>及其实部和虚部。 现在， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReImPlot</a>可以做到： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/a7e/839/99ea7e839bec41403001a3df0d9791c4.png" alt="图片"><br><br> 复杂功能的可视化是一个（复杂的）故事，细节在人们对某个功能的注意方面有很大的不同。 因此，在12.0中我们要做的一件事情就是引入精心选择的标准化方式（例如命名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">颜色函数</a> ）以突出显示不同的功能： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a58/60e/f9fa5860e97af38616e4fd560e50e133.png" alt="图片"><br><br><a name="3"></a><h2> 不确定性演算 </h2><br><br> 现实世界中的测量通常具有不确定性，不确定性可以表示为具有±误差的值。 我们提供了附加软件包，用于处理年龄段的“有错误的数字”。 但是在12.0版中，我们正在建立具有不确定性的计算，而且我们做得对。 <br><br> 关键是[ <b><i>x，δ</i></b> ] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">周围</a>的符号对象，它表示值“ <i>x</i>周围”，不确定度<i>δ</i> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/987/e57/9be/987e579be95c8038385caeb3c766faa9.png" alt="图片"><br><br> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>进行算术运算，并且存在不确定性如何组合的整体计算方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ea/87b/023/5ea87b0239a365da00d1ff3619587bf6.png" alt="图片"><br><br> 如果您绘制数字，它们将显示为误差线： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c72/127/5fe/c721275fe91ac720eb52f69806471d18.png" alt="图片"><br><br> 有很多选择-例如，这是显示<i>x</i>和<i>y的</i>不确定性的一种方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b4/740/804/6b4740804b0137742c2b40b9b83f36d5.png" alt="图片"><br><br> 您可以拥有数量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/3ac/b72/87d3acb72e026dfe5fc87f2758bc18eb.png" alt="图片"><br><br> 而且，您还可以使用符号<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">环绕</a>对象： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/658/d68/252/658d682523ad51f7825b9471ac275df3.png" alt="图片"><br><br> 但是，真正的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">环绕</a>对象”是什么？ 在某些情况下，存在基于不确定的正态分布来组合不确定性的某些规则。 但是，没有人说过[ <b><i>x，δ</i></b> ]表示实际上详细遵循正态分布的任何事物，而[[ <b><i>x，δ</i></b> ]则表示在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">间隔</a> [{ <b><i>x-δ， x +δ</i></b> }]。 只是对象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">周围会</a>根据一致的通用规则传播错误或不确定性，从而成功地捕获了实验科学中通常要做的事情。 <cut></cut><br><br> 好的，假设您进行了一些有价值的测量。 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MeanAround</a>获得值的估计值及其不确定性（是的，如果度量本身具有不确定性，则在加权其贡献时将考虑这些不确定性）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/57a/a6e/8f457aa6e06da5b6493c5dec5d68f0ba.png" alt="图片"><br><br> 系统中的所有功能（尤其是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机器学习中的功能</a> ）开始具有选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ComputeUncertainty-</a> &gt; <b>True</b> ，这使它们给出了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>对象而不是纯数字。 <cut></cut><br><br> 到处看似一个简单的概念，但它充满了微妙之处-这是直到现在它才进入系统的主要原因。 许多微妙之处围绕不确定性之间的相关性。 基本思想是，每个“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">周围”</a>物体的不确定性均假定为独立的。 但有时会有一些具有相关不确定性的值-因此，除了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around之外</a> ，还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VectorAround</a> ，它表示具有指定协方差矩阵的潜在相关值的向量。 <cut></cut><br><br> 当处理代数公式之类的东西时，甚至还有更多的微妙之处。 如果将此处的x替换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a> ，则按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>的规则，假定每个实例都是不相关的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26f/11b/524/26f11b52481b9a43894a6e6139f721ae.png" alt="图片"><br><br> 但是，可能有人想在这里假设，即使x的值可能不确定，但对于每个实例它都是相同的，并且可以使用功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AroundReplace</a>来做到这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一点</a> （注意结果是不同的）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0d/d52/079/b0dd52079c1f882bd07bd4c2548d6f88.png" alt="图片"><br><br> 如何显示不确定数字有很多微妙之处。 就像您应该输入多少个尾随的0： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f58/4b5/e58/f584b5e58b4425310eaf74001d22e666.png" alt="图片"><br><br> 或者您应该包括多少精度的不确定性（尾数为35时会有一个常规的断点）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ae/ba1/ab3/5aeba1ab3a1cb82aecef0916e914f8dc.png" alt="图片"><br><br> 在少数情况下，许多数字是已知的（例如，一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">物理常数</a> ），人们希望采用另一种方式来指定不确定性： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/db5/9da/472db59da0302ecc2431e7c8763f856c.png" alt="图片"><br><br> 而且它还在继续。 但是逐步地， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>将开始在整个系统中显示。 顺便说一句，还有许多其他方法可以指定数字。 这是一个相对误差为10％的数字： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/20e/20e/25920e20e4b3e7d2d94c5c6217a0dc05.png" alt="图片"><cut></cut><br><br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>可以代表间隔的最佳方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/594/b54/43b/594b5443bf4a687dce3bb7f97f8886fe.png" alt="图片"><br><br> 对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分布</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Around</a>计算方差： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25e/416/4b5/25e4164b5a291048ea53a6c0a4455f0f.png" alt="图片"><br><br> 通过提供不对称的不确定性，它也可以考虑不对称性： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de3/ee9/ffd/de3ee9ffd8924bce1da15f0c51382114.png" alt="图片"><cut></cut><br><br><a name="4"></a><h2> 经典数学，基础和高级 </h2><br><br> 在进行数学计算时，既要“使一切正确”，又要不使基本用户感到困惑或恐吓始终是一个挑战。  12.0版引入了一些帮助。 首先，尝试求解不可约的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">五次方程</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3f/cf1/d97/b3fcf1d9770b4e9f02f2c7e46c5b7273.png" alt="图片"><br><br> 在过去，这会显示很多显式的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Root</a>对象。 但是现在， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">根</a>对象被格式化为显示其近似数值的框。 计算的工作原理完全相同，但是显示并不会立即使人们不得不了解代数。 <br><br> 当我们说<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Integrate时</a> ，在反导数的意义上是指“找到一个积分”。 但是在基本演算中，人们希望看到积分的显式常数（就像在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram | Alpha中一样</a> ），因此我们为此添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一个选项</a> （C [ <i>n</i> ]也有一个不错的新输出形式）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fef/c4b/9a9/fefc4b9a9329ed8fb3f1563e4fd6d689.png" alt="图片"><cut></cut><br><br> 当我们对符号集成功能进行基准测试时，我们做得很好。 但是总会有更多的事情要做，特别是在找到最简单形式的积分方面（从理论上讲，这是符号表达等价性无法确定的必然结果）。 在12.0版中，我们继续在前沿进行介绍，并添加了以下示例： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/191/243/ecc/191243ecc750f0ecc26245903400708d.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/294/2ea/521/2942ea5212b75bd96ad2f87d96900713.png" alt="图片"><br><br> 在版本11.3中，我们引入了渐近分析，能够找到积分的渐近值，等等。  12.0版为方程式添加了渐近和，渐近递归和渐近解： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4e/067/eac/f4e067eaca0282bded7ee459a43ac671.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/a40/ae7/374/a40ae73749aa34e9e5592b81349424c9.png" alt="图片"><br><br> 数学运算的一大优点就是它为我们提供了解释数学本身的新方法。 我们一直在做的事情是增强我们的文档，以便它解释数学以及函数。 例如，这是有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">极限</a>的文档的开始-带有图表和核心数学思想的示例： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dca/3f8/553/dca3f8553b7e125ccd1652e0db7b42ea.png" alt="图片"><br><br><a name="5"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多边形的更多内容</a> </h2><br><br> 从版本1开始，多边形就已经成为Wolfram语言的一部分。但是在版本12.0中，它们已经得到了概括：现在有一种系统的方法可以在其中指定孔。 一个典型的地理用例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">南非</a>的多边形-带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莱索托</a>国家/地区的孔。 <cut></cut><br><br> 在12.0版中，就像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Root</a>一样， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Polygon</a>获得了一种方便的新显示形式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25a/661/229/25a661229630a18e6774e8392256e80d.png" alt="图片"><br><br> 您可以像以前一样使用它进行计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/459/421/0e645942121e3640d6e94aee8d81c7da.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RandomPolygon</a>也是新的。 您可以以3D的形式询问5个随机凸多边形，每个多边形有10个顶点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/b13/97a/4afb1397ae458cbe6f65b4e60b4d0457.png" alt="图片"><br><br> 多边形上有许多新操作。 类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PolygonDecomposition</a> ，它可以例如将多边形分解为凸形部分： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/355/6d6/d40/3556d6d4001a062fc7e69abcc9608ebc.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/b8c/45c/dc9b8c45c761c47a3f63c13e350a9308.png" alt="图片"><br><br> 带孔的多边形也引入了对其他类型操作的需求，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OuterPolygon</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SimplePolygonQ</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CanonicalizePolygon</a> 。 <br><br><a name="6"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用多面体计算</a> </h2><br><br> 多边形很容易指定：您只需按顺序给出其顶点（如果它们有孔，则还应给出这些孔的顶点）。 多面体稍微复杂一点：除了给出顶点外，您还必须说出这些顶点如何形成面。 但是在12.0版中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Polyhedron</a>使您可以相当普遍地执行此操作，包括空隙（孔的3D模拟）等。 <cut></cut><br><br> 但是首先，认识到它们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已有2000多年的历史</a> ，版本12.0引入了五种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">柏拉图固体的功能</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd4/2c7/46d/cd42c746d283d84f51475a5c4ce61056.png" alt="图片"><br><br> 有了柏拉图固体，就可以立即开始使用它们进行计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f61/adf/030/f61adf030665d1250c1d6a6c1af50c99.png" alt="图片"><br><br> 这是对着顶点1的立体角（因为它是柏拉图式的，所以所有顶点都具有相同的角度）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00a/ecb/210/00aecb210b0a43e43f2cee1b7d931d72.png" alt="图片"><br><br> 这是在多面体上完成的操作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5de/334/178/5de3341783cb1a1fa22f6b7dec19e38a.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/cf8/610/2db/cf86102db986e4b546033bb33143ad97.png" alt="图片"><br><br> 除了柏拉图固体之外，第12版还构建了所有“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">统一多面体</a> ”（在每个顶点上有<i>n个</i>边和<i>m个</i>面相交）—并且您还可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PolyhedronData</a>获得名为多面体的符号<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多面体</a>版本： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/58a/d66/4e1/58ad664e151bd438534ef46fb8edad57.png" alt="图片"><br><br> 您可以制作任何多面体（包括带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RandomPolyhedron</a>的“随机”面体），然后在其上进行所需的任何计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/d03/c94/feed03c9478d56949ad87fb186bab070.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/7b2/e7a/ce6/7b2e7ace667a89b9073fc5ef2f2a0461.png" alt="图片"><br><br><a name="7"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欧几里得风格的几何可计算</a> </h2><br><br>  Mathematica和Wolfram语言在执行显式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算几何</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以代数表示的几何方面</a>都非常强大。 但是几何如何在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Euclid的《元素》中</a>完成呢？在几何中，人们提出了几何断言，然后看到它们的后果是什么？ <cut></cut><br><br> 好吧，在第12版中，借助我们构建的整个技术塔，我们终于能够提供一种新型的数学计算-实际上使Euclid 2000年前所做的工作实现了自动化。 一个关键思想是引入具有表示诸如点之类的构造的符号的符号“几何场景”，然后根据它们定义几何对象和关系。 <br><br> 例如，这是一个几何场景，表示一个三角形<i>a，b，c</i>和一个通过<i>a，b</i>和<i>c</i>的圆，中心为<i>o</i> ，约束条件为<i>o</i>处于从<i>a</i>到<i>c</i>的直线的中点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/445/016/c4c44501624329454f84cc8fb1ec777b.png" alt="图片"><cut></cut><br><br> 就其本身而言，这只是一个象征性的事情。 但是我们可以对其进行操作。 例如，我们可以要求它的随机实例，其中<i>a，b，c</i>和<i>o</i>是特定的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e5/6ea/d91/5e56ead91bfa6c293c242bfd705e94c7.png" alt="图片"><br><br> 您可以根据需要生成任意数量的随机实例。 我们尝试使实例尽可能通用，而不会因约束而导致巧合： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49b/b67/f03/49bb67f03b0b1092fea069b53e66dd4c.png" alt="图片"><br><br> 好的，但是现在让我们“玩欧几里得”，找到与我们的设置一致的几何猜想： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/8f6/9e8/b908f69e82fa1ab97a30fa1e84505996.png" alt="图片"><br><br> 对于给定的几何场景，可能会有许多可能的猜想。 我们尝试挑选出有趣的东西。 在这种情况下，我们提出了两个-第一个是图示：线ba与线cb垂直。 碰巧的是，这个结果实际上出现在Euclid中（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作为建议31的一部分</a>出现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三本书中</a> ）-尽管通常被称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thales定理</a> 。 <br><br> 在12.0中，我们现在有了一种完整的符号语言，用于表示以Euclid风格几何图形出现的典型事物。 这是一个更复杂的情况-与所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拿破仑定理</a>相对应： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f05/c8c/104/f05c8c104fcdf99ea328c7560527b2d3.png" alt="图片"><br><br> 在12.0中，有许多新的有用的几何函数可用于显式坐标： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e1/00e/54c/5e100e54c164ea8ebe779cdbc141a9b6.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/0d0/a6f/783/0d0a6f783c9ec6a93d1a923d57749b4b.png" alt="图片"><br><br> 对于三角形，支持12种类型的“中心”，是的，可以有符号坐标： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/601/ccb/d1c601ccbaa16a760752448b7ba2ed62.png" alt="图片"><br><br> 为了支持设置几何语句，我们还需要“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何断言</a> ”。 在12.0中，有29种不同的类型，例如<b>“并行”</b> ， <b>“同余”</b> ， <b>“正切”</b> ， <b>“凸”</b>等。 以下是三个断言成对切线的圆： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/985/d70/c88985d70f115c1421ac8cc68263f4ae.png" alt="图片"><cut></cut><br><br><a name="8"></a><h2> 用公理理论走向超级符号化 </h2><br><br> 版本11.3引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindEquationalProof，</a>用于生成证明的符号表示。 但是这些证明应使用什么公理？  12.0版引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AxiomaticTheory</a> ，它为各种常见的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公理理论</a>提供了公理。 <cut></cut><br><br> 这是我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">个人最喜欢的公理系统</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3ec/601/6b23ec60112b0cd0f9f0fc747502e2a3.png" alt="图片"><br><br> 这是什么意思？ 从某种意义上说，它是一种比我们以前更具有象征意义的符号表达。 在类似1 + <b>x的情况下，</b>我们没有说<b>x</b>的值是多少，但我们认为<b>x</b>可以有一个值。 在上面的表达式中，a，b和c是纯粹的“形式符号”，在本质上起到结构性作用，永远不能被认为具有具体的价值。 <br><br>  ·（中心点）呢？ 在1 + <b>x中，</b>我们知道+的含义。 但是·旨在成为纯抽象运算符。 公理的点实际上是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定义</a>可表示的内容上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的约束</a> 。 在这种特殊情况下，事实证明，公理是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布尔代数</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公理</a> ，因此可以表示<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nand</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nor</a> 。 但是我们可以完全正式地得出公理的结果，例如使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindEquationalProof</a> ： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/613/d7a/c1a613d7ab9276a8a8808d5ab66d5782.png" alt="图片"><br><br> 所有这些都有很多微妙之处。 在上面的示例中，使用·作为运算符非常有用，尤其是因为它显示得很好。 但是它没有内在的含义，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AxiomaticTheory</a>允许您提供其他内容（在此处<b>f</b> ）作为运算符： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/719/69d/0d971969d2ea806acd7731a1cd05de0b.png" alt="图片"><br><br> 那边的<b>“ Nand”</b>在做什么？ 这是运算符的名称（但不应将其解释为与运算符的值有关）。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在群论公理中</a> ，出现了几个运算符： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/730/14e/58e/73014e58e9294ca346a33100ff11029a.png" alt="图片"><br><br> 这给出了各种运算符的默认表示形式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/a3d/13f/fdba3d13fdc809aec140f6d009636d73.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AxiomaticTheory</a>知道有关特定公理系统的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">著名</a>定理： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d85/307/a1cd85307f96a829e361eddba42b8b1f.png" alt="图片"><br><br> 在版本7中引入了形式符号的基本概念，用于在生成的结构中表示虚拟变量，例如： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcf/776/9be/dcf7769be4d3dbd84d6ffeeb2cefd47e.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/6bd/b1e/dd56bdb1e5f8b7228d7771fc330e3bbb.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/4ed/39e/d874ed39e82a38e789faad6f2707e09b.png" alt="图片"><cut></cut><br><br> 您可以使用<b>\ [FormalA]</b>或Esc，a，Esc等输入正式符号。 但是回到版本7， <br>  <b>\ [FormalA]</b>呈现为。 这意味着上面的表达式看起来像： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/10f/c98/72f10fc989b21cccb6449320c1af21b4.png" alt="图片"><br><br> 我一直认为这看起来异常复杂。 对于版本12，我们想简化它。 我们尝试了多种可能性，但最终都选择了单个灰色底纹-我认为它看起来要好得多。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AxiomaticTheory中</a> ，变量和运算符都是“纯符号”的。 但是确定的一件事是每个运算符的友善程度，可以问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AxiomaticTheory</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/288/2d5/2672882d54d51de715ffe6c0d624dfb7.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/760/11a/606/76011a6066fc20d5d24f4efd1a162643.png" alt="图片"><br><br> 方便的是，可以将运算符和arities的表示形式立即输入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Groupings中</a> ，以获得涉及特定变量的可能表达式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/920/134/0b5/9201340b5bcde61ed67e6992301850b1.png" alt="图片"><cut></cut><br><br><a name="9"></a><h2>  <i>n</i>身体问题 </h2><br><br> 公理理论代表了数学的经典历史领域。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>n</i>体问题</a>是另一个经典的历史领域，更多的是在应用方面。  12.0版引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NBodySimulation</a> ，它可以模拟n体问题。 这是一个具有某些初始条件（以及平方反比定律）的三体问题（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Earth-Moon-Sun</a> ）： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/362/3da/d9f3623dafa645ab3bed5091d21d8cae.png" alt="图片"><br><br> 您可以询问解决方案的各个方面。 这将位置作为时间的函数进行绘制： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/c04/d39/54bc04d39ddca678811b75f0b3914271.png" alt="图片"><br><br> 在下面，这只是求解微分方程式，但是-有点像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SystemModel</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NBodySimulation</a>提供了一种方便的方法来建立方程式并处理其解。 而且，是的，内置了标准力法则，但是您可以定义自己的法则。 <br><br><a name="10"></a><h2> 语言扩展和便利 </h2><br><br> 三十多年来，我们一直在完善Wolfram语言的核心，在每个后续版本中，我们最终都会引入一些新的扩展和便利。 <br><br> 从1.0版开始，我们就具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a>功能，但是在12.0版中，我们对其进行了很大的扩展。 它曾经只是提供有关符号的信息（尽管它也已经现代化）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34f/bbc/fd3/34fbbcfd359d9ade3c08c1ca3a0e10df.png" alt="图片"><br><br> 但是现在它也提供了有关许多对象的信息。 以下是有关分类器的信息： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/461/475/cf7/461475cf72622b2c8420ff7892cb3d5a.png" alt="图片"><br><br> 以下是有关云对象的信息： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/467/983/f34/467983f34a490152baf5694191fa8521.png" alt="图片"><br><br> 将鼠标悬停在“信息框”中的标签上，即可找到相应属性的名称： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75c/6b4/5ae/75c6b45ae4e6df0e30acd246ba3a54bc.png" alt="图片"><br><br> 对于实体， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a>提供了已知属性值的摘要： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/635/cbb/4a5/635cbb4a55316f1cfa16f17ee5e38317.png" alt="图片"><br><br> 在过去的几个版本中，我们引入了许多新的摘要显示表单。 在版本11.3中，我们引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Iconize</a> ，它本质上是一种为任何内容创建摘要显示表单的方式。 实践证明，Iconize比我们最初预期的要有用。 这对于隐藏笔记本和Wolfram语言代码中不必要的复杂性非常有用。 在12.0中，我们重新设计了Iconize的显示方式，特别是使其在表达式和代码中“很好地阅读”。 <br><br> 您可以显式图标化某些内容： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/725/95b/5b072595b693946d4892dae18e39bdc8.png" alt="图片"><br><br> 按+，您将看到一些详细信息： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/c08/a0a/6c9c08a0a6c58f5ccf381fa7c0dd62ee.png" alt="图片"><br><br> 按下 <img src="https://habrastorage.org/getpro/habr/post_images/e2d/fae/9c2/e2dfae9c2087bb311e8de301b1b3bf2b.png" alt="图片"> 然后您将再次获得原始表达式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/53b/fba/74353bfbaa9cd3e488e2ba06ec844c3d.png" alt="图片"><br><br> 如果您要在计算中引用大量数据，则始终可以将其存储在文件中或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云中</a> （甚至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据存储库中</a> ）。 但是，通常将它放在笔记本中会更方便，因此您可以将所有内容都放在同一位置。 避免数据“接管您的笔记本”的一种方法是将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">放在封闭的单元格中</a> 。 但是Iconize提供了一种更灵活，更优雅的方式来执行此操作。 <cut></cut><br><br> 在编写代码时，“就地图标化”通常很方便。 现在，右键单击菜单可让您执行以下操作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc3/6d1/419/bc36d14196f62400be648f39102d4c0e.png" alt="图片"><br><br> 说到显示，这是我们在12.0中添加的一些小而方便的东西： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4e/0fb/f93/d4e0fbf930c62473e9e65acfbf7613c6.png" alt="图片"><br><br> 这是我们添加的其他两个“数字便利”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca1/cdd/83d/ca1cdd83d14c1bc395ad30ae4c0c272b.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/12d/516/d6012d516a4e0c77ea4bccce3ff65572.png" alt="图片"><br><br> 函数式编程一直是Wolfram语言的核心部分。 但是，我们一直在寻求扩展它，并引入新的，通常有用的原语。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SubsetMap</a>是版本12.0中的一个示例： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dbf/b62/579/dbfb62579374722db514bb08da3a7df3.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/c62/cba/0ad/c62cba0ad9c5b4a96f09a8478c2bb1ff.png" alt="图片"><br><br> 函数通常是可以接受多个输入但总会给出单个输出的事物。 但是，在诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">量子计算之</a>类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">领域</a> ，人们反而对拥有<b><i>n个</i></b>输入和<b><i>n个</i></b>输出感兴趣。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SubsetMap</a>有效地实现<b><i>n-&gt; n个</i></b>函数，从列表中<b><i>n个</i></b>指定位置提取输入，对其进行一些操作，然后将结果放回相同的<b><i>n个</i></b>位置。 <cut></cut><br><br> 大约一年前，我开始制定现在的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SubsetMap</a> 。 我很快意识到，实际上，多年来我确实可以在各种地方使用此功能。 但是，这种特殊的“计算工作量”应该称为什么？ 我最初的工作名称是<b>ArrayReplaceFunction</b> （在我的笔记中简称为<b>ARF</b> ）。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一系列（直播）会议中，</a>我们来回走了。 有一些想法，例如<b>ApplyAt</b> （但不是真正的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apply</a> ）和<b>MutateAt</b> （但是在左值意义上并没有做突变），还有<b>RewriteAt</b> ， <b>ReplaceAt</b> ， <b>MultipartApply</b>和<b>ConstructInPlace</b> 。 有一些关于咖喱式“函数装饰器”形式的想法，例如<b>PartAppliedFunction</b> ， <b>PartwiseFunction</b> ， <b>AppliedOnto</b> ， <b>AppliedAcross</b>和<b>MultipartCurry</b> 。 <cut></cut><br><br> 但是以某种方式解释功能时，我们会继续讨论该功能在列表的子集上的运行方式，以及它实际上与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Map的关系</a> ，只是一次要在多个元素上运行。 所以最后我们确定了名称<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SubsetMap</a> 。 并且-进一步增强了语言设计的重要性-令人惊讶的是，一旦有人为这样的名称命名，如何立即发现自己能够对此进行推理，并查看可以在何处使用它。 <cut></cut><br><br><a name="11"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多机器学习功能</a> </h2><br><br> 多年来，我们一直在努力使Wolfram语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">成为进行最新机器学习</a>的最高级别和最自动化的系统。 早期，我们引入了“超级功能” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分类</a>和预测，它们以完全自动化的方式执行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分类</a>和预测任务，并针对给定的特定输入自动选择最佳方法。 在此过程中，我们引入了其他超级功能，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SequencePredict</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ActiveClassification</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FeatureExtract</a> 。 <cut></cut><br><br> 在12.0版中，我们有几个重要的新机器学习超级功能。 有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindAnomalies</a> ，可以在数据中查找“异常元素”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e9/842/0f8/4e98420f8f21287739edd2c50a40780b.png" alt="图片"><br><br> 伴随着这个，还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DeleteAnomalies</a> ，它删除了它认为异常的元素： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/113/d75/659113d751f1ba6aa282932934798d34.png" alt="图片"><br><br> 还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SynthesizeMissingValues</a> ，它尝试为丢失的数据生成合理的值： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c7/63a/706/9c763a7063ed27d225a26691ba2c5b03.png" alt="图片"><br><br> 这些功能如何工作？ 它们全部基于一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LearnDistribution</a>的新函数，该函数在给定某些示例的情况下尝试学习数据的基础分布。 如果示例只是数字，那么这本质上将是标准的统计问题，对此我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EstimatedDistribution之类的</a>东西。 但是，关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LearnDistribution的要点</a>是，它可以处理任何类型的数据，而不仅仅是数字。 在这里，它正在学习颜色集合的基本分布： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/27d/b6b/c7327db6baf384bbd60138052aebf9c4.png" alt="图片"><br><br> 一旦有了这种“学习的分布”，我们就可以用它做各种各样的事情。 例如，这会从中生成20个随机样本： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/d6f/d52/9f3d6fd526a5e04950ad9967d2be2ed4.png" alt="图片"><br><br> 但是现在考虑一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindAnomalies</a> 。 它要做的是找出相对于预期而言哪些数据点异常。 或者换句话说，给定数据的基础分布，它会发现哪些数据点是异常值，从某种意义上说，根据分布，它们应该仅以非常低的概率出现。 <br><br> 就像普通的数值分布一样，我们可以为特定数据计算<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> 。 鉴于我们从示例中学到的颜色分布，很可能是紫色： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/dd2/7ba/5cedd27ba152fe7ca464496a4d0e337f.png" alt="图片"><br><br> 但是红色确实不太可能： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/661/1cf/b1d/6611cfb1d1904561634aa0e2c6c2fb3c.png" alt="图片"><br><br> 对于普通的数值分布，有一些像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CDF</a>这样的概念可以告诉我们累积概率，例如，我们将得到比特定值“更远”的结果。 对于任意事物的空间，实际上没有“进一步”的概念。 但是，我们提出了一个称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RarerProbability</a>的函数，该函数告诉我们生成一个比我们提供的内容小的PDF的示例的总概率是多少： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/1c9/f85/cea1c9f851a749bc7ab94ac98564a880.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/553/936/867/5539368677118fe2a426e54ea90fe15b.png" alt="图片"><br><br> 现在，我们有了一种描述异常的方法：它们只是数据点，很少有。 实际上， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindAnomalies</a>具有一个选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AcceptanceThreshold</a> （默认值为0.001），该选项指定应算作“非常小”的内容。 <br><br> 好的，但是让我们看一下这项工作，而不是颜色。 让我们通过查看1000个手写数字示例来训练异常检测器： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/be6/4ab/932be64abd36ee01f8e3ee3d0d6b8221.png" alt="图片"><cut></cut><br><br> 现在， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindAnomalies</a>可以告诉我们哪些示例是异常的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/70f/82c/1a870f82c6f931dafe8fc0e2b8b927f8.png" alt="图片"><br><br><a name="12"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最新的神经网络</a> </h2><br><br> 作为版本11的一部分，我们早在2016年就引入了用于构建，探索和使用神经网络的符号框架。从那时起，在每个版本中，我们都添加了各种最新功能。 在2018年6月，我们推出了我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">神经网络存储库</a> ，以轻松地从Wolfram语言访问最新的神经网络模型-已有近100种不同类型的策展模型在存储库中，并且一直在不断添加新模型。 <cut></cut><br><br> 因此，如果您需要最新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BERT“变压器”神经网络</a> （今天已添加！），可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetModel中</a>获取它： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/5be/7c9/4445be7c9d0067b2a1361107e73bcfcb.png" alt="图片"><br><br> 您可以打开它并查看所涉及的网络（是的，我们已经更新了版本12.0的网络图的显示）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04a/661/15c/04a66115c8f1e1cb2b77e16c49456f19.png" alt="图片"><br><br> 您可以立即使用网络，在这里生成某种“意义特征”数组： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f56/ac7/57a/f56ac757a4a507a3400a7e0c501a3ba0.png" alt="图片"><br><br> 在12.0版中，我们引入了几种新的层类型-特别是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AttentionLayer</a> ，它允许设置一种最新的“变压器”体系结构-并且我们通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetMapThreadOperator</a>和多序列等功能增强了“神经网络功能编程”功能。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetFoldOperator</a> 。 除了这些“内部网”增强功能之外，版本12.0还添加了各种新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetEncoder</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetDecoder</a>案例，例如针对数百种语言的文本进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BPE标记化</a> ，以及包含用于将数据移入和移出的自定义函数的功能。神经网络。 <cut></cut><br><br> 但是12.0版中一些最重要的增强功能是基础架构。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetTrain</a>现在支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多GPU训练</a> ，以及处理混合精度算术和灵活的提前停止条件。 我们将继续使用流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MXNet</a>低级神经网络框架（我们一直是该框架的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主要贡献者</a> ），因此我们可以利用最新的硬件优化。 有很多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新选项</a>可以查看培训过程中发生的情况，还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetMeasurements</a>可以让您对网络的性能进行33种不同类型的测量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/293/411/6fe/2934116fefa0ced9f0d4eb2809b61db1.png" alt="图片"><br><br> 神经网络不是进行机器学习的唯一方法，甚至不是最好的方法。 但是12.0版中的新功能是，我们现在能够在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Classify</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Predict中</a>自动使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自规范化网络</a> ，因此它们在有意义时可以轻松<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">利用神经网络</a> 。 <cut></cut><br><br><a name="13"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用图像计算</a> </h2><br><br> 从版本10.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始</a> ，我们引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageIdentify</a> ，用于识别图像的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">含义</a> 。 在版本12.0中，我们设法对此进行了概括，不仅要弄清楚图像的含义，而且要弄清楚图像中的内容。 因此，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageCases</a>将向我们展示图像中已知种类的对象的情况： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/699/38b/07d/69938b07d4f5d23796dd282807e3de8b.png" alt="图片"><br><br> 有关更多详细信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageContents</a>给出了有关图像内容的数据集： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce0/7ac/df7/ce07acdf74f8aa8eee69228e739f0aea.png" alt="图片"><br><br> 您可以告诉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageCases</a>寻找特定种类的东西： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e84/271/b83/e84271b83fa44fd7bf939f549276e256.png" alt="图片"><br><br> 而且，您还可以测试图像是否包含特定种类的东西： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/546/558/90e54655834a9b06ad1812f4ae7f39a5.png" alt="图片"><br><br> 从某种意义上讲， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageCases</a>类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindFaces</a>的通用版本，用于查找图像中的人脸。  12.0版中的新功能是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindFaces</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FacialFeatures</a>变得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更加高效和强大</a> -如今， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindFaces</a>基于神经网络而不是传统的图像处理，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FacialFeatures</a>的网络现在为10 MB，而不是500 MB： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/3a4/9ca/0b83a49caa8ac1adaeb5dfcf21b44168.png" alt="图片"><br><br> 像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageCases之类的</a>功能代表“新型”图像处理，这种类型的处理似乎在几年前才想到。 但是，尽管这样的功能可以让人们做各种各样的新事情，但是在更经典的技术中仍然有很多价值。 很长时间以来，我们已经用Wolfram语言完成了相当完整的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经典图像处理</a> ，但是我们仍在不断进行改进。 <br><br> 版本12.0中的一个示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImagePyramid</a>框架，用于执行多尺度图像处理： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/111/d22/e88/111d22e88f581c029ffb99a0e5834fba.png" alt="图片"><br><br>  12.0版中有几个与颜色计算有关的新功能。 一个关键的想法是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ColorsNear</a> ，它代表感知颜色空间中的一个邻居，这里围绕着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">粉红色</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45d/58e/576/45d58e57625e51287bb250e08bf3b5b0.png" alt="图片"><br><br> 例如，可以在新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageRecolor</a>函数中使用颜色邻域的概念： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/f79/bd4/940f79bd4758f23e1ad64ea2ee4ecfa1.png" alt="图片"><br><br><a name="14"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语音识别及更多音频</a> </h2><cut></cut><br><br> 当我坐在计算机上写这篇文章时，我将对计算机说些话，然后将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">捕获</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5a/3ef/aa1/d5a3efaa106b59e92e75535d1d62485f.png" alt="图片"><br><br> 这是我捕获的音频的频谱图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/f1f/98f/b78f1f98fc9eaeccd42d6ec659f932e4.png" alt="图片"><br><br> 到目前为止，我们可以在11.3版中执行此操作（尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">频谱图</a>在12.0版中的速度提高了10倍）。 但是现在有一些新东西： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c08/f75/d85/c08f75d85e312beab3df8faac86fb0a6.png" alt="图片"><br><br> 我们正在做语音转文字！ 我们正在使用最先进的神经网络技术，但我对它的运行效果感到惊讶。 它非常精简，而且我们能够很好地处理甚至很长的音频，例如存储在文件中的音频。 在典型的计算机上，转录将以实际的实时速度进行，因此一个小时的语音翻译将需要大约一个小时。 <br><br> 目前，我们认为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语音识别是</a>实验性的，我们将继续对其进行改进。 但是有趣的是，另一个主要的计算任务只是成为Wolfram语言中的一个函数。 <br><br> 在12.0版中，还有其他增强功能。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpeechSynthesize</a>支持新的语言和新的声音（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VoiceStyleData</a> []所列）。 <br><br> 现在有类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebImageSearch</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAudioSearch，</a>它使您可以在网络上搜索音频： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/42a/f34/be542af34f29ede4b252d3e1b6ed53f1.png" alt="图片"><br><br> 您可以检索实际的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">音频</a>对象： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/ace/d35/93baced35a76090293277dcbd1db4380.png" alt="图片"><br><br> 然后，您可以进行频谱图或其他测量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/b8b/fe1/b70b8bfe1a81411f3bcc5575e2877844.png" alt="图片"><br><br> 然后-版本12.0中的新增功能-您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AudioIdentify</a>尝试识别声音的类别（是说话的公鸡吗？）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/411/906/a52/411906a5253e31363c191f7c8724b02b.png" alt="图片"><br><br> 我们仍然认为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AudioIdentify是</a>实验性的。 这是一个有趣的开始，但是例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ImageIdentify</a>确实不能正常工作。 <br><br> 一个更成功的音频功能是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PitchRecognize</a> ，它试图识别音频信号中的主导频率（它同时使用“经典”方法和神经网络方法）。 它尚不能处理“和弦”，但对于“单个音符”而言，它的效果非常好。 <br><br> 当处理音频时，人们通常不仅希望识别音频中的内容，而且还要对其进行注释。  12.0版引入了大规模<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">音频框架的开始</a> 。 现在， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AudioAnnotate</a>可以标记沉默的地方或大声的地方。 将来，我们将添加说话人识别和单词边界以及许多其他功能。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">除此之外</a> ，我们还具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AudioAnnotationLookup之类的</a>功能，用于挑选音频对象中以特定方式进行了注释的部分。 <br><br> 在所有这些高级音频功能的下方，都有一个完整的低级音频处理基础架构。  12.0版大大增强了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AudioBlockMap</a> （用于将滤波器应用于音频信号），并引入了诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ShortTimeFourier之类的</a>功能。 <cut></cut><br><br> 频谱图可以有点像乐谱的连续模拟，其中音高是时间的函数。 在12.0版中，现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有了InverseSpectrogram，</a>它从一系列频谱图数据转换为音频。 从1991年的Version 2开始，我们就开始使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Play</a>从一个函数（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sin</a> [100 t]）生成声音。 现在，借助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">逆频谱图，</a>我们有了从“频率-时间位图”转换为声音的方法。  （而且，是的，当一个相位只有量级信息时，存在关于相位的最佳猜测的棘手问题。） <cut></cut><br><br><a name="15"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自然语言处理</a> </h2><cut></cut><br><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram | Alpha开始</a> ，我们已经拥有了非常强大的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自然语言理解（NLU）功能</a> 。 这意味着，给定一种自然语言，我们就可以很好地将其理解为Wolfram语言-然后我们可以从中进行计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/aa2/d3a/22faa2d3a207aaf6fdd5cd47a8408640.png" alt="图片"><br><br> 但是自然语言处理（NLP）怎么样？在这种情况下，我们正在花很长的时间来使用自然语言，而不是试图完全理解它们，而只是查找或处理它们的特定功能？ 诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextSentences</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextStructure</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextCases</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WordCounts之类的</a>功能在一段时间内为我们提供了该领域的基本功能。 但是在12.0版中-通过利用最新的机器学习以及我们长期的NLU和知识库功能-我们现在已经跃升为具有非常强大的NLP功能。 <br><br> 核心是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextCases</a>的显着增强版本。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextCases</a>的基本目标是在一段文本中查找不同类型的内容的案例。 这方面的一个例子是经典的NLP任务“实体识别”， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextCases可以</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia文章中找到有关</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ocelots的</a>国家名称： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/e70/de1/16fe70de1d0a16db3941c075a71ba6ef.png" alt="图片"><br><br> 我们还可以询问提到了哪些岛屿，但是现在我们不要求使用Wolfram语言解释： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/068/852/db4/068852db45ddb0d8cfe071bb93206131.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextCases</a>并不是完美的，但效果很好： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/7d5/2ee/b457d52ee71f23cbae86e1fda3230241.png" alt="图片"><br><br> 它也支持很多不同的内容类型： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/127/634/7aa1276342f4271c4575980535e966aa.png" alt="图片"><br><br> 您可以要求它查找<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代词，简化的从句</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数量</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电子邮件地址</a>或150种实体（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公司</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工厂</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电影</a> ）中的任何一种。 您还可以要求它挑选出特定于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">人类</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算机</a>语言的文本，或者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与特定主题</a> （例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">旅行</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">健康</a> ）相关的文本，或者具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正面或负面情绪</a>的文本。 而且，您可以使用诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Containing之类的</a>构造来要求这些东西的组合（例如包含河流名称的名词短语）： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/f16/dff/c24f16dffd2f160822ef44d45733d946.png" alt="图片"><br><br> 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TextContents</a>可让您查看在特定文本中检测到的所有实体的详细信息： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/d94/ed6/c09d94ed63c55e9761600051bbf45025.png" alt="图片"><br><br> 而且，是的，原则上可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindTextualAnswer</a>使用这些功能来尝试回答文本中的问题-但是在这种情况下，结果可能很古怪： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/bda/47c/dd2bda47c4bffa6d8e0fcfaeb257cc3e.png" alt="图片"><br><br> 当然，您可以从我们实际的内置精选知识库中获得真正的答案： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/8b1/037/5a58b1037a1d329f6682310bbe1432db.png" alt="图片"><br><br> 顺便说一下，在版本12.0中，我们添加了各种小的“自然语言便捷功能”，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">同义词</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反义词</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d03/6eb/33e/d036eb33e224c13fe5142b9fcdd6e0f9.png" alt="图片"><cut></cut><br><br><a name="16"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算化学</a> </h2><cut></cut><br><br>  12.0版中的“惊奇”新领域之一是计算化学。 很长时间以来，我们就已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已知的已知化学物质</a>中获得了数据。 但是在12.0版中，我们可以使用简单指定为纯符号对象的分子进行计算。 这是我们可以指定什么是水分子的方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe5/f2f/8a3/fe5f2f8a3b35defcd268f3cb29dac95b.png" alt="图片"><br><br> 这是我们制作3D渲染的方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/389/9f6/5fb/3899f65fb0c9925debf42fdcb706b265.png" alt="图片"><br><br> 我们可以处理“已知化学物质”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/12f/519/51d12f519a629dc2569824a94276cefd.png" alt="图片"><br><br> 我们可以使用任意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IUPAC</a>名称： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f7/616/2eb/3f76162eb9b84381c315f3079f3ff781.png" alt="图片"><br><br> 或者我们“组成”化学物质，例如通过其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SMILES</a>字符串指定它们： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e69/d4f/9a7/e69d4f9a7483fec38f34ddb95a4ddf81.png" alt="图片"><br><br> 但是我们不只是在这里生成图片。 我们还可以从结构中计算出事物，例如对称性： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff5/e48/752/ff5e487522c4ff085124985e35b2d48c.png" alt="图片"><br><br> 给定一个分子，我们可以做一些事情，例如加亮碳-氧键： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58f/52d/2be/58f52d2be24dfb02f7b3f0b8d8a1ea01.png" alt="图片"><br><br> 或突出显示结构，例如由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SMARTS</a>字符串指定的结构（此处为任何5元环）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/101/286/0cc10128672716f58dd1244e6fd9e5bc.png" alt="图片"><br><br> 您也可以搜索“分子模式”。 结果以原子数表示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ee/d62/f89/0eed62f8900cd8abb5102d85f3643f2b.png" alt="图片"><br><br> 我们在12.0版中添加的计算化学功能非常通用且非常强大（需要注意的是，到目前为止，它们仅处理有机分子）。 在最低级别上，他们将分子视为带有与键相对应的边缘的标记图。 但是他们也了解物理学，并且正确地解释了原子价和键构型。 不用说，有很多细节（关于立体化学，对称性，芳香性，同位素等）。 但是最终结果是，分子结构和分子计算现已成功添加到Wolfram语言所集成的区域列表中。 <cut></cut><br><br><a name="17"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地理计算扩展</a> </h2><cut></cut><br><br>  Wolfram语言已经具有强大的地理计算功能，但是12.0版增加了更多功能，并增强了其中一些功能。 <br><br> 例如，现在有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RandomGeoPosition</a> ，它会生成一个随机的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经纬度</a>位置。 有人可能会认为这是微不足道的，但当然必须担心坐标转换–使得它变得更加微不足道的是，人们可以告诉它仅在特定区域内（这里是法国）来选择点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ca/0e0/b8c/4ca0e0b8c6ea3d558b1135c9faad4f92.png" alt="图片"><br><br>  12.0版中新的地理功能的主题不仅是处理地理点和区域，而且还处理地理矢量。 这是当前的风向矢量，例如，在埃菲尔铁塔的位置，以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoVector</a>表示，具有速度和方向（还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoVectorENU</a> ，它提供东，北和上分量，以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoGridVector</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoVectorXYZ</a> ）： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd8/ecc/292/dd8ecc292eca49b7d615bf97383f0b69.png" alt="图片"><br><br> 诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoGraphics之类的</a>功能可让您可视化离散的地理矢量。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoStreamPlot</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StreamPlot</a> （或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ListStreamPlot</a> ）的地理模拟-并显示由地理矢量（此处为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WindDirectionData</a> ）形成的流线： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/574/bc5/2ec574bc5058ebe3a6683a1fc37ddfde.png" alt="图片"><br><br> 大地测量学是一个数学复杂的领域，我们为自己在Wolfram语言中的出色表现而感到自豪。 在12.0版中，我们添加了一些新功能来填充一些细节。 例如，我们现在具有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoGridUnitDistance</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoGridUnitArea之</a>类的函数，这些函数给出与地球上每个位置（或月球，火星等）上不同的地理投影相关的失真（基本上是雅可比矩阵的特征值）。 <cut></cut><br><br><a name="18"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">许多可视化方面的增强</a> </h2><cut></cut><br><br> 我们一直在稳步发展的可视化方向之一就是所谓的“元图形”：图形事物的标记和注释。 我们在11.0版中引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标注</a> ； 在12.0版中，它已扩展到3D图形之类的东西： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4a/3ed/f61/a4a3edf6114585c46f0d2ee21e26bc27.png" alt="图片"><br><br> 弄清楚在哪里标记事物非常好，即使它们变得有点复杂： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/2f8/e88/2ec2f8e886cb6b03de54e7bd6656136d.png" alt="图片"><br><br> 要使图形看起来真的很漂亮，有很多细节很重要。  12.0版中已增强的功能是确保图形的列在其框架上对齐，而与刻度标签的长度无关。 我们还添加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LabelVisibility</a> ，它使您可以指定应该使不同标签可见的相对优先级。 <br><br> 版本12.0的另一个新功能是多面板图版式，其中不同的数据集显示在不同的面板中，但是只要有可能，面板就共享轴： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b3/e39/327/8b3e3932775f9af0311ed9ed60dbe99b.png" alt="图片"><br><br><a name="19"></a><h2> 加强知识库集成 </h2><cut></cut><br><br> 我们精心挑选的知识库（例如为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram | Alpha提供支持的</a>知识库）是庞大且不断增长的。 在每个版本的Wolfram语言中，我们都在逐步加强其与语言核心的集成。 <br><br> 在12.0版中，我们要做的一件事就是直接用该语言公开数百种实体： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/734/28c/54c73428c169ffdfcd343779d7626b23.png" alt="图片"><br><br> 在12.0版之前，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram | Alpha示例”页面</a>用作记录多种类型实体的代理。 但是现在有针对所有这些语言的Wolfram语言文档： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d4a/dd2/3cad4add27d7ccff27dd59e3447c2622.png" alt="图片"><br><br> 仍然有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SatelliteData</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WeatherData</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FinancialData之类的功能</a>来处理通常需要复杂选择或计算的实体类型。 但是在版本12.0中，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自然语言</a> （“ control + =”）输入以及“黄色框”实体和属性以相同的方式访问每种实体类型： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8be/f48/d21/8bef48d211fff1a08d21345e7d254005.png" alt="图片"><br><br> 顺便说一句，也可以隐式使用实体，例如在这里要求具有已知最高熔点的5个元素： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3e/ef0/efa/d3eef0efa20040b8399756699d9b4347.png" alt="图片"><br><br> 并且可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dated</a>来获取时间序列值： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/126/ff8/c91126ff895cfeb581bfca5122ec5307.png" alt="图片"><br><br><a name="20"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从外部数据库集成大数据</a> </h2><cut></cut><br><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Knowledgebase</a>内置的数据，我们已经非常方便。 您有实体，并且很容易询问属性等等： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/d3d/e20/3dfd3de207b039a6967c85ad2c521258.png" alt="图片"><br><br> 但是，如果您有自己的数据怎么办？ 您可以设置它以便如此轻松地使用它吗？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本11的</a>一项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主要新功能</a>是增加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityStore</a> ，它可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定义自己的实体类型</a> ，然后指定实体，属性和值。 <cut></cut><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram数据存储库</a>包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大量实体存储示例</a> 。 这是一个： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/405/694/99540569492a7cfffdbbaeb369350a16.png" alt="图片"><br><br> 它描述了单个实体类型： <b>“ SWLibraryBook”</b> 。 为了能够像内置实体一样使用这种类型的实体，我们“注册”实体存储： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adb/4b4/484/adb4b44849ef8a9bd812f3ba4fcaf02b.png" alt="图片"><br><br> 现在，我们可以做一些事情，例如请求10个类型为<b>“ SWLibraryBook”的</b>随机实体： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87f/450/569/87f450569780bd52dbdeb4232a53a3fa.png" alt="图片"><br><br> 实体存储中的每个实体都有各种属性。 这是一个特定实体的属性值的数据集： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/75a/678/0bd75a678383e5a960cf54cc9fb082ba.png" alt="图片"><br><br> 好的，但是通过这种设置，我们基本上是将实体存储的全部内容读取到内存中。 这使得执行所需的Wolfram语言操作非常高效。 但是对于大量数据（例如，太大而无法容纳在内存中的数据）来说，这不是一个很好的可伸缩解决方案。 <br><br> 但是大数据的典型来源是什么？ 通常，它是一个数据库，通常是一个可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL</a>访问的关系<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> 。 十多年来，我们已经拥有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DatabaseLink软件包，</a>用于对SQL数据库的低级别读写访问。 但是在12.0版中，我们添加了一些主要的内置功能，这些功能允许使用Wolfram语言处理外部关系数据库，就像实体存储或Wolfram知识库的内置部分一样。 <cut></cut><br><br> 让我们从一个玩具示例开始。 这是恰好存储在文件中的小型关系数据库的符号表示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/019/ffa/52e019ffa9d662ab70188bf0405301e5.png" alt="图片"><br><br> 马上我们得到一个框，它总结了数据库中的内容，并告诉我们该数据库有8个表。 如果打开框，我们可以开始检查这些表的结构： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/122/56e/06312256e8f9bc1176607d93cf25cc85.png" alt="图片"><br><br> 然后，我们可以将该关系数据库设置为Wolfram语言中的实体存储。 它看起来与上面的图书馆书本实体非常相似，但是现在实际的数据没有被拉到内存中了。 相反，它仍然在外部关系数据库中，而我们只是在Wolfram语言中定义了（类似于ORM的）实体映射： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/e63/4e2/8b1e634e224e6a4934be1587c7717e0f.png" alt="图片"><br><br> 现在我们可以注册该实体存储，这将设置一堆实体类型（至少默认情况下），这些实体类型以数据库中表的名称命名： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/edd/866/084/edd866084fe3db87ec50356b8939bdba.png" alt="图片"><br><br> 现在，我们可以像在Wolfram知识库中的内置实体上那样对它们进行“实体计算”。 这里的每个实体对应于数据库中“员工”表中的一行： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/36c/44e/c7536c44e7a0dcf9d6a836284ecaa295.png" alt="图片"><br><br> 对于给定的实体类型，我们可以询问其具有哪些属性。 这些“属性”对应于基础数据库中表中的列： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/425/18a/9ba/42518a9ba7ce936ddeb9b0fec02b8956.png" alt="图片"><br><br> 现在我们可以要求特定实体的特定属性的值： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/675/28e/30c/67528e30c68a14d89c4d3c37a55d8c26.png" alt="图片"><br><br> 我们还可以通过给出标准来挑选实体； 在这里，我们要求“付款”实体的“金额”属性的值最大为4： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/abd/283/0a3abd28351670f7e077e8f9be802971.png" alt="图片"><br><br> 我们同样可以要求以下最大金额的值： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/000/14e/080/00014e080a7f3b00cad21997ae4e0ed0.png" alt="图片"><br><br> 好的，但是这里变得更加有趣：到目前为止，我们一直在研究一个小的文件支持的数据库。 但是，对于外部服务器上托管的巨型数据库，我们可以做完全相同的事情。 <br><br> 例如，让我们连接到TB级的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenStreetMap PostgreSQL数据库</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a>基本上包含世界的街道地图： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/f93/cf1/e98f93cf15f73f6dc8b6ef4ba1fefaa5.png" alt="图片"><br><br> 和以前一样，让我们​​在此数据库中将表注册为实体类型。 像大多数野生数据库一样，结构中的故障很少，可以解决，但会生成警告： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/e5b/d1a/76ae5bd1a8f15d5e82c197edcd165758.png" alt="图片"><br><br> 但是现在我们可以问有关数据库的问题，例如世界上所有街道上有多少个地理点或“节点”（是的，这是一个很大的数字，这就是数据库很大的原因）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f0/ab8/d84/7f0ab8d842816bf203f34902d776ef31.png" alt="图片"><br><br> 在这里，我们要询问（101 GB）planet_osm_polygon表中具有10个最大（投影）区域的对象的名称（是的，它需要一秒钟的时间）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa8/64c/9a8/aa864c9a824695d9103d343179e7055b.png" alt="图片"><br><br> 那么这一切如何运作？ 基本上发生的是，我们的Wolfram语言表示形式已被编译成低级SQL查询，然后将其发送以直接在数据库服务器上执行。 <br><br> 有时，您会要求获得的结果只是最终值（例如，上面的“金额”）。 但是在其他情况下，您会需要一些中间的东西-例如以特定方式选择的实体集合。 当然，这个收藏可能会有十亿个条目。 因此，我们在版本12.0中引入的一个非常重要的功能是，我们可以纯粹地象征性地表示和操作这些事物，直到最后才将它们解析为特定的事物。 <cut></cut><br><br> 回到我们的玩具数据库，下面是一个示例，该示例如何指定通过汇总具有给定<b>国家/地区</b>值的所有<b>客户</b>的总<b>creditLimit</b>获得的实体类别： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80c/be6/df1/80cbe6df161ed110a92ad09404f8f8cd.png" alt="图片"><br><br> 起初，这只是象征性的东西。 但是，如果我们要求特定的值，那么实际的数据库查询就完成了，并且我们获得了特定的结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5c5/b20/74b5c5b20962af159309c5283f5efc32.png" alt="图片"><br><br> 有一系列新功能可用于设置不同种类的查询。 这些功能实际上不仅适用于关系数据库，而且适用于实体商店和内置的Wolfram知识库。 因此，例如，我们可以要求<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">元素周期表中</a>给定时间段的平均原子质量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/311/f49/7c0311f49157522cb68a2216c59445d4.png" alt="图片"><br><br> 一个重要的新构造是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityFunction</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityFunction</a>类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Function</a> ，不同之处在于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityFunction</a>的变量表示实体（或实体的类），并且它描述可以直接在外部数据库上执行的操作。 这是一个带有内置数据的示例，其中我们定义了一个“已过滤”实体类，其中过滤条件是测试总体值的函数。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FilteredEntityClass</a>本身只是象征性地表示，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityList</a>实际上执行查询，并解析（此处为未排序的）实体的显式列表： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/2f9/1d7/d322f91d70935e233936a6259b290c82.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/254/5e7/d9d/2545e7d9d2fbae039e939b399afa29d1.png" alt="图片"><br><br> 除了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityFunction</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AggregatedEntityClass</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SortedEntityClass之外</a> ，版本12.0还包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SampledEntityClass</a> （从类中获取一些实体）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExtendedEntityClass</a> （以添加计算属性）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CombinedEntityClass</a> （以组合来自不同类的属性）。 有了这些原语，就可以建立“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关系代数</a> ”的所有标准运算。 <br><br> 在标准数据库编程中，通常以“连接”和“外键”等的整个丛林结束。 我们的Wolfram语言表示形式使您可以在更高层次上进行操作-基本上，联接成为函数组合，而外键只是不同的实体类型。  （但是，如果要进行显式连接，则可以使用例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CombinedEntityClass</a> 。） <cut></cut><br><br> 实际情况是，所有那些Wolfram语言构造都已被编译成SQL，或更准确地说，是适合您所使用的特定数据库的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL</a>的特定方言（我们目前支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQLite</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MySQL</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PostgreSQL</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MS</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-SQL</a> ，即将支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OracleSQL</a> 。 进行编译时，我们会自动检查类型，以确保您得到有意义的查询。 即使是相当简单的Wolfram语言规范也可能最终变成许多行SQL。 例如 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12b/9eb/a16/12b9eba16ea5e3901b91f4c8c415eaca.png" alt="图片"><br><br> 会产生以下中间SQL（此处用于查询SQLite数据库）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad4/1c0/54c/ad41c054c0fcb315cbeb189e6cd37595.png" alt="图片"><br><br> 我们在12.0版中拥有的数据库集成系统非常复杂-我们已经在该系统上工作了很多年。 这是向前迈出的重要一步，它使Wolfram语言可以直接处理大数据的新“大”水平，并让Wolfram语言直接对TB级的数据集进行数据科学。 就像发现世界上哪些街道式实体的名称中带有“ Wolfram”一样： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ad/6d7/772/0ad6d77728e8b4ea3b50aa2d19755533.png" alt="图片"><br><br><a name="21"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RDF，SPARQL等</a> </h2><cut></cut><br><br> 代表有关世界的知识的最佳方法是什么？ 自古以来，这个问题就一直被哲学家（和其他人）争论。 有时人们说逻辑是关键。 有时是数学。 有时是关系数据库。 但是现在我们至少知道一个坚实的基础（或者至少，我很确定我们知道）：一切都可以用计算来表示。 这是一个强大的想法-从某种意义上讲，这就是使我们使用Wolfram语言所做的一切成为可能。 <br><br> 但是，是否存在通用计算的子集可用于表示至少某些种类的知识？ 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram知识库中</a>广泛使用的一种概念是实体（“纽约市”），财产（“人口”）及其价值（“ 860万人”）的概念。 当然，这样的三元组并不能代表世界上所有的知识（“火星明天的位置将是什么？”）。 但是，当涉及到有关不同事物的某些“静态”知识时，它们是一个不错的起点。 <cut></cut><br><br> 那么如何才能形式化这种知识表示呢？ 一个答案是通过图形数据库。 在12.0版中（与许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“语义Web”</a>项目保持一致），我们支持使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RDF的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图形数据库</a> ，并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SPARQL</a>对其进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查询</a> 。 在RDF中，中心对象是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IRI</a> （“国际化资源标识符”），它可以表示实体或属性。 然后，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三元组</a> ”由三元组（“主题”，“谓词”，“对象”）组成，每个三元组中的每个元素都是IRI（或文字，例如数字）。 然后可以将整个对象视为图形数据库或图形存储，或者在数学上称为超图。  （这是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超图，</a>因为谓词“边缘”也可以是其他位置的顶点。） <br><br> 您可以像构建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityStore</a>一样构建自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RDFStore</a> －实际上，您可以像查询<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RDFStore</a>一样使用SPARQL查询任何Wolfram语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityStore</a> 。 而且由于Wolfram知识库的实体属性部分可以视为实体存储，因此您也可以查询此实体。 因此，这里最后是一个示例。 国家/城市列表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实体</a> [“ <b>Country</b> ”]， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实体</a> [“ <b>City</b> ”]}实际上代表RDF商店。 那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SPARQLSelect</a>是对该存储执行操作的运算符。 它的作用是尝试找到一个与您的要求匹配的三元组，并为“ SPARQL变量” x赋予特定值： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/555/3c2/76b5553c2aff9438334527e35f90d7ea.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/01e/9f8/bd1/01e9f8bd168dee384d98c73ef0ba546f.png" alt="图片"><br><br> 当然，在Wolfram语言中，还有一种更简单的方法可以做到这一点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/681/ba6/b32/681ba6b329a9b03af93c6f9e80f5f602.png" alt="图片"><br><br> 但是，借助SPARQL，您可以做更多奇特的事情-例如询问与美国和墨西哥相关的房地产： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f8e/ba3/5d9f8eba3cb3a6a6af53790ea0b0f9ad.png" alt="图片"><br><br> 或者是否存在从葡萄牙到德国的基于邻国关系的道路： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/e1d/c2e/4a0e1dc2ee25e9f86d75d4370ef6b84c.png" alt="图片"><br><br> 原则上，您可以仅将SPARQL查询作为字符串编写（有点像可以编写SQL字符串）。 但是我们在版本12.0中所做的是引入了SPARQL的符号表示形式，该符号表示形式允许对表示形式本身进行计算，例如，可以轻松地自动生成复杂的SPARQL查询。  （并且这样做特别重要，因为单独的实际SPARQL查询习惯变得非常冗长和费力。） <cut></cut><br><br> 可以，但是在野外有RDF存储吗？ 一个长期的希望是，Web的很大一部分将以某种方式进行足够的标记以“成为语义”，并实际上是一个巨大的RDF存储。 如果发生这种情况会很好，但是到目前为止绝对没有。 仍然有一些公共RDF商店，以及组织内的一些RDF商店，借助我们在12.0版中的新功能，我们处于与他们一起做有趣事情的独特位置。 <br><br><a name="22"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数值优化</a> </h2><cut></cut><br><br> 在数学的工业应用中，一种非常普遍的问题形式是：“如果必须满足某些约束条件，哪种配置可以使成本最小化（或使收益最大化）？” 半个多世纪以前，发明了所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单纯形算法</a>来解决此类问题的线性形式，其中目标函数（成本，收益）和约束条件都是问题中变量的线性函数。 到1980年代，已经发明了效率更高的（“内部点”）方法，并且很长时间以来，我们就一直使用这些方法来进行Wolfram语言中的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线性编程</a> ”。 <br><br> 但是非线性问题呢？ 好吧，在一般情况下，可以使用NMinimize之类的功能。 他们所做的是最先进的工作。 但这是一个难题。 但是，几年前，很明显，即使在非线性优化问题中，也存在一类所谓的凸优化问题，实际上可以像线性问题一样有效地解决。  （“凸”表示目标和约束都只包含凸函数-因此，当一个函数逼近极值时，没有任何东西可以“摆动”，并且不会存在不是全局最小值的任何局部最小值。） <br><br> 在12.0版中，我们现在对凸优化的所有各种标准类都有了强大的实现。 这是一个简单的情况，涉及最小化具有两个线性约束的二次形式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/47d/6dc/e6747d6dcb1ab95e6d38ab59e9581ece.png" alt="图片"><br><br>  <b>NMinimize</b>可以在版本11.3中解决此特定问题： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/935/47d/9d893547d303b6a8d13ef7997f178254.png" alt="图片"><br><br> 但是，如果有更多变量，旧的<b>NMinimize</b>将很快陷入困境。 但是，在12.0版中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二次优化</a>将继续正常运行，最多可以处理100,000个以上的变量，且约束超过100,000个（只要它们相当稀疏）。 <br><br> 在12.0版中，我们获得了“原始凸优化”功能，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SemidefiniteOptimization</a> （处理线性矩阵不等式）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConicOptimization</a> （处理线性向量不等式）。 但是，像<b>NMinimize</b>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FindMinimum</a>这样的函数也可以自动识别何时可以通过转换为凸优化形式来有效解决问题。 <br><br> 一个如何设置凸优化问题？ 较大的变量涉及对整个向量或变量矩阵的约束。 在12.0版中，我们现在有了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VectorGreaterEqual之类的</a>功能（输入为≥），可以立即表示这些功能。 <cut></cut><br><br><a name="23"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非线性有限元分析</a> </h2><cut></cut><br><br> 偏微分方程很难，而且我们已经致力于处理它们的越来越复杂的通用方法已有30年了。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1991年，</a>我们首次在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本2中</a>引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NDSolve</a> （用于ODE）。 到1990年代中期，我们有了第一个（1 +1维）数值PDE。 在2003年，我们引入了强大的模块化框架来处理数值微分方程。 但是就PDE而言，我们基本上仍然只处理简单的矩形区域。 为了超出构建第10版中引入的整个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算几何系统的要求</a> ，并以此发布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了第一个有限元PDE求解器</a> 。 然后，在版本11中，我们归纳为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特征问题</a> 。 <cut></cut><br><br> 现在，在版本12中，我们将介绍另一个主要的概括：非线性有限元分析。 有限元分析涉及将区域分解为小的离散三角形，四面体等，在这些三角形上，原始PDE可以通过大量耦合方程式近似。 当原始PDE是线性的时，这些方程式也将是线性的—这就是人们在谈论“有限元分析”时所考虑的典型情况。 <br><br> 但是，有许多具有实际重要性的PDE并不是线性的-要解决这些问题，需要进行非线性有限元分析，这是我们现在在版本12.0中所拥有的。 <br><br> 例如，以下是解决非线性非线性PDE的方法，该非线性PDE描述了2D最小表面（例如理想化的肥皂膜）的高度，此处在环形区域上具有（狄利克雷）边界条件，使其在正弦上摆动。边缘（好像肥皂膜从电线上悬挂了）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d58/4c9/085/d584c9085402fbf95a17ae1c3e6f62a6.png" alt="图片"><br><br> 在我的计算机上，仅需四分之一秒即可求解此方程式，并获得插值函数。 这是代表解的插值函数图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/dae/1d4/b70dae1d4342878a4a8709a52f189c51.png" alt="图片"><br><br><a name="24"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新的，复杂的编译器</a> </h2><cut></cut><br><br> 多年来，我们已经投入大量工程来优化Wolfram语言程序的执行。 早在1989年，我们就开始自动将简单的机器精度数值计算编译为有效的虚拟机的指令（并且碰巧，我为此编写了原始代码）。 多年来，我们已经扩展了此编译器的功能，但始终仅限于相当简单的程序。 <br><br> 在12.0版中，我们迈出了重要的一步，并且我们发布了一个新的，功能更强大的编译器的第一个版本，该版本已经开发了好几年。 该编译器既可以处理更广泛的程序（包括复杂的功能构造和复杂的控制流程），也可以不编译为虚拟机，而是直接编译为优化的本机代码。 <br><br> 在12.0版中，我们仍然考虑使用新的编译器。 但是它正在迅速发展，它将对Wolfram语言中许多事物的效率产生巨大影响。 在12.0版中，我们只是公开具有特定编译功能的新编译器的“工具包形式”。 但是，我们将逐步使编译器越来越多地自动运行-在值得花时间进行什么级别的编译时，通过机器学习和其他方法来解决。 <cut></cut><br><br> 在技​​术层面上，新的Version 12.0编译器基于LLVM，并通过生成LLVM代码来工作-链接到Wolfram语言内核本身使用的同一低级运行时库，并回调完整的Wolfram语言内核以获取功能不在运行时库中。 <br><br> 这是在新版本的当前编译器中编译纯函数的基本方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/7b3/226/ba77b32262e365742d3ced0ec799df3d.png" alt="图片"><br><br> 生成的编译代码函数的工作原理与原始函数相同，但速度更快： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f0/3d1/97c/4f03d197cd7a530a506c79397ccfc257.png" alt="图片"><br><br> 使<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FunctionCompile</a>生成更快的函数的很大一部分是，您要告诉它对要获取的参数类型进行假设。 我们支持许多基本类型（例如“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Integer32</a> ”和“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Real64</a> ”）。 但是，当使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FunctionCompile时</a> ，您将提交特定的参数类型，因此可以生成更多简化的代码。 <br><br> 新编译器的许多复杂之处与推断在程序执行中将生成什么类型​​的数据有关。  （涉及许多图论和其他算法，不用说，编译器的所有元编程都是使用Wolfram语言完成的。） <br><br> 这是一个涉及类型推断的示例（ <b>fib</b>的类型推导为<b>“ Integer64”-&gt;“ Integer64”</b> ：返回整数的整数函数）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/330/cec/c5a/330cecc5a2bad1f5969fdb779c605f37.png" alt="图片"><cut></cut><br><br> 在我的计算机上， <b>cf</b> [25]运行的速度比未编译的功能快300倍。  （当然，当编译版本的输出不再是“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Integer64</a> ”类型时，编译版本就会失败，但是标准Wolfram语言版本仍然可以正常工作。） <br><br> 编译器已经可以处理数百种Wolfram语言编程原语，可以适当地跟踪产生的类型，并生成直接实现这些原语的代码。 但是，有时候，人们可能想在Wolfram语言中使用复杂的函数，而对于这些函数而言，生成自己的编译代码没有任何意义-而真正想做的只是调用Wolfram语言内核中的这些函数。 在12.0版中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">KernelFunction</a>可以做到这一点： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/eef/a82/001eefa824b0e7e8faa353ed8bc9ae9b.png" alt="图片"><br><br> 好的，但是，假设有一个已编译的代码函数。 它可以做什么？ 好吧，首先可以在Wolfram语言中运行它。 一个人也可以存储它，然后再运行它。 对于特定的处理器体系结构（例如64位x86），可以完成任何特定的编译。 但是，如果需要， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CompiledCodeFunction会</a>自动保留足够的信息以对其他体系结构进行其他编译。 <br><br> 但是，有了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CompiledCodeFunction</a> ，有趣的新可能性之一就是可以直接生成甚至可以在Wolfram语言环境之外运行的代码。  （我们的旧编译器具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CCodeGenerate</a>软件包，该软件包在简单的情况下提供了稍微相似的功能-尽管即使这样仍依赖于精心编写的C编译器的工具链等。） <br><br> 这是导出原始LLVM代码的方式（请注意，尾递归优化之类的操作会自动完成-并且还要注意符号函数和编译器选项的末尾）： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0b/334/d15/b0b334d15588277d73fe30ebd8d00181.png" alt="图片"><br><br> 如果使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FunctionCompileExportLibrary</a> ，则将获取一个库文件-Mac上的.dylib，Windows上的.dll以及Linux上的.so。 可以通过执行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LibraryFunctionLoad</a>在Wolfram语言中使用它。 但是也可以在外部程序中使用它。 <br><br> 决定新编译器通用性的主要因素之一是其类型系统的丰富性。 现在，编译器支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">14种原子类型</a> （例如“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boolean</a> ”，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Integer8</a> ”，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Complex64</a> ”等）。 它还支持“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PackedArray</a> ”之类的类型构造函数，例如， <b>TypeSpecifier</b> [“ <b>PackedArray</b> ”] [ <b>“ Real64”，2</b> ]对应于64位实数的等级2压缩数组。 <br><br> 在Wolfram语言的内部实现中（顺便说一下，它本身主要是在Wolfram语言中），我们有一种优化的方法可以长时间存储数组。 在12.0版中，我们将其公开为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumericArray</a> 。 与普通的Wolfram语言构造不同，您必须详细告诉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumericArray</a>应该如何存储数据。 但是随后它以一种很好的优化方式工作： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/2df/d9a/ae82dfd9a6d516d1f8038605806203fc.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/329/9b2/11b/3299b211b774d6d2591c286e553bb7c2.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/b3a/90b/4e4b3a90bce8a219f635daea28e90507.png" alt="图片"><br><br><a name="25"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用Python和其他语言</a> </h2><cut></cut><br><br> 在版本11.2中，我们引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExternalEvaluate</a> ，它使您可以从Wolfram语言中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript</a>之类的语言进行计算（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python中</a> ，“ ^”表示<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BitXor</a> ）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/99c/95e/c2599c95e39a197fbb2872e7763d55c8.png" alt="图片"><cut></cut><br><br> 在版本11.3中，我们引入了外部语言单元，以简化在笔记本中直接输入外部语言程序或其他输入的操作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/80c/9b6/5b780c9b6a375c6f5a245f0320968bb5.png" alt="图片"><br><br> 在12.0版中，我们正在加强集成。 例如，在外部语言字符串中，可以使用&lt;* ... *&gt;给出Wolfram语言代码以进行评估： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/058/d7d/dd5058d7dcabc3d023583639c178d07d.png" alt="图片"><br><br> 这也适用于外部语言单元： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/7ae/b35/4657aeb351918b197eaa587fdc93686c.png" alt="图片"><br><br> 当然，Python不是Wolfram语言，所以很多事情不起作用： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78e/fa6/5cb/78efa65cb9c4a980fbfef0271562fd35.png" alt="图片"><br><br> 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExternalEvaluate</a>至少可以从Python返回许多类型的数据，包括列表（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">List</a> ），字典（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Association</a> ），图像（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Image</a> ），日期（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DateObject</a> ）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumPy数组</a> （如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumericArray</a> ）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">熊猫数据集</a> （如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TimeSeries）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DataSet</a>等）。  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExternalEvaluate</a>也可以返回<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExternalObject</a> ，该对象基本上是可以发送回Python的对象的句柄。） <cut></cut><br><br> 您也可以直接使用外部函数（稍微奇怪的ord基本上是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ToCharacterCode</a>的Python类似物）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/740/baa/4c6740baad353bfe1951c06480598677.png" alt="图片"><br><br> 这是一个Python纯函数，用Wolfram语言象征性地表示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/c54/9cd/e01c549cdec28029ba753c6d8aaaadbe.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/5a3/44c/33d/5a344c33d789c5f380f06c77a7f5cc66.png" alt="图片"><br><br><a name="26"></a><h2> 从Python和其他地方调用Wolfram语言 </h2><cut></cut><br><br> 一个人应该如何使用Wolfram语言？ 有很多方法。 一个人可以直接在笔记本上使用它。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用</a>在云中执行它的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API</a> 。 或者可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令行shell中</a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WolframScript</a> 。  WolframScript可以针对本地<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram引擎</a>运行，也可以针对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram引擎运行</a> 。 它使您可以直接给出要执行的代码： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e94/d3e/29e/e94d3e29e3a03923dd85c4da9f60f724.png" alt="图片"><br><br> 它使您可以执行诸如定义函数之类的事情，例如使用文件中的代码： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/f6e/f12/6b1f6ef12064eeb1b6a57b8e98b8aa57.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/c58/ba6/d3d/c58ba6d3de02fd8cefdda1d86c7d66d5.png" alt="图片"><br><br> 随着版本12.0的发布，我们还发布了第一个针对Python的新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram语言客户端库</a> 。 该库的基本思想是使Python程序易于调用Wolfram语言。  （值得指出的是，通过有效的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WSTP</a> ，我们已经有效地拥有了至少30年的C语言客户端库。） <br><br> 语言客户端库的工作方式因不同的语言而异。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于Python（作为一种解释语言（实际上是早期Wolfram语言所提供的信息））来说，它特别简单。</font><font style="vertical-align: inherit;">之后您</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建立特写库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并启动会话（本地或云），你可以当时只是由钨评价语言下面的代码和得到的结果早在Python的：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/f6a/f1a/638f6af1a998246c352f06c7872093ef.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以通过沃尔弗拉姆还可以直接访问语言功能的（与一种以逆</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExternalFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/374/3b0/4203743b04153aa9946d9212b8f3d9c3.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以直接与pandas结构，NumPy数组等交互。</font><font style="vertical-align: inherit;">实际上，您实际上可以将整个Wolfram语言视为可以从Python访问的巨型库。</font><font style="vertical-align: inherit;">或者，当然，您可以直接使用精美的集成Wolfram语言，如果需要，可以创建外部API。</font></font><br><br><a name="27"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wolfram“ Super Shell”的更多内容 </font></font></h2><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Wolfram语言的一项功能是，它使您不必考虑计算机系统的详细信息以及文件和进程之类的内容。但是有时人们想要在系统级别上工作。对于相当简单的操作，您可以只使用操作系统GUI。但是对于更复杂的事情呢？过去，我通常会使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix shell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是很长一段时间以来，我改用Wolfram语言。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将所有内容都放在笔记本中当然非常方便，并且能够以编程方式使用诸如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FileNames</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ls），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FindList</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（grep），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemProcessData</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ps），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteRunProcess</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ssh）和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FileSystemScan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是在12.0版中，我们添加了许多附加功能来支持将Wolfram语言用作“超级外壳”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有</font><font style="vertical-align: inherit;">一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteFile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用来象征性地表示一个远程文件（如果需要的话，带有身份验证）-您可以立即在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CopyFile之类的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中使用它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FileConvert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可直接在不同格式之间转换文件。</font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且，如果您真的想深入研究，请按照以下方法在来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wolfram.com的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取中跟踪端口80和443上的所有数据包</font><font style="vertical-align: inherit;">：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/589/07d/c0f/58907dc0f140b552d76390afe36a509b.png" alt="图片"><br><br><a name="28"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 伪造网络浏览器 </font></font></h2><cut></cut><br><br> 在Wolfram语言中，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">URLExecute</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTTPRequest之</a>类的功能以及$ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cookies</a>等，很长时间以来一直很容易与Web服务器进行交互。 但是在12.0版中，我们添加了一些新功能：Wolfram语言可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">控制Web浏览器</a> ，并以编程方式使其能够完成我们想要的功能。 我们能做的最直接的事情就是将网站的外观图像显示在网络浏览器上： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/334/338/96a/33433896a1f7bd04f15791dfd2dd3bf5.png" alt="图片"><br><br> 结果是我们可以使用以下图像进行计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/3b8/f2d/e513b8f2d3c5e4261bb90a4a7815064e.png" alt="图片"><br><br> 要进行更详细的操作，我们必须启动浏览器会话（我们目前支持Firefox和Chrome）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="图片"><br><br> 随即，一个空白的浏览器窗口出现在我们的屏幕上。 现在，我们可以使用WebExecute打开网页： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b7/d5e/313/3b7d5e313a576e8ef19c8608b9697af5.png" alt="图片"><br><br> 现在我们打开了页面，可以运行许多命令。 这将单击第一个包含文本“ Programming Lab”的超链接： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55b/5d1/5f8/55b5d15f81d2abe5cccf61152aa9046d.png" alt="图片"><br><br> 这将返回我们已经到达的页面的标题： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="图片"><br><br> 您可以键入字段，运行JavaScript，并基本上以编程方式执行您可以使用网络浏览器进行的任何操作。 不用说，多年来我们一直在公司内部使用该技术的版本来测试我们所有的各种网站和Web服务。 但是现在，在版本12.0中，我们将提供一个简化的版本，该版本普遍可用。 <br><br><a name="29"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独立微控制器</a> </h2><cut></cut><br><br> 对于当今世界上的每台通用计算机，运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微控制器</a>而无需任何通用操作系统的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微控制器的</a>数量大概是其的十倍。 微控制器的价格可能在几美分到几美元之间，而在中档汽车之类的产品中，可能会有30美分。 <br><br> 在12.0版中，我们引入了Wolfram语言的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微控制器套件</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">套件</a>使您可以提供符号规范，并从中自动生成和部署代码以在微控制器中自主运行。 在典型设置中，微控制器会不断对来自传感器的数据进行计算，并实时向执行器输出信号。 在控制理论和信号处理中，最常见的计算类型是有效的计算类型。 <br><br> 长期以来，我们一直支持直接使用Wolfram语言进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">控制理论</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号处理</a> 。 但是现在，微控制器工具包可以采用语言中指定的内容，并将其作为嵌入式代码下载到独立的微控制器中，该微控制器可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部署在任何地方</a> （在设备，IoT，设备等中）。 <br><br> 例如，以下是如何生成模拟信号处理滤波器的符号表示的方法： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/255/6c6/67e/2556c667eb6b487b0657419d5bd1e480.png" alt="图片"><br><br> 我们可以直接在Wolfram语言中使用此过滤器-假设使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RecurrenceFilter</a>将其应用于音频信号。 我们还可以做一些事情，例如绘制其频率响应： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a85/22b/8d9/a8522b8d961d04d6d967139e82f52978.png" alt="图片"><br><br> 要将滤波器部署在微控制器中，我们首先必须从这种连续时间表示中得出离散时间近似值，该近似值可以在微控制器中以紧密循环（此处为每0.1秒）运行： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecc/e6d/c76/ecce6dc76f8dbfc9e74b556d7a9b96c2.png" alt="图片"><br><br> 现在，我们准备使用微控制器套件将其实际部署到微控制器中。 该套件支持一百多种不同类型的微控制器。 这是将过滤器部署到已连接到计算机串行端口的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Arduino Uno的方法</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95f/f0e/781/95ff0e781b43e3f53e708f8929f666a9.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/7bb/a8f/2a17bba8f0708021de792c4b86dd7b41.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微控制器EmbedCode的</a>工作原理是生成适当的类似于C的源代码，将其编译为所需的微控制器体系结构，然后通过所谓的编程器将其实际部署到微控制器中。 这是在这种特殊情况下生成的实际源代码： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/30c/52a/6ef30c52a232105557cb984db655cc1f.png" alt="图片"><br><br> 所以现在我们有了这样的东西，它可以运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Butterworth过滤器</a> ，我们可以在任何地方使用它： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfd/ab3/e39/bfdab3e39ead3e8cf85251bf28d5d277.png" alt="图片"><br><br> 如果我们想检查它在做什么，我们总是可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DeviceOpen</a>将其重新连接到Wolfram语言，以打开其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">串行端口</a> ，并从中进行读写。 <br><br><a name="30"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到Unity Universe</a> </h2><cut></cut><br><br>  Wolfram语言和视频游戏之间有什么关系？ 多年来，Wolfram语言已在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏开发的许多方面</a> （模拟策略，创建几何图形，分析结果等）在后台使用。 但是一段时间以来，我们一直在研究Wolfram语言和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity游戏环境</a>之间的更紧密链接，并且在12.0版中，我们发布了该链接的第一个版本。 <br><br> 基本方案是让Unity与Wolfram语言一起运行，然后建立双向通信，从而可以交换对象和命令。 引擎盖下的管道非常复杂，但是结果是Wolfram Language和Unity的优势完美融合。 <br><br> 这将设置链接，然后在Unity中启动一个新项目： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/270/93a/4af27093ade48a6ef031b2d618d99c5a.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/92a/378/da492a378b2669aa287728aeb27b13a1.png" alt="图片"><br><br> 现在创建一些复杂的形状： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/214/e3e/bb3214e3e4669b136d966ab856d78ce0.png" alt="图片"><br><br> 然后，只需一个命令即可将其作为一个名为“ <b>thingoid</b> ”的对象放入Unity游戏： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df4/edb/5aa/df4edb5aa6f976cd757e21476f505de5.png" alt="图片"><br><br> 在Wolfram语言中，该对象具有符号表示形式，并且UnityLink现在提供了数百种用于操纵此类对象的功能，并且始终在Unity和Wolfram语言中维护版本。 <cut></cut><br><br> 可以将Wolfram语言中的内容立即带入Unity，这非常强大，无论它们是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图像</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">音频</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地理地形</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分子结构</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3D解剖结构</a>还是其他任何东西。 然后可以通过Unity游戏中的诸如游戏物理性或用户动作之类的东西来操纵这些东西，这也非常强大。  （最终，人们可以期望拥有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类似Manipulate</a>的功能，其中控件不仅是滑块和其他东西，而是复杂的游戏玩法。） <br><br> 自1990年代初以来，我们就进行了将Wolfram语言–生成的内容应用于虚拟现实的实验。 但是在现代，Unity已成为设置VR / AR环境的事实上的标准-现在使用UnityLink可以将来自Wolfram语言的内容日常地放入任何现代XR环境中，变得非常简单。 <cut></cut><br><br> 人们可以使用Wolfram语言为Unity游戏做准备，但是在Unity游戏中，UnityLink基本上还可以让人们插入可以在游戏期间在本地计算机上或通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Cloud中</a>的API执行的Wolfram语言代码。 并且，除其他外，这使得将钩子插入游戏变得很简单，因此游戏可以发送“遥测”（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Data Drop</a> ）以Wolfram语言进行分析。  （也可以编写游戏脚本，例如，这对游戏测试非常有用。） <br><br> 编写游戏是一件复杂的事情。 但是UnityLink提供了一种有趣的新方法，可以简化各种游戏的原型制作以及学习游戏开发的思路。 原因之一是它通过使用Wolfram语言中的符号构造有效地让一个脚本更高级别地玩游戏。 但是另一个原因是，它允许在笔记本中逐步完成开发过程，并解释和记录其每一步。 例如，以下是描述“ <a href="">钢琴游戏</a> ”的发展的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算文章</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/ef8/2b4/a42ef82b4e18bc1c47fc84bc60128dd0.png" alt="图片"><br><br>  UnityLink不是一件简单的事情：它包含600多个函数。 但是有了这些功能，就有可能访问Unity的几乎所有功能，并建立几乎任何可以想象的游戏。 <br><br><a name="31"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机器学习的模拟环境</a> </h2><cut></cut><br><br> 对于诸如强化学习之类的东西，在进行机器学习时，必须在循环中拥有可操纵的外部环境。 好吧， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ServiceExecute</a>允许您启动实际设备（向左转动机器人）并从传感器获取数据（机器人是否跌倒了？）， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DeviceExecute</a>允许您调用API（发布该tweet或进行该交易的效果如何？）。 <br><br> 但是出于许多目的，人们想要的是拥有一个模拟的外部环境。 从某种意义上说，纯Wolfram语言已经在某种程度上做到了这一点，例如，提供了访问丰富的“计算宇宙”的途径，其中充满了可修改的程序和方程式（元<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">胞自动机</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微分方程式</a> ……）。 而且，是的，可以通过现实世界来了解该计算宇宙中的事物，例如具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">海洋</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">化学物质</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">山脉</a>的真实属性。 <br><br> 但是，什么样的环境更像我们现代人通常在其中学习的环境-充满了已构建的工程结构等等？ 足够方便的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SystemModel</a>可以访问许多实际的工程系统。 通过UnityLink，我们可以期望获得丰富的基于游戏的世界模拟。 <br><br> 但首先，在版本12.0中，我们将建立与一些简单游戏的连接-特别是来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenAI“ gym”的连接</a> 。 该界面与用于与现实世界进行交互的界面非常相似，可以像访问“设备”一样访问游戏（在适当的时候进行了“开源痛苦”的安装）： <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec9/83a/b2d/ec983ab2d7c63efc693c939acda7dbf9.png" alt="图片"><br><br> 我们可以阅读游戏状态： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/872/c7a/884872c7a130bbfecc2f09bf679b2299.png" alt="图片"><br><br> 我们可以将其显示为图像： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6c/fcd/9ac/d6cfcd9ac48ffe0b14508449c745c2f0.png" alt="图片"><br><br> 稍加努力，我们就可以在游戏中采取100个随机动作（始终检查我们没有“死”），然后显示观察到的游戏状态的特征空间图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cf/a32/6d4/1cfa326d4dedba01361ae861654470df.png" alt="图片"><br><br><a name="32"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块链（和CryptoKitty）计算</a> </h2><cut></cut><br><br> 在版本11.3中，我们开始<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了与区块链的首次连接</a> 。  12.0版增加了许多新特性和功能，也许最值得注意的是具有写入公共区块链以及从中读取的功能。  （我们还为Wolfram云用户提供了自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram区块链</a> 。）我们目前正在支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比特币</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以太坊</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARK</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块</a>链，包括其主网和测试网（是的，我们有自己的节点直接连接到这些区块链）。 <br><br> 在版本11.3中，我们允许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始读取</a>来自区块链<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的交易</a> 。 在版本12.0中，我们添加了一层分析，例如，您可以要求<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以太坊区块</a>链上的“ CK”令牌（AKA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CryptoKitties</a> ） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/764/9d7/9fd/7649d79fd08e80c7b49e0b4ed01601c2.png" alt="图片"><br><br> 快速查看历史记录中的所有令牌交易，并对不同令牌的活跃程度做出一词云： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b34/e2a/ed1/b34e2aed1642c72e2adc852c646652d0.png" alt="图片"><br><br> 但是如何进行我们自己的交易呢？ 假设我们要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比特币ATM</a> （就像在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我附近的百吉饼商店中存在的</a>那个那样）将现金转移到比特币地址。 好吧，首先我们创建我们的加密密钥（并且我们需要确保我们记得我们的私有密钥！）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/808/40a/27a/80840a27a3055248b226d25587a73509.png" alt="图片"><br><br> 接下来，我们必须使用我们的公钥并从中生成一个比特币地址： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caf/e3d/947/cafe3d947d2d41234d0f7586f2915e4f.png" alt="图片"><br><br> 从中制作一个QR码，您就可以开始使用ATM了： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a74/929/50e/a7492950e7d0a95d38186315c1ddd001.png" alt="图片"><br><br> 但是，如果我们想自己写区块链怎么办？ 在这里，我们将使用比特币测试网（因此，我们不会花费真钱）。 这显示了我们之前进行的交易的输出-包括0.0002比特币（即20,000聪）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/321/cd7/fd4321cd77d95b3ed9efd7c0de0895ed.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/364/802/556/3648025569fe0af443c62393e883beee.png" alt="图片"><br><br> 现在，我们可以建立一个使用此输出的事务，例如，向两个地址（我们为ATM事务定义的地址）分别发送8000个聪： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/040/6c6/137/0406c61375496148813593fadd4ee74b.png" alt="图片"><br><br> 好的，所以现在我们有了一个区块链交易对象，该对象将向矿工愿意支付所有剩余的加密货币（此处为4000 satoshi）的费用（用红色显示，因为这是您要花费的“实际钱”）。区块链中的交易。 但是，在我们可以提交此交易（并“花钱”）之前，我们必须使用私钥对其进行签名： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/f79/eda/d50f79eda8d9794ebc5c806981154bc4.png" alt="图片"><br><br> 最后，我们只应用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BlockchainTransactionSubmit</a> ，我们已经提交了要放在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块链上</a>的交易： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23e/a41/90b/23ea4190b20e3551659e93dad7b69e91.png" alt="图片"><br><br> 这是它的交易ID： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/823/fa5/39a823fa520d89549e8e1e2168740057.png" alt="图片"><br><br> 如果我们立即询问该交易，我们将收到一条消息，指出该交易不在区块链中： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/f7f/642/060f7f642cb825d2622240997bc0eafe.png" alt="图片"><br><br> 但是等了几分钟之后，就到了，它很快就会传播到比特币测试网区块链的每个副本中： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/b84/8a2/bd2b848a27bee449da4f33e59b81c6e5.png" alt="图片"><br><br> 如果您准备花真钱，则可以使用完全相同的功能在主网上进行交易。 您也可以做类似购买CryptoKitties的事情。 诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BlockchainContractValue之类的</a>功能可以用于任何（目前仅以太坊）智能合约，并且可以立即了解诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ERC-20</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ERC-721</a>令牌之类的内容。 <br><br><a name="33"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有普通的加密货币</a> </h2><cut></cut><br><br> 处理区块链涉及很多加密，其中一些是12.0版中的新功能（特别是处理椭圆曲线）。 但是在版本12.0中，我们还扩展了非区块链密码功能。 例如，我们现在有了直接处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数字签名的功能</a> 。 这将从上方使用私钥创建数字签名： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/992/aea/095/992aea095dda73b7c235697083f415b0.png" alt="图片"><br><img src="https://habrastorage.org/getpro/habr/post_images/e63/6a4/1fa/e636a41faad25da5ad4ec9b608c84263.png" alt="图片"><br><br> 现在，任何人都可以使用相应的公共密钥来验证消息： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/856/188/068/856188068028388c87e44b766c116697.png" alt="图片"><br><br> 在12.0版中，我们为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hash</a>函数添加了几种新类型的哈希，尤其是为了支持各种加密货币。 我们还添加了生成和验证<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">派生密钥的方法</a> 。 从任何密码开始， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GenerateDerivedKey</a>将把它“塞入”更长的时间（为了更安全，您应该添加“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">salt</a> ”）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/913/885/a62/913885a629ef74ed691138b7466691a4.png" alt="图片"><br><br> 这是派生密钥的一个版本，适用于各种身份验证方案： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b7/538/8ea/9b75388ea82f526769bf51a88a911989.png" alt="图片"><br><br><a name="34"></a><h2> 连接到财务数据源 </h2><cut></cut><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram知识库</a>包含各种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">财务数据</a> 。 通常，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">金融实体</a> （如股票），然后有一个财产（如价格）。 这是苹果公司股票价格的完整每日历史（以对数刻度看起来最好，这令人印象深刻）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/710/812/cab710812fa2da43a0b71dc75152b7c6.png" alt="图片"><br><br> 但是，虽然Wolfram知识库中的财务数据（通常以Wolfram语言提供）一直在不断更新，但是它不是实时的（通常会延迟15分钟），并且没有许多金融交易员使用的所有细节。 但是，对于严重的财务使用，我们开发了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Finance Platform</a> 。 现在，在12.0版中，可以直接访问Bloomberg和Reuters的财务数据提要。 <br><br> 我们构建Wolfram语言的方式，与彭博社和路透社的连接框架始终以该语言提供，但只有在具有Wolfram金融平台以及适当的Bloomberg或Reuters订阅的情况下，才会激活该语言。 但是，如果您拥有这些，则连接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">彭博终端</a>服务的外观如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/ff6/97f/dd5ff697ffebdb5c00d653d50438672a.png" alt="图片"><br><br> 彭博终端机处理的所有金融工具现在都可以以Wolfram语言的实体形式获得： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c9/4b0/c6e/0c94b0c6e8d86d6311981528c4dd2931.png" alt="图片"><br><br> 现在我们可以请求该实体的属性： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffd/290/bb2/ffd290bb25269f2331d0f913de0ff61e.png" alt="图片"><br><br> 彭博航站楼共有超过60,000个属性可供访问： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5dd/de8/940/5ddde8940cb5f533179581155afbae90.png" alt="图片"><br><br> 这是5个随机示例（是的，它们非常详细；这些是彭博名称，而不是我们的名称）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/6f0/8ab/6386f08ab9fc2877748ce7d93567d2ce.png" alt="图片"><br><br> 我们支持彭博终端服务， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">彭博数据许可</a>服务和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">路透社电子</a>服务。 现在可以做的一件复杂的事情是设置一个连续任务以异步接收数据，并在每次收到新数据时调用“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理程序函数</a> ”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/0a4/833/ab40a48336f338db8a6b232fd2215d03.png" alt="图片"><br><br><a name="35"></a><h2> 软件工程和平台更新 </h2><cut></cut><br><br> 我已经讨论了Wolfram语言中的许多新功能和新功能。 但是Wolfram语言的基础架构又如何呢？ 好吧，我们也一直在努力。 例如，在版本11.3和版本12.0之间，我们设法修复了将近8000个报告的错误。 我们还使许多事情变得更快，更强大。 通常，我们一直在加强系统的软件工程，例如将初始下载大小减少近10％（尽管已添加了所有功能）。  （我们还进行了诸如从云中改进<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">知识库元素</a>的预测性<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预取之类的工作，</a>因此，当您需要类似的数据时，很有可能已经将其缓存在计算机上了。） <br><br> 操作系统不断更新是计算环境的一项长期功能-要利用其最新功能，应用程序也必须进行更新。 我们已经进行了数年的Mac笔记本界面重大更新工作，该更新终于在12.0版中准备好了。 作为更新的一部分，我们重写和重组了20多年开发和完善的大量代码，但是结果是，在版本12.0中，Mac上我们系统的所有内容都是完全64位的，并利用了最新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cocoa API</a> 。 这意味着笔记本电脑的前端显着提高了速度，并且还可以超过以前的2 GB内存限制。 <br><br>  Linux上还有一个平台更新，现在笔记本界面完全支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qt 5</a> ，它允许所有渲染操作“无头”进行，而无需任何X服务器，从而大大简化了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Engine</a>在云中的部署。  （版本12.0尚不支持Windows的高dpi，但即将推出。） <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Cloud</a>的开发在某些方面与Wolfram语言和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Desktop</a>应用程序的开发不同（尽管出于内部兼容性的考虑，我们在两种环境中同时发布了12.0版）。 但是自从版本11.3发布以来的过去一年中，Wolfram Cloud取得了巨大进步。 <cut></cut><br><br> 特别值得注意的是云笔记本的进步-支持更多的界面元素（包括嵌入式网站和视频中的某些元素，而台式笔记本甚至还没有提供这些元素）以及极大地提高了鲁棒性和速度。  （使我们整个笔记本界面都可以在网络浏览器中工作并不是软件工程的壮举，并且在12.0版中，有一些非常复杂的策略可以用于维护一致的快速加载缓存以及完整的符号DOM表示。） <br><br> 在12.0版中，现在只有一个简单的菜单项（“文件”&gt;“发布到云...”），可以将任何笔记本发布到云中。 笔记本发布后，世界上任何人都可以与它进行交互-并制作自己的副本，以便他们可以对其进行编辑。 <br><br> 有趣的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，云已经进入</a>了Wolfram语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以完成的工作</a> 。 除了云知识库的所有无缝集成，以及能够接触诸如区块链之类的功能之外，如果没有直接的电子邮件服务器连接，还可以使用诸如使用云通过云发送，发送任何笔记本等便利功能。 <br><br><a name="36"></a><h2> 还有很多... </h2><cut></cut><br><br> 尽管这是一个漫长的过程，但它还不能完全讲述12.0版中的新增功能的全部故事。 与我们团队的其他成员一起，我已经为版本12.0进行了很长时间的努力-但是仍然很高兴看到其中实际上有多少。 <br><br> 但是至关重要的（还有很多工作要做！）是我们添加的所有内容都经过精心设计，以与现有内容保持一致。 从30年前的第一个版本开始，到现在的Wolfram语言，我们一直遵循相同的核心原则-这是使我们能够在保持长期兼容性的同时大幅扩展系统的一部分。 <br><br> 始终很难确切地确定为每个新版本优先开发的内容，但是我对我们为版本12.0所做的选择感到非常满意。 在过去的一年中，我进行了许多演讲，而对于能够经常谈论发生的事情我感到非常震惊：“嗯，碰巧这将成为12.0版的一部分！ ” <br><br> 我个人使用版本12.0的内部初步版本已经将近一年了，我已经把它的许多新功能视为理所当然-并且经常使用和享受它们。 因此，今天我们拥有最终的12.0版非常高兴，它正式包含了所有这些新功能，随时可供任何人使用... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448394/">https://habr.com/ru/post/zh-CN448394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448382/index.html">我们如何评估文件质量</a></li>
<li><a href="../zh-CN448386/index.html">让人回覆您的讯息的9种惊人的简单方法</a></li>
<li><a href="../zh-CN448388/index.html">数字听写将在俄罗斯首次举行</a></li>
<li><a href="../zh-CN448390/index.html">如何制作伊洛娜面具的手表</a></li>
<li><a href="../zh-CN448392/index.html">构造活动图表的两种方法</a></li>
<li><a href="../zh-CN448396/index.html">为macOS Mojave上的强化运行时和公证服务做好准备</a></li>
<li><a href="../zh-CN448400/index.html">Netplan以及如何正确烹饪</a></li>
<li><a href="../zh-CN448402/index.html">证书颁发机构（CA）从Windows 2008R到Windows 2012 R2的迁移失败</a></li>
<li><a href="../zh-CN448404/index.html">如何使用Yandex.Direct API示例（第2部分）使用并行计算来加快R语言API的工作速度</a></li>
<li><a href="../zh-CN448408/index.html">DCIM-数据中心管理的关键</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>