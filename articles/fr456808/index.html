<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏎️ 🔠 🕴️ Comment améliorer les performances des applications Web frontales: cinq conseils 👩🏻‍🤝‍👨🏼 🤴🏾 ♎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans bon nombre de mes projets frontaux, à un moment donné, j'ai dû faire face à une baisse de la productivité - cela se produit généralement lorsque ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment améliorer les performances des applications Web frontales: cinq conseils</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/456808/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/p2/n1/fh/p2n1fhon961as8f21unatry3hfi.jpeg"></a> <br><br>  Dans bon nombre de mes projets frontaux, à un moment donné, j'ai dû faire face à une baisse de la productivité - cela se produit généralement lorsque la complexité de l'application augmente, ce qui est normal.  Néanmoins, les développeurs sont toujours responsables des performances, donc dans mon article, je donnerai cinq conseils pour optimiser les applications que j'applique moi-même: certains peuvent sembler évidents, certains affectent les principes de base de la programmation - mais, je pense, rafraîchir la mémoire n'est pas superflu sera.  Chaque conseil est accompagné de tests: vous pouvez les exécuter vous-même et tester les performances. <br><br>  <b>Traduit en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alconost</a></b> <br><a name="habracut"></a><br><h2>  Préface </h2><br>  N'oubliez pas: si le code n'a pas besoin d'être optimisé, n'entrez pas dedans.  Bien sûr, le code que vous écrivez devrait fonctionner rapidement, et vous pouvez toujours trouver un algorithme plus rapide - mais celui écrit doit rester clair pour les autres développeurs.  Dans la conférence «La programmation en tant qu'art», Donald Knuth a exprimé une idée très importante sur l'optimisation du code: <br><br><blockquote>  <i>Le vrai problème était que les programmeurs passaient trop de temps à se soucier de l'efficacité dans des endroits et des moments inappropriés.</i>  <i><b>L'optimisation prématurée est à l'origine de toutes</b> les <b>erreurs de</b> programmation (ou du moins la plupart).</i> <i><br></i> </blockquote><br><h2>  1. Recherche: au lieu des tableaux ordinaires - objets et tableaux associatifs </h2><br>  Lorsque vous travaillez avec des données, des situations surviennent souvent lorsque, par exemple, vous devez trouver un objet, en faire quelque chose, puis trouver un autre objet, etc.  La structure de données la plus courante dans JS est un tableau, donc le stockage de données en eux est une pratique normale.  Cependant, chaque fois que vous avez besoin de trouver quelque chose dans le tableau, vous devez utiliser des méthodes telles que "find", "indexOf", "filter" ou itérer avec des boucles - c'est-à-dire que vous devez parcourir les éléments du début à la fin.  Ainsi, nous effectuons une recherche linéaire, dont la complexité est 0 (n) (dans le pire des cas, nous devrons effectuer autant de comparaisons qu'il y a d'éléments dans le tableau).  Si vous effectuez cette opération plusieurs fois sur de petites baies, l'impact sur les performances sera faible.  Cependant, si nous avons beaucoup d'éléments et que l'opération est effectuée plusieurs fois, les performances échoueront certainement. <br><br>  Dans ce cas, ce sera une bonne solution pour convertir un tableau régulier en objet ou en tableau associatif et effectuer une recherche de clé: dans ces structures, les éléments sont accessibles avec la complexité O (1) - nous aurons un appel mémoire, quelle que soit la taille.  L'amélioration de la vitesse de travail est obtenue grâce à l'utilisation d'une structure de données appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">table de hachage</a> . <br><br>  Vous pouvez tester les performances ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/finding-element-object-vs-map-vs-array/1</a> .  Voici mes résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/3e0/62f/3c03e062f1990f348bdd5fb7084e7278.png"><br><br>  La différence est très importante: pour un tableau associatif et un objet, j'ai des millions d'opérations par seconde, alors que pour un tableau, le meilleur résultat est un peu plus d'une centaine d'opérations.  Bien sûr, la conversion des données n'est pas prise en compte ici, mais même en tenant compte de son fonctionnement sera beaucoup plus rapide. <br><br><h2>  2. Au lieu d'exceptions - l'opérateur conditionnel "si" </h2><br>  Parfois, il semble plus facile d'ignorer la vérification nulle et de simplement attraper les exceptions correspondantes.  Bien sûr, c'est une mauvaise habitude - vous n'avez pas besoin de le faire, et si vous en avez un dans votre code, il suffit de réécrire les sections correspondantes.  Mais pour vous convaincre complètement, je soutiendrai cette recommandation par des tests.  J'ai décidé de tester trois façons de faire des vérifications: l'expression «try-catch», la condition «if» et le calcul de «court-circuit». <br><br>  Test: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/try-catch-vs-conditions/1</a> .  Voici mes résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/4d8/9eb/d744d89eb0f25200abece3ccb5370f8b.png"><br><br>  Je pense qu'il est évident à partir d'ici qu'un contrôle de «null» est nécessaire.  De plus, comme vous pouvez le voir, il n'y a presque aucune différence entre la condition "si" et le calcul du "court-circuit" - alors appliquez-vous à ce que ment l'âme. <br><br><h2>  3. Moins il y a de cycles, mieux c'est </h2><br>  Une autre considération évidente, mais peut-être controversée.  Il existe de nombreuses fonctions pratiques pour les tableaux: «carte», «filtre», «réduire», de sorte que leur utilisation semble attrayante, et le code avec eux semble plus propre et plus facile à lire.  Mais lorsque la question se pose d'améliorer la productivité, vous pouvez essayer de réduire le nombre de fonctions appelées.  J'ai décidé d'analyser deux cas: 1) «filtrer», puis «carte», et 2) «filtrer», puis «réduire» - et les comparer avec la chaîne fonctionnelle, «forEach» et la boucle traditionnelle «for».  Pourquoi exactement ces deux cas?  Les tests montrent que les avantages obtenus peuvent ne pas être très importants.  De plus, dans le deuxième cas, j'ai également essayé d'utiliser "filtre" lors de l'appel de "réduire". <br><br>  Test de performance pour "filtre" et "carte": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-map/1</a> .  Mes résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/8f7/a78/6008f7a7819add9d68e1b4311d489461.png"><br><br>  On peut voir qu'un cycle est plus rapide, mais la différence est faible.  La raison d'un si petit écart est l'opération de «poussée», qui n'est pas nécessaire lors de l'utilisation de la «carte».  Par conséquent, dans ce cas, vous pouvez vous demander s'il est vraiment nécessaire de procéder à un cycle. <br><br>  Maintenant, vérifions "filtrer" + "réduire": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-reduce/1</a> .  Mes résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/0ae/a22/b6e0aea22e9b87555180ed93a7b0bdad.png"><br><br>  Ici, la différence est déjà plus grande: la combinaison de deux fonctions en une a accéléré l'exécution de près de la moitié.  Néanmoins, le passage au cycle traditionnel "for" donne une augmentation de vitesse beaucoup plus importante. <br><br><h2>  4. Utilisez des boucles régulières </h2><br>  Ces conseils peuvent également sembler controversés, car les développeurs adorent les cycles fonctionnels: ils sont bien lus et peuvent simplifier le travail.  Cependant, ils sont moins efficaces que les cycles traditionnels.  Je pense que vous remarquerez peut-être déjà la différence dans l'utilisation des boucles for, mais jetons un coup d'œil dans un test séparé: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/for-loops-in-few-different-ways/</a> .  Comme vous pouvez le voir, en plus des mécanismes intégrés, j'ai également vérifié "forEach" dans la bibliothèque "Lodash" et "each" dans "jQuery".  Résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1d/06f/e3d/f1d06fe3d1ff046226ff524737538676.png"><br><br>  Et encore une fois, nous voyons que la boucle "for" la plus simple est beaucoup plus rapide que les autres.  Certes, ces boucles ne sont valables que pour les tableaux - dans le cas d'autres objets itérables, vous devez utiliser "forEach", "for ... of" ou l'itérateur lui-même.  Mais «for ... in» ne devrait être appliqué que s'il n'y a pas d'autre méthode du tout.  N'oubliez pas non plus que «for ... in» accepte toutes les propriétés de l'objet (et dans le tableau les propriétés sont des index), ce qui peut conduire à des résultats imprévisibles.  Étonnamment, les méthodes de Lodash et jQuery n'étaient pas si mauvaises en termes de performances, donc dans certains cas, vous pouvez les utiliser en toute sécurité au lieu du «forEach» intégré (il est intéressant de noter que dans le test, la boucle de Lodash a fonctionné plus rapidement que le intégré). <br><br><h2>  5. Utilisez les fonctions intégrées pour travailler avec le DOM </h2><br>  Parfois, vous regardez le code de quelqu'un d'autre et voyez que le développeur a importé jQuery uniquement pour manipuler le DOM - je suis sûr que vous l'avez vu aussi, car c'est l'une des bibliothèques JavaScript les plus populaires.  Il est clair qu'il n'y a rien de mal à utiliser des bibliothèques pour contrôler le DOM: nous utilisons aujourd'hui React et Angular, et ils font de même.  Cependant, il semble parfois que jQuery devrait être utilisé même pour des opérations simples pour extraire un élément du DOM et y apporter des modifications mineures. <br><br>  Voici une comparaison des fonctions intégrées pour le DOM et des opérations JQuery similaires dans trois cas différents: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsperf.com/native-dom-functions-vs-jquery/1</a> .  Mes résultats: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1f/921/4ed/a1f9214ed02f914a5cf613d90bafb05c.png"><br><br>  Et encore une fois, les fonctions les plus élémentaires - «getElementById» et «getElementsByClassName» - se sont avérées être les plus rapides lors de la visualisation du DOM.  Dans le cas des identifiants et des sélecteurs avancés, querySelector est également plus rapide que jQuery.  Et dans un seul cas, «querySelectorAll» est plus lent que jQuery (obtention des éléments par nom de classe).  Pour plus d'informations sur comment et comment remplacer jQuery, voir ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://youmightnotneedjquery.com</a> . <br><br>  Il est clair que si vous utilisez déjà la bibliothèque pour gérer le DOM, il est fortement recommandé de vous y tenir - cependant, pour les cas simples, les outils intégrés suffisent. <br><br><h2>  Matériel supplémentaire </h2><br>  Ces cinq conseils vous aideront à écrire un code JavaScript plus rapide.  Mais si vous souhaitez en savoir plus sur l'optimisation des performances, voici quelques recommandations: <br><br>  1. Optimisation des bundles JavaScript à l'aide de Webpack: c'est un sujet très complet, mais si tout est fait correctement, le chargement des applications peut être considérablement accéléré. <br><br>  2. Structures de données, algorithmes de base et leur complexité: beaucoup pensent que ce n'est «qu'une théorie», mais dans le premier paragraphe, nous avons vu comment cette théorie fonctionne dans la pratique. <br><br>  3. Tests sur la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsPerf</a> : ici, vous pouvez vous familiariser avec une comparaison de différentes façons d'accomplir la même tâche en JavaScript et en même temps voir un indicateur important dans la pratique - la différence de vitesse. <br><br>  <b>À propos du traducteur</b> <br><br>  L'article a été traduit par Alconost. <br><br>  Alconost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localise des jeux</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applications et des sites</a> dans 70 langues.  Traducteurs en langue maternelle, tests linguistiques, plateforme cloud avec API, localisation continue, chefs de projet 24/7, tout format de ressources de chaîne. <br><br>  Nous réalisons également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des vidéos de publicité et de formation</a> - pour les sites qui vendent, présentent des images, de la publicité, des formations, des teasers, des explicateurs, des bandes-annonces pour Google Play et l'App Store. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En savoir plus</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456808/">https://habr.com/ru/post/fr456808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456794/index.html">Architecture de l'interface utilisateur Web: un passé en bois, un présent étrange et un brillant avenir</a></li>
<li><a href="../fr456796/index.html">Svalbard - nouveau nom pour le projet Have I Been Pwned avant la vente</a></li>
<li><a href="../fr456798/index.html">Tutoriels SDL 2: Leçon 5 - Textures</a></li>
<li><a href="../fr456804/index.html">Suivez l'argent: comment le groupe RTM a commencé à cacher les adresses des serveurs C&C dans un portefeuille crypté</a></li>
<li><a href="../fr456806/index.html">Un robot de tous les soucis</a></li>
<li><a href="../fr456812/index.html">Ce qu'il y a à l'Université ITMO - festivals informatiques, hackathons, conférences et séminaires ouverts</a></li>
<li><a href="../fr456814/index.html">Apprenez la programmation fonctionnelle en Python en 10 minutes</a></li>
<li><a href="../fr456818/index.html">L'administrateur système dans une entreprise inaccessible. Le fardeau insupportable d'être?</a></li>
<li><a href="../fr456824/index.html">Qu'est-ce que la probabilité et comment la calculer</a></li>
<li><a href="../fr456826/index.html">Autoscaling DIY avec AWX, Ansible, haproxy et CROC Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>