<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 🧜🏽 🤶🏿 Node.js手册，第7部分：异步编程 🔟 💝 🤛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在翻译Node.js手册的第七部分时，我们将讨论异步编程，考虑使用回调，promise和async / await构造之类的问题，并讨论使用事件。 

  

 [我们建议您阅读]周期的其他部分  第1部分： 一般信息和入门 
 第2部分： JavaScript，V8，一些开发技巧 
 第3部...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js手册，第7部分：异步编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/"> 今天，在翻译Node.js手册的第七部分时，我们将讨论异步编程，考虑使用回调，promise和async / await构造之类的问题，并讨论使用事件。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[我们建议您阅读]周期的其他部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一般信息和入门</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript，V8，一些开发技巧</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管，REPL，使用控制台，模块</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm，package.json和package-lock.json文件</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm和npx</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，调用堆栈，计时器</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步编程</a> <br> 第8部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第8部分：HTTP和WebSocket协议</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，</a>第9 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分：使用文件系统</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第10部分：标准模块，流，数据库，NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南的完整PDF</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">编程语言中的异步</font> </h2><br>  JavaScript本身是一种同步的单线程编程语言。 这意味着您无法在并行运行的代码中创建新线程。 但是，计算机本质上是异步的。 即，无论主程序执行流程如何，都可以执行某些动作。 在现代计算机中，每个程序都分配了一定数量的处理器时间，当该时间用完时，系统还会将资源分配给另一个程序一段时间。 这种切换是周期性执行的，执行速度如此之快，以至于人们根本无法注意到它，因此，我们认为我们的计算机可以同时执行许多程序。 但这是一种幻想（更不用说多处理器机器了）。 <br><br> 在程序的内部，使用中断-信号传输到处理器，并引起系统的注意。 我们不再赘述，最重要的是要记住，在程序暂停直到需要处理器资源之前，它的异步行为是完全正常的。 在程序无法使系统正常工作的时候，计算机可以解决其他问题。 例如，使用这种方法，当程序正在等待对对其发出的网络请求的响应时，它不会阻塞处理器，直到接收到响应为止。 <br><br> 通常，编程语言是异步的，其中一些使程序员能够使用内置语言工具或专用库来控制异步机制。 我们正在谈论的语言包括C，Java，C＃，PHP，Go，Ruby，Swift和Python。 它们中的一些允许您使用线程以异步样式进行编程，以启动新进程。 <br><br><h2>  <font color="#3AC1EF">JavaScript异步</font> </h2><br> 如前所述，JavaScript是一种单线程同步语言。 用JS编写的代码行按在文本中出现的顺序依次执行。 例如，下面是一个非常普通的JS程序，它演示了此行为： <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br> 但是创建了JavaScript以便在浏览器中使用。 从一开始，它的主要任务就是组织与用户活动有关的事件的处理。 例如，这些事件是诸如<code>onClick</code> ， <code>onMouseOver</code> ， <code>onChange</code> ， <code>onSubmit</code>等事件。 如何在同步编程模型的框架内解决此类问题？ <br><br> 答案在于运行JavaScript的环境。 即，浏览器允许您有效地解决此类问题，并为程序员提供适当的API。 <br><br> 在Node.js的环境中，有用于执行非阻塞I / O操作的工具，例如处理文件，组织网络上的数据交换等。 <br><br><h2>  <font color="#3AC1EF">回呼</font> </h2><br> 如果我们谈论基于浏览器的JavaScript，则可以注意到，当用户单击按钮时不可能事先知道。 为了确保系统响应此类事件，将为其创建处理程序。 <br><br> 事件处理程序接受事件发生时将调用的函数。 看起来像这样： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br> 此类函数也称为回调函数或回调。 <br><br> 回调是一个常规函数，将其作为值传递给另一个函数。 仅在发生特定事件时才调用它。  JavaScript实现了一流功能的概念。 可以将此类函数分配给变量，然后传递给其他函数（称为高阶函数）。 <br><br> 客户端JavaScript开发中的一种常见方法是，将所有客户端代码包装在<code>window</code>对象的<code>load</code>事件的侦听器中，该侦听器在页面准备好工作后调用传递给它的回调： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br> 回调无处不在，不仅用于处理DOM事件。 例如，我们已经在定时器中使用了它们： <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">XHR请求</a>还使用回调。 在这种情况下，看起来就像是将一个函数分配给相应的属性。 当特定事件发生时，将调用类似的函数。 在以下示例中，此类事件是请求状态更改： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">handling回调中的错误处理</font> </h3><br> 让我们谈谈如何处理回调中的错误。 有一种处理此类错误的通用策略，Node.js中也使用了这种策略。 它包含以下事实：任何回调函数的第一个参数都是错误对象。 如果没有错误，则将<code>null</code>写入此参数。 否则，将有一个错误对象，其中包含其描述和有关它的其他信息。 看起来是这样的： <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">▍回调问题</font> </h3><br> 回调在简单情况下方便使用。 但是，每个回调是代码嵌套的附加级别。 如果使用了几个嵌套的回调，这将很快导致代码结构的严重复杂化： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br> 在此示例中，仅显示了4个级别的代码，但实际上一个级别可能会遇到很多级别，通常称为“回调地狱”。 您可以使用其他语言结构来解决此问题。 <br><br><h2>  <font color="#3AC1EF">承诺和异步/等待</font> </h2><br> 从ES6标准开始，JavaScript引入了新功能，这些功能使编写异步代码变得更加容易，从而消除了对回调的需求。 我们正在谈论出现在ES6中的Promise，以及出现在ES8中的async / await构造。 <br><br><h3>  <font color="#3AC1EF">▍承诺</font> </h3><br> 承诺（承诺对象）是使用JavaScript中的异步软件构造的一种方法，通常可以减少回调的使用。 <br><br><h4> 了解承诺 </h4><br> 承诺通常被定义为某些值的代理对象，预计将来会出现。 承诺也称为“承诺”或“承诺结果”。 尽管此概念已经存在多年，但仅在ES2015中将诺言标准化并添加到该语言中。 在ES2017中，基于诺言的async / await设计已经出现，可以认为是它们的方便替代品。 因此，即使您不打算使用常规的Promise，对它们如何工作的理解对于有效使用异步/等待构造也很重要。 <br><br><h4> 诺言如何运作 </h4><br> 承诺被调用后，它将进入挂起状态。 这意味着，导致承诺的函数将继续执行，同时在承诺中执行一些计算，然后承诺会通知它。 如果promise执行的操作成功完成，那么promise将转移到已实现状态。 据说这种诺言已成功解决。 如果操作以错误完成，则将promise置于拒绝状态。 <br><br> 让我们谈一谈兑现承诺。 <br><br><h4> 创建承诺 </h4><br> 用于处理promise的API为我们提供了相应的构造函数，该构造函数由形式为<code>new Promise()</code>的命令调用。 这是创建诺言的方式： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis检查全局常量<code>done</code> ，如果其值为<code>true</code> ，则成功解析它。 否则，承诺将被拒绝。 使用函数的<code>resolve</code>和<code>reject</code>参数，我们可以从promise中返回值。 在这种情况下，我们返回一个字符串，但是这里可以使用一个对象。 <br><br><h4> 兑现承诺 </h4><br> 我们在上面创建了一个承诺，现在考虑使用它。 看起来像这样： <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br> 调用<code>checkIfItsDone()</code>将导致isItDoneYet <code>isItDoneYet()</code>的执行，并导致组织等待其解决。 如果Promise成功解析，则传递给<code>.then()</code>方法的回调将起作用。 如果发生错误，即承诺将被拒绝，则可以在传递给<code>.catch()</code>方法的函数中对其进行处理。 <br><br><h4> 连锁承诺 </h4><br>  Promise方法返回promise，使您可以将它们组合成链。 这种行为的一个很好的例子是基于浏览器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API Fetch</a> ，它是<code>XMLHttpRequest</code>的抽象层。 对于Node.js，有一个相当流行的npm包，它实现了Fetch API，我们将在后面讨论。 该API可用于加载某些网络资源，并且由于可以将诺言链组合在一起，因此可以组织对下载数据的后续处理。 实际上，当您通过调用<code>fetch()</code>函数来调用Fetch API时，就会创建一个Promise。 <br><br> 考虑以下链接promise的示例： <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br> 在这里，我们使用npm包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">node-fetch</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jsonplaceholder.typicode.com</a>资源作为JSON数据源。 <br><br> 在此示例中， <code>fetch()</code>函数用于使用承诺链加载TODO列表项。 执行<code>fetch()</code> ，将返回具有许多属性的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">响应</a> ，我们对以下属性感兴趣： <br><br><ul><li>  <code>status</code>是一个数字值，代表HTTP状态代码。 </li><li>  <code>statusText</code> -HTTP状态代码的文本描述，如果请求成功，则由字符串<code>OK</code>表示。 </li></ul><br>  <code>response</code>对象具有一个<code>json()</code>方法，该方法返回一个Promise，根据其解析度，将以JSON格式呈现请求主体的已处理内容。 <br><br> 鉴于以上所述，我们描述了这段代码中发生的事情。 链中的第一个承诺由我们宣布的<code>status()</code>函数表示，该函数检查响应的状态，如果它指示请求失败（即HTTP状态代码不在200到299之间），则该承诺将被拒绝。 此操作导致以下事实：未执行promise链中的其他<code>.then()</code>表达式，我们立即进入<code>.catch()</code>方法，将其与错误消息一起输出到控制台，并显示文本<code>Request failed</code> 。 <br><br> 如果HTTP状态代码适合我们，则调用我们声明的<code>json()</code>函数。 由于上一个承诺（如果成功解析）将返回一个<code>response</code>对象，因此我们将其用作第二个承诺的输入值。 <br><br> 在这种情况下，我们将返回已处理的JSON数据，因此第三个承诺将收到该数据，然后在它们之前，在控制台中显示一条消息，该消息是由于请求而可能获取必要数据的结果。 <br><br><h4> 错误处理 </h4><br> 在前面的示例中，我们在承诺链上附加了<code>.catch()</code>方法。 如果承诺链中的某些地方出错并发生错误，或者某个承诺被拒绝， <code>.catch()</code>控制权转移到最近的表达式<code>.catch()</code> 。 这是诺言中发生错误的情况： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br> 这是一个拒绝承诺后触发<code>.catch()</code>的示例： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4> 级联错误处理 </h4><br> 如果<code>.catch()</code>表达式中发生错误怎么办？ 要处理此错误，您可以在promise链中包含另一个<code>.catch()</code>表达式（然后可以根据需要将尽可能多的<code>.catch()</code>表达式附加到链中）： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br> 现在让我们看一些用于管理诺言的有用方法。 <br><br><h4>  Promise.all（） </h4><br> 如果您需要在解决多个承诺后执行某些操作，则可以使用<code>Promise.all()</code>命令执行此操作。 考虑一个例子： <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br> 在ES2015中，出现了破坏性分配的语法；使用它，您可以创建以下形式的构造： <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br> 在这里，作为示例，我们考虑了API Fetch，但是<code>Promise.all()</code>当然允许您使用任何promise。 <br><br><h4>  Promise.race（） </h4><br>  <code>Promise.race()</code>命令允许您解析传递给它的承诺之一后执行指定的操作。 包含此第一个承诺的结果的相应回调仅被调用一次。 考虑一个例子： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4> 使用Promise时发生未捕获的TypeError错误 </h4><br> 如果在处理<code>new Promise()</code>遇到<code>Uncaught TypeError: undefined is not a promise</code> <code>new Promise()</code>错误，请确保在创建<code>Promise()</code>时使用<code>new Promise()</code>构造，而不仅仅是<code>Promise()</code> 。 <br><br><h3>  <font color="#3AC1EF">▍异步/等待设计</font> </h3><br> 异步/等待构造是一种现代的异步编程方法，可以简化它。 异步功能可以表示为Promise和生成器的组合，通常，这种构造是对Promise的抽象。 <br><br> 异步/等待设计减少了使用Promise时必须编写的样板代码量。 当诺言出现在ES2015标准中时，它们旨在解决创建异步代码的问题。 他们完成了这项任务，但是在两年内，他们共享ES2015和ES2017标准的输出，因此很明显，它们不能被视为解决问题的最终解决方案。 <br><br> 可以解决的问题之一就是著名的“回调地狱”，但是解决这个问题却创造了他们自己类似性质的问题。 <br><br> 承诺是简单的构造，可以使用更简单的语法构建某些内容。 结果，当时间到来时，出现了异步/等待构造。 它的使用使您可以编写看起来像同步的代码，但是它是异步的，尤其是它不会阻塞主线程。 <br><br><h4> 异步/等待构造如何工作 </h4><br> 异步函数返回一个promise，如以下示例所示： <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br> 当需要调用类似的函数时，必须将<code>await</code>关键字放在命令之前。 这将导致调用它的代码等待相应诺言的允许或拒绝。 应该注意的是，必须使用<code>async</code>声明使用<code>await</code>关键字的函数： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br> 合并上面的两个代码片段并检查其行为： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br> 此代码将输出以下内容： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  <code>I did something</code>的文本会延迟3秒进入控制台。 <br><br><h4> 关于承诺和异步功能 </h4><br> 如果您使用<code>async</code>声明某个函数，则这意味着即使未明确完成该函数也将返回promise。 因此，例如，以下示例为有效代码： <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br> 此设计与此类似： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4> 异步/等待的优势 </h4><br> 通过分析以上示例，您可以看到使用async / await的代码比使用promise链接的代码或基于回调函数的代码更简单。 当然，这里我们看了非常简单的例子。 通过使用复杂得多的代码，您可以充分体验上述好处。 例如，这里是如何使用Promise加载和解析JSON数据的方法： <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br> 这是使用async / await解决相同问题的方法： <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4> 使用异步函数中的序列 </h4><br> 异步功能可以轻松地组合成类似于Promise链的设计。 但是，这种结合的结果具有更好的可读性： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br> 此代码将输出以下文本： <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4> 简化调试 </h4><br> 承诺很难调试，因为使用它们您不能有效地使用调试器的常用工具（例如“逐步跳过”，逐步过渡）。 可以使用与常规同步代码相同的方法来调试使用async / await编写的代码。 <br><br><h2>  <font color="#3AC1EF">Node.js中的事件生成</font> </h2><br> 如果您在浏览器中使用JavaScript，那么您就会知道事件在处理用户与页面的交互中起着巨大的作用。 它是关于处理由单击和鼠标移动，键盘上的击键等引起的事件。 在Node.js中，您可以使用程序员自己创建的事件。 在这里，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">events</a>模块创建自己的事件系统。 特别是，此模块为我们提供了<code>EventEmitter</code>类，该类的功能可用于组织事件处理。 使用此机制之前，您需要连接它： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br> 使用它时，我们可以使用<code>on()</code>和<code>emit()</code>方法。  <code>emit</code>方法用于调用事件。  <code>on</code>方法用于配置回调，即在调用特定事件时调用的事件处理程序。 <br><br> 例如，让我们创建一个<code>start</code>事件。 发生这种情况时，我们将向控制台输出一些内容： <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br> 为了触发此事件，使用以下构造： <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br> 执行该命令的结果是，事件处理程序被调用， <code>started</code>的字符串进入控制台。 <br><br> 您可以将参数传递给事件处理程序，将它们表示为<code>emit()</code>方法的附加参数： <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br> 在处理程序需要传递几个参数的情况下，也会发生同样的事情： <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code>类<code>EventEmitter</code>还有一些其他有用的方法： <br><br><ul><li>  <code>once()</code> -允许您注册只能调用一次的事件处理程序。 </li><li>  <code>removeListener()</code> -允许您从传递给它的事件的处理程序数组中删除传递给它的处理程序。 </li><li>  <code>removeAllListeners()</code> -允许您删除传递给它的事件的所有处理程序。 </li></ul><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了JavaScript中的异步编程，尤其是讨论了回调，promise和async / await构造。 在这里，我们谈到了使用<code>events</code>模块处理开发人员描述的<code>events</code> 。 我们的下一个主题将是Node.js平台的网络机制。 <br><br>  <b>亲爱的读者们！</b> 为Node.js编程时，是否使用async / await构造？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424555/">https://habr.com/ru/post/zh-CN424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424539/index.html">Java 11：String中的新增功能</a></li>
<li><a href="../zh-CN424541/index.html">UGJ 2018惨败故事：如何制作没人喜欢的游戏（不要做！）</a></li>
<li><a href="../zh-CN424543/index.html">Java 11 / JDK 11：常规可用性</a></li>
<li><a href="../zh-CN424551/index.html">暖管：关于磁性音频技术的五种法莱卡</a></li>
<li><a href="../zh-CN424553/index.html">Node.js指南，第6部分：事件循环，调用堆栈，计时器</a></li>
<li><a href="../zh-CN424557/index.html">Node.js指南，第8部分：HTTP和WebSocket协议</a></li>
<li><a href="../zh-CN424559/index.html">大数据抵抗1或难以捉摸的乔。 互联网匿名，反检测，针对您和您的反跟踪</a></li>
<li><a href="../zh-CN424563/index.html">直线将对话的详细信息发送给陌生人</a></li>
<li><a href="../zh-CN424565/index.html">概述：房地产场所的3D扫描</a></li>
<li><a href="../zh-CN424567/index.html">在公司的本地网络中阻止在线广告的经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>