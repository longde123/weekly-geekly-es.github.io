<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏾 👋🏼 🚵🏼 Verwenden von X-Macro in modernem C ++ - Code 🌲 🙅🏾 👅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Moderne C ++ - Entwicklungstrends legen nahe, dass Makros im Code maximal abgelehnt werden können. Aber manchmal ohne Makros und in ihrer besonders hä...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von X-Macro in modernem C ++ - Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475162/">  Moderne C ++ - Entwicklungstrends legen nahe, dass Makros im Code maximal abgelehnt werden können.  Aber manchmal ohne Makros und in ihrer besonders hässlichen Erscheinungsform kann man nicht tun, da es ohne sie noch schlimmer ist.  Über dieses und die Geschichte. <br><br>  Wie Sie wissen, ist der erste Schritt beim Kompilieren von C und C ++ der Präprozessor, der die Makros und Präprozessoranweisungen durch Nur-Text ersetzt. <br><br>  Dies ermöglicht es uns, seltsame Dinge zu tun, zum Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// xmacro.h "look, I'm a string!" // xmacro.cpp std::string str = #include "xmacro.h" ;</span></span></code> </pre> <a name="habracut"></a><br>  Nachdem der Präprozessor funktioniert, wird aus diesem Missverständnis der richtige Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = <span class="hljs-string"><span class="hljs-string">"look, I'm a string!"</span></span> ;</code> </pre> <br>  Natürlich kann dieser schreckliche Header nirgendwo anders eingefügt werden.  Und ja, aufgrund der Tatsache, dass wir diesen Header mehrmals in dieselbe Datei einfügen werden - kein #pragma einmal oder Wachen einschließen. <br><br>  Schreiben wir ein komplexeres Beispiel, das mit Hilfe von Makros verschiedene Aufgaben ausführt und sich gleichzeitig gegen zufällige #include verteidigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// xmacro.h #ifndef XMACRO #error "Never include me directly" #endif XMACRO(first) XMACRO(second) #undef XMACRO // xmacro.cpp enum class xenum { #define XMACRO(x) x, #include "xmacro.h" }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, xenum enm) { switch (enm) { #define XMACRO(x) case xenum::x: os &lt;&lt; "xenum::" #x; break; #include "xmacro.h" } return os; }</span></span></code> </pre> <br>  Das ist immer noch hässlich, aber es gibt bereits einen gewissen Reiz: Wenn Sie der enum-Klasse ein neues Element hinzufügen, wird es automatisch zur überladenen output-Anweisung hinzugefügt. <br><br>  Hier können Sie den Anwendungsbereich dieser Methode formalisieren: die Notwendigkeit der Codegenerierung an verschiedenen Stellen aus einer Hand. <br><br>  Und jetzt die traurige Geschichte von X-Macro und Windows.  Es gibt ein solches System wie Windows-Leistungsindikatoren, mit dem Sie bestimmte Leistungsindikatoren an das Betriebssystem senden können, damit andere Anwendungen sie abrufen können.  Zabbix kann beispielsweise so konfiguriert werden, dass Leistungsindikatoren erfasst und überwacht werden.  Dies ist sehr praktisch und Sie müssen das Rad bei der Rückgabe / Abfrage von Daten nicht neu erfinden. <br><br>  Ich dachte aufrichtig, dass das Hinzufügen eines neuen Zählers wie ein HANDLE-Zähler = AddCounter ("Name") aussieht.  Ah, wie falsch ich war. <br><br>  Zuerst müssen Sie ein spezielles XML-Manifest ( <a href="">Beispiel</a> ) schreiben oder es mit dem Programm ecmangen.exe aus dem Windows SDK generieren. Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">irgendeinem Grund wurde</a> dieses ecmangen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch</a> aus den neuen Versionen des Windows 10 SDK entfernt.  Als Nächstes müssen Sie den Code und die RC-Datei mit dem Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ctrpp</a> generieren, das auf unserem XML-Manifest basiert.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Hinzufügen neuer Leistungsindikatoren zum System selbst</a> erfolgt nur mit dem Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lodctr</a> mit unserem XML-Manifest im Argument. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist eine RC-Datei?</b> <div class="spoiler_text">  Dies ist eine Erfindung von Microsoft, die nicht mit Standard-C ++ verwandt ist.  Mithilfe dieser Dateien können Sie Ressourcen in exe \ dll einbetten, z. B. Zeichenfolgen \ Symbole \ Bilder usw., und diese dann mithilfe der speziellen Windows-API abrufen. <br><br>  Perfcounters verwenden diese .rc-Dateien, um Zählernamen zu lokalisieren, und es ist nicht klar, warum diese Namen lokalisiert werden sollten. <br></div></div><br>  Zusammenfassend: Um 1 Zähler hinzuzufügen, benötigen Sie: <br><br><ol><li>  XML-Manifest ändern </li><li>  Generieren Sie neue C- und RC-Projektdateien basierend auf dem Manifest </li><li>  Schreiben Sie eine neue Funktion, die einen neuen Zähler erhöht </li><li>  Schreiben Sie eine neue Funktion, die den Zählerwert übernimmt </li></ol><br>  Insgesamt: 4 bis 5 geänderte Dateien in diff-e, um einen einzigen Zähler und eine Konstante zu erhalten, die unter der Arbeit mit dem XML-Manifest leidet, das die Informationsquelle im Plus-Code ist.  Das bietet uns Microsoft. <br><br>  Tatsächlich sieht die erfundene Lösung beängstigend aus, aber das Hinzufügen eines neuen Zählers erfolgt genau in einer Zeile in einer Datei.  Außerdem wird alles automatisch mithilfe von Makros und leider einem vorab erstellten Skript generiert, da das XML-Manifest weiterhin benötigt wird, obwohl es jetzt nicht das Hauptmanifest ist. <br><br>  Unsere perfcounters_ctr.h sieht fast identisch mit dem obigen Beispiel aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NV_PERFCOUNTER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"You cannot do this!"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> ... NV_PERFCOUNTER(copied_bytes) NV_PERFCOUNTER(copied_files) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> NV_PERFCOUNTER</span></span></code> </pre><br>  Wie ich bereits geschrieben habe, erfolgt das Hinzufügen von Zählern durch Laden des XML-Manifests mit lodctr.exe.  In unserem Programm können wir sie nur initialisieren und ändern. <br><br>  Die für uns interessanten Initialisierungsfragmente im generierten Opener sehen folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPIED_BYTES 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     0 #define COPIED_FILES 1 //      const PERF_COUNTERSET_INFO counterset_info{ ... 2, //    XML-  ... }; struct { PERF_COUNTERSET_INFO set; PERF_COUNTER_INFO counters[2]; //     } counterset { counterset_info, { //     { COPIED_BYTES, ... }, { COPIED_FILES, ... } } }</span></span></span></span></code> </pre> <br>  Total: Wir brauchen eine Entsprechung in der Form "Zählername - Zunehmender Index", und bei der Kompilierung ist es notwendig, die Anzahl der Zähler zu kennen und ein Initialisierungsarray aus den Zählerindizes zu sammeln.  Hier hilft das X-Makro. <br><br>  Die Zuordnung eines Zählernamens zu seinem aufsteigenden Index ist einfach genug. <br><br>  Der folgende Code wird zu einer Aufzählungsklasse, deren interne Indizes bei 0 beginnen und um eins inkrementieren.  Wenn wir das letzte Element mit unseren Händen addieren, finden wir sofort heraus, wie viele Zähler wir insgesamt haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_enum</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NV_PERFCOUNTER(ctr) ctr, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"perfcounters_ctr.h"</span></span></span><span class="hljs-meta"> total_counters };</span></span></code> </pre> <br>  Und basierend auf unserer Aufzählung müssen wir die Zähler initialisieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter_count = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(counter_enum::total_counters); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PERF_COUNTERSET_INFO counterset_info{ ... counter_count, ... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PERF_COUNTERSET_INFO <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; PERF_COUNTER_INFO counters[counter_count]; } counterset { counterset_info, { <span class="hljs-comment"><span class="hljs-comment">//     #define NV_PERFCOUNTER(ctr) \ { static_cast&lt;int&gt;(counter_enum::ctr), ... }, #include "perfcounters_ctr.h" } }</span></span></code> </pre> <br>  Das Ergebnis war, dass die Initialisierung eines neuen Zählers jetzt 1 Zeile dauert und keine zusätzlichen Änderungen in anderen Dateien erfordert (zuvor hat jede Regeneration 3 Codeteile nur bei der Initialisierung geändert). <br><br>  Und fügen wir eine praktische API zum Inkrementieren von Zählern hinzu.  Etwas im Geist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NV_PERFCOUNTER(ctr) \ inline void ctr##_tick(size_t diff = 1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   counter_enum::ctr */</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"perfcounters_ctr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NV_PERFCOUNTER(ctr) \ inline size_t ctr##_get() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    counter_enum::ctr */</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"perfcounter_ctr.h"</span></span></span></span></code> </pre><br>  Der Präprozessor generiert wunderschöne Getter / Setter für uns, die wir sofort im Code verwenden können, zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copied_bytes_tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> diff = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copied_bytes_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  Aber wir haben noch 2 traurige Dinge: das XML-Manifest und die .rc-Datei (leider ist es notwendig). <br><br>  Wir haben es einfach genug gemacht - ein vorgefertigtes Skript, das die Originaldatei mit Makros liest, die Zähler definieren, analysiert, was zwischen "NV_COUNTER (" und ")" liegt, und basierend darauf beide Dateien generiert, die sich in .gitignore befinden Streu keine Unterschiede. <br><br>  <u>Es war</u> : Spezielle Software basierend auf dem XML-Manifest generierten Codierungscode.  Viele Änderungen im Projekt für jedes Hinzufügen / Entfernen des Zählers. <br><br>  Jetzt: Der Präprozessor und das Prebuild-Skript generieren alle Leistungsindikatoren, das XML-Manifest und die RC-Datei.  Genau eine Zeile in diff-e zum Hinzufügen / Entfernen eines Zählers.  Vielen Dank an den Präprozessor, der zur Lösung dieses Problems beigetragen hat und in diesem speziellen Fall mehr Gutes als Schaden angerichtet hat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475162/">https://habr.com/ru/post/de475162/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475142/index.html">Schlaf, Entspannung und Musik: Wie Profisportler Müdigkeit überwinden und was können wir dagegen tun?</a></li>
<li><a href="../de475144/index.html">Teilen Sie Laravel in Komponenten</a></li>
<li><a href="../de475146/index.html">Die Qual oder die lange Geschichte eines Datenwiederherstellungsversuchs</a></li>
<li><a href="../de475154/index.html">Inhouse-Zeitraffer mit IPEYE-Cloud-Überwachungsservice</a></li>
<li><a href="../de475158/index.html">Playme P570 Mono Review: Kurz und bündig</a></li>
<li><a href="../de475164/index.html">Diskussion: Das Internet ist auf Open Source angewiesen - welche Argumente haben Kritiker?</a></li>
<li><a href="../de475166/index.html">Elektronikentwicklung. Projektaudit in Beispielen. Wir sparen die warmen Böden mit allen habr</a></li>
<li><a href="../de475168/index.html">Wechselkursinvestitionen mit geringem Risiko: Verwendung von IIA-Konten und Anleihen als Alternative zu Bankeinlagen</a></li>
<li><a href="../de475170/index.html">Probleme der Grundmuster für die Erstellung datengesteuerter Apps auf React.JS</a></li>
<li><a href="../de475172/index.html">5 Möglichkeiten, den Raspberry Pi vorteilhaft zu nutzen Teil drei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>