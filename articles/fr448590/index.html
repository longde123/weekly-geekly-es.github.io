<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➡️ 🤞🏾 📏 Des inconnus familiers ou encore une fois sur l'utilisation de modèles de conception 🐃 ✖️ 👨🏿‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sur le thème des modèles de conception, des tonnes d'articles ont été écrits et de nombreux livres ont été publiés. Cependant, ce sujet ne cesse d'êtr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des inconnus familiers ou encore une fois sur l'utilisation de modèles de conception</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448590/"><p> Sur le thème des modèles de conception, des tonnes d'articles ont été écrits et de nombreux livres ont été publiés.  Cependant, ce sujet ne cesse d'être pertinent, car les modèles nous permettent d'utiliser des solutions prêtes à l'emploi et éprouvées, ce qui nous permet de réduire le temps de développement du projet en améliorant la qualité du code et en réduisant les dettes techniques. </p><br><p>  Depuis l'avènement des modèles de conception, il existe de nouveaux exemples de leur utilisation efficace.  Et c'est merveilleux.  Cependant, il y avait une mouche dans la pommade: chaque langue a ses propres spécificités.  Et golang - et plus encore (il n'a même pas de modèle OOP classique).  Par conséquent, il existe des variations des modèles, en fonction des langages de programmation individuels.  Dans cet article, je voudrais aborder le sujet des modèles de conception en relation avec le golang. </p><a name="habracut"></a><br><h1>  Décorateur </h1><br><blockquote>  Le modèle Decorator vous permet de connecter un comportement supplémentaire à l'objet (statiquement ou dynamiquement) sans affecter le comportement d'autres objets de la même classe.  Un modèle est souvent utilisé pour adhérer au principe de responsabilité unique, car il vous permet de répartir les fonctionnalités entre les classes pour résoudre des problèmes spécifiques. <br></blockquote><p>  Le modèle DECORATOR bien connu est largement utilisé dans de nombreux langages de programmation.  Ainsi, dans golang, tout middleware est construit sur sa base.  Par exemple, le profilage des requêtes peut ressembler à ceci: </p><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfileMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { started := time.Now() next.ServeHTTP() elapsed := time.Now().Sub(started) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"HTTP: elapsed time %d"</span></span>, elapsed) }</code> </pre> <br><p>  Dans ce cas, l'interface du décorateur est la seule fonction.  En règle générale, cela doit être recherché.  Cependant, un décorateur avec une interface plus large peut parfois être utile.  Par exemple, envisagez l'accès à une base de données (package base de données / sql).  Supposons que nous ayons besoin de faire le même profilage des requêtes de base de données.  Dans ce cas, nous avons besoin de: </p><br><ul><li>  Au lieu d'interagir directement avec la base de données via un pointeur, nous devons passer à l'interaction via une interface (pour séparer le comportement de l'implémentation). </li><li>  Créez un wrapper pour chaque méthode qui exécute une requête de base de données SQL. </li></ul><br><p>  En conséquence, nous obtenons un décorateur qui vous permet de profiler toutes les requêtes dans la base de données.  Les avantages de cette approche sont indéniables: </p><br><ul><li>  Maintient la propreté du code du composant d'accès à la base de données principale. </li><li>  Chaque décorateur met en œuvre une seule exigence.  De ce fait, sa facilité de mise en œuvre est atteinte. </li><li>  En raison de la composition des décorateurs, nous obtenons un modèle extensible qui s'adapte facilement à nos besoins. </li><li>  Nous n'obtenons aucune surcharge de performances en mode production en raison d'un simple arrêt du profileur. </li></ul><br><p>  Ainsi, par exemple, vous pouvez implémenter les types de décorateurs suivants: </p><br><ul><li>  Battement de coeur  Pinging d'une base de données pour maintenir en vie une connexion à celle-ci. </li><li>  Profiler.  La sortie du corps de la demande et de son temps d'exécution. </li><li>  Renifleur.  Collection de métriques de base de données. </li><li>  Clone  Clonage de la base de données d'origine à des fins de débogage. </li></ul><br><p>  En règle générale, lors de l'implémentation de décorateurs riches, l'implémentation de toutes les méthodes n'est pas requise: il suffit de déléguer des méthodes non implémentées à un objet interne. </p><br><p>  Supposons que nous devons implémenter un enregistreur avancé pour suivre les requêtes DML d'une base de données (pour suivre les requêtes INSERT / UPDATE / DELETE).  Dans ce cas, nous n'avons pas besoin d'implémenter l'intégralité de l'interface de la base de données - chevauchons uniquement la méthode Exec. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyDatabase <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Query(...) (sql.Rows, error) QueryRow(...) error Exec(query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>) error Ping() error } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyExecutor <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MyDatabase } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *MyExecutor)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ... }</code> </pre> <br><p>  Ainsi, nous voyons que créer même un riche décorateur dans la langue golang n'est pas particulièrement difficile. </p><br><h1>  Méthode de modèle </h1><br><blockquote>  Méthode de modèle (méthode de modèle Eng) - un modèle de conception comportementale qui définit la base de l'algorithme et permet aux héritiers de redéfinir certaines étapes de l'algorithme sans changer sa structure dans son ensemble. <br></blockquote><p>  Le langage golang prend en charge le paradigme OOP, ce modèle ne peut donc pas être implémenté dans sa forme pure.  Cependant, rien ne nous empêche d'improviser des constructeurs en utilisant des fonctions adaptées. </p><br><p>  Supposons que nous devons définir une méthode de modèle avec la signature suivante: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  Lors de la déclaration, il nous suffit d'utiliser un champ de type fonctionnel.  Pour plus de commodité, nous pouvons utiliser la fonction wrapper pour compléter l'appel avec le paramètre manquant et pour créer une instance spécifique, la fonction constructeur correspondante. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MethodImpl <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(me *MyStruct, s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ms *MyStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.MethodImpl(ms, s) } <span class="hljs-comment"><span class="hljs-comment">// First constructor func NewStruct1() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 1 ... }, } } // Second constructor func NewStruct2() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 2 ... }, } } func main() { // Create object instance o := NewStruct2() // Call the template method err := o.Method("hello") ... }</span></span></code> </pre> <br><p>  Comme vous pouvez le voir dans l'exemple, la sémantique d'utilisation du modèle n'est presque pas différente de la POO classique. </p><br><h1>  Adaptateur </h1><br><blockquote>  Le modèle de conception «Adaptateur» vous permet d'utiliser l'interface d'une classe existante comme une autre interface.  Ce modèle est souvent utilisé pour garantir que certaines classes fonctionnent avec d'autres sans modifier leur code source. <br></blockquote><p>  En général, les adaptateurs peuvent servir de fonctions distinctes et d'interfaces entières.  Si avec les interfaces tout est plus ou moins clair et prévisible, alors du point de vue des fonctions individuelles il y a des subtilités. </p><br><p>  Supposons que nous écrivions un service qui possède une API interne: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(ctx context.Context, order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  Si nous devons fournir une API publique avec une interface différente (par exemple pour travailler avec gRPC), nous pouvons simplement utiliser les fonctions d'adaptateur qui traitent de la conversion de l'interface.  Il est très pratique d'utiliser des fermetures à cet effet. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRequest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span></span> { Order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CreateResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s MyService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Decode request req := request.(CreateRequest) // Call service method id, err := s.Create(ctx, req.Order) // Encode response return CreateResponse{ID: id, Err: err}, nil } }</span></span></code> </pre> <br><p>  La fonction makeCreateEndpoint comporte trois étapes standard: </p><br><ul><li>  valeurs de décodage </li><li>  appel d'une méthode à partir de l'API interne du service implémenté </li><li>  encodage de valeur </li></ul><br><p>  Tous les points de terminaison dans le package gokit sont construits sur ce principe. </p><br><h1>  Visiteur </h1><br><blockquote>  Le modèle «Visiteur» est un moyen de séparer l'algorithme de la structure de l'objet dans lequel il opère.  Le résultat de la séparation est la possibilité d'ajouter de nouvelles opérations aux structures d'objets existantes sans les modifier.  C'est une façon de se conformer au principe ouvert / fermé. <br></blockquote><p>  Considérez le modèle de visiteur bien connu sur l'exemple des formes géométriques. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Geometry <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Visit(GeometryVisitor) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GeometryVisitor <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { VisitPoint(p *Point) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitLine(l *Line) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitCircle(c *Circle) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Point <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitPoint(point) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Line <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X1, Y1 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> X2, Y2 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitLine(line) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Circle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y, R <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(circle *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitCircle(circle) }</code> </pre> <br><p>  Supposons que nous voulons écrire une stratégie pour calculer la distance d'un point donné à une forme spécifiée. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DistanceStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *DistanceStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance from point(X, Y) to point p } func (s *DistanceStrategy) VisitLine(l *Line) (interface{}, error) { // Evaluate distance from point(X, Y) to line l } func (s *DistanceStrategy) VisitCircle(c *Circle) (interface{}, error) { // Evaluate distance from point(X, Y) to circle c } func main() { s := &amp;DistanceStrategy{X: 1, Y: 2} p := &amp;Point{X: 3, Y: 4} res, err := p.Visit(s) if err != nil { panic(err) } fmt.Printf("Distance is %g", res.(float32)) }</span></span></code> </pre> <br><p>  De même, nous pouvons mettre en œuvre d'autres stratégies dont nous avons besoin: </p><br><ul><li>  Étendue verticale </li><li>  L'étendue horizontale de l'objet </li><li>  Construire un carré couvrant minimum (MBR) </li><li>  D'autres primitives dont nous avons besoin. </li></ul><br><p>  De plus, les figures préalablement définies (Point, Ligne, Cercle ...) ne savent rien de ces stratégies.  Leur seule connaissance se limite à l'interface GeometryVisitor.  Cela vous permet de les isoler dans un package séparé. </p><br><p>  À une certaine époque, alors que je travaillais sur un projet cartographique, j'ai eu la tâche d'écrire une fonction pour déterminer la distance entre deux objets géographiques arbitraires.  Les solutions étaient très différentes, mais toutes n'étaient pas assez efficaces et élégantes.  Considérant en quelque sorte le modèle Visitor, j'ai remarqué qu'il sert à sélectionner la méthode cible et ressemble un peu à une étape de récursivité distincte, ce qui, comme vous le savez, simplifie la tâche.  Cela m'a incité à utiliser Double Visitor.  Imaginez ma surprise quand j'ai découvert qu'une telle approche n'est pas du tout mentionnée sur Internet. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> geometryStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ G Geometry } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;pointStrategy{Point: p}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;lineStrategy{Line: l}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;circleStrategy{Circle: c}) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> pointStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Point } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *pointStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance between point and p } func (point *pointStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between point and l } func (point *pointStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between point and c } type lineStrategy struct { *Line } func (line *lineStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between line and p } func (line *lineStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between line and l } func (line *lineStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between line and c } type circleStrategy struct { *Circle } func (circle *circleStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between circle and p } func (circle *circleStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between circle and l } func (circle *circleStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between circle and c } func Distance(a, b Geometry) (float32, error) { return a.Visit(&amp;geometryStrategy{G: b}) }</span></span></code> </pre> <br><p>  Ainsi, nous avons construit un mécanisme sélectif à deux niveaux, qui, à la suite de ses travaux, appellera la méthode appropriée pour calculer la distance entre deux primitives.  Nous ne pouvons qu'écrire ces méthodes et l'objectif est atteint.  C'est ainsi qu'un problème élégamment non déterministe peut être réduit à un certain nombre de fonctions élémentaires. </p><br><h1>  Conclusion </h1><br><p>  Malgré le fait qu'il n'y ait pas de POO classique dans le golang, la langue produit son propre dialecte de motifs qui jouent sur les forces de la langue.  Ces modèles vont de la manière standard du déni à l'acceptation universelle et deviennent les meilleures pratiques au fil du temps. </p><br><p>  Si les habrozhiteli respectés ont des réflexions sur les modèles, n'hésitez pas à exprimer vos pensées à ce sujet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448590/">https://habr.com/ru/post/fr448590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448576/index.html">Transistor Story Part 2: Du creuset de la guerre</a></li>
<li><a href="../fr448580/index.html">CQ CQ CQ Joyeuses Fêtes, Radio Amateur! #WorldAmateurRadioDay</a></li>
<li><a href="../fr448582/index.html">Créer une calculatrice de pourboires sur Kotlin: comment ça marche?</a></li>
<li><a href="../fr448584/index.html">7 erreurs courantes lors de l'utilisation de prépositions en anglais et comment les éviter</a></li>
<li><a href="../fr448588/index.html">L'architecture de l'équilibreur de charge réseau dans Yandex.Cloud</a></li>
<li><a href="../fr448594/index.html">Antivirus et pare-feu gratuits (UTM, NGFW) de Sophos</a></li>
<li><a href="../fr448596/index.html">Porte-tablette sur tapis roulant ou recherchez des étapes gratuites</a></li>
<li><a href="../fr448600/index.html">Comment Windows 10 Explore une vulnérabilité critique DHCP détecte deux autres erreurs de sécurité</a></li>
<li><a href="../fr448602/index.html">La surveillance est-elle morte? - Surveillance longue durée</a></li>
<li><a href="../fr448606/index.html">Sidorin: KnowledgeConf est sur la façon de maintenir les connaissances avec une durée moyenne de travail en un seul endroit en 2-3 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>