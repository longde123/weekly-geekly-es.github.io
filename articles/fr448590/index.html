<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û°Ô∏è ü§ûüèæ üìè Des inconnus familiers ou encore une fois sur l'utilisation de mod√®les de conception üêÉ ‚úñÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sur le th√®me des mod√®les de conception, des tonnes d'articles ont √©t√© √©crits et de nombreux livres ont √©t√© publi√©s. Cependant, ce sujet ne cesse d'√™tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des inconnus familiers ou encore une fois sur l'utilisation de mod√®les de conception</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448590/"><p> Sur le th√®me des mod√®les de conception, des tonnes d'articles ont √©t√© √©crits et de nombreux livres ont √©t√© publi√©s.  Cependant, ce sujet ne cesse d'√™tre pertinent, car les mod√®les nous permettent d'utiliser des solutions pr√™tes √† l'emploi et √©prouv√©es, ce qui nous permet de r√©duire le temps de d√©veloppement du projet en am√©liorant la qualit√© du code et en r√©duisant les dettes techniques. </p><br><p>  Depuis l'av√®nement des mod√®les de conception, il existe de nouveaux exemples de leur utilisation efficace.  Et c'est merveilleux.  Cependant, il y avait une mouche dans la pommade: chaque langue a ses propres sp√©cificit√©s.  Et golang - et plus encore (il n'a m√™me pas de mod√®le OOP classique).  Par cons√©quent, il existe des variations des mod√®les, en fonction des langages de programmation individuels.  Dans cet article, je voudrais aborder le sujet des mod√®les de conception en relation avec le golang. </p><a name="habracut"></a><br><h1>  D√©corateur </h1><br><blockquote>  Le mod√®le Decorator vous permet de connecter un comportement suppl√©mentaire √† l'objet (statiquement ou dynamiquement) sans affecter le comportement d'autres objets de la m√™me classe.  Un mod√®le est souvent utilis√© pour adh√©rer au principe de responsabilit√© unique, car il vous permet de r√©partir les fonctionnalit√©s entre les classes pour r√©soudre des probl√®mes sp√©cifiques. <br></blockquote><p>  Le mod√®le DECORATOR bien connu est largement utilis√© dans de nombreux langages de programmation.  Ainsi, dans golang, tout middleware est construit sur sa base.  Par exemple, le profilage des requ√™tes peut ressembler √† ceci: </p><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfileMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { started := time.Now() next.ServeHTTP() elapsed := time.Now().Sub(started) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"HTTP: elapsed time %d"</span></span>, elapsed) }</code> </pre> <br><p>  Dans ce cas, l'interface du d√©corateur est la seule fonction.  En r√®gle g√©n√©rale, cela doit √™tre recherch√©.  Cependant, un d√©corateur avec une interface plus large peut parfois √™tre utile.  Par exemple, envisagez l'acc√®s √† une base de donn√©es (package base de donn√©es / sql).  Supposons que nous ayons besoin de faire le m√™me profilage des requ√™tes de base de donn√©es.  Dans ce cas, nous avons besoin de: </p><br><ul><li>  Au lieu d'interagir directement avec la base de donn√©es via un pointeur, nous devons passer √† l'interaction via une interface (pour s√©parer le comportement de l'impl√©mentation). </li><li>  Cr√©ez un wrapper pour chaque m√©thode qui ex√©cute une requ√™te de base de donn√©es SQL. </li></ul><br><p>  En cons√©quence, nous obtenons un d√©corateur qui vous permet de profiler toutes les requ√™tes dans la base de donn√©es.  Les avantages de cette approche sont ind√©niables: </p><br><ul><li>  Maintient la propret√© du code du composant d'acc√®s √† la base de donn√©es principale. </li><li>  Chaque d√©corateur met en ≈ìuvre une seule exigence.  De ce fait, sa facilit√© de mise en ≈ìuvre est atteinte. </li><li>  En raison de la composition des d√©corateurs, nous obtenons un mod√®le extensible qui s'adapte facilement √† nos besoins. </li><li>  Nous n'obtenons aucune surcharge de performances en mode production en raison d'un simple arr√™t du profileur. </li></ul><br><p>  Ainsi, par exemple, vous pouvez impl√©menter les types de d√©corateurs suivants: </p><br><ul><li>  Battement de coeur  Pinging d'une base de donn√©es pour maintenir en vie une connexion √† celle-ci. </li><li>  Profiler.  La sortie du corps de la demande et de son temps d'ex√©cution. </li><li>  Renifleur.  Collection de m√©triques de base de donn√©es. </li><li>  Clone  Clonage de la base de donn√©es d'origine √† des fins de d√©bogage. </li></ul><br><p>  En r√®gle g√©n√©rale, lors de l'impl√©mentation de d√©corateurs riches, l'impl√©mentation de toutes les m√©thodes n'est pas requise: il suffit de d√©l√©guer des m√©thodes non impl√©ment√©es √† un objet interne. </p><br><p>  Supposons que nous devons impl√©menter un enregistreur avanc√© pour suivre les requ√™tes DML d'une base de donn√©es (pour suivre les requ√™tes INSERT / UPDATE / DELETE).  Dans ce cas, nous n'avons pas besoin d'impl√©menter l'int√©gralit√© de l'interface de la base de donn√©es - chevauchons uniquement la m√©thode Exec. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyDatabase <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Query(...) (sql.Rows, error) QueryRow(...) error Exec(query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>) error Ping() error } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyExecutor <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MyDatabase } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *MyExecutor)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ... }</code> </pre> <br><p>  Ainsi, nous voyons que cr√©er m√™me un riche d√©corateur dans la langue golang n'est pas particuli√®rement difficile. </p><br><h1>  M√©thode de mod√®le </h1><br><blockquote>  M√©thode de mod√®le (m√©thode de mod√®le Eng) - un mod√®le de conception comportementale qui d√©finit la base de l'algorithme et permet aux h√©ritiers de red√©finir certaines √©tapes de l'algorithme sans changer sa structure dans son ensemble. <br></blockquote><p>  Le langage golang prend en charge le paradigme OOP, ce mod√®le ne peut donc pas √™tre impl√©ment√© dans sa forme pure.  Cependant, rien ne nous emp√™che d'improviser des constructeurs en utilisant des fonctions adapt√©es. </p><br><p>  Supposons que nous devons d√©finir une m√©thode de mod√®le avec la signature suivante: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  Lors de la d√©claration, il nous suffit d'utiliser un champ de type fonctionnel.  Pour plus de commodit√©, nous pouvons utiliser la fonction wrapper pour compl√©ter l'appel avec le param√®tre manquant et pour cr√©er une instance sp√©cifique, la fonction constructeur correspondante. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MethodImpl <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(me *MyStruct, s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ms *MyStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.MethodImpl(ms, s) } <span class="hljs-comment"><span class="hljs-comment">// First constructor func NewStruct1() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 1 ... }, } } // Second constructor func NewStruct2() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 2 ... }, } } func main() { // Create object instance o := NewStruct2() // Call the template method err := o.Method("hello") ... }</span></span></code> </pre> <br><p>  Comme vous pouvez le voir dans l'exemple, la s√©mantique d'utilisation du mod√®le n'est presque pas diff√©rente de la POO classique. </p><br><h1>  Adaptateur </h1><br><blockquote>  Le mod√®le de conception ¬´Adaptateur¬ª vous permet d'utiliser l'interface d'une classe existante comme une autre interface.  Ce mod√®le est souvent utilis√© pour garantir que certaines classes fonctionnent avec d'autres sans modifier leur code source. <br></blockquote><p>  En g√©n√©ral, les adaptateurs peuvent servir de fonctions distinctes et d'interfaces enti√®res.  Si avec les interfaces tout est plus ou moins clair et pr√©visible, alors du point de vue des fonctions individuelles il y a des subtilit√©s. </p><br><p>  Supposons que nous √©crivions un service qui poss√®de une API interne: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(ctx context.Context, order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  Si nous devons fournir une API publique avec une interface diff√©rente (par exemple pour travailler avec gRPC), nous pouvons simplement utiliser les fonctions d'adaptateur qui traitent de la conversion de l'interface.  Il est tr√®s pratique d'utiliser des fermetures √† cet effet. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRequest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span></span> { Order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CreateResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s MyService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Decode request req := request.(CreateRequest) // Call service method id, err := s.Create(ctx, req.Order) // Encode response return CreateResponse{ID: id, Err: err}, nil } }</span></span></code> </pre> <br><p>  La fonction makeCreateEndpoint comporte trois √©tapes standard: </p><br><ul><li>  valeurs de d√©codage </li><li>  appel d'une m√©thode √† partir de l'API interne du service impl√©ment√© </li><li>  encodage de valeur </li></ul><br><p>  Tous les points de terminaison dans le package gokit sont construits sur ce principe. </p><br><h1>  Visiteur </h1><br><blockquote>  Le mod√®le ¬´Visiteur¬ª est un moyen de s√©parer l'algorithme de la structure de l'objet dans lequel il op√®re.  Le r√©sultat de la s√©paration est la possibilit√© d'ajouter de nouvelles op√©rations aux structures d'objets existantes sans les modifier.  C'est une fa√ßon de se conformer au principe ouvert / ferm√©. <br></blockquote><p>  Consid√©rez le mod√®le de visiteur bien connu sur l'exemple des formes g√©om√©triques. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Geometry <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Visit(GeometryVisitor) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GeometryVisitor <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { VisitPoint(p *Point) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitLine(l *Line) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitCircle(c *Circle) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Point <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitPoint(point) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Line <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X1, Y1 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> X2, Y2 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitLine(line) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Circle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y, R <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(circle *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitCircle(circle) }</code> </pre> <br><p>  Supposons que nous voulons √©crire une strat√©gie pour calculer la distance d'un point donn√© √† une forme sp√©cifi√©e. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DistanceStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *DistanceStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance from point(X, Y) to point p } func (s *DistanceStrategy) VisitLine(l *Line) (interface{}, error) { // Evaluate distance from point(X, Y) to line l } func (s *DistanceStrategy) VisitCircle(c *Circle) (interface{}, error) { // Evaluate distance from point(X, Y) to circle c } func main() { s := &amp;DistanceStrategy{X: 1, Y: 2} p := &amp;Point{X: 3, Y: 4} res, err := p.Visit(s) if err != nil { panic(err) } fmt.Printf("Distance is %g", res.(float32)) }</span></span></code> </pre> <br><p>  De m√™me, nous pouvons mettre en ≈ìuvre d'autres strat√©gies dont nous avons besoin: </p><br><ul><li>  √âtendue verticale </li><li>  L'√©tendue horizontale de l'objet </li><li>  Construire un carr√© couvrant minimum (MBR) </li><li>  D'autres primitives dont nous avons besoin. </li></ul><br><p>  De plus, les figures pr√©alablement d√©finies (Point, Ligne, Cercle ...) ne savent rien de ces strat√©gies.  Leur seule connaissance se limite √† l'interface GeometryVisitor.  Cela vous permet de les isoler dans un package s√©par√©. </p><br><p>  √Ä une certaine √©poque, alors que je travaillais sur un projet cartographique, j'ai eu la t√¢che d'√©crire une fonction pour d√©terminer la distance entre deux objets g√©ographiques arbitraires.  Les solutions √©taient tr√®s diff√©rentes, mais toutes n'√©taient pas assez efficaces et √©l√©gantes.  Consid√©rant en quelque sorte le mod√®le Visitor, j'ai remarqu√© qu'il sert √† s√©lectionner la m√©thode cible et ressemble un peu √† une √©tape de r√©cursivit√© distincte, ce qui, comme vous le savez, simplifie la t√¢che.  Cela m'a incit√© √† utiliser Double Visitor.  Imaginez ma surprise quand j'ai d√©couvert qu'une telle approche n'est pas du tout mentionn√©e sur Internet. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> geometryStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ G Geometry } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;pointStrategy{Point: p}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;lineStrategy{Line: l}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;circleStrategy{Circle: c}) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> pointStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Point } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *pointStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance between point and p } func (point *pointStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between point and l } func (point *pointStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between point and c } type lineStrategy struct { *Line } func (line *lineStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between line and p } func (line *lineStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between line and l } func (line *lineStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between line and c } type circleStrategy struct { *Circle } func (circle *circleStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between circle and p } func (circle *circleStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between circle and l } func (circle *circleStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between circle and c } func Distance(a, b Geometry) (float32, error) { return a.Visit(&amp;geometryStrategy{G: b}) }</span></span></code> </pre> <br><p>  Ainsi, nous avons construit un m√©canisme s√©lectif √† deux niveaux, qui, √† la suite de ses travaux, appellera la m√©thode appropri√©e pour calculer la distance entre deux primitives.  Nous ne pouvons qu'√©crire ces m√©thodes et l'objectif est atteint.  C'est ainsi qu'un probl√®me √©l√©gamment non d√©terministe peut √™tre r√©duit √† un certain nombre de fonctions √©l√©mentaires. </p><br><h1>  Conclusion </h1><br><p>  Malgr√© le fait qu'il n'y ait pas de POO classique dans le golang, la langue produit son propre dialecte de motifs qui jouent sur les forces de la langue.  Ces mod√®les vont de la mani√®re standard du d√©ni √† l'acceptation universelle et deviennent les meilleures pratiques au fil du temps. </p><br><p>  Si les habrozhiteli respect√©s ont des r√©flexions sur les mod√®les, n'h√©sitez pas √† exprimer vos pens√©es √† ce sujet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448590/">https://habr.com/ru/post/fr448590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448576/index.html">Transistor Story Part 2: Du creuset de la guerre</a></li>
<li><a href="../fr448580/index.html">CQ CQ CQ Joyeuses F√™tes, Radio Amateur! #WorldAmateurRadioDay</a></li>
<li><a href="../fr448582/index.html">Cr√©er une calculatrice de pourboires sur Kotlin: comment √ßa marche?</a></li>
<li><a href="../fr448584/index.html">7 erreurs courantes lors de l'utilisation de pr√©positions en anglais et comment les √©viter</a></li>
<li><a href="../fr448588/index.html">L'architecture de l'√©quilibreur de charge r√©seau dans Yandex.Cloud</a></li>
<li><a href="../fr448594/index.html">Antivirus et pare-feu gratuits (UTM, NGFW) de Sophos</a></li>
<li><a href="../fr448596/index.html">Porte-tablette sur tapis roulant ou recherchez des √©tapes gratuites</a></li>
<li><a href="../fr448600/index.html">Comment Windows 10 Explore une vuln√©rabilit√© critique DHCP d√©tecte deux autres erreurs de s√©curit√©</a></li>
<li><a href="../fr448602/index.html">La surveillance est-elle morte? - Surveillance longue dur√©e</a></li>
<li><a href="../fr448606/index.html">Sidorin: KnowledgeConf est sur la fa√ßon de maintenir les connaissances avec une dur√©e moyenne de travail en un seul endroit en 2-3 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>