<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± üëü üëø Fil d'Ariane: comment tomber amoureux de JSR-133. Rapport Yandex üôéüèº ‚Ü™Ô∏è üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les processeurs multic≈ìurs sont courants. T√¥t ou tard, tout programmeur pratique devra entrer dans le d√©dale de la programmation multi-thread et renco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fil d'Ariane: comment tomber amoureux de JSR-133. Rapport Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/477074/">  Les processeurs multic≈ìurs sont courants.  T√¥t ou tard, tout programmeur pratique devra entrer dans le d√©dale de la programmation multi-thread et rencontrer les "monstres" qui l'habitent.  Parlons par o√π commencer de cette fa√ßon et quels outils et approches aideront √† sortir victorieux.  J'ai fait ce rapport aux futurs participants au <a href="https://ya.cc/7w_Dq">stage √†</a> l' <a href="https://ya.cc/7w_Dq">ann√©e</a> de Yandex. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/veYXsOlYb2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Je m'appelle Seva Minkov.  Je travaille au sein du d√©partement infrastructure cloud du service recherche.  Je m'occupe principalement du backend.  J'√©cris dans diff√©rents langages, mais le plus souvent, c'est Java et les langages fonctionnant sur la machine virtuelle Java (JVM). <br><a name="habracut"></a><br>  Notre √©quipe d√©veloppe un cloud interne dans lequel presque tous les services Yandex sont lanc√©s - tous deux connus publiquement tels que Search, Mail et Alice, ainsi que divers services internes, machines virtuelles, ainsi que des t√¢ches MapReduce de courte dur√©e et des t√¢ches d'apprentissage automatique. <br><br>  Notre cloud n'est pas statique: l'entreprise se d√©veloppe, le nombre de services et les ressources qu'ils consomment augmentent.  Et notre √©quipe est tr√®s souvent confront√©e aux d√©fis de l'√©volutivit√© et de l'am√©lioration des performances.  Nous y parvenons en utilisant tous les outils disponibles, y compris la mise √† l'√©chelle verticale, c'est-√†-dire en acc√©l√©rant les composants individuels du syst√®me jusqu'√† la r√©√©criture de certains algorithmes √† un seul thread afin qu'ils fonctionnent plus rapidement.  Nous effectuons une mise √† l'√©chelle horizontale: √©craser le syst√®me en petites pi√®ces afin d'obtenir de meilleures performances en ajoutant des serveurs, des processeurs, des c≈ìurs, etc. <br><br>  Et la programmation multithread nous aide beaucoup dans ce domaine.  Nous parlerons de lui aujourd'hui - d‚Äôo√π cela vient-il, pourquoi est-il pertinent;  qu'est-ce qu'un mod√®le de m√©moire et comment est-il g√©n√©ralement repr√©sent√© en Java?  Nous aborderons certains aspects pratiques de la fa√ßon de tester vos applications et de v√©rifier leur exactitude. <br><br><img src="https://habrastorage.org/webt/me/f6/9z/mef69z0p-acv-chewvn7tuhphpk.jpeg"><br><br>  Pour commencer, regardons ce graphique int√©ressant, qui montre les tendances des caract√©ristiques des microprocesseurs au cours des 40 derni√®res ann√©es.  Il y a environ 10 √† 15 ans, lorsque l'herbe √©tait plus verte et que les processeurs √©taient √† un seul thread, un programmeur ordinaire pouvait une fois √©crire un programme √† un seul thread correct, puis s'appuyer sur la loi empirique de Moore.  Il dit que les processeurs sont deux fois plus rapides tous les deux ans.  Comme vous pouvez le constater, vers 2005, pour diverses raisons, les fabricants de microprocesseurs sont pass√©s √† une architecture multic≈ìur et ont commenc√© √† augmenter le nombre de c≈ìurs logiques.  Et le gain de performances d'un seul c≈ìur a cess√© d'ob√©ir √† la loi de Moore, et la puissance de traitement d'un c≈ìur a commenc√© √† cro√Ætre plus lentement.  Cela a fait une r√©volution, et les programmeurs ordinaires ont d√ª utiliser la programmation parall√®le pour utiliser ce gain de performances. <br><br>  Puisque nous nous entra√Ænons, nous allons essayer d'√©crire un simple programme multi-thread et de voir par vous-m√™me comment cela fonctionne. <br><br><img src="https://habrastorage.org/webt/rl/tv/gz/rltvgzwhsnhczo7tlpu5otwekuw.jpeg"><br><br>  √Ä titre d'exemple, prenons une t√¢che assez simple de lecture crois√©e d'enregistrements.  Ayons deux variables partag√©es X et Y, d'abord initialis√©es avec la valeur par d√©faut (z√©ro), et deux flux.  Chaque thread √©crit dans une variable et en lit une autre.  Dans ce cas, Thread1 √©crit une unit√© en X et lit Y. Le deuxi√®me thread fait de m√™me, uniquement √† l'envers. <br><br>  Une impl√©mentation Java simple pourrait ressembler √† ceci. <br><br><img src="https://habrastorage.org/webt/xz/dw/8g/xzdw8gsz8vr8f2p-0dvtdr1y6qw.jpeg"><br><br>  Nous allons √©crire la classe ReadWriteTest, elle aura deux variables statiques X et Y. Directement dans la m√©thode principale, nous construisons deux threads Thread1 et Thread2, donnons √† chacun d'entre eux une fonction lambda qui sera ex√©cut√©e au moment de l'ex√©cution du thread.  Mettez-y le code de la diapositive pr√©c√©dente et d√©marrez deux threads. <br><br>  L'ordre dans lequel les threads commencent est, dans un sens, impr√©visible.  Cela d√©pend de la fa√ßon dont le syst√®me d'exploitation threads threads.  En cons√©quence, nous pouvons avoir diff√©rentes versions.  Il semble comprendre comment tout cela fonctionne, nous devrons ex√©cuter ce programme plusieurs fois, puis agr√©ger la sortie et voir √† quelle fr√©quence telle ou telle r√©ponse sera trouv√©e dans le programme. <br><br><img src="https://habrastorage.org/webt/ij/os/e3/ijose3q1hdbyts7brwd31pujhou.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Lien depuis la diapositive</a></sub></sup> </h5><br>  Afin de ne pas r√©inventer la roue, nous pouvons utiliser un outil pr√™t √† l'emploi.  Cela s'appelle jcstress, l'utilitaire de tests de stress de concurrence Java qui fait partie du projet OpenJDK. <br><br>  Cet utilitaire fournit un cadre pour l'√©criture de tests de r√©sistance.  Dans ce cas, le code de la diapositive pr√©c√©dente est assez facilement r√©√©crit.  Tout d'abord, nous accrocherons l'annotation jcstress Test √† la classe, ce qui rendra simplement nos scripts de test visibles √† l'utilitaire.  Nous le marquons √©galement avec la classe State, qui indique que la classe contient des donn√©es qui peuvent changer: √† la fois en cours de modification et en lecture √† partir de diff√©rents flux.  Nous d√©clarons deux m√©thodes, thread1 et thread2, et les marquons avec l'annotation Actor.  L'annotation d'acteur signifie que la m√©thode doit √™tre ex√©cut√©e dans un thread s√©par√©.  jcstress garantit que chacune de ces m√©thodes sera ex√©cut√©e dans un thread s√©par√© sur exactement une instance de la classe State.  L'ordre dans lequel ils seront lanc√©s n'est pas sp√©cifiquement sp√©cifi√©.  Et le r√©sultat sera √©crit dans un objet II_Result montr√© sur la diapositive.  Nous pouvons supposer qu'il s'agit d'un tuple de deux valeurs num√©riques, qui sont pr√©sent√©es uniquement par la m√©thode de l'injection de d√©pendance, dont Cyril a parl√© dans un rapport pr√©c√©dent. <br><br>  Avant de commencer ce test, r√©fl√©chissons aux conclusions que les commandes peuvent donner et aux valeurs que nous pouvons ajouter dans r1 et dans r2. <br><br><img src="https://habrastorage.org/webt/na/ik/dn/naikdng1aeysfm7tc0fe7drjbfs.jpeg"><br><br>  Pour ce faire, nous utilisons le mod√®le dit d'alternance.  D'une mani√®re ou d'une autre, chacune des op√©rations: lire ou √©crire, s'effectue dans un certain ordre.  Il suffit de parcourir toutes ces options et de voir quels r√©sultats nous obtiendrons. <br><br><img src="https://habrastorage.org/webt/i5/4y/fk/i54yfklqj0mjn1jjhkwhqs8vna0.jpeg"><br><br>  Supposons que l'une des variantes possibles des √©v√©nements soit que le thread un soit compl√®tement ex√©cut√© avant le thread deux.  Tout d'abord, nous avons ajout√© un √† X, lu z√©ro √† partir de Y, car il n'y avait aucune entr√©e.  Puis ils en ont √©crit un dans Y et en ont lu un dans X, puisque le premier flux avait d√©j√† r√©ussi √† le faire. <br><br>  La premi√®re r√©ponse est z√©ro. <br><br><img src="https://habrastorage.org/webt/ot/7p/ax/ot7paxx6szikzgwp9xjiusgnfny.jpeg"><br><br>  La deuxi√®me variante du d√©veloppement des √©v√©nements est exactement le contraire: le flux deux a √©t√© ex√©cut√© avant le flux un. <br><br><img src="https://habrastorage.org/webt/_r/b5/sg/_rb5sgbawfh8cczgwyz9yzomji8.jpeg"><br><br>  En cons√©quence, nous obtenons un r√©sultat miroir de un z√©ro. <br><br><img src="https://habrastorage.org/webt/ja/ft/fi/jaftfi3gbc6cwnliw1nufl66x50.jpeg"><br><br>  Il y a environ quatre autres options qui donnent le m√™me r√©sultat lorsque l'ex√©cution des threads est compl√®tement confuse.  Par exemple, nous avons enregistr√© une unit√© dans un flux en X, dans le second, nous avons r√©ussi √† avoir une unit√© en Y, et nous calculons un.  Vous pouvez alors voir quelles autres options sont disponibles comme exercice √† domicile. <br><br><img src="https://habrastorage.org/webt/w2/bf/tr/w2bftrexoxplrdq_v81fuxeoxic.jpeg"><br><br>  Il semble que nous ayons pass√© en revue toutes les options possibles, il n'y a rien de plus.  Lan√ßons l'utilitaire et voyons quelle conclusion il donne. <br><br><img src="https://habrastorage.org/webt/8-/2k/p7/8-2kp79h_iv-0il5eo9ftko91ye.jpeg"><br><h5>  <sup><sub><a href="https://openjdk.java.net/projects/code-tools/jcstress/">Lien depuis la diapositive</a></sub></sup> </h5><br>  La sortie ressemble √† une table.  La premi√®re colonne r√©pertorie les r√©sultats que nous avons ajout√©s dans II_Result - l'utilitaire ex√©cute ce code des millions de fois - et le nombre de cas o√π un r√©sultat particulier a √©t√© rencontr√©.  Mais ce rapport n'aurait probablement pas √©t√© le cas si tout avait √©t√© si simple. <br><br>  En fait, dans cette conclusion, nous pouvons √©galement voir le r√©sultat z√©ro-z√©ro, ce qui est difficile √† expliquer avec le mod√®le d'alternance.  Il semble que l'une des options possibles est que quelqu'un directement dans le code du flux ait pris et r√©organis√© les lignes. <br><br>  Voyons pourquoi cela s'est produit et comment vivre avec.  Je vous demande √©galement de pr√™ter attention au fait que l'option one-one a √©t√© trouv√©e tr√®s rarement sur ma machine.  Sur 130 millions de repr√©sentations, seulement 154 repr√©sentations ont donn√© lieu √† un contre un.  Et au contraire, z√©ro √† z√©ro se produit tr√®s souvent, dans pr√®s de 30% des cas. <br><br><img src="https://habrastorage.org/webt/kw/sb/24/kwsb24gow4nmkjkdtmhzxnnvreo.jpeg"><br><br>  Donc, pour r√©sumer un r√©sultat interm√©diaire que nous avons tous vu avec vous.  Tout d'abord, nous pourrions comprendre que l'interaction des flux √† travers la m√©moire n'est pas triviale.  Le mod√®le de rotation que nous avons utilis√© ne fonctionne pas.  Nous avons vu un certain r√©arrangement.  Cela peut arriver pour plusieurs raisons. <br><br>  Par exemple, nous pourrions voir certains ¬´effets relativistes¬ª du fer.  Cela peut √™tre pens√© dans la veine suivante: dans un cycle d'horloge d'un processeur √† 3 GHz, la lumi√®re parcourt environ 10 cm dans le vide. Le protocole de lecture et d'√©criture dans la m√©moire du processeur est compliqu√© et il faut parfois plusieurs centaines de cycles d'horloge pour transf√©rer la valeur d'un c≈ìur √† un autre.  En cons√©quence, un noyau peut sembler voir le pass√©.  Le r√©sultat apr√®s l'enregistrement s'est produit, mais nous voyons l'ancienne valeur.  De plus, les processeurs ne restent pas immobiles et peuvent modifier les instructions par endroits. <br><br>  Les compilateurs d'optimisation modernes peuvent conduire √† la m√™me permutation.  Pour obtenir des performances monothread maximales, ils peuvent √©galement √©changer des instructions afin que cela ne perturbe pas l'exactitude d'un programme monothread.  Mais dans les programmes multithreads, cela peut conduire √† des effets int√©ressants que nous avons vus. <br><br>  Et la seconde - probablement la principale conclusion: nous avons vu que les programmes multithread ne sont pas fondamentalement d√©termin√©s.  Les programmes √† thread unique reposent principalement sur certains invariants en entr√©e et en sortie et sont d√©terministes;  √©tant donn√© que le g√©n√©rateur de nombres al√©atoires et l'entr√©e utilisateur sont des param√®tres d'entr√©e. <br><br>  Cela rend les choses tr√®s compliqu√©es: il est difficile de comprendre ce que fait le programme et il est difficile de le tester. <br><br>  Concernant la complexit√© des tests, nous pouvons ajouter que le m√™me r√©sultat n'a √©t√© trouv√© que 154 fois sur 130 millions d'appels.  La probabilit√© d'occurrence de ce r√©sultat est d'un millioni√®me.  En production, cela signifie qu'un tel bug peut √™tre reproduit apr√®s des semaines.  Et cela arrivera certainement quelque part dimanche soir, alors que vous ne vous y attendiez pas du tout. <br><br><img src="https://habrastorage.org/webt/sd/u8/hg/sdu8hgj5xiqhrnnganz3ltxzyp0.jpeg"><br><br>  R√©fl√©chissons √† comment nous devrions √™tre et √† ce que nous voulons g√©n√©ralement de notre langue pour dormir paisiblement le dimanche soir.  Premi√®rement, nous avons besoin d'un outil qui nous permet de pr√©dire le comportement du programme et de juger de son ex√©cution.  Deuxi√®mement, nous avons besoin d'outils de langage qui nous permettraient d'influencer les permutations et les effets - ils peuvent provenir du mat√©riel, du compilateur, etc. J'aimerais en savoir moins sur le fonctionnement d'un processeur particulier, les optimisations que le compilateur peut faire et utiliser l'abr√©viation qui venait du monde Java.  √âcrire une fois, ex√©cuter n'importe o√π - √©crivez une fois le code multithread correct pour qu'il fonctionne sur toutes les plateformes. <br><br><img src="https://habrastorage.org/webt/tx/lr/du/txlrdugf3x6nxzxnraij4qn9yzq.jpeg"><br><br>  Ces questions et exigences que nous avons √©num√©r√©es, elles ont surgi dans l'esprit des d√©veloppeurs pendant tr√®s longtemps et des th√©oriciens et praticiens.  Comme toute t√¢che complexe avec un haut niveau de complexit√©, elle a √©t√© r√©solue en introduisant le concept d'une machine abstraite.  Nous tous, d√©veloppeurs de langages de programmation de haut niveau, n'√©crivons pas pour un mat√©riel particulier, pas pour un tel mod√®le de processeur, mais √©crivons une machine abstraite.  Et la sp√©cification du langage est con√ßue pour d√©crire son comportement de mani√®re √† r√©concilier ces trois mondes.  D'une part, laissons les d√©veloppeurs de compilateurs et de processeurs faire leurs optimisations et nous faire l√©g√®rement r√©fl√©chir, programmeurs qui √©crivent d√©j√† dans un langage particulier. <br><br>  Le mod√®le de m√©moire occupe une position centrale dans cette machine abstraite.  Elle devrait r√©pondre √† une question: si je lis une variable X dans un flux, le r√©sultat de laquelle des derni√®res entr√©es puis-je y voir?  Une tentative de formalisation du mod√®le de m√©moire a √©t√© faite pour la premi√®re fois dans le langage Java, tous les autres mod√®les de m√©moire sont apparus plus tard.  Disons que C ++ 11 est presque un copier-coller du mod√®le de m√©moire Java avec quelques modifications. <br><br>  Il y avait plusieurs mod√®les de m√©moire en Java.  Initialement, le mod√®le de m√©moire dit "en forme de cloche", il a √©t√© reconnu comme infructueux, car il g√™nait le travail des programmeurs qui √©crivent en Java et interdisait certaines optimisations au compilateur, qui sont tout √† fait appropri√©es pour elles-m√™mes.  En cons√©quence, dans le cadre du processus communautaire JSR-133, un mod√®le de m√©moire moderne a √©t√© √©crit. <br><br>  Puisque nous avons l'√âcriture sous la forme d'une sp√©cification, essayons de l'examiner et de comprendre ce qui se passe r√©ellement √† l'int√©rieur. <br><br><img src="https://habrastorage.org/webt/3f/w6/qi/3fw6qiwjhoeqgtrdn3jngdqntfs.jpeg"><br><br>  Il y a un probl√®me.  Levez la main, qui a ouvert la sp√©cification de la langue et lu ce qui s'y passait.  Et combien d'entre vous ont lu le mod√®le de m√©moire du paragraphe 17.4?  Une petite surprise vous attend.  La sp√©cification du langage est essentiellement d√©crite dans un langage assez compr√©hensible.  Mais le mod√®le de m√©moire est plein, disons, de hardcore math√©matique.  Il y a des inclusions en grec, beaucoup de termes math√©matiques de la fermeture transitive s√©rie, l'union de deux ordres, etc. <br><br>  Malheureusement, il n'y a pas d'autre moyen.  La seule chose sur laquelle vous pouvez compter lors de l'√©criture de programmes multithread est la sp√©cification.  Elle devra lire et comprendre.  Je vous recommande vivement.  De plus, lorsque j'ai lu la sp√©cification pour la premi√®re fois, j'avais de telles impressions. <br><br>  Pourquoi est-ce si difficile?  J'ai fait le mauvais chemin et je vous pr√©viens vivement d'agir comme moi. <br><br>  Je l'ai pris, j'ai cherch√© sur Internet ce qu'est un mod√®le de m√©moire.  J'ai trouv√© un livre intitul√© JSR-133 Cookbook for Compiler Writers.  Elle d√©crit comment un d√©veloppeur de compilateur peut impl√©menter ce mod√®le de m√©moire de mani√®re simple.  Le probl√®me est qu'il s'agit d'une impl√©mentation sp√©cifique et qu'elle ne peut pas √™tre utilis√©e pour juger l'ensemble du mod√®le de m√©moire en g√©n√©ral. <br><br>  Quoi qu'il en soit, essayons de faire une petite tentative sur les principales conclusions qui peuvent √™tre comprises √† partir du mod√®le de m√©moire Java. <br><br><img src="https://habrastorage.org/webt/ii/tn/by/iitnbypnfohtdb0y3gyxuhv1fea.jpeg"><br><br>  Il peut y avoir de nombreuses ex√©cutions de votre programme multithread.  Nous l'avons vu nous-m√™mes sur l'exemple de notre programme auparavant.  Dans l'exemple le plus simple, nous avons d√©j√† eu quatre r√©sultats de sa mise en ≈ìuvre.  Et la t√¢che du mod√®le de m√©moire Java est de dire lesquelles de ces ex√©cutions sont correctes et lesquelles doivent √™tre interdites.  Et postule trois choses.  La premi√®re est que dans le cadre d'un thread, votre t√¢che est ex√©cut√©e de mani√®re pseudo-s√©quentielle.  Cela implique que le compilateur peut √©changer des op√©rations, le processeur peut √©galement ex√©cuter des instructions en parall√®le, les √©changer.  Mais ils doivent le faire pour que les effets visibles de l'ex√©cution de votre programme soient les m√™mes que s'ils √©taient ex√©cut√©s directement s√©quentiellement. <br><br>  Deuxi√®mement, les soi-disant significations de nulle part prises de nulle part sont interdites dans la langue.  Malheureusement, nous n'avons pas le temps de le montrer, mais il y a des cas o√π le compilateur peut vraiment faire une telle conversion que tout sera correct dans un programme √† un seul thread, et vous pouvez avoir un enregistrement dans un programme √† plusieurs threads que vous n'avez pas fait. <br><br>  Par cons√©quent, le mod√®le de m√©moire indique que la lecture de n'importe quelle variable retournera soit la valeur par d√©faut, soit certains des r√©sultats de l'enregistrement qui a √©t√© effectu√© une fois par une autre commande.  Et les actions restantes peuvent √™tre interpr√©t√©es comme s√©quentielles, si elles sont connect√©es par une relation d'ordre partiel qui se produit avant.  Et c'est maintenant le seul endroit o√π nous avons besoin de math√©matiques.  Relation partielle, c'est parce que toutes les op√©rations de lecture, d'√©criture des variables, elles sont reli√©es par relation.  Il a les propri√©t√©s de r√©flexivit√©, transitivit√© et antisym√©trie. <br><br><img src="https://habrastorage.org/webt/vq/vp/11/vqvp11dmptcgzyedx4hazndvmeo.jpeg"><br><br>  Parlons plus en d√©tail de ce qui se passe avant lui-m√™me.  La premi√®re r√®gle est qu'elle relie toutes les op√©rations au sein d'un m√™me thread.  Si vous avez √©crit dans un thread que X est √©gal √† un, Y est √©gal √† un;  il est indiqu√© que les op√©rations d'√©criture dans X sont li√©es √† ce qui se passe avant Y. C'est-√†-dire que X se produit avant Y. Et il lie √©galement certaines actions sp√©ciales, les actions dites de synchronisation.  En savoir plus dans la sp√©cification.  Par exemple, il s'agit d'√©crire et de lire √† partir d'une variable volatile, de verrouiller / d√©verrouiller sur un moniteur, d'entrer dans le bloc synchronis√© et de sortir du bloc synchronis√©.  Un point tr√®s important est que toutes les actions de synchronisation de votre programme voient les threads exactement dans le m√™me ordre, comme s'ils √©taient ex√©cut√©s un par un. <br><br>  Et arrive-avant relie quelques paires de ces actions.  Peu importe les actions de synchronisation des threads qui ont lieu.  Il est important qu'elles passent, par exemple, sur une variable volatile.  La sp√©cification dit, disons, que l'√©criture dans la variable volatile se produit avant toute autre action ult√©rieure.  Cela se r√©f√®re pr√©cis√©ment √† la mani√®re dont nous avons eu les actions de synchronisation. <br><br>  Et le plus important de tout cela est la r√®gle qui se produit avant la coh√©rence, qui ne fait que r√©pondre √† la question la plus importante sur le mod√®le de m√©moire.  Il peut √™tre interpr√©t√© comme suit.  S'il y a une cha√Æne d'op√©rations de lecture / √©criture dans une variable et qu'elles sont connect√©es par une cha√Æne de relations qui se produisent avant, alors la lecture devrait d√©finitivement voir le dernier enregistrement de cette cha√Æne.  S'il n'y est pas, vous pouvez voir toute autre valeur, tout autre enregistrement ou valeur par d√©faut.  Vous pouvez maintenant expirer, avec les d√©finitions de base que nous avons faites. <br><br><img src="https://habrastorage.org/webt/q6/jv/qq/q6jvqqzesul_tjyflrgcuy8s__4.jpeg"><br><br>  Essayons de tester la th√©orie dans la pratique?  Prenons un exemple avec une lecture crois√©e des enregistrements et ajoutons simplement le modificateur volatile aux variables X et Y. Essayons de prouver l'hypoth√®se que nous ne verrons plus la valeur z√©ro-z√©ro.  Pour ce faire, utilisez simplement les r√®gles que j'ai exprim√©es ci-dessus. <br><br>  Nous organiserons les √©v√©nements avant dans un seul fil.  L'√©criture vers X se produit - avant la lecture de Y et dans le deuxi√®me fil.  √âcrire √† Y arrive avant de lire √† partir de X. <br><br>  Et puis nous avons quatre actions de synchronisation: √©crire sur X, √©crire sur Y, lire sur X, lire sur Y. Elles peuvent appara√Ætre dans un certain ordre, et une paire peut se produire dans deux cas. <br><br><img src="https://habrastorage.org/webt/yz/mu/vr/yzmuvrfkneks1-usipllgsgxanc.jpeg"><br><br>  Par exemple, l'√©criture sur X dans le flux un s'est produite plus t√¥t que la lecture sur X dans le flux deux (arrive-avant se produit).  Comme vous pouvez le voir ici, la relation n'est pas li√©e √† Y. Le r√©sultat de la lecture de Y peut simplement nous renvoyer la valeur par d√©faut ou la valeur enregistr√©e par le deuxi√®me flux.  Une lecture de X doit toujours voir une unit√©.  Par cons√©quent, nos options peuvent √™tre nulles, √©gales √† une. <br><br><img src="https://habrastorage.org/webt/yc/zi/rm/yczirmhlmh3r0c2whc-g8dpxtvu.jpeg"><br><br>  Le deuxi√®me cas est lorsqu'une connexion se produit.  C'est la m√™me chose - √©crire sur Y arrive - avant de lire sur Y. De plus, il n'y a pas de connexion entre X. En cons√©quence, le r√©sultat est le m√™me, seulement l√† vous obtenez un z√©ro, z√©ro un.  Th√©oriquement, nous pouvons prouver notre nouveau comportement de programme. <br><br><img src="https://habrastorage.org/webt/ui/zs/7o/uizs7ojlz4smbqktuvisojvjxte.jpeg"><br><br>  Vous pouvez le v√©rifier en pratique.  Prenez et ajoutez le mot-cl√© volatile dans notre test.  Courez et voyez que, en effet, dans notre pays, cette valeur ne sera jamais reproduite.   happens-before ‚Äî        .         . <br><br><img src="https://habrastorage.org/webt/p8/xp/ao/p8xpaoj1prrfkwto0t3w7unlsli.jpeg"><br><br> ,        .  volatile     Z  volatile,  .   ,        Z;   ,  ,     ,     Z.        happens-before       .  ,     Z   ,        .           . <br><br>  , ,        ‚Äî       put value.    ‚Äî   get value    .   happens-before   ,       ,  put value happens-before get value.           ,        happens-before   ,   volatile,     .      ,    ,  ‚Äî put  happens-before get. <br><br><img src="https://habrastorage.org/webt/m6/br/hd/m6brhdf3iyak436nje-p-fyrq2a.jpeg"><br><br> ,    . -,  .  ,    ,    .         ,     .  ,     ,     .  ,         .    ,      ,      ,     ,       . <br><br> -,     ,  jcstress.       :     ,   JVM   .      ,        . <br><br>    ,   .  ‚Äî ¬´The Art of Multiprocessor Programming¬ª  .        ,   happens-before,  ,   . .     ‚Äî ¬´Java Concurrency in Practice¬ª  .     ,       .     ,   ,    . .    .       <a href="https://shipilev.net/"> </a> ,   performance-  Oracle,     Red Hat.      ,  Java-  ,   .        JMM. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez lire le blog de </font></font><a href="https://elizarov.livejournal.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a enseign√©, √† mon avis, la programmation multithread de l'ITMO. </font><font style="vertical-align: inherit;">Il a un blog l√©g√®rement abandonn√©, mais vous pouvez lire, rechercher ses conf√©rences et discours sur YouTube. </font><font style="vertical-align: inherit;">En g√©n√©ral, tr√®s appropri√©, je conseille. </font><font style="vertical-align: inherit;">Merci √† tous.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477074/">https://habr.com/ru/post/fr477074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477054/index.html">Webasto annonce un syst√®me de batterie automobile modulaire</a></li>
<li><a href="../fr477058/index.html">Enterprise Agile Russia √† Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../fr477060/index.html">DataArt accueillera une conf√©rence ouverte d'Andrei Terekhov, chef du d√©partement de programmation syst√®me, Matmekh, Universit√© d'√âtat de Saint-P√©tersbourg</a></li>
<li><a href="../fr477062/index.html">Fonctionnement du compilateur d'optimisation</a></li>
<li><a href="../fr477072/index.html">D√©veloppement client ou comment lancer un produit sans √©chec?</a></li>
<li><a href="../fr477078/index.html">WebStorm 2019.3: lancement plus rapide, prise en charge am√©lior√©e de Vue.js et autres am√©liorations</a></li>
<li><a href="../fr477082/index.html">Congr√®s am√©ricain contre Zuckerberg: quelles all√©gations les r√©gulateurs font-ils contre la balance stable de Facebook</a></li>
<li><a href="../fr477084/index.html">Le cerveau de l'entreprise. 2e partie</a></li>
<li><a href="../fr477092/index.html">Pr√©sentation des outils de s√©curit√© du r√©f√©rentiel GitHub</a></li>
<li><a href="../fr477096/index.html">La 5G va-t-elle nuire √† notre sant√©?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>