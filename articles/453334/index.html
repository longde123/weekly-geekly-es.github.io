<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèº üë®‚Äçüëß‚Äçüëß ‚òùüèº Hablar sobre PAKE üòñ üë±üèø ‚úäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ahora hablemos de la seguridad de la informaci√≥n. Esta publicaci√≥n est√° dedicada al lanzamiento del curso "Seguridad de la informaci√≥n criptogr√°fica" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hablar sobre PAKE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453334/">  Ahora hablemos de la seguridad de la informaci√≥n.  Esta publicaci√≥n est√° dedicada al lanzamiento del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Seguridad de la informaci√≥n criptogr√°fica"</a> , que comenzar√° el 30 de mayo.  Vamos <br><br>  Primera regla de PAKE: nunca hables de PAKE.  La segunda regla de PAKE establece que la primera regla no tiene sentido, ya que PAKE o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Password Exchange Authenticated Key Exchange</a> (intercambio de claves con autenticaci√≥n de contrase√±a) es una de las tecnolog√≠as m√°s √∫tiles que pr√°cticamente nunca se usa en ning√∫n lado.  Debe implementarse siempre que sea posible, pero no tan simple. <br><br><img src="https://habrastorage.org/webt/gk/qt/xa/gkqtxaksei42embld2iyquekz44.png"><br><br><a name="habracut"></a><br>  Para entender por qu√© estamos hablando de tonter√≠as, veamos un problema real. <br><br>  Supongamos que trabajo con un servidor que almacena las contrase√±as de los usuarios.  Hay una forma tradicional de almacenar: cifrar la contrase√±a de cada usuario y almacenar el resultado en una base de datos de contrase√±as.  Hay muchas ideas sobre c√≥mo manejar el proceso de hash.  La recomendaci√≥n m√°s com√∫n hoy en d√≠a es usar una funci√≥n de hash de contrase√±a de memoria r√≠gida (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scrypt</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">argon2</a> (con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sal √∫nica</a> ) para cada contrase√±a), y luego almacenar el resultado hash.  Hay diferentes opiniones sobre qu√© funci√≥n hash usar y si puede usar alg√∫n valor secreto (llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"pimienta"</a> ), pero por ahora no hablaremos de eso. <br><br>  Independientemente del enfoque que elija, todas estas soluciones tienen un tal√≥n de Aquiles: <br>  <i>Cuando el usuario regrese para ingresar al sitio, deber√° enviar su contrase√±a (abierta) al servidor para que realice la verificaci√≥n</i> . <br><br>  Esta necesidad puede tener consecuencias desagradables si su servidor se ve comprometido o si sus desarrolladores cometen alg√∫n error est√∫pido.  Por ejemplo, a principios del a√±o pasado, Twitter pidi√≥ a todos sus usuarios (¬°y esto a 330 millones!) Que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambiaran las contrase√±as</a> , porque result√≥ que la compa√±√≠a almacenaba contrase√±as textuales (no hash). <br><br>  Por el momento, el problema de iniciar sesi√≥n no contradice de ninguna manera los beneficios del hashing de contrase√±as.  Sin embargo, debe encontrar una soluci√≥n mejor: una en la que la contrase√±a nunca se env√≠e al servidor en texto claro.  La herramienta criptogr√°fica que nos ayudar√° a lograr esto es PAKE, y en particular, un nuevo protocolo llamado OPAQUE, que cubriremos al final de este art√≠culo. <br><br><h2>  ¬øQu√© es PAKE? </h2><br>  El protocolo PAKE, propuesto por primera vez por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bellovin y Merritt</a> , es un tipo espec√≠fico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de protocolo de intercambio de claves</a> .  Los protocolos de intercambio de claves (o "acuerdos de clave") est√°n dise√±ados para ayudar a las dos partes (llam√©moslas cliente y servidor) a acordar una clave compartida mediante criptograf√≠a de clave p√∫blica.  Los primeros protocolos de intercambio de claves (como el cl√°sico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diffie-Hellman</a> ) no estaban autorizados, lo que los hac√≠a vulnerables a ataques como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hombre en el medio</a> .  Una caracter√≠stica distintiva de los protocolos PAKE es que el cliente se autentica en el servidor con una contrase√±a.  Por razones obvias, se supone que el servidor ya conoce la contrase√±a o el hash, lo que permite la verificaci√≥n. <br><br>  Si eso fuera todo lo que necesitara, los protocolos PAKE ser√≠an f√°ciles de construir.  Pero lo que hace que PAKE sea realmente √∫til es que tambi√©n proporciona protecci√≥n con contrase√±a del cliente.  Se puede formular una garant√≠a m√°s seria de la siguiente manera: despu√©s de un intento de ingresar al sistema (exitoso o no), el cliente y el servidor solo deben saber si la contrase√±a del cliente coincide con el valor esperado por el servidor, y no m√°s informaci√≥n adicional.  Esta es una muy buena defensa.  De hecho, esto no es diferente de lo que requerimos de una prueba de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">divulgaci√≥n cero</a> . <br><br><img src="https://habrastorage.org/webt/fv/s6/kt/fvs6ktjjxphiyeae5k13gtw0w4y.png"><br><blockquote>  Una representaci√≥n idealizada del protocolo PAKE.  La entrada de ambos lados incluye cierta aleatoriedad, que no se muestra aqu√≠.  El esp√≠a no necesita encontrar la clave secreta compartida K, que es aleatoria y no es una funci√≥n de la contrase√±a. </blockquote><br>  Por supuesto, el problema obvio con PAKE es que muchos desarrolladores no quieren ejecutar el protocolo de "intercambio de claves" en primer lugar.  Solo quieren asegurarse de que el usuario conozca la contrase√±a. <br><br>  Lo mejor de PAKE es que el caso de uso "solo inicio de sesi√≥n" es bastante f√°cil de ejecutar.  Supongamos que tengo un protocolo PAKE est√°ndar que permite que el cliente y el servidor acuerden una clave com√∫n K. Si conoce la contrase√±a correcta (y solo en este caso), todo lo que necesitamos implementar es un simple control que ambas partes recibieron La misma llave.  (Esto se puede hacer, por ejemplo, si las partes calculan con √©l alguna funci√≥n criptogr√°fica y verifican los resultados). Por lo tanto, PAKE puede ser √∫til incluso si solo desea verificar la contrase√±a. <br><br><h2>  SRP: PAKE, sobre qu√© tiempo se ha olvidado </h2><br>  El concepto PAKE parece proporcionar una ventaja de seguridad obvia sobre el enfoque ingenuo que usamos hoy para ingresar al servidor.  ¬°Y los m√©todos en s√≠ mismos son antiguos, en el sentido de que PAKE se conoce desde 1992!  A pesar de esto, la luz nunca lo vio.  ¬øPor qu√© est√° pasando esto? <br><br>  Hay varias razones obvias.  Lo m√°s obvio est√° relacionado con las limitaciones de Internet: es mucho m√°s f√°cil poner un formulario de contrase√±a en una p√°gina web que implementar una criptograf√≠a elegante en un navegador.  Sin embargo, esta explicaci√≥n no es suficiente.  Incluso las aplicaciones nativas rara vez implementan PAKE para las operaciones de inicio de sesi√≥n.  Otra posible explicaci√≥n est√° relacionada con las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patentes</a> , aunque la mayor√≠a de ellas ya han expirado.  Para m√≠, hay dos razones probables para no tener PAKE: <br><br><ul><li>  Falta de implementaciones PAKE de alta calidad en lenguajes populares, lo que hace que su uso sea problem√°tico; </li><li>  Los especialistas en criptograf√≠a no transmiten mal la esencia y el valor de su trabajo, por lo que la mayor√≠a de las personas ni siquiera saben que PAKE existe en absoluto. </li></ul><br>  A pesar de que dije que PAKE no se usa ahora, todav√≠a hay excepciones a las reglas. <br><br>  Hay un gran protocolo desarrollado en 1998 por Tom Wu (que no debe confundirse con Tim Wu), que se llama "SRP" (abreviatura de "Contrase√±a remota segura").  De hecho, es solo un PAKE de tres etapas con algunas funciones adicionales que no se implementaron en los primeros trabajos.  Hasta donde yo s√©, SRP difiere en que es el protocolo PAKE m√°s com√∫n en el mundo.  Dar√© dos pruebas de esta declaraci√≥n: <br><br><ol><li>  SRP fue estandarizado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TLS ciphersuite</a> e implementado en bibliotecas como, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSSL</a> , aunque nadie parece usarlo especialmente. </li><li>  Apple hace un amplio uso de SRP en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">iCloud Key Vault</a> </li></ol><br>  El segundo hecho en s√≠ mismo podr√≠a hacer que SRP sea uno de los protocolos criptogr√°ficos m√°s utilizados en el mundo, la cantidad de dispositivos que Apple estampa es tan grande.  Y no hay nada gracioso. <br><br>  El hecho de que la industria haya aceptado el SRP es ciertamente bueno, pero por otro lado, y no muy.  Principalmente porque, aunque cualquier respaldo de PAKE es bueno, SRP por s√≠ solo no es la mejor implementaci√≥n de PAKE.  Pens√© en adentrarme en la jungla de discusiones sobre SRP, pero este discurso ya se estaba prolongando, y me desv√≠o de la historia sobre un protocolo realmente bueno, del que hablaremos a continuaci√≥n.  Si todav√≠a est√° interesado en la discusi√≥n sobre SRP, lo traje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  En lugar de estos detalles innecesarios, perm√≠tanme escribir un breve resumen de mis pensamientos sobre SRP: <br><br><ol><li>  SRP hace algunas cosas bien.  Primero, a diferencia de las versiones anteriores de PAKE, no necesita almacenar la contrase√±a sin procesar en el servidor (o, de manera equivalente, un hash que podr√≠a ser utilizado por un atacante en lugar de una contrase√±a).  En cambio, el servidor almacena un "verificador", que es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funci√≥n</a> unidireccional del hash de contrase√±a.  Esto significa que una fuga de la base de datos de contrase√±as no permite que un atacante reemplace inmediatamente a un usuario solo si no realiza m√°s costosos ataques de diccionario.  (El nombre t√©cnico para esto es PAKE "asim√©trico"). </li><li>  Hay mejores noticias, ¬°la versi√≥n actual de SRP (v4 v6a) a√∫n no ha sido hackeada! </li><li>  Sin embargo (no se ofenda por los desarrolladores), la arquitectura del protocolo SRP es completamente loca, y sus versiones anteriores fueron pirateadas varias veces, por lo que ahora tenemos la versi√≥n 6a.  Adem√°s, la "prueba de seguridad" en el art√≠culo de investigaci√≥n original en realidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no prueba nada</a> . </li><li>  SRP se basa actualmente en aritm√©tica de enteros (final), y por varias razones (v√©ase la cl√°usula 3 anterior) su arquitectura claramente no puede transferirse a una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curva</a> el√≠ptica.  Esto requiere m√°s ancho de banda y c√≥mputo, por lo que SRP no puede aprovechar las muchas mejoras de rendimiento que hemos desarrollado en complementos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Curve25519</a> . </li><li>  SRP es vulnerable a ataques previos a la computaci√≥n porque pasa la sal del usuario a cualquier atacante que pueda iniciar una sesi√≥n de SRP.  Esto significa que puedo pedirle sal a su servidor y construir un diccionario de posibles hashes de contrase√±a antes de que el servidor se vea comprometido. </li><li>  A pesar de todas estas deficiencias, SRP es extremadamente simple y tambi√©n viene con c√≥digo de trabajo.  Adem√°s, OpenSSL tiene un c√≥digo de trabajo que incluso se integra con TLS, lo que lo hace relativamente f√°cil de implementar. </li></ol><br>  De todos estos puntos, este √∫ltimo es casi seguramente responsable del (relativamente) alto grado de √©xito comercial que SRP logr√≥ sobre otros protocolos PAKE.  No es perfecto, sino real.  Esto es lo que quer√≠a transmitir a los expertos en seguridad criptogr√°fica. <br><br><h2>  OPAQUE: PAKE nueva generaci√≥n </h2><br>  Cuando comenc√© a pensar en PAKE hace unos meses, no pude evitar notar que la mayor√≠a de las implementaciones existentes funcionaban bastante mal.  O ten√≠an problemas, como en SRP, o requer√≠an que el usuario almacenara la contrase√±a (o contrase√±a efectiva) en el servidor, o se mostraba la "sal" al atacante, dando la oportunidad de llevar a cabo el ataque antes de calcular. <br><br>  Luego, a principios del a√±o pasado, Jarecki, Kravczyk y Xu revelaron al mundo un nuevo protocolo llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OPAQUE</a> .  Tiene una serie de ventajas significativas: <br><br><ol><li>  Se puede implementar incluso si hay problemas de Diffie-Hellman y logaritmos discretos.  Esto significa que, a diferencia de SRP, se puede instanciar f√°cilmente utilizando curvas el√≠pticas efectivas. </li><li>  A√∫n mejor: OPAQUE no revela sal a un atacante.  √âl resuelve este problema usando "PRF olvidadizo" para combinar la sal con la contrase√±a para que el cliente no reciba la sal y el servidor no reciba la contrase√±a. </li><li> OPAQUE funciona con cualquier funci√≥n de hash de contrase√±a.  Dado que todo el trabajo de hash se realiza en el cliente, OPAQUE puede quitar la carga del servidor, liberando el servicio en l√≠nea, por ejemplo, para usar configuraciones de seguridad extremadamente voluminosas, por ejemplo, configurar <code>scrypt</code> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucha RAM</a> . </li><li>  En t√©rminos de recuento de mensajes y exponente, OPAQUE no es muy diferente de SRP.  Pero dado que se puede implementar con par√°metros m√°s eficientes, es probable que funcione de manera mucho m√°s eficiente. </li><li>  A diferencia de SRP, OPAQUE tiene evidencia de seguridad razonable (en un modelo muy fuerte). </li></ol><br>  Incluso hay una propuesta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">borrador de Internet</a> para OPAQUE, que puede leer aqu√≠.  Desafortunadamente, por el momento no s√© nada sobre la calidad de la implementaci√≥n del c√≥digo, excepto que ya hay varias implementaciones potenciales.  Espero que este problema se resuelva pronto. <br>  El protocolo OPAQUE completo se enumera a continuaci√≥n.  En el resto de esta secci√≥n, voy a hablar sobre c√≥mo funciona. <br><br>  <b>Problema 1: Mantener la sal en secreto.</b>  Como mencion√© anteriormente, el principal problema con las versiones anteriores de PAKE es la necesidad de transferir sal del servidor al cliente (a√∫n no autenticado).  Esto permite que un atacante realice ataques antes de calcular d√≥nde puede generar un diccionario basado en los datos recibidos. <br><br>  El problema aqu√≠ es que la sal generalmente se pasa a una funci√≥n hash (por ejemplo, scrypt) junto con la contrase√±a.  Intuitivamente, alguien necesita calcular esta funci√≥n.  Si es un servidor, entonces el servidor deber√≠a ver una contrase√±a, que mata cualquier significado.  Si este es un cliente, entonces necesita sal. <br><br>  Te√≥ricamente, puede solucionar este problema calculando la funci√≥n de hash de contrase√±a utilizando el protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguro de c√≥mputo bipartito (2PC)</a> .  En la pr√°ctica, es casi seguro que tales soluciones ser√°n ineficaces, principalmente porque las funciones de hashing de contrase√±as son complejas y requieren mucho tiempo.  Esto aumentar√° incre√≠blemente la complejidad de cualquier sistema 2PC. <br><br>  OPAQUE trata esto de la siguiente manera.  Deja un hash de contrase√±a en el lado del cliente, pero no muestra sal.  En cambio, utiliza un protocolo especial de dos v√≠as llamado PRF olvidadizo para calcular otra sal (llam√©mosle salt2) para que el cliente pueda usar salt2 en la funci√≥n hash pero no pueda acceder a la sal original. <br><br>  Funciona algo como esto: <br><blockquote>  <i>El servidor almacena "sal", y el cliente tiene contrase√±a.salt2 = PRF (sal, contrase√±a), esto se calcula entre el cliente y el servidor utilizando un protocolo en el que el cliente nunca reconocer√° la sal y el servidor sabr√° la contrase√±a.</i>  <i>El cliente recibe salt2K = PasswordHash (salt2, contrase√±a), y todo esto se considera en el cliente.</i> </blockquote><br>  La implementaci√≥n real de PRF olvidadizo se puede hacer usando varios elementos de grupo y exponentes.  A√∫n mejor, si el cliente ingresa la contrase√±a incorrecta, entonces el protocolo recibe un valor ficticio "salt2", que no dice nada sobre el valor real de la sal. <br><br>  <b>Problema 2: Prueba de que el cliente recibi√≥ la clave K correcta.</b> Por supuesto, en este momento el cliente recibi√≥ la clave K, pero el servidor no tiene idea de qu√© es.  El servidor tampoco sabe si esta es la clave correcta. <br><br>  La soluci√≥n OPAQUE se basa en la vieja idea de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gentry, Mackenzie y Ramzan</a> .  Cuando un usuario inicia sesi√≥n por primera vez en el servidor, el servidor genera una clave p√∫blica y privada confiable para el protocolo de acuerdo seguro (por ejemplo, HMQV) y cifra la clave privada recibida bajo K junto con la clave p√∫blica del servidor.  El cifrado autenticado resultante (y la clave p√∫blica) se almacena en la base de datos de contrase√±as. <br><br>  <b><i>C = Cifrar (K, clave secreta del cliente | clave p√∫blica del servidor)</i></b> <br><br><img src="https://habrastorage.org/webt/9z/tb/uk/9ztbukhcywebjlgyrlbbaltk-0a.png"><br>  <i>Versi√≥n completa del protocolo OPAQUE, extracto del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> .</i> <br><br>  Cuando el cliente quiere autenticarse utilizando el protocolo OPAQUE, el servidor le env√≠a el c√≥digo <b>C</b> almacenado.  Si el cliente ingres√≥ la contrase√±a correcta en la primera fase, puede obtener <b>K</b> y descifrar este cifrado.  De lo contrario, es in√∫til.  Usando una clave secreta cableada, ahora puede ejecutar un protocolo de acuerdo est√°ndar con una clave autenticada para completar el protocolo de enlace.  (El servidor verifica la entrada de los clientes al compararlos con su copia de la clave p√∫blica del cliente, y el cliente hace lo mismo). <br><br>  <b>Ahora pongamos todo junto.</b>  Todos estos pasos se pueden combinar en un protocolo, que tiene el mismo n√∫mero de pasos que SRP.  Si no presta atenci√≥n a los pasos de verificaci√≥n, se ver√° como el protocolo anterior.  En principio, la idea es solo en dos mensajes: uno del cliente y el segundo se env√≠a de vuelta al servidor. <br><br>  El √∫ltimo aspecto del trabajo de OPAQUE es que tiene buena evidencia de seguridad que nos dice que el protocolo resultante puede considerarse seguro si tomamos uno o m√°s logaritmos discretos en un modelo de or√°culo aleatorio, que es una suposici√≥n est√°ndar, que aparentemente , tiene lugar en la configuraci√≥n con la que trabajamos. <br><br><h2>  Conclusi√≥n </h2><br>  En resumen, tenemos una tecnolog√≠a confiable que puede hacer que el proceso de usar contrase√±as sea mucho m√°s f√°cil, y tambi√©n puede permitirnos manejarlas de manera m√°s eficiente, con muchos par√°metros de hash y mucha carga de trabajo en el lado del cliente.  ¬øPor qu√© esto no se usa en todas partes?  Quiz√°s en los pr√≥ximos a√±os todo cambie.  El tiempo lo dir√°. <br><br>  De acuerdo con la tradici√≥n establecida, estamos esperando sus comentarios y los invitamos a visitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el d√≠a de puertas abiertas</a> , que se llevar√° a cabo el 27 de mayo por nuestra maestra, la criptoanalista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elena Kirshanova</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453334/">https://habr.com/ru/post/453334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453324/index.html">Diodo como rectificador</a></li>
<li><a href="../453326/index.html">C√≥mo automatizar la gesti√≥n de la infraestructura de TI: discuta tres tendencias</a></li>
<li><a href="../453328/index.html">Diez a√±os en un sitio remoto</a></li>
<li><a href="../453330/index.html">Qu√© hacer si la RAM se bloquea. Anamnesis y m√©todos de tratamiento.</a></li>
<li><a href="../453332/index.html">Sobre el extra√±o m√©todo de ahorrar espacio en el disco duro</a></li>
<li><a href="../453336/index.html">Gu√≠a de selecci√≥n de m√°quinas de quemado CNC</a></li>
<li><a href="../453338/index.html">Lanzamiento de Rust 1.35.0: implementaciones de rasgos funcionales y otras innovaciones</a></li>
<li><a href="../453340/index.html">Perl 5.30 lanzado</a></li>
<li><a href="../453342/index.html">Mitos sobre empleados remotos que nos destruimos</a></li>
<li><a href="../453346/index.html">Tecnolog√≠as de almacenamiento y protecci√≥n de datos: el tercer d√≠a en VMware EMPOWER 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>