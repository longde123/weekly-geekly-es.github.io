<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍥 👩🏼‍✈️ 🛣️ Intégrité des données dans une architecture de microservices - comment la garantir sans transactions distribuées et connectivité étroite 👨🏾‍🤝‍👨🏽 ⛰️ 🚵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. Comme vous le savez peut-être, j'avais l'habitude d' écrire et de parler davantage du stockage, de Vertica, du stockage de Big Data et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intégrité des données dans une architecture de microservices - comment la garantir sans transactions distribuées et connectivité étroite</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/426101/"><p>  Bonjour à tous.  Comme vous le savez peut-être, j'avais l'habitude d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrire</a> et de parler davantage du stockage, de Vertica, du stockage de Big Data et d'autres choses analytiques.  Désormais, toutes les autres bases de données, non seulement analytiques, mais aussi OLTP (PostgreSQL) et NOSQL (MongoDB, Redis, Tarantool) sont également tombées dans mon domaine de responsabilité. </p><br><p>  Cette situation m'a permis de considérer une organisation qui a plusieurs bases de données comme une organisation qui a une base de données hétérogène (hétérogène) distribuée.  Une seule base de données hétérogène distribuée, constituée d'un tas de PostgreSQL, Redis et Mong ... Et, éventuellement, d'une ou deux bases de données Vertica. </p><br><p> Le travail de cette base distribuée unique génère un tas de tâches intéressantes.  Tout d'abord, du point de vue des affaires, il est important que tout soit normal avec des données se déplaçant le long d'une telle base.  Je n'utilise pas spécifiquement le terme intégrité, cohérence, car  le terme est complexe, et dans différentes nuances de considérer un SGBD (théorème A <strong>C</strong> ID et <strong>C</strong> AP), il a une signification différente. </p><br><p>  La situation avec une base distribuée est aggravée si une entreprise essaie de passer à une architecture de microservice.  Sous le chat, je parle de la façon d'assurer l'intégrité des données dans une architecture de microservice sans transactions distribuées et connectivité étroite.  (Et à la fin j'explique pourquoi j'ai choisi cette illustration pour l'article). </p><br><p><img src="https://habrastorage.org/webt/br/li/ui/brliuiadpszbdp6shhwg-a7agpu.png"></p><a name="habracut"></a><br><p>  Selon Chris Richardson (l'un des évangélistes les plus célèbres de l'architecture de microservices), cette architecture a deux approches pour travailler avec des bases de données: base de données partagée et base de données par service. </p><br><p><img src="https://habrastorage.org/webt/ry/jh/xk/ryjhxkec5ilup0adwjqav-aoikg.png"></p><br><p>  La base de données partagée est une bonne première étape, une excellente solution pour une petite entreprise sans plans de croissance ambitieux.  De plus, ce modèle est en soi un anti-modèle du point de vue de l'architecture de microservices, comme  deux services partageant une base commune ne peuvent pas être testés et mis à l'échelle indépendamment.  C'est-à-dire  ces services sont plutôt un service qui tend à devenir un monolithe. </p><br><p>  Le modèle de base de données par service suppose que chaque service possède sa propre base de données.  Un service ne peut accéder aux données d'un autre service que via l'API (au sens large), sans connexion directe à sa base de données. </p><br><p>  Le modèle de base de données par service permet aux équipes des services correspondants de sélectionner les bases de données à leur guise.  Quelqu'un est capable dans MongoDB, quelqu'un croit en PostgreSQL, quelqu'un a besoin de Redis (le risque de perte de données lors de l'arrêt est acceptable pour ce service), et quelqu'un stocke généralement les données dans des fichiers CSV sur disque (et pourquoi, en fait , et non?). </p><br><p><img src="https://habrastorage.org/webt/8y/uf/ln/8yuflnhn4nzbfso12xm39_6_p9u.png"></p><br><p>  Travailler avec un tel «zoo» de bases de données soulève la tâche de restaurer l'ordre dans les données à un tout nouveau niveau de complexité. </p><br><h1 id="acid-i-mikroservisnaya-arhitektura">  Architecture ACID et microservice </h1><br><p>  Examinons la tâche de mettre les choses en ordre à travers le prisme de l'ensemble d'exigences ACID basé sur un SGBD classique: nous allons développer l'essence de chaque lettre de l'abréviation et illustrer les difficultés de cette lettre dans l'architecture de microservices. </p><br><p>  <strong>(A) CID - Atomicité.</strong>  <strong>Atomicité - tout ou rien.</strong> </p><br><p>  Selon l'exigence d'atomicité, il est impératif de terminer toutes les étapes (avec des répétitions possibles), si une étape importante échoue, annuler les étapes terminées. </p><br><p>  L'illustration ci-dessus illustre le processus de test d'achat d'un service VIP: l'argent est réservé dans la facturation (1), un service bonus est activé pour un utilisateur (2), le type d'utilisateur est changé en Pro (3), l'argent réservé dans la facturation est débité (4).  Les quatre étapes doivent être terminées ou non. </p><br><p><img src="https://habrastorage.org/webt/ag/gt/cx/aggtcxiv5ip-anc82hoivfcpxyg.png"></p><br><p>  Dans ce cas, vous ne pouvez pas bloquer au milieu du processus, par conséquent, l'asynchronie est préférable, dans les cas extrêmes, le synchronisme avec le délai d'expiration intégré. </p><br><p>  <strong>A (C) ID - Cohérence.</strong>  <strong>Cohérence - chaque étape ne doit pas contredire les conditions aux limites.</strong> </p><br><p>  Exemples classiques de conditions pour, par exemple, envoyer de l'argent du client A dans le service 1 au client B dans le service 2: à la suite d'un tel envoi d'argent ne devrait pas devenir moins (l'argent ne devrait pas être perdu pendant le transfert) ou plus (il est inacceptable d'envoyer le même argent à deux utilisateurs en même temps).  Pour se conformer à cette exigence, vous devez coder les conditions quelque part et vérifier les données pour les conditions (idéalement, sans appels supplémentaires). </p><br><p><img src="https://habrastorage.org/webt/hz/ha/zn/hzhazn63hlnpo7hojezmf5gmuyw.png"></p><br><p>  <strong>ACI (D) - Durabilité.</strong>  <strong>L'exigence de durabilité signifie que les effets des opérations ne disparaissent pas.</strong> </p><br><p>  Dans les conditions de persistance de Polyglot, un service peut fonctionner sur une base de données qui peut régulièrement «perdre» les données qui y sont enregistrées.  Une astuce similaire peut être obtenue même à partir de bases de données solides comme PostgreSQL, si la réplication asynchrone y est activée.  L'illustration montre comment les modifications enregistrées dans Master, mais qui n'ont pas atteint Slave via la réplication asynchrone, peuvent être détruites en brûlant le serveur Master.  Pour garantir les exigences de durabilité, il est nécessaire de pouvoir diagnostiquer et récupérer correctement ces pertes. </p><br><p><img src="https://habrastorage.org/webt/du/y0/fv/duy0fv-a9l8auvniphyeguskx_g.png"></p><br><p>  <strong>Et où suis-je, demandez-vous?</strong> </p><br><p>  Et nulle part.  L'isolement dans un environnement de plusieurs services asynchrones indépendants est une exigence technique.  La recherche moderne a montré que de vrais processus commerciaux peuvent être mis en œuvre sans isolement.  L'isolement simplifie la réflexion en minimisant la concurrence (le développement de l'informatique parallèle est plus difficile pour un programmeur), mais l'architecture des microservices est intrinsèquement massive-parallèle, l'isolement dans un tel environnement est redondant. </p><br><p>  Il existe de nombreuses approches pour se conformer aux exigences ci-dessus.  L'algorithme de transactions distribuées le plus connu fourni par ce que l'on appelle la validation en deux phases (2PC).  Malheureusement, la mise en œuvre de validations en deux phases nécessite la réécriture de tous les services impliqués.  Et le plus grave: cet algorithme n'est pas très productif.  Les illustrations issues d'études récentes montrent que cet algorithme montre une certaine performance sur une base distribuée de deux serveurs, mais avec une augmentation du nombre de serveurs, la productivité ne croît pas linéairement ... Ou plutôt, elle ne croît pas du tout. </p><br><p><img src="https://habrastorage.org/webt/2t/eh/c6/2tehc6ckxsixeoqru14yp75pfy0.png"></p><br><p>  L'un des principaux avantages de l'architecture de microservices est la possibilité d'augmenter linéairement les performances en ajoutant simplement de plus en plus de serveurs.  Il s'avère que si nous utilisons un commit en deux phases pour garantir l'intégrité distribuée, ce processus deviendra un goulot d'étranglement, un frein à la croissance de la productivité, malgré l'augmentation du nombre de serveurs. </p><br><p>  Comment garantir l'intégrité distribuée (exigences ACiD) sans commits en deux phases, avec la possibilité d'évoluer de manière linéaire dans les performances? </p><br><p>  La recherche moderne (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">An Evaluation of Distributed Concurrency Control. VLDB 2017</a> ) soutient que la soi-disant «approche optimiste» peut aider.  La différence entre l'engagement en deux phases et «l'approche optimiste» généralisée peut être illustrée par la différence entre l'ancien magasin soviétique (avec un comptoir) et un supermarché moderne comme Auchan.  Dans un magasin avec un comptoir, chaque client est considéré comme suspect et reçoit un contrôle maximal.  D'où les lignes et les conflits.  Et au supermarché, l'acheteur est considéré comme honnête par défaut, ils lui donnent la possibilité de s'approcher des étagères et de remplir les chariots.  Bien sûr, il existe des outils de surveillance pour attraper les escrocs (caméras, sécurité), mais la plupart des acheteurs n'ont jamais à s'en occuper. </p><br><p>  Par conséquent, le supermarché peut être agrandi, agrandi, simplement en plaçant plus de caisses.  Il en va de même avec l'architecture de microservices: si l'intégrité distribuée est assurée par une «approche optimiste», lorsque seuls les processus où quelque chose s'est mal passé sont en outre chargés de vérifications.  Et les processus normaux passent sans vérifications supplémentaires. </p><br><p>  C'est important.  L '«approche optimiste» comprend plusieurs algorithmes.  Je voudrais vous parler de la saga - l'algorithme pour maintenir l'intégrité distribuée, recommandé par Chris Richardson. </p><br><h1 id="sagi--elementy-algoritma">  Sagas - éléments de l'algorithme </h1><br><p>  L'algorithme d'affaissement a deux options.  Par conséquent, dans un premier temps, je voudrais décrire universellement les éléments requis de l'algorithme afin que la description soit adaptée aux deux options. </p><br><p>  <strong>Élément 1.</strong> Canal fiable et persistant de livraison d'événements entre les services, garantissant "au moins une livraison".  C'est-à-dire  si l'étape 2 du processus s'est terminée avec succès, une notification (événement) à ce sujet doit atteindre l'étape 3 au moins une fois, les livraisons répétées sont acceptables, mais rien ne doit être perdu.  "Persistant" signifie que le canal doit stocker les notifications pendant un certain temps (2-3 jours, une semaine) afin qu'un service qui a perdu les dernières modifications en raison de la perte de la base de données (voir l'exemple de durabilité, dans l'illustration c'est l'étape 2), puisse restaurer ces changements en rejouant les événements de la chaîne. </p><br><p><img src="https://habrastorage.org/webt/du/kr/sy/dukrsykrnmfcf4u6srrgffx4f5a.png"></p><br><p>  <strong>Élément 2.</strong> Idempotence des appels de service grâce à l'utilisation d'une clé d'idempotence unique.  Imaginez que moi (l'utilisateur) lance le processus d'achat d'un package VIP (voir l'exemple pour Atomicity).  Au début du processus, on me donne une clé unique, la clé d'idempotence, par exemple, 42. Ensuite, l'appel à chacune des étapes (1 → 2 → 3 → 4) doit être effectué avec la clé d'idempotence indiquée.  Dans le paragraphe ci-dessus, la possibilité de l'arrivée répétée du même message au service (à l'étape) est évoquée.  Le service (étape) doit automatiquement pouvoir ignorer l'arrivée répétée de l'événement traité, en vérifiant la répétition par la clé idempotency.  Autrement dit, si tous les services (étapes de processus) sont idempotents, afin de répondre aux exigences d'atomicité et de durabilité, il suffit de rediriger vers les étapes correspondant aux événements des canaux.  Les étapes qui ont ignoré les événements les exécuteront et les étapes qui ont déjà terminé les événements les ignoreront en raison de l'idempotency. </p><br><p><img src="https://habrastorage.org/webt/1u/5i/0e/1u5i0epymw6_tmvodacj2yeirra.png"></p><br><p>  <strong>Élément 3.</strong> Annulation des appels de service (étapes) par clé idempotency. </p><br><p>  Pour garantir l'atomicité (voir l'exemple), si le processus avec la clé idempotency 42, par exemple, s'est arrêté / est tombé à l'étape 3, il est alors nécessaire d'annuler l'exécution réussie des étapes 1 et 2 pour la clé 42. Pour cela, chaque étape de processus obligatoire doit avoir une étape de «compensation» , Une méthode API qui annule l'exécution de l'étape requise pour la clé d'idempotence spécifiée (42).  L'implémentation des appels compensatoires est un élément difficile mais nécessaire au raffinement des services dans le cadre de l'implémentation de l'algorithme d'affaissement. </p><br><p><img src="https://habrastorage.org/webt/rp/oc/pb/rpocpblpnxfk5uw6mk6-2cvywdi.png"></p><br><p>  Les trois éléments énumérés ci-dessus sont pertinents pour les deux versions de la mise en œuvre de la «sag»: orchestrée et chorégraphique. </p><br><h1 id="orkestriruemye-sagi">  Sagas orchestrées </h1><br><p>  L'algorithme plus simple et plus évident pour les sagas orchestrées est plus facile à comprendre et à mettre en œuvre.  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent article,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">kevteev a</a> décrit l'algorithme et le processus de mise en œuvre du mécanisme des sagas orchestrées dans Avito.  Leur algorithme suppose l'existence d'un service de contrôle, "orchestrant" les appels de service dans le cadre de processus métier desservis.  Le même service de surveillance peut avoir sa propre base de données (par exemple, PostgreSQL), qui agit comme un canal fiable de livraison d'événements persistants (élément 1). </p><br><h1 id="horeograficheskie-sagi">  Sagas chorégraphiques </h1><br><p>  La saga chorégraphique est plus délicate.  Ici, un bus de données qui met en œuvre les exigences suivantes doit agir comme un canal persistant fiable: publication de type "ignorer", livraison d'événements de publication-abonnement, au moins une fois de livraison.  C'est-à-dire  chaque étape de chaque processus doit recevoir une commande pour fonctionner à partir du bus et y envoyer le message de réussite, sur le début de l'étape suivante, afin qu'il le lise également sur le bus et poursuive le processus.  De plus, pour chaque message, il peut y avoir plusieurs abonnés. </p><br><p>  La saga chorégraphique devrait également avoir un service de contrôle, un service de sagas, mais beaucoup plus «léger».  Le service doit connaître les processus métier enregistrés dans le système, la composition des étapes incluses dans chaque processus.  Il doit également écouter le bus, surveiller l'exécution de chaque processus (chaque clé d'idempotence), et seulement si quelque chose s'est mal passé, soit lancer des «répétitions» d'étapes spécifiques, soit lancer des «annulations», des «compensations» pour les étapes suivies. </p><br><h1 id="nyuansy">  Nuances </h1><br><p>  L'une des nuances les plus importantes des sagas qui les distinguent des transactions classiques est un écart par rapport à la linéarité, la séquence et l'obligation de chaque étape.  Une saga n'est pas nécessairement une chaîne linéaire d'événements, elle peut être un graphique dirigé: un nouvel événement d'enregistrement d'utilisateur peut engendrer plusieurs étapes en parallèle (envoi de SMS, enregistrement d'une connexion, génération d'un mot de passe, envoi d'un e-mail), dont certaines peuvent être facultatives.  Dans une première approximation, il semble que dans une telle saga "ramifiée" avec des étapes facultatives, il est difficile de déterminer l'achèvement de la saga (processus), mais, en fait, tout est simple: la saga (processus) est terminée lorsque toutes les étapes requises sont terminées, dans n'importe quel ordre. </p><br><p><img src="https://habrastorage.org/webt/ta/ff/rz/taffrzux1gpdt5c_-dtqilxmqh4.png"></p><br><p>  La deuxième nuance, plus typique des sagas chorégraphiques, mais également possible pour les sagas orchestrées, est de choisir une approche pour l'enregistrement des processus métier, types de sagas dans le service sagas.  L'exemple d'atomicité décrit un processus de quatre étapes obligatoires consécutives. </p><br><p>  Qui a enregistré ce processus, indiqué toutes les étapes, placé les dépendances et les étapes obligatoires?  La réponse évidente mais démodée est que l'enregistrement du processus doit être effectué de manière centralisée dans le service d'affaissement.  Mais cette réponse n'est pas très cohérente avec l'architecture de microservices.  Dans l'architecture de microservices, il est plus prometteur, plus productif et plus rapide d'enregistrer des processus ascendants.  C'est-à-dire  de ne pas noter toutes les nuances du processus dans le service sag, mais de permettre aux services individuels de «s'intégrer» dans les processus existants par eux-mêmes, en indiquant leur nature contraignante / facultative et leurs prédécesseurs obligatoires. </p><br><p>  C'est-à-dire  le processus d'enregistrement d'un utilisateur dans le service d'affaissement peut initialement comprendre trois étapes, puis, pendant le développement du système, sept autres étapes y seront intégrées, et une étape sera écrite, et il y en aura neuf.  Un tel schéma «anarchiste» et «décentralisé» est difficile à tester, à mettre en œuvre un processus strict et coordonné, mais il est beaucoup plus pratique pour les équipes Agiles, pour une évolution produit multidirectionnelle continue. </p><br><p>  En fait, ici.  Avec une présentation sérieuse, je pense qu'il vaut la peine de terminer, sinon l'article s'est avéré trop volumineux. </p><br><hr><br><p>  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers la présentation de</a> ce matériel, j'ai fait un reportage sur ce sujet à Highload Siberia 2018. <br>  UPD - et vidéo de la conférence: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6HvSpqBc8fA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><hr><br><h1 id="epilog">  Épilogue </h1><br><p>  En fin de compte, je voudrais essayer d'expliquer tout ce qui précède dans un langage plus figuratif. <br>  Après tout, qu'est-ce qu'une saga depuis le début?  Cette intrigue, cette aventure du Moyen Âge ... Ou du Game of Thrones.  Un événement a lieu (une bataille, un mariage, quelqu'un meurt), la nouvelle s'envole à travers le monde à travers des messagers, des pigeons voyageurs, des marchands.  Lorsque les informations parviennent aux intéressés (dans une semaine, un mois, un an), ils réagissent: ils envoient des armées, déclarent la guerre, exécutent quelqu'un et de nouveaux messages volent. </p><br><p>  Aucun organisme de réglementation ne surveille la séquence des actions.  Aucune transaction, aucun retour en arrière, dans le sens d'annuler l'action, comme si elle n'avait jamais été.  De manière adulte, chaque action se déroule pour toujours.  Il peut être indemnisé, mais c'est précisément l'action (meurtre) et l'indemnisation (salaire pour la tête, vira), et non l'abolition de la mort. </p><br><p>  Les événements prennent beaucoup de temps, proviennent de différentes sources, les actions se déroulent en parallèle et pas strictement séquentiellement.  Et assez souvent, de nouveaux participants apparaissent soudainement dans l'intrigue, qui décident de participer (les dragons arrivent;)) ... et certains des anciens participants meurent soudainement. </p><br><p>  De telles choses.  Cela semble être un gâchis et un chaos, mais tout fonctionne, la coordination interne du monde n'est pas rompue, l'intrigue se développe et est cohérente ... Bien que parfois imprévisible. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426101/">https://habr.com/ru/post/fr426101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426091/index.html">8 analyseurs de journaux cloud pour évaluer l'environnement de travail</a></li>
<li><a href="../fr426093/index.html">Monétisation des données des utilisateurs par rapport à la publicité intégrée: avantages et inconvénients</a></li>
<li><a href="../fr426095/index.html">Webinaire ouvert «Comment ne pas écrire en Python»</a></li>
<li><a href="../fr426097/index.html">Arduino Projet "RoboCar4W Robot Machine"</a></li>
<li><a href="../fr426099/index.html">Typegram News</a></li>
<li><a href="../fr426103/index.html">Webinaire «Avez-vous besoin de Kubernetes» le 15 octobre à 19h00</a></li>
<li><a href="../fr426105/index.html">Ma prise en une semaine</a></li>
<li><a href="../fr426111/index.html">Google va toujours lancer un service de recherche censuré en Chine</a></li>
<li><a href="../fr426113/index.html">Google Actualités et Leo Tolstoy: Visualisation des représentations vectorielles des mots avec t-SNE</a></li>
<li><a href="../fr426115/index.html">La pratique de l'utilisation du modèle d'acteur dans la plateforme backend de Quake Champions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>