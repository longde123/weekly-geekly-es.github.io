<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùé üöô üë®üèæ‚Äçü§ù‚Äçüë®üèº OpenSceneGraph: Gestion des √©v√©nements ü§ë üôå üõÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 L'une des caract√©ristiques du langage C ++ pour laquelle il est souvent critiqu√© est l'absence de m√©canisme de traitement des √©v√©nement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Gestion des √©v√©nements</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438218/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  L'une des caract√©ristiques du langage C ++ pour laquelle il est souvent critiqu√© est l'absence de m√©canisme de traitement des √©v√©nements dans la norme.  Pendant ce temps, ce m√©canisme est l'un des principaux moyens d'interaction de certains composants logiciels avec d'autres composants logiciels et mat√©riels, et il est mis en ≈ìuvre au niveau d'un syst√®me d'exploitation sp√©cifique.  Naturellement, chaque plate-forme a ses propres nuances de mise en ≈ìuvre du m√©canisme d√©crit. <br><br>  En relation avec tout ce qui pr√©c√®de, lors du d√©veloppement en C ++, il est n√©cessaire d'impl√©menter le traitement des √©v√©nements d'une mani√®re ou d'une autre, r√©solu en utilisant des biblioth√®ques et des frameworks tiers.  Le framework Qt bien connu fournit un m√©canisme pour les signaux et les slots, qui permet d'organiser l'interaction des classes h√©rit√©es de QObject.  L'impl√©mentation d'√©v√©nements est √©galement pr√©sente dans la biblioth√®que boost.  Et bien s√ªr, le moteur OpenSceneGraph ne pouvait se passer de son propre ¬´v√©lo¬ª, dont l'application sera discut√©e dans l'article. <br><a name="habracut"></a><br>  OSG est une biblioth√®que graphique abstraite.  D'une part, il fait abstraction de l'interface proc√©durale d'OpenGL, fournissant au d√©veloppeur un ensemble de classes qui encapsulent la m√©canique enti√®re de l'API OpneGL.  D'autre part, il r√©sume √©galement une interface utilisateur graphique sp√©cifique, car les approches de sa mise en ≈ìuvre sont diff√©rentes pour diff√©rentes plates-formes et ont des fonctionnalit√©s m√™me au sein de la m√™me plate-forme (MFC, Qt, .Net pour Windows, par exemple). <br><br>  Quelle que soit la plateforme, du point de vue de l'application, l'interaction de l'utilisateur avec l'interface graphique se r√©sume √† la g√©n√©ration d'une s√©quence d'√©v√©nements par ses √©l√©ments, qui sont ensuite trait√©s √† l'int√©rieur de l'application.  La plupart des cadres graphiques utilisent cette approche, mais m√™me au sein de la m√™me plate-forme, ils ne sont malheureusement pas compatibles les uns avec les autres. <br><br>  Pour cette raison, OSG fournit sa propre interface de base pour g√©rer les √©v√©nements de widget widget et les entr√©es utilisateur bas√©es sur la classe osgGA :: GUIEventHandler.  Ce gestionnaire peut √™tre attach√© √† la visionneuse en appelant la m√©thode addEventHandler () et supprim√© par la m√©thode removeEventHandler ().  Naturellement, la classe de gestionnaire concret doit √™tre h√©rit√©e de la classe osgGA :: GUIEventHandler et la m√©thode handle () doit y √™tre red√©finie.  Cette m√©thode accepte deux arguments: osgGA :: GUIEventAdapter, qui contient la file d'attente des √©v√©nements de l'interface graphique et osg :: GUIActionAdepter, utilis√© pour les commentaires.  Typique dans la d√©finition est une telle conception <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdepter &amp;aa)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br>  Le param√®tre osgGA :: GUIActionAdapter permet au d√©veloppeur de demander √† l'interface graphique d'intervenir en r√©ponse √† l'√©v√©nement.  Dans la plupart des cas, une visionneuse est affect√©e par ce param√®tre, un pointeur vers lequel peut √™tre obtenu par conversion de pointeur dynamique <br><br><pre> <code class="cpp hljs">osgViewer::Viewer* viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><h1>  1. Gestion des √©v√©nements du clavier et de la souris </h1><br>  La classe osgGA :: GUIEventAdapter () g√®re tous les types d'√©v√©nements pris en charge par OSG, fournissant des donn√©es pour la d√©finition et la r√©cup√©ration de leurs param√®tres.  La m√©thode getEventType () renvoie l'√©v√©nement GUI actuel contenu dans la file d'attente d'√©v√©nements.  Chaque fois, en rempla√ßant la m√©thode handle () du gestionnaire, lors de l'appel de ces m√©thodes, vous devez utiliser ce getter pour recevoir l'√©v√©nement et d√©terminer son type. <br><br>  Le tableau suivant d√©crit tous les √©v√©nements disponibles. <br><br><table><thead><tr><th>  Type d'√©v√©nement </th><th>  La description </th><th>  M√©thodes de r√©cup√©ration des donn√©es d'√©v√©nement </th></tr></thead><tbody><tr><td>  PUSH / RELEASE / DOUBLECLICK </td><td>  Cliquez / rel√¢chez et double-cliquez sur les boutons de la souris </td><td>  getX (), getY () - obtenir la position du curseur.  getButton () - code du bouton enfonc√© (LEFT_MOUSE_BUTTON, RIGHT_MOUSE_BUTTON, MIDDLE_MOUSE_BUTTON </td></tr><tr><td>  Scrol </td><td>  Molette (s) de la souris </td><td>  getScrollingMotion () - retourne SCROOL_UP, SCROLL_DOWN, SCROLL_LEFT, SCROLL_RIGHT </td></tr><tr><td>  DRAG </td><td>  Glisser la souris </td><td>  getX (), getY () - position du curseur;  getButtonMask () - valeurs similaires √† getButton () </td></tr><tr><td>  D√âPLACER </td><td>  D√©placement de la souris </td><td>  getX (), getY () - position du curseur </td></tr><tr><td>  KEYDOWN / KEYUP </td><td>  Appuyer / rel√¢cher une touche d'un clavier </td><td>  getKey () - Code ASCII de la touche enfonc√©e ou la valeur de l'√©num√©rateur Key_Symbol (par exemple, KEY_BackSpace) </td></tr><tr><td>  CADRE </td><td>  √âv√©nement g√©n√©r√© lors du rendu d'une image </td><td>  pas d'entr√©e </td></tr><tr><td>  UTILISATEUR </td><td>  √âv√©nement d√©fini par l'utilisateur </td><td>  getUserDataPointer () - renvoie un pointeur vers un tampon de donn√©es utilisateur (le tampon est contr√¥l√© par un pointeur intelligent) </td></tr></tbody></table><br>  Il existe √©galement une m√©thode getModKeyMask () pour obtenir des informations sur la touche de modification enfonc√©e (renvoie les valeurs de la forme MODKEY_CTRL, MODKEY_SHIFT, MODKEY_ALT, etc.), vous permettant de traiter les combinaisons de touches utilisant des modificateurs <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ea.getModKeyMask() == osgGA::GUIEventAdapter::MODKEY_CTRL) { <span class="hljs-comment"><span class="hljs-comment">//    Ctrl }</span></span></code> </pre><br>  Gardez √† l'esprit que les m√©thodes de d√©finition comme setX (), setY (), setEventType (), etc.  non utilis√© dans le gestionnaire handle ().  Ils sont appel√©s par le syst√®me de fen√™trage graphique de bas niveau OSG pour mettre l'√©v√©nement en file d'attente. <br><br><h1>  2. Nous contr√¥lons le cessna √† partir du clavier </h1><br>  Nous savons d√©j√† comment transformer des objets de sc√®ne via les classes osg :: MatrixTransform.  Nous avons examin√© diff√©rents types d'animations √† l'aide des classes osg :: AnimationPath et osg :: Animation.  Mais pour l'interactivit√© d'une application (comme un jeu), l'animation et les transformations ne sont clairement pas suffisantes.  L'√©tape suivante consiste √† contr√¥ler la position des objets sur la sc√®ne √† partir des p√©riph√©riques d'entr√©e utilisateur.  Essayons de fixer la gestion √† notre bien-aim√© cessna. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de clavier</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ModelController : public osgGA::GUIEventHandler { public: ModelController( osg::MatrixTransform *node ) : _model(node) {} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool ModelController::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (void) aa; if (!_model.valid()) return false; osg::Matrix matrix = _model-&gt;getMatrix(); switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: switch (ea.getKey()) { case 'a': case 'A': matrix *= osg::Matrix::rotate(-0.1, osg::Z_AXIS); break; case 'd': case 'D': matrix *= osg::Matrix::rotate( 0.1, osg::Z_AXIS); break; case 'w': case 'W': matrix *= osg::Matrix::rotate(-0.1, osg::X_AXIS); break; case 's': case 'S': matrix *= osg::Matrix::rotate( 0.1, osg::X_AXIS); break; default: break; } _model-&gt;setMatrix(matrix); break; default: break; } return true; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(mt.get()); osg::ref_ptr&lt;ModelController&gt; mcontrol = new ModelController(mt.get()); osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get()); viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(0.0f, -100.0f, 0.0f), osg::Vec3(), osg::Z_AXIS ); viewer.getCamera()-&gt;setAllowEventFocus(false); viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pour r√©soudre ce probl√®me, nous √©crivons une classe de gestionnaire d'√©v√©nements d'entr√©e <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelController</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelController( osg::MatrixTransform *node ) : _model(node) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::MatrixTransform&gt; _model; };</code> </pre><br>  Lors de la construction de cette classe, en tant que param√®tre, un pointeur est transmis au n≈ìud de transformation, sur lequel nous agirons dans le gestionnaire.  La m√©thode du gestionnaire handle () elle-m√™me est red√©finie comme suit <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ModelController::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) aa; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_model.valid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; osg::Matrix matrix = _model-&gt;getMatrix(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::KEYDOWN: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getKey()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'D'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'w'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'W'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'s'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'S'</span></span>: matrix *= osg::Matrix::rotate( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, osg::X_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } _model-&gt;setMatrix(matrix); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Parmi les d√©tails essentiels de sa mise en ≈ìuvre, il convient de noter que nous devons d'abord obtenir la matrice de transformation √† partir du n≈ìud que nous contr√¥lons <br><br><pre> <code class="cpp hljs">osg::Matrix matrix = _model-&gt;getMatrix();</code> </pre><br>  Ensuite, deux instructions switch () imbriqu√©es analysent le type d'√©v√©nement (frappe) et le code de la touche enfonc√©e.  En fonction du code de la touche enfonc√©e, la matrice de transformation courante est multipli√©e par une matrice de rotation suppl√©mentaire autour de l'axe correspondant <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span>: matrix *= osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, osg::Z_AXIS); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  - tournez l'avion √† des angles de lacet de -0,1 radians lorsque vous appuyez sur la touche "A". <br><br>  Apr√®s avoir trait√© les frappes, n'oubliez pas d'appliquer une nouvelle matrice de transformation au n≈ìud de transformation <br><br><pre> <code class="cpp hljs">_model-&gt;setMatrix(matrix);</code> </pre><br>  Dans la fonction main (), chargez le mod√®le d'avion et cr√©ez un n≈ìud de transformation parent pour celui-ci, en ajoutant le sous-graphique r√©sultant au n≈ìud racine de la sc√®ne <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mt-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(mt.get());</code> </pre><br>  Cr√©er et initialiser un gestionnaire de saisie utilisateur <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;ModelController&gt; mcontrol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelController(mt.get());</code> </pre><br>  Cr√©ez une visionneuse en y ajoutant notre gestionnaire <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.addEventHandler(mcontrol.get());</code> </pre><br>  Configurer la matrice de vue de la cam√©ra <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setViewMatrixAsLookAt( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-100.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(), osg::Z_AXIS );</code> </pre><br>  Interdire √† la cam√©ra de recevoir des √©v√©nements des p√©riph√©riques d'entr√©e <br><br><pre> <code class="cpp hljs">viewer.getCamera()-&gt;setAllowEventFocus(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Si cela n'est pas fait, le gestionnaire accroch√© √† la cam√©ra interceptera par d√©faut toutes les entr√©es utilisateur et interf√©rera avec notre gestionnaire.  Nous d√©finissons les donn√©es de la sc√®ne au spectateur et les ex√©cutons <br><br><pre> <code class="cpp hljs">viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Maintenant, apr√®s avoir lanc√© le programme, nous pourrons contr√¥ler l'orientation de l'avion dans l'espace en appuyant sur les touches A, D, W et S. <br><br><img src="https://habrastorage.org/webt/a0/gu/od/a0guoddsokpfkthvefo07tfn1h4.gif"><br><br>  Une question int√©ressante est de savoir ce que la m√©thode handle () devrait retourner en la quittant.  Si true est retourn√©, alors nous indiquons OSG, alors nous avons d√©j√† trait√© les √©v√©nements d'entr√©e et aucun traitement suppl√©mentaire n'est n√©cessaire.  Le plus souvent, ce comportement ne nous convient pas, il est donc recommand√© de renvoyer false du gestionnaire afin de ne pas interrompre le traitement des √©v√©nements par d'autres gestionnaires s'ils sont attach√©s √† d'autres n≈ìuds de la sc√®ne. <br><br><h1>  3. Utilisation des visiteurs dans le traitement des √©v√©nements </h1><br>  Semblable √† la fa√ßon dont il est impl√©ment√© lors de la travers√©e d'un graphe de sc√®ne lors de sa mise √† jour, OSG prend en charge les rappels pour g√©rer les √©v√©nements qui peuvent √™tre associ√©s aux n≈ìuds et aux objets g√©om√©triques.  Pour cela, des appels √† setEventCallback () et addEventCallback () sont utilis√©s, qui prennent en param√®tre un pointeur sur l'osg :: NodeCallback enfant.  Pour recevoir des √©v√©nements dans l'op√©rateur operator (), nous pouvons convertir le pointeur qui lui est transmis au visiteur du site en un pointeur vers osgGA :: EventVisitor, par exemple comme ceci <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/EventVisitor&gt; ... void operator()( osg::Node *node, osg::NodeVisitor *nv ) { std::list&lt;osg::ref_ptr&lt;osgGA::GUIEventAdapter&gt;&gt; events; osgGA::EventVisitor *ev = dynamic_cast&lt;osgGA::EventVisitor *&gt;(nv); if (ev) { events = ev-&gt;getEvents(); //       } }</span></span></span></span></code> </pre><br><h1>  4. Cr√©ation et traitement d'√©v√©nements personnalis√©s </h1><br>  OSG utilise une file d'attente d'√©v√©nements interne (FIFO).  Les √©v√©nements au d√©but de la file d'attente sont trait√©s et supprim√©s de celle-ci.  Les √©v√©nements nouvellement g√©n√©r√©s sont plac√©s √† la fin de la file d'attente.  La m√©thode handle () de chaque gestionnaire d'√©v√©nements sera ex√©cut√©e autant de fois qu'il y a d'√©v√©nements dans la file d'attente.  La file d'attente d'√©v√©nements est d√©crite par la classe osgGA :: EventQueue, qui, entre autres, vous permet de placer un √©v√©nement dans la file d'attente √† tout moment en appelant la m√©thode addEvent ().  L'argument de cette m√©thode est un pointeur sur osgGA :: GUIEventAdapter, qui peut √™tre d√©fini sur un comportement sp√©cifique √† l'aide des m√©thodes setEventType (), etc. <br><br>  L'une des m√©thodes de la classe osgGA :: EventQueue est userEvent (), qui d√©finit un √©v√©nement utilisateur en l'associant aux donn√©es utilisateur, un pointeur vers lequel lui est transmis en tant que param√®tre.  Ces donn√©es peuvent √™tre utilis√©es pour repr√©senter tout √©v√©nement personnalis√©. <br><br>  Impossible de cr√©er sa propre instance de la file d'attente d'√©v√©nements.  Cette instance a d√©j√† √©t√© cr√©√©e et attach√©e √† l'instance de la visionneuse, vous ne pouvez donc obtenir qu'un pointeur vers ce singleton <br><br><pre> <code class="cpp hljs">viewer.getEventQueue()-&gt;userEvent(data);</code> </pre><br>  Les donn√©es utilisateur sont un objet de l'h√©ritier d'osg :: Referenced, c'est-√†-dire que vous pouvez y cr√©er un pointeur intelligent. <br><br>  Lorsqu'un √©v√©nement personnalis√© est re√ßu, le d√©veloppeur peut en extraire des donn√©es en appelant la m√©thode getUserData () et le traiter comme bon lui semble. <br><br><h1>  5. Impl√©mentation du temporisateur utilisateur </h1><br>  De nombreuses biblioth√®ques et frameworks qui impl√©mentent l'interface graphique fournissent un d√©veloppeur de classe pour impl√©menter des temporisateurs qui g√©n√®rent un √©v√©nement apr√®s un certain intervalle de temps.  OSG ne contient pas de moyens r√©guliers pour impl√©menter des minuteries, alors essayons d'impl√©menter une sorte de minuteur nous-m√™mes, en utilisant l'interface pour cr√©er des √©v√©nements personnalis√©s. <br><br>  Sur quoi pouvons-nous compter pour r√©soudre ce probl√®me?  Pour un certain √©v√©nement p√©riodique qui est constamment g√©n√©r√© par le rendu, par exemple sur FRAME, l'√©v√©nement de dessin de l'image suivante.  Pour cela, nous utilisons le m√™me exemple avec le passage du mod√®le de cessna de normal √† br√ªlant. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de minuterie</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/GUIEventHandler&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct TimerInfo : public osg::Referenced { TimerInfo(unsigned int c) : _count(c) {} unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class TimerHandler : public osgGA::GUIEventHandler { public: TimerHandler(osg::Switch *sw, unsigned int interval = 1000) : _switch(sw) , _count(0) , _startTime(0.0) , _interval(interval) , _time(0) { } virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: osg::ref_ptr&lt;osg::Switch&gt; _switch; unsigned int _count; double _startTime; unsigned int _interval; unsigned int _time; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool TimerHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = dynamic_cast&lt;osgViewer::Viewer *&gt;(&amp;aa); if (!viewer) break; double time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); unsigned int delta = static_cast&lt;unsigned int&gt;( (time - _startTime) * 1000.0); _startTime = time; if ( (_count &gt;= _interval) || (_time == 0) ) { viewer-&gt;getEventQueue()-&gt;userEvent(new TimerInfo(_time)); _count = 0; } _count += delta; _time += delta; break; } case osgGA::GUIEventAdapter::USER: if (_switch.valid()) { const TimerInfo *ti = dynamic_cast&lt;const TimerInfo *&gt;(ea.getUserData()); std::cout &lt;&lt; "Timer event at: " &lt;&lt; ti-&gt;_count &lt;&lt; std::endl; _switch-&gt;setValue(0, !_switch-&gt;getValue(0)); _switch-&gt;setValue(1, !_switch-&gt;getValue(1)); } break; default: break; } return false; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.addEventHandler(new TimerHandler(root.get(), 1000)); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  D√©terminons d'abord le format des donn√©es envoy√©es dans le message utilisateur, en le d√©finissant comme une structure <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Referenced { TimerInfo(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) : _count(c) {} <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br>  Le param√®tre _count contiendra le nombre entier de millisecondes qui se sont √©coul√©es entre le moment o√π le programme a √©t√© lanc√© et le prochain √©v√©nement de temporisation a √©t√© re√ßu.  La structure h√©rite de la classe osg :: Referenced afin qu'elle puisse √™tre contr√¥l√©e via des pointeurs intelligents OSG.  Cr√©ez maintenant un gestionnaire d'√©v√©nements <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TimerHandler(osg::Switch *sw, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval = <span class="hljs-number"><span class="hljs-number">1000</span></span>) : _switch(sw) , _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) , _startTime(<span class="hljs-number"><span class="hljs-number">0.0</span></span>) , _interval(interval) , _time(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osg::Switch&gt; _switch; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _startTime; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _interval; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _time; };</code> </pre><br>  Ce gestionnaire a plusieurs membres prot√©g√©s sp√©cifiques.  La variable _switch indique un n≈ìud qui change de mod√®le d'avion;  _count - le compte √† rebours relatif du temps √©coul√© depuis la derni√®re g√©n√©ration de l'√©v√©nement timer, sert √† compter les intervalles de temps;  _startTime - une variable temporaire pour stocker le compte √† rebours pr√©c√©dent, effectu√©e par le spectateur;  _time - la dur√©e totale de fonctionnement du programme en millisecondes.  Le constructeur de classe accepte un n≈ìud de commutation comme param√®tre et, facultativement, l'intervalle de temps requis pour que le temporisateur de commutation fonctionne. <br><br>  Dans cette classe, nous rempla√ßons la m√©thode handle () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> TimerHandler::handle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::FRAME: { osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!viewer) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); _startTime = time; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _count += delta; _time += delta; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Nous analysons ici le type de message re√ßu.  S'il s'agit de FRAME, les actions suivantes sont effectu√©es: <br><ol><li>  Obtenez un pointeur vers le spectateur <br></li></ol><br><pre> <code class="cpp hljs">osgViewer::Viewer *viewer = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgViewer::Viewer *&gt;(&amp;aa);</code> </pre><br><ol><li>  √Ä la r√©ception du pointeur correct, lisez le temps √©coul√© depuis le d√©marrage du programme <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time = viewer-&gt;getFrameStamp()-&gt;getReferenceTime();</code> </pre><br>  calculer le temps pass√© √† restituer une image en millisecondes <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( (time - _startTime) * <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  et rappelez-vous le compte de temps actuel <br><br><pre> <code class="cpp hljs">_startTime = time;</code> </pre><br>  Si la valeur du compteur _count a d√©pass√© l'intervalle de temps requis (ou s'il s'agit du premier appel lorsque _time est toujours nul), nous mettons le message utilisateur dans la file d'attente, en transmettant dans la structure ci-dessus le temps du programme en millisecondes.  Le compteur _count est remis √† z√©ro <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (_count &gt;= _interval) || (_time == <span class="hljs-number"><span class="hljs-number">0</span></span>) ) { viewer-&gt;getEventQueue()-&gt;userEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerInfo(_time)); _count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Quelle que soit la valeur de _count, nous devons l'augmenter et _time de la quantit√© de retard n√©cessaire pour dessiner un cadre <br><br><pre> <code class="cpp hljs">_count += delta; _time += delta;</code> </pre><br>  C'est ainsi que l'√©v√©nement timer sera g√©n√©r√©.  La gestion des √©v√©nements est impl√©ment√©e comme suit <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::USER: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_switch.valid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *ti = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimerInfo *&gt;(ea.getUserData()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Timer event at: "</span></span> &lt;&lt; ti-&gt;_count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); _switch-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !_switch-&gt;getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Ici, nous v√©rifions la validit√© du pointeur sur le n≈ìud de commutation, soustrayons les donn√©es de l'√©v√©nement, provenant de la structure TimerInfo, affichons le contenu de la structure √† l'√©cran et changeons l'√©tat du n≈ìud. <br><br>  Le code de la fonction main () est similaire au code des deux exemples de commutation pr√©c√©dents, √† la diff√©rence que dans ce cas, nous suspendons un gestionnaire d'√©v√©nements au visualiseur <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerHandler(root.get(), <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre><br>  transmettre le pointeur au n≈ìud racine et l'intervalle de commutation requis en millisecondes au constructeur du gestionnaire.  En ex√©cutant l'exemple, nous verrons que les mod√®les commutent √† des intervalles d'une seconde, et dans la console, nous trouvons la sortie des moments auxquels la commutation s'est produite <br><br><pre> <code class="plaintext hljs">Timer event at: 0 Timer event at: 1000 Timer event at: 2009 Timer event at: 3017 Timer event at: 4025 Timer event at: 5033</code> </pre><br>  Un √©v√©nement personnalis√© peut √™tre g√©n√©r√© √† tout moment pendant l'ex√©cution du programme, et pas seulement lors de la r√©ception de l'√©v√©nement FRAME, ce qui donne un m√©canisme tr√®s flexible pour l'√©change de donn√©es entre les parties du programme, permet de traiter les signaux provenant de p√©riph√©riques d'entr√©e non standard, tels que des joysticks ou des gants VR, par exemple. <br><br>  <i>√Ä suivre ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438218/">https://habr.com/ru/post/fr438218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438204/index.html">Dispositif de compilateur Swift. Partie 1</a></li>
<li><a href="../fr438206/index.html">26 recommandations pour l'utilisation du type var en Java</a></li>
<li><a href="../fr438210/index.html">Civilisation des ressorts, 2/5</a></li>
<li><a href="../fr438212/index.html">Preuve de concept: comment v√©rifier que la mise en ≈ìuvre du ML en vaut la chandelle</a></li>
<li><a href="../fr438214/index.html">Les startups technologiques am√©ricaines feront face √† de nouveaux contr√¥les gouvernementaux en 2019</a></li>
<li><a href="../fr438224/index.html">Quartier du gouvernement. Pilote</a></li>
<li><a href="../fr438226/index.html">R√©soudre les probl√®mes d'installation de .NET Framework 3.5 sur Windows 8 sur un r√©seau avec WSUS</a></li>
<li><a href="../fr438228/index.html">Avez-vous command√© des lunettes vid√©o transparentes avec HDMI et USB-C? Rencontre: Epson Moverio BT-35E</a></li>
<li><a href="../fr438230/index.html">Traduction "Pr√©parez vos applications pour les exigences 64 bits"</a></li>
<li><a href="../fr438234/index.html">R√©sum√© des √©v√©nements informatiques de f√©vrier</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>