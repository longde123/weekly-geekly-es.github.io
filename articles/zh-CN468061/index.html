<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 🥀 📮 Linux上的Cron：历史记录，用法和设备 👩‍⚖️ 🗡️ 🥔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="经典著作写道，欢乐时光没有被观察到。 在那些荒芜的时代，既没有程序员也没有Unix，但是如今程序员已经非常了解：cron将代替时间，而不是他们。 


 对我而言，命令行实用程序既有弱点，又有常规性。 sed，awk，wc，cut和其他旧程序每天由我们服务器上的脚本运行。 他们中的许多人都是作为70...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux上的Cron：历史记录，用法和设备</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p> 经典著作写道，欢乐时光没有被观察到。 在那些荒芜的时代，既没有程序员也没有Unix，但是如今程序员已经非常了解：cron将代替时间，而不是他们。 </p><br><p> 对我而言，命令行实用程序既有弱点，又有常规性。  sed，awk，wc，cut和其他旧程序每天由我们服务器上的脚本运行。 他们中的许多人都是作为70年代的调度程序cron的任务而设计的。 </p><br><p> 很长时间以来，我只是简单地使用了cron，而没有涉及任何细节，但是有一次，在运行脚本时遇到错误，我决定彻底弄清楚。 因此，在撰写本文时，我熟悉了POSIX crontab，流行的Linux发行版中的主要cron变体以及其中的某些设备，从而出现了这篇文章。 </p><br><p> 使用Linux并在cron中运行任务？ 对Unix系统应用程序架构感兴趣？ 然后我们就在路上！ </p><a name="habracut"></a><br><h1 id="soderzhanie"> 目录内容 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">物种起源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">畅销书-Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Debian和Ubuntu上使用cron</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cronie在Red Hat，Fedora和CentOS上</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SLES和openSUSE中的cronie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vixie Cron设备</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">后记</a> </li></ul><br><h1 id="proishozhdenie-vidov"> 物种起源 </h1><br><p> 显然，所有操作系统都需要定期执行用户或系统程序。 因此，对于允许集中计划和执行任务的服务的需求，程序员已经实现了很长的时间。 </p><br><p>类似Unix的操作系统的谱系来自1970年代由Bell Labs开发的Version 7 Unix，其中包括著名的Ken Thompson。 与版本7 Unix一起，提供了cron，该服务用于定期执行超级用户任务。 </p><br><p> 典型的现代cron是一个简单的程序，但是原始版本的算法甚至更简单：该服务每分钟唤醒一次，从单个文件（/ etc / lib / crontab）中读取任务板，并在当前时间执行应为超级用户执行的任务。 </p><br><p> 随后，所有类似Unix的操作系统都提供了用于简单有用的服务的高级选项。 </p><br><p> 类似于Unix的操作系统的主要标准POSIX中包含了1992年对crontab格式的通用描述和实用程序的基本原理，因此，事实上的cron成为了法律上的标准。 </p><br><p>  1987年，Paul Vixie在采访了Unix用户以获取有关cron的建议后，发布了该守护程序的另一个版本，该守护程序解决了传统cron的某些问题并扩展了表文件的语法。 </p><br><p> 在第三个版本中，Vixie cron开始满足POSIX的要求，此外，该程序具有自由许可证，或者什至根本没有许可证，除了README的愿望：作者不提供保证，您不能删除作者的名字，并且只能在以下情况下出售程序：源代码。 事实证明，这些要求与自由软件的原理兼容，自由软件的原理在那些年中变得越来越流行，因此90年代初出现的一些关键Linux发行版采用Vixie cron作为系统，并且仍在开发中。 </p><br><p> 特别是Red Hat和SUSE正在开发Vixie cron-cronie fork，而Debian和Ubuntu在使用带有许多补丁程序的原始Vixie cron。 </p><br><p> 首先，让我们熟悉POSIX中描述的用户定义的crontab实用程序，然后我们将研究Vixie cron中引入的语法扩展以及在流行的Linux发行版中使用Vixie cron变体。 最后，蛋糕上的樱桃是cron守护程序设备的解析。 </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p> 如果原始的cron始终为超级用户工作，那么现代的调度程序通常会处理普通用户的任务，这更安全，更方便。 </p><br><p>  Cron附带了两个程序集：不断运行的cron守护程序和可供用户使用的crontab实用程序。 后者允许您编辑特定于系统中每个用户的任务表，而守护程序则从用户和系统表启动任务。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">POSIX标准</a>未描述守护程序的行为，仅将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">crontab</a>用户程序形式化。 当然，暗示了存在用于启动用户任务的机制，但是没有详细描述。 </p><br><p> 使用crontab实用程序可以执行四件事：在编辑器中编辑用户任务表，从文件中加载表，显示当前任务表，并清除任务表。  crontab实用程序的示例： </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p> 调用<code>crontab -e</code> ，将使用在标准<code>EDITOR</code>环境<code>EDITOR</code>指定的编辑器。 </p><br><p> 任务本身以以下格式描述： </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p> 前五个记录字段：分钟[1..60]，小时[0..23]，每月[1..31]，月份[1..12]，一周[0..6]，其中0-周日。 最后的第六个字段是将由标准命令解释器执行的字符串。 </p><br><p> 在前五个字段中，值可以用逗号列出： </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p> 或通过连字符： </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  POSIX文件cron.allow和cron.deny中分别规定了用户对任务计划的访问权限，该文件分别列出了有权访问crontab的用户和无法访问程序的用户。 该标准不规范这些文件的位置。 </p><br><p> 根据标准，正在运行的程序必须至少传递四个环境变量： </p><br><ol><li>  HOME是用户的主目录。 </li><li>  LOGNAME-用户登录。 </li><li>  PATH是查找标准系统实用程序的路径。 </li><li>  SHELL是所用外壳的路径。 </li></ol><br><p> 值得注意的是，POSIX没有说明这些变量的值来自何处。 </p><br><h1 id="hit-prodazh--vixie-cron-30pl1"> 畅销书-Vixie cron 3.0pl1 </h1><br><p> 流行的cron变体的共同祖先是Vixie cron 3.0pl1，出现在1992 comp.sources.unix邮件列表中。 我们将更详细地考虑此版本的主要功能。 </p><br><p>  Vixie cron包含两个程序（cron和crontab）。 通常，守护程序负责从系统任务表和单个用户的任务表中读取和启动任务，而crontab实用程序负责编辑用户表。 </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii"> 任务表和配置文件 </h3><br><p> 超级用户任务表位于/ etc / crontab中。 系统表的语法与Vixie cron的语法相对应，已针对以下事实进行了调整：第六列指示启动任务的用户名称： </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p> 通用用户任务表位于/ var / cron / tabs / username中，并使用通用语法。 启动crontab实用程序后，这些文件将代表用户进行编辑。 </p><br><p> 可以在文件/ var / cron / allow和/ var / cron / deny中管理有权访问crontab的用户列表，将用户名添加为单独的一行就足够了。 </p><br><h3 id="rasshirennyy-sintaksis"> 扩展语法 </h3><br><p> 与POSIX crontab相比，Paul Vixie的解决方案对实用程序任务表语法进行了一些非常有用的修改。 </p><br><p> 新的表语法已可用：例如，您可以按名称（星期一，星期二等）指定星期几或月份： </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p> 您可以指定启动任务的步骤： </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p> 步骤和间隔可以混合： </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p> 支持常规语法的直观替代（重新启动，每年，每年，每月，每月，每周，每天，午夜，每小时）： </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach"> 任务执行环境 </h3><br><p>  Vixie cron允许您更改正在运行的应用程序的环境。 </p><br><p> 守护程序不仅提供USER，LOGNAME和HOME环境变量，而且还从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">passwd文件中获取</a> 。  PATH变量获取值“ / usr / bin：/ bin”，而SHELL获取值“ / bin / sh”。 可以在用户表中更改除LOGNAME之外的所有变量的值。 </p><br><p>  cron本身使用一些环境变量（主要是SHELL和HOME）来运行任务。 这是使用bash而不是标准sh来运行自定义任务的样子： </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p> 最终，表中定义的所有环境变量（由cron使用或为流程所必需）都将传输到正在运行的任务。 </p><br><p>  crontab实用程序使用VISUAL或EDITOR环境变量中指定的编辑器来编辑文件。 如果在启动crontab的环境中未定义这些变量，则使用“ / usr / ucb / vi”（ucb可能是加州大学伯克利分校）。 </p><br><h1 id="cron-v-debian-i-ubuntu"> 在Debian和Ubuntu上使用cron </h1><br><p>  Debian和派生开发人员发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高度修改</a>的Vixie cron版本3.0pl1。 表文件的语法没有差异；对于用户而言，这是相同的Vixie cron。 最大的新功能： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">syslog</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SELinux</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PAM</a>支持。 </p><br><p> 较不明显但切实的更改-配置文件和任务表的位置。 </p><br><p>  Debian中的用户表位于目录/ var / spool / cron / crontabs中，系统表仍位于/ etc / crontab中。 特定于Debian的任务表位于/etc/cron.d中，cron守护程序从中自动读取它们。 用户访问控制由/etc/cron.allow和/etc/cron.deny文件控制。 </p><br><p> 默认shell / bin / sh仍然用作默认shell Debian播放一个与POSIX兼容的小型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dash</a> shell，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dash</a> shell运行时无需读取任何配置（在非交互模式下）。 </p><br><p> 最新版本的Debian中的Cron本身是通过systemd启动的，可以在/lib/systemd/system/cron.service中查看启动配置。 服务的配置没有什么特别的；任何更精细的任务管理都可以通过直接在每个用户的crontab中声明的环境变量来完成。 </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie在RedHat，Fedora和CentOS上 </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cronie</a> -Vixie cron版本4.1的fork。 与在Debian中一样，语法没有改变，但是增加了对PAM和SELinux的支持，在集群中工作，使用inotify跟踪文件以及其他功能。 </p><br><p> 默认配置位于通常的位置：系统表位于/ etc / crontab中，程序包将其表置于/etc/cron.d中，用户表位于/ var / spool / cron / crontabs中。 </p><br><p> 该守护程序在systemd下运行，服务配置为/lib/systemd/system/crond.service。 </p><br><p> 在启动时，类似Red Hat的发行版默认使用/ bin / sh，其作用是标准bash。 应该注意的是，通过/ bin / sh运行cron任务时，bash shell在POSIX兼容模式下启动，并且在非交互模式下运行时不会读取任何其他配置。 </p><br><h1 id="cronie-v-sles-i-opensuse">  SLES和openSUSE中的cronie </h1><br><p>  German SLES发行版及其openSUSE派生使用相同的cronie。 守护程序也在systemd下运行，服务配置位于/usr/lib/systemd/system/cron.service中。 配置：/etc/crontab、/etc/cron.d、/var/spool/cron/tabs。 由于/ bin / sh行为相同，因此以兼容POSIX的非交互模式启动。 </p><br><h1 id="ustroystvo-vixie-cron">  Vixie Cron设备 </h1><br><p> 与Vixie cron相比，cron的现代后代没有发生根本变化，但是尽管如此，他们已经获得了理解程序原理所不需要的新功能。 这些扩展中的许多都是凌乱的，使代码混乱。  Paul Vixie编写的原始cron源代码非常有趣。 </p><br><p> 因此，我决定使用针对cron开发的两个分支的通用程序示例Vixie cron 3.0pl1分析cron设备。 我将通过删除使阅读变得复杂的ifdefs并省略次要细节来简化示例。 </p><br><p> 恶魔的工作可以分为几个阶段： </p><br><ol><li> 程序初始化。 </li><li> 收集并更新要运行的任务列表。 </li><li> 主cron循环操作。 </li><li> 任务启动。 </li></ol><br><p> 让我们对它们进行排序。 </p><br><h3 id="inicializaciya"> 初始化 </h3><br><p> 启动后，cron在检查过程参数之后，将安装SIGCHLD和SIGHUP信号处理程序。 第一个记录子进程的完成，第二个关闭日志文件的文件描述符： </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p> 系统中的cron守护程序始终始终单独工作，仅作为超级用户和cron主目录运行。 以下调用使用守护进程的PID创建文件锁，确保用户正确，然后将当前目录更改为主目录： </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p> 默认路径已设置，将在启动进程时使用： </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p> 然后，该进程被“守护”：通过调用fork和子进程中的新会话（调用setsid）来创建该进程的子副本。 父进程不再需要-它完成了工作： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p> 父进程的终止释放了锁文件上的锁。 另外，您需要将文件中的PID更新为子文件。 之后，将填充任务数据库： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p> 进一步的cron进入主要工作周期。 但在此之前，请看一下加载任务列表。 </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach"> 收集和更新任务列表 </h3><br><p>  load_database函数负责加载任务列表。 它检查主系统crontab和带有用户文件的目录。 如果文件和目录未更改，则不会重新读取任务列表。 否则，将开始形成新的任务列表。 </p><br><p> 下载具有特殊文件名和表名的系统文件： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p> 循环加载用户表： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p> 然后，将旧数据库替换为新数据库。 </p><br><p> 在上面的示例中，调用process_crontab函数可确保存在与表文件名匹配的用户（除非它是超级用户），然后调用load_user。 后者已经逐行读取文件本身： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p> 在这里，环境变量（格式为VAR = value的行）由load_env / env_set函数设置，或者任务描述（* * * * * / path /到/ exec）由load_entry函数读取。 </p><br><p>  load_entry返回的入口实体是我们的任务，位于一般任务列表中。 在函数本身中，对时间格式进行了冗长的分析，但是我们对环境变量和任务启动参数的形成更感兴趣： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p> 主循环还可以与当前任务列表一起使用。 </p><br><h3 id="glavnyy-cikl"> 主循环 </h3><br><p> 来自第7版Unix的原始cron的工作非常简单：在一个周期中，我重新读取了配置，以超级用户身份运行了当前分钟的任务，并一直睡到下一分钟开始。 在旧计算机上使用这种简单方法需要太多资源。 </p><br><p>  SysV中提出了一个替代版本，在该版本中，守护程序要么进入睡眠状态，要么直到定义任务的第二分钟，要么进入30分钟。 在这种模式下，用于重新读取配置和检查任务的资源较少，但是快速更新任务列表变得不便。 </p><br><p>  Vixie cron每分钟返回一次检查任务列表，因为到80年代末，标准Unix计算机上的资源变得越来越大： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p> 调用函数job_runqueue（任务的枚举和开始）和do_command（每个任务的开始）的cron_sleep函数直接参与任务的执行。 应该更详细地考虑最后一个功能。 </p><br><h3 id="zapusk-zadachi"> 任务启动 </h3><br><p>  do_command函数以良好的Unix风格执行，也就是说，它确实分叉用于异步任务执行。 父进程继续启动任务，子进程正在准备任务进程： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  child_process中有很多逻辑：它将标准输出和错误流传递到其自身上，以便随后可以将其发送到邮件（如果在任务表中指定了MAILTO环境变量），最后等待主任务过程完成。 </p><br><p> 任务过程由另一个分支形成： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  —    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p> 在这里，一般来说，整个cron。 我省略了一些有趣的细节，例如，说明远程用户，但概述了主要内容。 </p><br><h1 id="posleslovie"> 后记 </h1><br><p>  Cron是一个令人惊讶的简单实用的程序，它是Unix世界的最佳传统。 她没有做任何多余的事情，但是在过去的几十年中，她一直在出色地工作。 认识Ubuntu随附版本的代码只用了一个小时，我得到了很多乐趣！ 希望我能和你分享。 </p><br><p> 我不了解您，但是让我感到难过的是，现代编程由于具有重新复杂化和抽象化的趋势，早已不再具有这种简单性。 </p><br><p>  cron有许多现代替代方案：systemd-timers允许您组织具有依赖性的复杂系统，在fcron中，您可以更灵活地控制任务对资源的消耗。 但就我个人而言，我一直拥有最简单的crontab。 </p><br><p> 简而言之，请热爱Unix，使用简单的程序，不要忘记阅读平台的魔法！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468061/">https://habr.com/ru/post/zh-CN468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468043/index.html">如何创建要出售的UI套件。 开发商业设计系统的阶段</a></li>
<li><a href="../zh-CN468047/index.html">在lsFusion中使用层次结构</a></li>
<li><a href="../zh-CN468053/index.html">机器学习助您一臂之力。 第一部分</a></li>
<li><a href="../zh-CN468057/index.html">类似于Unix的OS开发-多任务处理和系统调用（7）</a></li>
<li><a href="../zh-CN468059/index.html">我与Hai句的第二个星期：很多隐藏的钻石和令人惊喜的惊喜，以及一些问题</a></li>
<li><a href="../zh-CN468063/index.html">角效应</a></li>
<li><a href="../zh-CN468065/index.html">面向所有人的心理产品管理模型</a></li>
<li><a href="../zh-CN468067/index.html">Alpha合成如何工作</a></li>
<li><a href="../zh-CN468071/index.html">Tungsten Labs首席技术官Eduard Medvedev：“我们已经发展到技术可能造成巨大伤害的地步”</a></li>
<li><a href="../zh-CN468073/index.html">安德烈·捷列霍夫（Andrei Terekhov）：“您可以随心所欲地说美国人更好，但我们的汽车永远不会抛锚”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>