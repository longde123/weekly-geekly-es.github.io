<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõãÔ∏è üçú üôÜüèΩ Curso MIT "Seguran√ßa de sistemas de computadores". Aula 3: Estouros de Buffer: Explora√ß√µes e Prote√ß√£o, Parte 3 üîû ‚ÜóÔ∏è üîñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula n¬∫ 6.858. "Seguran√ßa de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguran√ßa de sistemas de computadores". Aula 3: Estouros de Buffer: Explora√ß√µes e Prote√ß√£o, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418099/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula n¬∫ 6.858.  "Seguran√ßa de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security √© um curso sobre o desenvolvimento e implementa√ß√£o de sistemas de computador seguros.  As palestras abrangem modelos de amea√ßas, ataques que comprometem a seguran√ßa e t√©cnicas de seguran√ßa baseadas em trabalhos cient√≠ficos recentes.  Os t√≥picos incluem seguran√ßa do sistema operacional (SO), recursos, gerenciamento de fluxo de informa√ß√µes, seguran√ßa de idiomas, protocolos de rede, seguran√ßa de hardware e seguran√ßa de aplicativos da web. <br><br>  Palestra 1: ‚ÄúIntrodu√ß√£o: modelos de amea√ßas‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: ‚ÄúControle de ataques de hackers‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: ‚ÄúEstouros de Buffer: Explora√ß√µes e Prote√ß√£o‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Voc√™ pode usar a t√©cnica de adivinhar o "can√°rio" para seus pr√≥prios fins, a fim de descobrir a presen√ßa de bits "fracos", em termos de sele√ß√£o.  Ou seja, se voc√™ adivinhou corretamente, o servidor ir√° reiniciar, e isso servir√° como um sinal para voc√™ de que o valor definido √© bastante f√°cil de adivinhar.  Assim, √© poss√≠vel derrotar os ‚Äúcan√°rios‚Äù aleat√≥rios, assumindo que ap√≥s a reinicializa√ß√£o do servidor, seu valor n√£o ser√° alterado.  Voc√™ tamb√©m pode usar gadgets para implementar uma sequ√™ncia relacionada de v√°rios ataques. <br><br>  A seguir, veremos uma maneira mais produtiva na qual voc√™ pode usar todos esses m√©todos para impedir a preven√ß√£o de execu√ß√£o de dados, espa√ßos de endere√ßos aleat√≥rios e "can√°rios". <br><br>  Vamos voltar nossa aten√ß√£o para arquiteturas de 64 bits em vez de arquiteturas de 32 bits.  Os primeiros s√£o mais adequados para a randomiza√ß√£o, por isso oferecem muito mais "chance" de se defender contra um hacker.  E esses sistemas parecem muito mais interessantes em termos de forma√ß√£o de ataques. <br><br>  Esse tipo de arquitetura de 64 bits tamb√©m foi considerado do ponto de vista do <b>BROP</b> , programa√ß√£o ‚Äúcega‚Äù de orienta√ß√£o reversa.  Para simplificar, assumimos que a √∫nica diferen√ßa entre m√°quinas de 64 bits e 32 bits √© que, em uma m√°quina de 64 bits, os argumentos s√£o passados ‚Äã‚Äãpara os registradores e, para uma m√°quina de 32 bits, para a pilha. <br><br><img src="https://habrastorage.org/webt/hg/z1/jc/hgz1jcij9zzqbaqc3fiztx1ctze.jpeg"><br><br>  Quando uma fun√ß√£o come√ßa a execu√ß√£o, √© necess√°rio "procurar" em certos registradores para descobrir onde est√£o os argumentos. <br><br>  Agora vamos √† ess√™ncia da palestra de hoje - o que √© programa√ß√£o cega voltada para o retorno, ou <b>BROP</b> .  A primeira coisa que faremos √© encontrar um gadget de parada.  Lembre-se de que quando dizemos "gadget", queremos dizer essencialmente endere√ßos de retorno.  O gadget √© identificado com o endere√ßo de retorno, o endere√ßo inicial da sequ√™ncia de instru√ß√µes para a qual queremos ir.  Ent√£o, o que √© um gadget de parada? <br><br>  Essencialmente, √© o endere√ßo de retorno para algum lugar do c√≥digo; no entanto, se voc√™ pular para l√°, basta pausar o programa, mas n√£o cause a falha do programa.  √â por isso que isso √© chamado de gadget de parada. <br><br>  Voc√™ pode pular para algum lugar do c√≥digo, que inicia uma chamada do sistema inativa, ou faz uma pausa ou algo assim.  √â poss√≠vel que o programa de alguma forma "fique preso" em um loop infinito se voc√™ pular para este local.  Realmente n√£o importa por que a parada ocorre, mas voc√™ pode imaginar alguns cen√°rios que levariam a ela. <br><br>  Para que serve um gadget de parada? <br><br>  Assim que o atacante conseguiu derrotar o "can√°rio" usando a t√©cnica interativa de adivinhar bits, ele pode come√ßar a reescrever esse endere√ßo de retorno, o <b>endere√ßo de retiro</b> e come√ßa a "apalpar" o dispositivo de parada.  Observe que a maioria dos endere√ßos aleat√≥rios que voc√™ pode colocar na pilha provavelmente causar√° uma falha no servidor.  Novamente, esta mensagem √© para voc√™, atacante, √© uma indica√ß√£o de que o que voc√™ encontrou n√£o √© um gadget de parada.  Porque quando o servidor trava, o soquete √© fechado e voc√™, como invasor, entende que n√£o usou o dispositivo de parada.  Mas se voc√™ adivinhou algo e o soquete depois disso permanece aberto por um tempo, voc√™ pensa: "Sim, eu encontrei esse dispositivo de parada!"  Portanto, a id√©ia b√°sica do primeiro passo √© encontrar esse gadget de parada. <br><br><img src="https://habrastorage.org/webt/xb/af/zx/xbafzxirvhgep_31ahp8fuzpey4.jpeg"><br><br>  A segunda etapa √© que voc√™ deseja encontrar dispositivos que excluam entradas da pilha usando o comando <b>pop</b> .  Portanto, voc√™ deve usar esta sequ√™ncia de instru√ß√µes cuidadosamente projetadas para descobrir quando voc√™ pega um desses gadgets de pilha.  Essa sequ√™ncia consistir√° no <b>endere√ßo da sonda</b> , no <b>endere√ßo de parada do endere√ßo de parada</b> e no <b>endere√ßo de falha</b> do sistema do <b>endere√ßo de falha</b> . <br><br>  Portanto, o <b>endere√ßo do probe</b> √© o que vamos colocar na pilha.  Este ser√° o endere√ßo do gadget em potencial para limpar a pilha, o <b>endere√ßo de parada</b> - √© o que consideramos na primeira etapa, este √© o endere√ßo do gadget de parada.  Em seguida <b>, o endere√ßo de falha</b> ser√° simplesmente o endere√ßo do c√≥digo n√£o execut√°vel.  Aqui voc√™ pode simplesmente colocar o endere√ßo zero (0 x 0) e se voc√™ aplicar a fun√ß√£o <b>ret</b> a esse endere√ßo e tentar executar o c√≥digo l√°, isso causar√° uma falha no programa. <br><br><img src="https://habrastorage.org/webt/38/fa/ba/38fabavrj2kahtqh0_ruuxiigaa.jpeg"><br><br>  Portanto, podemos usar esses tipos de endere√ßos para descobrir onde esses gadgets limpam a <b>pilha</b> . <br><br>  Vou dar um exemplo simples.  Suponha que tenhamos dois exemplos diferentes de <b>sondas</b> , a armadilha de <b>captura</b> e a <b>armadilha de</b> <b>parada</b> .  Suponha que, com a ajuda do <b>probe,</b> vamos "testar" algum endere√ßo, suponha que ele comece com 4 e termine com oito: 0x4 ... 8, e atr√°s dele esteja o pr√≥ximo endere√ßo do formul√°rio 0x4 ... C.  Hipoteticamente, podemos supor que um desses dois endere√ßos seja o endere√ßo do gadget de <b>popping de pilha</b> . <br><br>  A <b>armadilha de trap</b> ter√° zero endere√ßos 0x0 e 0x0 e permitir√° que o dispositivo de <b>parada pare de</b> ter endere√ßos arbitr√°rios como 0xS ... 0xS ..., isso n√£o importa.  Esse gadget de parada aponta para o c√≥digo de suspens√£o (10), fazendo com que o programa seja pausado. <br><br>  Vamos come√ßar com a opera√ß√£o do <b>probe</b> , que limpa alguns registros e retorna na seguinte sequ√™ncia: <b>pop rax;</b>  <b>ret</b> .  O que vai acontecer?  Quando o sistema pula para esse endere√ßo, o ponteiro da pilha se move para o meio do nosso gadget.  O que o gadget vai fazer aqui?  Certo, execute <b>a</b> opera√ß√£o <b>pop rax</b> . <br><br><img src="https://habrastorage.org/webt/i2/eu/zr/i2euzrwlujsohfb4dl-szdeasac.jpeg"><br><br>  E depois segue <b>ret</b> , que mover√° a fun√ß√£o para a linha superior do gadget, ou seja, para <b>parar</b> , e a fun√ß√£o ser√° interrompida sem travar o programa inteiro.  Portanto, usando esse gadget, um invasor pode dizer que o endere√ßo do <b>probe</b> pertence a uma dessas fun√ß√µes, o que limpa a pilha, porque a conex√£o do cliente do servidor est√° aberta. <br><br>  Agora, vamos supor que o segundo endere√ßo do <b>probe</b> aponte para algo como <b>xor rax, rax, ret</b> para algum registro. <br><br><img src="https://habrastorage.org/webt/kw/5t/r3/kw5tr3vdtrqedphe0onl6ec-wa0.jpeg"><br><br>  Ent√£o, o que acontece se tentarmos pular para esse gadget?  Observe que ele n√£o limpa nada na pilha, apenas altera o conte√∫do dos registros.  Ent√£o, vamos retornar ao endere√ßo 0x0 localizado acima.  E isso far√° com que o sistema falhe.  A conex√£o do cliente com o servidor ser√° interrompida e o hacker entender√° que esse n√£o √© um gadget para limpar o <b>popping da pilha</b> . <br><br>  Dessa forma, voc√™ pode usar uma s√©rie mais bizarra de armadilhas e parar dispositivos, por exemplo, pode limpar dois itens na pilha.  Para fazer isso, basta colocar outra instru√ß√£o de <b>trap</b> aqui, e se esse gadget n√£o apagar dois elementos, voc√™ se encontrar√° em um desses trap e o c√≥digo interromper√° a execu√ß√£o.  Os materiais da palestra descrevem uma coisa chamada <b>gadget BROP,</b> que √© √∫til se voc√™ n√£o gosta de voltar √† programa√ß√£o.  Mas hoje tamb√©m mostrarei como voc√™ pode usar esses gadgets <b>pop</b> simples para iniciar um ataque semelhante.  Depois que voc√™ entender isso, ser√° muito mais f√°cil lidar com um <b>gadget BROP</b> . <br><br>  Mas todos voc√™s entendem como podemos usar a fun√ß√£o de <b>sonda</b> para esses gadgets?  Suponha que voc√™ encontre o local dos trechos de c√≥digo que permitem limpar a pilha com a fun√ß√£o <b>pop</b> , remova um elemento dela, mas voc√™ realmente n√£o sabe em qual registro essa fun√ß√£o <b>pop</b> funcionar√°.  Voc√™ apenas sabe que ela j√° est√° pronta para execu√ß√£o.  Mas voc√™ precisa saber em qual registro esses gadgets <b>pop</b> funcionar√£o, porque em uma arquitetura de 64 bits, os registros controlam onde est√£o localizados os argumentos da fun√ß√£o que voc√™ deseja chamar. <br><br>  Assim, nosso objetivo √© poder criar dispositivos que nos permitam excluir os valores que colocamos em determinados registros de pilha e, finalmente, iniciar uma chamada de <b>sistema de chamada de sistema</b> , o que nos permite fazer algo ruim. <br>  Portanto, agora precisamos determinar quais registros s√£o usados ‚Äã‚Äãpelos gadgets <b>pop</b> . <br><br><img src="https://habrastorage.org/webt/xp/w-/hw/xpw-hw9rdgd2argq0yx6xgi3ece.jpeg"><br><br>  Para fazer isso, podemos tirar proveito da chamada do sistema de pausa.  Se a chamada do sistema for pausada, a execu√ß√£o do programa ser√° suspensa e ele n√£o aceitar√° nenhum argumento.  E isso significa que o sistema ignora tudo nos registros. <br><br>  De fato, para encontrar a instru√ß√£o de pausa que estamos executando, voc√™ pode vincular todos esses gadgets <b>pop</b> para que possamos coloc√°-los todos na pilha e, entre cada um deles, <b>inserimos um n√∫mero syscall</b> para pausar.  Ent√£o veremos se podemos "suspender" o programa dessa maneira.  Deixe-me dar um exemplo concreto. <br><br>  Aqui, colocamos um gadget na barra de endere√ßo de retorno que limpa os registros da <b>RDI</b> e aplica a fun√ß√£o <b>ret</b> a eles.  Acima dele, colocaremos um <b>n√∫mero syscall</b> para pausar. <br><br>  Suponha que tenhamos mais um gadget localizado acima que implemente a fun√ß√£o <b>pop</b> em outro registro, digamos <b>RSI</b> e depois <b>ret</b> .  E ent√£o colocamos o <b>n√∫mero syscall</b> novamente para pausar.  E fazemos isso para todos os gadgets que encontramos e acabamos no topo da pilha com o endere√ßo putativo para <b>syscall</b> . <br><br><img src="https://habrastorage.org/webt/qd/yx/3v/qdyx3vymmlc13o-sceyeimho_ro.jpeg"><br><br>  Lembre-se novamente de como voc√™ usa essas chamadas do sistema.  Voc√™ deve colocar o <b>n√∫mero</b> <b>syscall no</b> registro <b>RAX</b> e chamar a fun√ß√£o <b>libc syscall</b> , que est√° prestes a fazer a chamada do sistema solicitada. <br><br>  Ent√£o, o que acontece quando executamos esse c√≥digo?  Vamos chegar aqui, na linha de <b>endere√ßo ret</b> , saltaremos para o endere√ßo desse gadget; observe que o invasor sabe que esse gadget, localizado √† direita, remove algo da pilha, mas ainda n√£o sabe em qual registro est√° localizado. <br><br>  Ent√£o, se pularmos para o <b>endere√ßo ret</b> , o que acontece?  Ele usar√° a fun√ß√£o <b>pop</b> para pausar o <b>syscall</b> , em alguns registros que o invasor n√£o conhece e, em seguida, continuaremos subindo essa cadeia de opera√ß√µes na pilha. <br><br>  Ao fazer isso, esperamos que um desses dispositivos execute a fun√ß√£o <b>pop</b> para o <b>n√∫mero</b> <b>syscall no</b> registro <b>RAX</b> correspondente.  Assim, quando chegamos aqui, no topo da pilha, no caminho "bagun√ßando" todos os registros que t√™m um <b>n√∫mero de syscall</b> para pausar, esperamos que ainda tenhamos um registro, que deve estar correto.  Porque se um de nossos gadgets fizer isso e, em seguida, ao fazer o <b>ret</b> , depois de um tempo retornaremos aqui, no topo da pilha, teremos uma pausa.  Mais uma vez, a pausa atua como um sinal para o atacante.  Como se esse endere√ßo assumido para <b>syscall</b> estiver incorreto, o programa falhar√°. <br><br>  Ent√£o, o que nos permite fazer essa fase de ataque?  Ainda n√£o sabemos em quais registros <b>os</b> gadgets <b>pop</b> est√£o localizados, mas sabemos que um deles <b>liberar√°</b> o <b>RAX</b> que queremos controlar.  E provavelmente sabemos o endere√ßo <b>syscall</b> , porque conseguimos pausar o sistema. <br><br>  Depois de fazer isso, podemos verificar esses gadgets um por um e descobrir qual deles coloca o sistema em pausa.  Em outras palavras, cortamos tudo entre a linha de <b>endere√ßo ret</b> e a parte superior da pilha para ir direto para <b>syscall</b> .  Verificaremos se ocorreu uma pausa ou falha no sistema.  Se ocorrer uma falha, identificamos o gadget que o causou, por exemplo, est√° na linha inferior √† direita, √© o <b>pop rdi</b> .  Livre-se dele e tente o pr√≥ximo.  Coloque aqui na linha acima <b>ret address o</b> endere√ßo real para <b>syscall</b> .  Podemos pausar o programa?  Sim, isso significa que aprendemos que esse gadget <b>pop</b> deve liberar <b>RAX</b> .  Isso est√° claro? <br><br>  <b>P√∫blico-alvo:</b> ent√£o, uma maneira de adivinhar o endere√ßo de uma chamada do sistema √© apenas uma transfer√™ncia cega de gadgets? <br><br>  <b>Professor:</b> sim, √©, e h√° maneiras de otimizar esse processo nos materiais de aula quando voc√™ usa a extens√£o de arquivo <b>PLT</b> e coisas semelhantes.  Com o simples ataque que eu descrevi, voc√™ simplesmente colou o endere√ßo aqui e verifique se causou uma pausa ou n√£o.  Como resultado do teste, descobrimos a localiza√ß√£o do <b>syscall</b> .  Vamos descobrir onde <b>est√° localizada</b> a instru√ß√£o que executa o <b>pop RAX</b> .  Tamb√©m precisamos de gadgets que executam <b>pop</b> em alguns outros registros.  Voc√™ pode fazer testes semelhantes para eles.  Portanto, em vez de pausar o <b>n√∫mero syscall</b> , use <b>push</b> para algum outro comando que, por exemplo, use os argumentos <b>RAX</b> e <b>RDI</b> . <br><br>  Assim, voc√™ pode usar o fato de que, para qualquer conjunto espec√≠fico de registros que voc√™ deseja controlar, existe algum tipo de <b>syscall</b> que dar√° a um invasor um sinal para descobrir se voc√™ o interrompeu com √™xito ou n√£o.  Portanto, no final desta fase, voc√™ ter√° o endere√ßo <b>syscall</b> e o endere√ßo de heap do gadget, que permitem exibir registros arbitr√°rios. <br><br>  E agora vamos para o quarto passo, que ser√° chamado de <b>grava√ß√£o</b> / grava√ß√£o.  O quarto passo √© gravar uma chamada do sistema.  Para ligar para <b>escrever</b> , precisamos dos seguintes gadgets: <br><br>  <b>pop rdi, ret;</b> <b><br></b>  <b>pop rsi, ret;</b> <b><br></b>  <b>pop rdx, ret;</b> <b><br></b>  <b>pop rax, ret;</b> <b><br></b>  <b>syscall</b> <br><br><img src="https://habrastorage.org/webt/kj/1h/ds/kj1hdsjhh1509eliv3vjxte7nw4.jpeg"><br><br>  Como esses registros s√£o usados ‚Äã‚Äãpor uma chamada do sistema?  O primeiro √© o soquete, ou, mais geralmente, o descritor de arquivo que voc√™ ir√° transferir para grava√ß√£o.  O segundo √© o buffer, o terceiro √© o tamanho desse buffer, o quarto √© o n√∫mero de chamada do sistema e o quinto √© o pr√≥prio <b>syscall</b> . <br><br>  Portanto, se encontrarmos todos esses dispositivos, podemos controlar os valores incorporados nos argumentos, que, por sua vez, s√£o colocados nesses registros, porque apenas os "empurramos" para a pilha. <br><br>  O que deve ser um soquete?  Aqui temos que adivinhar um pouco.  Voc√™ pode aproveitar o fato de o Linux limitar o n√∫mero de conex√µes abertas simult√¢neas para um arquivo que atinge um valor de 2024. E tamb√©m deve ser o m√≠nimo de todos os dispon√≠veis. <br><br>  Gostaria de saber o que vamos inserir no ponteiro do buffer?  √â isso mesmo, pretendemos usar o fragmento de texto do programa aqui, vamos coloc√°-lo em um ponteiro em algum lugar no c√≥digo do programa.  Isso nos permite ler o arquivo bin√°rio fora da mem√≥ria usando a chamada de cliente correta do soquete.  Em seguida, o invasor pode pegar esse arquivo bin√°rio, analis√°-lo offline e offline, usando o <b>GDB</b> ou outra ferramenta para descobrir onde tudo isso est√° localizado.  O invasor sabe que agora, toda vez que o servidor "travar", o mesmo conjunto aleat√≥rio de coisas ser√° armazenado nele.  Portanto, agora que um invasor pode descobrir os endere√ßos e as compensa√ß√µes do conte√∫do da pilha, ele pode atacar esses dispositivos diretamente.  Ele pode atacar diretamente outras vulnerabilidades, descobrir como abrir o shell e similares.  Em outras palavras, no local em que voc√™ forneceu o bin√°rio com o hacker, voc√™ foi derrotado. <br><br>  √â assim que o ataque do <b>BROP funciona</b> .  Como eu disse, nos materiais da palestra, existem muitas maneiras de otimizar esses processos, mas primeiro voc√™ precisa entender o material principal; caso contr√°rio, a otimiza√ß√£o perde seu significado.  Portanto, voc√™ pode falar comigo sobre otimiza√ß√£o individualmente ou depois da aula. <br><br>  Por enquanto, basta dizer que estes s√£o os princ√≠pios b√°sicos de como voc√™ pode iniciar um ataque <b>BROP</b> .  Voc√™ deve encontrar o gadget de <b>parada</b> , encontrar os gadgets que executam a fun√ß√£o de entradas da pilha <b>pop</b> , descobrir em quais registros eles est√£o localizados, onde o <b>syscall</b> est√° localizado e, em seguida, iniciar a <b>grava√ß√£o</b> , com base nas informa√ß√µes obtidas. <br><br><img src="https://habrastorage.org/webt/xb/-q/iq/xb-qiqqwytbciwpbxiow5i_fovi.jpeg"><br><br>  Ent√£o, rapidamente <b>repasse</b> o t√≥pico, como voc√™ se defende do <b>BROP</b> ?  Portanto, a coisa mais √≥bvia que voc√™ tem √© a re-randomiza√ß√£o.  Como os servidores "ca√≠dos" n√£o reaparecem, n√£o criam vers√µes aleat√≥rias de si mesmos, atuam como um sinal que d√° ao invasor a oportunidade de testar v√°rias hip√≥teses sobre como os programas funcionam. <br><br>  Uma maneira f√°cil de se proteger √© garantir que voc√™ execute <b>exec, em</b> vez de <b>bifurcar,</b> ao reviver seu processo.  Porque quando voc√™ executa o processo, voc√™ cria um espa√ßo completamente novo, localizado aleatoriamente, pelo menos √© o que acontece no Linux.  No Linux, quando voc√™ compila usando <b>PIE</b> , <b>Position Independent Execution</b> , um execut√°vel independente de local, quando voc√™ usa <b>exec,</b> voc√™ obt√©m apenas um novo espa√ßo de endere√ßo aleat√≥rio. <br><br>  A segunda maneira √© simplesmente usar o Windows, porque esse sistema operacional basicamente n√£o tem o equivalente a uma fun√ß√£o <b>fork</b> .  Isso significa que, quando voc√™ reviver um servidor no Windows, ele sempre ter√° um novo espa√ßo de endere√ßo aleat√≥rio. <br><br>  Algu√©m aqui perguntou o que aconteceria se, ap√≥s um mau funcionamento do servidor, ele n√£o desconectasse?  Portanto, se durante uma falha no servidor, de alguma forma, ‚Äúcapturar‚Äù esse erro e manter a conex√£o aberta por um tempo, podemos confundir o invasor para que ele n√£o receba um sinal sobre a falha e pense que encontrou o endere√ßo correto. <br><br>  Nesse caso, seu ataque do <b>BROP</b> se transformar√° em um ataque do <b>DOS</b> .  Porque voc√™ acabou de obter todos os poss√≠veis processos zumbis que existem por a√≠.  Eles s√£o in√∫teis, mas voc√™ n√£o pode deix√°-los ir mais longe, caso contr√°rio voc√™ ter√° que excluir essas informa√ß√µes. <br><br>  Outra coisa em que voc√™ pode pensar √© fazer a verifica√ß√£o de fronteira sobre a qual conversamos anteriormente.  Os materiais da palestra dizem que esse m√©todo √© improdutivo, pois √© 2 vezes mais caro, mas voc√™ ainda pode us√°-lo. <br><br>  √â assim que o <b>BROP</b> funciona.  Quanto aos trabalhos de casa, √© feita uma pergunta mais delicada: e se voc√™ usar um hash do tempo atual?  Ou seja, o per√≠odo de tempo durante o qual voc√™ reinicia o programa.  Isso √© suficiente para impedir esse tipo de ataque?  Observe que o hash n√£o fornece magicamente bits de entropia, se os dados inseridos no hash forem facilmente previs√≠veis.  Se o seu hash contiver bilh√µes de bits, isso n√£o importa.  Mas se voc√™ tiver apenas alguns significados, o atacante apenas os adivinhar√°.  Obviamente, usar um hash de tempo aleat√≥rio √© melhor do que n√£o usar nada para proteger contra um hacker, mas isso n√£o fornecer√° a seguran√ßa com a qual voc√™ deve contar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A vers√£o completa do curso est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Obrigado por ficar conosco.  Voc√™ gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usu√°rios da Habr em um an√°logo exclusivo de servidores b√°sicos que inventamos para voc√™:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as op√ß√µes est√£o dispon√≠veis com RAID1 e RAID10, at√© 24 n√∫cleos e at√© 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente n√≥s temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um pr√©dio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418099/">https://habr.com/ru/post/pt418099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418087/index.html">80% dos check-outs de autoatendimento est√£o em risco</a></li>
<li><a href="../pt418089/index.html">Vis√£o geral da fresadora CNC SolidCraft</a></li>
<li><a href="../pt418091/index.html">Lista de artigos e literatura sobre NAS</a></li>
<li><a href="../pt418093/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 3: Estouros de Buffer: Explora√ß√µes e Prote√ß√£o, Parte 2</a></li>
<li><a href="../pt418095/index.html">Sobre o dispositivo da funcionalidade de teste integrada no Rust (tradu√ß√£o)</a></li>
<li><a href="../pt418101/index.html">Etimologia dos Termos de TI</a></li>
<li><a href="../pt418103/index.html">O chefe da Roscosmos lembrou seu primeiro foguete e compartilhou planos para o futuro</a></li>
<li><a href="../pt418105/index.html">Por que abrir o YouTube no Firefox ou Edge pode demorar 5 vezes mais do que no Google Chrome</a></li>
<li><a href="../pt418107/index.html">Definindo um prefixo para o scanner MINDEO CS2190 para trabalhar com 1C no modo de quebra de teclado</a></li>
<li><a href="../pt418111/index.html">Aprendizagem on-line moderna: desafios e tend√™ncias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>