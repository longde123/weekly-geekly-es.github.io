<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛋️ 🍜 🙆🏽 Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 3 🔞 ↗️ 🔖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418099/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Você pode usar a técnica de adivinhar o "canário" para seus próprios fins, a fim de descobrir a presença de bits "fracos", em termos de seleção.  Ou seja, se você adivinhou corretamente, o servidor irá reiniciar, e isso servirá como um sinal para você de que o valor definido é bastante fácil de adivinhar.  Assim, é possível derrotar os “canários” aleatórios, assumindo que após a reinicialização do servidor, seu valor não será alterado.  Você também pode usar gadgets para implementar uma sequência relacionada de vários ataques. <br><br>  A seguir, veremos uma maneira mais produtiva na qual você pode usar todos esses métodos para impedir a prevenção de execução de dados, espaços de endereços aleatórios e "canários". <br><br>  Vamos voltar nossa atenção para arquiteturas de 64 bits em vez de arquiteturas de 32 bits.  Os primeiros são mais adequados para a randomização, por isso oferecem muito mais "chance" de se defender contra um hacker.  E esses sistemas parecem muito mais interessantes em termos de formação de ataques. <br><br>  Esse tipo de arquitetura de 64 bits também foi considerado do ponto de vista do <b>BROP</b> , programação “cega” de orientação reversa.  Para simplificar, assumimos que a única diferença entre máquinas de 64 bits e 32 bits é que, em uma máquina de 64 bits, os argumentos são passados ​​para os registradores e, para uma máquina de 32 bits, para a pilha. <br><br><img src="https://habrastorage.org/webt/hg/z1/jc/hgz1jcij9zzqbaqc3fiztx1ctze.jpeg"><br><br>  Quando uma função começa a execução, é necessário "procurar" em certos registradores para descobrir onde estão os argumentos. <br><br>  Agora vamos à essência da palestra de hoje - o que é programação cega voltada para o retorno, ou <b>BROP</b> .  A primeira coisa que faremos é encontrar um gadget de parada.  Lembre-se de que quando dizemos "gadget", queremos dizer essencialmente endereços de retorno.  O gadget é identificado com o endereço de retorno, o endereço inicial da sequência de instruções para a qual queremos ir.  Então, o que é um gadget de parada? <br><br>  Essencialmente, é o endereço de retorno para algum lugar do código; no entanto, se você pular para lá, basta pausar o programa, mas não cause a falha do programa.  É por isso que isso é chamado de gadget de parada. <br><br>  Você pode pular para algum lugar do código, que inicia uma chamada do sistema inativa, ou faz uma pausa ou algo assim.  É possível que o programa de alguma forma "fique preso" em um loop infinito se você pular para este local.  Realmente não importa por que a parada ocorre, mas você pode imaginar alguns cenários que levariam a ela. <br><br>  Para que serve um gadget de parada? <br><br>  Assim que o atacante conseguiu derrotar o "canário" usando a técnica interativa de adivinhar bits, ele pode começar a reescrever esse endereço de retorno, o <b>endereço de retiro</b> e começa a "apalpar" o dispositivo de parada.  Observe que a maioria dos endereços aleatórios que você pode colocar na pilha provavelmente causará uma falha no servidor.  Novamente, esta mensagem é para você, atacante, é uma indicação de que o que você encontrou não é um gadget de parada.  Porque quando o servidor trava, o soquete é fechado e você, como invasor, entende que não usou o dispositivo de parada.  Mas se você adivinhou algo e o soquete depois disso permanece aberto por um tempo, você pensa: "Sim, eu encontrei esse dispositivo de parada!"  Portanto, a idéia básica do primeiro passo é encontrar esse gadget de parada. <br><br><img src="https://habrastorage.org/webt/xb/af/zx/xbafzxirvhgep_31ahp8fuzpey4.jpeg"><br><br>  A segunda etapa é que você deseja encontrar dispositivos que excluam entradas da pilha usando o comando <b>pop</b> .  Portanto, você deve usar esta sequência de instruções cuidadosamente projetadas para descobrir quando você pega um desses gadgets de pilha.  Essa sequência consistirá no <b>endereço da sonda</b> , no <b>endereço de parada do endereço de parada</b> e no <b>endereço de falha</b> do sistema do <b>endereço de falha</b> . <br><br>  Portanto, o <b>endereço do probe</b> é o que vamos colocar na pilha.  Este será o endereço do gadget em potencial para limpar a pilha, o <b>endereço de parada</b> - é o que consideramos na primeira etapa, este é o endereço do gadget de parada.  Em seguida <b>, o endereço de falha</b> será simplesmente o endereço do código não executável.  Aqui você pode simplesmente colocar o endereço zero (0 x 0) e se você aplicar a função <b>ret</b> a esse endereço e tentar executar o código lá, isso causará uma falha no programa. <br><br><img src="https://habrastorage.org/webt/38/fa/ba/38fabavrj2kahtqh0_ruuxiigaa.jpeg"><br><br>  Portanto, podemos usar esses tipos de endereços para descobrir onde esses gadgets limpam a <b>pilha</b> . <br><br>  Vou dar um exemplo simples.  Suponha que tenhamos dois exemplos diferentes de <b>sondas</b> , a armadilha de <b>captura</b> e a <b>armadilha de</b> <b>parada</b> .  Suponha que, com a ajuda do <b>probe,</b> vamos "testar" algum endereço, suponha que ele comece com 4 e termine com oito: 0x4 ... 8, e atrás dele esteja o próximo endereço do formulário 0x4 ... C.  Hipoteticamente, podemos supor que um desses dois endereços seja o endereço do gadget de <b>popping de pilha</b> . <br><br>  A <b>armadilha de trap</b> terá zero endereços 0x0 e 0x0 e permitirá que o dispositivo de <b>parada pare de</b> ter endereços arbitrários como 0xS ... 0xS ..., isso não importa.  Esse gadget de parada aponta para o código de suspensão (10), fazendo com que o programa seja pausado. <br><br>  Vamos começar com a operação do <b>probe</b> , que limpa alguns registros e retorna na seguinte sequência: <b>pop rax;</b>  <b>ret</b> .  O que vai acontecer?  Quando o sistema pula para esse endereço, o ponteiro da pilha se move para o meio do nosso gadget.  O que o gadget vai fazer aqui?  Certo, execute <b>a</b> operação <b>pop rax</b> . <br><br><img src="https://habrastorage.org/webt/i2/eu/zr/i2euzrwlujsohfb4dl-szdeasac.jpeg"><br><br>  E depois segue <b>ret</b> , que moverá a função para a linha superior do gadget, ou seja, para <b>parar</b> , e a função será interrompida sem travar o programa inteiro.  Portanto, usando esse gadget, um invasor pode dizer que o endereço do <b>probe</b> pertence a uma dessas funções, o que limpa a pilha, porque a conexão do cliente do servidor está aberta. <br><br>  Agora, vamos supor que o segundo endereço do <b>probe</b> aponte para algo como <b>xor rax, rax, ret</b> para algum registro. <br><br><img src="https://habrastorage.org/webt/kw/5t/r3/kw5tr3vdtrqedphe0onl6ec-wa0.jpeg"><br><br>  Então, o que acontece se tentarmos pular para esse gadget?  Observe que ele não limpa nada na pilha, apenas altera o conteúdo dos registros.  Então, vamos retornar ao endereço 0x0 localizado acima.  E isso fará com que o sistema falhe.  A conexão do cliente com o servidor será interrompida e o hacker entenderá que esse não é um gadget para limpar o <b>popping da pilha</b> . <br><br>  Dessa forma, você pode usar uma série mais bizarra de armadilhas e parar dispositivos, por exemplo, pode limpar dois itens na pilha.  Para fazer isso, basta colocar outra instrução de <b>trap</b> aqui, e se esse gadget não apagar dois elementos, você se encontrará em um desses trap e o código interromperá a execução.  Os materiais da palestra descrevem uma coisa chamada <b>gadget BROP,</b> que é útil se você não gosta de voltar à programação.  Mas hoje também mostrarei como você pode usar esses gadgets <b>pop</b> simples para iniciar um ataque semelhante.  Depois que você entender isso, será muito mais fácil lidar com um <b>gadget BROP</b> . <br><br>  Mas todos vocês entendem como podemos usar a função de <b>sonda</b> para esses gadgets?  Suponha que você encontre o local dos trechos de código que permitem limpar a pilha com a função <b>pop</b> , remova um elemento dela, mas você realmente não sabe em qual registro essa função <b>pop</b> funcionará.  Você apenas sabe que ela já está pronta para execução.  Mas você precisa saber em qual registro esses gadgets <b>pop</b> funcionarão, porque em uma arquitetura de 64 bits, os registros controlam onde estão localizados os argumentos da função que você deseja chamar. <br><br>  Assim, nosso objetivo é poder criar dispositivos que nos permitam excluir os valores que colocamos em determinados registros de pilha e, finalmente, iniciar uma chamada de <b>sistema de chamada de sistema</b> , o que nos permite fazer algo ruim. <br>  Portanto, agora precisamos determinar quais registros são usados ​​pelos gadgets <b>pop</b> . <br><br><img src="https://habrastorage.org/webt/xp/w-/hw/xpw-hw9rdgd2argq0yx6xgi3ece.jpeg"><br><br>  Para fazer isso, podemos tirar proveito da chamada do sistema de pausa.  Se a chamada do sistema for pausada, a execução do programa será suspensa e ele não aceitará nenhum argumento.  E isso significa que o sistema ignora tudo nos registros. <br><br>  De fato, para encontrar a instrução de pausa que estamos executando, você pode vincular todos esses gadgets <b>pop</b> para que possamos colocá-los todos na pilha e, entre cada um deles, <b>inserimos um número syscall</b> para pausar.  Então veremos se podemos "suspender" o programa dessa maneira.  Deixe-me dar um exemplo concreto. <br><br>  Aqui, colocamos um gadget na barra de endereço de retorno que limpa os registros da <b>RDI</b> e aplica a função <b>ret</b> a eles.  Acima dele, colocaremos um <b>número syscall</b> para pausar. <br><br>  Suponha que tenhamos mais um gadget localizado acima que implemente a função <b>pop</b> em outro registro, digamos <b>RSI</b> e depois <b>ret</b> .  E então colocamos o <b>número syscall</b> novamente para pausar.  E fazemos isso para todos os gadgets que encontramos e acabamos no topo da pilha com o endereço putativo para <b>syscall</b> . <br><br><img src="https://habrastorage.org/webt/qd/yx/3v/qdyx3vymmlc13o-sceyeimho_ro.jpeg"><br><br>  Lembre-se novamente de como você usa essas chamadas do sistema.  Você deve colocar o <b>número</b> <b>syscall no</b> registro <b>RAX</b> e chamar a função <b>libc syscall</b> , que está prestes a fazer a chamada do sistema solicitada. <br><br>  Então, o que acontece quando executamos esse código?  Vamos chegar aqui, na linha de <b>endereço ret</b> , saltaremos para o endereço desse gadget; observe que o invasor sabe que esse gadget, localizado à direita, remove algo da pilha, mas ainda não sabe em qual registro está localizado. <br><br>  Então, se pularmos para o <b>endereço ret</b> , o que acontece?  Ele usará a função <b>pop</b> para pausar o <b>syscall</b> , em alguns registros que o invasor não conhece e, em seguida, continuaremos subindo essa cadeia de operações na pilha. <br><br>  Ao fazer isso, esperamos que um desses dispositivos execute a função <b>pop</b> para o <b>número</b> <b>syscall no</b> registro <b>RAX</b> correspondente.  Assim, quando chegamos aqui, no topo da pilha, no caminho "bagunçando" todos os registros que têm um <b>número de syscall</b> para pausar, esperamos que ainda tenhamos um registro, que deve estar correto.  Porque se um de nossos gadgets fizer isso e, em seguida, ao fazer o <b>ret</b> , depois de um tempo retornaremos aqui, no topo da pilha, teremos uma pausa.  Mais uma vez, a pausa atua como um sinal para o atacante.  Como se esse endereço assumido para <b>syscall</b> estiver incorreto, o programa falhará. <br><br>  Então, o que nos permite fazer essa fase de ataque?  Ainda não sabemos em quais registros <b>os</b> gadgets <b>pop</b> estão localizados, mas sabemos que um deles <b>liberará</b> o <b>RAX</b> que queremos controlar.  E provavelmente sabemos o endereço <b>syscall</b> , porque conseguimos pausar o sistema. <br><br>  Depois de fazer isso, podemos verificar esses gadgets um por um e descobrir qual deles coloca o sistema em pausa.  Em outras palavras, cortamos tudo entre a linha de <b>endereço ret</b> e a parte superior da pilha para ir direto para <b>syscall</b> .  Verificaremos se ocorreu uma pausa ou falha no sistema.  Se ocorrer uma falha, identificamos o gadget que o causou, por exemplo, está na linha inferior à direita, é o <b>pop rdi</b> .  Livre-se dele e tente o próximo.  Coloque aqui na linha acima <b>ret address o</b> endereço real para <b>syscall</b> .  Podemos pausar o programa?  Sim, isso significa que aprendemos que esse gadget <b>pop</b> deve liberar <b>RAX</b> .  Isso está claro? <br><br>  <b>Público-alvo:</b> então, uma maneira de adivinhar o endereço de uma chamada do sistema é apenas uma transferência cega de gadgets? <br><br>  <b>Professor:</b> sim, é, e há maneiras de otimizar esse processo nos materiais de aula quando você usa a extensão de arquivo <b>PLT</b> e coisas semelhantes.  Com o simples ataque que eu descrevi, você simplesmente colou o endereço aqui e verifique se causou uma pausa ou não.  Como resultado do teste, descobrimos a localização do <b>syscall</b> .  Vamos descobrir onde <b>está localizada</b> a instrução que executa o <b>pop RAX</b> .  Também precisamos de gadgets que executam <b>pop</b> em alguns outros registros.  Você pode fazer testes semelhantes para eles.  Portanto, em vez de pausar o <b>número syscall</b> , use <b>push</b> para algum outro comando que, por exemplo, use os argumentos <b>RAX</b> e <b>RDI</b> . <br><br>  Assim, você pode usar o fato de que, para qualquer conjunto específico de registros que você deseja controlar, existe algum tipo de <b>syscall</b> que dará a um invasor um sinal para descobrir se você o interrompeu com êxito ou não.  Portanto, no final desta fase, você terá o endereço <b>syscall</b> e o endereço de heap do gadget, que permitem exibir registros arbitrários. <br><br>  E agora vamos para o quarto passo, que será chamado de <b>gravação</b> / gravação.  O quarto passo é gravar uma chamada do sistema.  Para ligar para <b>escrever</b> , precisamos dos seguintes gadgets: <br><br>  <b>pop rdi, ret;</b> <b><br></b>  <b>pop rsi, ret;</b> <b><br></b>  <b>pop rdx, ret;</b> <b><br></b>  <b>pop rax, ret;</b> <b><br></b>  <b>syscall</b> <br><br><img src="https://habrastorage.org/webt/kj/1h/ds/kj1hdsjhh1509eliv3vjxte7nw4.jpeg"><br><br>  Como esses registros são usados ​​por uma chamada do sistema?  O primeiro é o soquete, ou, mais geralmente, o descritor de arquivo que você irá transferir para gravação.  O segundo é o buffer, o terceiro é o tamanho desse buffer, o quarto é o número de chamada do sistema e o quinto é o próprio <b>syscall</b> . <br><br>  Portanto, se encontrarmos todos esses dispositivos, podemos controlar os valores incorporados nos argumentos, que, por sua vez, são colocados nesses registros, porque apenas os "empurramos" para a pilha. <br><br>  O que deve ser um soquete?  Aqui temos que adivinhar um pouco.  Você pode aproveitar o fato de o Linux limitar o número de conexões abertas simultâneas para um arquivo que atinge um valor de 2024. E também deve ser o mínimo de todos os disponíveis. <br><br>  Gostaria de saber o que vamos inserir no ponteiro do buffer?  É isso mesmo, pretendemos usar o fragmento de texto do programa aqui, vamos colocá-lo em um ponteiro em algum lugar no código do programa.  Isso nos permite ler o arquivo binário fora da memória usando a chamada de cliente correta do soquete.  Em seguida, o invasor pode pegar esse arquivo binário, analisá-lo offline e offline, usando o <b>GDB</b> ou outra ferramenta para descobrir onde tudo isso está localizado.  O invasor sabe que agora, toda vez que o servidor "travar", o mesmo conjunto aleatório de coisas será armazenado nele.  Portanto, agora que um invasor pode descobrir os endereços e as compensações do conteúdo da pilha, ele pode atacar esses dispositivos diretamente.  Ele pode atacar diretamente outras vulnerabilidades, descobrir como abrir o shell e similares.  Em outras palavras, no local em que você forneceu o binário com o hacker, você foi derrotado. <br><br>  É assim que o ataque do <b>BROP funciona</b> .  Como eu disse, nos materiais da palestra, existem muitas maneiras de otimizar esses processos, mas primeiro você precisa entender o material principal; caso contrário, a otimização perde seu significado.  Portanto, você pode falar comigo sobre otimização individualmente ou depois da aula. <br><br>  Por enquanto, basta dizer que estes são os princípios básicos de como você pode iniciar um ataque <b>BROP</b> .  Você deve encontrar o gadget de <b>parada</b> , encontrar os gadgets que executam a função de entradas da pilha <b>pop</b> , descobrir em quais registros eles estão localizados, onde o <b>syscall</b> está localizado e, em seguida, iniciar a <b>gravação</b> , com base nas informações obtidas. <br><br><img src="https://habrastorage.org/webt/xb/-q/iq/xb-qiqqwytbciwpbxiow5i_fovi.jpeg"><br><br>  Então, rapidamente <b>repasse</b> o tópico, como você se defende do <b>BROP</b> ?  Portanto, a coisa mais óbvia que você tem é a re-randomização.  Como os servidores "caídos" não reaparecem, não criam versões aleatórias de si mesmos, atuam como um sinal que dá ao invasor a oportunidade de testar várias hipóteses sobre como os programas funcionam. <br><br>  Uma maneira fácil de se proteger é garantir que você execute <b>exec, em</b> vez de <b>bifurcar,</b> ao reviver seu processo.  Porque quando você executa o processo, você cria um espaço completamente novo, localizado aleatoriamente, pelo menos é o que acontece no Linux.  No Linux, quando você compila usando <b>PIE</b> , <b>Position Independent Execution</b> , um executável independente de local, quando você usa <b>exec,</b> você obtém apenas um novo espaço de endereço aleatório. <br><br>  A segunda maneira é simplesmente usar o Windows, porque esse sistema operacional basicamente não tem o equivalente a uma função <b>fork</b> .  Isso significa que, quando você reviver um servidor no Windows, ele sempre terá um novo espaço de endereço aleatório. <br><br>  Alguém aqui perguntou o que aconteceria se, após um mau funcionamento do servidor, ele não desconectasse?  Portanto, se durante uma falha no servidor, de alguma forma, “capturar” esse erro e manter a conexão aberta por um tempo, podemos confundir o invasor para que ele não receba um sinal sobre a falha e pense que encontrou o endereço correto. <br><br>  Nesse caso, seu ataque do <b>BROP</b> se transformará em um ataque do <b>DOS</b> .  Porque você acabou de obter todos os possíveis processos zumbis que existem por aí.  Eles são inúteis, mas você não pode deixá-los ir mais longe, caso contrário você terá que excluir essas informações. <br><br>  Outra coisa em que você pode pensar é fazer a verificação de fronteira sobre a qual conversamos anteriormente.  Os materiais da palestra dizem que esse método é improdutivo, pois é 2 vezes mais caro, mas você ainda pode usá-lo. <br><br>  É assim que o <b>BROP</b> funciona.  Quanto aos trabalhos de casa, é feita uma pergunta mais delicada: e se você usar um hash do tempo atual?  Ou seja, o período de tempo durante o qual você reinicia o programa.  Isso é suficiente para impedir esse tipo de ataque?  Observe que o hash não fornece magicamente bits de entropia, se os dados inseridos no hash forem facilmente previsíveis.  Se o seu hash contiver bilhões de bits, isso não importa.  Mas se você tiver apenas alguns significados, o atacante apenas os adivinhará.  Obviamente, usar um hash de tempo aleatório é melhor do que não usar nada para proteger contra um hacker, mas isso não fornecerá a segurança com a qual você deve contar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A versão completa do curso está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418099/">https://habr.com/ru/post/pt418099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418087/index.html">80% dos check-outs de autoatendimento estão em risco</a></li>
<li><a href="../pt418089/index.html">Visão geral da fresadora CNC SolidCraft</a></li>
<li><a href="../pt418091/index.html">Lista de artigos e literatura sobre NAS</a></li>
<li><a href="../pt418093/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 2</a></li>
<li><a href="../pt418095/index.html">Sobre o dispositivo da funcionalidade de teste integrada no Rust (tradução)</a></li>
<li><a href="../pt418101/index.html">Etimologia dos Termos de TI</a></li>
<li><a href="../pt418103/index.html">O chefe da Roscosmos lembrou seu primeiro foguete e compartilhou planos para o futuro</a></li>
<li><a href="../pt418105/index.html">Por que abrir o YouTube no Firefox ou Edge pode demorar 5 vezes mais do que no Google Chrome</a></li>
<li><a href="../pt418107/index.html">Definindo um prefixo para o scanner MINDEO CS2190 para trabalhar com 1C no modo de quebra de teclado</a></li>
<li><a href="../pt418111/index.html">Aprendizagem on-line moderna: desafios e tendências</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>