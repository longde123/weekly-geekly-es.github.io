<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö†Ô∏è üßñüèª üëãüèª WAL in PostgreSQL: 4. Protokoll einrichten ü§º üë®‚Äçüè´ üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns also mit dem Ger√§t des Puffercaches vertraut gemacht und anhand seines Beispiels festgestellt, dass f√ºr die Wiederherstellung ein Vorauf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL in PostgreSQL: 4. Protokoll einrichten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/">  Wir haben uns also mit dem Ger√§t des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Puffercaches</a> vertraut gemacht und anhand seines Beispiels festgestellt, dass f√ºr die Wiederherstellung ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Voraufzeichnungsprotokoll</a> erforderlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> , wenn der Inhalt des RAM im Falle eines Fehlers verschwindet.  Die Gr√∂√üe der erforderlichen Protokolldateien und die Wiederherstellungszeit sind aufgrund eines regelm√§√üig ausgef√ºhrten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√ºfpunkts begrenzt</a> . <br><br>  In fr√ºheren Artikeln haben wir bereits eine ziemlich gro√üe Anzahl wichtiger Einstellungen in Bezug auf das Journal auf die eine oder andere Weise betrachtet.  In diesem Artikel (dem letzten in dieser Reihe) werden die noch nicht diskutierten Optimierungsprobleme behandelt: Protokollierungsstufen und deren Zweck sowie die Zuverl√§ssigkeit und Leistung der Protokollierung. <br><br><h1>  Protokollebenen </h1><br>  Der Hauptzweck des Voraufzeichnungsprotokolls besteht darin, nach einem Fehler eine Wiederherstellung bereitzustellen.  Wenn Sie jedoch noch ein Tagebuch f√ºhren m√ºssen, kann es f√ºr andere Aufgaben angepasst werden, indem eine bestimmte Menge zus√§tzlicher Informationen hinzugef√ºgt wird.  Es gibt verschiedene Protokollierungsstufen.  Sie werden durch den Parameter <em>wal_level festgelegt</em> und so organisiert, dass das Protokoll jeder n√§chsten Ebene alles enth√§lt, was in das Protokoll der vorherigen Ebene f√§llt, sowie etwas anderes Neues. <br><a name="habracut"></a><br><h2>  Minimal </h2><br>  Die minimal m√∂gliche Stufe wird durch den Wert <em>wal_level</em> = minimal festgelegt und garantiert nur die Wiederherstellung nach einem Fehler.  Aus Platzgr√ºnden werden Vorg√§nge im Zusammenhang mit der Massendatenverarbeitung (z. B. CREATE TABLE AS SELECT oder CREATE INDEX) nicht protokolliert.  Stattdessen werden die erforderlichen Daten sofort auf die Festplatte geschrieben, und ein neues Objekt wird dem Systemverzeichnis hinzugef√ºgt und wird sichtbar, wenn die Transaktion festgeschrieben wird.  Wenn w√§hrend des Vorgangs ein Fehler auftritt, bleiben die bereits aufgezeichneten Daten unsichtbar und verletzen die Konsistenz nicht.  Wenn der Fehler nach Abschluss des Vorgangs auftritt, ist alles Notwendige bereits auf der Festplatte gespeichert und muss nicht protokolliert werden. <br><br>  Mal sehen.  <em>Stellen</em> Sie zun√§chst die gew√ºnschte Stufe ein (dazu m√ºssen Sie auch einen anderen Parameter √§ndern - <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Beachten Sie, dass zum √Ñndern der Ebene ein Neustart des Servers erforderlich ist. <br><br>  Merken Sie sich die aktuelle Position im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Erstellen wir nun die Tabelle (CREATE TABLE AS SELECT) und schreiben die Position erneut in das Protokoll.  Die von der SELECT-Anweisung ausgew√§hlte Datenmenge spielt in diesem Fall keine Rolle, daher beschr√§nken wir uns auf eine Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  Schauen wir uns mit dem bekannten Dienstprogramm pg_waldump die Protokolleintr√§ge an. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Einige Details k√∂nnen nat√ºrlich von Start zu Start unterschiedlich sein, aber in diesem Fall ist dies geschehen.  Der Heap2-Manager-Eintrag bezieht sich auf die Bereinigung. Hier handelt es sich um eine On-Page-Bereinigung einer der Tabellen im Systemkatalog (Systemobjekte k√∂nnen mit blo√üem Auge leicht durch die ‚Äûkurze‚Äú Zahl in rel unterschieden werden): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Dann gibt es einen Datensatz zum Abrufen der n√§chsten OID f√ºr die Tabelle, die wir erstellen werden: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Nun die eigentliche Erstellung der Tabelle: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  Das Einf√ºgen von Daten in eine Tabelle wird jedoch nicht protokolliert.  Dann gibt es zahlreiche Eintr√§ge zum Einf√ºgen von Zeilen in verschiedene Tabellen und Indizes - dieses PostgreSQL registriert die erstellte Tabelle im Systemverzeichnis (ich gebe es in Kurzform an): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Und schlie√ülich die Transaktionsfixierung: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  Replik </h2><br>  Wenn wir das System aus der Sicherung wiederherstellen, beginnen wir mit einem bestimmten Status des Dateisystems und bringen die Daten schrittweise zum Wiederherstellungspunkt, wobei die archivierten Journaleintr√§ge wiedergegeben werden.  Die Anzahl solcher Datens√§tze kann sehr gro√ü sein (z. B. mehrere Tage), dh der Wiederherstellungszeitraum deckt nicht einen Kontrollpunkt ab, sondern viele.  Daher ist klar, dass die Mindeststufe des Protokolls nicht ausreicht. Wenn ein Vorgang nicht protokolliert wird, wissen wir einfach nicht, dass er wiederholt werden muss.  Um aus einer Sicherung wiederherzustellen, m√ºssen <em>alle</em> Vorg√§nge protokolliert werden. <br><br>  Gleiches gilt f√ºr die Replikation. Alles, was nicht protokolliert wird, wird nicht auf das Replikat √ºbertragen und nicht reproduziert.  Wenn wir jedoch Anforderungen auf einem Replikat ausf√ºhren m√∂chten, ist dies immer noch kompliziert. <br><br>  Zun√§chst ben√∂tigen wir Informationen zu exklusiven Sperren, die auf dem Prim√§rserver auftreten, da diese m√∂glicherweise mit Anforderungen auf dem Replikat in Konflikt stehen.  Solche Sperren werden protokolliert und auf das Replikat angewendet (im Auftrag des Startvorgangs). <br><br>  Zweitens m√ºssen Sie in der Lage sein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenschnappsch√ºsse</a> zu erstellen, und daf√ºr werden, wie wir uns erinnern, Informationen √ºber laufende Transaktionen ben√∂tigt.  Bei einem Replikat handelt es sich nicht nur um lokale Transaktionen, sondern auch um Transaktionen auf dem Hauptserver.  Die einzige M√∂glichkeit, diese Informationen zu √ºbertragen, besteht darin, sie regelm√§√üig in das Protokoll zu schreiben (dies geschieht alle 15 Sekunden). <br><br>  Die Protokollebene, die sowohl die F√§higkeit zur Wiederherstellung nach einer Sicherung als auch die M√∂glichkeit der physischen Replikation garantiert, wird durch den Wert wal_level = replica festgelegt.  (Vor Version 9.6 gab es zwei separate Ebenen Archiv und hot_standby, aber dann wurden sie zu einer gemeinsamen Ebene kombiniert.) <br><br>  Ab PostgreSQL 10 ist diese Stufe standardm√§√üig festgelegt (und davor war sie minimal).  Setzen Sie daher die Parameter einfach auf die Standardwerte zur√ºck: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Wir l√∂schen die Tabelle und wiederholen genau die gleiche Abfolge von Aktionen wie beim letzten Mal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  √úberpr√ºfen Sie nun die Journaleintr√§ge. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Bereinigen, OID abrufen, Tabelle erstellen und im Systemverzeichnis registrieren - im Moment ist alles so, wie es war: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, ‚Ä¶ rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Aber etwas Neues.  Die Aufzeichnung einer exklusiven Sperre in Bezug auf den Standby-Manager - in diesem Fall blockiert sie die Transaktionsnummer (warum wird sie ben√∂tigt, werden wir in der n√§chsten Artikelserie ausf√ºhrlich besprechen): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  Und dies ist ein Datensatz zum Einf√ºgen von Zeilen in unsere Tabelle (vergleichen Sie die Dateinummer rel mit der oben im CREATE-Datensatz angegebenen): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Commit-Datensatz: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  Ein weiterer Datensatz, der regelm√§√üig auftritt und nicht an die abgeschlossene Transaktion gebunden ist, bezieht sich auf den Standby-Manager und berichtet √ºber die derzeit laufenden Transaktionen: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  Logisch </h2><br>  Schlie√ülich wird die letzte Ebene durch den Wert des Parameters <em>wal_level</em> = logisch festgelegt und bietet die M√∂glichkeit der logischen Dekodierung und logischen Replikation.  Es muss auf dem Publishing-Server aktiviert sein. <br><br>  Aus Sicht von Journaleintr√§gen unterscheidet sich diese Ebene praktisch nicht von Replikatdatens√§tzen - Datens√§tze, die sich auf Replikationsurspr√ºnge beziehen, und beliebige logische Eintr√§ge, die dem Anwendungsprotokoll hinzugef√ºgt werden k√∂nnen, werden hinzugef√ºgt.  Grunds√§tzlich h√§ngt die logische Dekodierung von Informationen √ºber laufende Transaktionen ab, da Sie eine Momentaufnahme der Daten erstellen m√ºssen, um √Ñnderungen im Systemkatalog zu verfolgen. <br><br>  Jetzt werden wir nicht n√§her auf die Funktionsweise von Sicherung und Replikation eingehen - dies ist ein gro√ües Thema f√ºr eine separate Artikelserie. <br><br><h1>  Zuverl√§ssigkeit aufzeichnen </h1><br>  Es ist klar, dass der Journalmechanismus zuverl√§ssig sein und Garantien f√ºr die M√∂glichkeit der Wiederherstellung in allen Situationen bieten muss (nat√ºrlich nicht im Zusammenhang mit einer Besch√§digung des Datentr√§gers).  Die Zuverl√§ssigkeit wird von vielen Faktoren beeinflusst, von denen wir Caching, Datenkorruption und Atomizit√§t von Aufzeichnungen ber√ºcksichtigen werden. <br><br><h2>  Caching </h2><br>  Auf dem Datenpfad zum nichtfl√ºchtigen Speicher (z. B. einem Festplattenlaufwerk) befinden sich zahlreiche Caches. <br><br>  Wenn ein Programm (ein beliebiges, aber in unserem Fall PostgreSQL) das Betriebssystem auffordert, etwas auf die Festplatte zu schreiben, √ºbertr√§gt das Betriebssystem die Daten in seinen Cache im RAM.  Die tats√§chliche Aufzeichnung erfolgt asynchron, abh√§ngig von den Einstellungen des E / A-Schedulers des Betriebssystems. <br><br>  Wenn das Betriebssystem beschlie√üt, Daten zu schreiben, fallen diese in den Cache des Laufwerks (Festplatte).  Die Antriebselektronik kann auch die Aufzeichnung verz√∂gern, z. B. das Sammeln von Daten in Gruppen, deren gleichzeitige Aufzeichnung rentabler ist.  Wenn ein RAID-Controller verwendet wird, wird zwischen dem Betriebssystem und dem Laufwerk eine andere Caching-Ebene angezeigt. <br><br>  Wenn Sie also keine besonderen Ma√ünahmen ergreifen, ist v√∂llig unklar, wann die Daten wirklich sicher gespeichert werden.  Dies ist normalerweise nicht wichtig, aber es gibt kritische Stellen, an denen PostgreSQL sicherstellen muss, dass die Daten sicher geschrieben sind.  Dies ist zun√§chst ein Journal (wenn der Journaleintrag die Festplatte nicht erreicht hat, verschwindet er zusammen mit dem Rest des RAM-Inhalts) und ein Pr√ºfpunkt (es muss sichergestellt sein, dass die schmutzigen Seiten tats√§chlich auf die Festplatte geschrieben wurden).  Es gibt jedoch auch andere Situationen, z. B. die Ausf√ºhrung nicht journalisierter Vorg√§nge auf der Mindeststufe usw. <br><br>  Das Betriebssystem bietet Tools, die das sofortige Schreiben von Daten in den nichtfl√ºchtigen Speicher gew√§hrleisten m√ºssen.  Es gibt mehrere Optionen, aber es gibt zwei Hauptoptionen: Entweder wird nach der Aufzeichnung ein Synchronisierungsbefehl gegeben (fsync, fdatasync), oder beim √ñffnen (oder Schreiben) einer Datei wird ein spezielles Flag f√ºr die Synchronisierung oder sogar die direkte Aufzeichnung angezeigt, wobei der Betriebssystem-Cache umgangen wird. <br><br>  F√ºr das Protokoll k√∂nnen Sie mit dem Dienstprogramm pg_test_fsync die Methode ausw√§hlen, die f√ºr ein bestimmtes Betriebssystem und ein bestimmtes Dateisystem am besten geeignet ist. Sie wird im Konfigurationsparameter <em>wal_sync_method</em> installiert.  Normale Dateien werden immer mit fsync synchronisiert. <br><br>  Der subtile Punkt ist, dass bei der Auswahl einer Methode die Eigenschaften der Ausr√ºstung ber√ºcksichtigt werden m√ºssen.  Wenn Sie beispielsweise einen Controller verwenden, der von einer Backup-Batterie unterst√ºtzt wird, gibt es keinen Grund, den Cache nicht zu verwenden, da die Batterie bei einem Stromausfall Daten speichert. <br><br><blockquote>  Die Dokumentation enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Details</a> zu diesem Thema. <br></blockquote><br>  In jedem Fall ist die Synchronisation teuer und findet nicht √∂fter als unbedingt erforderlich statt (wir werden etwas weniger auf dieses Problem zur√ºckkommen, wenn wir √ºber die Leistung sprechen). <br><br>  Im Allgemeinen kann die Synchronisation <em>deaktiviert</em> werden (der Parameter <em>fsync</em> ist daf√ºr verantwortlich). In diesem Fall sollten Sie jedoch die Speicherzuverl√§ssigkeit vergessen.  Durch Deaktivieren von <em>fsync</em> stimmen Sie zu, dass Daten jederzeit unwiederbringlich verloren gehen k√∂nnen.  Wahrscheinlich ist die einzig sinnvolle Option, diese Option zu verwenden, die vor√ºbergehende Steigerung der Produktivit√§t, wenn Daten problemlos aus einer anderen Quelle wiederhergestellt werden k√∂nnen (z. B. w√§hrend der ersten Migration). <br><br><h2>  Datenkorruption </h2><br>  Das Ger√§t ist fehlerhaft und die Daten k√∂nnen auf dem Medium besch√§digt werden, wenn Daten √ºber Schnittstellenkabel usw. √ºbertragen werden. Einige dieser Fehler werden auf Hardwareebene verarbeitet, andere jedoch nicht. <br><br>  Um das Problem rechtzeitig zu erkennen, werden die Journaleintr√§ge immer mit Pr√ºfsummen versehen. <br><br>  Datenseiten k√∂nnen auch mit Pr√ºfsummen gesch√ºtzt werden.  Derzeit ist dies nur m√∂glich, wenn der Cluster initialisiert wurde. In PostgreSQL 12 k√∂nnen sie jedoch mit dem Dienstprogramm pg_checksums ein- und ausgeschaltet werden (allerdings noch nicht im laufenden Betrieb, sondern nur, wenn der Server gestoppt ist). <br><br>  In einer Produktionsumgebung m√ºssen Pr√ºfsummen trotz des Aufwands f√ºr ihre Berechnung und Kontrolle enthalten sein.  Dies verringert die Wahrscheinlichkeit, dass ein Fehler nicht rechtzeitig erkannt wird. <br><br><blockquote>  Reduziert, eliminiert aber nicht. <br>  Erstens werden Pr√ºfsummen nur beim Zugriff auf die Seite √ºberpr√ºft. Daher k√∂nnen Sch√§den unbemerkt bleiben, bis sie in alle Sicherungen eingehen.  Aus diesem Grund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sucht pg_probackup</a> w√§hrend der Sicherung nach Pr√ºfsummen aller Seiten des Clusters. <br>  Zweitens wird eine mit Nullen gef√ºllte Seite als korrekt angesehen. Wenn das Dateisystem die Datei versehentlich "aufhebt", bleibt dies m√∂glicherweise unbemerkt. <br>  Drittens sch√ºtzen Pr√ºfsummen nur die Hauptschicht der Datendateien.  Die verbleibenden Ebenen und anderen Dateien (z. B. XACT-Transaktionsstatus) sind durch nichts gesch√ºtzt. <br>  Leider. <br></blockquote><br>  Mal sehen, wie es funktioniert.  Stellen Sie zun√§chst sicher, dass Pr√ºfsummen aktiviert sind (beachten Sie, dass dies bei der Installation eines Pakets auf Debian-√§hnlichen Systemen nicht der Fall ist): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  Der Parameter <em>data_checksums</em> ist schreibgesch√ºtzt. <br><br>  Hier ist die Datei, in der sich unsere Tabelle befindet: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Stoppen Sie den Server und √§ndern Sie einige Bytes auf der Nullseite. L√∂schen Sie beispielsweise den letzten Protokolleintrag aus dem LSN-Header. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  Grunds√§tzlich konnte der Server nicht gestoppt werden.  Es reicht aus, dass die Seite auf die Festplatte geschrieben und aus dem Cache gezwungen wurde (andernfalls arbeitet der Server mit der Seite aus dem Cache).  Ein solches Szenario ist jedoch schwieriger zu reproduzieren. <br><br>  Jetzt starten wir den Server und versuchen die Tabelle zu lesen. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  Was aber, wenn die Daten nicht aus dem Backup wiederhergestellt werden k√∂nnen?  Mit <em>dem</em> Parameter <em>ignore_checksum_failure</em> k√∂nnen <em>Sie</em> versuchen, die Tabelle zu lesen, nat√ºrlich mit dem Risiko, dass Daten verzerrt werden. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  In diesem Fall l√§uft nat√ºrlich alles gut, da wir nur den Seitentitel und nicht die Daten selbst durcheinander gebracht haben. <br><br>  Und noch etwas.  Wenn die Pr√ºfsummen aktiviert sind, werden Eingabeaufforderungsbits in das Protokoll geschrieben (wir haben sie zuvor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersucht</a> ), da eine √Ñnderung eines beliebigen, auch nicht wesentlichen Bits auch zu einer √Ñnderung der Pr√ºfsumme f√ºhrt.  Wenn Pr√ºfsummen <em>deaktiviert</em> sind, ist der Parameter <em>wal_log_hints</em> f√ºr das Schreiben von Hinweisbits in das <em>Protokoll verantwortlich</em> . <br><br>  √Ñnderungen an Tooltip-Bits werden immer als <em>Ganzseitenbild</em> (FPI, Ganzseitenbild) protokolliert, wodurch die Gr√∂√üe des Protokolls in der angegebenen Reihenfolge erh√∂ht wird.  In diesem Fall ist es sinnvoll, die Komprimierung von Vollbildern mit dem Parameter <em>wal_compression zu aktivieren</em> (dieser Parameter wurde in Version 9.5 <em>angezeigt</em> ).  Nachfolgend sehen wir uns bestimmte Zahlen an. <br><br><h2>  Atomarit√§tsrekord </h2><br>  Und schlie√ülich gibt es das Problem der Atomizit√§t der Aufzeichnung.  Eine Datenbankseite ben√∂tigt mindestens 8 KB (es k√∂nnen 16 oder 32 KB sein), und auf einer niedrigen Ebene erfolgt die Aufzeichnung in Bl√∂cken, die normalerweise kleiner sind (normalerweise 512 Byte oder 4 KB).  Daher kann im Falle eines Stromausfalls die Datenseite teilweise aufgezeichnet werden.  Es ist klar, dass es w√§hrend der Wiederherstellung keinen Sinn macht, normale Journaleintr√§ge auf eine solche Seite anzuwenden. <br><br>  Zum Schutz k√∂nnen Sie mit PostgreSQL das <em>vollst√§ndige Bild der Seite</em> in das Protokoll schreiben, wenn es nach dem Start des Pr√ºfpunkts zum ersten Mal ge√§ndert wird (dasselbe Bild wird aufgezeichnet, wenn sich die Tooltip-Bits √§ndern).  Der Parameter <em>full_page_writes steuert dies</em> und ist standardm√§√üig aktiviert. <br><br>  Wenn ein Seitenabbild w√§hrend der Wiederherstellung in einem Protokoll auftritt, wird es bedingungslos (ohne LSN-Pr√ºfung) auf die Festplatte geschrieben: Es besteht mehr Vertrauen, da es wie jeder Protokolldatensatz durch eine Pr√ºfsumme gesch√ºtzt ist.  Und bereits regelm√§√üige Journaleintr√§ge werden auf dieses garantiert korrekte Bild angewendet. <br><br>  Obwohl PostgreSQL nicht zugewiesenen Speicherplatz aus dem Ganzseitenbild ausschlie√üt (wir haben uns zuvor die Blockstruktur angesehen), nimmt das Volumen der generierten Journaleintr√§ge erheblich zu.  Wie bereits erw√§hnt, kann die Situation durch Komprimieren der vollst√§ndigen Bilder (Parameter <em>wal_compression</em> ) verbessert werden. <br><br>  Um die √Ñnderung der Gr√∂√üe des Protokolls irgendwie zu sp√ºren, f√ºhren wir ein einfaches Experiment mit dem Dienstprogramm pgbench durch.  Initialisieren wir: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  Die <em>Option full_page_writes ist</em> aktiviert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  F√ºhren Sie den Haltepunkt aus und f√ºhren Sie den Test sofort 30 Sekunden lang aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Protokollgr√∂√üe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  Deaktivieren Sie nun den Parameter full_page_writes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Und wiederhole das Experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Protokollgr√∂√üe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  Ja, die Gr√∂√üe hat abgenommen, aber √ºberhaupt nicht so bedeutend, wie man es erwarten k√∂nnte. <br><br>  Der Grund daf√ºr ist, dass der Cluster mit Pr√ºfsummen auf den Datenseiten initialisiert wird und Sie daher beim √Ñndern der QuickInfo-Bits immer noch ganzseitige Bilder in das Protokoll schreiben m√ºssen.  Diese Daten (in unserem Fall) machen etwa die H√§lfte des Gesamtvolumens aus, was anhand der Statistiken ersichtlich ist: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  Aus Gr√ºnden der Kompaktheit habe ich die Nullzeilen aus der Tabelle entfernt.  Achten Sie auf die Gesamtzeile (Gesamt) und vergleichen Sie die Gr√∂√üe der Vollbilder (FPI-Gr√∂√üe) mit der Gr√∂√üe normaler Datens√§tze (Datensatzgr√∂√üe). <br><br>  Der Parameter <em>full_page_writes</em> kann nur deaktiviert werden, wenn das Dateisystem und die Hardware, die f√ºr sich verwendet werden, eine atomare Aufzeichnung gew√§hrleisten.  Wie wir jedoch sehen k√∂nnen, gibt es daf√ºr keinen guten Grund (vorausgesetzt, dass Pr√ºfsummen enthalten sind). <br><br>  Nun wollen wir sehen, wie die Komprimierung hilft. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Wiederholen Sie das gleiche Experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Protokollgr√∂√üe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Schlussfolgerung: Bei einer gro√üen Anzahl von Ganzseitenbildern (aufgrund von Pr√ºfsummen oder <em>Vollseitenschreibungen</em> , <em>dh</em> fast immer) ist es h√∂chstwahrscheinlich sinnvoll, die Komprimierung zu verwenden, obwohl dadurch der Prozessor <em>geladen</em> wird. <br><br><h1>  Leistung </h1><br>  W√§hrend des normalen Serverbetriebs erfolgt eine kontinuierliche sequentielle Aufzeichnung von Protokolldateien.  Da es keinen wahlfreien Zugriff gibt, erf√ºllen auch normale Festplatten diese Aufgabe.  Diese Art des Ladens unterscheidet sich jedoch erheblich von der Art und Weise, wie auf die Datendateien zugegriffen wird. <br><br>  Daher ist es normalerweise vorteilhaft, das Protokoll auf einer separaten physischen Festplatte (oder einem Festplattenarray) abzulegen, die auf dem Server-Dateisystem bereitgestellt ist.  Anstelle des Verzeichnisses $ PGDATA / pg_wal m√ºssen Sie einen symbolischen Link zum entsprechenden Verzeichnis erstellen. <br><br><blockquote>  Es gibt einige Situationen, in denen Protokolldateien nicht nur geschrieben, sondern auch gelesen werden m√ºssen.  Der erste ist ein verst√§ndlicher Fall der Wiederherstellung nach einem Fehler.  Der zweite ist weniger trivial.  Dies tritt auf, wenn die Streaming-Replikation verwendet wird und das Replikat keine Journaleintr√§ge empf√§ngt, w√§hrend sie sich noch in den RAM-Puffern des Hauptservers befinden.  Dann muss der Walsender-Prozess die erforderlichen Daten von der Festplatte lesen.  Wir werden dar√ºber ausf√ºhrlicher sprechen, wenn wir zur Replikation kommen. <br></blockquote><br>  Die Protokollierung erfolgt in einem von zwei Modi: <br><br><ul><li>  synchron - Wenn eine Transaktion festgeschrieben wird, ist die Fortsetzung der Arbeit erst m√∂glich, wenn sich alle Journaleintr√§ge zu dieser Transaktion auf der Festplatte befinden. </li><li>  asynchron - Die Transaktion wird sofort abgeschlossen und das Protokoll wird im Hintergrund geschrieben. </li></ul><br>  Der Synchronmodus wird durch den Parameter <em>synchronous_commit</em> bestimmt und ist standardm√§√üig aktiviert. <br><br>  Da die Synchronisation mit einer realen (d. H. Langsamen) E / A verbunden ist, ist es vorteilhaft, sie so wenig wie m√∂glich durchzuf√ºhren.  Zu diesem <em>Zweck macht</em> der Wartungsprozess, der die Transaktion abschlie√üt und das Protokoll schreibt, eine kurze Pause, die durch den Parameter <em>commit_delay festgelegt</em> wird.       ,       <em>commit_siblings</em>  .     ,                 .    ,     ,  -    . <br><br>    <em>commit_siblings</em> = 5,  <em>commit_delay</em> = 0,      .  <em>commit_delay</em>     ,     OLTP-. <br><br>          LSN (  ,       ).     . <br><br>      ( D   ACID) ‚Äî   ,            .     ,       ( COMMIT      )    . <br><br>    ,  <em>synchronous_commit</em> = off ( local). <br><br>         wal writer,      (   <em>wal_writer_delay</em> = 200ms  ). <br><br>    ,  ,         WAL.  ,    , , ,     . (,    :  ,    ,         .) <br><br>       ,     (  )   ‚Äî    ? <br><br>     ,            ,      . <br><br>     ‚Äî     .   :       ,        3 √ó <em>wal_writer_delay</em>  (        ). <br><br>   ‚Äî    ‚Äî    . <br><br>  :      ( <em>fsync</em> = off),       .         , , ,       . <br><br>  <em>synchronous_commit</em>      .    ,     . ,      ,         . <br><br>       .           ,    WAL.         ,        ,        . <br><br>   -   ,     ,       pgbench. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br>       900    (tps),   ‚Äî 1500. ,         ,  ,         . <br><br>         .  -    ,       .  ! <br><br>         ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461523/">https://habr.com/ru/post/de461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461507/index.html">Warum haben wir uns entschieden, den Unternehmensbeschleuniger StartupDrive von Gazprom Neft zu starten, und wer hat ihn bereits bestanden?</a></li>
<li><a href="../de461509/index.html">Reiseassistenten: Eine Auswahl an Ger√§ten und Zubeh√∂r</a></li>
<li><a href="../de461511/index.html">Python Dependency Management: Ein Vergleich der Ans√§tze</a></li>
<li><a href="../de461517/index.html">Beste Copy-Paste-Algorithmen f√ºr C und C ++. Haiku OS Kochbuch</a></li>
<li><a href="../de461519/index.html">Beste Copy-Paste-Algorithmen f√ºr C und C ++. Haiku OS Rezeptsammlung</a></li>
<li><a href="../de461525/index.html">Wie ich einen wirklich adaptiven Slider (Karussell) gemacht habe</a></li>
<li><a href="../de461527/index.html">DIY akustische Levitation</a></li>
<li><a href="../de461531/index.html">Tic Tac Toe, Teil 6: Flasche und Sellerie / RabbitMQ</a></li>
<li><a href="../de461533/index.html">Visualisierung des Schlafes des ersten Jahres des Kindes auf den Mustern der Decke</a></li>
<li><a href="../de461535/index.html">C ++, FIX, Oracle und PL / SQL: Was ein IT-Spezialist wissen muss, um einen Job in Finanzen + echte Stellenangebote zu bekommen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>