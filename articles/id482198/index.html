<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐷 👊🏼 🦐 Cara membuat autoscaler Anda untuk sebuah cluster 🍂 ⚕️ 🍊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Kami melatih orang untuk bekerja dengan data besar. Tidak mungkin membayangkan program pendidikan tentang data besar tanpa cluster sendiri, di man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat autoscaler Anda untuk sebuah cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/newprolab/blog/482198/"><p>  Hai  Kami melatih orang untuk bekerja dengan data besar.  Tidak mungkin membayangkan program pendidikan tentang data besar tanpa cluster sendiri, di mana semua peserta bekerja bersama.  Untuk alasan ini, kami selalu memilikinya di program kami :) Kami terlibat dalam penyetelan, penyetelan dan administrasi, dan orang-orang langsung meluncurkan pekerjaan MapReduce di sana dan menggunakan Spark. </p><br><p>  Dalam posting ini, kami akan menjelaskan bagaimana kami memecahkan masalah pemuatan cluster yang tidak merata dengan menulis autoscaler kami menggunakan <a href="https://mcs.mail.ru/">cloud Mail.ru Cloud Solutions</a> . </p><a name="habracut"></a><br><h2 id="problema">  Masalah </h2><br><p>  Cluster yang kami gunakan tidak terlalu khas.  Pembuangan sangat tidak merata.  Misalnya, ada latihan praktis ketika semua 30 orang dan guru memasuki gugus dan mulai menggunakannya.  Atau, sekali lagi, ada hari sebelum batas waktu, ketika beban meningkat secara dramatis.  Sisa waktu, cluster beroperasi dalam mode underload. </p><br><p>  Solusi # 1 adalah untuk menjaga cluster yang akan menahan beban puncak, tetapi akan tetap menganggur selama sisa waktu. </p><br><p>  Solusi No. 2 adalah untuk menjaga cluster kecil di mana secara manual menambahkan node sebelum kelas dan selama beban puncak. </p><br><p>  Solusi No. 3 adalah untuk menjaga cluster kecil dan menulis autoscaler yang akan memantau beban cluster saat ini dan menambah dan menghapus node dari cluster menggunakan berbagai API. </p><br><p>  Dalam posting ini kita akan berbicara tentang keputusan No. 3.  Autoscaler seperti itu sangat tergantung pada faktor-faktor eksternal, dan bukan pada faktor-faktor internal, dan penyedia sering tidak menyediakannya.  Kami menggunakan infrastruktur cloud Mail.ru Cloud Solutions dan telah menulis autoscaler menggunakan MCS API.  Dan karena kami sedang berlatih bekerja dengan data, kami memutuskan untuk menunjukkan bagaimana Anda dapat menulis autoscaler serupa untuk keperluan Anda dan digunakan dengan cloud Anda </p><br><h2 id="prerequisites">  Prasyarat </h2><br><p>  Pertama, Anda harus memiliki cluster Hadoop.  Sebagai contoh, kami menggunakan distribusi HDP. </p><br><p>  Agar node Anda dapat dengan cepat ditambahkan dan dihapus, Anda harus memiliki distribusi peran tertentu di antara node. </p><br><ol><li>  Master node.  Ya, tidak ada yang perlu dijelaskan di sini: simpul utama gugus, di mana, misalnya, driver Spark diluncurkan, jika Anda menggunakan mode interaktif. </li><li>  Node tanggal.  Ini adalah simpul tempat Anda menyimpan data pada HDFS dan perhitungan dilakukan di sana. </li><li>  Komputasi node.  Ini adalah simpul di mana Anda tidak menyimpan apa pun di HDFS, tetapi perhitungan dilakukan di sana. </li></ol><br><p>  Poin penting.  Autoscaling akan terjadi karena jenis node ketiga.  Jika Anda mulai mengambil dan menambahkan node dari tipe kedua, maka kecepatan respons akan sangat rendah - terkompresi dan direkomendasikan akan memakan waktu berjam-jam di cluster Anda.  Ini, tentu saja, bukan yang Anda harapkan dari autoscaling.  Artinya, kita tidak menyentuh node dari tipe pertama dan kedua.  Mereka akan menjadi cluster yang layak minimal yang akan ada di seluruh program. </p><br><p>  Jadi, autoscoiler kami ditulis dalam Python 3, menggunakan Ambari API untuk mengelola layanan kluster, menggunakan <a href="https://mcs.mail.ru/help/iaas-api/openstack-api">API Mail.ru Cloud Solutions</a> (MCS) untuk memulai dan menghentikan mesin. </p><br><h2 id="arhitektura-resheniya">  Arsitektur Solusi </h2><br><ol><li> Modul <code>autoscaler.py</code> .  Tiga kelas terdaftar di dalamnya: 1) fungsi untuk bekerja dengan Ambari, 2) fungsi untuk bekerja dengan MCS, 3) fungsi yang terkait langsung dengan logika autoscaler. </li><li>  Observer skrip <code>observer.py</code> .  Bahkan, itu terdiri dari aturan yang berbeda: kapan dan pada saat apa untuk memanggil fungsi autoscaler. </li><li>  File dengan parameter konfigurasi <code>config.py</code> .  Ini berisi, misalnya, daftar node yang diizinkan untuk penskalaan otomatis dan parameter lain yang memengaruhi, misalnya, berapa banyak waktu untuk menunggu sejak node baru ditambahkan.  Ada juga stempel waktu dimulainya kelas, sehingga sebelum sesi konfigurasi cluster maksimum yang diizinkan diluncurkan. </li></ol><br><p>  Mari kita lihat potongan-potongan kode di dalam dua file pertama. </p><br><h2 id="1-modul-autoscalerpy">  1. Modul autoscaler.py </h2><br><h3 id="klass-ambari">  Kelas ambari </h3><br><p>  Ini adalah bagian dari kode yang berisi kelas <code>Ambari</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ambari</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ambari_url, cluster_name, headers, auth)</span></span></span><span class="hljs-function">:</span></span> self.ambari_url = ambari_url self.cluster_name = cluster_name self.headers = headers self.auth = auth <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_all_services</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> url = self.ambari_url + self.cluster_name + <span class="hljs-string"><span class="hljs-string">'/hosts/'</span></span> + hostname + <span class="hljs-string"><span class="hljs-string">'/host_components/'</span></span> url2 = self.ambari_url + self.cluster_name + <span class="hljs-string"><span class="hljs-string">'/hosts/'</span></span> + hostname req0 = requests.get(url2, headers=self.headers, auth=self.auth) services = req0.json()[<span class="hljs-string"><span class="hljs-string">'host_components'</span></span>] services_list = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-string"><span class="hljs-string">'HostRoles'</span></span>][<span class="hljs-string"><span class="hljs-string">'component_name'</span></span>], services)) data = { <span class="hljs-string"><span class="hljs-string">"RequestInfo"</span></span>: { <span class="hljs-string"><span class="hljs-string">"context"</span></span>:<span class="hljs-string"><span class="hljs-string">"Stop All Host Components"</span></span>, <span class="hljs-string"><span class="hljs-string">"operation_level"</span></span>: { <span class="hljs-string"><span class="hljs-string">"level"</span></span>:<span class="hljs-string"><span class="hljs-string">"HOST"</span></span>, <span class="hljs-string"><span class="hljs-string">"cluster_name"</span></span>: self.cluster_name, <span class="hljs-string"><span class="hljs-string">"host_names"</span></span>: hostname }, <span class="hljs-string"><span class="hljs-string">"query"</span></span>:<span class="hljs-string"><span class="hljs-string">"HostRoles/component_name.in({0})"</span></span>.format(<span class="hljs-string"><span class="hljs-string">","</span></span>.join(services_list)) }, <span class="hljs-string"><span class="hljs-string">"Body"</span></span>: { <span class="hljs-string"><span class="hljs-string">"HostRoles"</span></span>: { <span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"INSTALLED"</span></span> } } } req = requests.put(url, data=json.dumps(data), headers=self.headers, auth=self.auth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> req.status_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">201</span></span>, <span class="hljs-number"><span class="hljs-number">202</span></span>]: message = <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: message = req.status_code <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message</code> </pre> <br><p>  Untuk contoh di atas, Anda dapat melihat implementasi fungsi <code>stop_all_services</code> , yang menghentikan semua layanan pada node cluster yang diinginkan. </p><br><p>  Untuk kelas <code>Ambari</code> Anda lulus: </p><br><ul><li>  <code>ambari_url</code> , misalnya, dari bentuk <code>'http://localhost:8080/api/v1/clusters/'</code> , </li><li>  <code>cluster_name</code> adalah nama cluster Anda di Ambari, </li><li> <code>headers = {'X-Requested-By': 'ambari'}</code> </li> <li>  dan di dalam <code>auth</code> terdapat nama pengguna dan kata sandi Anda dari Ambari: <code>auth = ('login', 'password')</code> . </li></ul><br><p>  Fungsi itu sendiri tidak lebih dari beberapa panggilan melalui REST API ke Ambari.  Dari sudut pandang logika, pertama-tama kita mendapatkan daftar layanan yang berjalan pada node, dan kemudian kita bertanya pada cluster ini, pada node ini, untuk mentransfer layanan dari daftar ke keadaan <code>INSTALLED</code> .  Fungsi untuk meluncurkan semua layanan, untuk menempatkan node dalam status <code>Maintenance</code> , dll. Terlihat serupa - mereka hanya beberapa permintaan melalui API. </p><br><h3 id="klass-mcs">  MC kelas </h3><br><p>  Ini adalah bagian dari kode yang berisi kelas <code>Mcs</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mcs</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, id1, id2, password)</span></span></span><span class="hljs-function">:</span></span> self.id1 = id1 self.id2 = id2 self.password = password self.mcs_host = <span class="hljs-string"><span class="hljs-string">'https://infra.mail.ru:8774/v2.1'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_turn_on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> self.token = self.get_mcs_token() host = self.hostname_to_vmname(hostname) vm_id = self.get_vm_id(host) mcs_url1 = self.mcs_host + <span class="hljs-string"><span class="hljs-string">'/servers/'</span></span> + self.vm_id + <span class="hljs-string"><span class="hljs-string">'/action'</span></span> headers = { <span class="hljs-string"><span class="hljs-string">'X-Auth-Token'</span></span>: <span class="hljs-string"><span class="hljs-string">'{0}'</span></span>.format(self.token), <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } data = {<span class="hljs-string"><span class="hljs-string">'os-start'</span></span> : <span class="hljs-string"><span class="hljs-string">'null'</span></span>} mcs = requests.post(mcs_url1, data=json.dumps(data), headers=headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mcs.status_code</code> </pre> <br><p>  Untuk kelas <code>Mcs</code> , kami melewati id proyek di dalam cloud dan ID pengguna, serta kata sandi-nya.  Dalam fungsi <code>vm_turn_on</code> kami ingin mengaktifkan salah satu mesin.  Logikanya di sini sedikit lebih rumit.  Pada awal kode, tiga fungsi lain disebut: 1) kita perlu mendapatkan token, 2) kita perlu mengubah nama host menjadi nama mesin di MCS, 3) mendapatkan id dari mesin ini.  Selanjutnya, kami membuat post-request sederhana dan menjalankan mesin ini. </p><br><p>  Ini adalah bagaimana fungsi penerima token terlihat seperti: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mcs_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://infra.mail.ru:35357/v3/auth/tokens?nocatalog'</span></span> headers = {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>} data = { <span class="hljs-string"><span class="hljs-string">'auth'</span></span>: { <span class="hljs-string"><span class="hljs-string">'identity'</span></span>: { <span class="hljs-string"><span class="hljs-string">'methods'</span></span>: [<span class="hljs-string"><span class="hljs-string">'password'</span></span>], <span class="hljs-string"><span class="hljs-string">'password'</span></span>: { <span class="hljs-string"><span class="hljs-string">'user'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: self.id1, <span class="hljs-string"><span class="hljs-string">'password'</span></span>: self.password } } }, <span class="hljs-string"><span class="hljs-string">'scope'</span></span>: { <span class="hljs-string"><span class="hljs-string">'project'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: self.id2 } } } } params = ((<span class="hljs-string"><span class="hljs-string">'nocatalog'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>),) req = requests.post(url, data=json.dumps(data), headers=headers, params=params) self.token = req.headers[<span class="hljs-string"><span class="hljs-string">'X-Subject-Token'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.token</code> </pre> <br><h3 id="klass-autoscaler">  Autoscaler kelas </h3><br><p>  Kelas ini berisi fungsi yang terkait dengan logika kerja itu sendiri. </p><br><p>  Beginilah tampilan kode dari kelas ini: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Autoscaler</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ambari, mcs, scaling_hosts, yarn_ram_per_node, yarn_cpu_per_node)</span></span></span><span class="hljs-function">:</span></span> self.scaling_hosts = scaling_hosts self.ambari = ambari self.mcs = mcs self.q_ram = deque() self.q_cpu = deque() self.num = <span class="hljs-number"><span class="hljs-number">0</span></span> self.yarn_ram_per_node = yarn_ram_per_node self.yarn_cpu_per_node = yarn_cpu_per_node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hostname)</span></span></span><span class="hljs-function">:</span></span> flag1 = flag2 = flag3 = flag4 = flag5 = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hostname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.scaling_hosts: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status1 = self.ambari.decommission_nodemanager(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status1 == <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status1 == <span class="hljs-number"><span class="hljs-number">500</span></span>: flag1 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Decomission request accepted: {0}'</span></span>.format(flag1)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status3 = self.ambari.check_service(hostname, <span class="hljs-string"><span class="hljs-string">'NODEMANAGER'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status3 == <span class="hljs-string"><span class="hljs-string">'INSTALLED'</span></span>: flag3 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Nodemaneger decommissioned: {0}'</span></span>.format(flag3)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status2 = self.ambari.maintenance_on(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status2 == <span class="hljs-string"><span class="hljs-string">'Request accepted'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status2 == <span class="hljs-number"><span class="hljs-number">500</span></span>: flag2 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Maintenance request accepted: {0}'</span></span>.format(flag2)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status4 = self.ambari.check_maintenance(hostname, <span class="hljs-string"><span class="hljs-string">'NODEMANAGER'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status4 == <span class="hljs-string"><span class="hljs-string">'ON'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> status4 == <span class="hljs-string"><span class="hljs-string">'IMPLIED_FROM_HOST'</span></span>: flag4 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.ambari.stop_all_services(hostname) logging.info(<span class="hljs-string"><span class="hljs-string">'Maintenance is on: {0}'</span></span>.format(flag4)) logging.info(<span class="hljs-string"><span class="hljs-string">'Stopping services'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">90</span></span>) status5 = self.mcs.vm_turn_off(hostname) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: time.sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) status5 = self.mcs.get_vm_info(hostname)[<span class="hljs-string"><span class="hljs-string">'server'</span></span>][<span class="hljs-string"><span class="hljs-string">'status'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status5 == <span class="hljs-string"><span class="hljs-string">'SHUTOFF'</span></span>: flag5 = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'VM is turned off: {0}'</span></span>.format(flag5)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flag1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag3 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag4 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag5: message = <span class="hljs-string"><span class="hljs-string">'Success'</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">'Scale-down finished'</span></span>) logging.info(<span class="hljs-string"><span class="hljs-string">'Cooldown period has started. Wait for several minutes'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message</code> </pre> <br><p>  Untuk input kita mengambil kelas <code>Ambari</code> dan <code>Mcs</code> , daftar node yang diizinkan untuk scaling, serta parameter konfigurasi dari node: memori dan cpu yang dialokasikan ke node di BENANG.  Ada juga 2 parameter internal q_ram, q_cpu, yang merupakan antrian.  Dengan menggunakannya, kami menyimpan nilai-nilai beban cluster saat ini.  Jika kita melihat bahwa selama 5 menit terakhir telah terjadi peningkatan beban yang stabil, maka kami memutuskan bahwa kami perlu menambahkan simpul +1 ke kluster.  Hal yang sama juga berlaku untuk keadaan underload cluster. </p><br><p>  Kode di atas menunjukkan contoh fungsi yang menghapus mesin dari sebuah cluster dan menghentikannya di cloud.  Pertama, <code>YARN Nodemanager</code> , lalu mode <code>Maintenance</code> dihidupkan, maka kami menghentikan semua layanan pada mesin dan mematikan mesin virtual di cloud. </p><br><h2 id="2-skript-observerpy">  2. Script observer.py </h2><br><p>  Kode contoh dari sana: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scaler.assert_up(config.scale_up_thresholds) == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: hostname = cloud.get_vm_to_up(config.scaling_hosts) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hostname != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: status1 = scaler.scale_up(hostname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status1 == <span class="hljs-string"><span class="hljs-string">'Success'</span></span>: text = {<span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"{0} has been successfully scaled-up"</span></span>.format(hostname)} post = {<span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"{0}"</span></span>.format(text)} json_data = json.dumps(post) req = requests.post(webhook, data=json_data.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>), headers={<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>}) time.sleep(config.cooldown_period*<span class="hljs-number"><span class="hljs-number">60</span></span>)</code> </pre> <br><p>  Di dalamnya, kami memeriksa apakah ada kondisi untuk meningkatkan kapasitas cluster dan apakah ada mesin di cadangan sama sekali, kami mendapatkan nama host salah satunya, menambahkannya ke cluster dan mempublikasikan pesan tentang ini di Slack tim kami.  Setelah itu, <code>cooldown_period</code> diluncurkan, ketika kita tidak menambah atau menghapus apa pun dari cluster, tetapi cukup memantau beban.  Jika telah stabil dan berada di dalam koridor nilai beban optimal, maka kami hanya melanjutkan pemantauan.  Jika satu node tidak cukup, tambahkan satu lagi. </p><br><p>  Untuk kasus ketika kita memiliki pelajaran di depan, kita sudah tahu pasti bahwa satu node tidak cukup, jadi kami segera memulai semua node gratis dan tetap aktif sampai akhir pelajaran.  Ini terjadi dengan daftar kelas cap waktu. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Autoscaler adalah solusi yang baik dan nyaman untuk kasus-kasus ketika Anda memuat cluster tidak merata.  Anda secara bersamaan mencapai konfigurasi gugus yang diinginkan untuk beban puncak, dan pada saat yang sama tidak menahan gugus ini selama kurang muatan, menghemat uang.  Nah, ditambah lagi, semuanya terjadi secara otomatis tanpa partisipasi Anda.  Autoscoiler itu sendiri tidak lebih dari satu set permintaan ke API manajer kluster dan API penyedia cloud, terdaftar menurut logika tertentu.  Apa yang sebenarnya perlu diingat adalah pemisahan node menjadi 3 jenis, seperti yang kita tulis sebelumnya.  Dan kamu akan bahagia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482198/">https://habr.com/ru/post/id482198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482186/index.html">Hidup dan TI atau tahun ketika saya berhenti dari pekerjaan terakhir saya</a></li>
<li><a href="../id482188/index.html">Jajak pendapat Jumat tentang pembaruan</a></li>
<li><a href="../id482190/index.html">Seperti apa konten Durex di jejaring sosial di China</a></li>
<li><a href="../id482194/index.html">Otomatis Menghasilkan dan Mengisi Elemen Konfigurasi Perangkat Jaringan dengan Nornir</a></li>
<li><a href="../id482196/index.html">Apa pemodelan produksi dan mengapa itu diperlukan?</a></li>
<li><a href="../id482200/index.html">Blockchain untuk keamanan siber: harapan dan kenyataan</a></li>
<li><a href="../id482202/index.html">Metode untuk memperbarui kriptografi pada peralatan Titik Periksa ke GOST 2012</a></li>
<li><a href="../id482206/index.html">Cara membuat produksi suku cadang 3D untuk pesawat lebih ekonomis</a></li>
<li><a href="../id482208/index.html">Hadiah yang membuat Anda melewatkan Tahun Baru</a></li>
<li><a href="../id482212/index.html">Bicara tentang ... keju?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>