<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 👩🏾‍💼 🏂🏼 Pertukaran atom yang bersinar dan kemiskinan ⛪️ 🔧 🎲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa pertukaran atom itu buruk dan bagaimana saluran akan membantu mereka, apa yang penting terjadi di garpu keras Konstantinopel dan apa yang haru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertukaran atom yang bersinar dan kemiskinan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483828/">  Mengapa pertukaran atom itu buruk dan bagaimana saluran akan membantu mereka, apa yang penting terjadi di garpu keras Konstantinopel dan apa yang harus dilakukan ketika tidak ada yang membayar untuk gas. <br><br>  Motivasi utama setiap profesional keamanan adalah keinginan untuk menghindari tanggung jawab. <br><br>  Providence ramah, saya meninggalkan ICO, tidak menunggu transaksi ireversibel pertama, tetapi segera menemukan diri saya di belakang pengembangan pertukaran mata uang kripto. <br><a name="habracut"></a><br>  Saya jelas bukan Malchish Kibalchish, dan satu pandangan ketat sudah cukup bagi saya untuk melewati semua kunci dan kata sandi.  Oleh karena itu, tujuan utama saya sebagai seorang arsitek adalah untuk menempatkan sengatan merah kriptanalisis sejauh mungkin dari elemen infrastruktur yang saya sayangi. <br><br><h2>  Bukan kunci Anda, bukan masalah Anda </h2><br>  Kami sedang membangun sistem pertukaran aset dan ingin mengecualikan penyimpanan perantara dari aset-aset ini di rumah, tetapi kami harus memastikan keamanan transaksi. <br><br>  Anda dapat bertindak sebagai hakim dalam situasi kontroversial dan melakukan transaksi dengan dompet yang memerlukan dua dari tiga tanda tangan: pembeli, penjual, dan escrow. <br><br>  Namun, jika peserta berhasil menyerang escrow, maka ia menerima dua tanda tangan yang diperlukan. <br><br>  Atomic swap adalah skema pertukaran di mana kontrak pintar bertindak sebagai penjamin, yang hanya memungkinkan perilaku jujur. <br><br>  Seolah-olah dalam sebuah teka-teki tentang seekor kambing serigala dan kubis, Anda dapat bertindak hanya berdasarkan satu-satunya skenario yang benar dan menanggung kerugian jika Anda mundur darinya. <br><br>  Hanya alih-alih hewan yang rakus, perintah ini menyediakan fungsi hash di mana sangat sulit untuk menemukan tabrakan sehingga tidak layak untuk memulai. <br><br><h4>  Langkah Satu: Teka-Teki </h4><br>  Misalkan Alice ingin memberikan Bitcoin kepada Bob untuk beberapa "crypto yuan" suatu pagi yang cerah. <br><br><ul><li>  Dia membuat rahasia besar </li><li>  Menerima hash darinya </li><li>  Ini mentransfer bitcoin ke kontrak pintar, dari mana Bob dapat mengambil uang dengan menghadirkan sebuah rahasia (hash dari itu harus sama dengan yang ditentukan dalam kontrak) </li><li>  Jika Bob tidak berada di bitcoin di malam hari, Alice dapat mengambilnya kembali untuk dirinya sendiri. </li></ul><br><h4>  Langkah Dua: Umpan </h4><br>  Bob memasuki permainan dan mentransfer "cryptoeuro" ke kontraknya, yang ditulis sedemikian rupa sehingga: <br><br><ul><li>  Alice dapat mengambil "crypto-coin" dengan menghadirkan nomor rahasia </li><li>  Tidak lebih awal dari makan siang, Bob, jika Alice tidak muncul, dapat mengembalikan deposit <br></li></ul><br><h4>  Langkah Tiga: Solusi dalam Umpan </h4><br>  Alice datang untuk mengambil uangnya dan mengambil uang dari kontrak Bob, sembari mengungkapkan rahasianya. <br><br><h4>  Langkah terakhir: teka-teki terpecahkan </h4><br>  Bob melihat transaksi itu, dan dengan tatapan tajamnya ia mengisolasi rahasia yang dihadirkan Alice pada kontrak.  Dia menggunakan rahasia ini untuk mengumpulkan bitcoin-nya. <br><br><h3>  Ketika terjadi kesalahan </h3><br>  Jika Alice tiba-tiba berubah menjadi fana, Bob mengambil yuan untuk makan siang. <br><br>  Pada gilirannya, Alice pada malam hari mengembalikan bitcoin jika Bob yang pengkhianat memutuskan untuk menahan uang itu sampai waktu yang lebih baik. <br><br>  Jika Anda lebih suka gambar daripada teks, di Habré ada penjelasan yang lebih rinci dan jelas <a href="https://habr.com/en/post/458646/">tentang pekerjaan pertukaran atom untuk Anda</a> . <br><br>  Perbedaan antara batas waktu dirancang untuk melindungi kita dari Alice yang jahat, yang mengambil uang Bob pada saat-saat terakhir, dan batas waktu berakhir ketika dia mengarahkan hex ke dalam transaksi dengan jari-jari yang gemetar. <br><br>  Peserta tidak dapat kehilangan uang mereka, maksimum harus menunggu pengembalian. <br><br><div class="spoiler">  <b class="spoiler_title">Dukungan Blockchain</b> <div class="spoiler_text">  Ini adalah skema sederhana seperti sepatu bot felt, yang tidak membutuhkan apa pun dari blockchain yang berinteraksi: <br><br><ul><li>  Dukungan untuk kontrak pintar dengan setidaknya satu cabang </li><li>  Kedua blockchain harus mendukung algoritma hashing yang sama (jangan lupa untuk memeriksa panjang rahasianya) </li><li>  Timelocks. </li></ul><br></div></div><br>  Pada pandangan pertama, orang sudah bisa mengatakan kepada pertukaran "selamat tinggal, pertemuan kami adalah kesalahan", tetapi tidak ada di sana. <br><br>  Untuk semua manfaatnya, solusi pertukaran atom tidak menyerang dengan likuiditas.  Sebagian besar karena dalam pasangan BTC-USD paling populer, bagian fiat tidak sepenuhnya tokenized. <br>  Keberhasilan USDT telah menghasilkan gelombang koin stabil dalam format ERC20 untuk setiap selera, dari USDC penahanan hingga DAI paling algoritmik. <br><br>  Oleh karena itu, untuk kesederhanaan, kami lebih lanjut berpendapat bahwa Alice menjual Bobcoins ke Bob untuk beberapa token ERC20, dan kami berharap untuk keberhasilan stabilisator, karena kami memiliki lebih banyak masalah teknis. <br><br><h3>  Kecepatan </h3><br>  Bitcoin dan Ethereum saja tidak terlalu cepat, tetapi di sini kita harus menunggu dulu untuk satu setoran dengan semua konfirmasi, lalu yang kedua. <br><br>  Ini semua karena peserta yang mengetahui rahasia pertama-tama menghasilkan uang, dan lawan menunggu untuk final dan baru kemudian mentransfer bagiannya. <br><br>  Selain itu, kami berhadapan dengan aset yang sangat fluktuatif, sehingga selama ini kursus dapat berubah secara signifikan, dan mengubah kondisinya tidak mudah. <br><br><h3>  Kerahasiaan </h3><br>  Setiap pertukaran meninggalkan artefak di kedua blockchain.  Seorang pengamat yang penuh perhatian dapat melihat hash yang sama dalam kontrak pintar dan membuat kesimpulan logis bahwa kesepakatan telah dibuat di sini, yang darinya banyak kesimpulan dapat dibuat dari nilai tukar hingga pajak. <br><br>  Ketika pertukaran tahu tentang urusan Anda - ini sangat tidak menyenangkan, ketika semua orang tahu tentang hal itu - itu sangat tidak menyenangkan. <br><br><h3>  Kegunaan </h3><br>  Kuda blockchain pada umumnya dan eter pada khususnya.  Mari kita lihat gerakan tubuh apa yang harus dilakukan penjual dan pembeli. <br><br>  Dari sudut pandang penjual, semuanya relatif sederhana: Anda hanya perlu mentransfer Bitcoin ke alamat p2sh.  Dengan eter semuanya jauh lebih rumit. <br><br><div class="spoiler">  <b class="spoiler_title">Kontrak</b> <div class="spoiler_text">  Pertimbangkan kontrak swap rata-rata gigab: <br><br><pre><code class="plaintext hljs">contract iERC20 { function totalSupply() public view returns (uint256); function transfer(address receiver, uint numTokens) public returns (bool); function balanceOf(address tokenOwner) public view returns (uint); function approve(address delegate, uint numTokens) public returns (bool); function allowance(address owner, address delegate) public view returns (uint); function transferFrom(address owner, address buyer, uint numTokens) public returns (bool); } contract Swapper { struct Swap { iERC20 token; bytes32 hash; uint amount; uint refundTime; bytes32 secret; } mapping (address =&gt; mapping(address =&gt; Swap)) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, uint refundTime) public { require(swaps[msg.sender][receiver].amount == 0); // check is swap with given hash already exists require(token.transferFrom(msg.sender, address(this), amount)); // transfer locked tokens to swap contract swaps[msg.sender][receiver] = Swap(token, hash, amount, refundTime, 0x00); //create swap } function hashOf(bytes32 secret) public pure returns(bytes32) { return sha256(abi.encodePacked(secret)); } function withdraw(address owner, bytes32 secret) public { Swap memory swap = swaps[owner][msg.sender]; require(swap.secret == bytes32(0)); require(swap.hash == sha256(abi.encodePacked(secret))); // swap exists swaps[owner][msg.sender].secret = secret; swap.token.transfer(msg.sender, swap.amount); } function refund(address receiver) public { Swap memory swap = swaps[msg.sender][receiver]; require(now &gt; swap.refundTime); delete swaps[msg.sender][receiver]; swap.token.transfer(msg.sender, swap.amount); } }</code> </pre> <br>  <b>Perhatian!</b>  Jangan gunakan ini dan kontrak lain dari artikel tentang produksi, mereka ditulis hanya untuk demonstrasi.  <b>Terutama yang ini</b> . <br></div></div><br><ul><li>  Bob harus memanggil metode yang <code>approve</code> pada kontrak token, memberikan akses kontrak swap ke tokennya <br></li><li>  Bob membuat swap dan kontrak menggunakan metode <code>transferFrom</code> mengambil token pengirim ke alamatnya <br></li><li>  Alice yang <code>withdraw</code> mengungkapkan sebuah rahasia dan kontrak itu meminta <code>transfer</code> <br></li></ul><br>  Sebagian besar dompet dan <code>approve</code> tidak mendukung token yang <code>approve</code> , dan untuk alasan yang baik. <br><br>  Pengguna sendiri sering keliru dan hanya mentransfer token ke kontrak, setelah itu token hilang begitu saja.  Komentar di Etherscan penuh dengan ratapan menyedihkan. <br><br>  Dan untuk memanggil kontrak, Anda harus membayar komisi dalam ETH, sehingga kedua peserta harus menyimpannya sebelum dimulainya transaksi, dan sedikit orang yang ingin melakukan ini. <br><br><h3>  Pemegang gas </h3><br>  Untuk memulainya, ada baiknya menghapus cek pengirim sedapat mungkin dan dengan asumsi bahwa kita memiliki seseorang yang menderita kelebihan gas dan menyebabkan kontrak untuk semua orang. <br><br><div class="spoiler">  <b class="spoiler_title">Kontrak yang ditingkatkan</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">contract Swapper { struct Swap { iERC20 token; address receiver; uint amount; address refundAddress; uint refundTime; } mapping (bytes32 =&gt; Swap) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public { require(swaps[hash].amount == 0); // use hash once require(token.transferFrom(msg.sender, address(this), amount)); swaps[hash] = Swap(token, receiver, amount, refundAddress, refundTime); } function withdraw(bytes memory secret) public { bytes32 hash = sha256(secret); Swap memory swap = swaps[hash]; require(swap.amount &gt; 0); delete swaps[hash]; swap.token.transfer(swap.receiver, swap.amount); } function refund(bytes32 hash) public { Swap memory swap = swaps[hash]; require(now &gt; swap.refundTime); delete swaps[hash]; swap.token.transfer(swap.refundAddress, swap.amount); } }</code> </pre><br></div></div><br><h3>  Dualisme Kontrak-Kunci dan EIP 712 </h3><br>  Seperti yang kita ketahui, alamat yang disiarkan dapat berupa kontrak, atau dapat menjadi subjek, dengan kata lain, kunci. <br>  Pekerjaan utama kunci adalah menandatangani pesan apa pun. <br><br>  Kita dapat menggunakan kontrak Bob sebagai pengirim, yang membuat semua lintasan yang diperlukan, sebelum memeriksa tanda tangan kunci Bob. <br><br>  Sekarang, siapa pun dapat mensponsori komisi anggota, tetapi hanya orang yang tahu kunci yang membuat keputusan. <br><br><div class="spoiler">  <b class="spoiler_title">Kontrak Bob</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library EIP712ProxyLibrary { function hashCommand(address sender, iERC20 token, Swapper swapper, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public view returns(bytes32); } contract ProxyBob { address owner; constructor(address _owner) public { owner = _owner; } function createSwap(Swapper swapper, iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime, uint8 v, bytes32 r, bytes32 s) public { require(owner == ecrecover(EIP712ProxyLibrary.hashCommand(address(this), token, swapper, hash, receiver, amount, refundAddress, refundTime), v, r, s)); token.approve(address(swapper), amount); swapper.create(token, hash, receiver, amount, refundAddress, refundTime); } }</code> </pre><br></div></div><br>  Ethereum memiliki standar <a href="" rel="nofollow">EIP 712</a> untuk bekerja dengan tanda tangan dari struktur data yang kompleks. Anda dapat membacanya lebih lanjut di <a href="https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26" rel="nofollow">blog dompet Metamask.</a> <br><br><h3>  Bagilah dan taklukkan </h3><br>  Seringkali skenario peretasan kontrak Ethereum terlihat seperti ini: <br><br><ul><li>  Peserta membayar dana untuk kontrak </li><li>  Lalu ambil uangnya </li><li>  Ada yang salah </li><li>  Seorang penyerang mengambil uang lagi dan lagi </li></ul><br>  Jika kita kembali ke contoh pertama kita, ada yang salah jika teka-teki itu adalah byte kosong. <br><br><div class="spoiler">  <b class="spoiler_title">Cara mencuri satu juta</b> <div class="spoiler_text">  Buat swap dengan hash <code>0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925</code> <br>  Ini adalah sha256 dari <code>0x0000000000000000000000000000000000000000000000000000000000000000</code> <br>  Kami melewati rahasia dan mengumpulkan token kami <br>  Kami lulus lagi dan mengambil orang asing, semua karena 0 = 0 <br></div></div><br>  Dengan membuat kontrak terpisah untuk setiap transaksi, kami dapat mengisolasi kontrak di level EVM. <br><br>  Tapi ini belum semuanya: sekarang setiap transaksi memiliki alamatnya sendiri, di mana Anda dapat mentransfer token dari dompet atau pertukaran apa pun. <br><br><h2>  Kontrak dan penciptaan yang ditinggalkan2 </h2><br>  Tapi sekarang untuk setiap transaksi kita harus membuat kontrak dan menunggu pembeli untuk mentransfer tenaga kerja "cryptofening" di sana.  Dalam skema "kontrak pagi, uang malam" selalu ada bahaya bahwa pembeli akan jatuh, dan eter telah dihabiskan untuk membuat kontrak. <br><br>  Apakah mungkin menghasilkan uang di pagi hari dan byte di malam hari? <br><br>  Dalam fork Konstantinopel, pengembang <a href="https://eips.ethereum.org/EIPS/eip-1014" rel="nofollow">EIP 1014</a> menambahkan pernyataan create2 yang menciptakan kontrak baru pada alamat deterministik <br><br><pre> <code class="plaintext hljs">keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]</code> </pre><br>  Dimana <br><br><ul><li>  alamat - alamat kontrak pabrik </li><li>  salt - sejumlah angka, artinya kita akan pelajari di seri selanjutnya </li><li>  init_code - kontrak bytecode dan parameter konstruktor. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Pabrik</b> <div class="spoiler_text">  Instruksi hanya bekerja melalui perakitan, sehingga pabrik terlihat agak menakutkan: <br><br><pre> <code class="plaintext hljs">contract Factory { event Deployed(address addr, uint256 salt); function create2(bytes memory code, uint256 salt) public { address addr; assembly { addr := create2(0, add(code, 0x20), mload(code), salt) } emit Deployed(addr, salt); } }</code> </pre><br>  Kode kontrak Anda dapat diperoleh menggunakan web3: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyContract = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(ABI, {}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ode = MyContract.deploy({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: BYTECODE, <span class="hljs-attr"><span class="hljs-attr">arguments</span></span>: contructorArgs }).encodeABI(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(FACTORY_ABI, factoryAddress); tx = factory.methods.create2(ode, salt);</code> </pre><br>  Karena dukungan yang terbatas dalam soliditas, gas untuk kontrak mungkin tidak dapat dihitung dengan benar karena beberapa seluk eter. <br><br>  Sangat menyenangkan bahwa jika terjadi kekurangan gas, kontrak jatuh dengan kesalahan internal, tanpa memberi tahu bahwa tidak ada cukup gas, seperti yang diharapkan. <br></div></div><br>  Sekarang kita dapat mentransfer token ke kontrak tanpa membuatnya terlebih dahulu, dan sampai kita mempublikasikannya di jaringan, tidak ada yang akan menebak apa sebenarnya yang dilakukan kontrak. <br><br><h3>  Gagak tidak akan mematuk gagak </h3><br>  Jelas bahwa trik anak-anak seperti itu tidak akan menghentikan seorang analis sungguhan, terutama yang telah menerima investasi bagus dalam memerangi <s>musuh</s> - <s>musuh rezim</s> pencucian uang, dan setelah membuat kontrak ia masih akan melihat hash. <br><br>  Bagaimana memastikan hash tidak menyala? <br><br>  Kami mentransfer swap itu sendiri ke rantai: peserta bertukar tanda tangan untuk transfer ke kontrak swap, dan kemudian rahasianya diungkapkan secara pribadi. <br><br><div class="spoiler">  <b class="spoiler_title">Langkah demi langkah</b> <div class="spoiler_text">  Dua "multisig" dibuat, dari mana Anda dapat menarik dana jika Anda memiliki tanda tangan Alice dan Bob. <br><br>  Agar offline, salah satu peserta tidak menjadi tragedi, kami menambahkan batas waktu lama yang baik. <br><br>  Alice dan Bob melakukan deposit secara paralel <br><br><ul><li>  Alice membuat rahasia dan memberi Bob hash rahasia dan tanda tangan transaksi, yang mentransfer bitcoin ke alamat swap </li><li>  Bob memberi Alice tanda tangan pada penarikan token pada kontrak swap dengan hash tersembunyi. </li><li>  Alice memberi tahu Bob rahasia. </li></ul><br></div></div><br>  Pada saat ini, harmoni terjadi: Alice dan Bob dapat menyelesaikan kesepakatan kapan saja.  Dalam lingkungan yang bersahabat seperti itu, mereka dapat bertukar tanda tangan dari menarik uang ke alamat akhir mereka. <br><br>  Bagi pengamat luar, sepertinya uang itu melewati kontrak dengan tanda tangan 2 dari 2. <br><br>  Dan juga skema semacam itu memungkinkan kedua belah pihak untuk melakukan deposit pada saat yang sama, karena rahasia sudah dibuat setelah semua konfirmasi. <br><br><h2>  Level 2 </h2><br>  Karena kita dapat menarik uang ke satu alamat dan tidak mempublikasikan transaksi perantara, tidak ada yang menghalangi kita untuk menarik uang ke beberapa alamat dan membuat transaksi perantara dalam jumlah tak terbatas.  Bukan berarti itu diperlukan untuk pertukaran, tetapi jika Anda mulai mengumpulkan swap, sulit untuk berhenti. <br><br>  Sekarang Alice dan Bob akan dapat berbalik dengan kekuatan dan main.  Misalnya, secara otomatis menghitung harga rata-rata dengan menukarkan Satoshi per detik, atau cukup langsung menghubungkan pembuat pasar dan penerima likuiditas. <br><br><div class="spoiler">  <b class="spoiler_title">Langkah demi langkah</b> <div class="spoiler_text"><ul><li>  Penjual membuat rahasia dan memberi pembeli hash rahasia dan tanda tangan transaksi di mana sebagian dana ditransfer ke alamat swap p2sh, dan sisanya dikembalikan ke alamat penjual <br></li><li>  Pembeli mentransmisikan tanda tangan yang memungkinkan untuk menarik token pada swap dan pengiriman ke alamat penerima. <br></li><li>  Penjual mengungkapkan rahasia </li><li>  Kisah ini diulangi dengan rahasia baru, sementara pada swap dan menyerah ditambahkan output yang sebelumnya dibeli ke alamat pembeli dan sudah dibayarkan ke alamat penjual </li></ul><br></div></div><br>  Sekarang kami memiliki akses ke perdagangan P2P kecepatan tinggi, yang utama adalah memantau waktu dan menutup kesepakatan sebelum waktu habis. <br><br>  Namun, setelah sedikit menyesuaikan kontrak kami, kami dapat memberikan keabadian saluran kami, yang akan sangat menyederhanakan pembuatan jaringan bagi kami. <br><br>  Tapi kita akan membicarakan ini di seri berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483828/">https://habr.com/ru/post/id483828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483814/index.html">Abraham Flexner: The Usefulness of Useless Knowledge (1939)</a></li>
<li><a href="../id483818/index.html">Engine, bahasa scripting, dan novel visual - dalam 45 jam</a></li>
<li><a href="../id483820/index.html">Apa yang mempengaruhi penerbitan kredit. Ikhtisar Kompetisi Risiko Default Kredit Rumah</a></li>
<li><a href="../id483822/index.html">5 fitur JavaScript yang tanpanya saya tidak bisa menulis kode</a></li>
<li><a href="../id483826/index.html">Menghubungkan Model Sensor CO2 MH-Z19B Menggunakan Output Analog Vo</a></li>
<li><a href="../id483830/index.html">Routing untuk iOS: navigasi universal tanpa menulis ulang aplikasi</a></li>
<li><a href="../id483832/index.html">RxJava to Coroutines: migrasi fitur ujung ke ujung</a></li>
<li><a href="../id483834/index.html">Debian: cukup mengubah i386 menjadi amd64</a></li>
<li><a href="../id483842/index.html">Sejarah menciptakan cloud rumah. Bagian 5. Memperbarui 2019 - PHP 7.2, MariaDB 10.4 dan Nextcloud 17</a></li>
<li><a href="../id483844/index.html">Analisis dokumen peraturan tentang perlindungan informasi di sektor kredit dan keuangan Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>