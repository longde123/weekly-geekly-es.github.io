<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ ü•õ ü§∞üèΩ Objetos versus estructuras de datos üçñ üõéÔ∏è üìñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el art√≠culo, cuya traducci√≥n se propone a continuaci√≥n, Robert Martin parece comenzar con pensamientos muy similares a los que se pueden ver en las...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Objetos versus estructuras de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477712/"><p>  En el art√≠culo, cuya traducci√≥n se propone a continuaci√≥n, Robert Martin parece comenzar con pensamientos muy similares a los que se pueden ver en las discusiones de Yegor Bugaenko sobre ORM, pero otros sacan conclusiones.  Personalmente, el enfoque de Yegor me impresiona, pero creo que Martin revela el tema con m√°s detalle.  Me parece que vale la pena conocer a todos los que han pensado qu√© lugar deber√≠a ocupar ORM y, en general, por qu√© necesitamos objetos en los que todos los campos est√©n abiertos.  El art√≠culo est√° escrito en el g√©nero "Di√°logo", donde un programador m√°s experimentado discute un problema con alguien que tiene menos experiencia. </p><br><blockquote>  ¬øQu√© es una clase? </blockquote><p>  Una clase es una especificaci√≥n de muchos objetos similares. </p><br><blockquote>  ¬øQu√© es un objeto? </blockquote><p>  Un objeto es un conjunto de funciones que realizan acciones con datos encapsulados. </p><br><blockquote>  ¬øO es mejor decir que un objeto es un conjunto de funciones que realizan acciones con datos cuya existencia est√° impl√≠cita </blockquote><p>  En el sentido de "implicado"? </p><a name="habracut"></a><br><blockquote>  Una vez que el objeto tiene funciones, se puede suponer que tambi√©n hay datos all√≠, pero no hay acceso directo a los datos y no son visibles desde el exterior. </blockquote><p>  ¬øNo est√°n los datos en el objeto? </p><br><blockquote>  Tal vez lo son, pero la regla que dice que deben estar all√≠ no existe.  Desde el punto de vista del usuario, un objeto no es m√°s que un conjunto de funciones.  Los datos con los que funcionan estas funciones deben existir, pero el usuario desconoce la posici√≥n de estos datos. </blockquote><p>  Bueno, digamos </p><br><blockquote>  Bueno, ¬øqu√© es una estructura de datos? </blockquote><p>  Una estructura de datos es una colecci√≥n de elementos relacionados. </p><br><blockquote>  O, en otras palabras, una estructura de datos es un conjunto de elementos con los que funcionan las funciones, cuya existencia est√° impl√≠citamente impl√≠cita. </blockquote><p>  Vale, vale.  Lo entiendo  Las funciones que funcionan con estructuras de datos no est√°n definidas dentro de estas estructuras, pero a partir de la existencia misma de una estructura de datos podemos concluir que debe haber algo que funcione con ellas. </p><br><blockquote>  Derecho  ¬øY qu√© hay de estas dos definiciones? </blockquote><p>  En cierto sentido, son opuestos entre s√≠. </p><br><blockquote>  De verdad.  Se complementan entre s√≠.  Como una mano y un guante. <br><ul><li>  Un objeto es un conjunto de funciones que funcionan con elementos de datos cuya existencia est√° impl√≠citamente impl√≠cita. </li><li>  Una estructura de datos es un conjunto de elementos de datos con los que funcionan las funciones, cuya existencia est√° impl√≠citamente impl√≠cita. </li></ul><br></blockquote><p>  Wow!  ¬°Entonces resulta que los objetos y las estructuras de datos no son lo mismo! </p><br><blockquote>  Derecho  Las estructuras de datos son DTO. </blockquote><p>  Y las tablas en las bases de datos tampoco son objetos, ¬øverdad? </p><br><blockquote>  Es cierto de nuevo.  Las bases de datos contienen estructuras de datos, no objetos. </blockquote><p>  Espera un momento  ¬øORM no asigna las tablas de la base de datos a los objetos? </p><br><blockquote>  Por supuesto que no.  No puede asignar tablas de bases de datos a objetos.  Las tablas en la base de datos son estructuras de datos, no objetos. </blockquote><p>  Entonces, ¬øqu√© hace ORM? </p><br><blockquote>  Transfieren datos de una estructura a otra. </blockquote><p>  ¬øEntonces no tienen nada que ver con los objetos? </p><br><blockquote>  Nada en absoluto  Estrictamente hablando, algo como ORM en el sentido de la tecnolog√≠a que asigna datos relacionales a objetos no existe, porque las tablas no pueden asignarse desde una base de datos a objetos. </blockquote><p>  Pero me dijeron que los ORM recogen objetos comerciales. </p><br><blockquote>  No, ORM recupera datos de una base de datos con la que trabajan los objetos comerciales </blockquote><p>  ¬øPero estas estructuras de datos no caen en objetos comerciales? </p><br><blockquote>  Tal vez lo consiguen, o tal vez no.  ORM no sabe nada sobre esto. </blockquote><p>  Pero la diferencia es puramente sem√°ntica. </p><br><blockquote>  No no  Hay consecuencias de largo alcance. </blockquote><p>  Por ejemplo? </p><br><blockquote>  Por ejemplo, el dise√±o del esquema de la base de datos y el dise√±o de objetos comerciales.  Los objetos comerciales definen el comportamiento empresarial.  El esquema de la base de datos define la estructura de datos comerciales.  Estas estructuras est√°n limitadas por fuerzas muy diferentes.  Una estructura de datos empresariales no es necesariamente la mejor estructura para el comportamiento empresarial. </blockquote><p>  Eeee  Esto es incomprensible. </p><br><blockquote>  Pi√©nsalo de esa manera.  El esquema de datos no est√° dise√±ado para una sola aplicaci√≥n, est√° destinado a usarse en toda la empresa.  Por lo tanto, la estructura de datos es un compromiso entre varias aplicaciones diferentes. </blockquote><p>  Esto es entendible. </p><br><blockquote>  Bueno  Ahora piense en cada aplicaci√≥n individual.  El modelo de objetos de cada aplicaci√≥n describe c√≥mo se estructura el comportamiento de la aplicaci√≥n.  Cada aplicaci√≥n tendr√° su propio modelo de objeto para que coincida mejor con el comportamiento de la aplicaci√≥n. </blockquote><p>  Ahh, ya veo.  Dado que el esquema de datos es un compromiso entre diferentes aplicaciones, el esquema no recaer√° en el modelo de objeto de cada aplicaci√≥n individual. </p><br><blockquote>  Derecho!  Los objetos y las estructuras se limitan a diferentes cosas.  Muy raramente encajan.  La gente llama a esto la falta de coincidencia de la impedancia relacional del objeto. </blockquote><p>  Algo que recuerdo.  Pero parece que la falta de coincidencia de impedancia se corrigi√≥ utilizando ORM. </p><br><blockquote>  Y ahora sabes que esto no es as√≠.  La falta de coincidencia de impedancia entre los objetos y las estructuras de datos es complementaria, no isomorfa. </blockquote><p>  Que? </p><br><blockquote>  Son opuestos, no algo similar. </blockquote><p>  Opuestos? </p><br><blockquote>  S√≠, en un sentido muy interesante.  Ver√°, los objetos y las estructuras de datos implican estructuras de control diametralmente opuestas. </blockquote><p>  Que? </p><br><blockquote>  Piense en un conjunto de clases que implementan alg√∫n tipo de interfaz com√∫n.  Por ejemplo, imagine clases que representan figuras bidimensionales, en las que hay funciones para calcular el √°rea y el per√≠metro de una figura. </blockquote><p>  ¬øCu√°nto empujan las formas al c√≥digo con los objetos en todos los ejemplos? </p><br><blockquote>  Veamos dos tipos diferentes de formas: Cuadrados y C√≠rculos.  Est√° claro que las funciones para calcular el √°rea y el per√≠metro de estas clases utilizan diferentes estructuras de datos.  Tambi√©n se entiende que estas operaciones se invocan mediante polimorfismo din√°mico. </blockquote><p>  Reduzca la velocidad por favor, nada est√° claro. </p><br><blockquote>  Hay dos funciones diferentes para calcular el √°rea, una para el cuadrado y la otra para el c√≠rculo.  Cuando se llama a una funci√≥n para calcular el √°rea de un objeto en particular, es este objeto el que decide a qu√© funci√≥n en particular llamar.  Esto se llama polimorfismo din√°mico. </blockquote><p>  Esta bien  Por supuesto  Un objeto sabe c√≥mo se implementan sus m√©todos.  Naturalmente </p><br><blockquote>  Ahora vamos a convertir estos objetos en estructuras de datos.  Usamos sindicatos discriminados. </blockquote><p>  Discriminado qu√©? </p><br><blockquote>  Uniones discriminadas.  Bueno, C ++, punteros, la palabra clave de uni√≥n, una bandera para determinar el tipo de estructura, Uniones discriminadas.  En nuestro caso, estas son solo dos estructuras de datos diferentes.  Uno para el cuadrado y otro para el c√≠rculo.  El c√≠rculo tiene un punto central y un radio.  Y un c√≥digo de tipo a partir del cual se puede entender que es un c√≠rculo. </blockquote><p>  El campo con el c√≥digo ser√° enum? </p><br><blockquote>  Pues si.  Y el cuadrado tendr√° el punto superior izquierdo y la longitud del lado.  Y tambi√©n enumeraci√≥n para indicar el tipo. </blockquote><p>  Esta bien  Habr√° dos estructuras con un c√≥digo de tipo. </p><br><blockquote>  Derecho  Ahora veamos la funci√≥n para el √°rea.  Probablemente habr√° un cambio, ¬øverdad? </blockquote><p>  Bueno  Por supuesto, para dos clases.  La rama para el cuadrado y para el c√≠rculo.  Y para el per√≠metro, tambi√©n necesita un interruptor similar. </p><br><blockquote>  Y de nuevo, correcto.  Ahora piense en estos dos escenarios.  En un escenario con objetos, dos implementaciones de funciones para un √°rea son independientes entre s√≠ y pertenecen (en cierto sentido) directamente al tipo.  La funci√≥n para el √°rea del cuadrado pertenece al cuadrado, y la funci√≥n para determinar el √°rea del c√≠rculo pertenece al c√≠rculo. </blockquote><p>  De acuerdo, entiendo a lo que est√°s conduciendo.  En un escenario con estructuras de datos, ambas implementaciones de una funci√≥n para un √°rea est√°n en la misma funci√≥n, no "pertenecen" (sea lo que sea que esa palabra signifique) al tipo. </p><br><blockquote>  M√°s lejos es mejor.  En el caso de los objetos, si necesita agregar el tipo Tri√°ngulo, ¬øqu√© c√≥digo se debe cambiar? </blockquote><p>  No cambies nada en absoluto.  Simplemente crea una nueva clase Triangle.  Aunque no, probablemente deba corregir el c√≥digo que crea los objetos. </p><br><blockquote>  Derecho  Entonces, al agregar un nuevo tipo, los cambios son insignificantes.  Ahora suponga que necesita agregar una nueva funci√≥n, por ejemplo, una funci√≥n para determinar el centro. </blockquote><p>  Luego debe agregarlo a los tres tipos, C√≠rculo, Cuadrado y Tri√°ngulo. </p><br><blockquote>  Bueno  Resulta que agregar nuevas funciones es dif√≠cil, porque tienes que hacer cambios en cada clase. </blockquote><p>  Pero con las estructuras de datos, todo es diferente.  Para agregar un Tri√°ngulo, debe cambiar cada funci√≥n para agregar ramas para manejar el Tri√°ngulo en cada interruptor. </p><br><blockquote>  Derecho  Es dif√≠cil agregar tipos; tienes que editar cada funci√≥n. </blockquote><p>  Pero para agregar una funci√≥n para el centro, no es necesario cambiar nada. </p><br><blockquote>  S√≠. Agregar funciones es f√°cil. </blockquote><p>  Wow  Resulta que estos dos enfoques son directamente opuestos. </p><br><blockquote>  Definitivamente si.  Para resumir </blockquote><br><ul><li>  Es dif√≠cil agregar nuevas funciones a las clases, debes hacer cambios en cada clase </li><li>  Agregar nuevas funciones a las estructuras de datos es simple, solo necesita agregar una funci√≥n, no necesita cambiar nada m√°s </li><li>  Agregar nuevos tipos a las clases es simple, solo necesita agregar una nueva clase </li><li>  Es dif√≠cil agregar nuevos tipos para estructuras; necesita arreglar cada funci√≥n </li></ul><br><p>  Si  Opuestos.  Opuestos en un sentido curioso.  Es decir, si se sabe de antemano que es necesario agregar nuevas funciones, es conveniente utilizar estructuras de datos.  Pero si sabe de antemano que tiene que agregar nuevos tipos, entonces necesita usar clases. </p><br><blockquote>  Buena observaci√≥n!  Pero hoy necesitamos pensar en una cosa m√°s.  Hay otro punto en el que las estructuras de datos y las clases son opuestas entre s√≠.  Dependencias </blockquote><p>  Adicciones? </p><br><blockquote>  S√≠, la direcci√≥n de las dependencias en el c√≥digo fuente. </blockquote><p>  Ok, preguntar√©.  Cual es la diferencia </p><br><blockquote>  Veamos el caso de las estructuras.  Cada funci√≥n contiene un conmutador que selecciona la implementaci√≥n deseada en funci√≥n del c√≥digo de tipo en la uni√≥n. </blockquote><p>  Si lo es.  ¬øY qu√©? </p><br><blockquote>  Veamos la llamada de funci√≥n para el √°rea.  El c√≥digo de llamada depende de la funci√≥n para el √°rea, y la funci√≥n para el √°rea depende de cada implementaci√≥n espec√≠fica. </blockquote><p>  ¬øY a qu√© te refieres cuando dices "depende"? </p><br><blockquote>  Imagine que cada implementaci√≥n de una funci√≥n para un √°rea se asigna a una funci√≥n separada.  Es decir, habr√° funciones circleArea, squareArea y triangleArea. </blockquote><p>  Bueno, resulta que en las ramas del conmutador simplemente habr√° llamadas a estas funciones. </p><br><blockquote>  Imagine que estas funciones est√°n en diferentes archivos. </blockquote><p>  Luego, en el archivo con el interruptor se importar√° o usar√° o incluir√° para archivos con funciones. </p><br><blockquote>  Derecho  Esta es una dependencia en el nivel del c√≥digo fuente.  Una fuente depende de otra fuente.  ¬øC√≥mo se dirige esta dependencia? </blockquote><p>  El c√≥digo fuente con el interruptor depende del c√≥digo fuente en el que se encuentran las implementaciones. </p><br><blockquote>  ¬øQu√© pasa con el c√≥digo que llama a la funci√≥n para el √°rea? </blockquote><p>  El c√≥digo de llamada depende del c√≥digo con el interruptor, que depende de todas las implementaciones. </p><br><blockquote>  Derecho  En todas las fuentes, la flecha se dirige en la direcci√≥n de la llamada, desde el c√≥digo de llamada hasta la implementaci√≥n.  Entonces, si desea hacer un peque√±o cambio en estas implementaciones ... </blockquote><p>  Vale, vale, ya veo a qu√© te refieres.  Un cambio en cualquiera de las implementaciones implicar√° la recompilaci√≥n de todos los archivos con el interruptor, y esto conducir√° al hecho de que todo lo que llame a este interruptor se recompilar√°, por ejemplo, en nuestro caso, la funci√≥n para el √°rea. </p><br><blockquote>  Si  Al menos lo ser√° para los idiomas que usan fechas de modificaci√≥n de archivos para comprender lo que debe reconstruirse. </blockquote><p>  Y estos son generalmente todos los sistemas con tipeo est√°tico, ¬øverdad? </p><br><blockquote>  S√≠, y algunos otros sistemas sin √©l. </blockquote><p>  Esto tiene que ser reconstruido mucho. </p><br><blockquote>  Y mucho para rehacerlo. </blockquote><p>  De acuerdo, pero en el caso de las clases, ¬øes al rev√©s? </p><br><blockquote>  S√≠, porque el c√≥digo que llama a la funci√≥n para el √°rea depende de la interfaz, y la implementaci√≥n tambi√©n depende de esta interfaz. </blockquote><p>  Ya veo  El c√≥digo para la clase Square importar√° o usar√° o incluir√° un archivo con la interfaz Shape. </p><br><blockquote>  Derecho  La flecha en los archivos de implementaci√≥n apunta en la direcci√≥n opuesta a la llamada.  Se dirige desde el c√≥digo de implementaci√≥n al c√≥digo de llamada.  Al menos este ser√° el caso de los idiomas tipados est√°ticamente.  Para los idiomas escritos din√°micamente, el c√≥digo que llama a la funci√≥n para el √°rea no depende en absoluto de nada, porque la vinculaci√≥n ocurre en tiempo de ejecuci√≥n. </blockquote><p>  Si, esta bien.  Es decir, si realiza cambios en una de las implementaciones ... </p><br><blockquote>  Solo es necesario reconstruir y reinstalar el c√≥digo con estos cambios. </blockquote><p>  Esto se debe a que las dependencias se dirigen opuestas a la direcci√≥n de las llamadas. </p><br><blockquote>  S√≠, lo llamamos inversi√≥n de dependencia. </blockquote><p>  Bien, resum√°moslo todo.  Las clases y las estructuras de datos se oponen entre s√≠ en tres sentidos. </p><br><ul><li>  Las funciones est√°n expl√≠citamente en las clases, y solo puede adivinar la existencia de datos.  Las estructuras de datos est√°n presentes expl√≠citamente en las estructuras de datos, y solo puede adivinar qu√© funciones est√°n disponibles. </li><li>  En el caso de las clases, agregar tipos es simple, pero agregar funciones es dif√≠cil.  En el caso de estructuras, agregar funciones es f√°cil, pero agregar tipos es dif√≠cil. </li><li>  Las estructuras de datos conducen a la compilaci√≥n y redistribuci√≥n del c√≥digo de llamada.  Las clases a√≠slan el c√≥digo de llamada y no necesitan volver a compilarlo e implementarlo nuevamente. </li></ul><br><blockquote>  Si, eso es correcto.  Y esto debe ser tenido en cuenta por cada dise√±ador y arquitecto de software. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477712/">https://habr.com/ru/post/477712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477696/index.html">Dominio front-end basado en TLS 1.3. Parte 2</a></li>
<li><a href="../477700/index.html">Principio de Hollywood (IoC)</a></li>
<li><a href="../477704/index.html">CodeSide. Nuevo juego para la famosa competencia rusa de la Copa AI</a></li>
<li><a href="../477706/index.html">Contenido mixto al descargar desde HTTPS: c√≥mo encontrar y superar</a></li>
<li><a href="../477710/index.html">Lo que no ense√±an en la escuela: c√≥mo capacitamos a los ingenieros de soporte t√©cnico</a></li>
<li><a href="../477716/index.html">Los matem√°ticos que usan el ejemplo de "etiqueta" calculan c√≥mo ocurre la aleatoriedad</a></li>
<li><a href="../477718/index.html">Capa convolucional: convoluci√≥n r√°pida seg√∫n el m√©todo de Shmuel Vinograd</a></li>
<li><a href="../477722/index.html">Gu√≠a de estilo de Google en C ++. Parte 8</a></li>
<li><a href="../477724/index.html">Seminario de marca de recursos humanos: sobre talentos, caza y contenido</a></li>
<li><a href="../477728/index.html">Qu√© hacer l√≠der del equipo para que el equipo no se agote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>