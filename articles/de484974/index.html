<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚥 ❣️ 🦑 Wang Fliesen für Turing Machine Simulation 👉🏻 ◀️ 👩🏿‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wang-Kacheln (Dominosteine) wurden 1961 von Hao Wang aus mathematischen Gründen erfunden. Sie wurden jedoch häufig in Spielen zur Erstellung von Kache...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wang Fliesen für Turing Machine Simulation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484974/">  Wang-Kacheln (Dominosteine) wurden 1961 von Hao Wang aus mathematischen Gründen erfunden. Sie wurden jedoch häufig in Spielen zur Erstellung von Kachelgrafiken verwendet.  Dank ihnen sehen die Ergebnisse nicht repetitiv aus, sowohl in 2D-Texturen als auch in 3D-Modellen mit Kacheln. <br><br>  Es scheint, dass Van-Kacheln auch Turing-Maschinen ausführen können, und deshalb sind sie Turing-vollständig, was bedeutet, dass sie jedes Programm ausführen können. <br><br>  Dies ist eine erstaunliche und unverständliche Aussage, daher werde ich in diesem Beitrag dieses Problem ein wenig untersuchen. <br><br><h2>  Kurz über Van Tiles </h2><br>  Van-Kacheln sind rechteckige Kacheln, bei denen jede der Flächen nur anderen spezifischen Flächen entsprechen kann. Für jede bestimmte Fläche gibt es jedoch mehrere mögliche Kacheln, die dieser Fläche entsprechen können.  Mit übereinstimmenden Flächen meine ich, dass sie sich nahtlos verbinden, ohne dass visuelle Artefakte oder Anzeichen einer Naht zwischen den Fliesen entstehen. <br><br>  Diese Eigenschaft ist nützlich für Grafiken, da Sie damit nahtlose Kachelgrafiken erstellen können. Die Konfiguration der Position der Kacheln kann jedoch vollständig nach dem Zufallsprinzip erfolgen, sofern alle Flächen miteinander kompatibel sind.  Das Ergebnis sind Kachelgrafiken, die sich keineswegs wiederholen, da visuelle Muster weniger auffallen als herkömmliche Kachelgrafiken. <br><br>  Grafische Beispiele, detailliertere Informationen und Links zu Shadertoy finden Sie hier: <a href="https://blog.demofox.org/2014/08/13/wang-tiling/">Wang Tiling</a> . <br><br>  Hier ist ein Beispiel, das ich erstellt habe.  Meine Grafiken sind "Kunstprogrammierer", aber ich hoffe, die Idee ist klar.  Die Zeichnung besteht aus 16 Kacheln und für jede Fläche gibt es zwei verschiedene Arten von Flächen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1dd/f35/586/1ddf35586684620140e0d28b0118dce1.png"></div><a name="habracut"></a><br><h2>  Kurz über Turingmaschinen </h2><br>  Turing-Maschinen wurden 1936 von Alan Turing als generalisierter Computer erfunden, für den nachgewiesen wurde, dass er jeden Algorithmus ausführen kann. <br><br>  Die Turing-Maschine besteht aus mehreren Hauptkomponenten: Speicherbändern, Lese- / Schreibköpfen und Zustandsautomaten. <br><br>  Das Speicherband hat eine unendliche Länge, dh es hat eine unendliche Speicherkapazität, und am Anfang wird es nur mit Nullen initialisiert. <br><br>  Der Lese- / Schreibkopf beginnt an einer bestimmten Position des Bandes und kann Werte lesen / schreiben sowie sich entlang des Bandes nach links und rechts bewegen. <br><br>  Die Zustandsmaschine steuert den Lese- / Schreibkopf. <br><br>  Die Zustandsmaschine weiß, in welchem ​​Zustand sie sich befindet, und hat Regeln, was in jedem Zustand zu tun ist, wenn sie einen Wert vom Band liest. <br><br>  Wenn beispielsweise in Zustand A 0 vom Band gelesen wird, kann die Regel lauten, 1 an die aktuelle Position des Bandes zu schreiben, den Lese- / Schreibkopf nach rechts zu bewegen oder in Zustand B überzugehen. Zustand B kann eine völlig andere Logik haben und entweder den Übergang durchführen zurück zu Zustand A oder in Zustand B bleiben oder in einen völlig anderen Zustand wechseln. <br><br>  Unter Verwendung einer derart einfachen Logik des Übergangs zwischen Zuständen kann ein beliebiger Computeralgorithmus ausgeführt werden. <br><br>  Die Turing-Maschine kann auch einen "Halt-Status" haben, was bedeutet, dass das Programm die Ausführung abgeschlossen hat und die Antwort berechnet wurde. <br><br>  Auf der Suche nach einigen Programmen.  kann leicht gesehen werden.  dass sie im Laufe der Zeit enden oder sich in einer Endlosschleife befinden und niemals aufhören werden.  Einige Programme befinden sich zwischen ihnen, sie sind komplex und es ist nicht so einfach festzustellen, ob sie jemals aufhören werden.  Turing hat bewiesen, dass es keine allgemeine Lösung gibt, um festzustellen, ob die Turing-Maschine anhält (es ist ein Computerprogramm), und dies wird als <a href="https://en.wikipedia.org/wiki/Halting_problem">Stopp-Problem bezeichnet</a> .  Im Allgemeinen ist der einzige Weg, um herauszufinden, ob ein Programm stoppt, zu warten.  Das heißt, im Allgemeinen lauten die Antworten auf diese Frage entweder "Ja" oder "Noch nicht". Bei vielen spezifischen Programmen können Sie jedoch feststellen, dass sie nach dem Start mit der Zeit enden werden. <br><br><h2>  Wang Fliesenberechnungen </h2><br>  Es stellt sich heraus, dass Wang-Kacheln eine Turing-Maschine simulieren können, das heißt, sie sind Turing-vollständig, was bedeutet, dass sie jeden Computeralgorithmus ausführen können. <br><br>  Um dies zu realisieren, benötigen wir eine Spalte mit Van-Kacheln, die den Zustand der Turing-Maschine zu einem bestimmten Zeitpunkt anzeigt, beginnend zum Zeitpunkt 0 in der äußersten linken Spalte.  Wir werden Kacheln in die rechte Spalte mit allen Regeln der Flächen einfügen und dann rechts davon eine Spalte erstellen usw., bis das Programm beendet wird (oder wir werden dies für immer tun, wenn es nicht endet).  Wenn Sie den richtigen Kachelsatz auswählen, reicht es aus, beim Anordnen der Kacheln zu prüfen, ob die Regeln der Flächen eingehalten werden, um die Turing-Maschine fertigzustellen. <br><br>  Schauen wir uns ein einfaches Beispiel an, das die folgenden Regeln für die Zustandsautomatenlogik enthält: <br><br><ol><li>  Wenn sich die Maschine im Zustand A befindet, schreiben wir beim Lesen von 0 1, bewegen den Lese- / Schreibkopf nach unten und gehen in den Zustand B. </li><li>  Befindet sich die Maschine im Zustand A, stoppt das Programm beim Lesen von 1 (wechselt in den Endzustand). </li><li>  Wenn sich die Maschine im Zustand B befindet, schreiben wir beim Lesen von 0 1, bewegen den Schreib- / Lesekopf nach oben und gehen in den Zustand A. </li><li>  Wenn sich die Maschine im Zustand B befindet, stoppt das Programm beim Lesen von 1 (geht in den Endzustand über). </li></ol><br><h3>  Bandlaufwerk </h3><br>  Zunächst benötigen wir einen dauerhaften Speicher für das Band.  Dazu benötigen wir die folgenden zwei Kacheln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/125/5dc/d811255dc542e1d46ff70e7dbeb94123.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br>  Um ihre Arbeit zu testen, können wir ein Segment des Bandes mit einigen Werten vorbereiten (eine Spalte mit Van-Kacheln erstellen) und sicherstellen, dass die einzigen geeigneten Van-Kacheln, die sich neben der ersten Spalte befinden, Kacheln sind, die die Werte 0 und 1 zeitlich vorwärts übertragen, ohne sie zu ändern sie. <br><br>  In der folgenden Abbildung wird das Band mit dem Wert 0101 in der Spalte ganz links (Zeitpunkt 0) initialisiert.  Wenn wir nur Kacheln mit kompatiblen Flächen haben, sehen wir, dass die Werte im Speicher für immer gespeichert sind.  Wir haben ein Speicherlaufwerk implementiert! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/773/2b8/cff/7732b8cffe9ffaf7b33320070373485d.png"></div><br>  Wir werden beginnen, unser Beispiel mit einem auf 0 initialisierten Speicher zu demonstrieren, und die obige Abbildung zeigt einfach die Persistenz des Speichers. <br><br><h3>  Schreib- / Lesekopf-Zustandsmaschine </h3><br>  Der Schreib- / Lesekopf einer Turingmaschine wird als Teil der Gesichtsinformation dargestellt.  Wenn sich der Lese- / Schreibkopf in dem Gesicht befindet, das 0 oder 1 speichert, speichert er somit auch den Zustand der Zustandsmaschine. <br><br>  In unserem Beispiel werden zwei Zustände verwendet (ohne den Endzustand): A und B. Wenn 1 gelesen wird, endet das Programm in einem der Zustände (A oder B). <br><br>  Dazu benötigen wir folgende Kacheln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/4a3/988/7d94a39887d1a95352c0205ff9f530eb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4d/31b/a7a/a4d31ba7a6b49c895390e7caeda59479.png"></div><br>  Da wir nun die Regeln für den Übergang in den Endzustand haben (Regeln 2 und 4), müssen wir verstehen, wie die Regeln implementiert werden, die das Umschalten von einem Zustand in einen anderen steuern (Regeln 1 und 3). <br><br><h3>  Schreib- / Lesekopf bewegen </h3><br>  Regel 1 besagt, dass wir, wenn wir uns in Zustand A befinden und 0 lesen, 1 schreiben müssen, den Lese- / Schreibkopf nach unten bewegen und in Zustand B gehen müssen. <br><br>  Wir brauchen diese Kachel, um 0 in Zustand A zu lesen, 1 als Ausgabe zu schreiben und der Kachel unten zu befehlen, in Zustand B überzugehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/85d/f54/3a385df54323ebee4f460b42899498a9.png"></div><br>  Die Kachel unter der aktuellen Kachel kann den Wert 0 oder 1 haben.  Ohne einen bestimmten Wert zu kennen, müssen wir ihn speichern, aber den Schreib- / Lesekopf akzeptieren und im Status B sein. Dazu benötigen wir zwei Kacheln - eine für 0 auf dem Band in dieser Position, die andere für 1 auf dem Band. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/18c/7f8/97318c7f8e44bf70cb6537da8c2bbd9e.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8e/ab0/772/f8eab0772ad7827b994646a275b9f23b.png"></div><br>  Regel 3 besagt, dass wir, wenn wir uns in Zustand B befinden und 0 lesen, 1 schreiben müssen, den Schreib- / Lesekopf nach oben bewegen und in Zustand A gehen müssen. <br><br>  Dazu benötigen wir eine Konstruktion, die der Konstruktion für Regel 1 ähnelt, aber wir bewegen uns nicht nach unten, sondern nach oben.  Die folgenden drei Kacheln ergeben das gewünschte Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1a/d68/bd0/c1ad68bd057f7b7fa0bb228d158bb36b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/e96/0da/a6fe960da1b315bda9d7461c7f2f4e6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br><h2>  Anfängliche Spaltenkacheln </h2><br>  Wir werden die Grenzen des Simulationsbereichs so wahrnehmen, als hätten sie eine x-Seite. <br><br>  Dies bedeutet, dass wir zum Erstellen der anfänglichen Spalte (Turing-Maschine zum Zeitpunkt 0) zwei spezielle Kacheln benötigen.  Eine Kachel wird benötigt, um den Wert 0 auf dem Band zu speichern, das das Band initialisiert, und eine andere Kachel, um die Position des Lese- / Schreibkopfs in Zustand A zu speichern, der unser Anfangszustand ist. <br><br>  Diese beiden Kacheln sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d34/969/edbd349698db9c4871c63fc44298fefe.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/6df/449/1996df4494d4b8ea4854ea1b3d2f9036.png"></div><br><h2>  Fertigset Fliesen </h2><br>  Hier ist der komplette Satz von 12 Kacheln, die wir verwenden werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/d56/8c1/853d568c1a623fe7c1fc123dff3dd671.png"></div><br><h2>  Volle Simulation </h2><br>  Hier ist das Originaldesign unserer Turing-Maschine zum Zeitpunkt 0. Beachten Sie, dass dies einer der möglichen Anfangszustände ist, aber dies ist der von uns gewählte Zustand.  Wir lassen keine Chance, zu entscheiden, wo der Lese- / Schreibkopf beginnt, und auch seine Anwesenheit.  Wenn wir nur die Regeln der Gesichter befolgen, können wir 4 oder 0 Schreib- / Leseköpfe oder eine beliebige Zahl zwischen ihnen erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/5b8/e7a/33e5b8e7a21b1c52a54b28324f50665d.png"></div><br>  Um die zweite Spalte zu erstellen, beginnen wir von oben nach unten und wählen eine Kachel aus, die den Einschränkungen der Fläche entspricht, die sie berührt.  In diesem ersten Schritt liest der Kopf 0, schreibt 1, bewegt sich nach unten und geht in den Zustand B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/551/9b1/4c65519b125288868d742b3f362e7380.png"></div><br>  Hier ist der zweite Schritt, in dem der Kopf 0 liest, 1 schreibt, nach oben geht und in den Zustand A übergeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/5bd/1e0/3e25bd1e0afad891f739c61a500dbf4c.png"></div><br>  Hier ist der letzte Schritt, in dem der Kopf 1 liest und in den Endzustand übergeht, um anzuzeigen, dass das Programm abgeschlossen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/25d/6bb/bb825d6bb75417f9863376d7f23524df.png"></div><br>  Das Programm wurde beendet und ergab einen Ausgabewert von 0110 oder 6. Diese Ausgabewerte sind nicht besonders signifikant, aber andere Programme können eine signifikante Ausgabe erzeugen.  Zum Beispiel können wir eine Turing-Maschine zwingen, zwei Zahlen hinzuzufügen, und die Ausgabe ist die Summe dieser beiden Zahlen. <br><br><h2>  Wichtiges Detail </h2><br>  Hier müssen wir ein wichtiges Detail erwähnen, das wir oben nicht berücksichtigt haben und das in den meisten Erklärungen von Turing-Maschinen auf Van-Fliesen nicht erwähnt wird. <br><br>  Wenn Sie das zweite Plättchen für Zeit 2 platzieren, besteht die einzige Einschränkung für die Seiten darin, dass das Plättchen x oben und 1 links haben muss.  In der Tat wird die Situation dadurch mehrdeutig, da nicht klar ist, welches der beiden unten gezeigten Kacheln ausgewählt werden soll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br>  Wie wählen wir dann die richtige aus? <br><br>  Die Antwort ist, dass wir nur eine Annahme treffen und eine davon auswählen.  Wenn in diesem Fall das falsche Plättchen ausgewählt ist, suchen wir nach einem Plättchen mit dem X oben und dem B0 links, wenn wir zum nächsten Plättchen übergehen.  Ein solches Plättchen gibt es nicht, daher können wir das Plättchen nicht legen.  In diesem Fall müssen wir zur letzten Kachel zurückkehren und eine der anderen Optionen ausprobieren. <br><br>  Das heißt, wenn Turing-Maschinen mit Wang-Kacheln simuliert werden, gibt es leider buchstäblich einen Versuch und Irrtum-Prozess, aber zumindest ist er überschaubar.  Es erschwert die Berechnungen im Pixel-Shader (oder in anderen Geräten mit hoher Parallelität) ein wenig, aber die Kosten sind nicht viel höher. <br><br><h2>  Schlussfolgerung und Links </h2><br>  Einige der folgenden Links behandeln Wang-Kacheln und Turing-Maschinen, aber die Diskussionen scheinen sich nicht strikt an Turing-Maschinen zu halten.  Beispielsweise können Sie feststellen, dass in einigen Beispielen Daten "zurück in die Zeit" zurückkehren dürfen. Wenn das Programm beendet wird, erfolgt die Antwort auf Band zum Zeitpunkt 0 der Turing-Maschine, obwohl diese Daten zum Zeitpunkt 0 nicht vorhanden waren. Dies zeigt, dass Wang-Kacheln die Berechnungen selbst durchführen können und nicht nur Turing-Maschinen simulieren, aber ich weiß nicht genau, wie diese Technik heißen wird. <br><br>  Wenn Sie außerdem wissen möchten, was beim Rechnen mit Wang-Kacheln nützlich ist, kann ich mir Fälle von deren praktischer Anwendung nicht vorstellen.  Wissenschaftler scheinen jedoch entdeckt zu haben, dass DNA in etwa wie Van-Kacheln wirken kann, da Verbindungen nur zwischen kompatiblen Gesichtern hergestellt werden.  Dank dessen werden nun DNA-basierte Berechnungen erforscht, die auf dem Prozess des Rechnens mit Wang-Kacheln basieren.  Ziemlich interessantes Thema! <br><br>  Hier ist die Implementierung der Berechnung von Primzahlen mit Wang-Kacheln in Shadertoy im WebGL-Pixel-Shader: <br><br>  <a href="https://www.shadertoy.com/view/4sV3zK">Shadertoy: WangTiles: PrimeGenerator</a> <br><br>  Hier sind einige weitere großartige Videos über Turing-Autos und das Problem des Anhaltens: <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DdNRDvLACg5Q">Erklärte Turing-Maschinen - Computerphile</a> <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DmacM_MtS_w4">Turing &amp; The Halting Problem - Computerphile</a> <br><br>  Und hier noch ein paar Links: <br><br>  <a href="https://moyix.wordpress.com/2012/04/06/computing-with-tiles/">Rechnen mit Kacheln</a> <br><br>  <a href="https://en.wikipedia.org/wiki/Wang_tile">Wikipedia: Van Fliesen</a> <br><br>  <a href="http://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/">Wang Fliesen und Turingmaschinen</a> <br><br>  <a href="https://because0fbeauty.wordpress.com/2014/02/28/wang-tiles-1/">Wang Fliesen - 1</a> <br><br>  Hier sind einige wissenschaftliche Artikel: <br><br>  <a href="http://www.math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings1989/2_Michie89.pdf">Rechnen mit Kacheln</a> <br><br>  <a href="http://link.springer.com/chapter/10.1007%252F978-0-387-09680-3_13">Berechenbarkeit von Fliesen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484974/">https://habr.com/ru/post/de484974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484954/index.html">Visuelle Fehlerbehebung für Kubernetes</a></li>
<li><a href="../de484964/index.html">Konfigurieren des Lastenausgleichs in InfoWatch Traffic Monitor</a></li>
<li><a href="../de484966/index.html">Vorgefertigte Vorlage zum Testen mit Spring</a></li>
<li><a href="../de484968/index.html">WPF DataGrid. Kampf um Vorlage</a></li>
<li><a href="../de484972/index.html">Wine 5.0 veröffentlicht</a></li>
<li><a href="../de484978/index.html">PubSub ist fast kostenlos: NOTIFY-Funktionen in PostgreSQL</a></li>
<li><a href="../de484982/index.html">Ist es einfach, Ihr Geschäft für einen IT-Spezialisten zu organisieren?</a></li>
<li><a href="../de484984/index.html">Unity-Spieleentwickler. Neuer Kurs von OTUS</a></li>
<li><a href="../de484990/index.html">Luxoft TechTalks - Video-Podcasts von globalen IT-Gurus und mehr</a></li>
<li><a href="../de484992/index.html">Schöner in großen Projekten: Verbringen Sie 20 Minuten mit dem Einrichten, vergessen Sie die Formatierung für immer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>