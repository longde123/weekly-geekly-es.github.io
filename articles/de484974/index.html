<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö• ‚ù£Ô∏è ü¶ë Wang Fliesen f√ºr Turing Machine Simulation üëâüèª ‚óÄÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wang-Kacheln (Dominosteine) wurden 1961 von Hao Wang aus mathematischen Gr√ºnden erfunden. Sie wurden jedoch h√§ufig in Spielen zur Erstellung von Kache...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wang Fliesen f√ºr Turing Machine Simulation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484974/">  Wang-Kacheln (Dominosteine) wurden 1961 von Hao Wang aus mathematischen Gr√ºnden erfunden. Sie wurden jedoch h√§ufig in Spielen zur Erstellung von Kachelgrafiken verwendet.  Dank ihnen sehen die Ergebnisse nicht repetitiv aus, sowohl in 2D-Texturen als auch in 3D-Modellen mit Kacheln. <br><br>  Es scheint, dass Van-Kacheln auch Turing-Maschinen ausf√ºhren k√∂nnen, und deshalb sind sie Turing-vollst√§ndig, was bedeutet, dass sie jedes Programm ausf√ºhren k√∂nnen. <br><br>  Dies ist eine erstaunliche und unverst√§ndliche Aussage, daher werde ich in diesem Beitrag dieses Problem ein wenig untersuchen. <br><br><h2>  Kurz √ºber Van Tiles </h2><br>  Van-Kacheln sind rechteckige Kacheln, bei denen jede der Fl√§chen nur anderen spezifischen Fl√§chen entsprechen kann. F√ºr jede bestimmte Fl√§che gibt es jedoch mehrere m√∂gliche Kacheln, die dieser Fl√§che entsprechen k√∂nnen.  Mit √ºbereinstimmenden Fl√§chen meine ich, dass sie sich nahtlos verbinden, ohne dass visuelle Artefakte oder Anzeichen einer Naht zwischen den Fliesen entstehen. <br><br>  Diese Eigenschaft ist n√ºtzlich f√ºr Grafiken, da Sie damit nahtlose Kachelgrafiken erstellen k√∂nnen. Die Konfiguration der Position der Kacheln kann jedoch vollst√§ndig nach dem Zufallsprinzip erfolgen, sofern alle Fl√§chen miteinander kompatibel sind.  Das Ergebnis sind Kachelgrafiken, die sich keineswegs wiederholen, da visuelle Muster weniger auffallen als herk√∂mmliche Kachelgrafiken. <br><br>  Grafische Beispiele, detailliertere Informationen und Links zu Shadertoy finden Sie hier: <a href="https://blog.demofox.org/2014/08/13/wang-tiling/">Wang Tiling</a> . <br><br>  Hier ist ein Beispiel, das ich erstellt habe.  Meine Grafiken sind "Kunstprogrammierer", aber ich hoffe, die Idee ist klar.  Die Zeichnung besteht aus 16 Kacheln und f√ºr jede Fl√§che gibt es zwei verschiedene Arten von Fl√§chen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1dd/f35/586/1ddf35586684620140e0d28b0118dce1.png"></div><a name="habracut"></a><br><h2>  Kurz √ºber Turingmaschinen </h2><br>  Turing-Maschinen wurden 1936 von Alan Turing als generalisierter Computer erfunden, f√ºr den nachgewiesen wurde, dass er jeden Algorithmus ausf√ºhren kann. <br><br>  Die Turing-Maschine besteht aus mehreren Hauptkomponenten: Speicherb√§ndern, Lese- / Schreibk√∂pfen und Zustandsautomaten. <br><br>  Das Speicherband hat eine unendliche L√§nge, dh es hat eine unendliche Speicherkapazit√§t, und am Anfang wird es nur mit Nullen initialisiert. <br><br>  Der Lese- / Schreibkopf beginnt an einer bestimmten Position des Bandes und kann Werte lesen / schreiben sowie sich entlang des Bandes nach links und rechts bewegen. <br><br>  Die Zustandsmaschine steuert den Lese- / Schreibkopf. <br><br>  Die Zustandsmaschine wei√ü, in welchem ‚Äã‚ÄãZustand sie sich befindet, und hat Regeln, was in jedem Zustand zu tun ist, wenn sie einen Wert vom Band liest. <br><br>  Wenn beispielsweise in Zustand A 0 vom Band gelesen wird, kann die Regel lauten, 1 an die aktuelle Position des Bandes zu schreiben, den Lese- / Schreibkopf nach rechts zu bewegen oder in Zustand B √ºberzugehen. Zustand B kann eine v√∂llig andere Logik haben und entweder den √úbergang durchf√ºhren zur√ºck zu Zustand A oder in Zustand B bleiben oder in einen v√∂llig anderen Zustand wechseln. <br><br>  Unter Verwendung einer derart einfachen Logik des √úbergangs zwischen Zust√§nden kann ein beliebiger Computeralgorithmus ausgef√ºhrt werden. <br><br>  Die Turing-Maschine kann auch einen "Halt-Status" haben, was bedeutet, dass das Programm die Ausf√ºhrung abgeschlossen hat und die Antwort berechnet wurde. <br><br>  Auf der Suche nach einigen Programmen.  kann leicht gesehen werden.  dass sie im Laufe der Zeit enden oder sich in einer Endlosschleife befinden und niemals aufh√∂ren werden.  Einige Programme befinden sich zwischen ihnen, sie sind komplex und es ist nicht so einfach festzustellen, ob sie jemals aufh√∂ren werden.  Turing hat bewiesen, dass es keine allgemeine L√∂sung gibt, um festzustellen, ob die Turing-Maschine anh√§lt (es ist ein Computerprogramm), und dies wird als <a href="https://en.wikipedia.org/wiki/Halting_problem">Stopp-Problem bezeichnet</a> .  Im Allgemeinen ist der einzige Weg, um herauszufinden, ob ein Programm stoppt, zu warten.  Das hei√üt, im Allgemeinen lauten die Antworten auf diese Frage entweder "Ja" oder "Noch nicht". Bei vielen spezifischen Programmen k√∂nnen Sie jedoch feststellen, dass sie nach dem Start mit der Zeit enden werden. <br><br><h2>  Wang Fliesenberechnungen </h2><br>  Es stellt sich heraus, dass Wang-Kacheln eine Turing-Maschine simulieren k√∂nnen, das hei√üt, sie sind Turing-vollst√§ndig, was bedeutet, dass sie jeden Computeralgorithmus ausf√ºhren k√∂nnen. <br><br>  Um dies zu realisieren, ben√∂tigen wir eine Spalte mit Van-Kacheln, die den Zustand der Turing-Maschine zu einem bestimmten Zeitpunkt anzeigt, beginnend zum Zeitpunkt 0 in der √§u√üersten linken Spalte.  Wir werden Kacheln in die rechte Spalte mit allen Regeln der Fl√§chen einf√ºgen und dann rechts davon eine Spalte erstellen usw., bis das Programm beendet wird (oder wir werden dies f√ºr immer tun, wenn es nicht endet).  Wenn Sie den richtigen Kachelsatz ausw√§hlen, reicht es aus, beim Anordnen der Kacheln zu pr√ºfen, ob die Regeln der Fl√§chen eingehalten werden, um die Turing-Maschine fertigzustellen. <br><br>  Schauen wir uns ein einfaches Beispiel an, das die folgenden Regeln f√ºr die Zustandsautomatenlogik enth√§lt: <br><br><ol><li>  Wenn sich die Maschine im Zustand A befindet, schreiben wir beim Lesen von 0 1, bewegen den Lese- / Schreibkopf nach unten und gehen in den Zustand B. </li><li>  Befindet sich die Maschine im Zustand A, stoppt das Programm beim Lesen von 1 (wechselt in den Endzustand). </li><li>  Wenn sich die Maschine im Zustand B befindet, schreiben wir beim Lesen von 0 1, bewegen den Schreib- / Lesekopf nach oben und gehen in den Zustand A. </li><li>  Wenn sich die Maschine im Zustand B befindet, stoppt das Programm beim Lesen von 1 (geht in den Endzustand √ºber). </li></ol><br><h3>  Bandlaufwerk </h3><br>  Zun√§chst ben√∂tigen wir einen dauerhaften Speicher f√ºr das Band.  Dazu ben√∂tigen wir die folgenden zwei Kacheln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/125/5dc/d811255dc542e1d46ff70e7dbeb94123.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br>  Um ihre Arbeit zu testen, k√∂nnen wir ein Segment des Bandes mit einigen Werten vorbereiten (eine Spalte mit Van-Kacheln erstellen) und sicherstellen, dass die einzigen geeigneten Van-Kacheln, die sich neben der ersten Spalte befinden, Kacheln sind, die die Werte 0 und 1 zeitlich vorw√§rts √ºbertragen, ohne sie zu √§ndern sie. <br><br>  In der folgenden Abbildung wird das Band mit dem Wert 0101 in der Spalte ganz links (Zeitpunkt 0) initialisiert.  Wenn wir nur Kacheln mit kompatiblen Fl√§chen haben, sehen wir, dass die Werte im Speicher f√ºr immer gespeichert sind.  Wir haben ein Speicherlaufwerk implementiert! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/773/2b8/cff/7732b8cffe9ffaf7b33320070373485d.png"></div><br>  Wir werden beginnen, unser Beispiel mit einem auf 0 initialisierten Speicher zu demonstrieren, und die obige Abbildung zeigt einfach die Persistenz des Speichers. <br><br><h3>  Schreib- / Lesekopf-Zustandsmaschine </h3><br>  Der Schreib- / Lesekopf einer Turingmaschine wird als Teil der Gesichtsinformation dargestellt.  Wenn sich der Lese- / Schreibkopf in dem Gesicht befindet, das 0 oder 1 speichert, speichert er somit auch den Zustand der Zustandsmaschine. <br><br>  In unserem Beispiel werden zwei Zust√§nde verwendet (ohne den Endzustand): A und B. Wenn 1 gelesen wird, endet das Programm in einem der Zust√§nde (A oder B). <br><br>  Dazu ben√∂tigen wir folgende Kacheln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/4a3/988/7d94a39887d1a95352c0205ff9f530eb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4d/31b/a7a/a4d31ba7a6b49c895390e7caeda59479.png"></div><br>  Da wir nun die Regeln f√ºr den √úbergang in den Endzustand haben (Regeln 2 und 4), m√ºssen wir verstehen, wie die Regeln implementiert werden, die das Umschalten von einem Zustand in einen anderen steuern (Regeln 1 und 3). <br><br><h3>  Schreib- / Lesekopf bewegen </h3><br>  Regel 1 besagt, dass wir, wenn wir uns in Zustand A befinden und 0 lesen, 1 schreiben m√ºssen, den Lese- / Schreibkopf nach unten bewegen und in Zustand B gehen m√ºssen. <br><br>  Wir brauchen diese Kachel, um 0 in Zustand A zu lesen, 1 als Ausgabe zu schreiben und der Kachel unten zu befehlen, in Zustand B √ºberzugehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/85d/f54/3a385df54323ebee4f460b42899498a9.png"></div><br>  Die Kachel unter der aktuellen Kachel kann den Wert 0 oder 1 haben.  Ohne einen bestimmten Wert zu kennen, m√ºssen wir ihn speichern, aber den Schreib- / Lesekopf akzeptieren und im Status B sein. Dazu ben√∂tigen wir zwei Kacheln - eine f√ºr 0 auf dem Band in dieser Position, die andere f√ºr 1 auf dem Band. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/18c/7f8/97318c7f8e44bf70cb6537da8c2bbd9e.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8e/ab0/772/f8eab0772ad7827b994646a275b9f23b.png"></div><br>  Regel 3 besagt, dass wir, wenn wir uns in Zustand B befinden und 0 lesen, 1 schreiben m√ºssen, den Schreib- / Lesekopf nach oben bewegen und in Zustand A gehen m√ºssen. <br><br>  Dazu ben√∂tigen wir eine Konstruktion, die der Konstruktion f√ºr Regel 1 √§hnelt, aber wir bewegen uns nicht nach unten, sondern nach oben.  Die folgenden drei Kacheln ergeben das gew√ºnschte Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1a/d68/bd0/c1ad68bd057f7b7fa0bb228d158bb36b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/e96/0da/a6fe960da1b315bda9d7461c7f2f4e6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br><h2>  Anf√§ngliche Spaltenkacheln </h2><br>  Wir werden die Grenzen des Simulationsbereichs so wahrnehmen, als h√§tten sie eine x-Seite. <br><br>  Dies bedeutet, dass wir zum Erstellen der anf√§nglichen Spalte (Turing-Maschine zum Zeitpunkt 0) zwei spezielle Kacheln ben√∂tigen.  Eine Kachel wird ben√∂tigt, um den Wert 0 auf dem Band zu speichern, das das Band initialisiert, und eine andere Kachel, um die Position des Lese- / Schreibkopfs in Zustand A zu speichern, der unser Anfangszustand ist. <br><br>  Diese beiden Kacheln sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d34/969/edbd349698db9c4871c63fc44298fefe.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/6df/449/1996df4494d4b8ea4854ea1b3d2f9036.png"></div><br><h2>  Fertigset Fliesen </h2><br>  Hier ist der komplette Satz von 12 Kacheln, die wir verwenden werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/d56/8c1/853d568c1a623fe7c1fc123dff3dd671.png"></div><br><h2>  Volle Simulation </h2><br>  Hier ist das Originaldesign unserer Turing-Maschine zum Zeitpunkt 0. Beachten Sie, dass dies einer der m√∂glichen Anfangszust√§nde ist, aber dies ist der von uns gew√§hlte Zustand.  Wir lassen keine Chance, zu entscheiden, wo der Lese- / Schreibkopf beginnt, und auch seine Anwesenheit.  Wenn wir nur die Regeln der Gesichter befolgen, k√∂nnen wir 4 oder 0 Schreib- / Lesek√∂pfe oder eine beliebige Zahl zwischen ihnen erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/5b8/e7a/33e5b8e7a21b1c52a54b28324f50665d.png"></div><br>  Um die zweite Spalte zu erstellen, beginnen wir von oben nach unten und w√§hlen eine Kachel aus, die den Einschr√§nkungen der Fl√§che entspricht, die sie ber√ºhrt.  In diesem ersten Schritt liest der Kopf 0, schreibt 1, bewegt sich nach unten und geht in den Zustand B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/551/9b1/4c65519b125288868d742b3f362e7380.png"></div><br>  Hier ist der zweite Schritt, in dem der Kopf 0 liest, 1 schreibt, nach oben geht und in den Zustand A √ºbergeht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/5bd/1e0/3e25bd1e0afad891f739c61a500dbf4c.png"></div><br>  Hier ist der letzte Schritt, in dem der Kopf 1 liest und in den Endzustand √ºbergeht, um anzuzeigen, dass das Programm abgeschlossen ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/25d/6bb/bb825d6bb75417f9863376d7f23524df.png"></div><br>  Das Programm wurde beendet und ergab einen Ausgabewert von 0110 oder 6. Diese Ausgabewerte sind nicht besonders signifikant, aber andere Programme k√∂nnen eine signifikante Ausgabe erzeugen.  Zum Beispiel k√∂nnen wir eine Turing-Maschine zwingen, zwei Zahlen hinzuzuf√ºgen, und die Ausgabe ist die Summe dieser beiden Zahlen. <br><br><h2>  Wichtiges Detail </h2><br>  Hier m√ºssen wir ein wichtiges Detail erw√§hnen, das wir oben nicht ber√ºcksichtigt haben und das in den meisten Erkl√§rungen von Turing-Maschinen auf Van-Fliesen nicht erw√§hnt wird. <br><br>  Wenn Sie das zweite Pl√§ttchen f√ºr Zeit 2 platzieren, besteht die einzige Einschr√§nkung f√ºr die Seiten darin, dass das Pl√§ttchen x oben und 1 links haben muss.  In der Tat wird die Situation dadurch mehrdeutig, da nicht klar ist, welches der beiden unten gezeigten Kacheln ausgew√§hlt werden soll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br>  Wie w√§hlen wir dann die richtige aus? <br><br>  Die Antwort ist, dass wir nur eine Annahme treffen und eine davon ausw√§hlen.  Wenn in diesem Fall das falsche Pl√§ttchen ausgew√§hlt ist, suchen wir nach einem Pl√§ttchen mit dem X oben und dem B0 links, wenn wir zum n√§chsten Pl√§ttchen √ºbergehen.  Ein solches Pl√§ttchen gibt es nicht, daher k√∂nnen wir das Pl√§ttchen nicht legen.  In diesem Fall m√ºssen wir zur letzten Kachel zur√ºckkehren und eine der anderen Optionen ausprobieren. <br><br>  Das hei√üt, wenn Turing-Maschinen mit Wang-Kacheln simuliert werden, gibt es leider buchst√§blich einen Versuch und Irrtum-Prozess, aber zumindest ist er √ºberschaubar.  Es erschwert die Berechnungen im Pixel-Shader (oder in anderen Ger√§ten mit hoher Parallelit√§t) ein wenig, aber die Kosten sind nicht viel h√∂her. <br><br><h2>  Schlussfolgerung und Links </h2><br>  Einige der folgenden Links behandeln Wang-Kacheln und Turing-Maschinen, aber die Diskussionen scheinen sich nicht strikt an Turing-Maschinen zu halten.  Beispielsweise k√∂nnen Sie feststellen, dass in einigen Beispielen Daten "zur√ºck in die Zeit" zur√ºckkehren d√ºrfen. Wenn das Programm beendet wird, erfolgt die Antwort auf Band zum Zeitpunkt 0 der Turing-Maschine, obwohl diese Daten zum Zeitpunkt 0 nicht vorhanden waren. Dies zeigt, dass Wang-Kacheln die Berechnungen selbst durchf√ºhren k√∂nnen und nicht nur Turing-Maschinen simulieren, aber ich wei√ü nicht genau, wie diese Technik hei√üen wird. <br><br>  Wenn Sie au√üerdem wissen m√∂chten, was beim Rechnen mit Wang-Kacheln n√ºtzlich ist, kann ich mir F√§lle von deren praktischer Anwendung nicht vorstellen.  Wissenschaftler scheinen jedoch entdeckt zu haben, dass DNA in etwa wie Van-Kacheln wirken kann, da Verbindungen nur zwischen kompatiblen Gesichtern hergestellt werden.  Dank dessen werden nun DNA-basierte Berechnungen erforscht, die auf dem Prozess des Rechnens mit Wang-Kacheln basieren.  Ziemlich interessantes Thema! <br><br>  Hier ist die Implementierung der Berechnung von Primzahlen mit Wang-Kacheln in Shadertoy im WebGL-Pixel-Shader: <br><br>  <a href="https://www.shadertoy.com/view/4sV3zK">Shadertoy: WangTiles: PrimeGenerator</a> <br><br>  Hier sind einige weitere gro√üartige Videos √ºber Turing-Autos und das Problem des Anhaltens: <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DdNRDvLACg5Q">Erkl√§rte Turing-Maschinen - Computerphile</a> <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DmacM_MtS_w4">Turing &amp; The Halting Problem - Computerphile</a> <br><br>  Und hier noch ein paar Links: <br><br>  <a href="https://moyix.wordpress.com/2012/04/06/computing-with-tiles/">Rechnen mit Kacheln</a> <br><br>  <a href="https://en.wikipedia.org/wiki/Wang_tile">Wikipedia: Van Fliesen</a> <br><br>  <a href="http://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/">Wang Fliesen und Turingmaschinen</a> <br><br>  <a href="https://because0fbeauty.wordpress.com/2014/02/28/wang-tiles-1/">Wang Fliesen - 1</a> <br><br>  Hier sind einige wissenschaftliche Artikel: <br><br>  <a href="http://www.math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings1989/2_Michie89.pdf">Rechnen mit Kacheln</a> <br><br>  <a href="http://link.springer.com/chapter/10.1007%252F978-0-387-09680-3_13">Berechenbarkeit von Fliesen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484974/">https://habr.com/ru/post/de484974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484954/index.html">Visuelle Fehlerbehebung f√ºr Kubernetes</a></li>
<li><a href="../de484964/index.html">Konfigurieren des Lastenausgleichs in InfoWatch Traffic Monitor</a></li>
<li><a href="../de484966/index.html">Vorgefertigte Vorlage zum Testen mit Spring</a></li>
<li><a href="../de484968/index.html">WPF DataGrid. Kampf um Vorlage</a></li>
<li><a href="../de484972/index.html">Wine 5.0 ver√∂ffentlicht</a></li>
<li><a href="../de484978/index.html">PubSub ist fast kostenlos: NOTIFY-Funktionen in PostgreSQL</a></li>
<li><a href="../de484982/index.html">Ist es einfach, Ihr Gesch√§ft f√ºr einen IT-Spezialisten zu organisieren?</a></li>
<li><a href="../de484984/index.html">Unity-Spieleentwickler. Neuer Kurs von OTUS</a></li>
<li><a href="../de484990/index.html">Luxoft TechTalks - Video-Podcasts von globalen IT-Gurus und mehr</a></li>
<li><a href="../de484992/index.html">Sch√∂ner in gro√üen Projekten: Verbringen Sie 20 Minuten mit dem Einrichten, vergessen Sie die Formatierung f√ºr immer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>