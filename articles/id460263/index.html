<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 👩‍💻 ⚜️ Membuat pencarian yang benar-benar cerdas: panduan langkah demi langkah 💓 😂 ❌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cari di sistem informasi perusahaan - sudah dari frasa ini sendiri terjebak di mulut. Baik jika Anda memilikinya, Anda bahkan tidak perlu memikirkan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat pencarian yang benar-benar cerdas: panduan langkah demi langkah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>Cari di sistem informasi perusahaan</em> - sudah dari frasa ini sendiri terjebak di mulut.  Baik jika Anda memilikinya, Anda bahkan tidak perlu memikirkan pengalaman pengguna yang positif.  Bagaimana cara membalikkan sikap pengguna yang dimanjakan oleh mesin pencari dan menciptakan produk yang cepat, akurat, dan dapat dimengerti dengan sempurna?  Kita perlu mengambil bagian yang bagus dari Elasticsearch, beberapa layanan cerdas dan mengaduknya dalam panduan ini. </p><br><p>  Ada banyak artikel tentang cara mempercepat pencarian teks lengkap berdasarkan Elasticsearch ke database yang ada.  Tetapi jelas tidak ada cukup artikel tentang cara melakukan pencarian yang benar-benar cerdas. </p><br><blockquote>  Pada saat yang sama, frasa "Pencarian Cerdas" itu sendiri telah berubah menjadi kata kunci dan digunakan untuk tempat itu dan bukan.  Jadi apa yang harus dilakukan mesin pencari agar dianggap pintar?  Pada akhirnya, ini dapat digambarkan sebagai memberikan hasil yang benar-benar dibutuhkan pengguna, bahkan jika hasil ini tidak cukup cocok dengan teks permintaan.  Mesin pencari populer seperti Google dan Yandex melangkah lebih jauh dan tidak hanya menemukan informasi yang mereka butuhkan, tetapi langsung menjawab pertanyaan pengguna. </blockquote><p>  Oke, kami tidak akan langsung menyapu keputusan ultimatum, tetapi apa yang bisa dilakukan untuk membawa pencarian teks lengkap <em>biasa</em> lebih dekat ke yang <em>cerdas</em> ? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Unsur kecerdasan </h2><br><p>  Pencarian cerdas - ini hanya kasus ketika kuantitas bisa masuk ke kualitas dan banyak fitur kecil dan cukup sederhana dapat membentuk rasa sihir. </p><br><ul><li>  Koreksi kesalahan pengguna - apakah ini salah ketik, tata letak yang salah, atau mungkin permintaan dengan hasil yang sedikit mencurigakan, tetapi mirip dengan permintaan yang memiliki informasi lebih banyak. </li><li>  Untuk <del>  th </del>  Obrolan NLP (pemrosesan bahasa alami, bukan apa yang Anda pikirkan) - jika pengguna memasukkan <em><strong>penawaran komersial untuk tahun lalu</strong></em> , apakah ia benar-benar ingin mencari kata-kata ini dalam teks semua dokumen atau apakah ia benar-benar hanya membutuhkan penawaran komersial dan hanya tahun lalu ? </li><li>  Memprediksi input berdasarkan permintaan sebelumnya atau dokumen populer. </li><li> Presentasi hasil adalah sorotan yang biasa dari fragmen yang ditemukan, informasi tambahan tergantung pada apa yang Anda cari.  Karena proposal komersial diperlukan pada paragraf sebelumnya, mungkin masuk akal untuk segera menunjukkan subjek proposal dan dari mana organisasi itu berasal? </li><li>  Penelusuran yang mudah - kemampuan untuk mempersempit kueri penelusuran menggunakan filter tambahan, aspek. </li></ul><br><h2 id="vvodnaya">  Pendahuluan </h2><br><p>  Ada DIRECTUM ECM dengan banyak dokumen di dalamnya.  Dokumen terdiri dari kartu dengan meta-informasi dan badan, yang dapat memiliki beberapa versi. </p><br><p>  Tujuannya adalah untuk dengan cepat dan mudah mencari informasi dalam dokumen-dokumen ini dengan cara yang biasa untuk pengguna mesin pencari. </p><br><h2 id="indeksirovanie">  Pengindeksan </h2><br><blockquote>  Untuk mencari sesuatu dengan baik, Anda harus mengindeksnya dengan baik terlebih dahulu. </blockquote><p>  Dokumen dalam ECM tidak statis, pengguna memodifikasi teks, membuat versi baru, mengubah data dalam kartu;  dokumen baru terus-menerus dibuat dan yang lama terkadang dihapus. <br>  Untuk menjaga informasi terkini di Elasticsearch, dokumen harus terus-menerus diindeks ulang.  Untungnya, ECM sudah memiliki antrian acara asinkron sendiri, jadi ketika Anda mengubah dokumen, tambahkan saja ke antrian untuk pengindeksan. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Memetakan dokumen ECM ke dokumen Elasticsearch </h3><br><p>  Badan dokumen di ECM dapat memiliki beberapa versi.  Dalam Elasticsearch, ini bisa dianggap sebagai array objek bersarang, tetapi kemudian menjadi tidak nyaman untuk bekerja dengannya - menjadi lebih sulit untuk menulis kueri, ketika mengubah salah satu versi, Anda perlu mengindeks ulang semuanya, versi berbeda dari dokumen yang sama tidak dapat disimpan dalam indeks yang berbeda (mengapa ini diperlukan - di bagian selanjutnya).  Karenanya, kami mendenormalisasi satu dokumen dari ECM menjadi beberapa dokumen Elasticsearch dengan kartu yang sama tetapi dengan badan yang berbeda. </p><br><p>  Selain kartu dan isi, berbagai informasi layanan ditambahkan ke dokumen Elasticsearch, yang layak disebutkan secara terpisah: </p><br><ul><li>  daftar ID grup dan pengguna yang memiliki hak atas dokumen - untuk pencarian dengan hak; </li><li>  jumlah panggilan ke dokumen - untuk mencari relevansi; </li><li>  waktu pengindeksan terakhir. </li></ul><br><h3 id="sostav-indeksov">  Komposisi Indeks </h3><br><p>  Ya, indeks jamak.  Biasanya, beberapa indeks untuk menyimpan informasi yang memiliki arti serupa dalam Elasticsearch hanya digunakan jika informasi ini tidak dapat diubah dan terikat pada beberapa jenis periode waktu, misalnya, log.  Kemudian indeks dibuat setiap bulan / hari atau lebih sering tergantung pada intensitas beban.  Dalam kasus kami, dokumen apa pun dapat diubah, dan dimungkinkan untuk menyimpan semuanya dalam satu indeks. </p><br><p>  Tapi - dokumen dalam sistem bisa dalam bahasa yang berbeda, dan menyimpan data multibahasa di Elasticsearch membawa 2 masalah: </p><br><ul><li>  Batang yang salah.  Untuk beberapa kata, basis akan ditemukan dengan benar, untuk beberapa - salah (akan ada kata lain dalam indeks), untuk beberapa - tidak akan ditemukan sama sekali (indeks akan menjadi tersumbat dengan bentuk kata).  Untuk beberapa kata dari bahasa yang berbeda dan dengan makna yang berbeda, dasarnya akan sama, dan kemudian arti kata tersebut akan hilang.  Penggunaan beberapa stemmer berturut-turut dapat menyebabkan perhitungan tambahan dari basis untuk yang sudah dihitung. </li></ul><br><blockquote>  Stamming - menemukan dasar kata.  Batang tidak harus menjadi akar kata atau bentuk normalnya.  Biasanya sudah cukup untuk kata-kata terkait diproyeksikan ke dalam satu kerangka kerja. <br>  Lemmatization adalah jenis stemming di mana bentuk kata normal (kosa kata) dianggap sebagai dasar. </blockquote><br><ul><li>  Frekuensi kata salah.  Beberapa mekanisme penentuan relevansi dalam ES memperhitungkan frekuensi kata yang dicari dalam dokumen (semakin sering, semakin tinggi relevansi) dan frekuensi kata yang dicari dalam indeks (semakin sering, semakin rendah relevansi).  Jadi, penyebaran kecil pidato Rusia dalam dokumen bahasa Inggris, ketika dokumen-dokumen bahasa Inggris sebagian besar berada dalam indeks, akan memiliki bobot yang tinggi, tetapi ada baiknya mencampur dokumen-dokumen bahasa Inggris dan Rusia dalam indeks, dan bobotnya akan berkurang. </li></ul><br><p>  Masalah pertama dapat dipecahkan untuk kasus ketika bahasa yang berbeda menggunakan set karakter yang berbeda, (dokumen Rusia-Inggris menggunakan huruf Cyrillic dan Latin) - stemmer bahasa hanya akan memproses karakter "mereka". </p><br><p>  Hanya untuk menyelesaikan masalah kedua, kami menggunakan pendekatan dengan indeks terpisah untuk setiap bahasa. </p><br><p>  Menggabungkan kedua pendekatan, kami memperoleh indeks bahasa, yang tetap mengandung analisis untuk beberapa bahasa yang tidak berpotongan dalam set karakter: Rusia-Inggris (dan secara terpisah Inggris-Rusia), Polandia-Rusia, Jerman-Rusia, Ukraina-Inggris, dll. . </p><br><p>  Agar tidak membuat semua kemungkinan indeks sebelumnya, kami menggunakan templat indeks - Elasticsearch memungkinkan Anda menentukan templat yang berisi pengaturan dan pemetaan, dan menentukan pola nama indeks.  Saat Anda mencoba untuk mengindeks dokumen ke dalam indeks yang tidak ada, nama yang cocok dengan salah satu pola template, tidak hanya indeks baru akan dibuat, tetapi juga pengaturan dan pemetaan dari template yang sesuai akan diterapkan padanya. </p><br><h3 id="struktura-indeksov">  Struktur Indeks </h3><br><p>  Untuk pengindeksan, kami menggunakan dua analisis sekaligus (melalui multi-bidang): default untuk pencarian dengan frasa persis dan kustom untuk yang lainnya: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  Dengan filter huruf kecil, semuanya jelas, saya akan menceritakan sisanya. </p><br><p>  Filter russian_morphology dan english_morphology dimaksudkan untuk analisis morfologis teks Rusia dan Inggris, masing-masing.  Mereka bukan bagian dari Elasticsearch dan dimasukkan sebagai bagian dari plugin analisis-morfologi yang terpisah.  Ini adalah lemmatizer yang menggunakan pendekatan kosa kata dalam kombinasi dengan beberapa heuristik dan bekerja secara signifikan, JAUH, lebih baik daripada filter bawaan untuk bahasa yang sesuai. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Dan: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Filter word_delimiter yang sangat aneh.  Ini, misalnya, membantu menghilangkan kesalahan ketik ketika tidak ada ruang setelah titik.  Kami menggunakan konfigurasi berikut: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  yo_filter memungkinkan Anda mengabaikan perbedaan antara E dan E: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  stop type filter ru_en_stopwords - kamus kata-kata berhenti kami. </p><br><h3 id="process-indeksirovaniya">  Proses pengindeksan </h3><br><p>  Badan-badan dokumen di ECM, sebagai aturan, file format kantor: .docx, .pdf, dll.  Untuk mengekstrak teks, plugin ingest-attachment digunakan dengan pipa berikut: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  Dari yang tidak biasa dalam pipa, mengabaikan kesalahan tidak adanya tubuh (ini terjadi untuk dokumen yang dienkripsi) dan menentukan indeks target berdasarkan bahasa teks.  Yang terakhir ini dilakukan dalam naskah tanpa rasa sakit, tubuh yang akan saya berikan secara terpisah, karena  karena pembatasan JSON, harus ditulis dalam satu baris.  Bersama dengan kesulitan debugging (cara yang disarankan adalah melemparkan pengecualian di sana-sini), itu benar-benar berubah menjadi menyakitkan. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Jadi, kami selalu mengirim dokumen ke <em>index_name</em> .  Jika bahasa tidak didefinisikan atau tidak didukung, maka dokumen mengendap dalam indeks ini, jika tidak jatuh ke <em>index_name_language</em> . </p><br><p>  Kami tidak menyimpan tubuh asli file, tetapi bidang _source diaktifkan, karena  diperlukan untuk memperbarui sebagian dokumen dan menyoroti yang ditemukan. </p><br><p>  Jika hanya kartu yang telah berubah sejak indeksasi terakhir, maka kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Pembaruan Menurut Permintaan</a> tanpa pipa untuk memperbaruinya.  Ini memungkinkan, pertama, untuk tidak menyeret badan dokumen yang berpotensi besar dari ECM, dan kedua, secara signifikan mempercepat pembaruan di sisi Elasticsearch - Anda tidak perlu mengekstraksi teks dokumen dari format kantor, yang sangat padat sumber daya. </p><br><blockquote>  Dengan demikian, sama sekali tidak ada pembaruan dokumen di Elasticsearch, secara teknis, ketika memperbarui dari indeks, dokumen lama dikeluarkan, diubah dan sepenuhnya diindeks lagi. </blockquote><p>  Tetapi jika badan berubah, maka dokumen lama umumnya dihapus dan diindeks dari awal.  Ini memungkinkan dokumen untuk <em>berpindah</em> dari satu indeks bahasa ke yang lain. </p><br><h2 id="poisk">  Cari </h2><br><p>  Untuk memudahkan deskripsi, saya akan memberikan tangkapan layar dari hasil akhir </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Teks lengkap </h3><br><p>  Jenis utama kueri yang kami miliki adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertanyaan Kueri String Sederhana</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  di mana <em>.exact</em> adalah bidang yang diindeks oleh parser <em>default</em> .  Pentingnya nama dokumen dua kali lebih tinggi dari bidang lainnya.  Kombinasi <code>"default_operator": "or"</code> dan <code>"minimum_should_match": "-35%"</code> memungkinkan Anda menemukan dokumen yang tidak mengandung hingga 35% dari kata-kata yang dicari. </p><br><h3 id="sinonimy">  Sinonim </h3><br><p>  Secara umum, analisis yang berbeda digunakan untuk pengindeksan dan pencarian, tetapi satu-satunya perbedaan di dalamnya adalah penambahan filter untuk menambahkan sinonim ke permintaan pencarian: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Hak akuntansi </h3><br><p>  Untuk pencarian berbasis hak, kueri utama tertanam di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bool Query</a> , dengan tambahan filter: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  Seperti yang kita ingat dari bagian pengindeksan, indeks memiliki bidang dengan ID pengguna dan grup yang memiliki hak atas dokumen.  Jika ada persimpangan bidang ini dengan array yang diteruskan, maka ada hak. </p><br><h3 id="tyuning-relevantnosti">  Penyesuaian Relevansi </h3><br><p>  Secara default, Elasticsearch mengevaluasi relevansi hasil menggunakan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BM25</a> menggunakan kueri dan teks dokumen.  Kami memutuskan bahwa tiga faktor lagi harus memengaruhi penilaian kepatuhan dengan hasil yang diinginkan dan aktual: </p><br><ul><li>  waktu pengeditan dokumen terakhir - semakin jauh di masa lalu, semakin kecil kemungkinan dokumen ini diperlukan; </li><li>  jumlah panggilan ke dokumen - semakin banyak, semakin besar kemungkinan dokumen ini dibutuhkan; </li><li><p>  Versi tubuh ECM memiliki beberapa kemungkinan status: sedang dikembangkan, operasional, dan tidak digunakan lagi.  Adalah logis bahwa akting lebih penting daripada yang lain. </p><br><p>  Anda dapat mencapai efek ini dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kueri Skor Fungsi</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  Akibatnya, ceteris paribus, kami mendapatkan kira-kira ketergantungan berikut dari pengubah peringkat hasil pada tanggal perubahan terakhir X dan jumlah klik Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  Kecerdasan eksternal </h3><br><p>  Untuk bagian dari fungsi pencarian cerdas, kita perlu mengekstraksi berbagai <em>fakta</em> dari permintaan pencarian: tanggal dengan aplikasi mereka (kreasi, modifikasi, persetujuan, dll.), Nama organisasi, jenis dokumen yang dicari, dll. </p><br><p>  Diminta juga untuk mengklasifikasikan permintaan ke dalam kategori tertentu, misalnya, dokumen menurut organisasi, oleh karyawan, peraturan, dll. </p><br><p>  Dua operasi ini dilakukan oleh Modul Cerdas ECM - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DIRECTUM Ario</a> . </p><br><h3 id="process-umnogo-poiska">  Proses pencarian cerdas </h3><br><p>  Sudah saatnya untuk mempertimbangkan secara lebih rinci mekanisme apa yang diterapkan unsur-unsur intelijen. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Koreksi kesalahan pengguna </h4><br><p>  Ketepatan tata letak ditentukan berdasarkan pada model bahasa trigram - untuk sebuah garis, dihitung seberapa besar kemungkinannya memenuhi urutan tiga karakternya dalam teks dalam bahasa Inggris dan Rusia.  Jika tata letak saat ini dianggap kecil kemungkinannya, maka, pertama, petunjuk dengan tata letak yang benar ditampilkan: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  dan kedua, langkah selanjutnya dari pencarian dilakukan dengan tata letak yang benar: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  Dan jika tidak ada yang dapat ditemukan dengan tata letak yang diperbaiki, maka pencarian dimulai dengan baris asli. </p><br><p>  Koreksi kesalahan ketik diimplementasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phrase Suggester</a> .  Ada masalah dengannya - jika Anda menjalankan kueri pada beberapa indeks secara bersamaan, maka saran mungkin tidak mengembalikan apa pun, sementara jika Anda mengeksekusi hanya pada satu indeks, ada hasilnya.  Ini <em>diperlakukan dengan</em> menetapkan kepercayaan = 0, tetapi kemudian menyarankan menyarankan mengganti kata-kata dengan bentuk normal.  Setuju, akan aneh ketika Anda mencari "huruf <strong>a</strong> " untuk mendapatkan jawaban dalam semangat: <em>Mungkin Anda sedang mencari surat <strong>tentang</strong> ?</em> </p><br><p>  Ini dapat dielakkan dengan menggunakan dua konfirmasi dalam permintaan: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Dari parameter umum yang digunakan </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Jika pendapat pertama mengembalikan hasil, tetapi yang kedua tidak, maka hasil ini adalah string asli itu sendiri, mungkin dengan kata-kata dalam bentuk lain, dan tidak perlu menunjukkan petunjuk.  Jika petunjuk masih diperlukan, frasa pencarian asli menyatu dengan petunjuk.  Ini terjadi dengan mengganti hanya kata-kata yang diperbaiki dan hanya kata-kata yang pemeriksa ejaan (menggunakan Hunspell) anggap salah. </p><br><p>  Jika pencarian pada string sumber menghasilkan 0 hasil, maka itu digantikan oleh string yang diperoleh oleh gabungan dan pencarian dilakukan lagi: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Jika tidak, string prompt yang dihasilkan hanya dikembalikan sebagai prompt untuk pencarian: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Klasifikasi kueri dan ekstraksi fakta </h4><br><p>  Seperti yang saya sebutkan, kami menggunakan DIRECTUM Ario, yaitu layanan klasifikasi teks dan layanan ekstraksi fakta.  Untuk melakukan ini, kami memberikan pertanyaan pencarian anonim kepada analis dan daftar fakta yang kami minati.  Berdasarkan pertanyaan dan pengetahuan tentang dokumen apa yang ada dalam sistem, analis mengidentifikasi beberapa kategori dan melatih layanan klasifikasi untuk menentukan kategori sesuai dengan teks kueri.  Berdasarkan kategori dan daftar fakta yang dihasilkan, kami merumuskan aturan untuk menggunakan fakta-fakta ini.  Misalnya, frasa <em><strong>untuk tahun terakhir</strong></em> dalam kategori <strong>Semua orang</strong> dianggap sebagai tanggal pembuatan dokumen, dan dalam kategori <strong>Menurut organisasi</strong> - tanggal pendaftaran.  Pada saat yang sama, yang <em><strong>dibuat tahun lalu</strong></em> harus dalam kategori apa pun jatuh pada tanggal pembuatan. </p><br><p>  Dari sisi pencarian - mereka membuat konfigurasi di mana mereka mendaftarkan kategori, fakta mana yang diterapkan pada filter facet mana. </p><br><h4 id="avtodopolnenie-vvoda">  Input selesai </h4><br><p>  Selain koreksi tata letak yang telah disebutkan, pencarian sebelumnya dari pengguna dan dokumen publik jatuh ke pelengkapan otomatis. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  Mereka diimplementasikan menggunakan jenis lain Suggester - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Completion Suggester</a> , tetapi masing-masing memiliki nuansa tersendiri. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Pelengkapan Otomatis: Riwayat Pencarian </h5><br><p>  Ada jauh lebih sedikit pengguna di ECM daripada mesin pencari, dan mengalokasikan cukup pertanyaan umum untuk mereka <del>  mengapa jamur lenin </del>  tidak mungkin.  Perlihatkan segala sesuatu secara berturut-turut juga tidak layak karena pertimbangan privasi.  Completion Suggester yang biasa hanya dapat mencari seluruh kumpulan dokumen dalam indeks, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Context Suggester</a> datang untuk menyelamatkan - cara untuk mengatur konteks untuk setiap petunjuk dan memfilter menurut konteks ini.  Jika nama pengguna digunakan sebagai konteks, maka hanya riwayatnya yang dapat ditampilkan kepada semua orang. </p><br><p>  Anda juga perlu memberi pengguna kesempatan untuk menghapus prompt yang membuatnya malu.  Sebagai kunci untuk penghapusan, kami menggunakan teks nama pengguna dan petunjuk.  Sebagai hasilnya, untuk indeks dengan petunjuk, kami mendapatkan pemetaan yang sedikit terduplikasi: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  Bobot untuk setiap petunjuk baru disetel ke petunjuk dan bertambah setiap kali Anda memasukkannya kembali menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Pembaruan Dengan Kueri</a> dengan skrip <code>ctx._source.suggest.weight++</code> sangat sederhana. </p><br><h5 id="avtodopolnenie-dokumenty">  Pelengkapan Otomatis: Dokumen </h5><br><p>  Tetapi mungkin ada banyak dokumen dan kemungkinan kombinasi hak.  Karenanya, di sini, sebaliknya, kami memutuskan untuk tidak melakukan pemfilteran dengan hak saat pelengkapan otomatis, tetapi hanya mengindeks dokumen publik.  Ya, dan Anda tidak perlu menghapus kiat individual dari indeks ini.  Tampaknya implementasi dalam segala hal lebih mudah daripada yang sebelumnya, jika bukan karena dua poin: </p><br><p>  Yang pertama - Completion Suggester hanya mendukung pencarian awalan, dan pelanggan senang menetapkan nomor item untuk semuanya, dan beberapa <code>.01.01   </code> saat Anda mengetik kueri Tidak <code>.01.01   </code> .  Di sini, bersama dengan nama lengkapnya, Anda juga dapat mengindeks n-gram yang diturunkan darinya: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  Ini tidak terlalu kritis dengan cerita, namun pengguna yang sama memasuki kira-kira baris yang sama jika dia mencari sesuatu lagi.  <em>Mungkin</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  Yang kedua - secara default, semua tips sama, tetapi kami ingin membuat beberapa dari mereka lebih sama dan lebih disukai sehingga ini konsisten dengan peringkat hasil pencarian.  Untuk melakukan ini, ulangi secara kasar fungsi gauss dan field_value_factor yang digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kueri Skor Fungsi</a> . </p><br><p>  Ternyata di sini adalah pipa seperti itu: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  dengan skrip berikut: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Mengapa repot-repot dengan saluran pipa tanpa rasa sakit alih-alih menulisnya dalam bahasa yang lebih nyaman?  Karena sekarang, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Reindex</a> , Anda dapat menyalip isi indeks pencarian ke dalam indeks untuk petunjuk (tentu saja dengan menentukan bidang yang diperlukan saja) hanya dalam satu perintah. </p><br><p>  Komposisi dokumen publik yang sangat dibutuhkan tidak sering diperbarui, sehingga perintah ini dapat dibiarkan secara manual. </p><br><h3 id="otobrazhenie-rezultatov">  Menampilkan Hasil </h3><br><h4 id="kategorii">  Kategori </h4><br><p>  Kategori menentukan segi mana yang akan tersedia dan seperti apa potongannya.  Itu dapat dideteksi secara otomatis oleh <em>intelijen eksternal</em> atau dipilih secara manual di atas bilah pencarian. </p><br><h4 id="fasety">  Segi </h4><br><p>  Aspek adalah hal yang sangat intuitif bagi setiap orang yang perilakunya, dijelaskan oleh aturan yang sangat sepele.  Berikut ini beberapa di antaranya: </p><br><ol><li><p>  Nilai facet tergantung pada hasil pencarian, TETAPI dan hasil pencarian tergantung pada aspek yang dipilih.  Bagaimana cara menghindari rekursi? </p><br></li><li><p>  Memilih nilai dalam satu segi tidak memengaruhi nilai-nilai lain dari segi ini, tetapi itu memengaruhi nilai di sisi lain: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  Nilai facet yang dipilih pengguna tidak boleh hilang, bahkan jika pilihan pada facet lain <em>memusnahkannya</em> menjadi 0 atau mereka tidak lagi di atas: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  Dalam elastisitas, aspek diwujudkan melalui mekanisme agregasi, tetapi untuk memenuhi aturan yang dijelaskan, agregasi ini harus diinvestasikan satu sama lain dan disaring oleh satu sama lain. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Pertimbangkan fragmen permintaan yang bertanggung jawab untuk ini: </p><br><div class="spoiler">  <b class="spoiler_title">Kode terlalu besar</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  Apa yang ada di sini itu: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">post_filter</a> memungkinkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> untuk memaksakan kondisi tambahan pada hasil permintaan yang sudah selesai dan tidak mempengaruhi hasil agregasi.  Kesenjangan rekursi yang sama.  Termasuk semua nilai yang dipilih dari semua sisi. </li><li>  agregasi tingkat atas, dalam contoh <em>card.author_value_id</em> dan <em>editor_value_id</em> .  Masing-masing memiliki: <br><ul><li>  memfilter menurut nilai-nilai semua aspek lain, kecuali untuk Anda sendiri; </li><li>  agregasi bersarang untuk nilai facet yang dipilih - <em>perlindungan terhadap pemusnahan</em> ; </li><li>  agregasi bersarang untuk nilai facet lainnya.  Kami menampilkan 10 teratas, dan meminta 11 teratas - untuk menentukan apakah akan menampilkan tombol <strong>Tampilkan semua</strong> . </li></ul></li></ul><br><h4 id="snippety">  Cuplikan </h4><br><p>  Bergantung pada kategori yang dipilih, cuplikan mungkin terlihat berbeda, misalnya, dokumen yang sama saat mencari dalam suatu kategori </p><br><p>  <strong>Semua</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  dan <strong>Karyawan</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Atau ingat, kami ingin melihat subjek dari penawaran komersial dan dari siapa itu datang? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  Agar tidak menyeret seluruh kartu dari elastis (ini memperlambat pencarian), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyaringan sumber digunakan</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  Untuk menyorot kata-kata yang ditemukan dalam teks dokumen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stabilo Fast Vector</a> digunakan - sebagai menghasilkan snippet yang paling tepat untuk teks besar, dan untuk nama - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stabilo terpadu</a> - sebagai yang paling sedikit menuntut sumber daya dan struktur indeks: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  Dalam hal ini, namanya disorot secara keseluruhan, dan dari teks kita mendapatkan hingga 3 fragmen 300 karakter.  Teks yang dikembalikan oleh stabilo Fast Vector lebih lanjut dikompresi oleh algoritma darurat untuk mendapatkan keadaan potongan yang diminimalkan. </p><br><h3 id="kollaps">  Runtuh </h3><br><p>  Secara historis, pengguna ECM ini terbiasa dengan fakta bahwa pencarian mengembalikan <em>dokumen kepada</em> mereka, tetapi pada kenyataannya Elasticsearch mencari di antara <em>versi dokumen</em> .  Mungkin ternyata beberapa versi yang hampir identik akan ditemukan pada permintaan yang sama.  Ini akan mengacaukan hasil dan membingungkan pengguna.  Untungnya, perilaku ini dapat dihindari dengan menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Field Collapsing</a> - beberapa versi agregasi ringan yang sudah bekerja pada hasil akhir (dalam hal ini menyerupai post_filter, <em>dua kruk adalah pasangan</em> ).  <em>Runtuhnya</em> akan menghasilkan objek <em>runtuh</em> yang paling relevan. </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Sayangnya, collapse memiliki sejumlah efek yang tidak menyenangkan, misalnya, berbagai karakteristik numerik dari hasil pencarian terus kembali seolah-olah tidak ada runtuh.  Artinya, jumlah hasil, jumlah nilai facet - semua akan <em>sedikit</em> salah, tetapi pengguna biasanya tidak memperhatikan hal ini, seperti halnya pembaca yang lelah, yang kemungkinan besar belum pernah membaca proposal ini sebelumnya. </p><br><p>  Akhirnya </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460263/">https://habr.com/ru/post/id460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460253/index.html">10 alasan untuk menjadikan keterampilan Anda sebagai asisten suara</a></li>
<li><a href="../id460255/index.html">Backdoor di Node.js: mengapa, mengapa, dan cara kerjanya</a></li>
<li><a href="../id460257/index.html">Halo Dunia! Perendaman dalam di Terminal</a></li>
<li><a href="../id460259/index.html">Apa itu desain UI dan UX? Apa yang umum dan berbeda?</a></li>
<li><a href="../id460261/index.html">Amazon: 25 Tahun Sukses E-commerce</a></li>
<li><a href="../id460265/index.html">Buat template proyek Xcode</a></li>
<li><a href="../id460273/index.html">Otorisasi di Apple Pay untuk yang terkecil</a></li>
<li><a href="../id460275/index.html">Mengapa Anda tidak membutuhkan solusi yang tepat</a></li>
<li><a href="../id460279/index.html">10 milyar kontrak: siapa yang akan berurusan dengan cloud untuk Pentagon</a></li>
<li><a href="../id460281/index.html">Bagaimana UX Writer Membantu Meningkatkan Produk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>