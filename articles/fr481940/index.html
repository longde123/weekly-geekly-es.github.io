<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÄÑÔ∏è üòµ üì∑ Travail rapide et efficace en ligne de commande ü§∞üèø üé≠ üßóüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreux conseils et astuces en ligne de commande sur Internet. La plupart d'entre eux d√©crivent les triviaux comme "apprendre les raccou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travail rapide et efficace en ligne de commande</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p> Il existe de nombreux conseils et astuces en ligne de commande sur Internet.  La plupart d'entre eux d√©crivent les triviaux comme "apprendre les raccourcis clavier" ou " <code>sudo !!</code> ex√©cutera la commande pr√©c√©dente avec sudo".  Au lieu de cela, je vais vous dire quoi faire quand vous avez d√©j√† appris les raccourcis clavier et que vous connaissez <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly">  Le terminal devrait d√©marrer instantan√©ment </h3><br><p>  Combien de temps vous passez √† lancer un terminal?  Et un autre?  Pendant longtemps, j'ai utilis√© le raccourci Ctrl + Alt + T pour lancer un terminal et je pensais que c'√©tait rapide.  Lorsque j'ai migr√© d'Openbox vers i3, j'ai commenc√© √† lancer un terminal via Win + Enter, cette liaison fonctionnait d√®s le d√©part.  Tu sais quoi?  Maintenant, je ne pense pas que Ctrl + Alt + T soit assez rapide. </p><br><p>  Bien s√ªr, la chose n'est pas une acc√©l√©ration en millisecondes, mais que vous ouvrez un terminal au niveau des r√©flexes, compl√®tement inconscient de cela. </p><br><p>  Donc, si vous utilisez souvent un terminal, mais prenez une souris pour le lancer, essayez de configurer un raccourci clavier pratique.  Je suis s√ªr que vous l'aimerez. </p><br><h3 id="zsh-instead-of-bash">  Zsh au lieu de bash </h3><br><p>  C'est un sujet de guerre sacr√©e, je sais.  Vous devez installer Zsh pour au moins trois fonctionnalit√©s: saisie semi-automatique avanc√©e, correction de faute de frappe et ach√®vement de plusieurs noms de chemin: lorsqu'un seul onglet convertit <code>/u/s/d</code> en <code>/usr/share/doc</code> .  Arch Linux a d√©j√† migr√© vers Zsh dans son CD d'installation.  J'esp√®re que Zsh deviendra une fois un shell par d√©faut dans Ubuntu.  Ce sera un moment historique. </p><br><p>  Commencer √† utiliser Zsh n'est pas difficile du tout.  Installez-le simplement via le gestionnaire de paquets et trouvez une jolie configuration.  Je recommande de prendre la configuration utilis√©e dans Arch Linux: </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  La seule chose qui reste est de changer votre shell par d√©faut et de vous reconnecter. </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p>  C'est tout, continuez √† travailler comme si de rien n'√©tait. </p><br><h3 id="how-the-shell-prompt-should-look-like">  A quoi devrait ressembler l'invite du shell </h3><br><p>  L'invite du shell est un petit texte affich√© dans le terminal au d√©but de votre ligne de commande.  Il doit √™tre configur√© pour votre type de travail.  Vous pouvez le percevoir comme le tableau de bord d'un v√©hicule.  S'il vous pla√Æt, mettez-y des informations utiles, laissez-les vous aider √† naviguer!  Rendez-le pratique surtout si vous le voyez tous les jours! </p><br><p>  L'invite du shell doit √™tre color√©e.  Vous n'√™tes pas d'accord?  Essayez de compter le nombre de commandes ex√©cut√©es dans ce terminal: </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p>  Et maintenant avec de la couleur: </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  L'invite du shell doit afficher le r√©pertoire de travail actuel d'un shell.  Si le r√©pertoire de travail actuel n'est pas affich√©, vous devez le garder √† l'esprit et le v√©rifier p√©riodiquement avec la commande <code>pwd</code> .  S'il vous pla√Æt ne faites pas √ßa.  Gardez √† l'esprit certaines choses vraiment importantes et ne perdez pas votre temps pour la commande <code>pwd</code> . </p><br><p>  Si vous passez parfois au compte root, vous avez besoin d'une indication "utilisateur actuel".  Le nom d'utilisateur particulier n'est souvent pas important, mais son statut (normal ou root) l'est.  La solution consiste √† utiliser color: red shell prompt pour root et green pour un utilisateur r√©gulier.  Et vous ne prendrez jamais le contr√¥le du shell racine comme d'habitude. </p><br><p>  Si vous vous connectez √† des serveurs √† l'aide de ssh, vous devez distinguer vos shells locaux et distants.  Pour cela, votre invite shell doit contenir un nom d'h√¥te, ou mieux encore - indiquer une connexion ssh. </p><br><p>  L'invite du shell peut afficher le code de sortie de la derni√®re commande.  N'oubliez pas que le code de sortie z√©ro signifie qu'une commande s'est termin√©e avec succ√®s, non nulle - la commande s'est termin√©e sans succ√®s.  Vous pouvez obtenir le code de sortie de la derni√®re commande via <code>echo $?</code>  , mais taper tout ce qui est sacr√©ment long.  Laissez le shell vous montrer la sortie infructueuse √† la place. </p><br><p>  Si vous travaillez avec des d√©p√¥ts Git, il sera utile de voir l'√©tat du r√©f√©rentiel dans l'invite du shell: la branche actuelle et l'√©tat du r√©pertoire de travail.  Vous gagnerez du temps sur les commandes <code>git status</code> et <code>git branch</code> et ne vous engagez pas sur une mauvaise branche.  Oui, le calcul du statut peut prendre beaucoup de temps dans les d√©p√¥ts de graisses, mais pour moi les avantages l'emportent sur les inconv√©nients. </p><br><p>  Certaines personnes ajoutent une horloge √† l'invite du shell ou m√™me le nom d'un terminal virtuel (tty), ou des gribouillis arbitraires.  Tout cela est superflu.  Il vaut mieux garder beaucoup de place pour les commandes. </p><br><p>  Voil√† √† quoi ressemble mon invite shell dans diff√©rentes conditions: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Vous pouvez voir sur la capture d'√©cran que la barre de titre du terminal fait le m√™me travail.  C'est aussi un morceau de tableau de bord et il devrait √©galement √™tre configur√©. </p><br><p>  Alors, comment tout cela devrait-il √™tre impl√©ment√© dans <code>.zshrc</code> ?  La variable <code>PROMPT</code> d√©finit l'invite de gauche et <code>RPROMPT</code> d√©finit l'invite de droite.  La variable <code>EUID</code> d√©finit le statut d'un utilisateur (normal ou root) et la pr√©sence <code>SSH_CLIENT</code> ou <code>SSH2_CLIENT</code> indique une connexion ssh.  Nous pouvons donc avoir un mod√®le: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  Je ne montre pas le code pr√™t pour le copier-coller car l'impl√©mentation exacte est une question de go√ªt.  Si vous ne voulez pas d√©ranger et que la capture d'√©cran ci-dessus vous convient, prenez mon cofig dans <a href="" rel="nofollow">le Github</a> . </p><br><p>  R√©sum√©: </p><br><ul><li>  L'invite du shell color√© est un must have. </li><li>  Le minimum requis est un r√©pertoire de travail actuel. </li><li>  L'enveloppe de la racine doit √™tre clairement visible. </li><li>  Le nom d'un utilisateur ne se soucie pas d'une charge utile si vous utilisez un seul compte. </li><li>  Le nom d'h√¥te est utile si vous vous connectez aux serveurs via ssh, il n'est pas obligatoire sinon. </li><li>  Il est utile de voir le code de sortie infructueux d'une derni√®re commande. </li><li>  Git repo status permet de gagner du temps sur <code>git status</code> et les commandes de <code>git branch</code> et apporte une infaillibilit√©. </li></ul><br><h3 id="heavily-use-the-command-history">  Utiliser beaucoup l'historique des commandes </h3><br><p>  La plupart des commandes de votre vie que vous saisissez plus d'une fois, il serait donc cool de les retirer de l'historique au lieu de taper √† nouveau.  Tous les shells modernes enregistrent un historique des commandes et offrent plusieurs fa√ßons de rechercher dans cet historique. </p><br><p>  Peut-√™tre √™tes-vous d√©j√† en mesure de creuser l'historique √† l'aide des raccourcis clavier Ctrl + R.  Malheureusement, il pr√©sente deux inconv√©nients: </p><br><ol><li>  La ligne de commande doit √™tre vide pour commencer la recherche, c'est-√†-dire dans le cas o√π "on a commenc√© √† taper une commande - souvenu de la recherche", vous devez d'abord nettoyer votre saisie, puis appuyez sur Ctrl + R et r√©p√©tez votre saisie.  Cela prend trop de temps. </li><li>  La recherche directe ne fonctionne pas par d√©faut car Ctrl + S arr√™te le terminal. </li></ol><br><p>  Le type de recherche le plus rapide et le plus pratique fonctionne de cette fa√ßon: </p><br><ol><li>  Vous commencez √† taper une commande, </li><li>  vous vous souvenez de la recherche, </li><li>  vous appuyez sur un raccourci clavier et le shell vous propose des commandes de l'historique qui ont commenc√© de la m√™me mani√®re. </li></ol><br><p>  Par exemple, vous souhaitez synchroniser un r√©pertoire local avec un r√©pertoire distant √† l'aide de Rsync et vous l'avez d√©j√† fait deux heures plus t√¥t.  Vous tapez <code>rsync</code> , appuyez sur une touche de raccourci une ou deux fois et la commande souhait√©e est pr√™te √† √™tre lanc√©e.  Vous n'avez pas besoin d'activer le mode de recherche d'abord, l'invite du shell ne change pas en <code>(reverse-i-search)':</code> , et rien ne saute nulle part.  Vous faites simplement d√©filer l'historique de la m√™me mani√®re que vous appuyez sur les fl√®ches ‚Üë ‚Üì pour faire d√©filer les commandes entr√©es pr√©c√©demment, mais avec un filtrage suppl√©mentaire.  C'est vraiment cool et √ßa fait gagner beaucoup de temps. </p><br><p>  Ce type de recherche ne fonctionne pas par d√©faut dans Bash et Zsh, vous devez donc l'activer manuellement.  J'ai choisi PgUp pour rechercher en avant et PgDown pour rechercher en arri√®re.  C'est loin de les atteindre, mais j'ai d√©j√† pris l'habitude.  Peut-√™tre que plus tard je passerai √† quelque chose de plus proche comme Ctrl + P et Ctrl + N. </p><br><p>  Pour Bash, vous devez ajouter quelques cha√Ænes √† <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Si vous avez pris un <code>.zshrc</code> complet √† l' <code>.zshrc</code> , il est tr√®s probable que PgUp et PgDown font d√©j√† le travail.  Sinon, ajoutez √† <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Les coquilles de poisson et d'Ipython ont d√©j√† une telle recherche li√©e aux fl√®ches ‚Üë ‚Üì.  Je pense que de nombreux utilisateurs ont migr√© vers Fish uniquement pour le comportement des fl√®ches.  Bien s√ªr, il est possible de lier les fl√®ches de cette fa√ßon dans Bash et Zsh si vous le souhaitez.  Utilisez-le dans <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Et ceci pour <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p>  Il est curieux qu'au fil du temps, j'ai commenc√© √† √©crire des commandes en gardant √† l'esprit que plus tard je les retirerai de l'histoire.  Permettez-moi de vous montrer quelques techniques. </p><br><p>  <strong>Rejoignez les commandes</strong> qui se suivent toujours: </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Les chemins absolus au lieu de relatifs</strong> vous permettent d'ex√©cuter une commande √† partir de n'importe quel r√©pertoire: <br>  <code>vim ~/.ssh/config</code> au lieu de <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> au lieu de <code>systemd-nspawn stretch</code> et ainsi de suite. </p><br><p>  <strong>L'utilisation de caract√®res g√©n√©riques</strong> rend vos commandes plus universelles.  Je l'utilise habituellement en conjonction avec <code>chmod</code> et <code>chown</code> . </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts">  Raccourcis clavier </h3><br><p>  Voici le minimum requis. </p><br><p>  Alt +.  - remplace le dernier argument de la commande pr√©c√©dente.  Il est √©galement accessible avec <code>!$</code> . <br>  Ctrl + A, Ctrl + E - saute respectivement au d√©but et √† la fin de la ligne. <br>  Ctrl + U, Ctrl + Y - couper et coller.  C'est pratique lorsque vous tapez une commande complexe et que vous remarquez que vous devez d'abord en ex√©cuter une autre.  Hmm, o√π enregistrer l'entr√©e actuelle?  Ici. <br>  Ctrl + W - tue un mot avant le curseur.  Il efface la ligne lorsqu'il est maintenu enfonc√©.  Par d√©faut, l'entr√©e est enregistr√©e dans le presse-papiers (utilis√©e pour Ctrl + Y). <br>  Ctrl + K - coupe la partie de la ligne apr√®s le curseur, l'ajoutant au presse-papiers.  Ctrl + A Ctrl + K efface rapidement la ligne. <br>  PgUp, PgDown, Ctrl + R - recherche d'historique. <br>  Ctrl + L efface le terminal. </p><br><h3 id="keyboard-responsiveness">  R√©activit√© du clavier </h3><br><p>  Je veux vous montrer une petite configuration qui vous permet de faire d√©filer, naviguer et effacer plus rapidement.  Que faisons-nous lorsque nous voulons effacer quelque chose de grand?  Nous appuyons sur la touche Retour arri√®re et la maintenons enfonc√©e, et nous la regardons revenir en arri√®re en effa√ßant les caract√®res.  Que se passe-t-il exactement?  Apr√®s avoir appuy√© sur Backspace, un caract√®re dispara√Æt, puis passe un petit d√©lai, puis la r√©p√©tition automatique est d√©clench√©e: Backspace efface les caract√®res un par un, comme vous le frappez √† plusieurs reprises. </p><br><p>  Je vous recommande de r√©gler le retard et la fr√©quence de r√©p√©tition automatique en fonction de la vitesse de vos doigts.  Le d√©lai est requis lorsque vous souhaitez effacer un seul caract√®re - il vous donne le temps de rel√¢cher une touche.  Un retard trop important vous fait attendre une r√©p√©tition automatique.  Pas assez pour que vous soyez ennuy√©, mais assez pour ralentir le transfert de vos pens√©es de la t√™te vers l'ordinateur.  Plus la fr√©quence de r√©p√©tition automatique est √©lev√©e, plus le texte est effac√© rapidement et plus il est difficile d'arr√™ter ce processus.  Le but est de trouver une valeur optimale. </p><br><p>  Ainsi, la commande magique est: </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190 - dur√©e du retard en millisecondes, <br>  20 - fr√©quence en r√©p√©titions par seconde. </p><br><p>  Je recommande de partir de ces valeurs et d'augmenter petit √† petit le retard jusqu'√† faux positifs, puis de revenir un peu.  Si le d√©lai est trop petit, vous ne pourrez pas utiliser le clavier.  Pour r√©soudre ce probl√®me, un serveur X ou un ordinateur complet doit √™tre red√©marr√©.  Alors, soyez prudent. </p><br><p>  Pour enregistrer les param√®tres, vous devez ajouter cette commande quelque part dans le d√©marrage automatique de X. </p><br><h3 id="process-exit-indication">  Indication de sortie de processus </h3><br><p>  Je dois souvent lancer des processus de longue haleine: une grosse sauvegarde, un transfert de donn√©es volumineuses, un empaquetage / extraction d'archives, la construction de paquets, etc.  Habituellement, je d√©marre un tel processus, passe √† une autre t√¢che et regarde occasionnellement si mon processus √† long terme s'est termin√©.  Parfois, je plonge trop profond√©ment dans le travail et l'oublie.  La solution consiste √† ajouter une notification de sortie de processus qui me mettra hors de transe. </p><br><p>  Il existe de nombreux outils √† cet effet: notify-send, dzen2, bip, aplay, wall.  Tous sont bons d'une mani√®re ou d'une autre, mais ne fonctionnent pas avec la connexion ssh.  C'est pourquoi j'utilise le bip du terminal: </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  Le codage ASCII a un caract√®re 0x7, nomm√© <a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> .  Il est utilis√© pour √©mettre un bip sur le haut-parleur du PC.  Le haut-parleur PC n'est pas une chose moderne, tous les ordinateurs ne l'ont pas et il n'est pas entendu dans les √©couteurs.  C'est pourquoi certains terminaux utilisent une soi-disant cloche visuelle.  J'utilise urxvt, et il effectue une cloche visuelle en levant le drapeau d'urgence.  Qu'est ce que c'est?  C'est une chose utilis√©e quand une fen√™tre veut vous dire que c'est urgent. </p><br><p>  Vous pouvez v√©rifier comment votre terminal r√©agit au caract√®re de la cloche en ce moment: </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p>  Trois secondes vous sont accord√©es pour passer √† une autre fen√™tre, cela peut √™tre n√©cessaire. </p><br><p>  Malheureusement, tous les terminaux ne peuvent pas afficher la cloche visuelle en levant le drapeau d'urgence.  J'ai v√©rifi√© les plus populaires. </p><br><div class="scrollable-table"><table><thead><tr><th>  √âmulateur de terminal </th><th>  cloche visuelle comme drapeau d'urgence </th></tr></thead><tbody><tr><td>  konsole </td><td>  peut √™tre activ√© dans les pr√©f√©rences </td></tr><tr><td>  urxvt </td><td>  oui </td></tr><tr><td>  xfce4-terminal </td><td>  peut √™tre activ√© dans les pr√©f√©rences </td></tr><tr><td>  xterm </td><td>  non </td></tr><tr><td>  terme r√©tro cool </td><td>  non </td></tr><tr><td>  lxterminal </td><td>  non </td></tr><tr><td>  gnome-terminal </td><td>  non </td></tr></tbody></table></div><br><p>  Il est trop long pour taper <code>echo $'\a'</code> , j'ai donc cr√©√© un alias de <code>wake</code> . </p><br><h3 id="aliases">  Alias </h3><br><p>  Par d√©faut, les commandes <code>cp</code> , <code>scp</code> et <code>rm</code> fonctionnent de mani√®re non r√©cursive et √ßa craint!  C'est un sacr√© mauvais h√©ritage!  Eh bien, il peut √™tre corrig√© √† l'aide d'alias.  Mais regardons d'abord quand un comportement non r√©cursif peut √™tre utile. </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p>  Seuls les fichiers seront copi√©s dans <code>foodir</code> , mais pas les r√©pertoires.  La m√™me situation va avec <code>rm</code> : </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p>  supprimera uniquement les fichiers et les liens symboliques, mais conservera les r√©pertoires.  Mais √† quelle fr√©quence avez-vous besoin de cette fonctionnalit√©?  J'aime √† penser que <code>cp</code> et <code>rm</code> fonctionnent toujours r√©cursivement. </p><br><p>  D'accord, mais qu'en est-il de la s√©curit√©?  Peut-√™tre qu'un comportement non r√©cursif prot√®ge vos fichiers?  Il y a un cas o√π vous avez un lien symbolique vers le r√©pertoire et que vous souhaitez supprimer ce lien symbolique, mais conservez le r√©pertoire.  Si une barre oblique est ajout√©e (intentionnellement ou occasionnellement) au nom du r√©pertoire et que le mode r√©cursif est activ√© via <code>-r</code> , le r√©pertoire deviendra vide!  VIDE! </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p>  Sans <code>-r</code> arg, il abusera et ne supprimera rien.  Ainsi, la <code>rm</code> r√©cursive augmente un peu le risque de perdre des donn√©es. </p><br><p>  J'ai activ√© le mode r√©cursif pour <code>cp</code> , <code>scp</code> et <code>rm</code> , et j'ai √©galement ajout√© <code>-p</code> pour <code>mkdir</code> pour cr√©er facilement des r√©pertoires imbriqu√©s. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Depuis deux ans, je n'ai jamais regrett√© ces alias et jamais perdu de donn√©es.  Il y a aussi un inconv√©nient: il est possible de copier / supprimer moins de donn√©es que n√©cessaire et de ne pas les voir lorsque vous travaillez sur le syst√®me sans alias.  Alors, soyez prudent.  Je sais ce que je fais et je lance toujours <code>rm</code> avec prudence. </p><br><p>  Les plus <code>ls</code> sont les alias <code>ls</code> et vous les utilisez probablement d√©j√†: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p>  Un grep color√© est √©galement beaucoup plus joli qu'incolore: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Les alias ne fonctionnent pas dans les scripts, n'oubliez pas ce fait!  Vous devez sp√©cifier explicitement tous les arguments. </p><br><h3 id="touch-typing">  Saisie tactile </h3><br><p>  C'est √©vident, mais je vous rappelle que la saisie tactile aide √† taper plus vite.  Ce sera difficile au d√©but, mais vous d√©passerez les limites avec le temps. </p><br><p>  Le meilleur moment pour apprendre la saisie tactile est les vacances, quand personne ne vous d√©range.  S'il vous pla√Æt ne vous pr√©cipitez pas lors de l'apprentissage!  Votre objectif est <em>de m√©moriser l'</em> emplacement de chaque personnage, non pas tant avec votre esprit qu'avec vos doigts.  Il vaut mieux taper lentement, mais sans erreurs plut√¥t que rapidement avec des erreurs.  N'oubliez pas que les ma√Ætres ont de bons r√©sultats non pas avec des doigts rapides mais sans faire d'erreurs. </p><br><p>  N'oubliez pas de faire une pause.  Votre cerveau et vos doigts doivent se reposer.  Lorsque des erreurs commencent √† appara√Ætre, cela signifie que vous devez faire une pause. </p><br><h3 id="that-is-all-for-today">  C'est tout pour aujourd'hui </h3><br><p>  J'esp√®re que ces conseils vous aideront vraiment.  Bonne chance! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481940/">https://habr.com/ru/post/fr481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481926/index.html">D√©couvrez la nouvelle solution Veeam Backup pour AWS</a></li>
<li><a href="../fr481930/index.html">Culture du d√©veloppement: comment les performances et l'efficacit√© sont √©valu√©es</a></li>
<li><a href="../fr481932/index.html">D√©ploiement sans interruption et bases de donn√©es</a></li>
<li><a href="../fr481934/index.html">Analyse: pourquoi les actions Tesla augmentent dans le prix</a></li>
<li><a href="../fr481936/index.html">Avantages et inconv√©nients des tests A / B: exp√©rience des grandes entreprises</a></li>
<li><a href="../fr481942/index.html">Retour vers le futur: quel jeu moderne a √©t√© pr√©sent√© en 2010</a></li>
<li><a href="../fr481944/index.html">Qu'est-ce qui d√©termine la position du site sur la page de recherche?</a></li>
<li><a href="../fr481946/index.html">M√©thodes de communication dans les √©quipes Microsoft: canaux vs chats</a></li>
<li><a href="../fr481948/index.html">Comment cr√©er un robot virtuel?</a></li>
<li><a href="../fr481950/index.html">Tutoriel: Boot de printemps r√©actif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>