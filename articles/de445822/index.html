<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☃️ 🆙 👩🏼‍🎤 Warum Jaop? Warum Schläger? 👩🏾‍🤝‍👨🏻 🖇️ 👄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Fortsetzung des Artikels „Warum Schläger? Warum Lisp? " Ich schrieb ungefähr ein Jahr, nachdem ich Racket entdeckt hatte. Als Neuling ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Jaop? Warum Schläger?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445822/"> Dies ist eine Fortsetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Warum Schläger?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum Lisp? "</a>  Ich schrieb ungefähr ein Jahr, nachdem ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Racket</a> entdeckt hatte.  Als Neuling konnte ich das Lob, das von allen Seiten auf Lisp strömte, nicht verstehen.  Ich wusste nicht, was ich denken sollte.  Wie man versteht, dass Lisp letztendlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"tiefe Erleuchtung"</a> verursachen wird.  Okay, Bruder, sagst du? <br><br>  Ich hatte eine einfache Frage: <b>Was nützt das?</b>  In einem früheren Artikel habe ich versucht, darauf zu antworten, und die Gründe zusammengefasst, warum jemand Lisp oder insbesondere Racket lernen möchte. <br><br>  Ich habe eine Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neun Sprachfunktionen zusammengestellt,</a> die für mich als Neuling bei Racket am wertvollsten sind.  Feature Nummer 5 ist beispielsweise „die Erstellung neuer Programmiersprachen“.  Diese Methode wird auch als <i>sprachorientierte Programmierung</i> oder <i>JOP bezeichnet</i> . <br><a name="habracut"></a><br>  Seitdem ist IOP mein Lieblingsteil von Racket geworden, und ich habe meine Bewunderung in dem Online-Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beautiful Racket geteilt</a> , in dem die ROP-Technik und das Racket-Tool erklärt werden. <br><br>  Ein Beispiel in meiner Arbeit ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pollen</a> .  Ich habe diese Programmiersprache für die bequeme Typografie meiner Online-Bücher geschrieben.  In Pollen ist der vorherige Absatz wie folgt programmiert: <br><br><pre><code class="plaintext hljs">#lang pollen     ◊link["https://beautifulracket.com/appendix/why-racket-why-lisp.html#so-really-whats-in-it-for-me-now"]{  },        Racket. ,  № 5 — «   ».     ◊em{- },  ◊em{}.</code> </pre> <br>  Ein weiteres Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brag</a> , ein Parser-Generator (im Stil von <code>lex/yacc</code> ), der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BNF-Grammatik</a> als Quellcode verwendet.  Ein einfaches Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bf-</a> Sprache: <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Beide Sprachen sind in Racket implementiert und können mit dem üblichen Racket-Interpreter oder in der Racket-IDE (DrRacket genannt) ausgeführt werden. <br><br><h1>  Hauptprobleme </h1><br>  Und doch ... Trotz der Tatsache, dass das Buch Tausende von Menschen gezwungen hat, Racket zu erkunden, scheint es mir manchmal, dass ich auf den gleichen schnellen Weg gehe wie die Lisp-Fans, die ich einst kritisiert habe. <br><br>  Wenn NOP so cool ist, warum dann ein paar Tage damit verbringen, ein Buch zu lesen?  Richtig?  Ich kann alles kurz und ohne weiteres erklären.  Zwei einfache Fragen müssen beantwortet werden: <br><br><ol><li>  Welche Probleme eignen sich am besten für die Sprachprogrammierung? <br></li><li>  Warum eignet sich Racket am besten zum Erstellen von Sprachen? </li></ol><br>  Die zweite Frage ist einfach.  Der erste ist nicht.  Ich wurde oft gefragt.  Ich habe oft den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berühmten</a> Satz von Richter Potter Stewart zitiert: Sie werden ihn verstehen, wenn Sie ihn sehen.  Die Antwort ist gut genug für diejenigen, die wirklich interessiert sind.  Aber nicht für diejenigen, die auf der Seite stehen und sachliche Argumente hören möchten. <br><br>  Also werde ich es versuchen.  Denken Sie daran, dass ich kein Professor für Informatik bin und nicht über die Theorie der Programmiersprachen sprechen kann.  Vielmehr verwende ich Racket und domänenspezifische Sprachen (DSL) für praktische Zwecke: Meine tägliche Arbeit hängt von ihnen ab.  Daher werde ich mich auf praktische Aspekte konzentrieren. <br><br><h1>  Kurze Antwort </h1><br><ol><li>  JOP ist eigentlich eine Interface-Design-Methode.  Es ist ideal für Aufgaben, die eine <b>minimale Notation</b> bei <b>maximaler Genauigkeit</b> erfordern.  Minimale Notation bedeutet die einzig zulässige Notation.  Nichts Überflüssiges.  Maximale Präzision, dh die Bedeutung dieser Notation, ist genau das, was Sie sagen.  Keine Mehrdeutigkeit oder Muster.  IOP kommt wie nichts anderes auf den Punkt. <br><br>  (Ungeduldig kann zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bestimmten Kategorien von Aufgaben</a> übergehen, die von NOP profitieren). <br></li><li>  Racket ist aufgrund seines <b>Makrosystems</b> ideal für OOP.  Sie arbeiten im Compiler-Stil und vereinfachen die Codekonvertierung.  Das Racket-Makrosystem ist besser als jedes andere. </li></ol><br>  An dieser Stelle möchte die Hälfte der Leser des Artikels anonyme Kommentare veröffentlichen, in denen meine Thesen kritisiert werden.  Aber bitte denken Sie daran: Auf jeden Fall habe ich gewonnen.  JOP und Racket haben meine Programmierproduktivität unglaublich gesteigert.  Gerne teile ich dieses Wissen mit Ihnen, damit auch Sie diese Vorteile nutzen können.  Ich werde mich aber auch freuen, wenn diese Werkzeuge meine Geheimwaffe bleiben.  In diesem Fall bleibe ich bei 0,01% der produktivsten Programmierer und erhalte ein beeindruckenderes und profitableres Ergebnis als die restlichen 99,9%. <br><br>  Sie haben also die Wahl. <br><br><h1>  Lange Antwort </h1><br>  Wenn Sie über die wichtigsten Fragen nachdenken, kommt es auf eine Meta-Frage an: Warum ist es schwierig, die Vorteile von Atomwaffen zu erklären? <br><br>  Wenn wir über <i>Sprachen</i> sprechen, ist der Begriff vielleicht voller Erwartungen darüber, was eine Sprache ist und was sie tut.  Während wir uns in diesem Paradigma befinden, ist es schwierig, den Wert von Programmiersprachen zu verstehen. <br><br>  Wenn Sie jedoch den Umfang verringern und Sprachen als Teil einer breiteren Kategorie von Mensch-Computer-Schnittstellen betrachten, ist es einfacher, die spezifischen Vorteile von OOP zu erkennen.  Also lass es uns tun. <br><br><h1>  Allgemeine Sprachen und domänenspezifische Sprachen </h1><br>  Erstens eine kleine Terminologie.  Sprachorientierte Programmierung (auch als OOP bekannt) ist die Idee, Programmierprobleme zu lösen, indem eine neue Sprache erstellt und anschließend ein Programm darauf geschrieben wird.  Oft werden solche "kleinen Sprachen" als domänenspezifische Sprachen (DSLs) bezeichnet. <br><br>  Wie der Name schon sagt, wird eine fachorientierte Sprache an die Aufgaben eines bestimmten Fachgebiets angepasst.  Beispielsweise werden PostScript, SQL, <code>make</code> , reguläre Ausdrücke, <code>.htaccess</code> und HTML als themenorientierte Sprachen betrachtet.  Sie versuchen nicht alles zu tun.  Sie konzentrieren sich vielmehr darauf, eine Sache gut zu machen. <br><br>  Am anderen Ende des Spektrums <i>befinden sich Allzwecksprachen</i> .  Hier sehen wir C, Pascal, Perl, Java, Python, Ruby, Racket usw. Warum werden sie nicht als themenorientiert angesehen?  Weil sie sich für eine Vielzahl von Computeraufgaben positionieren. <br><br>  In der Praxis sind Allzwecksprachen häufig auf ein bestimmtes Gebiet spezialisiert.  Zum Beispiel ist C für die Systemprogrammierung besser als andere.  Perl - für Skripte in der Systemadministration.  Python ist eine Sprache für Anfänger.  Schläger für sprachorientierte Programmierung.  In jedem Fall wurde die Sprache ursprünglich dafür entwickelt. <br><br>  Es gibt eine feine Linie zwischen DSL und Allzwecksprachen.  Zum Beispiel wurde Ruby als Allzwecksprache erstellt, wurde jedoch vor allem für Webanwendungen durch die Verbindung mit Ruby on Rails populär.  JavaScript hingegen war ursprünglich eine themenorientierte Sprache für Webbrowserskripte.  Aber er mutierte wie ein Virus und ist seitdem weit über die ursprüngliche Aufgabe hinaus gewachsen. <br><br><h1>  Was ist eine Sprache? </h1><br>  Wenn dieses ganze breite Spektrum Sprachen genannt wird, was sind dann die bestimmenden Merkmale der Sprache? <br><br>  Ich weiß, was Sie denken: „Hier irren Sie sich.  HTML ist keine Sprache.  Dies ist nur ein Markup.  Er kann den Algorithmus nicht beschreiben. “  Oder: „Reguläre Ausdrücke sind keine Sprache.  Sie arbeiten nicht alleine.  Es ist nur eine Syntax für eine andere Sprache. " <br><br>  Das habe ich auch gedacht.  Aber je genauer ich hinschaute, desto verschwommener wirkten diese Unterschiede.  Daher meine erste Hauptaussage (von drei): Die Programmiersprache ist von Natur aus ein Austauschmedium - <b>ein Notationssystem, das für Menschen und Computer verständlich ist</b> . <br><br>  Das Notationssystem (Notation) bedeutet, dass die Sprache eine Syntax hat.  "Klar" bedeutet, dass die Sprache mit ihrer Syntax <i>Bedeutung</i> vermittelt (oder <i>Semantik</i> , wenn Sie ein ausgefalleneres Wort verwenden).  Diese Definition umfasst alle universellen Programmiersprachen.  Und alles DSL.  (Aber nicht jeder Datenstrom, auf den später noch näher eingegangen wird). <br><br>  (Obwohl „Programmieren“ und „Sprache“ Wörter sind, die idiomatisch zusammen verwendet werden, werden diese Sprachen nicht nur von Menschen zum Programmieren von Computern verwendet. Manchmal werden sie von Computern verwendet, um mit uns zu kommunizieren (z. B. S-Ausdrücke), manchmal, um miteinander zu kommunizieren (Zum Beispiel XML, JSON, HTML.) Auf jeden Fall scheint es falsch, diese Funktionen auszuschließen. Aber in der Praxis ja - was wir normalerweise mit einer Programmiersprache machen, ist tatsächlich Programmierung). <br><br>  Betrachten Sie den HTML-Code: eine Möglichkeit, einem Computer - insbesondere einem Webbrowser - mitzuteilen, wie eine Webseite gezeichnet werden soll.  Dies ist ein Notationssystem (spitze Klammern, Tags, Attribute usw.), das für Mensch und Computer verständlich ist (das <code>charset</code> gibt die Zeichenkodierung an, das <code>p</code> Tag enthält einen Absatz usw.). <br><br>  Hier ist eine kleine HTML-Seite: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My web page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>world<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Angenommen, Sie stimmen nicht zu, dass HTML eine Programmiersprache ist.  Gut.  Wir werden unsere Seite in Python anzeigen.  Das ist eine echte Programmiersprache, oder? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;!DOCTYPE html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;meta charset=\"UTF-8\"&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;title&gt;My web page&lt;/title&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;p&gt;Hello &lt;strong&gt;world&lt;/strong&gt;&lt;/p&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span></code> </pre> <br>  Wenn Python eine Programmiersprache ist, HTML jedoch nicht, ist dieses Python-Beispiel ein Programm, das HTML-Beispiel jedoch nicht. <br><br>  Offensichtlich ist dies ein gequälter Unterschied.  Hier fügt die Pythonisierung nichts anderes als Komplexität und Stereotypisierung hinzu.  Das Pikante ist, dass der einzige interessante semantische Inhalt in einem Python-Programm - unter dem Gesichtspunkt der Verwaltung eines Webbrowsers - darin besteht, dass er in HTML eingebettet ist (möglicherweise können HTML-Tags wie <code>DOCTYPE</code> , <code>meta</code> und <code>strong</code> als Funktionen betrachtet werden, die Argumente annehmen).  Die Logik lässt uns zu dem Schluss kommen, dass HTML, obwohl es einfacher und weniger flexibel ist, immer noch eine Programmiersprache ist. <br><br><h1>  Eingebettete Sprachen </h1><br>  Ein Beispiel mit HTML und Python, das wir uns ausgedacht haben.  Das Einbetten von DSL in eine andere Sprache ist jedoch allgegenwärtig.  Die auf diese Weise verwendeten Sprachen werden als <i>eingebettet bezeichnet</i> .  Sie stellen die häufigste Form der Sprachprogrammierung dar.  Als Programmierer haben Sie sich seit vielen Jahren auf JOP verlassen, auch wenn Sie den Namen nicht kannten. <br><br>  Zum Beispiel reguläre Ausdrücke (andere Beispiele: <code>printf</code> zum Formatieren von Zeichenfolgen, CLDR für Datums- / Zeitmuster, SQL).  Wir können uns den regulären Ausdruck nicht als eigenständige Sprache vorstellen.  Aber jeder Programmierer weiß, was es ist: <br><br><pre> <code class="plaintext hljs">^fo+(bar)*$</code> </pre> <br>  Darüber hinaus können Sie diesen regulären Ausdruck wahrscheinlich in Ihre bevorzugte Programmiersprache eingeben und er funktioniert einfach.  Dieses konsistente Verhalten ist nur möglich, weil die Notation regulärer Ausdrücke eine externe Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POSIX</a> ) ist. <br><br>  Wie bei HTML könnten wir einen äquivalenten Ausdruck in der Notation der Hostsprache schreiben.  Beispielsweise unterstützt Racket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheme Regular Expressions</a> (SRE): Dies sind reguläre Ausdrücke mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">S-Ausdrucksnotation</a> .  Die obige Vorlage wird wie folgt geschrieben: <br><br><pre> <code class="plaintext hljs">(seq bos "f" (+ "o") (* (submatch "bar")) eos)</code> </pre> <br>  Racket-Programmierer verwenden jedoch selten SRE-Ausdrücke.  Sie sind zu lang und schwer zu merken. <br><br>  Ein weiteres allgegenwärtiges Beispiel für eingebettetes DSL: mathematische Ausdrücke.  Jeder Programmierer weiß, was das bedeutet: <br><br><pre> <code class="plaintext hljs">(1 + 2) * (3 / 4) - 5</code> </pre> <br>  Mathematische Ausdrücke allein erzeugen keine interessanten Programme.  Wir müssen sie mit anderen Sprachkonstrukten kombinieren.  Aber wie bei regulären Ausdrücken ist dies eine ergonomische und praktische Aufzeichnung.  Mathematische Ausdrücke haben ihre eigene Notation und Bedeutung, die sowohl für Menschen als auch für Computer verständlich sind, sodass sie als separate integrierte Sprache gelten. <br><br><h1>  Scherzen Sie, dass HTML programmiert? </h1><br>  Nein, das ist es.  Ich bestätige, dass HTML (sowohl reguläre als auch mathematische Ausdrücke) als rudimentäre Programmiersprachen qualifiziert ist.  Dies bedeutet, dass das Schreiben von HTML (oder regulären Ausdrücken oder mathematischen Ausdrücken) als rudimentäre Programmierung gilt. <br><br>  Bitte keine Panik.  Natürlich ist dies ein "Programmierer" auf LinkedIn, der nur HTML- und Arithmetikkenntnisse besitzt. Dies ist Unsinn (obwohl er in einer Woche wahrscheinlich einen Job für 180.000 US-Dollar bekommen wird).  Dies ist jedoch eine separate Frage, was „Programmierer“ auf dem Arbeitsmarkt bedeutet.  Wir reden nicht darüber. <br><br><h1>  Turing Totality Trap </h1><br>  Wenn Sie diese Definition von Programmiersprachen immer noch nervt, denken Sie vielleicht, dass eine echte Programmiersprache alle möglichen Algorithmen ausdrücken sollte - das heißt, sie sollte <i>vollständig sein</i> . <br><br>  Ich verstehe, dass sich ein solcher Gedanke intuitiv anbietet.  Jede universelle Programmiersprache ist Turing vollständig. <br><br>  Das Problem ist jedoch, dass dies ein niedriger Balken ist.  Die Vollständigkeit ist eine technische Metrik, die nicht dem Sprachgebrauch in der realen Welt entspricht.  Beispielsweise sind reguläre Ausdrücke nicht vollständig, aber sie sind nützlich, wenn viele Berechnungen mit minimalen Notationen ausgedrückt werden.  HTML ist auch nicht vollständig, aber es ist eine nützliche Möglichkeit, den Browser zu steuern.  Im Gegenteil, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bf-</a> Sprache ist Turing vollständig, aber selbst die trivialsten Aufgaben erfordern Kilometer unpassierbaren Codes. <br><br><h1>  Sprachbeschränkungen </h1><br>  Fällt etwas unter meine Definition von Sprache?  Nein. <br><br><ul><li>  <i>Binärdatenformate gelten</i> nicht als Sprachen.  Zum Beispiel eine <code>jpeg</code> Datei.  Obwohl ein Computer sie verstehen kann, tut dies eine Person nicht.  Oder PDF: Wenn Sie es hacken, gibt es einige Teile, die für Menschen lesbar sind.  Dies liegt jedoch daran, wie PDF funktioniert.  Es macht keinen Sinn, Ideen mit PDF-Konstrukten zu schreiben. <br></li><li>  <i>Textdateien</i> sind keine Sprachen.  Angenommen, wir haben eine Datei mit Homers Ilias.  Wir Menschen können es lesen und verstehen.  Obwohl der Computer die Datei trivial verarbeiten kann, indem er beispielsweise ihren Inhalt druckt, ist der darin enthaltene Text für den Computer nicht nachvollziehbar. <br></li><li>  <i>Grafische Benutzeroberflächen</i> sind keine Sprachen.  Ja, dies sind Notationssysteme (die auf Text und Bild basieren).  Aber sie sind nur für Menschen verständlich.  Computer zeichnen eine GUI, verstehen sie aber nicht. </li></ul><br><h1>  Sprachen als Schnittstellen </h1><br>  Oben habe ich die Programmiersprache als "Medium des Austauschs" zwischen Menschen und Computern beschrieben.  Somit passen Sprachen in eine breitere Kategorie, die wir <i>Schnittstellen</i> nennen. <br><br>  Dies führt zu der zweiten grundlegenden Aussage (von drei): Die <b>Sprachprogrammierung ist im Grunde eine Methode zum Entwerfen einer Schnittstelle</b> .  Wenn Sie über Schnittstellen nachdenken möchten, wird Ihnen JOP gefallen.  Wenn nicht, werden Sie JOP immer noch lieben, weil es Schnittstellen ermöglicht, die sonst nicht erreichbar sind. <br><br>  Eines meiner Lieblingsbeispiele für eine Sprache als Schnittstelle ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prahlen</a> , eine mit Racket erstellte Parsergeneratorsprache.  Wenn Sie jemals die Lex / Yacc-Toolchain verwendet haben, wissen Sie, dass das Ziel häufig darin besteht, einen Parser aus einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BNF-Grammatik</a> zu generieren.  Zum Beispiel sieht es für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bf</a> so aus: <br><br><pre> <code class="plaintext hljs">bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre><br>  Um einen Parser in einer Allzwecksprache zu erstellen, müssen Sie diese Grammatik in eine Reihe von nativem Code übersetzen.  Dies ist eine mühsame Arbeit.  Und sinnlos - haben wir die Grammatik nicht schon aufgeschrieben?  Warum nochmal? <br><br>  <code>brag</code> erfüllt jedoch unseren Wunsch.  Um den Parser zu erstellen, fügen wir der Datei einfach die Zeile <code>#Lang brag</code> , die die BNF-Grammatik auf magische Weise in den Quellcode von <code>brag</code> konvertiert: <br><br><pre> <code class="plaintext hljs">#Lang brag bf- : (Bf-op | Bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "."| "," Bf-loop : "["(Bf-op | Bf-loop)* "]"</code> </pre> <br>  Fertig!  Bei der Kompilierung exportiert diese Datei die <code>parse</code> , die diese BNF-Grammatik implementiert. <br><br>  Dies ist eines meiner Lieblingsbeispiele, da es anderen Optionen zweifellos überlegen ist.  Darüber hinaus ist eine solche Schnittstelle mit einer Allzwecksprache praktisch unmöglich. <br><br>  Ein JOP-Programmierer erstellt jedoch ständig solche Schnittstellen. <br><br><a name="1"></a><h1>  Wo Sprache die beste Schnittstelle ist </h1><br>  Dies bringt mich zu meiner dritten und letzten Grundthese, dass <b>Sprachen gegenüber Schnittstellen einzigartige Vorteile haben</b> .  Natürlich sind die folgenden Kategorien nicht vollständig oder exklusiv.  Aber ich habe festgestellt, dass IOP in solchen Situationen viel zu bieten hat: <br><br>  1. Wenn Sie eine Schnittstelle für weniger erfahrene Programmierer oder Nicht-Programmierer oder faule Programmierer erstellen möchten (unterschätzen Sie nicht die Größe der letzteren Kategorie). <br><br>  Beispielsweise verfügt Racket über eine ausgefeilte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webanwendungsbibliothek</a> .  Ein einfacher Webserver kann aber auch schnell mit der Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>web-server/insta</code></a> werden: <br><br><pre> <code class="plaintext hljs">#lang web-server/insta (define (start request) (response/xexpr '(html (body "Hello LOP World"))))</code> </pre> <br>  Matthew Flatt demonstriert in seinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Erstellen von Sprachen im Schläger"</a> die Sprache, die spielbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Textabenteuer</a> erzeugt.  Wie <code>brag</code> sieht es eher nach einer Spezifikation als nach einem Programm aus, aber es funktioniert: <br><br><pre> <code class="plaintext hljs">#lang txtadv ===VERBS=== north, n "go north" south, s "go south" get _, grab _, take _ "get" ===THINGS=== ---cactus--- get "Ouch!" ===PLACES=== ---desert--- "You're in a desert. There is nothing for miles around." [cactus, key] north meadow south desert</code> </pre> <br>  2. Wenn Sie die Notation vereinfachen möchten.  Ein Beispiel sind reguläre Ausdrücke.  Ein weiteres Beispiel ist meine fachorientierte Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pollen</a> zum Schreiben von Online-Büchern.  Pollen ähnelt Racket, nur dass Sie hier im Textmodus arbeiten und Sonderzeichen verwenden, um Racket-Befehle anzuzeigen, die in den Inhalt eingebettet sind (Pollen basiert auf der Racket-Dokumentationssprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scribble</a> , die den Großteil der Last übernimmt).  Der Anfang dieses Absatzes ist also wie folgt programmiert: <br><br><pre> <code class="plaintext hljs">    .    —  .   —  -  ◊link["https://pollenpub.com/"]{Pollen}   -.</code> </pre> <br>  Pollen kümmert sich darum, alle erforderlichen Tags einzufügen und in unfehlbaren HTML-Code umzuwandeln.  Ich habe immer noch alle Vorteile des manuellen Markups (volle Kontrolle über die Seite), aber keine Nachteile (z. B. kann ich nicht versehentlich ein nicht geschlossenes Tag hinterlassen). <br><br>  Ein weiteres Beispiel für eine vereinfachte Notation ist <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lindenmayer</a></code> , die Fraktalerzeugung und Zeichensprache des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lindenmayer-Systems</a> wie dieses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/e10/ffe/f98e10ffe99b9f7efbb052ddaf4097a5.png"></div><br><br>  In einem typischen Racket könnte ein Lindenmayer-Programm folgendermaßen aussehen: <br><br><pre> <code class="plaintext hljs">#lang racket/base (require lindenmayer/simple/compile) (define (finish val) (newline)) (define (A value) (display 'A)) (define (B value) (display 'B)) (lindenmayer-system (void) finish 3 (A) (A -&gt; AB) (B -&gt; A))</code> </pre> <br>  Sie können jedoch die vereinfachte Notation verwenden, indem Sie einfach die <code>#lang</code> Notation oben in der Datei ändern: <br><br><pre> <code class="plaintext hljs">#lang lindenmayer/simple ## axiom ## A ## rules ## A -&gt; AB B -&gt; A ## variables ## n=3</code> </pre> <br>  Die Sprache setzt voraus, dass Sie bereits mit dem L-System vertraut sind.  Eine vereinfachte Notation macht es jedoch einfach, Ihre Wünsche in einem Programm aufzuschreiben, das das tut, was Sie wollen. <br><br>  3. Wenn Sie mit einer vorhandenen Notation arbeiten möchten.  Wir haben oben gesehen, wie <code>brag</code> BNF-Grammatik als Quellcode verwendet. <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Ein weiteres Beispiel.  Leute, die Pollen ausprobiert haben, sagten: "Ja, das ist großartig, aber ich bevorzuge Markdown."  Kein Problem: <code>pollen/markdown</code> ist ein Pollendialekt, der Pollensemantik bietet, aber die übliche Markdown-Notation akzeptiert: <br><br><pre> <code class="markdown hljs">    .    —  .   —  -  [<span class="hljs-string"><span class="hljs-string">Pollen</span></span>](<span class="hljs-link"><span class="hljs-link">"https://pollenpub.com/"</span></span>)   -.</code> </pre> <br>  Das Schönste?  Ich habe diesen Dialekt in nur einer Stunde geschrieben und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Markdown-Parser</a> mit dem vorhandenen Code kombiniert. <br><br>  4. Wenn Sie ein Zwischenziel für andere Sprachen erstellen möchten.  JSON, YAML, S-Ausdrücke und XML sind fachorientierte Sprachen, die Datenformate für maschinelles Lesen und Schreiben definieren. <br><br>  In Perfect Racket heißt eine Trainingssprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>jsonic</code></a> .  Sie können Racket-Ausdrücke in JSON einbetten, wodurch JSON programmierbar wird.  Der Quellcode sieht folgendermaßen aus: <br><br><pre> <code class="json hljs">#lang jsonic // a line comment [ @$ '<span class="hljs-literal"><span class="hljs-literal">null</span></span> $@, @$ (* <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) $@, @$ (= <span class="hljs-number"><span class="hljs-number">2</span></span> (+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) $@, @$ (list <span class="hljs-string"><span class="hljs-string">"array"</span></span> <span class="hljs-string"><span class="hljs-string">"of"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span>) $@, @$ (hash 'key<span class="hljs-number"><span class="hljs-number">-1</span></span> '<span class="hljs-literal"><span class="hljs-literal">null</span></span> 'key<span class="hljs-number"><span class="hljs-number">-2</span></span> (even? <span class="hljs-number"><span class="hljs-number">3</span></span>) 'key<span class="hljs-number"><span class="hljs-number">-3</span></span> (hash 'subkey <span class="hljs-number"><span class="hljs-number">21</span></span>)) $@ ]</code> </pre> <br>  Kompiliert zu regulärem JSON: <br><br><pre> <code class="json hljs">[ <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-string"><span class="hljs-string">"array"</span></span>,<span class="hljs-string"><span class="hljs-string">"of"</span></span>,<span class="hljs-string"><span class="hljs-string">"strings"</span></span>], {<span class="hljs-attr"><span class="hljs-attr">"key-1"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-attr"><span class="hljs-attr">"key-3"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"subkey"</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span>},<span class="hljs-attr"><span class="hljs-attr">"key-2"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} ]</code> </pre> <br>  5. Wenn der Hauptteil des Programms die Konfiguration ist.  Beispielsweise können Dotfiles als DSL beschrieben werden.  Ein komplexeres Beispiel von Racket ist Jesse Alamas Riposte, eine Sprache zum Testen der JSON-basierten HTTP-API: <br><br><pre> <code class="plaintext hljs">#lang riposte $productId := 41966 $qty := 5 $campaignId := 1 $payload := { "product_id": $productId, "campaign_id": $campaignId, "qty": $qty } POST $payload cart/{uuid}/items responds with 200 $itemId := /items/0/cart_item_id GET cart responds with 200</code> </pre> <br>  Als Miniatur-Skriptsprache ist Riposte viel intelligenter als die durchschnittliche Punktedatei.  Es verbirgt den gesamten für HTTP-Transaktionen erforderlichen Zwischencode und ermöglicht es dem Benutzer, sich auf das Schreiben von Tests zu konzentrieren.  Es ist immer noch Hausreinigung.  Aber zumindest können Sie sich auf den Haushalt konzentrieren, den Sie interessieren. <br><br><h1>  Warum Schläger? </h1><br>  Kritiker von JOP fragen oft: „Warum eine fachorientierte Sprache machen?  Ist es einfacher, eine native Bibliothek zu schreiben? “ <br><br>  Nein, es ist nicht einfacher, wenn Sie das richtige Werkzeug haben.  Schläger ist ungewöhnlich: Er wurde von Grund auf speziell für YOP entwickelt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher ist die Implementierung von DSL auf Racket schneller, billiger und einfacher als Alternativen. In der ersten Lektion meines Buches habe ich beispielsweise gezeigt, wie man in einer Stunde eine neue Sprache entwickelt - auch wenn Sie Racket noch nie verwendet haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter der Haube jedes DSL in Racket funktioniert der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source-to-Source-Compiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tatsächlich </font><font style="vertical-align: inherit;">, der die DSL-Notation und -Semantik in ein gleichwertiges Racket-Programm konvertiert. Aus diesem Grund kann Racket DSL nicht so schnell ausgeführt werden wie manuell geschriebener C-Code. Dann sind jedoch alle Racket-Tools und -Bibliotheken für jedes DSL verfügbar. Sie verlieren an Produktivität, gewinnen aber immer wieder an Komfort. Und wenn das Erstellen eines DSL bequem und einfach ist, wird es zu einer realistischen Option für eine viel größere Bandbreite von Problemen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Kritik zu beantworten - nein, DSL erfordert nicht unbedingt mehr Arbeit als die native Bibliothek. </font><font style="vertical-align: inherit;">Darüber hinaus kann eine Sprache, wie wir bereits gesehen haben, als Schnittstelle das tun, was eine native Bibliothek nicht kann.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warum Makro? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da alle DSLs in Racket kompiliert sind, muss der Programmierer einige Syntaxtransformatoren schreiben, die die DSL-Notation in das native Racket konvertieren. </font><font style="vertical-align: inherit;">Diese Syntaxkonverter werden als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Makros bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tatsächlich können sie als Erweiterungen des Racket-Compilers beschrieben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Racket-Makrosystem ist riesig, elegant und zweifellos die Perle seiner Krone. </font><font style="vertical-align: inherit;">Ein Großteil meines Buches handelt von der Freude, mit </font><font style="vertical-align: inherit;">Racket- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Makros zu arbeiten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich kann zwei herausragende Funktionen nennen:</font></font><br><br><ol><li>  Racket    ,   <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a></i> .     .    ,      ,   Racket   ,     ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .           ( .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">« »</a> ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlägermakros sind </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hygienisch</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">standardmäßig behält der vom Makro erstellte Code den lexikalischen Kontext bei, aus dem das Makro definiert wird. </font><font style="vertical-align: inherit;">In der Praxis entfällt dadurch die große Menge unnötiger Gesten, die normalerweise für DSL erforderlich sind (weitere Informationen finden Sie im Kapitel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hygiene</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ist es möglich, DSL beispielsweise in Python zu implementieren? </font></font> Natürlich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich habe ich mein erstes DSL speziell in Python geschrieben - und verwende es immer noch in meiner </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schriftdesignarbeit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nun, das. </font><font style="vertical-align: inherit;">Einmal war genug. </font><font style="vertical-align: inherit;">Seitdem benutze ich Racket.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fazit: Sieg mit YaOP </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Moment können Sie eine von zwei Reaktionen haben: </font></font><br><br><ol><li> <i>«  ,    ,    »</i> . ,          . ,    ,       .       .        .      ,       .         . <br></li><li> <i>«,   ,     c    Racket    »</i> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>  ,     -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Riposte</a> , —         (  ): <br><br><blockquote> [ ]     -  Racket. ,  ,    -     …             : «     API  ,   ?»  : «  Riposte».  ,   ,  [DSL],   ,   .    «» Racket.   <b> DSL  ,   </b> . </blockquote></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende des Artikels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Warum Schläger? </font><font style="vertical-align: inherit;">Warum Lisp? " </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sagte, dass die Lisp-Sprache "Ihnen die Möglichkeit gibt, Ihr Potenzial als Programmierer und Denker freizusetzen und dadurch Ihre Erwartungen an das, was Sie erreichen können, zu erhöhen." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOP bietet eine ähnliche Möglichkeit: unsere Erwartungen zu erhöhen, was Programmiersprachen für uns tun können. </font><font style="vertical-align: inherit;">Sprachen sind keine Black Boxes. </font><font style="vertical-align: inherit;">Dies sind die Schnittstellen, die wir entwerfen können. </font><font style="vertical-align: inherit;">Gleichzeitig eröffnen wir neue Möglichkeiten für das, was mit Hilfe von Programmen getan werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die beste Programmiertechnik finden, verwenden Sie sie. </font><font style="vertical-align: inherit;">Jetzt, wo ich OOP und Racket habe, werde ich nie mehr zurückkommen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weiterführende Literatur </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">« Racket»</a>   ( ).       .    —    ,     Racket     . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Racket 2019</a> .    Racket     :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">« Racket»</a> ( )   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«  »</a> (  Racket). <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«   Racket:  »</a>  .  ,   —     ,      «» ( ),     ,      . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«   Racket»</a>  .  —   Racket (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ).           DSL   DSL    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> DSL,   Racket,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445822/">https://habr.com/ru/post/de445822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445806/index.html">Wie künstliche Intelligenz die Wissenschaft verändert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gefährliche Leben eines Virus-Crackers, der sich mächtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten verändert hat</a></li>
<li><a href="../de445816/index.html">Wie wir Server-Rendering gesehen haben und was daraus wurde</a></li>
<li><a href="../de445820/index.html">MVCC-3. Zeilenversionen</a></li>
<li><a href="../de445824/index.html">Codegenerierung in Dart. Teil 1. Grundlagen</a></li>
<li><a href="../de445826/index.html">Wir gehen mit Bedacht durch die Stadt - 2: Gehen wir mit dem genetischen Algorithmus im Kreis durch die Stadt</a></li>
<li><a href="../de445828/index.html">Chinesisches Sonnenspektrum</a></li>
<li><a href="../de445832/index.html">Strahlung: der unsichtbare Mörder und seine Töchter oder ein bisschen über Radon</a></li>
<li><a href="../de445834/index.html">Entwicklung der Fähigkeit zur Verwendung von Gruppierung und Datenvisualisierung in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>