<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏽 🤷🏾 🚖 Warum Gauß? (100 Möglichkeiten, das Gleichungssystem zu lösen) 🤮 🚙 🐒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was werden Sie tun, wenn Sie aufgefordert werden, ein einfaches System mit drei Unbekannten zu lösen? Jeder hat seinen eigenen und bequemsten Ansatz f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Gauß? (100 Möglichkeiten, das Gleichungssystem zu lösen)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418241/">  Was werden Sie tun, wenn Sie aufgefordert werden, ein einfaches System mit drei Unbekannten zu lösen?  Jeder hat seinen eigenen und bequemsten Ansatz für ihn persönlich entwickelt.  Es gibt viele Möglichkeiten, ein System linearer algebraischer Gleichungen zu lösen.  Aber warum wird die Gauß-Methode speziell bevorzugt? <br><a name="habracut"></a><br><h3>  Das Wichtigste zuerst </h3><br>  Beginnen wir mit einem einfachen.  Es sei ein lineares Gleichungssystem dritter Ordnung gegeben: <br><br><p><math> </math> $$ display $$ \ left \ {\ begin {align} a_ {11} x_1 + a_ {12} x_2 + a_ {13} x_3 = b_1, \\ a_ {21} x_1 + a_ {22} x_2 + a_ { 23} x_3 = b_2, \\ a_ {31} x_1 + a_ {32} x_2 + a_ {33} x_3 = b_3.  \\ \ end {align} \ right. $$ display $$ </p><br>  Die Gauß-Methode besteht darin, die Terme unterhalb der Hauptdiagonale nacheinander zu "zerstören".  Im ersten Schritt wird die erste Gleichung mit multipliziert <math> </math> $ inline $ \ dfrac {a_ {21}} {a_ {11}} $ inline $   und von der Sekunde subtrahiert (und auf ähnliche Weise multipliziert mit <math> </math> $ inline $ \ dfrac {a_ {31}} {a_ {11}} $ inline $   und vom dritten abgezogen).  Das heißt, nach dieser Konvertierung erhalten wir Folgendes: <br><p><math> </math> $$ display $$ \ left \ {\ begin {align} a_ {11} x_1 + a_ {12} x_2 + a_ {13} x_3 = b_1, \\ a_ {22} 'x_2 + a_ {23}' x_3 = b_2 ', \\ a_ {32}' x_2 + a_ {33} 'x_3 = b_3'.  \\ \ end {align} \ right. $$ display $$ </p><br>  Nun wird die zweite Gleichung mit multipliziert <math> </math> $ inline $ \ dfrac {a_ {32} '} {a_ {22}'} $ inline $   und vom dritten abgezogen: <br><p><math> </math> $$ display $$ \ left \ {\ begin {align} a_ {11} x_1 + a_ {12} x_2 + a_ {13} x_3 = b_1, \\ a_ {22} 'x_2 + a_ {23}' x_3 = b_2 ', \\ a_ {33}' 'x_3 = b_3' '.  \\ \ end {align} \ right. $$ display $$ </p><br>  Ich habe ein ziemlich einfaches System, das Sie leicht finden können <math> </math> $ inline $ x_3 $ inline $   dann <math> </math> $ inline $ x_2 $ inline $   und <math> </math> $ inline $ x_1 $ inline $   . <br><br>  Ein aufmerksamer Leser wird auf jeden Fall bemerken: Was ist, wenn die diagonalen Elemente gleich Null sind?  Was tun, wenn zum Beispiel <math> </math> $ inline $ a_ {11} = 0 $ inline $   ?  Endet die berühmte Gauß-Methode dort? <br><br>  Nichts Schlimmes!  Lass uns finden <math> </math> $ inline $ \ max | a_ {1j} | $ inline $   und tauschen <math> </math> $ inline $ j $ inline $   th und erste Reihe (ohne Verlust der Allgemeinheit, nehmen wir an, dass <math> </math> $ inline $ \ max | a_ {1j} |  = a_ {13} $ inline $   )  Beachten Sie, dass der Fall, wenn alles <math> </math> $ inline $ a_ {1j} = 0 $ inline $   es kann nicht sein, da in diesem Fall die Determinante der Koeffizientenmatrix verschwindet und es nicht möglich ist, das System zu lösen.  Nachdem wir die 3. Gleichung in der ersten Zeile neu angeordnet haben, führen wir die zuvor beschriebenen Schritte aus. <br><br>  Die Suche nach dem maximalen Modulo-Element kann bei jeder Iteration durchgeführt werden, d. H. Bei <math> </math> $ inline $ k $ inline $   -th Iteration zu suchen <math> </math> $ inline $ \ max | a_ {kj} | $ inline $   dann ändern <math> </math> $ inline $ j $ inline $   und <math> </math> $ inline $ k $ inline $   th Zeile.  Der Algorithmus, in dem das maximale Element in der Spalte gesucht wird, wird als Gauß-Methode mit der Auswahl des Hauptelements in der Spalte bezeichnet. <br><br>  Es gibt noch einen anderen Weg.  Kann weiter <math> </math> $ inline $ k $ inline $   -th Iteration zu suchen <math> </math> $ inline $ \ max | a_ {ik} | $ inline $   Ändern Sie dann nicht die Zeilen, sondern die Spalten.  Es ist jedoch wichtig, sich die Indizes der sich ändernden Spalten in einem Array zu merken <math> </math> $ inline $ \ alpha $ inline $   (dann, um die genaue Reihenfolge der Variablen wiederherzustellen). <br><br>  Ein Beispiel für einen einfachen Code, der diesen Algorithmus implementiert: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Locale; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Scanner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GuassianEliminationSearchMainElementsAtString</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ Scanner sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(<span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>)); sc.useLocale(Locale.US); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = sc.nextInt(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// input for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { a[i][j] = sc.nextDouble(); } b[i] = sc.nextDouble(); } int[] alpha = new int[n + 1]; // array of indices for (int i = 1; i &lt;= n; i++) { alpha[i] = i; } for (int m = 1; m &lt;= n; m++) { double max = Math.abs(a[m][m]); int count = m; for (int i = m + 1; i &lt;= n; i++) { if (Math.abs(a[m][i]) &gt; max) { // search max elements at the string max = Math.abs(a[m][i]); count = i; } } int tmp = alpha[m]; // swap strings alpha[m] = alpha[count]; alpha[count] = tmp; for (int i = m; i &lt;= n; i++) { double tmp2 = a[i][m]; a[i][m] = a[i][count]; a[i][count] = tmp2; } for (int i = m + 1; i &lt;= n; i++) { // guassian right stroke b[i] = b[i] - a[i][m] * b[m] / a[m][m]; for (int j = m + 1; j &lt; n; j++) { a[i][j] = a[i][j] - a[i][m] * a[m][j] / a[m][m]; } } } // for m double[] x = new double[n+1]; for (int i = n; i &gt;= 1; i--) { // guassian back stroke double sum = 0; for (int j = i + 1; j &lt;= n; j++) { sum += a[i][j] * x[alpha[j]]; } x[alpha[i] - 1] = (b[i] - sum) / a[i][i]; } // output PrintWriter pw = new PrintWriter("output.txt"); for (int i = 0; i &lt; n; i++) { pw.printf(Locale.US, "x%d = %.5f \n", i + 1, x[i]); } pw.flush(); pw.close(); } }</span></span></code> </pre> <br><h3>  Warum Gauß? </h3><br>  Es gibt einen anderen Weg, um SLAE zu lösen.  Eine davon ist die Cramer-Methode.  Es besteht in der vorläufigen Berechnung einer bestimmten Anzahl von Determinanten, mit deren Hilfe die Werte der Variablen sofort berechnet werden.  Unter dem ursprünglichen System sieht diese Methode folgendermaßen aus: <br><br><p><math> </math> $$ display $$ \ Delta = \ begin {vmatrix} a_ {11} &amp; a_ {12} &amp; a_ {13} \\ a_ {21} &amp; a_ {22} &amp; a_ {23} \\ a_ {31} &amp; a_ {32} &amp; a_ {33} \\ \ end {vmatrix}, \ Delta_1 = \ begin {vmatrix} b_1 &amp; a_ {12} &amp; a_ {13} \\ b_2 &amp; a_ {22} &amp; a_ {23} \ \ b_3 &amp; a_ {32} &amp; a_ {33} \\ \ end {vmatrix}, $$ display $$ </p><br><p><math> </math> $$ display $$ \ Delta_2 = \ begin {vmatrix} a_ {11} &amp; b_1 &amp; a_ {13} \\ a_ {21} &amp; b_2 &amp; a_ {23} \\ a_ {31} &amp; b_3 &amp; a_ {33} \\ \ end {vmatrix}, \ Delta_3 = \ begin {vmatrix} a_ {11} &amp; a_ {12} &amp; b_1 \\ a_ {21} &amp; a_ {22} &amp; b_2 \\ a_ {31} &amp; a_ {32 } &amp; b_3 \\ \ end {vmatrix}, $$ display $$ </p><br><p><math> </math> $$ display $$ x_i = \ dfrac {\ Delta_i} {\ Delta}. $$ display $$ </p><br><br>  Aber denken Sie daran - was ist ein Qualifier? <br><br>  Per Definition die Determinante einer Matrix <math> </math> $ inline $ A = (a_ {ij}) $ inline $   Es gibt einen Betrag <p><math> </math> $$ Anzeige $$ \ Summe \ Grenzen_ {1 \ leq i_1 &lt;\ Punkte &lt;i_n \ leq n} (-1) ^ {N (i_1, \ Punkte, i_n)} a_ {1i_1} \ Punkte a_ {ni_n}, $$ Anzeige $$ </p>  wo <math> </math> $ inline $ N (i_1, \ dots, i_n) $ inline $   - Platzhalter <math> </math> $ inline $ i_1, \ dots, i_n. $ inline $ <br><br>  Die Determinante enthält <math> </math> $ inline $ n! $ inline $   Begriffe.  Um das System zu lösen, müssen Sie zählen <math> </math> $ inline $ n + 1 $ inline $   Determinanten.  Ausreichend groß <math> </math> $ inline $ n $ inline $   es ist sehr teuer.  Zum Beispiel wenn <math> </math> $ inline $ n = 12 $ inline $   Die Anzahl der Operationen wird <math> </math> $ inline $ 12! (12 + 1) = 6227020800, $ inline $   während die Gauß-Methode mit Asymptotik <math> </math> $ inline $ n ^ 3 $ inline $   wird nur erfordern <math> </math> $ inline $ 12 ^ 3 = 1728 $ inline $   Operationen. <br><br><h3>  Iterative Methoden </h3><br>  Sogenannte iterative Methoden eignen sich auch als Algorithmen zur Lösung von SLAEs.  Sie bestehen darin, die Näherungen nacheinander zu berechnen, bis eine von ihnen der genauen Antwort so nahe wie möglich kommt. <br><br>  Zunächst wird ein beliebiger Vektor ausgewählt <math> </math> $ inline $ x ^ 0 $ inline $   Ist eine Nullnäherung.  Darauf wird ein Vektor aufgebaut. <math> </math> $ inline $ x ^ 1 $ inline $   - Dies ist die erste Annäherung.  Usw.  Die Berechnungen enden wann <math> </math> $ inline $ || x ^ k - x ^ {k + 1} ||  &lt;\ varepsilon $ inline $   wo <math> </math> $ inline $ \ varepsilon $ inline $   - einen eingestellten Wert im Voraus.  Die letzte Ungleichung bedeutet, dass unsere „Verbesserung“ der Lösung mit jeder Iteration nahezu unbedeutend ist. <br><br>  Betrachten Sie die beliebte Jacobi-Methode, eine der einfachsten iterativen Methoden zum Lösen von SLAEs. <br><br>  Zunächst schreiben wir das System in der folgenden Form: <br><p><math> </math> $$ Anzeige $$ \ Summe \ Grenzen_ {j \ leq n} a_ {ij} x_j = b_i, \ i = \ overline {1, n}.  $$ Anzeige $$ </p><br>  Trennen <math> </math> $ inline $ i $ inline $   -th Begriff und drücken Sie es durch alles andere aus: <br><p><math> </math> $$ display $$ x_i = \ dfrac {b_i - \ sum \ limit_ {j \ neq i} a_ {ij} x_j} {a_ {ii}}, \ i = \ overline {1, n}. $$ display $ $ </p><br>  Hängen Sie nun einfach die "Zähler" an die Variablen und erhalten Sie die Jacobi-Iterationsmethode: <br><p><math> </math> $$ display $$ x_i ^ k = \ dfrac {b_i - \ sum \ limit_ {j \ neq i} a_ {ij} x_j ^ k} {a_ {ii}}, \ i = \ overline {1, n}, \ k = 0,1, \ Punkte. $$ Anzeige $$ </p><br><br>  Beachten Sie, dass eine Voraussetzung für die Verwendung dieser Methode das Fehlen von Nullen entlang der Hauptdiagonale ist. <br><br>  Implementierung der Jacobi-Methode in Java: <br>  <i>Als</i> <math> </math> <i>$ inline $ \ varepsilon $ inline $</i>   <i>es wird ein vorberechnetes sogenanntes maschinen-epsilon genommen.</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Locale; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Scanner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JacobiMethod</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> FileNotFoundException </span></span>{ Scanner sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(<span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>)); sc.useLocale(Locale.US); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = sc.nextInt(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] x0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= n; j++) { a[i][j] = sc.nextDouble(); } b[i] = sc.nextDouble(); x0[i] = b[i] / a[i][i]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> EPS = EPSCalc(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> norm = Double.MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= n; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(j == i) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; sum += a[i][j] * x0[j]; } x[i] = (b[i] - sum) / a[i][i]; } norm = normCalc(x0, x, n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { x0[i] = x[i]; } counter++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(norm &gt; EPS); PrintWriter pw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(<span class="hljs-string"><span class="hljs-string">"output.txt"</span></span>); pw.println(counter + <span class="hljs-string"><span class="hljs-string">" iterations"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { pw.printf(Locale.US, <span class="hljs-string"><span class="hljs-string">"x%d = %f\n"</span></span>, i, x0[i]); } pw.flush(); pw.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> []x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { sum += Math.abs(x1[i] - x2[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EPSCalc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> eps = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> + eps &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { eps /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eps; } }</code> </pre><br>  Eine Modifikation der Jacobi-Methode ist die Relaxationsmethode.  Der Hauptunterschied besteht darin, dass mit Hilfe eines vorgewählten Parameters die Anzahl der Iterationen erheblich reduziert wird.  Lassen Sie uns kurz die Hauptidee der Methode beschreiben. <br><br>  Aus dem ursprünglichen System drücken wir noch einmal aus <math> </math> $ inline $ x $ inline $   , aber lassen Sie uns die Zähler etwas anders einrichten und den Parameter hinzufügen <math> </math> $ inline $ \ omega $ inline $   :: <br><p><math> </math> $$ display $$ x_i ^ k = \ dfrac {\ omega \ left (b_i - \ sum \ limit_ {j = 1} ^ {i-1} a_ {ij} x_j ^ {k + 1} - \ sum \ limit_ {j = i + 1} ^ n a_ {ij} x_j ^ k \ right)} {a_ {ii}} + (1- \ omega) x_i ^ k, \ i = \ overline {1, n}, \ k = 0,1, \ dots. $$ display $$ </p><br>  Bei <math> </math> $ inline $ \ omega = 1 $ inline $   alles wird zu einer Jacobi-Methode. <br><br>  Also werden wir nach etwas „Gutem“ suchen <math> </math> $ inline $ \ omega $ inline $   .  Stellen Sie eine Nummer ein <math> </math> $ inline $ s $ inline $   und wir werden Werte nehmen <math> </math> $ inline $ \ omega \ in (0,2) $ inline $   , für die wir jeweils die Normen berücksichtigen werden <math> </math> $ inline $ || x ^ {k + 1} -x ^ k ||, \ k = \ overline {1, s} $ inline $   .  Denken Sie bei der kleinsten dieser Normen an diesen Wert <math> </math> $ inline $ \ omega $ inline $   und damit lösen wir unser System. <br><br>  Abbildung der Java-Methode: <br>  <i>hier</i> <math> </math> <i>$ inline $ s = 5 $ inline $</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Locale; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Scanner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessiveOverRelaxation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> FileNotFoundException </span></span>{ Scanner sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(<span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>)); sc.useLocale(Locale.US); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = sc.nextInt(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>][n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= n; j++) { a[i][j] = sc.nextDouble(); } b[i] = sc.nextDouble(); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> EPS = EPSCalc(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> w = bestRelaxationParameterCalc(a, b, n); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxChange = Double.MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { maxChange = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> firstSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= i - <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { firstSum += a[i][j] * x[j]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> secondSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= n; j++) { secondSum += a[i][j] * x[j]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lastTerm = (<span class="hljs-number"><span class="hljs-number">1</span></span> - w) * x[i]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z = (b[i] - firstSum - secondSum); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> temp = (w * z) / a[i][i] + lastTerm ; maxChange = Math.max(maxChange, Math.abs(x[i] - temp)); x[i] = temp; } counter++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(maxChange &gt; EPS); PrintWriter pw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(<span class="hljs-string"><span class="hljs-string">"output.txt"</span></span>); pw.println(w + <span class="hljs-string"><span class="hljs-string">" is the best relaxation parameter"</span></span>); pw.println(counter + <span class="hljs-string"><span class="hljs-string">" iterations"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { pw.printf(Locale.US, <span class="hljs-string"><span class="hljs-string">"x%d = %f\n"</span></span>, i, x[i]); } pw.flush(); pw.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bestRelaxationParameterCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][]a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> bestW = <span class="hljs-number"><span class="hljs-number">1</span></span>, bestMaxChange = Double.MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> w = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; w &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; w += <span class="hljs-number"><span class="hljs-number">0.05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxChange = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; s &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; s++) { maxChange = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> firstSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= i - <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { firstSum += a[i][j] * x[j]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> secondSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= n; j++) { secondSum += a[i][j] * x[j]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lastTerm = (<span class="hljs-number"><span class="hljs-number">1</span></span> - w) * x[i]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z = (b[i] - firstSum - secondSum); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> temp = (w * z) / a[i][i] + lastTerm; maxChange = Math.max(maxChange, Math.abs(x[i] - temp)); x[i] = temp; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxChange &lt; bestMaxChange) { bestMaxChange = maxChange; bestW = w; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestW; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EPSCalc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> eps = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> + eps &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { eps /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eps; } }</code> </pre><br><h4>  Anstelle einer Schlussfolgerung </h4><br>  Es gibt viel mehr Algorithmen zum Lösen von SLAE.  Zum Beispiel die Quadratwurzelmethode, bei der das gewünschte System durch zwei "einfache" Systeme ersetzt wird, deren Lösungen durch Elementarformeln berechnet werden;  Sweep-Methode, die für so spezifische tridiagonale Matrizen verwendet wird.  Jeder wählt die Methode für sein Problem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418241/">https://habr.com/ru/post/de418241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418229/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 8: Netzwerksicherheitsmodell, Teil 1</a></li>
<li><a href="../de418233/index.html">BMW Mnemonik zum Finden von Grenzwerten</a></li>
<li><a href="../de418235/index.html">Orchestrierte Saga oder Erstellen von Geschäftstransaktionen in Diensten mit der Datenbank nach Dienstmuster</a></li>
<li><a href="../de418237/index.html">Entwicklung mandantenfähiger Anwendungen auf der SAP Cloud Platform in Neo, Teil 2: Autorisierung und Authentifizierung</a></li>
<li><a href="../de418239/index.html">48 Megapixel für Smartphone</a></li>
<li><a href="../de418243/index.html">Die populäre Geschichte der Astronomie ist falsch</a></li>
<li><a href="../de418245/index.html">Wie man kein Projekt auf Bitrix entwickelt</a></li>
<li><a href="../de418247/index.html">Beschleunigen Sie die Float 4x4 Matrix Multiplikation mit SIMD</a></li>
<li><a href="../de418249/index.html">Neue VM-Images der Google Compute Engine für Deep Learning</a></li>
<li><a href="../de418251/index.html">Computer Vision: Wie KI uns beobachtet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>