<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧡 🐶 🌖 Mini ai cup 2 atau hampir AgarIO - apa yang bisa dilakukan untuk menang 🤰🏿 🚦 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Kali ini saya ingin menulis tentang bagaimana saya berhasil memenangkan kompetisi Mini AI Cup 2 . Seperti pada artikel terakhir saya, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini ai cup 2 atau hampir AgarIO - apa yang bisa dilakukan untuk menang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420737/">  Halo semuanya!  Kali ini saya ingin menulis tentang bagaimana saya berhasil memenangkan kompetisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mini AI Cup 2</a> .  Seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> saya, praktis tidak ada detail implementasi.  Kali ini tugasnya kurang banyak, tetapi bagaimanapun ada banyak nuansa dan hal-hal kecil yang mempengaruhi perilaku bot.  Akibatnya, bahkan setelah hampir tiga minggu bekerja aktif di bot, masih ada ide tentang bagaimana meningkatkan strategi. <br><br><img src="https://habrastorage.org/webt/iw/ef/hv/iwefhvnhx6m3ubjpwo_d0cgn3qi.png"><br><br>  Di bawah memotong banyak gif dan traffic. <br><a name="habracut"></a><br>  <i>Yang gigih akan mencari tahu, sisanya akan lari ketakutan (dari komentar pada bagian <s>singkat yang</s> dikompresi).</i> <br><br>  <i>Mereka yang terlalu malas untuk membaca banyak dapat pergi ke spoiler kedua dari belakang artikel untuk melihat deskripsi <s>singkat</s> singkat dari algoritma <s>, dan kemudian Anda dapat mulai membaca dari awal</s> .</i> <br><br>  Tautan ke sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di github</a> . <br><br><h3>  Pemilihan alat </h3><br>  Seperti terakhir kali, saya butuh banyak waktu untuk memikirkan di mana untuk memulai.  Pilihannya adalah, antara lain, antara dua bahasa: Jawa, akrab bagi saya, dan sudah cukup dilupakan sejak masa siswa C ++.  Tetapi karena sejak awal tampaknya bagi saya bahwa hambatan utama untuk menulis bot yang baik bukanlah kecepatan pengembangan seperti produktivitas dari solusi akhir, pilihan tetap jatuh pada C ++. <br><br>  Setelah pengalaman sukses menggunakan visualizer saya sendiri untuk debugging bot di kompetisi sebelumnya, saya tidak ingin melakukannya tanpa kali ini juga.  Tetapi visualisator yang saya tulis untuk diri saya sendiri di Qt for <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeWars</a> tidak terlihat seperti solusi yang ideal untuk saya, dan saya memutuskan untuk menggunakan visualizer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Itu juga dibuat di bawah CodeWars, tetapi tidak memerlukan pemrosesan serius untuk digunakan dalam kompetisi ini.  Kesederhanaan relatif dari koneksi dan kenyamanan untuk memohon rendering di mana saja dalam kode dimainkan untuknya. <br><br>  Seperti sebelumnya, saya benar-benar ingin men-debug centang apa pun dalam permainan - kemampuan untuk menjalankan strategi pada saat sembarang dari permainan yang diuji.  Karena plug-in visualizer tidak dapat menyelesaikan masalah ini, dengan bantuan pasangan #ifdef (di mana saya juga membungkus potongan-potongan kode yang bertanggung jawab untuk rendering) saya menambahkan ke setiap centang pada penghematan kelas Konteks, yang berisi semua nilai yang diperlukan dari variabel dari centang sebelumnya.  Pada intinya, solusinya mirip dengan apa yang saya gunakan di Code Wizards, tetapi kali ini pendekatannya tidak begitu spontan.  Setelah mensimulasikan seluruh permainan, Anda diminta memasukkan nomor centang permainan, yang harus dimulai ulang.  Informasi tentang keadaan variabel sebelum centang ini diambil dari array, serta garis yang diterima oleh strategi input, yang memungkinkan saya untuk memainkan gerakan strategi saya dalam urutan yang diperlukan. <br><br><h3>  Mulai </h3><br>  Pada hari peraturan dibuka, saya tidak lewat dan pada malam pertama terlihat apa yang menanti kami.  Dia tidak ragu untuk marah pada format input json (ya, itu nyaman, tetapi beberapa peserta mulai belajar YP lama yang baru atau sudah lama terlupakan di kompetisi seperti itu, dan mulai dengan parsing json bukan yang paling menyenangkan), melihat formula gerakan yang aneh dan entah bagaimana mulai membentuk kerangka masa depan strategi (untuk memahami artikel di masa depan, ada baiknya membaca <a href="">aturan</a> ).  Selama 2 hari saya menulis banyak kelas seperti Ejection, Virus, Player dan lain-lain, membaca json, menghubungkan pustaka file tunggal untuk login ... Dan pada malam pembukaan kotak pasir tak bertingkat, saya sudah memiliki strategi yang hampir identik pada prinsipnya dengan C ++, tetapi secara signifikan, kode yang jauh lebih besar. <br><br>  Dan kemudian ... Saya mulai mencari tahu pilihan, bagaimana mengembangkannya.  Pikiran saat itu: <br><br><ul><li>  Pencarian untuk negara-negara dunia tidak dapat direduksi menjadi nilai-nilai yang dapat mengalahkan minimax dan modifikasi; </li><li>  Bidang-bidang potensial bagus, tetapi mereka menjawab dengan buruk pertanyaan tentang bagaimana dunia akan mengubah n tick berikutnya; </li><li>  Genetika dan algoritma serupa akan bekerja, tetapi hanya 20 ms yang diberikan per langkah, dan kedalaman perhitungan akan diinginkan, sekilas, lebih dari sensasi yang dapat diproses menggunakan GA.  Ya, dan Anda dapat bermain dengan pemilihan parameter mutasi "bahagia selamanya." </li></ul><br>  Saya pasti memutuskan satu hal: kita perlu melakukan simulasi dunia.  Lagi pula, dapatkah perkiraan perhitungan "mengalahkan" perhitungan yang dingin dan akurat?  Pertimbangan seperti itu, tentu saja, mendorong saya untuk melihat ke dalam kode yang seharusnya bertanggung jawab untuk mensimulasikan dunia di server, karena kali ini dimasukkan ke dalam domain publik bersama dengan aturan.  Lagi pula, tidak ada yang lebih baik daripada kode yang harus secara akurat menggambarkan aturan dunia? <br><br>  Jadi saya berpikir persis sampai saya mulai mempelajari kode yang seharusnya menguji bot kami di server dan secara lokal.  Awalnya, dalam hal pemahaman dan kebenaran kode, semuanya tidak begitu baik, dan panitia, bersama-sama dengan para peserta, mulai secara aktif memprosesnya.  Selama pengujian beta (menangkap beberapa hari setelah itu), perubahan dalam mesin permainan sangat serius, dan banyak yang tidak mulai berpartisipasi sampai saat ketika mesin pengujian tidak stabil.  Tetapi pada akhirnya, menurut saya, mereka menunggu mesin yang bekerja dengan baik untuk permainan yang sangat cocok untuk format kompetisi.  Saya juga tidak mulai menerapkan pendekatan serius sampai pelari lokal stabil, dan untuk minggu pertama tidak ada yang lebih masuk akal dilakukan di bot saya, kecuali untuk visualizer yang kacau. <br><br>  Menjelang akhir pekan pertama di telegram, panitia membuat kelompok terpisah di mana diasumsikan bahwa orang akan dapat membantu memperbaiki dan meningkatkan pelari lokal.  Saya juga mengambil bagian dalam pekerjaan di mesin dunia.  Setelah berdiskusi dalam obrolan ini, sebagai ujian, saya membuat 2 permintaan tarik ke pelari lokal: menyesuaikan formula <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makan</a> (dan perubahan kecil dalam urutan makan) dengan aturan, dan menggabungkan beberapa bagian menjadi satu agaric sambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mempertahankan kelembaman dan pusat massa</a> ).  Kemudian saya mulai berpikir tentang bagaimana memasukkan fisika tabrakan yang waras ke dalam kode ini, karena fisika yang ada di dunia permainan pada saat itu bekerja sangat tidak masuk akal.  Karena tabrakan antara kedua agari tidak dijelaskan dalam aturan, saya meminta panitia untuk kriteria yang menurut saya implementasi logika semacam itu akan dapat diterima.  Jawabannya adalah ini: agari dalam tabrakan harus "lunak" (yaitu, mereka bisa saling bertabrakan sedikit), sedangkan logika tabrakan dengan dinding tidak boleh disentuh (yaitu, dinding hanya harus menghentikan agarics, tetapi tidak mendorong mereka pergi).  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan tarik</a> saya berikutnya adalah perubahan fisika yang serius. <br><br><div class="spoiler">  <b class="spoiler_title">Sebelum dan sesudah perubahan fisika</b> <div class="spoiler_text">  <i>Fisika tabrakan tersebut adalah:</i> <br><img src="https://habrastorage.org/webt/hx/xc/ey/hxxceykf2thwuvqz9eknvhuy9rw.gif" alt="gambar"><br>  <i>Dan dia menjadi begitu setelah pembaruan:</i> <br><img src="https://habrastorage.org/webt/hu/4s/-k/hu4s-kyhokl2-0sotgkuhib2fem.gif" alt="gambar"><br></div></div><br>  Saya juga ingin menyoroti permintaan tarikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , yang secara signifikan mengurangi kode yang membingungkan dengan analisis keadaan dan sejumlah besar bug yang ditemukan (dan potensial) menjadi sesuatu yang jauh lebih dapat dipahami. <br><br><h3>  Menulis simulasi </h3><br>  Setelah membawa kode lokal pelari ke dalam bentuk waras, saya secara bertahap mulai mentransfer kode simulasi dunia dari pelari lokal ke bot saya.  Pertama-tama, tentu saja, itu adalah kode untuk mensimulasikan pergerakan agaric, dan pada saat yang sama merupakan kode untuk menghitung fisika tabrakan.  Butuh beberapa malam untuk menyimpan kode yang didesain ulang dari penulisan ulang bug (transfer logika tidak dilakukan dengan menyalin kode sama sekali) dan perkiraan perkiraan seberapa dalam perhitungan harus dilakukan. <br><br>  Fungsi peringkat untuk setiap centang pada saat itu adalah +1 untuk makanan yang saya makan dan -1 untuk makanan yang dimakan musuh, serta nilai yang sedikit lebih besar untuk makan agariota masing-masing.  Dalam konstanta untuk memakan agaric lain, pada awalnya ada perbedaan antara memakan lawan saya, lawan saya (dan, tentu saja, denda yang sangat besar untuk memakan agarika terakhir saya oleh lawan), serta dua lawan yang berbeda satu sama lain (setelah beberapa hari koefisien terakhir menjadi 0).  Selain itu, kecepatan total untuk semua kutu simulasi sebelumnya, setiap kutu dikalikan dengan 1 + 1e-5 untuk mendorong bot saya melakukan tindakan yang lebih berguna setidaknya sedikit lebih awal, dan pada akhir simulasi, kecepatan untuk kutu terakhir ditambahkan sebagai bonus, juga sangat kecil .  Untuk mensimulasikan pergerakan agaric, titik dipilih di tepi peta dengan langkah 15 derajat dari koordinat rata-rata aritmatika dari semua agari saya, dan sebuah titik dipilih, ketika mensimulasikan gerakan di mana fungsi estimasi mengambil nilai terbesar.  Dan sudah dengan simulasi yang tampaknya primitif dan penilaian sederhana pada saat itu, bot cukup percaya diri menempatkan dirinya di 10 besar. <br><br><div class="spoiler">  <b class="spoiler_title">Demonstrasi poin, perintah gerakan yang awalnya disimulasikan algoritma</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fy/xr/l_/fyxrl_dc2onzsfeij-vmex1qnoc.gif" alt="gambar"><br>  <i>Poin, perintah gerakan yang diberikan selama berbagai simulasi.</i>  <i>Jika Anda melihat sangat dekat - perintah terakhir yang diberikan kadang-kadang bergeser relatif terhadap poin yang dicari, tetapi ini adalah konsekuensi dari perubahan di masa depan.</i> <br></div></div><br>  Pada malam Jumat dan Sabtu, simulasi penggabungan agariat, simulasi “merongrong” virus, dan menebak TTF lawan ditambahkan.  TTF lawan adalah nilai perhitungan yang cukup menarik, dan dimungkinkan untuk memahami pada titik apa lawan membuat virus terbelah atau hanya dengan menangkap momen penerbangan yang tidak terkontrol, yang dapat bertahan dari sejumlah kecil kutu dengan viskositas yang besar dan hingga penerbangan melalui seluruh peta.  Karena tabrakan agaric dapat menyebabkan sedikit kelebihan dari kecepatan maksimum mereka, untuk menghitung TTF lawan, saya memeriksa bahwa kecepatannya dalam dua kutu berturut-turut benar-benar sesuai dengan kecepatan sehingga Anda bisa mendapatkan dua kutu dalam satu baris dalam penerbangan gratis (dalam penerbangan gratis, agari terbang dengan lurus dan dengan memperlambat setiap centang ketat sama dengan viskositas).  Ini hampir sepenuhnya menghilangkan kemungkinan positif palsu.  Juga, selama pengujian logika ini, saya perhatikan bahwa TTF yang lebih besar selalu sesuai dengan id agaric yang lebih besar (yang kemudian saya yakinkan ketika mentransfer kode <a href="">ledakan pada virus</a> dan <a href="">memproses pemisahan</a> ), yang juga layak digunakan. <br><br>  Setelah melihat pemisahan konstan di 3 teratas (yang memungkinkan mereka untuk secara signifikan mengumpulkan makanan di peta), sebagai ujian saya menambahkan perintah split permanen ke bot jika tidak ada musuh dalam radius visibilitas, dan pada hari Minggu pagi saya menemukan bot saya di baris kedua peringkat.  Mengelola beberapa agitator kecil sangat meningkatkan peringkat, tetapi kehilangan mereka jauh lebih mudah jika Anda menemukan lawan.  Dan karena rasa takut dimakan oleh para agiku sangat bersyarat (hukumannya hanya untuk makan dalam simulasi, tetapi tidak untuk mendekati lawan yang bisa makan), hal pertama yang ditambahkan adalah hukuman karena menyeberang dengan lawan yang bisa makan.  Dan penilaian yang sama ini bekerja seperti bonus untuk mengejar lawan.  Setelah memeriksa konsumsi CPU dengan strategi saya, saya memutuskan untuk menambahkan satu putaran simulasi lagi ketika split dilakukan pada centang pertama (logika ini, tentu saja, juga harus ditransfer ke kode saya dari pelari lokal), dan kemudian simulasi berjalan persis sama seperti sebelumnya .  Logika semacam ini sangat tidak cocok untuk "menembak" musuh (meskipun kadang-kadang secara tidak sengaja itu terpecah pada saat yang sangat cocok), tetapi itu sangat baik untuk mengumpulkan makanan lebih cepat, yang merupakan apa yang dilakukan seluruh pasukan pada waktu itu.  Modifikasi semacam itu memungkinkan kami untuk memasuki minggu berikutnya pada baris pertama peringkat, meskipun marginnya tidak signifikan. <br><br>  Pada saat itu, ini sudah cukup, "tulang punggung" dari strategi itu berhasil, strategi itu terlihat sangat primitif dan dapat diperluas.  Tapi yang benar-benar saya perhatikan adalah konsumsi CPU dan stabilitas kode secara keseluruhan.  Oleh karena itu, terutama malam hari bagian kerja berikutnya dari minggu ini ditujukan untuk meningkatkan akurasi simulasi (yang mana visualizer banyak membantu), menstabilkan kode (valgrind) dan beberapa optimisasi kecepatan kerja. <br><br><h3>  Mari kita lanjutkan </h3><br>  Strategi pengiriman saya berikutnya, yang menunjukkan hasil yang jauh lebih baik dan lebih maju dari lawan (pada waktu itu), berisi dua perubahan signifikan: menambahkan bidang potensial untuk mengumpulkan makanan dan menggandakan jumlah simulasi jika ada lawan dengan TTF yang tidak diketahui di dekatnya. <br><br>  Bidang potensial untuk mengumpulkan makanan dalam versi pertama cukup sederhana dan intinya adalah untuk mengingat makanan yang hilang dari zona visibilitas, mengurangi potensi di tempat-tempat di dekat bot musuh dan memusatkan perhatian pada zona visibilitas saya (dengan pemulihan berikutnya setiap saat). kutu sesuai dengan aturan).  Ini sepertinya perbaikan yang bermanfaat, tetapi dalam praktiknya, menurut pendapat subjektif saya, perbedaannya kecil atau sama sekali tidak ada.  Misalnya, pada kartu dengan inersia dan kecepatan tinggi, bot sering melewatkan makanan masa lalu dan kemudian mencoba untuk kembali ke sana, sementara kehilangan banyak kecepatan.  Namun, jika dia memutuskan untuk mempertahankan kecepatan dan mengabaikan makanan yang dilewati, dia akan makan lebih banyak. <br><br><div class="spoiler">  <b class="spoiler_title">Bidang pengumpulan makanan potensial</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/aw/ae/lg/awaelgpt4zl98lgdjfr1rvk53so.gif" alt="gambar"><br>  <i>Anda bisa memperhatikan bagaimana setiap 40 kutu bidang menjadi sedikit lebih cerah.</i>  <i>Setiap 40 kutu, bidang diperbarui sesuai dengan bagaimana makanan ditambahkan pada peta, dan kemungkinan makanan muncul secara merata "dioleskan" di seluruh bidang.</i>  <i>Jika pada kutu ini kita melihat bahwa ada makanan yang akan kita lihat pada kutu sebelumnya - probabilitas munculnya makanan ini tidak "dioleskan" dengan yang lain, tetapi ditentukan oleh titik-titik tertentu (makanan muncul setiap 40 kutu secara simetris ketat).</i> <br></div></div><br>  Utilitas subyektif yang sama sekali berbeda ternyata merupakan simulasi ganda musuh dengan TTF yang berbeda - minimum dan maksimum yang mungkin (dalam kasus saya tidak tahu TTF untuk semua agari terlihat di peta).  Dan jika sebelumnya bot saya berpikir bahwa kumpulan musuh agarics akan menjadi satu kesatuan dan bergerak perlahan, maka sekarang dia memilih yang terburuk dari dua skenario dan tidak mengambil risiko dekat dengan musuh, tentang siapa yang dia tahu lebih sedikit daripada yang dia inginkan. <br><br>  Setelah mendapatkan keuntungan yang signifikan, saya mencoba meningkatkannya dengan menambahkan definisi tentang titik di mana lawan memerintahkan agaranya untuk bergerak, dan meskipun titik ini dihitung dalam kebanyakan kasus dengan cukup akurat, ini saja tidak meningkatkan hasil bot.  Menurut pengamatan saya, itu menjadi lebih buruk daripada kasus ketika agari lawan hanya bergerak ke arah yang sama dan dengan kecepatan yang sama seolah-olah lawan tidak melakukan apa-apa, jadi suntingan ini disimpan di cabang gitar yang terpisah sampai waktu yang lebih baik. <br><br><div class="spoiler">  <b class="spoiler_title">Definisi tim lawan yang digunakan kemudian</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8l/vx/ac/8lvxacnkg_w4byrrkka9znflham.gif" alt="gambar"><br>  <i>Sinar dari agarics lawan menunjukkan dugaan tim yang diberikan lawan pada agarics mereka pada tick sebelumnya.</i>  <i>Sinar biru adalah arah yang tepat di mana agarik berubah arah pada centang terakhir.</i>  <i>Hitam yang dimaksud.</i>  <i>Dimungkinkan untuk lebih akurat menentukan arah tim hanya jika agar benar-benar berada di zona visibilitas kami (adalah mungkin untuk menghitung efek tabrakan terhadap perubahan kecepatannya).</i>  <i>Perpotongan sinar adalah tim lawan yang dituju.</i>  <i>Gif dibuat berdasarkan game <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aicups.ru/session/200710</a> , sekitar 3.000 kutu.</i> <br></div></div><br>  Ada juga upaya untuk mentransfer fungsi evaluasi ke penilaian massa yang diperoleh, upaya untuk mengubah fungsi mengevaluasi bahaya lawan ... Tapi sekali lagi, semua perubahan perasaan seperti itu menjadi lebih buruk.  Satu-satunya hal yang berguna dengan fungsi menilai bahaya dari menjadi dekat dengan musuh adalah optimasi kinerja lain bersama dengan memperluas perkiraan ini ke jari-jari yang jauh lebih besar daripada jari-jari persimpangan dengan musuh (pada dasarnya seluruh peta, tetapi dengan penurunan kuadrat, jika sedikit disederhanakan - membuat kehadiran dalam lima jari-jari atau lebih dari lawan di wilayah 1/25 dari bahaya maksimum dimakan).  Perubahan terakhir juga tidak terencana menyebabkan fakta bahwa agariks saya menjadi sangat takut untuk mendekati musuh yang jauh lebih besar, serta dalam hal ukuran mereka yang sangat superior lebih cenderung bergerak ke arah lawan.  Jadi, itu ternyata menjadi pengganti yang sukses dan tidak intensif sumber daya untuk kode yang direncanakan untuk masa depan, yang seharusnya bertanggung jawab atas ketakutan serangan oleh lawan melalui perpecahan (dan sedikit bantuan dalam serangan seperti itu kepada saya nanti). <br><br>  Setelah upaya yang lama dan relatif sia-sia untuk meningkatkan sesuatu, saya kembali lagi untuk memprediksi arah gerakan lawan.  Saya memutuskan untuk mencobanya jika bukan hanya untuk mengganti saingan tiruan, kemudian lakukan seperti yang saya lakukan dengan opsi TTF minimum dan maksimum - mensimulasikan dua kali dan memilih yang terbaik.  Tetapi untuk ini, CPU mungkin tidak cukup, dan dalam banyak game bot saya, mereka hanya bisa terputus dari sistem karena selera yang tak terpuaskan.  Oleh karena itu, sebelum menerapkan opsi ini, saya menambahkan definisi perkiraan waktu yang dihabiskan dan, jika batas terlampaui, saya mulai mengurangi jumlah gerakan simulasi.  Dengan menambahkan simulasi ganda musuh untuk kasus ketika saya tahu tempat di mana dia menuju, saya lagi menerima peningkatan yang agak serius di sebagian besar pengaturan permainan, kecuali untuk yang paling intensif sumber daya (dengan inersia tinggi / kecepatan rendah / viskositas rendah), yang disebabkan oleh penurunan kedalaman yang kuat Simulasi bisa menjadi sedikit lebih buruk. <br><br>  Sebelum dimulainya pertandingan kutu 25k, dua perbaikan lebih bermanfaat dibuat: penalti untuk mengakhiri simulasi jauh dari pusat peta, serta mengingat posisi lawan sebelumnya jika ia meninggalkan garis pandang (serta mensimulasikan gerakannya pada saat itu).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi penalti untuk posisi akhir bot dalam simulasi adalah medan bahaya statis yang sudah dihitung sebelumnya dengan nol bahaya dalam radius sedikit lebih besar dari setengah panjang lapangan bermain dan secara bertahap meningkat ketika bergerak menjauh dari lapangan bermain. Penerapan denda bidang ini pada titik akhir simulasi hampir tidak memerlukan CPU dan mencegah berjalan ekstra ke sudut-sudut, kadang-kadang menyelamatkan dari serangan musuh. Dan menghafal dengan simulasi rival berikutnya untuk sebagian besar memungkinkan kita untuk menghindari dua masalah yang kadang-kadang terwujud. Masalah pertama disajikan dalam GIF di bawah ini. Masalah kedua adalah bahwa jika musuh yang lebih besar hilang dari bidang pandang (misalnya, setelah penggabungan bagian-bagiannya), adalah mungkin untuk "berhasil" menyatukannya, juga memberi makan lawan yang sudah berbahaya.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh bidang bahaya di ujung belokan di sudut dan kutu terbuang</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rc/qc/7s/rcqc7st4c0xmmzn038tl7eiuxrm.png"><br> <i>      ,         </i> <br><img src="https://habrastorage.org/webt/r_/qm/zx/r_qmzxmxzysmrityd6sld0yjhlw.gif" alt="gambar"><br> <i>  ,       .      ,      .</i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, titik-titik simulasi gerakan ditambahkan ke titik-titik di tepi peta: ke setiap agarik saingan dan dalam radius koordinat rata-rata aritmatika dari agariki saya setiap 45 derajat. </font><font style="vertical-align: inherit;">Jari-jari diatur ke avgDistance dari koordinat rata-rata aritmatika dari agarics saya.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin Simulasi Baru</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1g/tp/s0/1gtps0pna1gmgquavh75h2ta-jc.gif" alt="gambar"><br> <i>        .       «»   ,   .       .</i> <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persiapan akhir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada saat pembukaan permainan untuk kutu 25k dan lolos ke final, saya memiliki margin yang kuat, tetapi saya tidak berencana untuk bersantai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seiring dengan permainan 25k baru, berita datang: permainan selama final juga akan panjang 25k, dan batas waktu strategi untuk kutu telah menjadi sedikit lebih. </font><font style="vertical-align: inherit;">Setelah mengevaluasi waktu yang dihabiskan strategi saya untuk permainan dalam kondisi baru, saya memutuskan untuk menambahkan versi lain dari simulasi: kami melakukan semuanya seperti biasa, tetapi selama simulasi saat bepergian dan melakukan split. </font><font style="vertical-align: inherit;">Ini, antara lain, membutuhkan penggunaan simulasi yang ditemukan pada langkah sebelumnya, tetapi dengan pergeseran 1 langkah (misalnya, jika kami menemukan bahwa memisahkan 7 kutu dari yang sekarang, maka langkah selanjutnya kami ulangi hal yang sama, tetapi kami sudah melakukan split pada langkah ke-6). </font><font style="vertical-align: inherit;">Ini secara signifikan menambahkan serangan agresif pada saingan, tetapi memakan lebih banyak waktu strategi.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seharusnya ada deskripsi singkat dari algoritma</font></font></b> <div class="spoiler_text"> <i>   </i> <br><br>  : <br><img src="https://habrastorage.org/webt/nr/we/mj/nrwemjif4m5vgis-dy_r6shmc3u.gif"><br><ul><li> f — ,            ; </li><li> sim —        (  ,  , TTF ,     ); </li><li> finalPositionFoodPotentialField —   ,   ,    ; </li><li> finalPositionCornerDanger —        .        ,         ; </li><li> n — ,         .  10   50 ; </li><li> ateFood —         i; </li><li> virusBurst —            i; </li><li> opponentAteFood —        i; </li><li> meAteOpponent —      ; </li><li> opponentAteMe —      ; </li><li> mine/opponents —     .  Yaitu          —      ; </li><li> danger —  ,   ,     . </li></ul><br><br><img src="https://habrastorage.org/webt/xu/0b/vq/xu0bvqxveolkicxieftkfrmuv5u.gif"><br><ul><li> moveType —    ,        ; </li><li> max/min TTF —   ,        TTF   (    TTF ); </li><li> dummy/aim —      Dummy         (    ,          ). </li></ul><br><br><img src="https://habrastorage.org/webt/kr/cn/vl/krcnvlbbrj1eyfcai1abuv4o4pi.gif"><br><ul><li> destination — ,         ; </li><li> moveTo —  ,   n    “   ”   ; </li><li> splitThenMove —       split   ; </li><li> delayedSplitThenMove —  ,  split    . </li></ul><br><br>             1 .  Yaitu  splitThenMove    moveTo, delayedSplitThenMove      7  6 ,      6  5  ..     ,     —               7 .                . <br><br>  destination : <br><ul><li>      15       ( —  ).  24      ; </li><li>  ,       (    ); </li><li>         : </li><li> “”     ,       ; </li><li>  8   .             . </li></ul><br>    destination     ,              . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua penyempurnaan lebih lanjut secara eksklusif terkait dengan efisiensi simulasi jika terjadi kekurangan TL: optimisasi urutan pemutusan bagian-bagian tertentu dari logika tergantung pada CPU yang dikonsumsi. </font><font style="vertical-align: inherit;">Di sebagian besar gim, ini tidak seharusnya mengubah apa pun, tetapi menghasilkan sesuatu yang lebih benar maka tidak berhasil.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin terakhir di final</font></font></b> <div class="spoiler_text"> <i>          .  808       2424 ,     . <s>   .</s></i> <br> <a href=""><img src="https://habrastorage.org/webt/ij/bi/qf/ijbiqfz4pmd8je8ps7qfvird4pi.png"></a> <br></div></div><br><h4>  Alih-alih sebuah kesimpulan </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, awal kompetisi ini ternyata agak berminyak, tetapi dalam satu setengah minggu pertama tugas dibawa ke bentuk yang cukup dimainkan dengan bantuan para peserta. </font><font style="vertical-align: inherit;">Awalnya, tugas itu sangat bervariasi, dan memilih pendekatan yang tepat untuk menyelesaikannya tidak tampak seperti tugas yang sepele. </font><font style="vertical-align: inherit;">Yang lebih menarik adalah menemukan cara untuk meningkatkan algoritme tanpa terbang melebihi batas konsumsi CPU. </font><font style="vertical-align: inherit;">Banyak terima kasih kepada penyelenggara untuk kompetisi dan untuk meletakkan kode sumber dunia untuk akses terbuka. </font><font style="vertical-align: inherit;">Yang terakhir, tentu saja, sangat menambah masalah bagi mereka di awal, tetapi sangat memudahkan (jika tidak dikatakan, yang memungkinkan pada prinsipnya) pemahaman peserta tentang perangkat simulator dunia. </font><font style="vertical-align: inherit;">Terima kasih khusus atas kesempatan untuk memilih hadiah! </font><font style="vertical-align: inherit;">Jadi hadiahnya keluar jauh lebih berguna :-) </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa saya perlu MacBook lain?</font></font></s> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420737/">https://habr.com/ru/post/id420737/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420715/index.html">Kebenaran sulit tentang beratnya belajar</a></li>
<li><a href="../id420725/index.html">Bagaimana saya mengajar AI bermain Tetris untuk NES. Bagian 1: analisis kode permainan</a></li>
<li><a href="../id420729/index.html">Buka webinar "Naive Bayes Classifier"</a></li>
<li><a href="../id420731/index.html">Zabbix tentang steroid: cara kerja platform pemantauan terpadu Sbertech</a></li>
<li><a href="../id420735/index.html">Kami mengundang Anda ke final marathon Find Yourself in Digital di kantor Mail.Ru Group</a></li>
<li><a href="../id420739/index.html">Kotaknya masih ada di pegangan: mengapa pada tahun 2018 Anda masih perlu belajar bahasa sendiri</a></li>
<li><a href="../id420741/index.html">Lembar cheat untuk programmer atau "kami akan google untuk Anda"</a></li>
<li><a href="../id420749/index.html">GitLab untuk Proyek Pengiriman Berkelanjutan pada Teknologi InterSystems: Kontainer</a></li>
<li><a href="../id420753/index.html">Microservice frontend - pendekatan modern untuk pemisahan bagian depan</a></li>
<li><a href="../id420757/index.html">Kontes Pemrograman: Perdagangan (Hasil)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>