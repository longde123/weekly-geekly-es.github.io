<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüåæ üë©üèº‚Äçüíª üôåüèø Verwenden der Partitionierung in MySQL f√ºr Zabbix mit einer gro√üen Anzahl von √úberwachungsobjekten üë∏üèΩ ‚òïÔ∏è üï∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr die √úberwachung von Servern und Diensten setzen wir seit langem erfolgreich eine kombinierte L√∂sung ein, die auf Nagios und Munin basiert. Dieser ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden der Partitionierung in MySQL f√ºr Zabbix mit einer gro√üen Anzahl von √úberwachungsobjekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lenvendo/blog/480082/">  F√ºr die √úberwachung von Servern und Diensten setzen wir seit langem erfolgreich eine kombinierte L√∂sung ein, die auf Nagios und Munin basiert.  Dieser Haufen hat jedoch eine Reihe von Nachteilen, so dass wir, wie viele, <a href="https://www.zabbix.com/">Zabbix</a> aktiv ausnutzen.  In diesem Artikel werden wir dar√ºber sprechen, wie Sie das Leistungsproblem mit minimalem Aufwand l√∂sen k√∂nnen, wenn Sie die Anzahl der entfernten Metriken erh√∂hen und das Volumen der MySQL-Datenbank erh√∂hen <br><a name="habracut"></a><br><h3>  Probleme bei der Verwendung einer MySQL-Datenbank mit Zabbix </h3><br>  Obwohl die Datenbank klein und die Anzahl der darin gespeicherten Metriken gering war, war alles wunderbar.  Der regul√§re Housekeeper-Prozess, mit dem Zabbix Server selbst gestartet wird, hat veraltete Datens√§tze erfolgreich aus der Datenbank gel√∂scht und verhindert, dass sie gr√∂√üer werden.  Sobald jedoch die Anzahl der erfassten Metriken anstieg und die Datenbankgr√∂√üe eine bestimmte Gr√∂√üe erreichte, wurde alles schlechter.  Die Haush√§lterin schaffte es nicht mehr, Daten f√ºr das zugewiesene Zeitintervall zu l√∂schen, und die alten Daten blieben in der Datenbank.  W√§hrend des Betriebs der Haush√§lterin war der Zabbix-Server einer erh√∂hten Belastung ausgesetzt, die lange anhalten konnte.  Es wurde klar, dass es notwendig war, die aktuelle Situation irgendwie zu l√∂sen. <br><br>  Dies ist ein bekanntes Problem. Fast alle, die mit gro√üen √úberwachungsmengen auf Zabbix arbeiteten, sahen sich mit dem gleichen Problem konfrontiert.  Es gab auch mehrere L√∂sungen: Zum Beispiel das Ersetzen von MySQL durch PostgreSQL oder sogar Elasticsearch. Die einfachste und bew√§hrte L√∂sung bestand jedoch darin, auf Partitionstabellen zu wechseln, in denen Metrikdaten in der MySQL-Datenbank gespeichert sind.  Wir haben uns f√ºr diesen Weg entschieden. <br><br><h3>  Migration von regul√§ren MySQL-Tabellen auf partitionierte </h3><br>  Zabbix ist gut dokumentiert und die Tabellen, in denen Metriken gespeichert werden, sind bekannt.  Dies sind Tabellen: <code>history</code> , in denen float-Werte gespeichert werden, <code>history_str</code> , in denen kurze Zeichenfolgenwerte gespeichert werden, <code>history_text</code> , in denen lange <code>history_uint</code> gespeichert werden, und <code>history_uint</code> , in denen ganzzahlige Werte gespeichert werden.  Es gibt auch eine <code>trends</code> , in der die Dynamik von √Ñnderungen gespeichert ist. Wir haben jedoch beschlossen, sie nicht zu ber√ºhren, da sie klein ist und wir etwas sp√§ter darauf zur√ºckkommen werden. <br><br>  Im Allgemeinen war klar, welche Tabellen verarbeitet werden mussten.  Wir haben beschlossen, Partitionen f√ºr jede Woche, mit Ausnahme der letzten, basierend auf den Zahlen des Monats, d. H.  vier Partitionen pro Monat: vom 1. bis zum 7., vom 8. bis zum 14., vom 15. bis zum 21. und vom 22. bis zum 1. (n√§chster Monat).  Die Schwierigkeit bestand darin, dass wir die ben√∂tigten Tabellen sofort in partitionierte Tabellen umwandeln mussten, ohne Zabbix Server zu unterbrechen und Messdaten zu erfassen. <br><br>  Seltsamerweise hat uns dabei die Struktur dieser Tabellen geholfen.  Die <code>history</code> hat beispielsweise die folgende Struktur: <br><br><pre> <code class="sql hljs">`itemid` bigint(20) unsigned NOT NULL, `clock` int(11) NOT NULL DEFAULT '0', `value` double(16,4) NOT NULL DEFAULT '0.0000', `ns` int(11) NOT NULL DEFAULT '0',</code> </pre> <br>  dabei <br><br><pre> <code class="sql hljs">KEY `history_1` (`itemid`,`clock`)</code> </pre> <br>  Wie Sie sehen, wird jede Metrik schlie√ülich in eine Tabelle mit zwei sehr wichtigen und f√ºr uns praktischen Feldern <b>itemid</b> und <b>clock</b> eingegeben.  So k√∂nnen wir beispielsweise eine tempor√§re Tabelle mit dem Namen <code>history_tmp</code> , eine <code>history_tmp</code> daf√ºr einrichten und dann alle Daten aus der <code>history</code> dorthin √ºbertragen und dann die <code>history</code> in <code>history_old</code> und die <code>history_tmp</code> Tabelle in <code>history</code> umbenennen und dann die Daten hinzuf√ºgen die wir von <code>history_old</code> zu <code>history</code> <code>history_old</code> <code>history</code> und <code>history_old</code> l√∂schen.  Sie k√∂nnen dies v√∂llig sicher tun, wir verlieren nichts, da die oben angegebenen Felder <b>itemid</b> und <b>clock</b> eine Verbindungsmetrik zu einer bestimmten Zeit und nicht zu einer Art Seriennummer enthalten. <br><br><h3>  Der √úbergangsprozess selbst </h3><br><blockquote>  Achtung!  Es ist sehr w√ºnschenswert, vor dem Starten einer Aktion eine vollst√§ndige Sicherung von der Datenbank durchzuf√ºhren.  Wir sind alle lebende Menschen und k√∂nnen Fehler in den Befehlen machen, die zu Datenverlust f√ºhren k√∂nnen.  Ja  Eine Sicherungskopie bietet keine maximale Relevanz, es ist jedoch besser, eine als keine zu haben. </blockquote>  Schalten Sie also nichts aus oder h√∂ren Sie nicht auf.  Die Hauptsache ist, dass auf dem MySQL-Server selbst gen√ºgend freier Speicherplatz vorhanden sein sollte, d. H.  Damit f√ºr jede der obigen Tabellen <code>history</code> , <code>history_text</code> , <code>history_str</code> , <code>history_uint</code> mindestens gen√ºgend Speicherplatz vorhanden ist, um eine Tabelle mit dem Suffix "_tmp" zu erstellen, <code>history_str</code> , sie <code>history_uint</code> der urspr√ºnglichen Tabelle. <br><br>  Wir werden nicht mehrmals alles f√ºr jede der obigen Tabellen beschreiben und alles am Beispiel von nur einer davon betrachten - der <code>history</code> . <br><br>  Erstellen Sie daher eine leere <code>history_tmp</code> Tabelle basierend auf der Struktur der <code>history</code> Tabelle. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span>;</code> </pre> <br>  Wir erstellen die Partitionen, die wir brauchen.  Lassen Sie es uns zum Beispiel einen Monat lang tun.  Jede Partition wird basierend auf der Partitionsregel erstellt, basierend auf dem Wert des <b>Uhrfelds</b> , das wir mit dem Zeitstempel vergleichen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANGE</span></span>( clock ) ( <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-01 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190207 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-07 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190214 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-14 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190221 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-21 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190301 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-01 00:00:00"</span></span>)) );</code> </pre> <br>  Dieser Operator f√ºgt der <code>history_tmp</code> uns erstellten Tabelle <code>history_tmp</code> eine Partitionierung hinzu.  Lassen Sie uns klarstellen, dass die Daten, f√ºr die der Wert des Uhrfelds kleiner als "2019-02-01 00:00:00" ist, in die Partition <i>p20190201 fallen</i> , dann die Daten, f√ºr die der Wert des Uhrfelds gr√∂√üer als "2019-02-01 00:00:00" ist, aber kleiner "2019-02-07 00:00:00" f√§llt in die <i>Gruppe p20190207</i> und so weiter. <br><blockquote>  <b>Wichtiger Hinweis:</b> Und was passiert, wenn die partitionierte Tabelle Daten enth√§lt, deren Wert im Uhrfeld gr√∂√üer oder gleich "2019-03-01 00:00:00" ist?  Da es f√ºr diese Daten keine geeignete Partition gibt, fallen sie nicht in die Tabelle und gehen verloren.  Daher d√ºrfen Sie nicht vergessen, rechtzeitig zus√§tzliche Partitionen zu erstellen, um einen solchen Datenverlust (√ºber den weiter unten berichtet wird) zu vermeiden. </blockquote>  Damit ist der tempor√§re Tisch vorbereitet.  F√ºllen Sie die Daten.  Der Vorgang kann ziemlich lange dauern, blockiert aber gl√ºcklicherweise keine weiteren Anforderungen, sodass Sie nur Geduld haben m√ºssen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history;</code> </pre> <br>  Das Schl√ºsselwort IGNORE wird beim erstmaligen Ausf√ºllen nicht ben√∂tigt, da die Tabelle noch keine Daten enth√§lt. Sie ben√∂tigen diese jedoch, wenn Sie Daten hinzuf√ºgen.  Au√üerdem kann es hilfreich sein, wenn Sie diesen Vorgang unterbrechen und beim Ausf√ºllen der Daten erneut starten m√ºssen. <br><br>  Nach einiger Zeit (vielleicht sogar ein paar Stunden) ist der erste Datenupload abgeschlossen.  Wie Sie verstehen, enth√§lt die <code>history_tmp</code> Tabelle jetzt nicht alle Daten aus der <code>history</code> Tabelle, sondern nur die Daten, die sich zum Zeitpunkt des Abfragestarts darin befanden.  Tats√§chlich haben Sie hier die Wahl: Entweder machen wir einen weiteren Durchgang (wenn der F√ºllvorgang lange gedauert hat), oder wir benennen die oben genannten Tabellen sofort um.  Nehmen wir zuerst den zweiten Durchgang.  Zuerst m√ºssen wir die Zeit des zuletzt eingef√ºgten Datensatzes in <code>history_tmp</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  Angenommen, Sie erhalten: <b>1551045645</b> .  Jetzt verwenden wir den erhaltenen Wert im zweiten Durchgang der Datenf√ºllung: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Diese Passage sollte viel schneller enden.  Wenn der erste Durchgang jedoch stundenlang und der zweite auch √ºber einen l√§ngeren Zeitraum durchgef√ºhrt wurde, ist es m√∂glicherweise richtig, den dritten Durchgang durchzuf√ºhren, der dem zweiten Durchgang vollst√§ndig √§hnlich ist. <br><br>  Am Ende f√ºhren wir den Vorgang zum <code>history_tmp</code> des Zeitpunkts der letzten Einf√ºgung des Datensatzes in <code>history_tmp</code> indem wir <code>history_tmp</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  <b>Angenommen</b> , Sie haben <b>1551085645</b> .  Behalten Sie diesen Wert bei - wir werden ihn zum Nachf√ºllen ben√∂tigen. <br><br>  Und jetzt, wenn die prim√§ren Daten in <code>history_tmp</code> , benennen wir die Tabellen um: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history_old; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history_tmp <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br>  Wir haben diesen Block als eine Transaktion konzipiert, um zu vermeiden, dass Daten in eine nicht vorhandene Tabelle eingef√ºgt werden, da die Verlaufstabelle nach dem ersten RENAME bis zum zweiten RENAME nicht vorhanden ist.  Aber selbst wenn einige Daten zwischen den RENAME-Vorg√§ngen in der <code>history</code> eingehen und die Tabelle selbst noch nicht existiert (aufgrund von Umbenennungen), wird eine kleine Anzahl von Einf√ºgefehlern angezeigt, die vernachl√§ssigt werden k√∂nnen (wir haben √úberwachung, nicht die Bank). <br><br>  Jetzt haben wir eine neue <code>history</code> mit Partitionierung, aber sie enth√§lt nicht gen√ºgend Daten, die beim letzten Durchlauf des Einf√ºgens von Daten in die <code>history_tmp</code> Tabelle <code>history_tmp</code> .  Aber wir haben diese Daten in der Tabelle <code>history_old</code> und teilen sie jetzt von dort aus.  Daf√ºr ben√∂tigen wir den zuvor gespeicherten Wert 1551085645. Warum haben wir diesen Wert gespeichert und die maximale F√ºllzeit nicht bereits aus der aktuellen <code>history</code> ?  Weil neue Daten bereits eingehen und wir die falsche Zeit bekommen.  Also messen wir die Daten: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_old <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Nach dem Ende dieses Vorgangs befinden sich in der neuen, partitionierten <code>history</code> alle Daten, die in der alten Tabelle enthalten waren, sowie die Daten, die nach dem Umbenennen der Tabelle eingegangen sind.  Die Tabelle <code>history_old</code> wird nicht mehr ben√∂tigt.  Sie k√∂nnen es sofort l√∂schen oder eine Sicherungskopie davon erstellen (falls Sie Paranoia haben), bevor Sie es l√∂schen. <br><br>  Der gesamte oben beschriebene Prozess muss f√ºr die <code>history_uint</code> <code>history_str</code> , <code>history_text</code> und <code>history_uint</code> . <br><br><h3>  Was muss in den Zabbix Server-Einstellungen behoben werden? </h3><br>  Jetzt liegt die Pflege der Datenbank zur Datenhistorie auf unseren Schultern.  Dies bedeutet, dass Zabbix keine alten Daten mehr l√∂schen sollte - wir werden es selbst tun.  Damit Zabbix Server nicht versucht, die Daten selbst zu bereinigen, m√ºssen Sie zur Zabbix-Weboberfl√§che gehen, im Men√º "Administration", dann im Untermen√º "Allgemein" und rechts in der Dropdown-Liste "Verlauf l√∂schen" ausw√§hlen.  Deaktivieren Sie auf der angezeigten Seite alle Kontrollk√§stchen f√ºr die Gruppe "Verlauf" und klicken Sie auf die Schaltfl√§che "Aktualisieren".  Auf diese Weise wird verhindert, dass <code>history*</code> -Tabellen von uns durch die Haush√§lterin bereinigt werden. <br><br>  Beachten Sie auf derselben Seite die Gruppe ‚ÄûDynamik der Ver√§nderungen‚Äú.  Dies ist nur die <code>trends</code> , zu der wir versprochen haben, zur√ºckzukehren.  Wenn es auch f√ºr Sie zu gro√ü geworden ist und partitioniert werden muss, deaktivieren Sie auch diese Gruppe und verarbeiten Sie diese Tabelle genau wie f√ºr <code>history*</code> -Tabellen. <br><br><h3>  Weitere Datenbankpflege </h3><br>  Wie bereits erw√§hnt, ist es f√ºr den normalen Betrieb in partitionierten Tabellen erforderlich, Partitionen rechtzeitig zu erstellen.  Du kannst das so machen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190307 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-07 00:00:00"</span></span>)));</code> </pre> <br>  Da wir partitionierte Tabellen erstellt und Zabbix Server verboten haben, diese zu bereinigen, ist das L√∂schen alter Daten nun unser Anliegen.  Zum Gl√ºck gibt es √ºberhaupt keine Probleme.  Dies geschieht einfach durch L√∂schen der Partition, deren Daten wir nicht mehr ben√∂tigen. <br><br>  Zum Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201;</code> </pre> <br>  Im Gegensatz zu DELETE FROM-Anweisungen mit einem Datumsbereich wird DROP PARTITION in wenigen Sekunden ausgef√ºhrt, l√§dt den Server √ºberhaupt nicht und funktioniert bei Verwendung der Replikation in MySQL genauso reibungslos. <br><br><h3>  Fazit </h3><br>  Die beschriebene L√∂sung hat sich bew√§hrt.  Das Datenvolumen w√§chst, es ist jedoch kein Leistungsabfall festzustellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480082/">https://habr.com/ru/post/de480082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480070/index.html">Vorteile reagieren: Ein Segen f√ºr Unternehmen?</a></li>
<li><a href="../de480072/index.html">Kubernetes: Warum ist es so wichtig, ein Systemressourcenmanagement einzurichten?</a></li>
<li><a href="../de480076/index.html">Multiprocessing und Abgleich von Daten aus verschiedenen Quellen</a></li>
<li><a href="../de480078/index.html">Neue Front-End-Bibliotheken bei React Peripherals</a></li>
<li><a href="../de480080/index.html">Was ben√∂tigen Sie f√ºr Notizen?</a></li>
<li><a href="../de480086/index.html">Wie Sie die Anforderungen von 152-FZ erf√ºllen, die pers√∂nlichen Daten unserer Kunden sch√ºtzen und nicht auf unseren Rechen treten</a></li>
<li><a href="../de480088/index.html">DevOps - OK, aber was tun? So reduzieren Sie die Handarbeit und erzielen das gew√ºnschte Ergebnis</a></li>
<li><a href="../de480090/index.html">Open Source ist alles</a></li>
<li><a href="../de480092/index.html">So l√∂sen Sie das Problem der Audioerkennung auf GO</a></li>
<li><a href="../de480096/index.html">Ende der Kindheit: Urheberrecht an Werken k√ºnstlicher Intelligenz (KI)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>