<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 👩🏼‍💻 🙌🏿 Verwenden der Partitionierung in MySQL für Zabbix mit einer großen Anzahl von Überwachungsobjekten 👸🏽 ☕️ 🕺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Für die Überwachung von Servern und Diensten setzen wir seit langem erfolgreich eine kombinierte Lösung ein, die auf Nagios und Munin basiert. Dieser ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden der Partitionierung in MySQL für Zabbix mit einer großen Anzahl von Überwachungsobjekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lenvendo/blog/480082/">  Für die Überwachung von Servern und Diensten setzen wir seit langem erfolgreich eine kombinierte Lösung ein, die auf Nagios und Munin basiert.  Dieser Haufen hat jedoch eine Reihe von Nachteilen, so dass wir, wie viele, <a href="https://www.zabbix.com/">Zabbix</a> aktiv ausnutzen.  In diesem Artikel werden wir darüber sprechen, wie Sie das Leistungsproblem mit minimalem Aufwand lösen können, wenn Sie die Anzahl der entfernten Metriken erhöhen und das Volumen der MySQL-Datenbank erhöhen <br><a name="habracut"></a><br><h3>  Probleme bei der Verwendung einer MySQL-Datenbank mit Zabbix </h3><br>  Obwohl die Datenbank klein und die Anzahl der darin gespeicherten Metriken gering war, war alles wunderbar.  Der reguläre Housekeeper-Prozess, mit dem Zabbix Server selbst gestartet wird, hat veraltete Datensätze erfolgreich aus der Datenbank gelöscht und verhindert, dass sie größer werden.  Sobald jedoch die Anzahl der erfassten Metriken anstieg und die Datenbankgröße eine bestimmte Größe erreichte, wurde alles schlechter.  Die Haushälterin schaffte es nicht mehr, Daten für das zugewiesene Zeitintervall zu löschen, und die alten Daten blieben in der Datenbank.  Während des Betriebs der Haushälterin war der Zabbix-Server einer erhöhten Belastung ausgesetzt, die lange anhalten konnte.  Es wurde klar, dass es notwendig war, die aktuelle Situation irgendwie zu lösen. <br><br>  Dies ist ein bekanntes Problem. Fast alle, die mit großen Überwachungsmengen auf Zabbix arbeiteten, sahen sich mit dem gleichen Problem konfrontiert.  Es gab auch mehrere Lösungen: Zum Beispiel das Ersetzen von MySQL durch PostgreSQL oder sogar Elasticsearch. Die einfachste und bewährte Lösung bestand jedoch darin, auf Partitionstabellen zu wechseln, in denen Metrikdaten in der MySQL-Datenbank gespeichert sind.  Wir haben uns für diesen Weg entschieden. <br><br><h3>  Migration von regulären MySQL-Tabellen auf partitionierte </h3><br>  Zabbix ist gut dokumentiert und die Tabellen, in denen Metriken gespeichert werden, sind bekannt.  Dies sind Tabellen: <code>history</code> , in denen float-Werte gespeichert werden, <code>history_str</code> , in denen kurze Zeichenfolgenwerte gespeichert werden, <code>history_text</code> , in denen lange <code>history_uint</code> gespeichert werden, und <code>history_uint</code> , in denen ganzzahlige Werte gespeichert werden.  Es gibt auch eine <code>trends</code> , in der die Dynamik von Änderungen gespeichert ist. Wir haben jedoch beschlossen, sie nicht zu berühren, da sie klein ist und wir etwas später darauf zurückkommen werden. <br><br>  Im Allgemeinen war klar, welche Tabellen verarbeitet werden mussten.  Wir haben beschlossen, Partitionen für jede Woche, mit Ausnahme der letzten, basierend auf den Zahlen des Monats, d. H.  vier Partitionen pro Monat: vom 1. bis zum 7., vom 8. bis zum 14., vom 15. bis zum 21. und vom 22. bis zum 1. (nächster Monat).  Die Schwierigkeit bestand darin, dass wir die benötigten Tabellen sofort in partitionierte Tabellen umwandeln mussten, ohne Zabbix Server zu unterbrechen und Messdaten zu erfassen. <br><br>  Seltsamerweise hat uns dabei die Struktur dieser Tabellen geholfen.  Die <code>history</code> hat beispielsweise die folgende Struktur: <br><br><pre> <code class="sql hljs">`itemid` bigint(20) unsigned NOT NULL, `clock` int(11) NOT NULL DEFAULT '0', `value` double(16,4) NOT NULL DEFAULT '0.0000', `ns` int(11) NOT NULL DEFAULT '0',</code> </pre> <br>  dabei <br><br><pre> <code class="sql hljs">KEY `history_1` (`itemid`,`clock`)</code> </pre> <br>  Wie Sie sehen, wird jede Metrik schließlich in eine Tabelle mit zwei sehr wichtigen und für uns praktischen Feldern <b>itemid</b> und <b>clock</b> eingegeben.  So können wir beispielsweise eine temporäre Tabelle mit dem Namen <code>history_tmp</code> , eine <code>history_tmp</code> dafür einrichten und dann alle Daten aus der <code>history</code> dorthin übertragen und dann die <code>history</code> in <code>history_old</code> und die <code>history_tmp</code> Tabelle in <code>history</code> umbenennen und dann die Daten hinzufügen die wir von <code>history_old</code> zu <code>history</code> <code>history_old</code> <code>history</code> und <code>history_old</code> löschen.  Sie können dies völlig sicher tun, wir verlieren nichts, da die oben angegebenen Felder <b>itemid</b> und <b>clock</b> eine Verbindungsmetrik zu einer bestimmten Zeit und nicht zu einer Art Seriennummer enthalten. <br><br><h3>  Der Übergangsprozess selbst </h3><br><blockquote>  Achtung!  Es ist sehr wünschenswert, vor dem Starten einer Aktion eine vollständige Sicherung von der Datenbank durchzuführen.  Wir sind alle lebende Menschen und können Fehler in den Befehlen machen, die zu Datenverlust führen können.  Ja  Eine Sicherungskopie bietet keine maximale Relevanz, es ist jedoch besser, eine als keine zu haben. </blockquote>  Schalten Sie also nichts aus oder hören Sie nicht auf.  Die Hauptsache ist, dass auf dem MySQL-Server selbst genügend freier Speicherplatz vorhanden sein sollte, d. H.  Damit für jede der obigen Tabellen <code>history</code> , <code>history_text</code> , <code>history_str</code> , <code>history_uint</code> mindestens genügend Speicherplatz vorhanden ist, um eine Tabelle mit dem Suffix "_tmp" zu erstellen, <code>history_str</code> , sie <code>history_uint</code> der ursprünglichen Tabelle. <br><br>  Wir werden nicht mehrmals alles für jede der obigen Tabellen beschreiben und alles am Beispiel von nur einer davon betrachten - der <code>history</code> . <br><br>  Erstellen Sie daher eine leere <code>history_tmp</code> Tabelle basierend auf der Struktur der <code>history</code> Tabelle. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span>;</code> </pre> <br>  Wir erstellen die Partitionen, die wir brauchen.  Lassen Sie es uns zum Beispiel einen Monat lang tun.  Jede Partition wird basierend auf der Partitionsregel erstellt, basierend auf dem Wert des <b>Uhrfelds</b> , das wir mit dem Zeitstempel vergleichen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANGE</span></span>( clock ) ( <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-01 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190207 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-07 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190214 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-14 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190221 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-21 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190301 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-01 00:00:00"</span></span>)) );</code> </pre> <br>  Dieser Operator fügt der <code>history_tmp</code> uns erstellten Tabelle <code>history_tmp</code> eine Partitionierung hinzu.  Lassen Sie uns klarstellen, dass die Daten, für die der Wert des Uhrfelds kleiner als "2019-02-01 00:00:00" ist, in die Partition <i>p20190201 fallen</i> , dann die Daten, für die der Wert des Uhrfelds größer als "2019-02-01 00:00:00" ist, aber kleiner "2019-02-07 00:00:00" fällt in die <i>Gruppe p20190207</i> und so weiter. <br><blockquote>  <b>Wichtiger Hinweis:</b> Und was passiert, wenn die partitionierte Tabelle Daten enthält, deren Wert im Uhrfeld größer oder gleich "2019-03-01 00:00:00" ist?  Da es für diese Daten keine geeignete Partition gibt, fallen sie nicht in die Tabelle und gehen verloren.  Daher dürfen Sie nicht vergessen, rechtzeitig zusätzliche Partitionen zu erstellen, um einen solchen Datenverlust (über den weiter unten berichtet wird) zu vermeiden. </blockquote>  Damit ist der temporäre Tisch vorbereitet.  Füllen Sie die Daten.  Der Vorgang kann ziemlich lange dauern, blockiert aber glücklicherweise keine weiteren Anforderungen, sodass Sie nur Geduld haben müssen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history;</code> </pre> <br>  Das Schlüsselwort IGNORE wird beim erstmaligen Ausfüllen nicht benötigt, da die Tabelle noch keine Daten enthält. Sie benötigen diese jedoch, wenn Sie Daten hinzufügen.  Außerdem kann es hilfreich sein, wenn Sie diesen Vorgang unterbrechen und beim Ausfüllen der Daten erneut starten müssen. <br><br>  Nach einiger Zeit (vielleicht sogar ein paar Stunden) ist der erste Datenupload abgeschlossen.  Wie Sie verstehen, enthält die <code>history_tmp</code> Tabelle jetzt nicht alle Daten aus der <code>history</code> Tabelle, sondern nur die Daten, die sich zum Zeitpunkt des Abfragestarts darin befanden.  Tatsächlich haben Sie hier die Wahl: Entweder machen wir einen weiteren Durchgang (wenn der Füllvorgang lange gedauert hat), oder wir benennen die oben genannten Tabellen sofort um.  Nehmen wir zuerst den zweiten Durchgang.  Zuerst müssen wir die Zeit des zuletzt eingefügten Datensatzes in <code>history_tmp</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  Angenommen, Sie erhalten: <b>1551045645</b> .  Jetzt verwenden wir den erhaltenen Wert im zweiten Durchgang der Datenfüllung: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Diese Passage sollte viel schneller enden.  Wenn der erste Durchgang jedoch stundenlang und der zweite auch über einen längeren Zeitraum durchgeführt wurde, ist es möglicherweise richtig, den dritten Durchgang durchzuführen, der dem zweiten Durchgang vollständig ähnlich ist. <br><br>  Am Ende führen wir den Vorgang zum <code>history_tmp</code> des Zeitpunkts der letzten Einfügung des Datensatzes in <code>history_tmp</code> indem wir <code>history_tmp</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  <b>Angenommen</b> , Sie haben <b>1551085645</b> .  Behalten Sie diesen Wert bei - wir werden ihn zum Nachfüllen benötigen. <br><br>  Und jetzt, wenn die primären Daten in <code>history_tmp</code> , benennen wir die Tabellen um: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history_old; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history_tmp <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br>  Wir haben diesen Block als eine Transaktion konzipiert, um zu vermeiden, dass Daten in eine nicht vorhandene Tabelle eingefügt werden, da die Verlaufstabelle nach dem ersten RENAME bis zum zweiten RENAME nicht vorhanden ist.  Aber selbst wenn einige Daten zwischen den RENAME-Vorgängen in der <code>history</code> eingehen und die Tabelle selbst noch nicht existiert (aufgrund von Umbenennungen), wird eine kleine Anzahl von Einfügefehlern angezeigt, die vernachlässigt werden können (wir haben Überwachung, nicht die Bank). <br><br>  Jetzt haben wir eine neue <code>history</code> mit Partitionierung, aber sie enthält nicht genügend Daten, die beim letzten Durchlauf des Einfügens von Daten in die <code>history_tmp</code> Tabelle <code>history_tmp</code> .  Aber wir haben diese Daten in der Tabelle <code>history_old</code> und teilen sie jetzt von dort aus.  Dafür benötigen wir den zuvor gespeicherten Wert 1551085645. Warum haben wir diesen Wert gespeichert und die maximale Füllzeit nicht bereits aus der aktuellen <code>history</code> ?  Weil neue Daten bereits eingehen und wir die falsche Zeit bekommen.  Also messen wir die Daten: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_old <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Nach dem Ende dieses Vorgangs befinden sich in der neuen, partitionierten <code>history</code> alle Daten, die in der alten Tabelle enthalten waren, sowie die Daten, die nach dem Umbenennen der Tabelle eingegangen sind.  Die Tabelle <code>history_old</code> wird nicht mehr benötigt.  Sie können es sofort löschen oder eine Sicherungskopie davon erstellen (falls Sie Paranoia haben), bevor Sie es löschen. <br><br>  Der gesamte oben beschriebene Prozess muss für die <code>history_uint</code> <code>history_str</code> , <code>history_text</code> und <code>history_uint</code> . <br><br><h3>  Was muss in den Zabbix Server-Einstellungen behoben werden? </h3><br>  Jetzt liegt die Pflege der Datenbank zur Datenhistorie auf unseren Schultern.  Dies bedeutet, dass Zabbix keine alten Daten mehr löschen sollte - wir werden es selbst tun.  Damit Zabbix Server nicht versucht, die Daten selbst zu bereinigen, müssen Sie zur Zabbix-Weboberfläche gehen, im Menü "Administration", dann im Untermenü "Allgemein" und rechts in der Dropdown-Liste "Verlauf löschen" auswählen.  Deaktivieren Sie auf der angezeigten Seite alle Kontrollkästchen für die Gruppe "Verlauf" und klicken Sie auf die Schaltfläche "Aktualisieren".  Auf diese Weise wird verhindert, dass <code>history*</code> -Tabellen von uns durch die Haushälterin bereinigt werden. <br><br>  Beachten Sie auf derselben Seite die Gruppe „Dynamik der Veränderungen“.  Dies ist nur die <code>trends</code> , zu der wir versprochen haben, zurückzukehren.  Wenn es auch für Sie zu groß geworden ist und partitioniert werden muss, deaktivieren Sie auch diese Gruppe und verarbeiten Sie diese Tabelle genau wie für <code>history*</code> -Tabellen. <br><br><h3>  Weitere Datenbankpflege </h3><br>  Wie bereits erwähnt, ist es für den normalen Betrieb in partitionierten Tabellen erforderlich, Partitionen rechtzeitig zu erstellen.  Du kannst das so machen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190307 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-07 00:00:00"</span></span>)));</code> </pre> <br>  Da wir partitionierte Tabellen erstellt und Zabbix Server verboten haben, diese zu bereinigen, ist das Löschen alter Daten nun unser Anliegen.  Zum Glück gibt es überhaupt keine Probleme.  Dies geschieht einfach durch Löschen der Partition, deren Daten wir nicht mehr benötigen. <br><br>  Zum Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201;</code> </pre> <br>  Im Gegensatz zu DELETE FROM-Anweisungen mit einem Datumsbereich wird DROP PARTITION in wenigen Sekunden ausgeführt, lädt den Server überhaupt nicht und funktioniert bei Verwendung der Replikation in MySQL genauso reibungslos. <br><br><h3>  Fazit </h3><br>  Die beschriebene Lösung hat sich bewährt.  Das Datenvolumen wächst, es ist jedoch kein Leistungsabfall festzustellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480082/">https://habr.com/ru/post/de480082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480070/index.html">Vorteile reagieren: Ein Segen für Unternehmen?</a></li>
<li><a href="../de480072/index.html">Kubernetes: Warum ist es so wichtig, ein Systemressourcenmanagement einzurichten?</a></li>
<li><a href="../de480076/index.html">Multiprocessing und Abgleich von Daten aus verschiedenen Quellen</a></li>
<li><a href="../de480078/index.html">Neue Front-End-Bibliotheken bei React Peripherals</a></li>
<li><a href="../de480080/index.html">Was benötigen Sie für Notizen?</a></li>
<li><a href="../de480086/index.html">Wie Sie die Anforderungen von 152-FZ erfüllen, die persönlichen Daten unserer Kunden schützen und nicht auf unseren Rechen treten</a></li>
<li><a href="../de480088/index.html">DevOps - OK, aber was tun? So reduzieren Sie die Handarbeit und erzielen das gewünschte Ergebnis</a></li>
<li><a href="../de480090/index.html">Open Source ist alles</a></li>
<li><a href="../de480092/index.html">So lösen Sie das Problem der Audioerkennung auf GO</a></li>
<li><a href="../de480096/index.html">Ende der Kindheit: Urheberrecht an Werken künstlicher Intelligenz (KI)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>