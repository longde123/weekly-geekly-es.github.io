<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚞 ✍🏾 👨🏼‍💼 Errorx - Bibliothek zum Arbeiten mit Fehlern in Go 🛃 🤶🏽 🥜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist Errorx und wie ist es nützlich? 


 Errorx ist eine Bibliothek zur Behandlung von Fehlern in Go. Es bietet Tools zum Lösen von Problemen im Zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Errorx - Bibliothek zum Arbeiten mit Fehlern in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/429690/"><h1 id="chto-takoe-errorx-i-chem-on-polezen">  Was ist Errorx und wie ist es nützlich? </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Errorx</a> ist eine Bibliothek zur Behandlung von Fehlern in Go.  Es bietet Tools zum Lösen von Problemen im Zusammenhang mit dem Fehlermechanismus in großen Projekten sowie eine einzige Syntax für die Arbeit mit diesen. </p><br><p><img src="https://habrastorage.org/webt/wq/c2/aw/wqc2awx3pmke-loujb4ea0yngya.jpeg" alt="Bild"></p><br><p>  Die meisten Joom-Serverkomponenten wurden seit Gründung des Unternehmens auf Go geschrieben.  Diese Entscheidung hat sich in der Anfangsphase der Entwicklung und der Lebensdauer des Dienstes ausgezahlt. Angesichts der <a href="">Ankündigungen</a> zu den Aussichten für Go 2 sind wir sicher, dass wir dies in Zukunft nicht bereuen werden.  Eine der Haupttugenden von Go ist die Einfachheit, und die Herangehensweise an Fehler zeigt dieses Prinzip wie nichts anderes.  Nicht jedes Projekt erreicht einen ausreichenden Umfang, sodass die Funktionen der Standardbibliothek nicht ausreichen, sodass Sie nach eigenen Lösungen in diesem Bereich suchen müssen.  Wir haben zufällig einige Entwicklungen in der Herangehensweise an die Arbeit mit Fehlern durchlaufen, und die errorx-Bibliothek spiegelt das Ergebnis dieser Entwicklung wider.  Wir sind davon überzeugt, dass dies für viele Menschen nützlich sein kann, auch für diejenigen, die sich noch nicht sehr unwohl fühlen, wenn sie mit Fehlern an ihren Projekten arbeiten. </p><a name="habracut"></a><br><h2 id="oshibki-v-go">  Fehler in Go </h2><br><p>  Bevor wir mit der Geschichte über errorx fortfahren, sollten einige Klarstellungen vorgenommen werden.  Was ist am Ende mit den Bugs los? </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Sehr einfach, oder?  In der Praxis enthält eine Implementierung häufig nur eine Zeichenfolgenbeschreibung des Fehlers.  Ein solcher Minimalismus hängt mit dem Ansatz zusammen, wonach ein Fehler nicht unbedingt etwas "Außergewöhnliches" bedeutet.  Die am häufigsten verwendeten Fehler. New () aus der Standardbibliothek entspricht dieser Idee: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;errorString{text} }</code> </pre> <br><p>  Wenn wir uns daran erinnern, dass Fehler in einer Sprache keinen besonderen Status haben und gewöhnliche Objekte sind, stellt sich die Frage: Was ist die Besonderheit der Arbeit mit ihnen? </p><br><p>  Fehler sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine Ausnahme</a> .  Es ist kein Geheimnis, dass viele, wenn sie Go kennenlernen, diesem Unterschied mit einigem Widerstand begegnen.  Es gibt viele Veröffentlichungen, die den in Go gewählten Ansatz erklären, unterstützen und kritisieren.  Auf die eine oder andere Weise dienen Fehler in Go vielen Zwecken, und mindestens einer davon entspricht genau den Ausnahmen in einigen anderen Sprachen: Fehlerbehebung.  Infolgedessen ist es natürlich, von ihnen dieselbe Ausdruckskraft zu erwarten, auch wenn der Ansatz und die Syntax, die mit ihrer Verwendung verbunden sind, sehr unterschiedlich sind. </p><br><h3 id="chto-ne-tak">  Was ist los? </h3><br><p>  Viele Projekte nutzen die Fehler in Go so wie sie sind und haben nicht die geringste Schwierigkeit.  Mit zunehmender Komplexität des Systems treten jedoch eine Reihe von Problemen auf, die auch ohne hohe Erwartungen Aufmerksamkeit erregen.  Eine gute Illustration ist eine ähnliche Zeile im Protokoll Ihres Dienstes: </p><br><p> <code>Error: duplicate key</code> </p> <br><p>  Hier wird das erste Problem sofort offensichtlich: Wenn Sie sich nicht absichtlich darum kümmern, ist es in einem irgendwie großen System fast unmöglich zu verstehen, was schief gelaufen ist, nur anhand der ersten Meldung.  In diesem Beitrag fehlen Details und ein breiterer Kontext des Problems.  Dies ist ein Fehler eines Programmierers, aber es kommt zu oft vor, um ihn zu vernachlässigen.  Der Code, der den "positiven" Zweigen des Kontrollgraphen gewidmet ist, verdient in der Praxis immer mehr Aufmerksamkeit und wird durch Tests besser abgedeckt als der "negative" Code, der mit einer Unterbrechung der Ausführung oder externen Problemen verbunden ist.  Wie oft das <code>if err != nil {return err}</code> Mantra <code>if err != nil {return err}</code> in Go-Programmen wiederholt wird, macht dieses Versehen noch wahrscheinlicher. </p><br><p>  Betrachten Sie als kleinen Exkurs dieses Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyToUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Data, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ids</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserID</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { users, err := m.LoadUsers(ids) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionData []*Data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, user := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> users { data, err := action(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ok, err := m.validateData(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Error(<span class="hljs-string"><span class="hljs-string">"Validation failed for %v"</span></span>, data) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } actionData = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(actionData, data) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Apply(actionData) }</code> </pre> <br><p>  Wie schnell haben Sie den Fehler in diesem Code gesehen?  Aber es wurde mindestens einmal gemacht, wahrscheinlich von jedem Go-Programmierer.  Hinweis: Fehler im Ausdruck, <code>if err != nil { return nil }</code> . </p><br><p>  Wenn wir mit einer verschwommenen Nachricht im Protokoll zum Problem zurückkehren, ist in dieser Situation natürlich auch jeder passiert.  Es ist sehr unangenehm, den Fehlerbehandlungscode bereits zu dem Zeitpunkt zu beheben, zu dem das Problem auftritt.  Darüber hinaus ist gemäß den anfänglichen Daten aus dem Protokoll völlig unklar, auf welcher Seite mit der Suche nach dem Teil des Codes begonnen werden soll, der tatsächlich verbessert werden muss.  Dies scheint eine weit hergeholte Komplexität für Projekte zu sein, deren Code und Anzahl der externen Abhängigkeiten gering sind.  Bei Großprojekten ist dies jedoch ein völlig reales und schmerzhaftes Problem. </p><br><p>  Angenommen, ein Programmierer mit bitterer Erfahrung möchte dem zurückgegebenen Fehler im Voraus einen Kontext hinzufügen.  Der naive Weg, dies zu tun, ist ungefähr so: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"failed to insert user %s: %v"</span></span>, u.Name, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Es wurde besser.  Der weitere Kontext ist noch unklar, aber jetzt ist es viel einfacher, zumindest in welchem ​​Code der Fehler aufgetreten ist.  Nachdem wir jedoch ein Problem gelöst haben, haben wir versehentlich ein anderes erstellt.  Durch den hier erstellten Fehler blieb die Diagnosemeldung original, aber alles andere, einschließlich des Typs und des zusätzlichen Inhalts, ging verloren. </p><br><p>  Betrachten Sie einen ähnlichen Code im Datenbanktreiber, um festzustellen, warum dies gefährlich ist: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrDuplicateKey = errors.New(<span class="hljs-string"><span class="hljs-string">"duplicate key"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// returns ErrDuplicateKey if a unique constraint is violated by insert } func IsDuplicateKeyError(err error) bool { return err == ErrDuplicateKey }</span></span></code> </pre> <br><p>  Jetzt wird die <code>IsDuplicateKeyError()</code> zerstört, obwohl wir zum Zeitpunkt des Hinzufügens unseres Textes zum Fehler nicht die Absicht hatten, seine Semantik zu ändern.  Dies wiederum wird den Code beschädigen, der auf dieser Prüfung beruht: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := InsertUser(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db.IsDuplicateKeyError(err) { <span class="hljs-comment"><span class="hljs-comment">// find existing user, handle conflict } else { return err } }</span></span></code> </pre> <br><p>  Wenn wir intelligenter vorgehen und unseren eigenen Fehlertyp hinzufügen möchten, der den ursprünglichen Fehler speichert und ihn beispielsweise über die <code>Cause() error</code> kann, lösen wir das Problem auch nur teilweise. </p><br><ol><li>  Anstelle der Fehlerverarbeitung müssen Sie nun wissen, dass der wahre Grund in <code>Cause()</code> </li><li>  Es gibt keine Möglichkeit, externen Bibliotheken dieses Wissen beizubringen, und die darin geschriebenen Hilfsfunktionen bleiben unbrauchbar </li><li>  Unsere Implementierung kann erwarten, dass <code>Cause()</code> die unmittelbare Fehlerursache zurückgibt (oder null, wenn dies nicht der Fall ist), während die Implementierung in einer anderen Bibliothek erwartet, dass die Methode die nicht null-Grundursache zurückgibt.  Das Fehlen von Standardwerkzeugen oder eines allgemein akzeptierten Vertrags birgt sehr unangenehme Überraschungen </li></ol><br><p>  Diese Teillösung wird jedoch in vielen Fehlerbibliotheken verwendet, einschließlich in gewissem Umfang auch in unseren.  In Go 2 ist geplant, diesen Ansatz bekannt zu machen. In diesem Fall ist es einfacher, die oben beschriebenen Probleme zu lösen. </p><br><h2 id="errorx">  Fehlerx </h2><br><p>  Im Folgenden werden wir über die Angebote von errorx sprechen, aber versuchen Sie zunächst, die Überlegungen zu formulieren, die der Bibliothek zugrunde liegen. </p><br><ul><li>  <strong>Diagnose ist wichtiger als Ressourceneinsparung.</strong>  Die Leistung beim Erstellen und Anzeigen von Fehlern ist wichtig.  Trotzdem stellen sie eher einen negativen als einen positiven Pfad dar und dienen in den meisten Fällen als Signal für ein Problem. Daher ist das Vorhandensein von Diagnoseinformationen in einem Fehler noch wichtiger. </li><li>  <strong>Standardmäßig Stapelverfolgung.</strong>  Damit der Fehler mit der Fülle der Diagnose verschwindet, sollten keine Anstrengungen erforderlich sein.  Im Gegenteil, gerade um einige der Informationen (aus Gründen der Kürze oder aus Leistungsgründen) auszuschließen, können zusätzliche Maßnahmen erforderlich sein. </li><li>  <strong>Semantik von Fehlern.</strong>  Es sollte eine einfache und zuverlässige Möglichkeit geben, die Bedeutung des Fehlers zu überprüfen: Art, Vielfalt, Eigenschaften. </li><li>  <strong>Einfache Zugabe.</strong>  Das Hinzufügen von Diagnoseinformationen zu einem übergebenen Fehler sollte einfach sein und die Überprüfung seiner Semantik nicht beeinträchtigen. </li><li>  <strong>Einfachheit.</strong>  Code, der Fehlern gewidmet ist, wird häufig und routinemäßig geschrieben, daher sollte die Syntax grundlegender Manipulationen mit ihnen einfach und präzise sein.  Dies reduziert die Anzahl der Fehler und erleichtert das Lesen. </li><li>  <strong>Weniger ist mehr.</strong>  Die Verständlichkeit und Einheitlichkeit des Codes ist wichtiger als die optionalen Funktionen und Erweiterungsoptionen (die wahrscheinlich niemand verwenden wird). </li><li>  <strong>Die Fehlersemantik ist Teil der API.</strong>  Fehler, die eine separate Verarbeitung im aufrufenden Code erfordern, sind de facto Teil des öffentlichen API-Pakets.  Sie müssen nicht versuchen, es auszublenden oder weniger explizit zu machen, aber Sie können die Verarbeitung bequemer und externe Abhängigkeiten weniger anfällig machen. </li><li>  <strong>Die meisten Fehler sind undurchsichtig.</strong>  Je mehr Arten von Fehlern für einen externen Benutzer nicht voneinander zu unterscheiden sind, desto besser.  Das Laden von API-Fehlertypen, die eine spezielle Behandlung erfordern, sowie das Laden der Fehler selbst mit den zur Verarbeitung erforderlichen Daten ist ein Konstruktionsfehler, der vermieden werden sollte. </li></ul><br><p>  Die schwierigste Frage für uns war die Erweiterbarkeit: Sollte errorx Grundelemente für die Einführung benutzerdefinierter Fehlertypen bereitstellen, deren Verhalten beliebig unterschiedlich ist, oder gibt es eine Implementierung, mit der Sie alles, was Sie benötigen, aus der Box holen können?  Wir haben die zweite Option gewählt.  Erstens löst errorx ein sehr praktisches Problem - und unsere Erfahrung mit der Verwendung zeigt, dass es für diesen Zweck besser ist, eine Lösung zu haben, als Ersatzteile für die Erstellung.  Zweitens ist die Überlegung zur Einfachheit sehr wichtig: Da Fehler weniger berücksichtigt werden, sollte der Code so gestaltet sein, dass es schwierig ist, mit ihnen zu arbeiten.  Die Praxis hat gezeigt, dass es dafür wichtig ist, dass alle diese Codes gleich aussehen und funktionieren. </p><br><h4 id="tldr-po-osnovnym-ficham-biblioteki">  TL; DR nach Hauptbibliotheksfunktionen: </h4><br><ul><li>  Stack-Trace-Erstellungsorte in allen Fehlern standardmäßig </li><li>  Typprüfungen auf Fehler, verschiedene Sorten </li><li>  Die Möglichkeit, einem vorhandenen Fehler Informationen hinzuzufügen, ohne etwas zu beschädigen </li><li>  Geben Sie die Sichtbarkeitssteuerung ein, wenn Sie den ursprünglichen Grund vor dem Anrufer verbergen möchten </li><li>  Fehlerbehandlungs-Code-Generalisierungsmechanismus (Typhierarchie, Merkmale) </li><li>  Fehleranpassung durch dynamische Eigenschaften </li><li>  Standardfehlertypen </li><li>  Syntax-Dienstprogramme zur Verbesserung der Lesbarkeit von Fehlerbehandlungscode </li></ul><br><h3 id="vvedenie">  Einführung </h3><br><p>  Wenn wir das oben analysierte Beispiel mit errorx überarbeiten, erhalten wir Folgendes: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( DBErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"db"</span></span>) ErrDuplicateKey = DBErrors.NewType(<span class="hljs-string"><span class="hljs-string">"duplicate_key"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return ErrDuplicateKey.New("violated constraint %s", details) } func IsDuplicateKeyError(err error) bool { return errorx.IsOfType(err, ErrDuplicateKey) }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to insert user %s"</span></span>, u.Name) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Der <code>IsDuplicateKeyError()</code> mit <code>IsDuplicateKeyError()</code> ändert sich nicht. </p><br><p>  Was hat sich in diesem Beispiel geändert? </p><br><ul><li>  <code>ErrDuplicateKey</code> wurde zu einem Typ, nicht zu einer Fehlerinstanz.  Die Überprüfung ist resistent gegen Kopierfehler, es besteht keine fragile Abhängigkeit von der exakten Gleichheit </li><li>  Es gibt einen Namespace für Datenbankfehler.  Es wird höchstwahrscheinlich andere Fehler geben, und eine solche Gruppierung ist für die Lesbarkeit nützlich und kann in einigen Fällen im Code verwendet werden </li><li>  Einfügen gibt für jeden Aufruf einen neuen Fehler zurück: <br><ul><li>  Der Fehler enthält weitere Details.  Dies ist natürlich ohne errorx möglich, aber es ist unmöglich, wenn jedes Mal dieselbe Fehlerinstanz zurückgegeben wird, die zuvor für <code>IsDuplicateKeyError()</code> erforderlich war. </li><li>  Diese Fehler können eine andere Stapelverfolgung enthalten, was nützlich ist, weil  Nicht für alle Aufrufe der Einfügefunktion ist diese Situation akzeptabel </li></ul></li><li>  <code>InsertUser()</code> ergänzt den Fehlertext, wendet jedoch den ursprünglichen Fehler an, der für nachfolgende Vorgänge vollständig beibehalten wird </li><li>  <code>IsDuplicateKeyError()</code> funktioniert jetzt: Es kann weder durch Kopieren des Fehlers noch durch beliebig viele Ebenen mit Decorate () verwöhnt werden. </li></ul><br><p>  Es ist nicht notwendig, immer nur einem solchen Schema zu folgen: </p><br><ul><li>  Die Art des Fehlers ist bei weitem nicht immer eindeutig: Die gleichen Typen können an vielen Stellen verwendet werden </li><li>  Falls gewünscht, kann die Stack-Trace-Sammlung deaktiviert werden, und Sie können nicht jedes Mal einen neuen Fehler erstellen, sondern denselben wie im ursprünglichen Beispiel zurückgeben.  Hierbei handelt es sich um sogenannte Sentinel-Fehler, deren Verwendung wir nicht empfehlen. Dies kann jedoch hilfreich sein, wenn der Fehler nur als Markierung im Code verwendet wird und Sie beim Erstellen von Objekten sparen möchten </li><li>  Es gibt eine Möglichkeit, die <code>errorx.IsOfType(err, ErrDuplicateKey)</code> beenden, wenn Sie die Semantik der Grundursache vor neugierigen Blicken verbergen möchten </li><li>  Neben dem Vergleich mit dem genauen Typ gibt es noch andere Möglichkeiten, die Typprüfung selbst durchzuführen </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godoc</a> enthält detaillierte Informationen zu all dem.  Im Folgenden werden die Hauptmerkmale, die für die tägliche Arbeit ausreichen, etwas näher erläutert. </p><br><h3 id="tipy">  Typen </h3><br><p>  Jeder errorx-Fehler gehört zu einem Typ.  Typ ist wichtig, weil  geerbte Fehlereigenschaften können durchlaufen werden;  Durch ihn oder seine Eigenschaften werden bei Bedarf Semantikprüfungen durchgeführt.  Darüber hinaus ergänzt der aussagekräftige Name des Typs die Fehlermeldung und kann sie in einigen Fällen ersetzen. </p><br><pre> <code class="go hljs">AuthErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"auth"</span></span>) ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>)</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ErrInvalidToken.NewWithNoMessage()</code> </pre> <br><p>  Die Fehlermeldung enthält <code>auth.invalid_token</code> .  Die Fehlerdeklaration könnte anders aussehen: </p><br><pre> <code class="go hljs">ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>).ApplyModifiers(errorx.TypeModifierOmitStackTrace)</code> </pre> <br><p>  In dieser Ausführungsform ist unter Verwendung des Typmodifikators die Stapelverfolgungssammlung deaktiviert.  Der Fehler hat eine Markersemantik: Sein Typ wird an den externen Benutzer des Dienstes übergeben, und ein Aufrufstapel in den Protokollen wäre nicht sinnvoll, da  Dies ist kein zu reparierendes Problem. </p><br><p>  Hier können wir den Vorbehalt machen, dass Fehler in mehreren Aspekten dualer Natur sind.  Der Inhalt des Fehlers wird sowohl für die Diagnose als auch manchmal als Information für einen externen Benutzer verwendet: API-Client, Bibliotheksbenutzer usw.  Fehler werden im Code sowohl als Mittel zur Vermittlung der Semantik des Geschehens als auch als Mechanismus zur Übertragung der Kontrolle verwendet.  Bei der Verwendung von Fehlertypen sollte dies berücksichtigt werden. </p><br><h3 id="sozdanie-oshibki">  Fehlererstellung </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyType.New(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>)</code> </pre> <br><p>  Das Abrufen eines eigenen Typs für jeden Fehler ist völlig optional.  Jedes Projekt kann ein eigenes Paket mit allgemeinen Fehlern haben, und einige Sätze werden zusammen mit errorx als Teil des allgemeinen Namespace bereitgestellt.  Es enthält Fehler, die in den meisten Fällen keine Verarbeitung im Code beinhalten und für „Ausnahmesituationen“ geeignet sind, in denen ein Fehler aufgetreten ist. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IllegalArgument.New(<span class="hljs-string"><span class="hljs-string">"negative value %d"</span></span>, value)</code> </pre> <br><p>  In einem typischen Fall wird eine Aufrufkette so konzipiert, dass am Ende der Kette ein Fehler erstellt und am Anfang verarbeitet wird.  In Go wird es nicht ohne Grund als schlechte Form angesehen, einen Fehler zweimal zu verarbeiten, d. H. Beispielsweise einen Fehler in das Protokoll zu schreiben und ihn höher im Stapel zurückzugeben.  Sie können dem Fehler jedoch selbst Informationen hinzufügen, bevor Sie ihn weitergeben: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to upload '%s' to '%s'"</span></span>, filename, location)</code> </pre> <br><p>  Der dem Fehler hinzugefügte Text wird im Protokoll angezeigt, es schadet jedoch nicht, den Typ des ursprünglichen Fehlers zu überprüfen. </p><br><p>  Manchmal entsteht das gegenteilige Bedürfnis: Unabhängig von der Art des Fehlers sollte der externe Benutzer des Pakets ihn nicht kennen.  Wenn er eine solche Gelegenheit bekommen würde, könnte er eine fragile Abhängigkeit von einem Teil der Implementierung schaffen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.ErrBadRequest.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to load user data"</span></span>)</code> </pre> <br><p>  Ein wichtiger Unterschied, der Wrap zur bevorzugten Alternative zu New macht, besteht darin, dass der ursprüngliche Fehler vollständig in den Protokollen wiedergegeben wird.  Und insbesondere wird es einen nützlichen ersten Aufrufstapel mit sich bringen. </p><br><p>  Ein weiterer nützlicher Trick, mit dem Sie alle möglichen Informationen zum Aufrufstapel speichern können, sieht folgendermaßen aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.EnhanceStackTrace(err, <span class="hljs-string"><span class="hljs-string">"operation fail"</span></span>)</code> </pre> <br><p>  Wenn der ursprüngliche Fehler von einer anderen Goroutine stammt, enthält das Ergebnis eines solchen Aufrufs eine Stapelverfolgung beider Goroutinen, was die Nützlichkeit ungewöhnlich erhöht.  Die Notwendigkeit, einen solchen Anruf zu tätigen, ist eindeutig auf Leistungsprobleme zurückzuführen: Dieser Fall ist relativ selten, und eine Ergonomie, die ihn selbst erkennt, würde den üblichen Wrap verlangsamen, wenn er überhaupt nicht erforderlich ist. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godoc</a> enthält weitere Informationen und beschreibt zusätzliche Funktionen wie DecorateMany. </p><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Am besten, wenn die Fehlerbehandlung auf Folgendes zurückzuführen ist: </p><br><pre> <code class="go hljs">log.Error(<span class="hljs-string"><span class="hljs-string">"Error: %+v"</span></span>, err)</code> </pre> <br><p>  Je weniger Fehler Sie machen müssen, außer um sie in das Protokoll auf der Systemschicht des Projekts zu drucken, desto besser.  In Wirklichkeit reicht dies manchmal nicht aus, und Sie müssen dies tun: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errorx.IsOfType(err, MyType) { <span class="hljs-comment"><span class="hljs-comment">/* handle */</span></span> }</code> </pre> <br><p>  Diese Prüfung ist sowohl bei einem Fehler vom Typ <code>MyType</code> als auch bei seinen <code>MyType</code> Typen erfolgreich und ist gegen <code>errorx.Decorate()</code> resistent.  Hier besteht jedoch eine direkte Abhängigkeit von der Art des Fehlers, was innerhalb des Pakets ganz normal ist, aber bei Verwendung außerhalb des Pakets unangenehm sein kann.  In einigen Fällen ist der Typ eines solchen Fehlers Teil einer stabilen externen API, und manchmal möchten wir diese Prüfung durch eine Eigenschaftsprüfung ersetzen und nicht durch die genaue Art des Fehlers. </p><br><p>  Bei klassischen Go-Fehlern würde dies über eine Schnittstelle erfolgen, deren Typ als Indikator für die Art des Fehlers dient.  Errorx-Typen unterstützen diese Erweiterung nicht, Sie können jedoch stattdessen den <code>Trait</code> Mechanismus verwenden.  Zum Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTemporary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HasTrait(err, Temporary()) }</code> </pre> <br><p>  Diese in errorx integrierte Funktion prüft, ob der Fehler die Standardeigenschaft <code>Temporary</code> , d. H.  ob es vorübergehend ist.  Das Markieren von Fehlertypen mit Merkmalen liegt in der Verantwortung der Fehlerquelle und kann durch diese ein nützliches Signal übertragen, ohne dass bestimmte interne Typen Teil der externen API sind. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IgnoreWithTrait(err, errorx.NotFound())</code> </pre> <br><p>  Diese Syntax ist nützlich, wenn eine bestimmte Art von Fehler erforderlich ist, um den Steuerungsfluss zu unterbrechen, sie sollte jedoch nicht an die aufrufende Funktion übergeben werden. </p><br><p>  Trotz der Fülle an Verarbeitungswerkzeugen, von denen hier nicht alle aufgeführt sind, ist es wichtig zu bedenken, dass das Arbeiten mit Fehlern so einfach wie möglich bleiben sollte.  Ein Beispiel für die Regeln, die wir einhalten wollen: </p><br><ul><li>  Code, der einen Fehler empfängt, sollte ihn immer vollständig protokollieren.  Wenn ein Teil der Informationen überflüssig ist, lassen Sie den Code, der den Fehler erzeugt, dies erledigen </li><li>  Sie sollten niemals den Fehlertext oder das Ergebnis der Funktion <code>Error()</code> verwenden, um ihn im Code zu verarbeiten.  Hierfür sind nur Typ- / Merkmalsprüfungen geeignet oder bei Nicht-Errorx-Fehlern eine Typzusicherung </li><li>  Der Benutzercode sollte nicht beschädigt werden, da ein Fehler nicht auf besondere Weise verarbeitet wird, auch wenn eine solche Verarbeitung möglich ist und zusätzliche Funktionen bietet </li><li>  Fehler, die von Eigenschaften überprüft werden, sind besser als sogenannte Sentinel-Fehler, weil  solche Kontrollen sind weniger fragil </li></ul><br><h3 id="vne-errorx">  Außerhalb errorx </h3><br><p>  Hier haben wir beschrieben, was dem Bibliotheksbenutzer sofort zur Verfügung steht, aber in Joom ist die Penetration von fehlerbezogenem Code sehr groß.  Das Protokollierungsmodul akzeptiert explizit Fehler in seiner Signatur und druckt sich selbst aus, um die Möglichkeit einer falschen Formatierung auszuschließen und optional verfügbare Kontextinformationen aus der Fehlerkette zu extrahieren.  Das Modul, das für die paniksichere Arbeit mit Goroutins verantwortlich ist, entpackt den Fehler, wenn er mit einer Panik auftritt, und weiß auch, wie man Panik mithilfe der Fehlersyntax darstellt, ohne den ursprünglichen Stack-Trace zu verlieren.  Einige davon werden wir vielleicht auch veröffentlichen. </p><br><h2 id="voprosy-sovmestimosti">  Kompatibilitätsprobleme </h2><br><p>  Trotz der Tatsache, dass wir sehr zufrieden sind, wie errorx es uns ermöglicht, mit Fehlern zu arbeiten, ist die Situation mit dem diesem Thema gewidmeten Bibliothekscode alles andere als ideal.  Wir bei Joom lösen ganz bestimmte praktische Probleme mit errorx, aber aus Sicht des Go-Ökosystems wäre es vorzuziehen, diesen gesamten Satz von Werkzeugen in der Standardbibliothek zu haben.  Der Fehler, dessen Quelle tatsächlich oder möglicherweise zu einem anderen Paradigma gehört, muss als fremd angesehen werden, d. H.  möglicherweise keine Informationen in der Form enthalten, die im Projekt akzeptiert wird. </p><br><p>  Es wurden jedoch einige Maßnahmen ergriffen, um nicht mit anderen vorhandenen Lösungen in Konflikt zu geraten. </p><br><p>  Das Format <code>'%+v'</code> verwendet, um einen Fehler zusammen mit der Stapelverfolgung zu drucken, falls vorhanden.  Dies ist der De-facto-Standard im Go-Ökosystem und sogar im Entwurfsentwurf für Go 2 enthalten. </p><br><p>  <code>Cause() error</code>  errorx ,  ,   ,    Causer,       errorx      Wrap(). </p><br><h2 id="buduschee">  </h2><br><p>  <a href=""></a>   ,    Go 2,      .  <a href="">   </a>       . </p><br><p> ,    errorx     Go 1.      ,    Go 2,     .       ,            ,        errorx. </p><br><p> Check-handle      ,   errorx , a <code>Unwrap() error</code>       <code>Wrap()</code>  errorx (.. ,        ,    <code>Wrap</code> ),    .     ,      ,  . </p><br><p>     design draft   Go 2,    <code>errorx.Is()</code>  <code>errorx.As()</code>   ,      errors   . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>   ,   ,   ,    -      ,        .      ,      API     :  ,   ,       .  1.0      ,           Joom. ,  -       . </p><br><p> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/joomcode/errorx</a> </p><br><p>   ,    ! </p><br><p><img src="https://habrastorage.org/webt/nk/hv/el/nkhvelss5upmybktmbpy68ozo_a.jpeg" alt="Bild"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429690/">https://habr.com/ru/post/de429690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429680/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 1</a></li>
<li><a href="../de429682/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 2</a></li>
<li><a href="../de429684/index.html">Firebase Summit 2018: kurz zur Hauptsache</a></li>
<li><a href="../de429686/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: „Benutzerauthentifizierung“, Teil 3</a></li>
<li><a href="../de429688/index.html">Wie man einen Helden erschafft, dem man glauben wird</a></li>
<li><a href="../de429692/index.html">Optimierung der Ereignisbehandlung in Angular</a></li>
<li><a href="../de429694/index.html">Mail.Ru nannte Yandex-Rankings „absurd“ und fordert, seine Marken daraus zu entfernen</a></li>
<li><a href="../de429696/index.html">Videoberichte mit MOSDROID # 13 Aluminium</a></li>
<li><a href="../de429698/index.html">So arbeiten Sie mit Lebedev Studio: Tutu.ru Erfahrung</a></li>
<li><a href="../de429700/index.html">Definition von Zahlen nach Gehör</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>