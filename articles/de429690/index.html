<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöû ‚úçüèæ üë®üèº‚Äçüíº Errorx - Bibliothek zum Arbeiten mit Fehlern in Go üõÉ ü§∂üèΩ ü•ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist Errorx und wie ist es n√ºtzlich? 


 Errorx ist eine Bibliothek zur Behandlung von Fehlern in Go. Es bietet Tools zum L√∂sen von Problemen im Zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Errorx - Bibliothek zum Arbeiten mit Fehlern in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/429690/"><h1 id="chto-takoe-errorx-i-chem-on-polezen">  Was ist Errorx und wie ist es n√ºtzlich? </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Errorx</a> ist eine Bibliothek zur Behandlung von Fehlern in Go.  Es bietet Tools zum L√∂sen von Problemen im Zusammenhang mit dem Fehlermechanismus in gro√üen Projekten sowie eine einzige Syntax f√ºr die Arbeit mit diesen. </p><br><p><img src="https://habrastorage.org/webt/wq/c2/aw/wqc2awx3pmke-loujb4ea0yngya.jpeg" alt="Bild"></p><br><p>  Die meisten Joom-Serverkomponenten wurden seit Gr√ºndung des Unternehmens auf Go geschrieben.  Diese Entscheidung hat sich in der Anfangsphase der Entwicklung und der Lebensdauer des Dienstes ausgezahlt. Angesichts der <a href="">Ank√ºndigungen</a> zu den Aussichten f√ºr Go 2 sind wir sicher, dass wir dies in Zukunft nicht bereuen werden.  Eine der Haupttugenden von Go ist die Einfachheit, und die Herangehensweise an Fehler zeigt dieses Prinzip wie nichts anderes.  Nicht jedes Projekt erreicht einen ausreichenden Umfang, sodass die Funktionen der Standardbibliothek nicht ausreichen, sodass Sie nach eigenen L√∂sungen in diesem Bereich suchen m√ºssen.  Wir haben zuf√§llig einige Entwicklungen in der Herangehensweise an die Arbeit mit Fehlern durchlaufen, und die errorx-Bibliothek spiegelt das Ergebnis dieser Entwicklung wider.  Wir sind davon √ºberzeugt, dass dies f√ºr viele Menschen n√ºtzlich sein kann, auch f√ºr diejenigen, die sich noch nicht sehr unwohl f√ºhlen, wenn sie mit Fehlern an ihren Projekten arbeiten. </p><a name="habracut"></a><br><h2 id="oshibki-v-go">  Fehler in Go </h2><br><p>  Bevor wir mit der Geschichte √ºber errorx fortfahren, sollten einige Klarstellungen vorgenommen werden.  Was ist am Ende mit den Bugs los? </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Sehr einfach, oder?  In der Praxis enth√§lt eine Implementierung h√§ufig nur eine Zeichenfolgenbeschreibung des Fehlers.  Ein solcher Minimalismus h√§ngt mit dem Ansatz zusammen, wonach ein Fehler nicht unbedingt etwas "Au√üergew√∂hnliches" bedeutet.  Die am h√§ufigsten verwendeten Fehler. New () aus der Standardbibliothek entspricht dieser Idee: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;errorString{text} }</code> </pre> <br><p>  Wenn wir uns daran erinnern, dass Fehler in einer Sprache keinen besonderen Status haben und gew√∂hnliche Objekte sind, stellt sich die Frage: Was ist die Besonderheit der Arbeit mit ihnen? </p><br><p>  Fehler sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine Ausnahme</a> .  Es ist kein Geheimnis, dass viele, wenn sie Go kennenlernen, diesem Unterschied mit einigem Widerstand begegnen.  Es gibt viele Ver√∂ffentlichungen, die den in Go gew√§hlten Ansatz erkl√§ren, unterst√ºtzen und kritisieren.  Auf die eine oder andere Weise dienen Fehler in Go vielen Zwecken, und mindestens einer davon entspricht genau den Ausnahmen in einigen anderen Sprachen: Fehlerbehebung.  Infolgedessen ist es nat√ºrlich, von ihnen dieselbe Ausdruckskraft zu erwarten, auch wenn der Ansatz und die Syntax, die mit ihrer Verwendung verbunden sind, sehr unterschiedlich sind. </p><br><h3 id="chto-ne-tak">  Was ist los? </h3><br><p>  Viele Projekte nutzen die Fehler in Go so wie sie sind und haben nicht die geringste Schwierigkeit.  Mit zunehmender Komplexit√§t des Systems treten jedoch eine Reihe von Problemen auf, die auch ohne hohe Erwartungen Aufmerksamkeit erregen.  Eine gute Illustration ist eine √§hnliche Zeile im Protokoll Ihres Dienstes: </p><br><p> <code>Error: duplicate key</code> </p> <br><p>  Hier wird das erste Problem sofort offensichtlich: Wenn Sie sich nicht absichtlich darum k√ºmmern, ist es in einem irgendwie gro√üen System fast unm√∂glich zu verstehen, was schief gelaufen ist, nur anhand der ersten Meldung.  In diesem Beitrag fehlen Details und ein breiterer Kontext des Problems.  Dies ist ein Fehler eines Programmierers, aber es kommt zu oft vor, um ihn zu vernachl√§ssigen.  Der Code, der den "positiven" Zweigen des Kontrollgraphen gewidmet ist, verdient in der Praxis immer mehr Aufmerksamkeit und wird durch Tests besser abgedeckt als der "negative" Code, der mit einer Unterbrechung der Ausf√ºhrung oder externen Problemen verbunden ist.  Wie oft das <code>if err != nil {return err}</code> Mantra <code>if err != nil {return err}</code> in Go-Programmen wiederholt wird, macht dieses Versehen noch wahrscheinlicher. </p><br><p>  Betrachten Sie als kleinen Exkurs dieses Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyToUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Data, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ids</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserID</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { users, err := m.LoadUsers(ids) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionData []*Data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, user := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> users { data, err := action(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ok, err := m.validateData(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Error(<span class="hljs-string"><span class="hljs-string">"Validation failed for %v"</span></span>, data) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } actionData = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(actionData, data) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Apply(actionData) }</code> </pre> <br><p>  Wie schnell haben Sie den Fehler in diesem Code gesehen?  Aber es wurde mindestens einmal gemacht, wahrscheinlich von jedem Go-Programmierer.  Hinweis: Fehler im Ausdruck, <code>if err != nil { return nil }</code> . </p><br><p>  Wenn wir mit einer verschwommenen Nachricht im Protokoll zum Problem zur√ºckkehren, ist in dieser Situation nat√ºrlich auch jeder passiert.  Es ist sehr unangenehm, den Fehlerbehandlungscode bereits zu dem Zeitpunkt zu beheben, zu dem das Problem auftritt.  Dar√ºber hinaus ist gem√§√ü den anf√§nglichen Daten aus dem Protokoll v√∂llig unklar, auf welcher Seite mit der Suche nach dem Teil des Codes begonnen werden soll, der tats√§chlich verbessert werden muss.  Dies scheint eine weit hergeholte Komplexit√§t f√ºr Projekte zu sein, deren Code und Anzahl der externen Abh√§ngigkeiten gering sind.  Bei Gro√üprojekten ist dies jedoch ein v√∂llig reales und schmerzhaftes Problem. </p><br><p>  Angenommen, ein Programmierer mit bitterer Erfahrung m√∂chte dem zur√ºckgegebenen Fehler im Voraus einen Kontext hinzuf√ºgen.  Der naive Weg, dies zu tun, ist ungef√§hr so: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"failed to insert user %s: %v"</span></span>, u.Name, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Es wurde besser.  Der weitere Kontext ist noch unklar, aber jetzt ist es viel einfacher, zumindest in welchem ‚Äã‚ÄãCode der Fehler aufgetreten ist.  Nachdem wir jedoch ein Problem gel√∂st haben, haben wir versehentlich ein anderes erstellt.  Durch den hier erstellten Fehler blieb die Diagnosemeldung original, aber alles andere, einschlie√ülich des Typs und des zus√§tzlichen Inhalts, ging verloren. </p><br><p>  Betrachten Sie einen √§hnlichen Code im Datenbanktreiber, um festzustellen, warum dies gef√§hrlich ist: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrDuplicateKey = errors.New(<span class="hljs-string"><span class="hljs-string">"duplicate key"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// returns ErrDuplicateKey if a unique constraint is violated by insert } func IsDuplicateKeyError(err error) bool { return err == ErrDuplicateKey }</span></span></code> </pre> <br><p>  Jetzt wird die <code>IsDuplicateKeyError()</code> zerst√∂rt, obwohl wir zum Zeitpunkt des Hinzuf√ºgens unseres Textes zum Fehler nicht die Absicht hatten, seine Semantik zu √§ndern.  Dies wiederum wird den Code besch√§digen, der auf dieser Pr√ºfung beruht: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := InsertUser(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db.IsDuplicateKeyError(err) { <span class="hljs-comment"><span class="hljs-comment">// find existing user, handle conflict } else { return err } }</span></span></code> </pre> <br><p>  Wenn wir intelligenter vorgehen und unseren eigenen Fehlertyp hinzuf√ºgen m√∂chten, der den urspr√ºnglichen Fehler speichert und ihn beispielsweise √ºber die <code>Cause() error</code> kann, l√∂sen wir das Problem auch nur teilweise. </p><br><ol><li>  Anstelle der Fehlerverarbeitung m√ºssen Sie nun wissen, dass der wahre Grund in <code>Cause()</code> </li><li>  Es gibt keine M√∂glichkeit, externen Bibliotheken dieses Wissen beizubringen, und die darin geschriebenen Hilfsfunktionen bleiben unbrauchbar </li><li>  Unsere Implementierung kann erwarten, dass <code>Cause()</code> die unmittelbare Fehlerursache zur√ºckgibt (oder null, wenn dies nicht der Fall ist), w√§hrend die Implementierung in einer anderen Bibliothek erwartet, dass die Methode die nicht null-Grundursache zur√ºckgibt.  Das Fehlen von Standardwerkzeugen oder eines allgemein akzeptierten Vertrags birgt sehr unangenehme √úberraschungen </li></ol><br><p>  Diese Teill√∂sung wird jedoch in vielen Fehlerbibliotheken verwendet, einschlie√ülich in gewissem Umfang auch in unseren.  In Go 2 ist geplant, diesen Ansatz bekannt zu machen. In diesem Fall ist es einfacher, die oben beschriebenen Probleme zu l√∂sen. </p><br><h2 id="errorx">  Fehlerx </h2><br><p>  Im Folgenden werden wir √ºber die Angebote von errorx sprechen, aber versuchen Sie zun√§chst, die √úberlegungen zu formulieren, die der Bibliothek zugrunde liegen. </p><br><ul><li>  <strong>Diagnose ist wichtiger als Ressourceneinsparung.</strong>  Die Leistung beim Erstellen und Anzeigen von Fehlern ist wichtig.  Trotzdem stellen sie eher einen negativen als einen positiven Pfad dar und dienen in den meisten F√§llen als Signal f√ºr ein Problem. Daher ist das Vorhandensein von Diagnoseinformationen in einem Fehler noch wichtiger. </li><li>  <strong>Standardm√§√üig Stapelverfolgung.</strong>  Damit der Fehler mit der F√ºlle der Diagnose verschwindet, sollten keine Anstrengungen erforderlich sein.  Im Gegenteil, gerade um einige der Informationen (aus Gr√ºnden der K√ºrze oder aus Leistungsgr√ºnden) auszuschlie√üen, k√∂nnen zus√§tzliche Ma√ünahmen erforderlich sein. </li><li>  <strong>Semantik von Fehlern.</strong>  Es sollte eine einfache und zuverl√§ssige M√∂glichkeit geben, die Bedeutung des Fehlers zu √ºberpr√ºfen: Art, Vielfalt, Eigenschaften. </li><li>  <strong>Einfache Zugabe.</strong>  Das Hinzuf√ºgen von Diagnoseinformationen zu einem √ºbergebenen Fehler sollte einfach sein und die √úberpr√ºfung seiner Semantik nicht beeintr√§chtigen. </li><li>  <strong>Einfachheit.</strong>  Code, der Fehlern gewidmet ist, wird h√§ufig und routinem√§√üig geschrieben, daher sollte die Syntax grundlegender Manipulationen mit ihnen einfach und pr√§zise sein.  Dies reduziert die Anzahl der Fehler und erleichtert das Lesen. </li><li>  <strong>Weniger ist mehr.</strong>  Die Verst√§ndlichkeit und Einheitlichkeit des Codes ist wichtiger als die optionalen Funktionen und Erweiterungsoptionen (die wahrscheinlich niemand verwenden wird). </li><li>  <strong>Die Fehlersemantik ist Teil der API.</strong>  Fehler, die eine separate Verarbeitung im aufrufenden Code erfordern, sind de facto Teil des √∂ffentlichen API-Pakets.  Sie m√ºssen nicht versuchen, es auszublenden oder weniger explizit zu machen, aber Sie k√∂nnen die Verarbeitung bequemer und externe Abh√§ngigkeiten weniger anf√§llig machen. </li><li>  <strong>Die meisten Fehler sind undurchsichtig.</strong>  Je mehr Arten von Fehlern f√ºr einen externen Benutzer nicht voneinander zu unterscheiden sind, desto besser.  Das Laden von API-Fehlertypen, die eine spezielle Behandlung erfordern, sowie das Laden der Fehler selbst mit den zur Verarbeitung erforderlichen Daten ist ein Konstruktionsfehler, der vermieden werden sollte. </li></ul><br><p>  Die schwierigste Frage f√ºr uns war die Erweiterbarkeit: Sollte errorx Grundelemente f√ºr die Einf√ºhrung benutzerdefinierter Fehlertypen bereitstellen, deren Verhalten beliebig unterschiedlich ist, oder gibt es eine Implementierung, mit der Sie alles, was Sie ben√∂tigen, aus der Box holen k√∂nnen?  Wir haben die zweite Option gew√§hlt.  Erstens l√∂st errorx ein sehr praktisches Problem - und unsere Erfahrung mit der Verwendung zeigt, dass es f√ºr diesen Zweck besser ist, eine L√∂sung zu haben, als Ersatzteile f√ºr die Erstellung.  Zweitens ist die √úberlegung zur Einfachheit sehr wichtig: Da Fehler weniger ber√ºcksichtigt werden, sollte der Code so gestaltet sein, dass es schwierig ist, mit ihnen zu arbeiten.  Die Praxis hat gezeigt, dass es daf√ºr wichtig ist, dass alle diese Codes gleich aussehen und funktionieren. </p><br><h4 id="tldr-po-osnovnym-ficham-biblioteki">  TL; DR nach Hauptbibliotheksfunktionen: </h4><br><ul><li>  Stack-Trace-Erstellungsorte in allen Fehlern standardm√§√üig </li><li>  Typpr√ºfungen auf Fehler, verschiedene Sorten </li><li>  Die M√∂glichkeit, einem vorhandenen Fehler Informationen hinzuzuf√ºgen, ohne etwas zu besch√§digen </li><li>  Geben Sie die Sichtbarkeitssteuerung ein, wenn Sie den urspr√ºnglichen Grund vor dem Anrufer verbergen m√∂chten </li><li>  Fehlerbehandlungs-Code-Generalisierungsmechanismus (Typhierarchie, Merkmale) </li><li>  Fehleranpassung durch dynamische Eigenschaften </li><li>  Standardfehlertypen </li><li>  Syntax-Dienstprogramme zur Verbesserung der Lesbarkeit von Fehlerbehandlungscode </li></ul><br><h3 id="vvedenie">  Einf√ºhrung </h3><br><p>  Wenn wir das oben analysierte Beispiel mit errorx √ºberarbeiten, erhalten wir Folgendes: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( DBErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"db"</span></span>) ErrDuplicateKey = DBErrors.NewType(<span class="hljs-string"><span class="hljs-string">"duplicate_key"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return ErrDuplicateKey.New("violated constraint %s", details) } func IsDuplicateKeyError(err error) bool { return errorx.IsOfType(err, ErrDuplicateKey) }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to insert user %s"</span></span>, u.Name) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Der <code>IsDuplicateKeyError()</code> mit <code>IsDuplicateKeyError()</code> √§ndert sich nicht. </p><br><p>  Was hat sich in diesem Beispiel ge√§ndert? </p><br><ul><li>  <code>ErrDuplicateKey</code> wurde zu einem Typ, nicht zu einer Fehlerinstanz.  Die √úberpr√ºfung ist resistent gegen Kopierfehler, es besteht keine fragile Abh√§ngigkeit von der exakten Gleichheit </li><li>  Es gibt einen Namespace f√ºr Datenbankfehler.  Es wird h√∂chstwahrscheinlich andere Fehler geben, und eine solche Gruppierung ist f√ºr die Lesbarkeit n√ºtzlich und kann in einigen F√§llen im Code verwendet werden </li><li>  Einf√ºgen gibt f√ºr jeden Aufruf einen neuen Fehler zur√ºck: <br><ul><li>  Der Fehler enth√§lt weitere Details.  Dies ist nat√ºrlich ohne errorx m√∂glich, aber es ist unm√∂glich, wenn jedes Mal dieselbe Fehlerinstanz zur√ºckgegeben wird, die zuvor f√ºr <code>IsDuplicateKeyError()</code> erforderlich war. </li><li>  Diese Fehler k√∂nnen eine andere Stapelverfolgung enthalten, was n√ºtzlich ist, weil  Nicht f√ºr alle Aufrufe der Einf√ºgefunktion ist diese Situation akzeptabel </li></ul></li><li>  <code>InsertUser()</code> erg√§nzt den Fehlertext, wendet jedoch den urspr√ºnglichen Fehler an, der f√ºr nachfolgende Vorg√§nge vollst√§ndig beibehalten wird </li><li>  <code>IsDuplicateKeyError()</code> funktioniert jetzt: Es kann weder durch Kopieren des Fehlers noch durch beliebig viele Ebenen mit Decorate () verw√∂hnt werden. </li></ul><br><p>  Es ist nicht notwendig, immer nur einem solchen Schema zu folgen: </p><br><ul><li>  Die Art des Fehlers ist bei weitem nicht immer eindeutig: Die gleichen Typen k√∂nnen an vielen Stellen verwendet werden </li><li>  Falls gew√ºnscht, kann die Stack-Trace-Sammlung deaktiviert werden, und Sie k√∂nnen nicht jedes Mal einen neuen Fehler erstellen, sondern denselben wie im urspr√ºnglichen Beispiel zur√ºckgeben.  Hierbei handelt es sich um sogenannte Sentinel-Fehler, deren Verwendung wir nicht empfehlen. Dies kann jedoch hilfreich sein, wenn der Fehler nur als Markierung im Code verwendet wird und Sie beim Erstellen von Objekten sparen m√∂chten </li><li>  Es gibt eine M√∂glichkeit, die <code>errorx.IsOfType(err, ErrDuplicateKey)</code> beenden, wenn Sie die Semantik der Grundursache vor neugierigen Blicken verbergen m√∂chten </li><li>  Neben dem Vergleich mit dem genauen Typ gibt es noch andere M√∂glichkeiten, die Typpr√ºfung selbst durchzuf√ºhren </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godoc</a> enth√§lt detaillierte Informationen zu all dem.  Im Folgenden werden die Hauptmerkmale, die f√ºr die t√§gliche Arbeit ausreichen, etwas n√§her erl√§utert. </p><br><h3 id="tipy">  Typen </h3><br><p>  Jeder errorx-Fehler geh√∂rt zu einem Typ.  Typ ist wichtig, weil  geerbte Fehlereigenschaften k√∂nnen durchlaufen werden;  Durch ihn oder seine Eigenschaften werden bei Bedarf Semantikpr√ºfungen durchgef√ºhrt.  Dar√ºber hinaus erg√§nzt der aussagekr√§ftige Name des Typs die Fehlermeldung und kann sie in einigen F√§llen ersetzen. </p><br><pre> <code class="go hljs">AuthErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"auth"</span></span>) ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>)</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ErrInvalidToken.NewWithNoMessage()</code> </pre> <br><p>  Die Fehlermeldung enth√§lt <code>auth.invalid_token</code> .  Die Fehlerdeklaration k√∂nnte anders aussehen: </p><br><pre> <code class="go hljs">ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>).ApplyModifiers(errorx.TypeModifierOmitStackTrace)</code> </pre> <br><p>  In dieser Ausf√ºhrungsform ist unter Verwendung des Typmodifikators die Stapelverfolgungssammlung deaktiviert.  Der Fehler hat eine Markersemantik: Sein Typ wird an den externen Benutzer des Dienstes √ºbergeben, und ein Aufrufstapel in den Protokollen w√§re nicht sinnvoll, da  Dies ist kein zu reparierendes Problem. </p><br><p>  Hier k√∂nnen wir den Vorbehalt machen, dass Fehler in mehreren Aspekten dualer Natur sind.  Der Inhalt des Fehlers wird sowohl f√ºr die Diagnose als auch manchmal als Information f√ºr einen externen Benutzer verwendet: API-Client, Bibliotheksbenutzer usw.  Fehler werden im Code sowohl als Mittel zur Vermittlung der Semantik des Geschehens als auch als Mechanismus zur √úbertragung der Kontrolle verwendet.  Bei der Verwendung von Fehlertypen sollte dies ber√ºcksichtigt werden. </p><br><h3 id="sozdanie-oshibki">  Fehlererstellung </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyType.New(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>)</code> </pre> <br><p>  Das Abrufen eines eigenen Typs f√ºr jeden Fehler ist v√∂llig optional.  Jedes Projekt kann ein eigenes Paket mit allgemeinen Fehlern haben, und einige S√§tze werden zusammen mit errorx als Teil des allgemeinen Namespace bereitgestellt.  Es enth√§lt Fehler, die in den meisten F√§llen keine Verarbeitung im Code beinhalten und f√ºr ‚ÄûAusnahmesituationen‚Äú geeignet sind, in denen ein Fehler aufgetreten ist. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IllegalArgument.New(<span class="hljs-string"><span class="hljs-string">"negative value %d"</span></span>, value)</code> </pre> <br><p>  In einem typischen Fall wird eine Aufrufkette so konzipiert, dass am Ende der Kette ein Fehler erstellt und am Anfang verarbeitet wird.  In Go wird es nicht ohne Grund als schlechte Form angesehen, einen Fehler zweimal zu verarbeiten, d. H. Beispielsweise einen Fehler in das Protokoll zu schreiben und ihn h√∂her im Stapel zur√ºckzugeben.  Sie k√∂nnen dem Fehler jedoch selbst Informationen hinzuf√ºgen, bevor Sie ihn weitergeben: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to upload '%s' to '%s'"</span></span>, filename, location)</code> </pre> <br><p>  Der dem Fehler hinzugef√ºgte Text wird im Protokoll angezeigt, es schadet jedoch nicht, den Typ des urspr√ºnglichen Fehlers zu √ºberpr√ºfen. </p><br><p>  Manchmal entsteht das gegenteilige Bed√ºrfnis: Unabh√§ngig von der Art des Fehlers sollte der externe Benutzer des Pakets ihn nicht kennen.  Wenn er eine solche Gelegenheit bekommen w√ºrde, k√∂nnte er eine fragile Abh√§ngigkeit von einem Teil der Implementierung schaffen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.ErrBadRequest.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to load user data"</span></span>)</code> </pre> <br><p>  Ein wichtiger Unterschied, der Wrap zur bevorzugten Alternative zu New macht, besteht darin, dass der urspr√ºngliche Fehler vollst√§ndig in den Protokollen wiedergegeben wird.  Und insbesondere wird es einen n√ºtzlichen ersten Aufrufstapel mit sich bringen. </p><br><p>  Ein weiterer n√ºtzlicher Trick, mit dem Sie alle m√∂glichen Informationen zum Aufrufstapel speichern k√∂nnen, sieht folgenderma√üen aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.EnhanceStackTrace(err, <span class="hljs-string"><span class="hljs-string">"operation fail"</span></span>)</code> </pre> <br><p>  Wenn der urspr√ºngliche Fehler von einer anderen Goroutine stammt, enth√§lt das Ergebnis eines solchen Aufrufs eine Stapelverfolgung beider Goroutinen, was die N√ºtzlichkeit ungew√∂hnlich erh√∂ht.  Die Notwendigkeit, einen solchen Anruf zu t√§tigen, ist eindeutig auf Leistungsprobleme zur√ºckzuf√ºhren: Dieser Fall ist relativ selten, und eine Ergonomie, die ihn selbst erkennt, w√ºrde den √ºblichen Wrap verlangsamen, wenn er √ºberhaupt nicht erforderlich ist. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godoc</a> enth√§lt weitere Informationen und beschreibt zus√§tzliche Funktionen wie DecorateMany. </p><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Am besten, wenn die Fehlerbehandlung auf Folgendes zur√ºckzuf√ºhren ist: </p><br><pre> <code class="go hljs">log.Error(<span class="hljs-string"><span class="hljs-string">"Error: %+v"</span></span>, err)</code> </pre> <br><p>  Je weniger Fehler Sie machen m√ºssen, au√üer um sie in das Protokoll auf der Systemschicht des Projekts zu drucken, desto besser.  In Wirklichkeit reicht dies manchmal nicht aus, und Sie m√ºssen dies tun: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errorx.IsOfType(err, MyType) { <span class="hljs-comment"><span class="hljs-comment">/* handle */</span></span> }</code> </pre> <br><p>  Diese Pr√ºfung ist sowohl bei einem Fehler vom Typ <code>MyType</code> als auch bei seinen <code>MyType</code> Typen erfolgreich und ist gegen <code>errorx.Decorate()</code> resistent.  Hier besteht jedoch eine direkte Abh√§ngigkeit von der Art des Fehlers, was innerhalb des Pakets ganz normal ist, aber bei Verwendung au√üerhalb des Pakets unangenehm sein kann.  In einigen F√§llen ist der Typ eines solchen Fehlers Teil einer stabilen externen API, und manchmal m√∂chten wir diese Pr√ºfung durch eine Eigenschaftspr√ºfung ersetzen und nicht durch die genaue Art des Fehlers. </p><br><p>  Bei klassischen Go-Fehlern w√ºrde dies √ºber eine Schnittstelle erfolgen, deren Typ als Indikator f√ºr die Art des Fehlers dient.  Errorx-Typen unterst√ºtzen diese Erweiterung nicht, Sie k√∂nnen jedoch stattdessen den <code>Trait</code> Mechanismus verwenden.  Zum Beispiel: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTemporary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HasTrait(err, Temporary()) }</code> </pre> <br><p>  Diese in errorx integrierte Funktion pr√ºft, ob der Fehler die Standardeigenschaft <code>Temporary</code> , d. H.  ob es vor√ºbergehend ist.  Das Markieren von Fehlertypen mit Merkmalen liegt in der Verantwortung der Fehlerquelle und kann durch diese ein n√ºtzliches Signal √ºbertragen, ohne dass bestimmte interne Typen Teil der externen API sind. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IgnoreWithTrait(err, errorx.NotFound())</code> </pre> <br><p>  Diese Syntax ist n√ºtzlich, wenn eine bestimmte Art von Fehler erforderlich ist, um den Steuerungsfluss zu unterbrechen, sie sollte jedoch nicht an die aufrufende Funktion √ºbergeben werden. </p><br><p>  Trotz der F√ºlle an Verarbeitungswerkzeugen, von denen hier nicht alle aufgef√ºhrt sind, ist es wichtig zu bedenken, dass das Arbeiten mit Fehlern so einfach wie m√∂glich bleiben sollte.  Ein Beispiel f√ºr die Regeln, die wir einhalten wollen: </p><br><ul><li>  Code, der einen Fehler empf√§ngt, sollte ihn immer vollst√§ndig protokollieren.  Wenn ein Teil der Informationen √ºberfl√ºssig ist, lassen Sie den Code, der den Fehler erzeugt, dies erledigen </li><li>  Sie sollten niemals den Fehlertext oder das Ergebnis der Funktion <code>Error()</code> verwenden, um ihn im Code zu verarbeiten.  Hierf√ºr sind nur Typ- / Merkmalspr√ºfungen geeignet oder bei Nicht-Errorx-Fehlern eine Typzusicherung </li><li>  Der Benutzercode sollte nicht besch√§digt werden, da ein Fehler nicht auf besondere Weise verarbeitet wird, auch wenn eine solche Verarbeitung m√∂glich ist und zus√§tzliche Funktionen bietet </li><li>  Fehler, die von Eigenschaften √ºberpr√ºft werden, sind besser als sogenannte Sentinel-Fehler, weil  solche Kontrollen sind weniger fragil </li></ul><br><h3 id="vne-errorx">  Au√üerhalb errorx </h3><br><p>  Hier haben wir beschrieben, was dem Bibliotheksbenutzer sofort zur Verf√ºgung steht, aber in Joom ist die Penetration von fehlerbezogenem Code sehr gro√ü.  Das Protokollierungsmodul akzeptiert explizit Fehler in seiner Signatur und druckt sich selbst aus, um die M√∂glichkeit einer falschen Formatierung auszuschlie√üen und optional verf√ºgbare Kontextinformationen aus der Fehlerkette zu extrahieren.  Das Modul, das f√ºr die paniksichere Arbeit mit Goroutins verantwortlich ist, entpackt den Fehler, wenn er mit einer Panik auftritt, und wei√ü auch, wie man Panik mithilfe der Fehlersyntax darstellt, ohne den urspr√ºnglichen Stack-Trace zu verlieren.  Einige davon werden wir vielleicht auch ver√∂ffentlichen. </p><br><h2 id="voprosy-sovmestimosti">  Kompatibilit√§tsprobleme </h2><br><p>  Trotz der Tatsache, dass wir sehr zufrieden sind, wie errorx es uns erm√∂glicht, mit Fehlern zu arbeiten, ist die Situation mit dem diesem Thema gewidmeten Bibliothekscode alles andere als ideal.  Wir bei Joom l√∂sen ganz bestimmte praktische Probleme mit errorx, aber aus Sicht des Go-√ñkosystems w√§re es vorzuziehen, diesen gesamten Satz von Werkzeugen in der Standardbibliothek zu haben.  Der Fehler, dessen Quelle tats√§chlich oder m√∂glicherweise zu einem anderen Paradigma geh√∂rt, muss als fremd angesehen werden, d. H.  m√∂glicherweise keine Informationen in der Form enthalten, die im Projekt akzeptiert wird. </p><br><p>  Es wurden jedoch einige Ma√ünahmen ergriffen, um nicht mit anderen vorhandenen L√∂sungen in Konflikt zu geraten. </p><br><p>  Das Format <code>'%+v'</code> verwendet, um einen Fehler zusammen mit der Stapelverfolgung zu drucken, falls vorhanden.  Dies ist der De-facto-Standard im Go-√ñkosystem und sogar im Entwurfsentwurf f√ºr Go 2 enthalten. </p><br><p>  <code>Cause() error</code>  errorx ,  ,   ,    Causer,       errorx      Wrap(). </p><br><h2 id="buduschee">  </h2><br><p>  <a href=""></a>   ,    Go 2,      .  <a href="">   </a>       . </p><br><p> ,    errorx     Go 1.      ,    Go 2,     .       ,            ,        errorx. </p><br><p> Check-handle      ,   errorx , a <code>Unwrap() error</code>       <code>Wrap()</code>  errorx (.. ,        ,    <code>Wrap</code> ),    .     ,      ,  . </p><br><p>     design draft   Go 2,    <code>errorx.Is()</code>  <code>errorx.As()</code>   ,      errors   . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>   ,   ,   ,    -      ,        .      ,      API     :  ,   ,       .  1.0      ,           Joom. ,  -       . </p><br><p> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/joomcode/errorx</a> </p><br><p>   ,    ! </p><br><p><img src="https://habrastorage.org/webt/nk/hv/el/nkhvelss5upmybktmbpy68ozo_a.jpeg" alt="Bild"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429690/">https://habr.com/ru/post/de429690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429680/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 1</a></li>
<li><a href="../de429682/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 2</a></li>
<li><a href="../de429684/index.html">Firebase Summit 2018: kurz zur Hauptsache</a></li>
<li><a href="../de429686/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: ‚ÄûBenutzerauthentifizierung‚Äú, Teil 3</a></li>
<li><a href="../de429688/index.html">Wie man einen Helden erschafft, dem man glauben wird</a></li>
<li><a href="../de429692/index.html">Optimierung der Ereignisbehandlung in Angular</a></li>
<li><a href="../de429694/index.html">Mail.Ru nannte Yandex-Rankings ‚Äûabsurd‚Äú und fordert, seine Marken daraus zu entfernen</a></li>
<li><a href="../de429696/index.html">Videoberichte mit MOSDROID # 13 Aluminium</a></li>
<li><a href="../de429698/index.html">So arbeiten Sie mit Lebedev Studio: Tutu.ru Erfahrung</a></li>
<li><a href="../de429700/index.html">Definition von Zahlen nach Geh√∂r</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>