<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♉️ 👖 👩🏼‍🏫 Cours MIT "Sécurité des systèmes informatiques". Conférence 14: «SSL et HTTPS», partie 1 👨🏾‍🎤 💊 ⛹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "Sécurité des systèmes informatiques." Nikolai Zeldovich, James Mickens. 2014 année...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "Sécurité des systèmes informatiques". Conférence 14: «SSL et HTTPS», partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/427783/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "Sécurité des systèmes informatiques."  Nikolai Zeldovich, James Mickens.  2014 année </h3><br>  Computer Systems Security est un cours sur le développement et la mise en œuvre de systèmes informatiques sécurisés.  Les conférences couvrent les modèles de menace, les attaques qui compromettent la sécurité et les techniques de sécurité basées sur des travaux scientifiques récents.  Les sujets incluent la sécurité du système d'exploitation (OS), les fonctionnalités, la gestion du flux d'informations, la sécurité des langues, les protocoles réseau, la sécurité matérielle et la sécurité des applications Web. <br><br>  Cours 1: «Introduction: modèles de menace» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 2: «Contrôle des attaques de pirates» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 3: «Débordements de tampon: exploits et protection» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 4: «Séparation des privilèges» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 5: «D'où viennent les systèmes de sécurité?» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> <br>  Conférence 6: «Opportunités» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 7: «Native Client Sandbox» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 8: «Modèle de sécurité réseau» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 9: «Sécurité des applications Web», <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 10: «Exécution symbolique» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 11: «Ur / Web Programming Language» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 12: Sécurité du réseau, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 13: «Protocoles réseau», <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 3</a> <br>  Conférence 14: «SSL et HTTPS» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Nous allons maintenant voir comment les protocoles cryptographiques sont utilisés pour protéger les connexions réseau sur Internet et comment ils interagissent généralement avec les facteurs réseau.  Avant d'entrer dans les détails, je tiens à vous rappeler qu'il y aura un test mercredi, mais pas dans ce public, mais à Walker, au 3ème étage, lors d'un cours régulier. <br><br><img src="https://habrastorage.org/webt/xe/vb/0j/xevb0jkxnzy3og_ofywkhfmhzli.jpeg"><br><br>  Donc, aujourd'hui, nous allons parler de la façon dont Internet utilise la cryptographie pour protéger une connexion réseau et examiner deux sujets étroitement liés. <br><br>  La première est de savoir comment sécuriser cryptographiquement les connexions à une plus grande échelle que le système Kerberos, que nous avons couvert dans la dernière conférence, protège.  La seconde est de savoir comment intégrer cette protection cryptographique, fournie au niveau du réseau, dans l'ensemble de l'application, et comment le navigateur Web garantit l'utilisation de la protection fournie par le protocole cryptographique.  Ces sujets sont étroitement liés, il s'avère donc que la protection des communications réseau est assez facile à fournir, car la cryptographie fonctionne toujours.  Mais l'intégrer dans le navigateur est une tâche beaucoup plus difficile que de construire un système autour de la cryptographie. <br><br>  Avant de plonger dans cette discussion, je veux vous rappeler les éléments de base de la cryptographie que nous utiliserons. <br><br>  Dans notre dernière conférence sur Kerberos, nous avons utilisé la cryptographie symétrique, ou <br>  cryptage et décryptage.  Cela signifie que vous avez une clé secrète K et deux fonctions.  Ainsi, vous pouvez prendre des données, appelons-le P, c'est du texte brut auquel vous pouvez appliquer la fonction de chiffrement, et c'est la fonction d'une clé K. Et si vous chiffrez ce texte brut, vous obtiendrez le texte chiffré C.De même, nous avons il existe une fonction de déchiffrement D qui utilise la même clé K, à la suite de quoi le texte chiffré C se transformera en texte brut P. C'est la primitive autour de laquelle Kerberos a été construit. <br><br><img src="https://habrastorage.org/webt/pg/km/c5/pgkmc5lrc_vzzniemf7k_qxv0c8.jpeg"><br><br>  Mais il s'avère qu'il existe d'autres primitives qui seront utiles pour la discussion d'aujourd'hui, et qui sont appelées chiffrement et déchiffrement asymétriques.  L'idée ici est d'avoir différentes clés pour le chiffrement et le déchiffrement.  Voyons pourquoi cela est si utile. <br><br>  Ici, il y a une fonction E, qui peut chiffrer un certain ensemble de messages P avec une certaine clé publique pk, pour obtenir le texte chiffré C. Pour le déchiffrer avec la fonction D, il suffit de spécifier la clé secrète correspondante sk et d'obtenir le texte source P. <br><br><img src="https://habrastorage.org/webt/oy/xp/3j/oyxp3jjifkqzcsikcgjrbmtaj_g.jpeg"><br><br>  La commodité du chiffrement asymétrique est que vous pouvez publier une clé publique sur Internet et que les gens peuvent chiffrer les messages pour vous, mais vous avez besoin d'une clé secrète pour déchiffrer leurs messages.  Aujourd'hui, nous verrons comment cela est utilisé dans le protocole.  En pratique, vous utiliserez souvent la cryptographie à clé publique d'une manière légèrement différente.  Par exemple, au lieu de chiffrer et de déchiffrer des messages, vous devrez peut-être signer ou vérifier des messages. <br><br>  Il s'avère qu'au niveau de l'implémentation, ce sont des opérations connexes, mais au niveau de l'application API, elles peuvent sembler un peu différentes.  Par exemple, vous pouvez signer le message M avec votre clé secrète sk et obtenir une signature S. Ensuite, vous pouvez vérifier ce message avec la clé publique correspondante pk et en conséquence obtenir un indicateur logique indiquant si la signature S est correcte pour le message M. <br><br><img src="https://habrastorage.org/webt/ib/2a/0j/ib2a0j4ie3lp28irckclwqkd6tw.jpeg"><br><br>  Voici quelques garanties relativement intuitives qui offrent ces fonctionnalités.  Si, par exemple, vous avez reçu cette signature et qu'elle est vérifiée correctement, cela signifie qu'elle devait être générée par quelqu'un avec la bonne clé secrète.  Est-ce clair? <br><br>  Essayons ensuite de comprendre comment protéger les connexions réseau à une plus grande échelle que Kerberos.  À Kerberos, nous avions un modèle assez simple, où tous les utilisateurs et serveurs utilisaient une sorte de connexion avec l'objet KDC, qui avait cette table géante d'utilisateurs, de services et leurs clés.  Chaque fois qu'un utilisateur veut parler à un serveur, il doit demander à KDC de créer le ticket dont il a besoin en fonction de cette table géante. <br><br><img src="https://habrastorage.org/webt/_p/re/mf/_premfpwfmsf-ux_g91rdizrpkk.jpeg"><br><br>  Cela semble donc être un modèle assez simple.  Alors pourquoi avons-nous besoin d'autre chose?  Pourquoi Kerberos n'est-il pas assez bon pour travailler avec des sites?  Pourquoi Internet n'utilise-t-il pas Kerberos exclusivement pour sécuriser toutes les connexions? <br><br>  Vous avez répondu correctement - parce que le seul KDC devrait faire confiance à tout le monde, et c'est mauvais.  Vous pouvez avoir des problèmes si vous considérez qu'une certaine machine est absolument sûre. <br><br>  Peut-être que les gens du MIT sont prêts à faire confiance à quelqu'un sur le réseau local géré par KDC, mais pas à tout le monde sur Internet. <br><br>  Et la réponse du deuxième étudiant est également correcte - il est très difficile de gérer un si grand nombre de clés.  En fait, il peut être très difficile de construire un seul KDC capable de gérer un milliard de clés ou dix milliards de clés pour toutes les personnes dans le monde.  Une autre complication de l'utilisation de Kerberos pour l'ensemble d'Internet est que tous les utilisateurs doivent avoir une clé ou doivent être connus par KDC.  Vous ne pouvez même pas utiliser Kerberos dans notre institut pour vous connecter à certains serveurs si vous n'avez pas de compte dans la base de données Kerberos.  Alors que pour tout Internet, il est tout à fait raisonnable de s'attendre à ce que lorsque vous allez à l'ordinateur, il ne sache pas du tout qui vous êtes, mais cela vous permettra d'aller sur le site Web d'Amazon, qui est protégé par la cryptographie. <br><br><img src="https://habrastorage.org/webt/yq/ok/mn/yqokmnixur_msywempw4ufdtd80.jpeg"><br><br>  Hein? <br><br>  Il y a plusieurs autres choses que vous attendez d'un protocole cryptographique, et nous verrons comment elles apparaissent dans SSL.  Mais l'idée clé est que cette solution est la même pour Kerberos et pour SSL ou TLS.  Vous avez raison lorsque vous mentionnez que les protocoles Kerberos originaux que nous lisons dans les documents de cours ont été développés il y a longtemps.  Et si nous voulons les utiliser pour l'Internet moderne, ils devront changer quelque chose.  Quelles autres pensées avez-vous, pourquoi ne devrions-nous pas utiliser Kerberos? <br><br>  C'est vrai, il y a un problème de mise à l'échelle lors de la restauration de l'accès, et éventuellement lors de l'enregistrement de nouveaux utilisateurs, car vous devrez vous rendre personnellement dans un bureau de compte et y ouvrir un compte.  Quoi d'autre? <br><br>  <b>Étudiant: Le</b> serveur Kerberos doit toujours être en ligne. <br><br>  <b>Professeur:</b> oui, c'est un autre problème.  Nous avons répertorié certains types de problèmes de gestion, mais au niveau du protocole, KDC doit toujours être en ligne, car il sert en fait d'intermédiaire pour toutes vos interactions avec les services.  Cela signifie que chaque fois que vous visitez un nouveau site Web, vous devez parler à KDC.  Premièrement, ce sera un goulot d'étranglement en termes de performances.  Comme d'autres types d'évolutivité, ce principe conduira à une évolutivité des performances, tandis que les principes énumérés ci-dessus ne conduisent qu'à une évolutivité de la gestion. <br><br><img src="https://habrastorage.org/webt/_o/nb/xw/_onbxws5l_wixnqzzhhqnhniknk.jpeg"><br><br>  Alors, comment pouvons-nous résoudre ce problème en utilisant ces principes?  L'idée est d'utiliser le chiffrement par clé pour arrêter d'utiliser KDC. <br><br>  Voyons d'abord si vous pouvez établir une connexion sécurisée si vous ne connaissez que certaines des clés publiques de l'autre côté.  Et puis nous verrons comment nous connectons la version de la clé publique KDC à l'authentification des parties dans ce protocole.  Si vous ne souhaitez pas utiliser KDC, vous pouvez effectuer les opérations suivantes avec la cryptographie à clé publique: découvrez en quelque sorte la clé publique du partenaire de l'autre côté de la connexion.  Donc, à Kerberos, si je veux me connecter à un serveur de fichiers, je connais la clé publique du serveur de fichiers quelque part.  En tant que recrue, je reçois un imprimé disant que la clé publique du serveur de fichiers est telle ou telle, et je peux l'utiliser pour me connecter. <br><br>  Vous pouvez simplement crypter le message pour la clé publique du serveur de fichiers auquel vous souhaitez vous connecter.  Mais il s'avère qu'en pratique, ces opérations avec ces clés publiques sont assez lentes.  Ils sont plusieurs ordres de grandeur plus lents que les clés de chiffrement symétriques.  Donc, dans la pratique, vous souhaitez généralement toujours abandonner l'utilisation du chiffrement public. <br><br>  Ainsi, un protocole typique pourrait ressembler à ceci.  Vous avez A et B, ils veulent communiquer, et A connaît la clé publique B. En même temps, A génère une sorte de clé de session S, en choisissant simplement un nombre aléatoire pour cela.  Ensuite, A est sur le point d'envoyer la clé de session S B, il ressemble donc à Kerberos.  Nous allons chiffrer la clé de session S pour B. <br><br>  Si vous vous souvenez, à Kerberos, pour ce faire, nous avions besoin d'un KDC parce que A ne connaissait pas la clé de B ou qu'il n'était pas autorisé à la connaître, car c'est un secret que seul B peut connaître. Mais avec une clé publique, vous pouvez le faire immédiatement, il suffit de crypter le secret avec cette clé publique Bspk et d'envoyer le message B. Maintenant, B peut décrypter ce message et dire: j'ai besoin d'utiliser cette clé secrète.  Nous avons maintenant un canal de communication où tous les messages sont simplement cryptés avec cette clé secrète S. <br><br><img src="https://habrastorage.org/webt/22/o9/mt/22o9mt6zwalsi4qdqdxslwf9-0a.jpeg"><br><br>  Il y a donc quelques fonctionnalités utiles dans ce protocole.  Premièrement, nous nous sommes débarrassés de la nécessité d'avoir KDC en ligne et de générer une clé de session pour nous.  Nous pourrions simplement garantir la confidentialité des informations transmises si l'une des parties à la connexion les génère puis les chiffre pour l'autre sans utiliser KDC. <br><br>  Une autre bonne chose est la certitude que seul B peut lire les messages envoyés de A à B, car seul B peut déchiffrer ce message.  Par conséquent, B doit avoir la clé privée correspondante S. <br><br>  <b>Étudiant:</b> importe qui donne cette clé - utilisateur ou serveur? <br><br>  <b>Professeur:</b> peut <b>-</b> être.  Je pense que cela dépend des propriétés que vous voulez de ce protocole.  Par conséquent, que se passe-t-il si A fait une erreur ou utilise le mauvais caractère aléatoire, le serveur qui renvoie les données pense: "Oh, maintenant ce sont les seules données que A verra."  Ce n'est peut-être pas tout à fait vrai, alors vous devriez y penser.  Il existe plusieurs autres problèmes avec ce protocole. <br><br>  <b>Étudiant:</b> Un attaquant peut-il utiliser une clé pour envoyer des messages répétés? <br><br>  <b>Professeur:</b> oui, le problème peut être que je peux simplement envoyer à nouveau ces messages, et il semblera que c'est A qui envoie à nouveau le message B, et ainsi de suite. <br><br>  Par conséquent, généralement la solution à ce problème est que les deux côtés de la connexion sont impliqués dans la génération de S et cela garantit que la clé que nous utilisons est «fraîche».  Parce qu'ici, sur la figure, en réalité, B ne génère rien, de sorte que ces messages de protocole se ressemblent à chaque fois. <br><br>  Il arrive généralement qu'un côté choisisse un nombre aléatoire comme S, puis l'autre côté, B, choisit également un nombre aléatoire, généralement appelé nonce.  Il y a deux chiffres et une clé qui n'est pas vraiment sélectionnée uniquement par un côté, c'est un hachage que les deux côtés ont choisi pour l'interaction conjointe.  En plus du hachage, vous pouvez utiliser le protocole Diffie-Hellman, que nous avons examiné dans la dernière conférence, grâce auquel vous obtenez d'abord la confidentialité.  Il s'agit de mathématiques plus compliquées que de simplement hacher deux nombres aléatoires qui ont choisi ces deux côtés.  Mais vous obtiendrez alors une propriété aussi bonne que la clé secrète partagée d'origine, éliminant ainsi la nécessité de transférer la clé de déchiffrement lors de la transmission de données chiffrées. <br><br>  Ainsi, des attaques répétées peuvent être évitées comme suit.  B génère un nonce et définit ensuite la vraie clé secrète S ', qui est utilisée pour hacher la clé secrète S avec ce nonce.  Et, bien sûr, B devrait renvoyer le nonce à A pour savoir ce qui se passe lorsqu'ils s'accordent tous les deux sur la clé. <br><br><img src="https://habrastorage.org/webt/d1/kj/yd/d1kjydts_olj6gitw4qnayq6aac.jpeg"><br><br>  Un autre problème est qu'il n'y a pas de véritable authentification A. A sait qui est B, ou du moins sait qui peut décrypter les données.  Mais B n'a aucune idée de qui est de l'autre côté, que ce soit une sorte d'adversaire se faisant passer pour un autre ou quelqu'un d'autre.  Comment résoudre ce problème dans le monde des clés publiques? <br><br>  Il existe plusieurs façons de procéder.  Une possibilité est de signer ce message initialement, car nous avons ce bon principe de signe.  Nous pourrions donc peut-être signer cela avec une clé secrète.  Ce signe fournit simplement une signature, mais vous l'assignez probablement, et vous fournissez également ce message. <br><br>  Ensuite, B doit savoir que A est une clé publique afin de vérifier la signature.  Mais si B sait que A est une clé publique, alors B sera à peu près sûr que A est celui qui a envoyé ce message. <br><br><img src="https://habrastorage.org/webt/9k/zg/xq/9kzgxqxgtokahv9sq5goydxluvk.jpeg"><br><br>  Vous pouvez également faire confiance au chiffrement.  Donc peut-être que B peut renvoyer nonce à A, en le chiffrant avec la clé publique fournie par A. Et alors seulement A peut déchiffrer nonce et générer la clé de session finale S '.  Il y a donc quelques astuces que vous pourriez faire.  C'est ainsi que les certificats clients fonctionnent aujourd'hui dans les navigateurs Internet. <br><br>  Ainsi, A possède une clé secrète et, par conséquent, lorsque vous recevez un certificat MIT personnel, votre navigateur crée une clé secrète de longue durée et reçoit un certificat pour celle-ci.  Et chaque fois que vous envoyez une demande au serveur Web, vous prouvez que vous connaissez la clé secrète de votre certificat utilisateur, puis définissez la clé secrète S pour le reste de la connexion. <br><br>  Ce sont des problèmes qui sont assez facilement résolus au niveau du protocole.  Cependant, la base de tout ce qui précède est que toutes les parties connaissent les clés publiques de l'autre.  Comment savoir la clé publique de quelqu'un?  Supposons que je veuille me connecter à un site Web, que j'ai une URL à laquelle je veux me connecter, ou un nom d'hôte, comment puis-je savoir quelle clé publique correspond? <br><br>  De même, si je me connecte au serveur MIT pour voir mes notes, comment le serveur sait-il quelle devrait être ma clé publique pour la distinguer de la clé publique d'un autre étudiant du MIT? <br><br>  C'est le principal problème que le KDC a abordé.  En fait, KDC a résolu deux problèmes pour nous.  Tout d'abord, il a généré un message (Ebspk (S)), créé une clé de session et l'a chiffrée pour le serveur.  Nous avons maintenant corrigé cela en créant une cryptographie à clé publique.  Mais nous devions également faire correspondre les noms de chaîne principaux aux clés cryptographiques Kerberos qui nous avaient été fournies plus tôt. <br><br>  Il existe un protocole TLC pour de telles choses dans le monde HTTPS.  Cela signifie que nous continuerons à nous appuyer sur certains aspects du processus qui prennent en charge ces gigantesques tables qui mappent les noms des participants au processus aux clés cryptographiques.  Le plan est que nous aurons quelque chose appelé une autorité de certification, qui est indiquée par les lettres CA dans toutes sortes de littérature sur la sécurité du réseau.  Cette autorité de certification prend également en charge logiquement le tableau, dans une partie dont les noms de tous les participants sont affichés, et dans l'autre - les clés publiques correspondantes.  La principale différence entre ce centre et Kerberos est que cette autorité de certification n'a pas à être en ligne pour toutes les transactions. <br>  À Kerberos, pour vous connecter avec quelqu'un ou trouver la clé de quelqu'un d'autre, vous devez parler à KDC.  Au lieu de cela, dans le monde de CA, ils le font. <br><br><img src="https://habrastorage.org/webt/n7/sr/ag/n7sragiofvbto-bml-z-y5vszdi.jpeg"><br><br>  Si vous avez ici une sorte de nom et la clé correspondante dans une autre partie du tableau, l'autorité de certification va simplement signer des messages indiquant que certaines lignes existent dans ce tableau.  Ainsi, l'autorité de certification devra avoir ses propres clés privées et publiques ici.  Il utilisera une clé secrète pour trouver des messages pour d'autres utilisateurs sur le système sur lesquels vous pouvez compter. <br><br>  Donc, si vous avez un enregistrement «nom + clé» dans la base de données de l'autorité de certification, l'autorité de certification créera un message indiquant que ce nom correspond à cette clé publique et signera ce message avec sa clé privée de l'autorité de certification. <br><br><img src="https://habrastorage.org/webt/4v/7q/1u/4v7q1ulrryyh20haewxx5hbd-xo.jpeg"><br><br>  Cela vous permet de faire des choses très similaires à ce que fait Kerberos, mais en même temps, nous nous débarrassons de la nécessité de trouver une CA en ligne pour toutes les transactions.  Et, il sera en fait beaucoup plus évolutif.  C'est exactement ce qu'on appelle communément un certificat.  L'évolutivité est assurée par le fait que pour un client ou toute autre personne utilisant ce système, un certificat fourni par une source n'est pas inférieur à un certificat provenant d'une autre source.  Il est signé par la clé secrète de l'autorité de certification.  Vous pouvez donc vérifier son authenticité sans avoir à contacter une autorité de certification ou toute autre partie répertoriée ici. <br><br>  Ça fonctionne comme ça.  Le serveur avec lequel vous souhaitez parler stocke le certificat qu'il a initialement reçu de l'autorité de certification.  Et chaque fois que vous vous y connectez, le serveur vous dit: «OK, voici mon certificat.  Il a été signé par ce CA.  Vous pouvez vérifier la signature et vous assurer qu'il s'agit bien de ma clé publique et de mon nom. » <br><br>  En revanche, la même chose se produit avec les certificats clients.  Lorsqu'un utilisateur se connecte au serveur Web, son certificat client indique que votre clé publique correspond à la clé secrète générée à l'origine dans le navigateur.  Ainsi, lors de la connexion au serveur, vous allez présenter un certificat signé par l'autorité de certification MIT, qui indique que votre nom d'utilisateur correspond à cette clé publique.     ,  ,    , ,       Athena. <br><br> <b>:</b>   ,      ? <br><br> <b>:</b> ,     ,    –   ,       ?  -      , ,  , ,    .    -      ,          .    .       ,  VeriSign. US Postal Service       CA,      ,           .  ,  CA  ,       KDC. <br><br>  ,      ,   Kerberos. ,    ,          KDC.        ,       KDC,       ,       .        ,          ,        .            CA  ,   KDS. <br><br> <b>:</b>      ? <br><br> <b>:</b> ,    .  ,   ,    KDC,          .    ,    .   , ,      .  ,  ,   ,  .       Kerberos,     .  Kerberos       ,       .  ,    ,      .     ,        ,        .    ,     . <br><br>   ,        .   ,  , CA        - ,     . ,        amazon.com,             amazon.com.     CA,       .  ,        ,     ,      . <br><br><img src="https://habrastorage.org/webt/te/xw/6a/texw6avc3kshcb4gza2tfknu0ac.jpeg"><br><br>     . , CA   ,    ,   ,    ,    -   ,     .  ,       ,        .   - ,     amazon.com,           ,   -       . <br><br>  ,     -,    ,    ,       ,    .    ,      .     «» ,    ,     . <br><br>   ,    . -,            CRL, ertificate Revocation List.    .       ,  -   ,    . ,  ,       ,       : «,    ,   ,   -       .     ,      ». <br><br>  ,   ,  ,     CRL,  ,   web-,     CRL. ,    - ,   ,       .     ,   ,     ,      ,        ,     . <br><br>     ,     .      ,       .          ,   .     ,             .       ,        CRL,         -   . <br><br> ,    ?      ,     .  ,       CRL   . <br><br>     ,       ,  ,      Kerberos,      KDC.   CA      ,         .    ,  «    SSL »,  OCSP.       CA   KDC.  ,    ,  ,     ,    ,       , -      .  ,   OCSP,        : «,    .   ,     »?  ,       CRL   .   ,     ,      .    ,    ,          . <br><br> 26:30  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> MIT «  ».  14: «SSL  HTTPS»,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q1OF_0ICt9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>  Merci de rester avec nous.    ?  Vous voulez voir des matériaux plus intéressants?  Soutenez-nous en passant une commande ou en le recommandant à vos amis, une <b>réduction de 30% pour les utilisateurs Habr sur un analogue unique de serveurs d'entrée de gamme que nous avons inventés pour vous:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la vérité sur VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbps à partir de 20 $ ou comment diviser le serveur?</a>  (les options sont disponibles avec RAID1 et RAID10, jusqu'à 24 cœurs et jusqu'à 40 Go de DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 cœurs) 10 Go DDR4 240 Go SSD 1 Gbit / s jusqu'en décembre gratuitement</b> en payant pour une période de six mois, vous pouvez commander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br> <b>Dell R730xd  2  ?</b>  Nous avons seulement <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 Go DDR4 6x480 Go SSD 1 Gbps 100 TV à partir de 249 $</a> aux Pays-Bas et aux États-Unis!</b>  Pour en savoir plus sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">création d'un bâtiment d'infrastructure.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe utilisant des serveurs Dell R730xd E5-2650 v4 coûtant 9 000 euros pour un sou?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427783/">https://habr.com/ru/post/fr427783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427771/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 13: Network Protocols, Part 2</a></li>
<li><a href="../fr427773/index.html">J'ai écrit une extension multi-navigateur pour les onglets, mais vous ne le faites pas</a></li>
<li><a href="../fr427775/index.html">Un bot déguisé en programmeur corrige les erreurs de code</a></li>
<li><a href="../fr427779/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 13: Network Protocols, Part 3</a></li>
<li><a href="../fr427781/index.html">Pourquoi les organisations de crédit data science</a></li>
<li><a href="../fr427785/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 14: «SSL et HTTPS», partie 2</a></li>
<li><a href="../fr427787/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 14: «SSL et HTTPS», partie 3</a></li>
<li><a href="../fr427789/index.html">Exxon Mobil accusé d'avoir manipulé les données d'impact environnemental de l'entreprise pour tromper les investisseurs</a></li>
<li><a href="../fr427793/index.html">Winamp 2019: retour triomphal et perspectives vagues</a></li>
<li><a href="../fr427795/index.html">[Vendredi] AI Revenge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>