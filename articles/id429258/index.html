<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎨 📋 😭 Cara membuat mekanik game yang andal hanya menggunakan Excel: pemodelan dan optimalisasi solusi 💆🏾 🧥 🧕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami sedang mencari, bukan iterasi 
 Desain game pada dasarnya adalah proses pencarian . Terlibat dalam desain, kami mengeksplorasi banyak konfigurasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat mekanik game yang andal hanya menggunakan Excel: pemodelan dan optimalisasi solusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429258/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ba/eee/530/6baeee530aa3ef791ab56d2a8e9228d7.png" alt="gambar"></div><br><h2>  Kami sedang mencari, bukan iterasi </h2><br>  Desain game pada dasarnya adalah proses <i>pencarian</i> .  Terlibat dalam desain, kami mengeksplorasi banyak konfigurasi desain yang mungkin untuk memecahkan masalah desain tertentu.  Misalnya, ini bisa menjadi cara menghubungkan kamar di ruang bawah tanah, serangkaian fungsi dan keterampilan yang dimiliki berbagai agen game, "angka ajaib" yang menentukan efektivitas unit dalam sistem pertempuran, atau kombinasi kemampuan yang akan hadir dalam permainan kami. <br><br>  Sama seperti karakter yang dikendalikan AI menggunakan sistem pencarian jalur untuk menavigasi dunia game, seorang desainer perlu menavigasi ruang tingkat tinggi dari kemungkinan konfigurasi, mengambil beberapa konfigurasi awal dan mengubahnya secara iteratif.  Kami dengan cermat mempertimbangkan aspek terpisah dari desain - sistem pertempuran, salah satu bagian dari dunia game, pohon teknologi dalam strategi - dan mencoba menemukan cara untuk memperbaikinya dengan mengubah konfigurasi ini. <br><br>  Desainer suka menggunakan istilah "iterasi" untuk menggambarkan proses ini, tetapi kata "pencarian" akan lebih cocok di sini.  Yang benar adalah ketika kita membuat "iterasi" desain, kita bereksperimen dengan game yang sedang dikembangkan.  Kami membuat asumsi yang masuk akal tentang set kecil modifikasi yang mengubah konfigurasi desain saat ini menjadi yang baru, yang, menurut pendapat kami, akan lebih memenuhi kriteria desain. <br><br>  "Iterasi" seperti itu sama sekali tidak seperti perubahan linear yang biasanya terjadi pada "iterasi" kode komputer;  jauh lebih mirip pencarian dalam labirin dengan banyak belokan tajam dan pengembalian paksa.  Seringkali mereka membawa kita lebih dekat ke gawang, tetapi seringkali tidak jelas apakah permainan telah membaik dari mereka.  Kadang-kadang ternyata perubahan desain, yang, menurut pendapat kami, seharusnya meningkatkan permainan, memiliki kekurangan yang tidak terduga dan kami perlu mengembalikannya atau mencoba lagi. <br><a name="habracut"></a><br>  Desain game adalah disiplin yang sangat kompleks.  Desainnya seperti ruangan gelap dengan banyak benda tajam;  sangat sulit untuk bergerak dengan aman di sepanjang jalan itu, menjauh dari jalan yang dilalui dengan baik.  Hampir selalu luka yang menyakitkan menunggu kami di sepanjang jalan, terutama jika Anda bergerak terlalu cepat.  Dan kami memiliki beberapa alat untuk menerangi ruangan gelap ini, serta beberapa teknik yang jelas dan terperinci untuk melakukan proses pencarian desain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/958/a56/132958a5643ec022cf571358e2d2eee1.jpg"></div><br><br>  Karena keberadaan ruangan gelap ini, kami melakukan "iterasi" - kami tidak tahu apa konsekuensi dari keputusan itu sampai kami memeriksanya.  Dengan kata lain, kita <b>sedang dalam pencarian</b> (Will Wright dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceramahnya di GDC 2004</a> menyebutnya "pencarian di ruang solusi"). <br><br>  Oleh karena itu, sangat sering desain menjadi hambatan kinerja, sumber kelemahan utama dan faktor risiko terbesar dalam pengembangan game.  Tim pengembangan yang tak terhitung jumlahnya ternyata diikat tangan dan kaki oleh solusi desain yang salah, tergelincir dalam proses kreatif, perubahan fungsi, kesalahan persepsi pasar target dan masalah desain lainnya yang menyebabkan masalah kualitas produk. <br><br>  Mengingat semua bahaya yang terkait dengan eksperimen desain, tidak mengherankan bahwa banyak penerbit dan pengembang besar begitu bersemangat untuk menghindari risiko, lebih memilih untuk secara ketat mematuhi asumsi genre, lisensi, dan genre yang telah diteliti dan diteliti dengan baik.  Itu sebabnya mereka tidak pergi ke risiko terkenal dari inovasi desain yang mungkin membawa hasil yang tidak diketahui.  Menjelajahi ruangan gelap terlalu berisiko. <br><br>  Kami ingin menemukan cara untuk mengubah sikap ini.  Daripada hanya <i>menghindari</i> inovasi, lebih baik mencari cara untuk meningkatkan keterampilan desain kami, memperluas kemampuan kami dan membuat alat yang kuat yang akan membuat inovasi desain lebih aman dan lebih efisien. <br><br><h2>  Seri artikel ini </h2><br>  Artikel ini akan menjadi yang pertama dari serangkaian posting tentang <i>solusi pemodelan</i> - seperangkat alat untuk menguraikan solusi menjadi model formal, yang kemudian dapat digunakan untuk mencari untuk menemukan hasil yang paling diinginkan. <br><br>  Pemodelan dan optimalisasi keputusan sering digunakan dalam manajemen, keuangan, perencanaan proyek dan banyak bidang lainnya untuk meningkatkan proses pengambilan keputusan dan menyelesaikan berbagai masalah dan optimisasi pengambilan keputusan.  Ini dilakukan dengan mencari di antara alternatif yang mungkin, yang lebih cepat daripada pilihan manual oleh orang-orang. <br><br>  Terlepas dari semua potensi keuntungannya, pemodelan, dan optimalisasi solusi, tampaknya ini menjadi topik yang cukup belum dijelajahi untuk para desainer di industri game.  Sebuah survei terhadap desainer profesional di forum pengembang populer menunjukkan bahwa hanya 25% responden yang setidaknya mendengar tentang pemodelan keputusan, dan hanya 8% yang menggunakannya dalam praktik.  Survei serupa yang dilakukan antara desainer melalui Facebook menunjukkan hasil yang kurang lebih sama dengan jumlah responden yang sama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/90b/b52/d5d90bb52bcf12c03ad7b8062154feeb.png"></div><br>  Ketika digunakan dengan benar, solusi pemodelan dapat secara signifikan meningkatkan banyak aspek dari proses desain: <br><br><ul><li>  Ini dapat membantu mengoptimalkan konfigurasi sistem desain tertentu atau nilai optimal dari parameter game. </li><li>  Ini dapat menjelaskan keputusan sebagai kombinasi fitur yang perlu dimasukkan dalam permainan. </li><li>  Ini membantu memodelkan keputusan yang dapat dibuat oleh seorang pemain, khususnya, untuk mengidentifikasi strategi dominan atau cara-cara di mana pemain mampu "mengalahkan sistem". </li></ul><br>  Dalam seri artikel ini saya akan berbicara tentang contoh-contoh dari ketiga kategori penggunaan. <br><br><h2>  Definisi </h2><br>  Apa itu "pemodelan keputusan"? <br><br>  Sederhananya, maka: <br><br><blockquote>  <b>Pemodelan keputusan adalah proses simulasi solusi dengan otomasi pencarian pencarian kalkulasinya berikutnya.</b> </blockquote><br>  Kami mulai dengan menanyakan beberapa jenis solusi, kemudian kami mencoba untuk memilih semua faktor yang terdiri dari solusi ini, dan kemudian menanamkannya dalam model yang secara akurat menggambarkan solusi, dan menentukan set variabel input dan satu variabel output.  Kemudian kami <i>mencari</i> solusi optimal untuk set variabel keputusan (atau variabel input) yang menciptakan output terbaik dari semua kemungkinan. <br><br>  Jika semuanya dilakukan dengan benar, maka kita dapat mencari lebih banyak solusi yang mungkin daripada yang dilakukan secara manual atau dalam imajinasi.  Meskipun kami tidak dapat menerapkan sistem ini untuk semuanya, untuk beberapa tugas kami bisa mendapatkan hasil yang lebih baik, menghitungnya lebih cepat, dan dalam beberapa kasus kami bahkan dapat memecahkan masalah yang <i>tidak dapat</i> diselesaikan dengan cara lain. <br><br>  Selama proses ini, kami juga menunjukkan sejumlah satu atau lebih <i>kondisi</i> , yang digunakan sebagai batas yang mengkonfirmasikan kebenaran model kami.  Kondisi tersebut dapat membatasi rentang nilai atau jenis variabel yang masuk, serta aspek lain dari model kami. <br><br><h2>  Mengapa membangun model? </h2><br>  Jika Anda memainkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Sid Meier's Civilisation</i></a> , maka suatu hari Anda mungkin bertanya-tanya, “Tunggu sebentar, bagaimana cara terbaik untuk memulai pengembangan kota?  Apakah saya perlu membangun monumen, dan kemudian gudang?  Atau apakah gudang diperlukan terlebih dahulu?  Atau mungkin kuil dulu, lalu gudang?  Keputusan mana yang <i>lebih baik</i> untuk dibuat?  Adakah yang bisa menjawab pertanyaan ini? " <br><br>  Anda juga dapat mengingat mekanisme pertempuran dalam strategi waktu-nyata.  Menyeimbangkan parameter beberapa unit dalam RTS adalah tugas yang terkenal karena kompleksitasnya.  Bagaimana jika kita memiliki sistem yang memungkinkan kita untuk mempercepat solusi dari masalah keseimbangan dengan menjawab pertanyaan tentang menyeimbangkan pertempuran permainan tanpa memainkan setiap solusi?  Bagaimana jika kita dapat mengajukan pertanyaan sistem?  Misalnya: "berapa banyak pendekar pedang yang Anda butuhkan untuk mengalahkan dua pemetik dan tiga pemanah?"  Atau: "Apa kombinasi termurah dari pemanah dan ketapel untuk mengalahkan menara pengawal musuh?" <br><br>  Bahkan, sistem seperti itu dapat dibuat! <br><br>  Jika kita dapat memodelkan tugas-tugas desain ini dengan cara yang benar, maka kita dapat menggunakan alat optimasi otomatis untuk mencari semua jawaban yang mungkin untuk menemukan jawaban yang paling sesuai dengan kriteria kita, <i>tanpa harus</i> memainkan permainan ribuan kali. <br><br>  Berikut adalah contoh masalah serupa - contoh yang akan kami pecahkan dalam artikel mendatang di seri ini. <br><br>  Katakanlah kita memiliki permainan yang disebut SuperTank.  Di SuperTank, kami mengendarai tank fantastis besar yang bertarung di medan perang dengan tank super lainnya.  Sebelum setiap pertempuran, kita dapat memilih kombinasi senjata tertentu untuk tank kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e8/218/b64/6e8218b645bdec66de54e22c1bcfec58.jpg"></div><br>  Kami memiliki 100 kredit yang dapat Anda pakai untuk peralatan.  Supertank pemain dapat membawa 50 ton senjata, dan juga memiliki 3 slot "kritis" untuk senjata berdaya tinggi khusus. <br><br>  Gim ini memiliki lima jenis senjata berikut, dan pemain dapat menggunakan jumlah apa pun dari setiap jenis, atau sepenuhnya mengabaikannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62e/717/050/62e717050c0d1e991663a3e9ef2dfc39.png"></div><br>  Misalkan kita memerlukan supertank untuk memiliki nilai kerusakan setinggi mungkin (kita mengasumsikan bahwa kerusakan per detik ditunjukkan, terlepas dari kecepatan senjata).  Kami juga berasumsi bahwa semua senjata memiliki jangkauan yang sama, lintasan proyektil, akurasi dan frekuensi tembakan, yaitu, mereka identik dalam segala hal kecuali nilai-nilai yang ditunjukkan dalam tabel. <br><br>  Sekarang cepat jawab berapa banyak senapan mesin, roket, laser, dll.  perlu ditempatkan di tangki super?  Kombinasi satu atau lebih jenis senjata apa yang akan memberi kita paling banyak kerusakan, sementara tidak melebihi batas berat, harga, dan slot kritis? <br><br>  Cobalah untuk menyelesaikan masalah secara manual atau menggunakan kalkulator. <br><br>  Bisakah ini dilakukan? <br><br>  Jika Anda mencoba, maka dengan cepat pastikan itu sangat sulit. <br><br>  Mungkin ada cara untuk menyelesaikannya dengan menggunakan persamaan matematika yang kompleks, tetapi kita adalah desainer, dan matematika bukanlah urusan kita. <br><br>  Pikirkan juga bagaimana jawaban akan berubah dengan parameter lain.  Akankah jawabannya berubah jika bukannya 50 ton tangki super dapat menampung 60?  Atau jika alih-alih 100 pinjaman kita memiliki 110 atau 90?  Bagaimana perubahan gigi yang optimal?  Dan jika kita memiliki 2 atau 4 slot kritis? <br><br>  Sekarang bayangkan bahwa kita memiliki sistem yang secara instan menghitung tata letak senjata dengan kerusakan terbesar untuk setiap set parameter (Bobot, Harga, Slot Kritis).  Cukup memasukkan parameter senjata dari tabel, lalu masukkan parameter supertank (50 ton, 100 kredit, 3 slot kritis) - dan <em><strong>BOOM!</strong></em>  - kami mendapat peralatan terbaik. <br><br>  Bukankah itu luar biasa? <br><br>  Kita dapat menggunakan sistem ini untuk secara instan mendapatkan jawaban untuk semua jenis pertanyaan berguna: <br><br><ul><li>  Bagaimana skema optimal akan berubah ketika parameter tangki super berubah? </li><li>  Bagaimana peralatan optimal akan berubah ketika mengubah parameter senjata? </li><li>  Apa yang dapat dilakukan kerusakan maksimum oleh supertank untuk parameter apa pun (Bobot, Harga, Slot Kritis)? </li><li>  Apakah keempat parameter senjata (Kerusakan, Berat, Harga, Slot Kritis) sesuai dan seimbang untuk setiap jenis senjata? </li><li>  Apakah kita memiliki senjata terlalu kuat yang terlalu sering digunakan?  Jika semua jenis senjata sangat berguna sehingga <i>selalu</i> benar untuk menggunakannya, maka itu akan selalu menjadi solusi optimal, sehingga tidak akan ada pilihan yang berarti.  Dalam hal ini, kita harus menghapus senjata dari permainan, atau mengubah keseimbangannya sehingga dalam kondisi tertentu itu <i>tidak</i> berguna. </li><li>  Apakah kita jarang atau tidak pernah menggunakan senjata?  Mirip dengan paragraf sebelumnya - jika beberapa jenis senjata sangat tidak berguna sehingga keputusan yang tepat adalah untuk <i>tidak</i> menggunakannya, maka tidak ada pilihan yang signifikan juga.  Dalam hal ini, ada baiknya melepaskan senjata dari permainan, atau mengubah keseimbangannya, sehingga dalam kondisi tertentu akan bijaksana untuk menggunakannya. </li></ul><br>  Semua ini adalah pertanyaan desain yang sangat penting, jawaban yang harus diketahui oleh perancang.  Mengetahui jawaban ini akan sangat berguna saat menyeimbangkan <i>gim SuperTank</i> . <br><br>  Hanya dalam beberapa paragraf, kami menggambarkan tugas yang sangat sulit bagi kami untuk dipecahkan secara manual, tetapi yang dipecahkan dengan menggunakan alat yang dibangun ke dalam Microsoft Excel. <br><br>  Dalam artikel mendatang, kami akan membangun model solusi nyata untuk contoh ini, yang akan menjawab semua pertanyaan di atas. <br><br>  Anda akan melihat bahwa model yang dapat dibuat dalam hitungan menit akan memungkinkan Anda untuk menyelesaikan tugas yang sulit ini.  Hanya dalam waktu singkat, kami akan menciptakan alat yang kuat yang memungkinkan kami untuk dengan cepat dan andal menjelajahi ruang desain. <br><br><h2>  Peta jalan </h2><br>  Dalam seri artikel ini, kami akan mengilustrasikan beberapa contoh yang lebih kompleks, dan membuat lembar bentang referensi sehingga Anda dapat menjalankan semua contoh ini sendiri, hanya menggunakan Excel yang diinstal dari alat.  Di antara contoh-contoh ini adalah sebagai berikut: <br><br><ul><li>  Contoh sederhana pertempuran untuk game strategi </li><li>  Sebuah model untuk mengoptimalkan koordinat dari beberapa teleport "lubang cacing" relatif satu sama lain dan sektor yang dihuni dalam game multiplayer ruang massal (MMO) </li><li>  Model yang menentukan tingkat pajak untuk model kota yang disederhanakan untuk menyeimbangkan kepuasan penduduk dan pendapatan pajak dalam strategi 4X seperti <i>Peradaban Sid Meier</i> </li><li>  Model untuk memilih mantra dan keterampilan untuk kelas karakter dalam gim multipemain masif </li><li>  Model optimasi untuk menentukan urutan konstruksi optimal untuk koloni planet dalam strategi 4X mirip dengan <i>Master of Orion</i> klasik </li><li>  Contoh tim yang mencoba menemukan kombinasi fitur yang tepat untuk sebuah game, dan model keputusan untuk membantu mereka memilih kompromi yang sesuai </li></ul><br>  Secara umum, seri ini akan terdiri dari contoh-contoh sederhana untuk menemukan strategi pemain yang optimal dalam subsistem spesifik permainan, dan kemudian beralih ke model keputusan yang mengoptimalkan parameter sistem permainan dan mengoptimalkan kombinasi set "fitur". <br><br>  Dalam setiap kasus ini, kami menjelaskan tugas, menunjukkan bagaimana memodelkannya di Excel dan menyelesaikannya menggunakan alat Solver bawaan (dalam versi Rusia - "Finding Solutions") dari Excel.  Dalam setiap kasus, Anda akan melihat bahwa kami dapat membuatnya lebih mudah, lebih cepat, dan lebih dapat diandalkan daripada tanpa menggunakan Solver atau alat serupa.  Juga untuk setiap contoh, saya akan menambahkan spreadsheet sehingga Anda dapat mengunduhnya dan memeriksanya sendiri, membuat ulang hasil dan bereksperimen dengan model Anda sendiri. <br><br>  Juga, jangan lupa bahwa representasi internal - apakah itu spreadsheet, program bahasa tingkat tinggi, atau yang lain - <i>tidak masalah</i> .  Yang penting bukanlah apa yang kita kerjakan - di Excel dan Solver, Java / C ++ / C #, atau dalam hal lain, tetapi fakta bahwa kita memodelkan tugas dan berusaha untuk menyelesaikannya. <br><br><h2>  Mengapa menggunakan model keputusan? </h2><br>  Beberapa pembaca mungkin skeptis sekarang.  Tampaknya membangun model keputusan banyak pekerjaan.  Mengapa semua upaya ini diperlukan jika kita dapat melakukan pengujian khusus dalam bentuk pengujian grup fokus dan pengujian beta? <br><br>  Untuk mulai dengan, saya akan mengatakan bahwa <u>solusi pemodelan tidak berlaku untuk setiap tugas</u> .  Beberapa tugas terlalu rumit atau terlalu sulit untuk dimodelkan menggunakan teknik seperti itu, di samping itu, ada banyak aspek dalam desain (misalnya, pertimbangan estetika, nilai permainan sebagai hiburan dan "sensasi" permainan) yang sulit atau bahkan tidak mungkin untuk dimodelkan secara numerik.  Dan solusi pemodelan jelas <i>tidak</i> menghilangkan kebutuhan untuk pengujian kelompok, pengujian beta, atau setiap hari memainkan proyek Anda sendiri dalam proses pengembangannya. <br><br>  Tetapi bahkan dengan semua ini dalam pikiran, pada akhir seri artikel akan menjadi jelas bagi Anda bahwa metode pemodelan dan optimalisasi solusi memberi kita seperangkat alat yang unik dan kuat.  Mereka dapat sepenuhnya atau sebagian menyelesaikan banyak masalah yang tidak dapat diselesaikan dengan cara lain, serta memberi Anda jawaban dan informasi tentang semua jenis masalah desain yang sulit didapat dengan cara lain. <br><br>  Seperti halnya alat lain, penggunanya harus memutuskan penerapannya. <br><br>  Ada banyak kasus di mana model keputusan mungkin tidak dapat diterima atau terlalu rumit.  Tetapi seperti yang akan Anda lihat dalam serangkaian artikel, mereka juga sangat berguna, dan semakin kita membuat keputusan desain yang tepat dan menghilangkan bug pada tahap awal, bahkan sebelum tahap pengujian, semakin besar kemungkinan sistem desain akan tahan lama, menarik dan tidak salah lagi. <br><br>  Pikirkan tentang alat yang tersedia untuk programmer biasa.  Pekerjaan programmer sangat rumit, tetapi disederhanakan oleh banyak alat untuk membantu menemukan bug bahkan sebelum tahap pengujian.  Mereka memiliki kompiler yang selalu mengingatkan Anda tentang kesalahan ketik yang dibuat;  mereka memiliki praktik pemrograman defensif yang mengidentifikasi cacat perangkat lunak;  mereka melakukan tinjauan kode yang membantu mengidentifikasi kelemahan dalam kode orang lain atau menunjukkan praktik pemrograman jahat;  selain itu, mereka memiliki banyak profil dan alat analisis statis untuk menyingkirkan semua jenis bug kinerja dan cacat lainnya. <br><br>  Tetapi desainer tidak memiliki alat seperti itu.  Kita dapat mengatakan bahwa pekerjaan kita juga rumit, tetapi kita tidak memiliki kompiler yang akan memberi tahu kita bahwa kita “membuat kesalahan sintaks”.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak memiliki profiler, atau alat debugging, atau alat analisis statis. Kami tidak dapat melakukan tinjauan kode karena kami tidak memiliki "kode". Kami menulis spesifikasi dan dokumen desain, dan itu saja; kita dapat bertukar dokumen dan spesifikasi fungsi di dalam tim dan berharap kolega kita akan memberi kita umpan balik yang baik, tetapi paling sering kita perlu memasukkan sistem ke dalam permainan untuk memahami apakah itu berfungsi atau tidak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini membuat desainnya sangat berisiko, panjang, dan mahal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam kasus pemrograman, orang cenderung membuat kesalahan dan ini merupakan bagian integral dari proses, jadi kami </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alat berkualitas tinggi sebanyak mungkin untuk melindungi diri dan proyek kami.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami masih sangat jauh dari memiliki alat desain penuh yang membantu desainer dalam menjelajahi ruang desain. Kita masih harus mengikuti jalur yang telah dilakukan oleh kompiler, debugger, profiler, dan alat analisis statis dalam pemrograman. Tapi kita sudah melihat fajar beberapa pemecah spesifik dan alat desain gim, termasuk tester playability dari versi Cut the Rope yang disebut Cut the Rope: Play Forever ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ); Sistem desain permainan abstrak Ludi, yang menghasilkan permainan papan Yavalath ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ); dan asisten otomatis Evolver saya sendiri untuk menyeimbangkan permainan seluler City Conquest ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi pemodelan akan membantu kita mengambil beberapa langkah lagi ke tingkat dukungan seperti itu dan akan memungkinkan kita untuk mulai melengkapi dan memperluas kecerdasan desainer kita sendiri dengan bantuan alat otomatis. </font><font style="vertical-align: inherit;">Dan jika kita memiliki pilihan: memiliki atau tidak memiliki alat, mengapa memilih "tidak memiliki"?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yang utama bukan spreadsheet, yang utama adalah model </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seri artikel ini ditulis untuk para desainer - yaitu, untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desainer, terlepas dari jenis pengalaman apa yang mereka miliki: seni, perangkat lunak, pengalaman dalam menciptakan cerita atau permainan papan. </font><font style="vertical-align: inherit;">Karenanya, kami tidak akan menyulitkan dan menjanjikan hal-hal berikut:</font></font><br><br><ul><li> <em><strong> </strong></em> .               Microsoft Excel     Solver (« »).   ,    <i></i>     Excel,      .  ,      ,     (    )      . </li></ul><br><ul><li> <em><strong> </strong></em> (,   ,  ).             ,    : , , ,      .      . </li></ul><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spreadsheet empat dimensi </font></font></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita hanya akan menggunakan dua dimensi.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda seorang desainer, seri artikel ini akan memberi Anda semua alat yang Anda butuhkan untuk membuat model solusi sendiri tanpa perlu kode atau programmer untuk menulis kode. </font><font style="vertical-align: inherit;">Jika Anda seorang programmer, seri ini akan memberi Anda instruksi yang cukup mudah untuk memrogram model solusi Anda sendiri dalam bahasa Java apa pun sehingga Anda dapat membangun model solusi Anda sendiri, baik dari awal atau berdasarkan pada templat yang sudah digunakan di Solver dan di Excel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel-artikel ini harus menjadi titik awal sehingga Anda dapat mengambil konsep yang disajikan di sini dan memilih sendiri: apakah akan menerapkannya di Excel, apakah akan memilih alat pengoptimalan lain, atau mencoba membangun solver Anda sendiri dalam bahasa tingkat tinggi. </font><font style="vertical-align: inherit;">Spreadsheet adalah fondasi yang solid untuk memulai, tetapi model keputusan seperti itu lebih cenderung menjadi batu loncatan Anda ke model yang lebih kaya dan lebih kompleks yang berintegrasi dengan arsitektur gim Anda.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penjelasan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita terlalu jauh dalam solusi pemodelan, kita perlu memberikan beberapa penjelasan. Pemodelan dan optimalisasi solusi tidak menciptakan sistem lengkap untuk desain game, dan kami tidak akan mengatakan hal seperti itu. Sangat berguna untuk melihatnya sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang membantu dalam beberapa aspek dari proses desain, dan seperti alat lainnya, alat ini memiliki banyak keterbatasan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah beberapa batasan yang perlu Anda ketahui:</font></font><br><br><ul><li> <b>   .</b>     ,        ,            .      ,     ,       .  ,     ,    ,    ,    ,    . </li></ul><br><ul><li> <b>  ().</b>     ,          .       « »,         ,            Excel.             (      / ),         (    ),      . </li></ul><br><ul><li> <b>   </b> .      ,   - ,  , «»       .             .  ,       ,           /,   . </li></ul><br><ul><li> <b>  </b> .     ,       Excel Solver,      ,   ,     ,        .            Solver       ,          .       ,    ,  « »    .  Solver ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontline</a> )        ,      ,  Solver  . </li></ul><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka tidak menjamin optimalitas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Karena kami bekerja dengan model yang kompleks, tidak mungkin 100% yakin bahwa kami telah menemukan </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Terkadang kita harus fokus pada yang terbaik kedua: kita akan menghabiskan lebih banyak waktu untuk optimasi atau mulai dari awal dan mengoptimalkan lagi sehingga kita dapat mengatakan dengan tingkat kepercayaan yang tinggi bahwa kita telah menemukan yang optimal atau sangat dekat dengan solusi optimal.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terakhir dan yang paling penting: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu memastikan bahwa model melakukan hal yang benar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tidak semua tugas cukup penting untuk memerlukan upaya seperti itu, kita perlu mengetahui prioritas kita secara tepat dan menghindari fokus yang tidak perlu pada mengoptimalkan tugas yang tidak berguna dan mengabaikan yang lain, yang lebih besar, yang bisa jauh lebih penting.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara sederhana, agar solusi pemodelan berguna, beberapa kondisi harus dipenuhi. Kita harus dapat menanamkan solusi yang dimaksud dalam model diskrit tertentu, dan menyatakan hasil solusi sebagai nilai tunggal. Dengan kata lain, kita harus bisa mengekspresikan, menggunakan model solusi, satu set input data hingga dalam satu nilai output sehingga meminimalkan atau memaksimalkan nilai output memberi kita solusi yang lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus di mana ada aspek subyektif yang tidak dapat tertanam dalam model ini, misalnya, aspek estetika atau aspek usability / playability, kita perlu memisahkannya dengan jelas dari model keputusan, atau menggunakan pemodelan keputusan sebagai pass pertama, atau hanya meninggalkan pemodelan keputusan sepenuhnya .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar kita dapat memodelkan solusi dalam spreadsheet, kita juga perlu membatasi kerumitan model. Jika game kami melakukan sesuatu yang sangat kompleks, kami mungkin tidak dapat membuat ulang kompleksitas ini di Excel. Namun, harus diingat bahwa ini hanya keterbatasan kekuatan model yang dapat dibangun di Excel, dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model keputusan itu sendiri. Di mesin gim kami sendiri, kami dapat membangun pemecah yang jauh lebih kuat, dan saya harap seri artikel ini akan menginspirasi Anda untuk melakukan hal itu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, semua keterbatasan ini tidak mungkin membuat pemodelan keputusan menjadi sia-sia. Bahkan dalam kasus ketika tugas terlalu rumit untuk optimasi lengkap dalam model solusi, model ini masih dapat membantu kita memilih banyak komponen desain yang jauh lebih dekat dengan konfigurasi yang benar, serta menemukan dan men-debug banyak tugas dasar bahkan pada tahap awal pengembangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bahkan ketika model solusi tidak dapat menemukan solusi optimal untuk masalah tersebut, baik karena tugasnya terlalu rumit, atau karena itu memerlukan pendekatan estetika dan faktor manusia subjektif lainnya, itu masih dapat membantu mempersempit batas-batas solusi, menghilangkan kebuntuan dan sebaliknya mengurangi kompleksitas masalah. .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, bahkan jika Anda memutuskan untuk tidak menggunakan pemodelan keputusan, jangan mencoba untuk mengoptimalkan spreadsheet atau membuat solver Anda sendiri, pemahaman tentang pemodelan keputusan masih akan membantu Anda berubah pikiran tentang membuat keputusan desain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seri artikel ini adalah studi. Kami akan melihat banyak contoh tugas desain game dan mengeksplorasi cara pemodelan dan optimasi yang disediakan oleh alat desain yang kuat. Anda mungkin skeptis atau memutuskan untuk tidak menggunakan optimasi sama sekali, tetapi saya harap Anda akan mengikuti penelitian kami dan mencari tahu bagaimana kami akan mengakhiri seri ini.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, kami ingin membuat desain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan benar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak pertanyaan desain bersifat subyektif, mereka tidak memiliki jawaban "benar" atau "salah". </font><font style="vertical-align: inherit;">Tapi mereka tentu, dalam beberapa kasus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan dalam kasus seperti itu, kita perlu tahu bagaimana mendapatkan jawaban yang benar, atau paling tidak memahami bagaimana menangani definisi dari jawaban yang “benar” dan mencari solusinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemodelan dan optimalisasi solusi adalah alat yang kuat yang membantu kami dalam banyak hal </font><font style="vertical-align: inherit;">Saya percaya bahwa alat seperti itu harus di alat masing-masing desainer. </font><font style="vertical-align: inherit;">Setelah beradaptasi dengan mereka, Anda akan menyadari bahwa alat-alat ini memiliki potensi besar yang belum direalisasi dalam studi yang lebih cepat dan lebih dapat diandalkan dari ruangan gelap desain game. </font><font style="vertical-align: inherit;">Dalam serangkaian artikel kami, kami akan menunjukkan berapa banyak kegunaannya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 2. Dasar-dasar optimasi dan penyebaran simulasi </font></font></h2><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spreadsheet untuk artikel ini dapat diunduh di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persiapan Model Solusi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita telah berbicara tentang model solusi, menjelaskan bagaimana mereka berguna, dan mendaftar beberapa keterbatasan mereka, kami ingin menggambarkan konsep-konsep dasar dengan contoh sederhana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sebelum kita melakukan ini, kita perlu memperkenalkan beberapa aturan mengenai struktur dan format. </font><font style="vertical-align: inherit;">Seperti halnya kode, jika Anda tidak berhati-hati, spreadsheet dapat dengan cepat berubah menjadi kekacauan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara sederhana, akan ada empat jenis sel dalam spreadsheet kami:</font></font><br><br><ul><li> <b></b> —    ,     —  ,          .        0  -     ,       .         ,     ,        .              . </li><li> <b>« »</b> —        . ,    ,   Tootsie Pop  17         0,25 ,      « ».     . </li><li> <b>«»</b> —         ,        .    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Tujuan"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atau "keluar") adalah sel yang nilainya kami berusaha untuk meminimalkan (atau memaksimalkan) ketika pengoptimal berjalan </font><font style="vertical-align: inherit;">Dalam contoh kami, selalu ada hanya satu sel target, selalu memiliki warna oranye dan garis hitam. </font><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada banyak pemecah yang lebih kuat yang mendukung bekerja dengan banyak tujuan, tetapi untuk artikel kami itu akan terlalu rumit.)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika kami menjalankan pengoptimal (alat Solver ("Solution Finder") yang dibangun di dalam Microsoft Excel), itu hanya akan melihat sel target yang kami tentukan dan kemudian mencoba untuk mengubah variabel keputusan, tetapi dapat (dalam batas yang kami tetapkan) atau meminimalkan, atau meminimalkan, atau maksimalkan nilai sel target ini (apa pun yang kami tentukan). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solver hampir tidak tahu apa-apa tentang perhitungan yang terjadi di dalam, atau tentang hubungan antara sel keputusan dan sel tujuan; </font><font style="vertical-align: inherit;">ia hanya melakukan salah satu dari beberapa algoritma yang tersedia untuknya, mencoba untuk meminimalkan atau memaksimalkan nilai sel target dengan mencari nilai-nilai yang mungkin dari sel solusi. </font><font style="vertical-align: inherit;">Algoritme seperti itu ("LP Simplex", "GRG Nonlinear", "Evolutionary") dirancang sedemikian rupa sehingga mereka jauh lebih pintar daripada menjelajahi semua opsi yang mungkin untuk solusi variabel dengan brute force, dan sangat sering menemukan jawaban untuk masalah serius dengan efisiensi luar biasa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, jika kami ingin tahu berapa kali Anda perlu menjilat untuk sampai di tengah Tootsie Pop, kami dapat menggunakan spreadsheet yang serupa:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/576/71e/0cb/57671e0cb3653cc8f3a1377acd4c472c.png"></div><br>  Kita dapat meminta Excel Solver untuk menyelesaikan masalah ini dengan memesannya untuk meminimalkan sel target "Massisa di Tootsie Pop", dan dia akan dengan cepat menggunakan eksperimen menentukan bahwa nilai sel solusi kuning memberikan hasil seperti itu ( "Berapa kali menjilat untuk sampai ke tengah Tootsie Pop") adalah 68. <br><br>  Tentu saja, melakukan ini sedikit bodoh, karena dari pernyataan masalah jelas bahwa jawabannya adalah 17 / 0,25 = 68.  Tidak masuk akal untuk menjalankan optimizer untuk memecahkan masalah yang dapat diselesaikan dengan aritmatika sederhana. <br><br>  Namun, dalam praktiknya, sebagian besar masalah yang kita hadapi tidak akan memiliki solusi matematika sederhana.  Mereka akan memiliki banyak variabel keputusan yang mengarah ke tujuan dengan cara yang tidak jelas, dan mencocokkan variabel keputusan dan output akan terlalu rumit untuk secara manual menghitung persamaan matematika (dan sekali lagi, dalam seri ini kita akan dengan cermat menghindari matematika yang rumit). <br><br>  Kami akan fokus pada deskripsi tugas, dan meninggalkan semua kerja keras untuk Solver. <br><br><h2>  Contoh 1: pajak </h2><br>  Dalam model keputusan nyata pertama kami, kami akan menunjukkan contoh penentuan tarif pajak yang optimal.  Tidak ada yang suka pajak, tetapi dalam hal ini kami tidak akan membayar, tetapi menerima pajak;  Saya harap ini akan mengurangi siksaan Anda. <br><br>  Bayangkan kita menciptakan strategi 4X mirip dengan <i>Peradaban Sid Meier</i> .  Kami sedang dalam proses menciptakan kota dengan tingkat ketidakpuasan tertentu, tergantung pada ukurannya.  Penduduk yang “tidak puas” pada dasarnya tidak cenderung bekerja sama, dan kami tidak menerima penghasilan dari mereka.  Kita juga dapat mencoba mendapatkan uang dari kota-kota dengan mengubah tarif pajak setiap kota, tetapi dengan kenaikan tarif pajak, tingkat ketidakpuasan akan tumbuh secara eksponensial, sehingga pajak yang sangat tinggi menjadi kontraproduktif. <br><br>  Misalkan kita dapat menunjukkan tarif pajak dengan kenaikan 10% dalam kisaran nilai dari 0% hingga 50%.  Berikut adalah tangkapan layar yang menunjukkan sistem serupa dari strategi 4X klasik <i>Master of Orion 2</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/9b7/745/ca79b7745a79ae16ccda4cb7a1579388.png"></div><br>  Sebagai desainer, kami ingin mengajukan pertanyaan sederhana: apa yang akan menjadi tarif pajak optimal dalam kasus umum? <br><br>  Ini harus menjadi tugas yang sederhana, karena hanya ada 6 nilai tarif pajak yang dapat diterima.  Kita cukup menguji masing-masing dari 6 nilai secara manual, menemukan nilai yang memberi kita penghasilan terbesar, dan dalam hal ini masalah tersebut dipecahkan! <br><br>  (Bahkan, Anda mungkin dapat menemukan persamaan matematika untuk menyelesaikan masalah ini, seperti dalam contoh dengan Tootsie Pop, tetapi itu akan menjadi kontraproduktif, karena kami sedang mempersiapkan model ini sehingga tumbuh menjadi yang lebih kompleks, yang tidak dapat diselesaikan dengan menggunakan persamaan Selain itu, dalam seri artikel ini kami menghindari matematika.) <br><br>  Mari kita mulai dengan menjelaskan tugas sebagai berikut: <br><br><ul><li>  Kami memiliki kota ukuran 12 (yang berarti 12 juta orang).  Orang-orang ini diwakili sebagai 12 "warga negara" yang terpisah. </li><li>  Setiap warga negara pada waktu tertentu dapat merasa puas atau tidak puas. </li><li>  Warga negara yang puas membayar dalam bentuk pajak (tarif pajak x 10) (yaitu, misalnya, tarif pajak 20% memberi kita 2 unit mata uang dalam pendapatan pajak untuk setiap warga negara yang puas). </li><li>  Warga yang tidak puas tidak membayar pajak. </li><li>  Ada 3 warga yang tidak puas di kota yang tetap tidak puas terlepas dari tarif pajak. </li><li>  Jumlah tambahan warga menjadi tidak bahagia berdasarkan rumus berikut: (Populasi) x ((tarif pajak) x (tarif pajak)) x 3,5, nilainya dibulatkan ke angka keseluruhan terdekat.  Untuk kota kami dengan ukuran 12, ini akan memberi kami 0 warga negara tambahan yang tidak puas dengan tingkat 0% dan 10%, 1 warga negara tambahan yang tidak puas pada tingkat 20%, 3 warga negara tambahan yang tidak puas pada tingkat 30%, 6 pada tingkat 40%, dan 10 pada tingkat 50%. </li></ul><br>  Sederhana bukan? <br><br>  Kami akan menjelaskan ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spreadsheet yang terlampir pada artikel</a> sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/7fe/9ec/a127fe9ec1fd1a7bbea4132988b05258.png"></div><br>  Anda mungkin memperhatikan bahwa kami menetapkan kotak keputusan kuning (Tingkat Pajak (0-5)) sebagai cara tidak langsung untuk menunjukkan tarif pajak.  Alih-alih menetapkan tarif pajak langsung di sel keputusan, sel penghitungan Tarif Pajak mengambil nomor Tingkat Pajak dari sel keputusan dan mengalikannya dengan 10%.  Ada alasan logis untuk melakukan ini secara tidak langsung, dan kami akan segera melihatnya. <br><br>  Sekarang kita dapat bereksperimen dan mengganti semua nilai yang mungkin dari tingkat pajak.  Anda cukup memasukkan masing-masing angka dari 0 hingga 5 di sel Tingkat Pajak, dan mendapatkan yang berikut ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/46b/13a/56546b13a04666043bbc79de2d34b1f7.png"></div><br>  Seperti yang Anda lihat, ada tarif pajak optimal: 30%, yang memaksimalkan pendapatan pajak, memberikan 18 unit mata uang. <br><br><h2>  Mari kita mengotomatisasi sistem! </h2><br>  Ini memang hebat, tetapi bagaimana jika kita memiliki lebih dari enam opsi?  Bagaimana jika ada ratusan kemungkinan tarif pajak atau jika kita perlu mengubah variabel keputusan lainnya?  Semuanya akan menjadi terlalu rumit untuk menguji nilai secara manual. <br><br>  Seperti yang akan kita lihat, inilah tepatnya yang digunakan Solver. <br><br>  Pertama, kami akan mengatur ulang nilai sel Tingkat Pajak ke nol.  Kemudian kita akan pergi ke tab Data Excel dan lihat di sisi kanan rekaman, di bagian Analisis, tombol Solver ("Cari solusi"). <br><br><div style="text-align:center;"><img height="125" src="https://habrastorage.org/getpro/habr/post_images/2fa/e50/0ab/2fae500ab2a070411c71756b2668099d.png"></div><br>  Jika Anda tidak melihatnya, buka Opsi Excel, pilih kategori Add-in, pastikan Add-in Excel dipilih di daftar turun bawah Kelola. ), klik Go dan pastikan Solver Add-in dicentang. <br><br>  Setelah mengklik tombol Solver, Anda akan melihat kotak dialog serupa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e61/6df/a81/e616dfa81c6835e3be29107f2586dabb.png"></div><br>  Sekarang mari kita lihat semua langkah yang terlibat dalam mengatur kotak dialog Solver. <br><br>  Di bidang "Tetapkan Tujuan" ("Optimalkan fungsi tujuan") kami menunjukkan apa yang perlu kami optimalkan.  Dalam hal ini, kami mencoba untuk mendapatkan sebanyak mungkin penerimaan pajak, jadi kami akan memilih kotak oranye untuk sasaran, yang mewakili pendapatan pajak, dan kemudian klik "Kepada: Maks" di daftar tombol radio. <br><br>  Di bagian "Dengan Mengubah Sel Variabel", kami memilih sel yang harus "Dihitung oleh Pencarian Solusi".  Kita perlu menentukan tarif pajak yang optimal, jadi pilih kotak solusi kuning (Tingkat Pajak (0-5)).  Jika semuanya berjalan dengan baik, maka sebagai hasilnya sel ini akan diberi nilai 3 sesuai dengan tarif pajak 30%, optimalitas yang telah kita tentukan dalam perhitungan manual. <br><br>  Akhirnya, kita perlu menambahkan beberapa <i>batasan</i> .  Bahkan, kendala adalah prasyarat untuk setiap sel dalam model solusi kami, dan Excel Solver hanya akan fokus pada solusi yang memenuhi batasan yang ditentukan.  Pembatasan tersebut dapat membatasi sel tertentu (biasanya sel keputusan dan sel perhitungan) ke nilai minimum dan / atau maksimum yang ditentukan, dan / atau menyebabkan Solver memprosesnya sebagai variabel integer atau biner (0 atau 1).  Kendala sangat berguna untuk membuat model yang benar, yang akan dibatasi. <br><br>  Solver membutuhkan setidaknya beberapa batasan yang memungkinkannya untuk menentukan batas sel keputusan - dengan kata lain, nilai minimum dan maksimum untuk setiap sel.  Untuk menambahkan batasan, Anda perlu mengklik tombol Add di sebelah kanan, dan kemudian kotak dialog berikut akan terbuka: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/207/b48/338/207b48338753cad17a214009fea0a950.png"></div><br>  Kami akan menambahkan dua kendala, satu sehingga sel solusi Tingkat Pajak memenuhi kondisi&gt; = 0, dan satu lagi sehingga sel solusi adalah &lt;= 5. Kemudian, dalam daftar Metode Pemecahan, pilih Evolutionary (“Evolutionary” cari solusi ") dan klik Solve (" Temukan solusi "). <br><br>  Setelah bekerja sekitar 30 detik, Solver akan memberi kita jawaban yang sama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/c07/93a/490c0793a105102112be90066c574d04.png"></div><br>  Oh, ada masalah.  Solver menerima jumlah pendapatan yang benar, tetapi tarif pajaknya tidak benar.  Pemain dapat menetapkan pajak hanya dengan kenaikan 10%, tetapi Solver jelas menetapkan tarif pajak fraksional, yang tidak dapat dilakukan oleh pemain. <br><br>  Anda dapat memecahkan masalah dengan membatasi nilai sel tarif pajak ke seluruh angka.  Itu bisa sama dengan 0, 1, 2, 3, 4 atau 5, tetapi tanpa nilai menengah. <br><br>  Untungnya, dalam Solver ini bisa sangat mudah dicapai.  Buka Pemecah Masalah, klik tombol Tambah, pilih sel solusi Tingkat Pajak, lalu pilih batasan int dalam daftar turun bawah di tengah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89a/6fa/0a5/89a6fa0a5dae27a2b93ccbda07dce45b.png"></div><br>  Sekarang jalankan Solver lagi dan dapatkan yang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/10f/338/c3310f338f48d293c17ff7c367ad9b0d.png"></div><br>  Sempurna!  Dengan sedikit usaha, kami mendapat jawaban yang benar di Solver.  Seperti yang akan segera kita lihat, dengan peningkatan skala tugas, volume pekerjaan yang dilakukan oleh alat untuk kita secara signifikan melebihi waktu yang dihabiskan untuk menyiapkannya. <br><br><h2>  Kota berkembang </h2><br>  Mari kita memperluas tugas sekarang dengan sedikit menyulitkan model kota. <br><br>  Dalam setiap strategi 4X, kota (atau planet, atau koloni, atau unit penghuni lainnya) tumbuh seiring waktu.  Kami akan berasumsi bahwa kota ini memiliki peningkatan konstan 8% per putaran, mulai dari 1.500 ribu (1,5 juta) warga, dan meningkat hingga ukuran 12 juta jiwa.  Sekarang spreadsheet kita akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ba/eee/530/6baeee530aa3ef791ab56d2a8e9228d7.png"></div><br>  Setiap baris tabel baru menggambarkan satu arah permainan. <br><br>  Kami juga mengubah perhitungan tingkat dasar ketidakpuasan.  Sekarang dihitung sebagai satu detik dari tingkat populasi dasar (dalam jutaan), dibulatkan ke bawah.  Karena ini, ketidakpuasan dasar akan 0 sampai kota tumbuh ke ukuran 4, setelah itu akan tumbuh secara linear dengan ukuran kota. <br><br>  Seperti sebelumnya, kita dapat bereksperimen dengan level pajak secara manual dengan mengubah nilai Level Pajak.  Kami akan menerima 0, 102, 190, 222, 144 dan 65 unit mata uang dalam penerimaan pajak, dengan setiap tingkat pajak dari 0% hingga 50%. <br><br>  Dan lagi kita bisa mendapatkan Solver untuk menyelesaikan masalah ini;  dia akan dengan cepat menentukan bahwa tarif pajak optimal adalah 30% seperti sebelumnya, yang memberi kita penghasilan 222 unit mata uang.  Seperti inilah tampilan dialog Solver: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a24/f1d/c14/a24f1dc144c4894e64347c9d0627bdf5.png"></div><br><br><h2>  Tarif pajak variabel </h2><br>  Tapi, tentu saja, pemain tidak akan bermain dengan cara ini.  "Kota" kami yang disimulasikan menetapkan satu tarif pajak dan tetap sama untuk setiap gerakan game.  Tetapi pemain sungguhan dapat memiliki tarif pajak kapan saja, dan dia sering perlu menyesuaikannya karena kotanya tumbuh dan keadaan berubah. <br><br>  Bukankah lebih bagus jika kita tidak hanya dapat menentukan tarif pajak tunggal yang optimal, tetapi juga menghitung nilai optimal dalam setiap langkah? <br><br>  Dia akan segera memberi tahu kami bagaimana pemain dapat menyesuaikan pajak. <br><br>  Dan ternyata ini bisa dilakukan!  Setelah menyiapkan model solusi dengan cara yang benar, kami dapat mengimplementasikannya dengan sangat sederhana. <br><br>  Perbedaan terbesar adalah bahwa kita perlu menghapus sel keputusan Tingkat Pajak (0-5) dan menggantinya dengan seluruh kolom sel tingkat pajak, seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77f/7f3/a68/77f7f3a682c0d6c69585f3f16160304e.png"></div><br>  Sekarang, alih-alih memaksa Solver untuk mengoptimalkan sel tunggal, kami memerintahkannya untuk mengoptimalkan seluruh kolom Tingkat Pajak.  Seperti inilah kotak dialog Solver akan terlihat - Anda dapat melihat bahwa hampir sama dengan sebelumnya, hanya alih-alih satu sel variabel dan batasan sekarang mewakili seluruh rentang sel di kolom Tingkat Pajak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/343/1f3/8a53431f3779139993292745b0e37c0d.png"></div><br>  Solver benar-benar membuktikan bahwa perubahan dalam tarif pajak mengubah hasilnya - pendapatan kumulatif sekarang mencapai 232 unit mata uang.  Dibandingkan dengan tarif pajak yang sama, pertumbuhan hanya 5% (222 terhadap 232 unit), tetapi masih signifikan karena kita tahu bahwa beberapa pemain akan dapat mencapainya. <br><br>  Melihat lebih dekat pada solusi yang diterima Solver, Anda dapat melihat bahwa itu dimulai dengan tarif pajak 50%, karena kota ukuran 1 tidak mengandung cukup banyak orang untuk menimbulkan ketidakpuasan.  Dalam proses pertumbuhan kota, alat mengubah tarif pajak di setiap belokan dalam kisaran dari 20% menjadi 30%, tergantung mana yang akan menghasilkan lebih banyak pendapatan. <br><br>  Spreadsheet untuk contoh ini dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ;  di dalamnya, tiga tahap dari contoh ini dibagi menjadi beberapa lembar spreadsheet yang terpisah (pajak yang sama untuk kota dengan populasi permanen, pajak yang sama untuk kota yang tumbuh, dan tarif pajak variabel untuk kota yang tumbuh). <br><br><h2>  Kesimpulan </h2><br>  Solusi yang kami temukan menunjukkan sesuatu yang menarik: sifat diskrit dari simulator permainan kami, yang mewakili pengelompokan jutaan orang secara sewenang-wenang sebagai "warga negara" diskrit yang dapat memiliki satu atau dua tingkat kepuasan tersendiri, memperkenalkan fitur karakteristik ke dalam model.  Meskipun permainan itu sendiri pada tingkat tertentu akan memerlukan diskritisasi semacam itu demi aksesibilitas dan kemampuan bermain, pemain yang cerdas dan licik akan dapat mengeksploitasi fragmentasi buatan ini untuk mendapatkan keunggulan dibandingkan pemain yang tidak ingin repot dengan tingkat pajak di setiap belokan. <br><br>  Situasi ini mengarah pada pertanyaan yang menarik: apakah ini yang kita inginkan?  Apakah mekanisme para pemain membuatnya perlu bagi mereka untuk terlibat dalam manajemen mikro tingkat pajak di setiap belokan?  Dan apakah kita ingin memungkinkan gamer yang berorientasi daya mengalahkan sistem dengan cara ini;  Apakah trik semacam itu cocok dengan keuntungan mereka sebesar 5%? <br><br>  Saya tidak bisa menjawab pertanyaan-pertanyaan ini.  Pada akhirnya, <i>Anda</i> adalah seorang desainer yang menetapkan tujuan desain, jadi terserah Anda untuk memutuskan apakah tingkat operasi sistem ini memenuhi tujuan yang Anda tetapkan untuk game. <br><br>  Tentu saja, model ini hanya bingkai telanjang.  Dalam strategi 4X yang nyata, pemain dapat membuat segala macam keputusan tentang cara mengembangkan kota, membangun gedung, dan membuat perubahan lain yang memengaruhi pertumbuhan kota, kepuasan, pendapatan pajak, dan produktivitas. <br><br>  Dalam artikel yang akan datang dalam seri ini, kita akan membangun model yang mirip, tetapi jauh lebih kompleks dari seluruh koloni planet dalam permainan yang mengingatkan pada <i>Master of Orion 2</i> .  Contoh ini akan jauh lebih canggih, karena kita akan dapat membuat keputusan di setiap belokan yang selanjutnya akan mempengaruhi semua parameter ini, seperti pertumbuhan dan produktivitas, yaitu setiap keputusan akan memiliki konsekuensi yang mempengaruhi keputusan selanjutnya.  Namun, kami masih yakin bahwa pengoptimal evolusi alat Solver mampu mengatasi tugas ini. <br><br>  Pada artikel selanjutnya, kami akan memenuhi janji kami dan mengoptimalkan pembelian senjata untuk SuperTank dalam contoh dari artikel pengantar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429258/">https://habr.com/ru/post/id429258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429248/index.html">Kiat Polyglot: cara mempelajari bahasa apa pun tanpa air mata dan kutukan</a></li>
<li><a href="../id429250/index.html">Seratus Resep Pembukuan Digital</a></li>
<li><a href="../id429252/index.html">Analisis statis aplikasi seluler</a></li>
<li><a href="../id429254/index.html">Pada Kurva Bezier dan Kecepatan Arduino, Bagian Dua</a></li>
<li><a href="../id429256/index.html">Cara menumbuhkan hutan di Actionscript3 / Flash dalam beberapa * baris kode</a></li>
<li><a href="../id429260/index.html">Cara kami untuk penyimpanan log terpusat</a></li>
<li><a href="../id429262/index.html">Selamat datang di Pertemuan Musim Gugur DIYorDIE 17 November</a></li>
<li><a href="../id429264/index.html">Waktu UPS Li-ion: bahaya kebakaran atau langkah aman ke masa depan?</a></li>
<li><a href="../id429266/index.html">Apa gaji untuk spesialis TI yang ditawarkan oleh majikan My Circle, data untuk Mei-Oktober 2018</a></li>
<li><a href="../id429268/index.html">Laba-laba raksasa dan minotaur di jalanan Toulouse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>