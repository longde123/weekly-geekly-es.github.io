<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏼 💟 ⤴️ Mengapa JavaScript diperlukan mode ketat? 🕢 📕 🙂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mode ketat adalah bagian penting dari JavaScript modern. Mode ini yang memungkinkan pengembang untuk menggunakan lebih terbatas daripada sintaksis sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa JavaScript diperlukan mode ketat?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477284/">  Mode ketat adalah bagian penting dari JavaScript modern.  Mode ini yang memungkinkan pengembang untuk menggunakan lebih terbatas daripada sintaksis standar. <br><br>  Semantik mode ketat berbeda dari mode non-ketat tradisional, yang kadang-kadang disebut "mode ceroboh".  Dalam mode ini, aturan sintaks bahasa tidak begitu ketat, dan ketika beberapa kesalahan terjadi, sistem tidak memberi tahu pengguna tentang mereka.  Yaitu, kesalahan dapat diabaikan, dan kode di mana mereka dibuat dapat dieksekusi lebih lanjut.  Ini dapat menyebabkan hasil eksekusi kode yang tidak terduga. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/477284/"><img src="https://habrastorage.org/webt/cm/tk/0u/cmtk0u9w_n1ifbiykbgvswupxcm.jpeg"></a> <br><br>  Mode ketat memperkenalkan beberapa perubahan pada semantik JavaScript.  Ini mencegah sistem dari menutup mata terhadap kesalahan dengan melemparkan pengecualian yang sesuai.  Ini menyebabkan eksekusi program terhenti. <br><br>  Mode ketat, di samping itu, membantu dalam menulis program di mana tidak ada kekurangan yang mencegah mesin JS dari mengoptimalkan kode.  Lebih lanjut, dalam mode ini dilarang menggunakan elemen sintaks yang mungkin mendapatkan makna khusus dalam versi bahasa yang akan datang. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fitur menggunakan mode ketat</font> </h2><br>  Mode ketat dapat diterapkan ke fungsi individual atau ke seluruh skrip.  Itu tidak bisa diterapkan hanya pada instruksi individual atau pada blok kode yang dilampirkan dalam kurung kurawal.  Untuk menggunakan mode ketat di tingkat keseluruhan skrip, di bagian paling awal file, sebelum perintah lain, Anda harus <code>"use strict"</code> atau <code>'use strict'</code> konstruksi <code>'use strict'</code> . <br><br>  Jika proyek memiliki beberapa skrip yang tidak menggunakan mode ketat, dan lain-lain yang menggunakan mode ini, maka mungkin saja skrip ini digabungkan. <br><br>  Ini akan mengarah pada fakta bahwa kode yang tidak dimaksudkan untuk dieksekusi dalam mode ketat akan berada dalam keadaan seperti itu ketika sistem mencoba untuk mengeksekusinya dalam mode ketat.  Kebalikannya juga dimungkinkan - kode yang ditulis untuk mode ketat akan jatuh ke mode non-ketat.  Karena itu, yang terbaik adalah tidak mencampur skrip "ketat" dan "tidak ketat". <br><br>  Seperti yang telah disebutkan, mode ketat dapat diterapkan ke fungsi individual.  Untuk melakukan ini - konstruksi <code>"use strict"</code> atau <code>'use strict'</code> harus ditempatkan di bagian atas tubuh fungsi, sebelum perintah lainnya.  Mode ketat dengan pendekatan ini berlaku untuk semua yang ditempatkan di tubuh fungsi, termasuk fungsi bersarang. <br><br>  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strictFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nestedFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{    <span class="hljs-comment"><span class="hljs-comment">//        } }</span></span></code> </pre> <br>  Dalam modul JavaScript yang muncul dalam standar ES2015, mode ketat diaktifkan secara default.  Karena itu, ketika bekerja dengan mereka, Anda tidak perlu memasukkannya secara eksplisit. <br><br><h2>  <font color="#3AC1EF">Perubahan yang diperkenalkan ke kode JS dengan mode ketat</font> </h2><br>  Mode ketat memengaruhi sintaksis kode dan cara kode berperilaku selama eksekusi program.  Kesalahan dalam kode dikonversi menjadi pengecualian.  Fakta bahwa dalam mode diam diam-diam crash dalam mode ketat menyebabkan pesan kesalahan.  Ini mirip dengan bagaimana sistem merespons kesalahan sintaks dalam mode lax.  Dalam mode ketat, bekerja dengan variabel disederhanakan, penggunaan fungsi <code>eval</code> dan objek <code>arguments</code> diatur dengan ketat, dan bekerja dengan konstruksi yang dapat diimplementasikan dalam versi bahasa yang akan datang disederhanakan. <br><br><h3>  <font color="#3AC1EF">▍ Konversi kesalahan diam menjadi pengecualian</font> </h3><br>  Kesalahan diam dikonversi dalam mode ketat ke pengecualian.  Dalam mode longgar, sistem tidak secara eksplisit merespons kesalahan tersebut.  Dalam mode ketat, keberadaan kesalahan seperti itu menyebabkan kode tidak dapat dioperasikan. <br><br>  Jadi, berkat ini, sulit untuk membuat kesalahan dengan secara tidak sengaja mendeklarasikan variabel global, karena variabel dan konstanta dalam mode ketat tidak dapat dideklarasikan tanpa menggunakan arahan <code>var</code> , <code>let</code> atau <code>const</code> .  Akibatnya, membuat variabel tanpa arahan ini akan menyebabkan program tidak dapat dioperasikan.  Misalnya, mencoba untuk mengeksekusi kode berikut akan memunculkan exception <code>ReferenceError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; badVariable = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Kode tersebut tidak dapat dijalankan dalam mode ketat, karena jika mode ketat dimatikan, itu akan membuat variabel global <code>badVariable</code> .  Mode ketat melindungi programmer dari membuat variabel global secara tidak sengaja. <br><br>  Upaya untuk mengeksekusi kode apa pun yang, dalam mode normal, tidak berfungsi, sekarang melempar pengecualian.  Kesalahan dianggap sebagai konstruksi sintaksis yang salah yang diabaikan begitu saja dalam mode longgar. <br><br>  Jadi, misalnya, dalam mode ketat, Anda tidak bisa melakukan operasi penetapan nilai pada entitas read-only seperti <code>arguments</code> , <code>NaN</code> atau <code>eval</code> . <br><br>  Dalam mode ketat, pengecualian, misalnya, akan dilemparkan dalam kasus berikut: <br><br><ul><li>  upaya untuk menetapkan nilai ke properti hanya-baca, seperti beberapa jenis properti global yang dapat ditulis ulang; </li><li>  upaya untuk menulis nilai ke properti yang hanya memiliki pengambil; </li><li>  Upaya untuk menulis sesuatu ke properti objek yang tidak dapat diperluas. </li></ul><br>  Berikut adalah contoh konstruksi sintaks yang mengarah ke pengecualian mode ketat: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); obj.foo = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj2 = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>; } }; obj2.foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fixedObj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(fixedObj); fixed.bar= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Mencoba menjalankan fragmen kode tersebut dalam mode ketat akan menghasilkan pengecualian <code>TypeError</code> .  Misalnya, <code>undefined</code> dan <code>Infinity</code> adalah entitas global yang nilainya tidak dapat ditimpa, dan properti <code>foo</code> objek <code>obj</code> tidak mendukung penulisan ulang.  Properti <code>foo</code> dari <code>obj2</code> hanya memiliki pengambil.  Objek <code>fixedObj</code> dibuat non-extensible menggunakan metode <code>Object.preventExtensions</code> . <br><br>  Upaya menghapus <code>TypeError</code> terhapuskan juga akan menghasilkan <code>TypeError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype</code> </pre> <br>  Mode ketat melarang menetapkan properti dengan nama yang sama ke objek.  Akibatnya, upaya untuk mengeksekusi kode berikut akan menghasilkan kesalahan sintaksis: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Mode ketat membutuhkan nama parameter fungsi menjadi unik.  Dalam mode non-ketat, jika, misalnya, dua parameter fungsi memiliki nama yang sama <code>one</code> , maka, ketika melewati fungsi argumen, nilai parameter akan menjadi apa yang termasuk dalam argumen yang dinyatakan terakhir. <br><br>  Dalam mode ketat, parameter fungsi dengan nama yang sama dilarang.  Akibatnya, upaya untuk mengeksekusi kode berikut akan menghasilkan kesalahan sintaksis: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multiply = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x*x*y;</code> </pre> <br>  Dalam mode ketat, Anda tidak dapat menggunakan notasi oktal angka, mendahului angka dengan nol.  Ini tidak ada dalam spesifikasi, tetapi fitur ini didukung oleh browser. <br><br>  Keadaan ini membingungkan pengembang, memaksa mereka untuk percaya bahwa angka 0 sebelumnya diabaikan, tanpa banyak akal.  Dalam mode ketat, mencoba menggunakan angka di awal yang 0 akan menghasilkan kesalahan sintaks. <br><br>  Mode ketat juga melarang penggunaan konstruksi yang menghambat optimasi.  Penerjemah, sebelum melakukan optimasi kode, perlu tahu bahwa variabel disimpan tepat di mana, menurut penerjemah, itu disimpan.  Dalam mode ketat, hal-hal yang mengganggu optimasi dilarang. <br><br>  Salah satu contoh larangan semacam itu menyangkut pernyataan <code>with</code> .  Jika Anda menggunakan instruksi ini, ini mencegah penerjemah JS dari menemukan variabel atau properti mana yang kami maksudkan, karena ada kemungkinan bahwa entitas dengan nama yang sama ada di luar dan di dalam blok pernyataan <code>with</code> . <br><br>  Misalkan ada kode seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  Penerjemah tidak akan dapat mengetahui apakah variabel <code>x</code> terletak di dalam blok <code>with</code> mengacu pada variabel eksternal <code>x</code> , atau ke properti <code>obj.x</code> dari objek <code>obj</code> . <br><br>  Akibatnya, tidak jelas persis di mana nilai <code>x</code> akan berada di memori.  Untuk menghilangkan ambiguitas seperti itu, dalam mode ketat penggunaan pernyataan <code>with</code> dilarang.  Mari kita lihat apa yang terjadi jika Anda mencoba menjalankan kode berikut dalam mode ketat: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  Hasil dari upaya ini akan menjadi kesalahan sintaksis. <br><br>  Bahkan dalam mode ketat, dilarang untuk mendeklarasikan variabel dalam kode yang diteruskan ke metode <code>eval</code> . <br><br>  Misalnya, dalam mode normal, perintah form <code>eval('let x')</code> akan menghasilkan deklarasi variabel <code>x</code> .  Hal ini memungkinkan pemrogram untuk menyembunyikan deklarasi variabel dalam string, yang dapat menyebabkan menimpa definisi variabel yang sama di luar <code>eval</code> . <br><br>  Untuk mencegah hal ini, dalam mode ketat dilarang untuk mendeklarasikan variabel dalam kode yang diteruskan sebagai string ke metode <code>eval</code> . <br><br>  Mode ketat juga melarang penghapusan variabel reguler.  Akibatnya, mencoba mengeksekusi kode berikut akan menghasilkan kesalahan sintaksis: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x;</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Melarang konstruksi sintaks yang salah</font> </h3><br>  Dalam mode ketat, penggunaan yang salah dari <code>arguments</code> dan <code>arguments</code> dilarang.  Ini adalah larangan semua jenis manipulasi dengan mereka.  Sebagai contoh, ini adalah sesuatu seperti memberikan nilai baru kepada mereka, menggunakan nama mereka sebagai nama variabel, fungsi, parameter fungsi. <br><br>  Berikut adalah contoh penyalahgunaan <code>eval</code> dan <code>arguments</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>++; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>--; ++<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { set p(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eval</span></span></span><span class="hljs-function">) </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'arguments'</span></span>, <span class="hljs-string"><span class="hljs-string">"'use strict'; return 1;"</span></span>);</code> </pre> <br>  Dalam mode ketat, Anda tidak bisa membuat alias untuk objek <code>arguments</code> dan menetapkan nilai <code>arguments</code> baru melalui alias ini. <br><br>  Dalam mode normal, jika parameter pertama dari fungsi adalah <code>a</code> , maka pengaturan nilai <code>a</code> dalam kode fungsi juga mengarah ke perubahan nilai dalam <code>arguments[0]</code> .  Dalam mode ketat, <code>arguments</code> akan selalu berisi daftar argumen yang dengannya fungsi dipanggil. <br><br>  Misalkan Anda memiliki kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  a = <span class="hljs-number"><span class="hljs-number">2</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br>  Konsol akan mendapatkan <code>[2,1]</code> .  Ini karena menulis nilai 2 ke <code>a</code> tidak menulis nilai 2 ke <code>arguments[0]</code> . <br><br><h3>  <font color="#3AC1EF">PtOptimasi kinerja</font> </h3><br>  Dalam mode ketat, properti <code>arguments.callee</code> tidak didukung.  Dalam mode normal, ia mengembalikan nama fungsi induk dari fungsi yang properti <code>callee</code> dari objek <code>arguments</code> kita periksa. <br><br>  Dukungan untuk properti ini mengganggu optimisasi, seperti fungsi inlining, karena menggunakan <code>arguments.callee</code> membutuhkan ketersediaan referensi ke fungsi yang tidak tertanam ketika mengakses properti ini.  Dalam mode ketat, menggunakan <code>arguments.callee</code> memunculkan exception <code>TypeError</code> . <br><br>  Dalam mode ketat, <code>this</code> ini tidak harus selalu menjadi objek.  Dalam keadaan normal, jika fungsi ini terikat, menggunakan <code>call</code> , <code>apply</code> atau <code>bind</code> , untuk sesuatu yang bukan objek, ke nilai tipe primitif seperti <code>undefined</code> , <code>null</code> , <code>number</code> atau <code>boolean</code> , nilai seperti itu harus menjadi objek. <br><br>  Jika konteks <code>this</code> berubah menjadi sesuatu yang bukan objek, objek global akan menggantikannya.  Misalnya, <code>window</code> .  Ini berarti bahwa jika Anda memanggil fungsi dengan mengatur <code>this</code> ke nilai yang bukan objek, bukan nilai ini, referensi ke objek global akan jatuh ke <code>this</code> . <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn() === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-number"><span class="hljs-number">2</span></span>) === <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.bind(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)() === <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Semua perintah <code>console.log</code> akan menghasilkan <code>true</code> , karena dalam mode ketat nilai <code>this</code> dalam fungsi tidak secara otomatis diganti oleh referensi ke objek global jika <code>this</code> disetel ke nilai yang bukan objek. <br><br><h3>  <font color="#3AC1EF">▍ Perubahan terkait keamanan</font> </h3><br>  Dalam mode ketat, Anda tidak dapat membuat properti fungsi <code>caller</code> dan <code>arguments</code> publik.  Faktanya adalah <code>caller</code> , misalnya, dapat memberikan akses ke fungsi yang disebut fungsi yang properti <code>caller</code> sedang kita akses. <br><br>  Objek <code>arguments</code> menyimpan argumen yang dilewatkan ke fungsi ketika dipanggil.  Misalnya, jika kita memiliki fungsi <code>fn</code> , ini berarti bahwa melalui <code>fn.caller</code> Anda dapat mengakses fungsi yang disebut fungsi, dan menggunakan <code>fn.arguments</code> Anda dapat melihat argumen yang dilewatkan ke <code>fn</code> ketika dipanggil. <br><br>  Fitur-fitur ini berpotensi menimbulkan risiko keamanan.  Akibatnya, akses ke properti ini dilarang dalam mode ketat. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secretFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  secretFunction.caller;  secretFunction.arguments; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restrictedRunner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretFunction(); } restrictedRunner();</code> </pre> <br>  Pada contoh sebelumnya, kita tidak bisa, dalam mode ketat, mengakses <code>secretFunction.caller</code> dan <code>secretFunction.arguments</code> .  Faktanya adalah bahwa properti ini dapat digunakan untuk mendapatkan setumpuk panggilan fungsi.  Jika Anda mencoba menjalankan kode ini, pengecualian <code>TypeError</code> akan <code>TypeError</code> . <br><br>  Dalam mode ketat, pengidentifikasi yang dapat digunakan dalam versi JavaScript yang akan datang tidak dapat digunakan untuk memberi nama variabel atau properti objek.  Sebagai contoh, kita berbicara tentang pengidentifikasi berikut: <code>implements</code> , <code>interface</code> , <code>let</code> , <code>package</code> , <code>private</code> , <code>protected</code> , <code>public</code> , <code>static</code> dan <code>yield</code> . <br><br>  Dalam ES2015 dan dalam versi standar selanjutnya, pengidentifikasi ini menjadi kata-kata yang dicadangkan.  Dan mereka tidak dapat digunakan untuk memberi nama variabel atau properti dalam mode ketat. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Mode ketat adalah standar yang telah ada selama bertahun-tahun.  Ia menikmati dukungan browser yang sangat luas.  Masalah dengan kode mode ketat hanya dapat terjadi di browser lama, seperti Internet Explorer. <br><br>  Browser modern seharusnya tidak mengalami kesulitan dengan mode JavaScript yang ketat.  Akibatnya, kita dapat mengatakan bahwa mode ini harus digunakan untuk mencegah kesalahan "diam" dan untuk meningkatkan keamanan aplikasi.  Kesalahan diam dikonversi menjadi pengecualian yang menghambat pelaksanaan program, dan dalam hal meningkatkan keamanan, misalnya, mekanisme mode ketat yang membatasi <code>eval</code> dan mencegah akses ke tumpukan panggilan fungsi dapat dicatat.  Selain itu, penggunaan mode ketat memfasilitasi optimalisasi kode mesin JS dan memaksa programmer untuk hati-hati menangani kata-kata yang disimpan yang mungkin digunakan dalam versi JavaScript yang akan datang. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan mode ketat saat menulis kode JS untuk proyek Anda? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477284/">https://habr.com/ru/post/id477284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477272/index.html">Pengantar pertama untuk AssemblyScript</a></li>
<li><a href="../id477274/index.html">Bagaimana Anda menyingkirkan kode CSS yang tidak digunakan? Bagian 1</a></li>
<li><a href="../id477276/index.html">Bagaimana Anda menyingkirkan kode CSS yang tidak digunakan? Bagian 2</a></li>
<li><a href="../id477278/index.html">Pengujian frontend</a></li>
<li><a href="../id477282/index.html">Membuat profil Pergi kode proyek dan menyelesaikan masalah alokasi memori</a></li>
<li><a href="../id477286/index.html">Aksioma atau Ambil: apa yang akan digunakan pada 2019?</a></li>
<li><a href="../id477288/index.html">John Lewis di 2018 Undoing Aging Conference</a></li>
<li><a href="../id477290/index.html">Acara digital di Moskow dari 25 November hingga 1 Desember</a></li>
<li><a href="../id477292/index.html">Acara digital di St. Petersburg dari 25 November hingga 1 Desember</a></li>
<li><a href="../id477294/index.html">Python untuk AI: Pertandingan yang dibuat di surga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>