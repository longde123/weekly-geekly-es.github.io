<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’‡ğŸ» ğŸ›€ğŸ¿ â€¼ï¸ Berhentilah berdebat tentang pemrograman fungsional dan OOP â™¥ï¸ ğŸ‘œ ğŸ¤‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pos berisi sejumlah olok-olok, Kementerian Kesehatan dengan meyakinkan meminta pembaca yang tidak siap untuk tidak membaca. 

 Artikel tentang topik "...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berhentilah berdebat tentang pemrograman fungsional dan OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450300/">  <i>Pos berisi sejumlah olok-olok, Kementerian Kesehatan dengan meyakinkan meminta pembaca yang tidak siap untuk tidak membaca.</i> <br><br>  Artikel tentang topik "AF lebih baik" atau "OOP lebih baik" menyerupai debat tentang apa yang terbaik untuk makan siang, garpu, atau sendok.  Secara tradisional, junes dimulai dengan sendok, tetapi seseorang yang sangat berwibawa pernah mengatakan kepada saya bahwa ia hanya makan daging dan menggunakan garpu, sehingga lahirlah mode baru - memakan garpu.  Mereka makan bubur dan sup, dan bahkan berhasil meminum smoothies.  Internet dipenuhi dengan artikel, seberapa baik kita, bahwa kita belajar makan smoothie dengan garpu dan mengatasi semua garu.  Ini lucu dan sedih, di satu sisi, ini memberikan keunggulan kompetitif bagi orang-orang berpengalaman yang menunjukkan hasil super hanya mengabaikan sensasi ini, di sisi lain, mereka harus melatih kembali kolega dan karyawan, membersihkan sampah yang disebabkan oleh angin dari kepala mereka.  Dalam artikel ini saya akan mencoba memberi tahu visi saya, yang tidak mengklaim sebagai kebenaran absolut, tetapi bekerja sangat baik dalam praktiknya <br><a name="habracut"></a><br>  Seperti kebiasaan dalam sains, kita mulai dengan definisi.  Definisi klasik OOP melibatkan mengikuti prinsip-prinsip pewarisan, enkapsulasi, dan polimorfisme.  Tetapi jika kita tidak memiliki salah satu dari komponen ini, apakah itu akan menjadi OOP?  Dan jika tidak, apa jadinya?  <s>Sementara bagian yang membosankan dari para penonton melayang-layang di atas tidak praktis dan tidak memberi kita pertanyaan,</s> <b>mari kita ingat apa yang terjadi sebelum PLO</b> .  Dan di depannya adalah pemrograman prosedural.  Dan ide utama OOP pada saat itu adalah <b>koneksi data dan fungsi untuk pemrosesan mereka</b> .  Idenya sederhana, tetapi cukup revolusioner, sulit untuk membayangkan berapa banyak, tetapi lebih lanjut tentang itu nanti. <br><br>  Pemrograman fungsional, dalam interpretasi gratis, menganggap <b>program sebagai rumus matematika</b> .  Formula diformalkan dengan baik dan dengan input yang sama mengembalikan output yang sama.  Seluruh program terdiri dari rutinitas yang mengikuti prinsip yang sama.  Bagaimana ini berbeda dari pemrograman prosedural yang sama?  FP aktif menggunakan <b>fungsi murni</b> , idealnya seluruh program harus fungsi murni.  Fungsi murni <b>tidak memiliki efek samping</b> , mereka dapat dengan mudah memoize, mudah diuji, dll ... Kita dapat mengatakan bahwa dalam fungsi murni ide utama dan keuntungan dari FP. <br><br>  Dan sekarang dua pertanyaan: <br>  - Bisakah kita menggunakan fungsi murni di OOP? <br>  - Bisakah kita mengikat fungsi ke data di FP? <br>  Jawaban keduanya adalah ya.  Metode kelas statis dapat murni, bahkan metode instance dapat dianggap bersih jika mereka tidak membuat efek samping dan kami menganggap properti instance kelas sebagai parameter.  Batas-batas definisi klasik meningkat dan beberapa mungkin tidak setuju, tetapi dalam praktiknya itu hanya berfungsi.  Dan metode tersebut diformalkan dan diuji tidak lebih buruk dari fungsi klasik murni yang ditulis sesuai dengan semua kanon.  Tentang metode pengikatan pada data sedikit lebih rumit, bahasa dan perpustakaan yang digunakan memaksakan pembatasan.  Katakanlah dalam JavaScript ini dilakukan secara elemen, tidak yakin tentang Haskell dan Erlang.  Sekarang hal yang paling menarik adalah apa yang diberikannya, dan mengapa OOP telah meningkatkan hype 20-30 tahun yang lalu.  Jika Anda menulis sebuah program kecil - Anda dapat menulis sesuka Anda, kecuali untuk kecantikan Anda, itu tidak memengaruhi apa pun.  Ketika Anda membuat program yang sangat besar, masalah kompleksitas muncul.  Bukan dari kompleksitas komputasi, kami percaya bahwa di sini kami melakukan semuanya dengan baik, tetapi kompleksitas yang dirasakan.  Katakanlah Anda memiliki 50.000 baris kode, dan semuanya bermanfaat.  Bagaimana mengatur mereka agar tidak menjadi gila (atau tidak meninggalkan pekerjaan pada 11 malam)?  Kami tidak dapat mengurangi jumlah operasi, tetapi kami dapat mengurangi jumlah koneksi di antara mereka (enkapsulasi membantu kami dalam hal ini).  Kami menyembunyikan implementasi kompleks di belakang antarmuka yang sederhana dan terus bekerja hanya dengan antarmuka.  Sebagai contoh, Internet adalah hal yang sangat rumit, tetapi kebanyakan pengembang memiliki pengetahuan yang cukup tentang protokol HTTP untuk melakukan pekerjaan mereka <s>dan menyerahkan jaringan, fisik, dan tingkat lainnya ke administrator sistem</s> .  Semakin lemah konektivitas modul kami, semakin <b>sedikit kompleksitas</b> pada tahap integrasi satu sama lain.  Semakin sedikit satu modul yang tahu tentang yang lain, semakin sedikit mereka terhubung.  Metode pengikatan ke data di dalam modul membantu kita menyingkirkan pengetahuan ini dari para konsumen modul.  Ini adalah keunggulan pragmatis utama OOP.  Atas apa?  Pendekatan di atas tanpa data dan metode yang mengikat.  FP, seperti yang kami ketahui, tidak mengatakan apa-apa tentang ini.  Anda bisa meneruskan kelas sebagai argumen ke fungsi murni, atau Anda bisa menggunakan fungsi murni sebagai metode kelas, itu tidak bertentangan satu sama lain, tetapi hanya menambahnya. <br><br>  Dalam praktiknya, di mana terutama satu pendekatan bekerja, dan di mana yang lain terutama?  Ketika saya menulis <b>backend</b> pada NodeJS, entah bagaimana ternyata dalam paradigma <b>fungsional</b> dengan sendirinya.  Mengapa  Karena permintaan ke server pada dasarnya adalah fungsi, dengan input dan output tetap.  Pendekatan fungsional jatuh pada permintaan server dengan sangat alami dan kode lebih kompak dan fleksibel.  Ketika saya membuat <b>frontend</b> untuk browser, <b>OOP</b> biasanya bekerja lebih baik, karena selain input dan output, kami juga memiliki <b>aliran acara pengguna</b> , serta acara program, seperti awal dan akhir animasi, permintaan server, dll ... Pendekatan fungsional bekerja jika hanya untuk menggambar halaman statis tanpa interaktivitas, ketika menggunakan FP di ujung depan, baik waktu interaktif atau pengembangan menderita (sesuai dengan pengukuran kami, setiap 3 kali).  Mengapa <br><br>  Setiap paradigma pemrograman didasarkan pada model realitas tertentu, dan model selalu merupakan penyederhanaan.  Dalam FP, model ini memberlakukan lebih banyak pembatasan pada dunia, sehingga lebih mudah untuk diformalkan.  Untuk alasan yang sama, ketika itu menjadi tidak relevan dengan kondisi masalah, itu mulai membutuhkan lebih banyak tongkat penyangga.  Misalnya, FI ujung depan menyelesaikan masalah input pengguna dengan membuat berbagai acara (aksi, redux hi).  Tetapi ini adalah abstraksi yang tidak relevan, yang, selain dampak kinerjanya, sangat meningkatkan waktu pengembangan.  Dengan pendekatan ini, Anda dapat membuat daftar todo, tetapi pada proyek yang sangat besar Anda harus memecahkan batu bata dengan dahi Anda, dan kemudian menulis artikel kemenangan untuk yang sama malang.  Sebagai perbandingan, ketika kami menulis terminal pertukaran (pada vanilla js, tentu saja) dengan kanvas, svg dan diperbarui beberapa kali per detik melalui websockets, dalam beberapa komponen yang sering diperbarui kami tidak menghapus divs, tetapi menggunakannya kembali, karena membuat ulang mereka relatif mahal operasi di browser (dan ini penting jika Anda memiliki <b>aplikasi yang sangat besar</b> ).  Jika Anda memprogram di ujung depan, Anda bahkan tidak akan memiliki pemikiran seperti itu, karena Anda telah mencapai kesepakatan dengan kekekalan (omong-omong, ini adalah hal yang luar biasa untuk bekerja dengan multithreading, yang <i>tidak terjadi</i> di JS), sehingga setiap tindakan melewati setiap peredam dan sampah lainnya.  Di sisi lain, di backend sering ternyata tanpa kelas sama sekali, karena di sana, Anda hanya dapat menghindari biaya pembuatannya, karena kondisi tugas sangat relevan dengan model FP.  Tetapi, untuk sebagian besar, pengembang Java dan PHP tidak terburu-buru untuk mempelajari FP, vendor front-end berada di garis depan, yang benar-benar membutuhkannya.  Sebagai latihan untuk pikiran - tentu saja menarik, hanya program yang diperoleh ... tetapi, dan orang lain menggunakannya.  Terlepas dari kenyataan bahwa frontend adalah bagian IT yang relatif muda, dan tugas-tugasnya yang belum terpecahkan di sana selama beberapa generasi.  Apa, tampaknya, bukan latihan untuk pikiran? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450300/">https://habr.com/ru/post/id450300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450288/index.html">UML & Arsitek Perusahaan: merancang proses target untuk membuat sistem otomatis</a></li>
<li><a href="../id450290/index.html">Baik, buruk, jahat - pengujian dalam proyek pemula</a></li>
<li><a href="../id450292/index.html">Apa yang Baru di Node 12</a></li>
<li><a href="../id450294/index.html">Racun paling menakutkan</a></li>
<li><a href="../id450298/index.html">Quantum Future (lanjutan)</a></li>
<li><a href="../id450302/index.html">Teknologi Radio Amatir: pembuatan papan sirkuit prototipe di sebuah pabrik Cina</a></li>
<li><a href="../id450304/index.html">Carapuzik mengendarai seekor semut: 100 juta tahun myrmecophilia</a></li>
<li><a href="../id450308/index.html">Pelacakan Ray GPU dalam Persatuan - Bagian 3</a></li>
<li><a href="../id450310/index.html">Cara kerja Philips VideoWRITER. Gambar pertama dari besi, lalu sedikit kebosanan</a></li>
<li><a href="../id450312/index.html">Docker Compose Starter Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>