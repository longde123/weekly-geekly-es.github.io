<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦉 😮 🏂 Concatenación de cadenas de bricolaje más rápida en Go 🌵 🏢 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy aceleraremos la unión de líneas cortas en Go en un 30%. Y para esto no necesitaremos modificar el propio Go, todo esto se implementará como una bi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Concatenación de cadenas de bricolaje más rápida en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417479/"><p><img src="https://habrastorage.org/webt/36/bi/u0/36biu0kvugh_maxmmyhmuvqlrs8.png"></p><br><p>  Hoy aceleraremos la unión de líneas cortas en Go en un 30%.  Y para esto no necesitaremos modificar el propio Go, todo esto se implementará como una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de terceros</a> . </p><br><p>  Debajo del corte que estás esperando: </p><br><ul><li> Comparando <code>+</code> , <code>strings.Builder</code> . <code>strings.Builder</code> y funciones de concatenación nativas </li><li>  Ir a detalles de la fila interna </li><li>  Bastante un poco de ensamblador </li></ul><br><p>  Este artículo también puede considerarse una excusa para discutir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL123256: runtime, cmd / compile: specialize concatstring2</a> .  Las ideas para mejorar esta lista de cambios son bienvenidas. </p><a name="habracut"></a><br><h1 id="srazu-rezultaty">  Resultados inmediatos </h1><br><p>  La comparación se realizó con la versión <code>go tip</code> (master) del compilador.  Puede obtener resultados similares en versiones alrededor de Go 1.5.  El último cambio significativo en la función <code>concatstrings</code> fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL3120: cmd / gc: asignar buffers para cadenas no escapadas en la pila</a> . </p><br><pre> <code class="hljs powershell">BenchmarkConcat2Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">83.8</span></span> ns/op BenchmarkConcat2Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">70.9</span></span> ns/op BenchmarkConcat2<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">62.1</span></span> ns/op BenchmarkConcat3Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">104</span></span> ns/op BenchmarkConcat3Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">89.9</span></span> ns/op BenchmarkConcat3<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">82.1</span></span> ns/op</code> </pre> <br><p>  <code>ConcatOperator</code> utiliza <code>+</code> . <br>  <code>ConcatBuilder</code> utiliza <code>strings.Builder</code> con la preasignación correcta. <br>  <code>Concat</code> usa la función que implementamos como parte de esta historia. </p><br><p>  Comparación a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">benchstat</a> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">62.7</span></span>ns ± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">-25.49</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) Concat3<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">103</span></span>ns ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">83</span></span>ns ± <span class="hljs-number"><span class="hljs-number">4</span></span>% <span class="hljs-number"><span class="hljs-number">-19.83</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  La implementación del ensamblador en <code>GOARCH=AMD64</code> poco más rápida y tiene una optimización adicional, que está presente en el operador incorporado <code>+</code> , pero más sobre eso a continuación: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">57.1</span></span>ns ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">-32.20</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  Tomaremos la función de ensamblador como 100% de rendimiento (en relación con el resto de las implementaciones consideradas). </p><br><blockquote>  Los resultados para líneas más largas se pueden ver en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">README.md</a> .  Cuanto más larga es la cadena, menos pronunciada es la diferencia entre implementaciones. </blockquote><br><h1 id="naivnaya-konkatenaciya">  Concatenación ingenua </h1><br><p>  La solución más fácil es usar el operador <code>+</code> . </p><br><p>  La semántica de esta declaración es la siguiente: tome dos líneas y devuelva una cadena de resultado que contenga la concatenación de ambas líneas.  No hay garantía de que se devuelva una nueva línea.  Por ejemplo, si hay una concatenación de una cadena vacía y cualquier otra, el tiempo de ejecución puede devolver un argumento no vacío, evitando la necesidad de asignar nueva memoria y copiar datos allí. </p><br><p>  Pero, como se puede ver en los resultados al comienzo del artículo, esta es la forma más lenta. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y }</code> </pre> <br><blockquote>  Calificación de desempeño: <strong>67.8%</strong> . </blockquote><br><h1 id="stringsbuilder">  Strings.Builder </h1><br><p>  No hace mucho tiempo, se agregó un nuevo tipo a Go - <a href="">strings.Builder</a> .  Este es un análogo de <code>bytes.Buffer</code> . <code>bytes.Buffer</code> , pero cuando se llama al método <code>String()</code> , la memoria no se reasigna y los datos no se copian. </p><br><p>  A diferencia de <code>bytes.Buffer</code> , el generador no tiene optimización de un <a href="">búfer pequeño</a> y, por lo tanto, memoria previamente asignada para una cadena.  Si no utiliza el método <code>Grow</code> , el rendimiento será peor que con <code>bytes.Buffer</code> .  Varias regresiones en Go 1.11 son causadas por esta característica particular (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL113235</a> ). </p><br><p>  En nuestro código, por la pureza del experimento, evitaremos este error. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2builder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder strings.Builder builder.Grow(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y)) <span class="hljs-comment"><span class="hljs-comment">//      builder.WriteString(x) builder.WriteString(y) return builder.String() }</span></span></code> </pre> <br><blockquote>  Calificación de rendimiento: <strong>80.5%</strong> (+12.7). </blockquote><br><h1 id="kodogeneraciya-dlya-konkatenacii">  Generación de código para concatenación </h1><br><p>  Si observamos qué código genera el compilador para el operador <code>+</code> , veremos llamadas a las funciones <code>concatstring2</code> , <code>concatstring3</code> , etc. (hasta <code>concatstring5</code> inclusive). </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } <span class="hljs-comment"><span class="hljs-comment">// =&gt; CALL runtime.concatstring2(SB) func concat3codegen(x, y, z) string { return x + y + z } // =&gt; CALL runtime.concatstring3(SB)</span></span></code> </pre> <br><p>  <a href="">Echa un</a> vistazo a <a href="">runtime / string.go</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [2]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [3]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) }</code> </pre> <br><p>  Por lo tanto, queda por aprender la función <code>concatstrings</code> . <br>  Una lista completa está disponible debajo del spoiler, pero aquí hay una descripción de alto nivel: </p><br><ol><li>  El parámetro <code>buf</code> puede ser <code>nil</code> .  El compilador asigna este búfer si la línea no "escapa" de su definición.  Si la cadena dura más que el marco, entonces este búfer siempre será <code>nil</code> (como suele suceder).  Sin embargo, si este búfer está disponible, será posible evitar la asignación en caso de que el resultado se rompa en él (su tamaño es de 32 bytes). </li><li>  Si todas las líneas, excepto una, están vacías, la función devolverá esta línea.  Pero al mismo tiempo, las líneas seleccionadas en la pila y dejando su marco omiten esta optimización para que la persona que llama no reciba memoria ya liberada. </li><li>  Además, todas las líneas se copian en la nueva memoria. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Listado completo de la función concatstrings</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// concatstrings implements a Go string concatenation x+y+z+... // The operands are passed in the slice a. // If buf != nil, the compiler has determined that the result does not // escape the calling function, so the string data can be stored in buf // if small enough. func concatstrings(buf *tmpBuf, a []string) string { idx := 0 l := 0 count := 0 for i, x := range a { n := len(x) if n == 0 { continue } if l+n &lt; l { throw("string concatenation too long") } l += n count++ idx = i } if count == 0 { return "" } // If there is just one string and either it is not on the stack // or our result does not escape the calling frame (buf != nil), // then we can return that string directly. if count == 1 &amp;&amp; (buf != nil || !stringDataOnStack(a[idx])) { return a[idx] } s, b := rawstringtmp(buf, l) for _, x := range a { copy(b, x) b = b[len(x):] } return s }</span></span></code> </pre> </div></div><br><p>  Aquí vemos varios lugares a la vez que se pueden optimizar para un caso particular: </p><br><ul><li>  <code>buf</code> estar vacío.  Cuando el compilador no pudo probar que la cadena es segura para colocar en la pila, pasar un parámetro adicional y verificar que sea <code>nil</code> dentro de la función solo genera una sobrecarga. </li><li>  Para el caso especial con <code>len(a) == 2</code> no necesitamos un ciclo y los cálculos pueden simplificarse.  Y esta es la forma más común de concatenación. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Estadísticas de concatenación</b> <div class="spoiler_text"><p>  Al ejecutar <code>./make.bash</code> ( <code>./make.bash</code> compilador Go y stdlib) vemos 445 concatenaciones con dos operandos: </p><br><ul><li>  398 resultados se están escapando.  En este caso, nuestra especialización tiene sentido. </li><li>  47 resultados no salen de su marco. </li></ul><br><p>  El <strong>89%</strong> total <strong>de las</strong> concatenaciones de dos argumentos obtienen la optimización del sudor. </p><br><p>  Para la utilidad <code>go</code> , tenemos: </p><br><ul><li>  501 llamadas concatstring2 </li><li>  194 llamadas concatstring3 </li><li>  55 llamadas concatstring4 </li></ul></div></div><br><h1 id="versiya-dlya-vseh-arhitektur">  Versión para todas las arquitecturas. </h1><br><p>  Para implementar la especialización, necesitamos saber cómo se representan las líneas en Go.  La compatibilidad binaria es importante para nosotros, aunque no es <code>unsafe.Pointer</code> se puede reemplazar con <code>*byte</code> sin ningún sacrificio. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stringStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { str *<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  La segunda conclusión importante que podemos extraer del tiempo de ejecución: las líneas comienzan su vida mutable.  Se asigna un trozo de memoria al que hace referencia el <code>[]byte</code> , en el que se escribe el contenido de la nueva línea, y solo después de que <code>[]byte</code> descarta ese <code>[]byte</code> , y la memoria a la que hace referencia se almacena en <code>stringStruct</code> . </p><br><p>  Para aquellos que desean más detalles, se sugiere estudiar las funciones de <code>rawstringtmp</code> y <code>rawstring</code> . </p><br><div class="spoiler">  <b class="spoiler_title">runtime.rawstring</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(&amp;s).str = p stringStructOf(&amp;s).len = size *(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, size} return }</span></span></code> </pre> </div></div><br><p>  Podemos subir más o menos lo mismo, usando el lado oscuro del paquete <code>unsafe</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { length := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> } b := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, length) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b, x) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x):], y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goString(&amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>], length) }</code> </pre> <br><p>  Destacamos <code>[]byte</code> , que usamos para formar el contenido de una nueva línea.  Entonces solo podemos finalizar la línea llevándola a la representación de tiempo de ejecución esperada.  La función <code>goString</code> es responsable de esto: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { s := stringStruct{str: ptr, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: length} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(*<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(unsafe.Pointer(&amp;s)) }</code> </pre> <br><blockquote>  Calificación de desempeño: <strong>91.9%</strong> (+10.9). </blockquote><br><h1 id="versiya-dlya-amd64">  Versión AMD64 </h1><br><p>  Desafortunadamente, la versión anterior de la función no tiene optimización para la concatenación con una cadena vacía, y también realizamos una serie de cálculos innecesarios debido a la incapacidad de asignar memoria directamente, tenemos que trabajar con el segmento de bytes. </p><br><p>  Una de las características interesantes del ensamblador Go es que le permite llamar, por ejemplo, funciones de tiempo de ejecución no exportables.  Podemos llamar a <code>runtime·mallocgc</code> desde el código de ensamblaje incluso si no es parte del paquete de <code>runtime</code> de <code>runtime</code> .  Utilizaremos esta propiedad. </p><br><p>  También podemos verificar la propiedad de las líneas de memoria de la pila, lo que hace que sea seguro optimizar el retorno de uno de los argumentos como resultado. </p><br><p>  Supongamos que se llama a una función con argumentos <code>concat2("", "123")</code> .  <code>x</code> es una cadena vacía, y si <code>y</code> no <code>y</code> asignado en la pila, podemos devolverlo como resultado de la concatenación. </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/; ,  x  y   stringStruct. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; CX - y.str. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; SI - y.len. maybe_return_y: /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;      . MOVQ (TLS), AX /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; *g CMPQ CX, (AX) JL return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &lt; g.stack.lo CMPQ CX, 8(AX) JGE return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &gt;= g.stack.hi JMP concatenate /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; y  ,    return_y: MOVQ CX, ret+32(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.len MOVQ SI, ret+40(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.str RET</span></span></code> </pre> <br><p>  <code>MOVQ (TLS), AX</code> moverá <a href="">* g</a> al registro <code>AX</code> .  La lectura en el desplazamiento cero dará el campo <code>g.stack.lo</code> , y <code>g.stack.hi</code> comienza con el octavo byte (para una plataforma de 64 bits). </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { lo <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0(AX) hi uintptr // 8(AX) } stackguard0 uintptr // 16(AX) stackguard1 uintptr // 24(AX) // ...   }</span></span></code> </pre> <br><p>  El cuerpo <code>concatenate</code> asigna memoria, la llena con ambas líneas y devuelve una nueva línea. </p><br><div class="spoiler">  <b class="spoiler_title">Listado completo con comentarios</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"textflag.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"funcdata.h"</span></span> <span class="hljs-type"><span class="hljs-type">TEXT</span></span> ·<span class="hljs-type"><span class="hljs-type">Strings</span></span>(<span class="hljs-type"><span class="hljs-type">SB</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">$4</span></span>8<span class="hljs-number"><span class="hljs-number">-48</span></span> <span class="hljs-type"><span class="hljs-type">NO_LOCAL_POINTERS</span></span> //    . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_y // x -  ,   y <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_x // y -  ,   x concatenate: <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">DI</span></span>)(<span class="hljs-type"><span class="hljs-type">SI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> // len(x) + len(y) //     . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVB</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·mallocgc(<span class="hljs-type"><span class="hljs-type">SB</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> //     <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) //  x. <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //  y   len(x). <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">AX</span></span>)(<span class="hljs-type"><span class="hljs-type">DI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">BX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">BX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //   . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">ADDQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_y: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_y //  y_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_y //  y_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // y  ,    return_y: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_x: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_x //  x_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_x //  x_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // x  ,    return_x: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span></code> </pre> <br><p>  Si está interesado en la naturaleza de <code>NO_LOCAL_POINTERS</code> en este código, puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Calling a Go function from asm ("error fatal: falta el stackmap")</a> . </p></div></div><br><blockquote>  Calificación de rendimiento: <strong>100%</strong> (+8.6). </blockquote><br><h1 id="v-kachestve-zaklyucheniya">  En conclusión </h1><br><p>  Todo el código se proporciona como un paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concat</a> . </p><br><p>  ¿Está el mundo listo para una concatenación tan rápida?  Quien sabe </p><br><p>  Al comienzo del artículo, se mencionó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL123256</a> .  Tiene varias vías de desarrollo: </p><br><ol><li>  Especialización variacional para el caso cuando el compilador no asigna un búfer temporal.  Hay menos crecimiento para cada caso, pero cubre más tipos de concatenación y prácticamente no aumenta el tamaño del código (tanto la máquina como el código Go). </li><li>  Más especializaciones para casos especiales.  Mayores ganancias, pero más código de máquina, pueden dañar el caché de instrucciones. </li><li>  Toneladas de código de máquina, para cada caso especial y memoria especializada, en la forma en que esto se hace en glibc.  Aquí surgen principalmente cuestiones de conveniencia. </li></ol><br><p>  La opción propuesta actual acelera solo el caso más común y más simple de concatenación de un par de cadenas (arity = 2). </p><br><p>  Si Go no acepta este cambio, se puede lograr una aceleración comparable mediante la implementación de operaciones de cadena en forma de una biblioteca de terceros.  Menos conveniente, hermoso y elegante, pero funciona. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417479/">https://habr.com/ru/post/es417479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486164/index.html">Coronavirus 2019-nCoV. FAQ zu Atemschutz und Desinfektion</a></li>
<li><a href="../de486174/index.html">Ich habe keinen Umsatz</a></li>
<li><a href="../es417473/index.html">Almacenamiento confiable con DRBD9 y Proxmox (Parte 1: NFS)</a></li>
<li><a href="../es417475/index.html">Codificación de borrado Glusterfs +: cuando necesita mucho, barato y confiable</a></li>
<li><a href="../es417477/index.html">Escritorio caliente</a></li>
<li><a href="../es417481/index.html">Acerca de los generadores en JavaScript ES6, y por qué es opcional estudiarlos</a></li>
<li><a href="../es417483/index.html">Comparación de marcos JS: React, Vue e Hyperapp</a></li>
<li><a href="../es417485/index.html">[marcador] Cheat sheet del administrador del sistema para herramientas de red Linux</a></li>
<li><a href="../es417487/index.html">El lugar donde comenzó la Internet rusa</a></li>
<li><a href="../es417489/index.html">Informe del Club de Roma 2018, Capítulo 3.4: “Energía descentralizada”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>