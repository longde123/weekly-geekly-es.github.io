<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø üñêüèæ üïò D√©veloppement d'un convertisseur abaisseur sur STM32F334: principe de fonctionnement, calculs, prototypage ‚ù§Ô∏è üë®üèª‚Äçüç≥ üêæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mes deux derniers articles, j'ai parl√© du module d'alimentation et de la carte de commande bas√©s sur le microcontr√¥leur STM32F334R8T6, qui sont c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement d'un convertisseur abaisseur sur STM32F334: principe de fonctionnement, calculs, prototypage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432778/">  Dans mes deux derniers articles, j'ai parl√© du module d'alimentation et de la carte de commande bas√©s sur le microcontr√¥leur STM32F334R8T6, qui sont con√ßus sp√©cifiquement pour la mise en ≈ìuvre de syst√®mes de commande pour les convertisseurs de puissance et les entra√Ænements √©lectriques.  Un exemple de convertisseur DC / AC a √©galement √©t√© consid√©r√©, qui √©tait une d√©monstration et non une construction termin√©e.  Il est maintenant temps de faire quelque chose de simple, mais d'utile et, surtout, de terminer. <br><br>  La plupart des questions concernant le projet et l'√©lectronique de puissance sont li√©es √† des topologies sp√©cifiques: quelqu'un souhaite apprendre l'algorithme de contr√¥le PFC, quelqu'un veut apprendre √† construire un demi-pont LLC, mais la topologie la plus populaire est sans aucun doute buck.  Apr√®s tout, le convertisseur buck (√©galement appel√© convertisseur buck) est le principal pour les projets les plus int√©ressants: c'est le pilote pour les lampes LED, la base du contr√¥leur MPPT pour les panneaux solaires, les chargeurs et bien plus encore. <br><br>  Le r√©seau contient de nombreuses informations sur buck, y compris des fiches techniques, mais elles sont dispers√©es et je n'ai personnellement rencontr√© aucun document d√©crivant en d√©tail le processus de cr√©ation d'un convertisseur buck avec contr√¥le num√©rique.  Il est temps de le r√©parer.  Il n'y a pratiquement pas de math√©matiques, l'explication est "sur les doigts", donc ce sera int√©ressant pour tous ceux qui sont en quelque sorte connect√©s √† l'√©lectronique. <br><br> <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Vous devez d'abord comprendre ce que nous voulons obtenir √† la fin et quelle introduction nous avons.  La topologie buck est abaiss√©e, c'est-√†-dire qu'elle vous permet de construire un convertisseur de tension abaisseur.  Comme vous le verrez plus tard, la tension √† la sortie du convertisseur abaisseur d√©pend presque lin√©airement de la tension √† l'entr√©e, vous devez donc ajouter un retour.  Aujourd'hui, je vais parler du retour de tension simple, qui est le plus intuitif et vous permettra de comprendre le principe de fonctionnement, alors que ce retour vous suffit pour r√©aliser la plupart des t√¢ches. <br><br>  √Ä la fin de l'article, nous obtiendrons une source de tension stabilis√©e de travail selon la topologie ¬´buck synchrone¬ª, fonctionnant √† une fr√©quence assez √©lev√©e avec contr√¥le num√©rique, impl√©ment√©e sur le STM32F334R8T6 en utilisant PWM haute r√©solution (HRPWM).  La plage de tension d'entr√©e est de 15 ... 60 V, la tension de sortie est de 12 V et le courant de sortie maximal est de 2 A. <br><br><h2>  Chapitre 1. Le principe de la topologie buck </h2><br>  Je vais commencer √† raconter √† partir des bases et am√©liorer progressivement notre convertisseur, comme  "Buck synchrone" est une version de la version am√©lior√©e avec une efficacit√© et une complexit√© de contr√¥le accrues.  La version de base de la topologie que vous avez probablement utilis√©e est la suivante: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  Cette topologie est utilis√©e dans les convertisseurs de tension √† faible puissance, par exemple, pour alimenter des circuits num√©riques et d'autres appareils √† faible puissance.  L'abaissement du courant continu / continu que vous utilisez dans vos appareils est probablement impl√©ment√© sur des microcircuits selon cette topologie.  Un exemple d'une telle puce est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LMR16006</a> . <br><br>  Le principe de fonctionnement de ce circuit est tr√®s simple, un signal PWM est fourni au transistor VT1, le travail lui-m√™me est divis√© en 2 √©tages, qui alternent l'un apr√®s l'autre: <br><br><ul><li>  <b>L'√©tape de stockage d'√©nergie dans le circuit LC.</b>  √Ä ce stade, le transistor VT1 est ouvert et le courant passe √† travers le transistor vers la charge, emmagasinant simultan√©ment de l'√©nergie dans l'inductance et la capacit√© de sortie: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>√âtape de d√©charge.</b>  A ce stade, le transistor VT1 se ferme puis le plaisir commence.  Acc√©l√©rateur - c'est une telle chose qui accumule de l'√©nergie si un potentiel lui est appliqu√© (VT1 ouvert) et la donne si le potentiel dispara√Æt (VT1 est ferm√©).  En m√™me temps, il cherche non seulement √† donner de l'√©nergie, mais √† enregistrer la valeur du courant et sa direction, donc, pour utiliser cette propri√©t√©, vous devez ajouter la diode VD1 pour fermer le circuit, car le courant ne circule que dans un circuit ferm√©: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  Lorsque j'ai pris connaissance de cette topologie dans la classe 6-7, je n'ai pas tout de suite compris pourquoi la diode ne conduisait pas de courant au 1er √©tage, maintenant cela semble banal, mais je pense que cela vaut la peine d'√™tre mentionn√©.  Lorsque VT1 est ouvert, le potentiel + VIN, par exemple + 20V, est appliqu√© √† la cathode de la diode VD1 et le potentiel de terre, respectivement, √† l'anode de la diode.  Pour que le courant passe √† travers la diode, il faut que ce soit exactement le contraire: le potentiel √† l'anode doit √™tre sup√©rieur au potentiel √† la cathode, donc, en buck-e, au stade du stockage d'√©nergie, la diode est ¬´ferm√©e¬ª.  Au stade de la d√©charge, la diode ferme d√©j√† le circuit, le potentiel + VIN n'agit pas sur sa cathode et ne la "verrouille" pas.  J'esp√®re que je l'ai clairement expliqu√©. <br><br>  Ensuite, vous devriez avoir une question: "Et quelle tension sera √† la sortie, si nous appliquions 20V √† l'entr√©e?".  Comme toujours, tout est simple: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  Comme le montre la formule, la tension de sortie d√©pend lin√©airement du facteur de marche du signal PWM que nous fournissons au transistor VT1.  Si quelqu'un ne conna√Æt pas ou a oubli√© le ¬´facteur d'utilisation¬ª, c'est le rapport entre le temps pendant lequel le transistor est √† l'√©tat ouvert et la dur√©e de la p√©riode.  Ce coefficient peut prendre une valeur de 0 √† 1 ou de 0 √† 100%.  De plus, nous fonctionnerons avec cette figure particuli√®re lors du contr√¥le du convertisseur, mais pour comprendre l'essence, substituons cette relation dans la formule: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  La fr√©quence de fonctionnement du convertisseur abaisseur est constante et est s√©lectionn√©e lors de la conception, elle ne change pas pendant le fonctionnement, et donc la p√©riode (T) est constante.  Il s'av√®re que la tension de sortie d√©pend directement de deux grandeurs physiques: <br><br><ul><li>  √† partir du moment o√π nous ouvrons le transistor sup√©rieur (VT1) - plus il est ouvert, plus l'√©nergie a le temps de s'accumuler dans le filtre LC et, en cons√©quence, la tension de sortie est plus √©lev√©e; </li><li>  √† partir de la tension d'entr√©e, par exemple, si nous fixons le remplissage de 50% et changeons Vin de 20 √† 40V, la tension de sortie passera √©galement de 10 √† 20V. </li></ul><br>  Je pense que l'image g√©n√©rale et le principe du travail ont commenc√© √† se dessiner en vous, fixons-le maintenant et regardons les vrais oscillogrammes et v√©rifions ce rapport dans la pratique.  J'ai assembl√© une disposition buck qui est charg√©e avec une LED de 10 W.  J'ai utilis√© 3 canaux de l'oscilloscope, qui sont inclus dans les points suivants: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Exp√©rience n ¬∞ 1 - Tension d'entr√©e (Vin) constante 20V, le rapport cyclique change</b> <br><br><ul><li>  Vin = 20V, D = 25%, Vout = D * Vin = 0,25 * 20V = 5V <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  Comme vous pouvez le voir sur les formes d'onde, la relation entre la tension de sortie et le rapport cyclique est correcte.  Bien s√ªr, c'√©tait une exp√©rience ¬´id√©alis√©e¬ª, en r√©alit√©, la tension d'entr√©e n'est pas stable et flotte dans une plage assez large.  Voyons maintenant quelle sera la d√©pendance √† la tension d'entr√©e √† un remplissage fixe. <br><br>  <b>Exp√©rience n ¬∞ 2 - La tension d'entr√©e (Vin) change, le rapport cyclique est constant et √©gal √† 50%</b> <br><br><ul><li>  Vin = 15 V, D = 50%, Vout = D * Vin = 0,5 * 15 V = 7,5 V <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30V, D = 50%, Vout = D * Vin = 0,5 * 30V = 15V <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Maintenant, nous avons vu dans la pratique que la tension de sortie d√©pend √©galement lin√©airement de la tension d'entr√©e √† un rapport cyclique fixe.  Comprenez-vous d√©j√† comment cela stabilisera la sortie?  Le principe de stabilisation est simple comme la formule elle-m√™me - Vout est 12V et constant, nous pouvons changer le rapport cyclique √† l'aide d'un microcontr√¥leur, donc si Vin augmente, la tension de sortie augmente √©galement et √† ce moment nous diminuons le facteur d'utilisation jusqu'√† ce qu'il redevienne 12V.  En cons√©quence, lorsque Vin diminue, nous commen√ßons √† augmenter le rapport cyclique jusqu'√† ce que la tension Vout redevienne 12V. <br><br>  Sur quoi d'autre voudrais-je attirer l'attention dans la partie th√©orique ... Ah, oui!  Vous vous demandez s√ªrement comment un PWM avec une amplitude de 20V apr√®s un transistor s'est finalement transform√© en une tension constante avec des ondulations rares?  En effet, si nous mettons la sonde rouge de l'oscilloscope √† la source du transistor VT1, la sonde verte apr√®s le filtre LC, nous verrons l'image suivante: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  Vous pouvez voir comment le filtre LC ¬´lubrifie¬ª la tension alternative en tension constante, mais le fait est que l'√©nergie stock√©e dans l'inductance et la capacit√© ne peut pas √™tre consomm√©e instantan√©ment, donc la tension ne peut pas changer instantan√©ment.  Nous obtenons qu'au moment o√π le PWM devant l'inductance devient 0V, la tension de sortie est fournie par l'√©nergie stock√©e dans le filtre, qui n'absorbe pas imm√©diatement et est suffisante pour maintenir la tension au moment o√π VT1 se ferme.  Tout est sur les doigts bien s√ªr, si c'est int√©ressant d'approfondir, alors comme toujours je conseille <b>B. Yu.</b>  <b>Semenova "Power Electronics: du simple au complexe"</b> , il y a tout un chapitre sur le buck (chopper). <br><br><h3>  La lutte pour l'efficacit√© </h3><br>  Comme je l'ai √©crit un peu plus t√¥t, c'√©tait la version de base de la topologie.  Son principal inconv√©nient est de fortes pertes sur la diode de verrouillage.  Quel est le courant dans les syst√®mes simples fonctionnant sur MK et CPLD?  Habituellement dans 1A, parfois 2A, s'il y a une sorte d'affichage TFT.  Dans ce cas, la perte m√™me lors de l'utilisation d'une diode Schottky sera de 0,4 V * 2 A = 0,8 watts.  En principe, il est tol√©rable de se dissiper autant sur le bo√Ætier SMA / SMB sans probl√®me, bien qu'avec une tension de 3,3 V et 2 A, une perte de 0,8 V soit toujours 12% d'efficacit√©! <br><br>  Imaginez maintenant le cas o√π le courant que nous avons est de 20 A.  Il peut s'agir d'un contr√¥leur MPPT, d'un grand syst√®me d'alimentation FPGA et bien plus encore.  Dans ce cas, la perte sera de 0,4 V * 20 A = 8 W!  Qu'est-ce que cela signifie?  Par exemple, dans le cas du MPPT, vous aurez moins d'√©nergie stock√©e dans la batterie, dans le cas de l'alimentation FPGA, ce seront 8 watts de chaleur suppl√©mentaires qui doivent √™tre dissip√©s quelque part et dans les deux cas, c'est sans aucun doute une perte d'efficacit√© globale.  Que peut-on faire?  Et rempla√ßons la diode VD1 par un autre Mosfet √† canal N et obtenons ce circuit: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Maintenant, le transistor VT2 agit comme une diode, c'est-√†-dire qu'il conduit le courant lorsque VT1 est ferm√©.  La diode, qui √©tait dans la version de base, ne n√©cessitait pas de contr√¥le, maintenant nous sommes oblig√©s de payer un canal de contr√¥le suppl√©mentaire avec un signal PWM pour am√©liorer les performances. <br><br>  Tout d'abord, calculons combien nous avons r√©duit les pertes.  La r√©sistance de canal d'un mosfet moderne est de plusieurs m√©gohms.  √Ä titre d'exemple, prenons un transistor de mon module d'alimentation, dont j'ai parl√© dans les articles pr√©c√©dents - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPP083N10N5AKSA1</a> avec une r√©sistance de canal de 8,3 mOhm.  Nous obtenons des pertes statiques √©gales √† 0,0083 * 20A * 20A = 3,32 watts.  Bien s√ªr, il y aura des pertes dynamiques, qui avec un pilote correctement con√ßu ne d√©passeront pas 20%, c'est-√†-dire que les pertes totales pour nous seront de 4 watts.  Nous obtenons que la transition d'un buck conventionnel √† un buck synchrone peut r√©duire de moiti√© la perte de la diode. <br><br>  Voyons maintenant la gestion la plus compliqu√©e.  Comme nous l'avons d√©j√† compris, la diode de verrouillage conduisait du courant lorsque VT1 √©tait ferm√©.  Il en r√©sulte que VT2 doit √™tre ferm√© lorsque VT1 est ouvert et, par cons√©quent, VT2 est ouvert lorsque VT1 est ferm√©.  Si c'est plus simple, les transistors fonctionnent alternativement: soit l'un est ouvert, soit l'autre, si les deux transistors s'ouvrent, il y aura un courant traversant, car  ils sont interconnect√©s entre VIN et GND.  Voyons ce que devrait √™tre le signal, o√π le "canal jaune" est le transistor VT1 et le "canal vert" est le transistor VT2: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  Comme vous pouvez le voir, si le ¬´1¬ª logique est d√©fini dans le canal jaune (sur VT1), alors le ¬´0¬ª logique doit √™tre d√©fini dans le canal vert (sur VT2).  Nous obtenons que VT1 pompe l'√©nergie dans le filtre LC, et VT2 ferme le circuit √† l'√©tape de d√©charge. <br><br>  Il y a un autre point que vous avez d√©j√† entendu ou lu ci-dessus - √† <b>travers le courant</b> .  Le fait est qu'un transistor r√©el (pas un id√©al) (mosfet) a une certaine capacit√© sur la grille, c'est-√†-dire qu'en r√©alit√©, il ne passe pas instantan√©ment de log.0 √† log.1, et l'√©nergie dans le transistor ne se dissout pas instantan√©ment, ce qui entra√Æne des transistors pendant une courte p√©riode au moment de la commutation, les deux peuvent √™tre ouverts.  Cela peut entra√Æner, au mieux, une augmentation des pertes, ce qui signifie un √©chauffement et, au pire, un babah, car  le courant traversant est un court-circuit commun (court-circuit).  Pour √©viter cela, un retard ou le soi-disant temps mort est introduit entre la fermeture d'un transistor et la mise en marche d'un autre.  Cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  Je pense que vous avez remarqu√© qu'il y a un petit √©cart √† la limite de commutation du signal.  Je l'ai install√© sciemment grand (environ 3%) pour que vous puissiez le voir, en r√©alit√© il est beaucoup plus petit.  En g√©n√©ral, le temps mort (ci-apr√®s dt) est r√©gl√© le plus court possible, mais en m√™me temps suffisant pour permettre la fermeture des transistors.  Elle peut √™tre calcul√©e, ou elle peut √™tre choisie empiriquement, je pense personnellement que telle ou telle option est normale, mais le Jedi barbu vous dira probablement: "Il faut y penser, mais il vaut mieux la mod√©liser!"  C'est certainement correct, mais d√©cidez par vous-m√™me - si vous n'√™tes pas trop paresseux, mod√©lisez dans LTspice en tenant compte des inductances et des capacit√©s parasites des conducteurs et des composants. <br><br>  Pour le stand dans cet article, j'ai d√©fini dt √† ~ 100 ns (en fait 104).  Mon module vous permet de l'installer beaucoup moins, car  le pilote est tr√®s s√©v√®re appliqu√©, mais √† coup s√ªr, beaucoup d'entre vous construiront votre mise en page sans mon module, ce qui signifie qu'il y aura tr√®s probablement de la morve.  Pour ne pas rester coinc√© √† cause de la morve, je laisse dt avec une marge et si vous avez un c√¢blage normal sur la carte, vous pouvez vous-m√™me le r√©duire - puis dans le chapitre sur le code, vous verrez comment, pour l'instant, nous voyons s'il y a vraiment dt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  On peut voir que dt dure 2,5 divisions et que chaque division est de 40 ns, ce qui signifie que la dur√©e est de ~ 100 ns, comme pr√©vu.  J'esp√®re que vous comprenez pourquoi le dt est n√©cessaire, combien de temps il devrait √™tre en dur√©e et comment le convertisseur fonctionne selon la topologie buck.  Si vous ne comprenez pas, alors comme d'habitude, les questions dans les commentaires, PM et mail sont accept√©es, alors que je semble r√©pondre √† tout le monde. <br><br><h2>  Chapitre 2. Le calcul des principaux composants </h2><br>  Dans cette partie de l'article, je montrerai comment calculer rapidement et facilement les principaux composants de puissance d'un convertisseur abaisseur synchrone, √† savoir: inductance, condensateurs d'entr√©e et de sortie, transistors. <br><br>  <u>Permettez-moi de vous rappeler les donn√©es d'entr√©e:</u> <br><br><ul><li>  Tension d'entr√©e: 15 ... 30V </li><li>  Tension de sortie: 12V </li><li>  Courant de sortie nominal: 2A </li><li>  Fr√©quence de commutation: 100 kHz </li></ul><br>  La tension de sortie de 12V est s√©lectionn√©e car  Je pr√©vois d'utiliser une LED 12V 20W comme charge, qui s'est av√©r√©e √™tre √† port√©e de main et est une charge tr√®s √©vidente.  Anticiper les questions des ¬´experts¬ª dans les commentaires - oui, je suis conscient que la LED a besoin d'une stabilisation de courant, mais nous faisons alors un stabilisateur de tension et la LED n'est qu'une charge. <br><br>  La tension d'entr√©e est s√©lectionn√©e √† partir du bulldozer, vous pouvez faire 15 ... 60V, donc si vous √™tes int√©ress√© par une plage diff√©rente, vous pouvez alors calculer vous-m√™me la valeur des composants.  Un courant nominal de 2A est choisi pour obtenir la puissance de sortie de 12V * 2A = 24 W, c'est-√†-dire un peu plus que ce qui est n√©cessaire pour la LED.  La LED elle-m√™me √† 12V consomme environ 1,82 ... 1,9A. <br><br>  Le param√®tre le plus int√©ressant est rest√© - la fr√©quence de fonctionnement du convertisseur.  Qu'est-ce que √ßa devrait √™tre?  Vous devrez r√©pondre ici vous-m√™me, dans mon cas c'est 100 kHz.  Le choix est bas√© sur deux points: <br><br><ul><li>  Une augmentation de la fr√©quence entra√Æne une diminution de l'inductance n√©cessaire de l'inductance, du condensateur d'entr√©e et de sortie.  Autrement dit - avec une augmentation de la fr√©quence, les dimensions de l'appareil diminuent.  Avec une fr√©quence d√©croissante, les dimensions augmentent. </li><li>  Une diminution de la fr√©quence entra√Æne une augmentation de l'efficacit√©, car  les pertes dynamiques lors de la commutation des transistors sont r√©duites.  L'augmentation de la fr√©quence augmente la composante dynamique des transistors et r√©duit en cons√©quence l'efficacit√©. </li></ul><br>  Maintenant, je ne vais pas discuter du choix de la fr√©quence, il suffit de supposer que 100 kHz.  Apr√®s avoir montr√© la m√©thodologie de calcul, nous reviendrons sur cette question, car  selon les formules, la d√©pendance des valeurs nominales des principaux composants √† la fr√©quence de fonctionnement sera plus clairement visible. <br><br>  <b>√âtape 1. Choisir des transistors</b> <br><br>  Nous nous int√©resserons principalement √† 3 param√®tres: la tension maximale ¬´drain-source¬ª, la r√©sistance de canal √† l'√©tat ouvert et la capacit√© de grille.  Le plein potentiel de la source de tension (Vin) est appliqu√© au transistor, et il y a √©galement des surtensions au moment de la commutation.  Vous avez 2 options: prendre le transistor VT1 et VT2 avec une marge de tension ou l'histoire du snubber RC sur VT2.  Dans mon cas, le module de puissance a des transistors 100V, et avec une entr√©e de 30V, c'est une √©norme marge de tension, m√™me 60V √©tait suffisant pour se passer des amortisseurs et prot√©ger le transistor contre les pannes. <br><br>  R√©sistance de canal - le plus petit est le mieux, mais il y a un MAIS.  Avec une diminution de la r√©sistance du canal, nous r√©duisons les pertes statiques (I <sup>2</sup> * R), mais la technologie est telle que la capacit√© de la grille augmente, ce qui entra√Æne une augmentation des pertes dynamiques.  Vous devez trouver un juste milieu entre la ¬´r√©sistance de canal¬ª et la ¬´capacit√© d'obturation¬ª.  Pour les tensions jusqu'√† 100V, je vous conseille de faire attention aux transistors de la s√©rie Infineon OptiMOS, regardez d√©j√† vous-m√™me les hautes tensions par recherche param√©trique ou m√™me vers les transistors IGBT.  Ces derniers sont √©galement pris en charge par mon module d'alimentation et ne n√©cessitent aucune modification du pilote. <br><br>  <b>√âtape 2. Le calcul de l'inductance de l'inductance</b> <br><br>  Il est n√©cessaire de calculer la valeur minimale de l'inductance, ce qui permettra √† notre convertisseur DC / DC de fonctionner en mode courant continu (L <sub>min</sub> ): <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  En termes de variables, je pense que tout est clair sauf - k <sub>ind</sub> .  Ce sont des courants d'ondulation admissibles dans l'inductance, ils choisissent g√©n√©ralement une valeur de 20 ... 50%, mais je r√®gle presque toujours 30%.  Plus l'ondulation du courant est petite, plus nous nous √©loignerons de la fronti√®re de saturation du noyau sur lequel l'inducteur est enroul√©, mais comme le montre la formule, une grande inductance de l'inducteur est n√©cessaire. <br><br>  Maintenant, nous calculons la valeur minimale de l'inductance, qui sera n√©cessaire pour mes donn√©es d'entr√©e, l'ondulation que je pondrai √† 30% comme je l'ai √©crit ci-dessus: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  Il faut comprendre qu'il s'agit de l'inductance minimale requise pour que le convertisseur abaisseur fonctionne en mode de courants inextricables, mais l√† encore, il y a une nuance.  Dans le processus d'augmentation du courant agissant dans l'enroulement, la perm√©abilit√© du noyau et l'inductance de l'inductance SANS courant et avec courant sont quelque peu diff√©rentes, la d√©pendance est diff√©rente pour diff√©rents mat√©riaux.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©viter la situation o√π, avec une augmentation du courant dans l'inductance, l'inductance diminue en dessous de L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et que dc / dc ne passe pas en mode de courant de coupure, il est n√©cessaire d'augmenter quelque peu l'inductance, c'est-√†-dire d'ajouter quelques tours suppl√©mentaires pendant l'enroulement. Une augmentation de l'inductance de 10 √† 15% sera suffisante pour le mat√©riau Kool Mu, et mon √©tranglement sera l√†-dessus. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtape 3. Calcul et fabrication de l'inductance</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je voudrais d√©crire cette proc√©dure dans la section ¬´prototypage¬ª, mais ensuite l'√©tape de calcul de l'inductance serait rest√©e moins claire pour vous, et j'ai probablement rat√© les images int√©ressantes, donc je vais tout d√©crire ici. Pour la fabrication de l'acc√©l√©rateur, je prendrai l'acc√©l√©rateur R26 / 14/11 (R est l'anneau et les chiffres sont des dimensions) en mat√©riau Kool Mu avec une perm√©abilit√© 60, vous pouvez t√©l√©charger la documentation pour cela et acheter ici -</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepkos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez maintenant calculer le nombre de tours et le fil √† enrouler. Commen√ßons peut-√™tre par le nombre de tours. Il y a un tel param√®tre pratique dans la documentation pour le noyau - A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est √©gal √† 75 nH / tour </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ici soigneusement - se transforme en carr√©! Pour trouver l'inductance du noyau, multipliez A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par le nombre de tours dans le carr√©. De l√†, la formule pour trouver le nombre de tours ressemble √† ceci: </font></font><br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir l'inductance minimale requise, il faut enrouler 40 tours, mais comme nous l'avons d√©j√† discut√©, il est n√©cessaire d'augmenter l√©g√®rement l'inductance, ajoutons 3 tours. On prend l'anneau et on tourne 43 tours, on obtient un tel acc√©l√©rateur:</font></font><br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour l'int√©r√™t, nous calculons quelle inductance devrait se produire: </font></font><br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et pour la fiabilit√©, nous v√©rifions l'inductance de l'inductance avec une pince √† √©piler: </font></font><br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137 ŒºH, super! Les </font><font style="vertical-align: inherit;">r√©sultats ont </font><font style="vertical-align: inherit;">converg√©, une erreur de ¬± 8% de A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il convient de mentionner que si vous n'avez pas la capacit√© de mesurer l'inductance, n'achetez pas de noyaux pour aliexpress, dans ChiD, ordinateur, ing√©nieur en √©lectronique et autres "restaurants" - il y a une chance d'obtenir le noyau √† partir d'un autre mat√©riau ou avec une mauvaise perm√©abilit√©, mais avec le marquage correct - v√©rifi√©. Sans la capacit√© de mesurer l'inductance, vous ne pourrez pas v√©rifier A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et vous pourrez vous tourmenter grandement √† la recherche de la cause du "babakh" de votre convertisseur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela soul√®ve une question raisonnable - ¬´aurons-nous suffisamment de noyau et ses dimensions? Peut-√™tre que c'√©tait plus n√©cessaire? ". Pour le mat√©riau Kool Mu, la limite d'induction magn√©tique est de 0,5 T; en pratique, il vaut mieux ne pas ramper au-del√† d'un seuil au-dessus de 0,45 T sans avoir clairement besoin. Il s'av√®re que l'enroulement enroul√© sur le noyau n'a pas √† cr√©er d'induction √† chaque point du noyau de plus de 0,45 T, nous v√©rifions donc: </font></font><br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, la valeur de l'induction magn√©tique de 0,06 T est bien inf√©rieure √† la limite de 0,5 T. Deux conclusions peuvent en √™tre tir√©es: d'une part, l'acc√©l√©rateur n'entrera pas en saturation, et d'autre part, le noyau est tr√®s gros et il est puissant de prendre un anneau beaucoup plus petit. J'ai pris la bague R26 simplement parce que j'ai toute leur boite, il n'y a pas d'autre sens secret.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste √† d√©terminer quelle section du fil prendre pour l'inductance. Tout d'abord, je vous d√©conseille fortement de prendre un fil d'un diam√®tre sup√©rieur √† 1 ... 1,2 mm √† des fr√©quences aussi √©lev√©es, car l'effet peau a d√©j√† un effet significatif et r√©duit la section efficace. Deuxi√®mement, la densit√© de courant dans le fil doit √™tre s√©lectionn√©e en fonction des conditions de refroidissement et de la puissance. √Ä faibles puissances (jusqu'√† 10-20 W), vous pouvez appliquer en toute s√©curit√© une densit√© de courant de 8..10 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√™me sans flux d'air. √Ä des puissances allant jusqu'√† plusieurs kilowatts, il est pr√©f√©rable de placer la densit√© de courant dans la plage de 5 ... 6 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et √† des puissances √† partir de 10 kW, il sera raisonnable de r√©duire la densit√© de courant √† 3 ... 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au bout de mes doigts, il y avait un fil verni d'un diam√®tre de 0,8 mm. Sa section transversale, respectivement, est de ~ 0,5 mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A un courant de 2A, on obtient une densit√© de courant dans l'enroulement d'environ 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Je pourrais utiliser un fil avec la moiti√© de la section, mais mon noyau est assez grand, donc un fil de section plus grande s'adapte sans aucun probl√®me. Lorsque vous optimisez votre appareil, vous devrez d'abord compter, puis acheter le fil de la section souhait√©e, puis vous pourrez obtenir les dimensions optimales de l'inductance. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtape 4. Calcul du condensateur de sortie</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, comme dans le cas de l'inductance, nous consid√©rerons la valeur minimale de la capacit√© qui doit √™tre install√©e dans le filtre LC √† la sortie du convertisseur abaisseur. En cons√©quence, si vous en installez plus, ce sera mieux et voyez pourquoi. Calculons la capacit√©: </font></font><br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien s√ªr, la capacit√© doit √©galement √™tre mise avec une certaine marge, surtout si vous n'utilisez que de la c√©ramique √† la sortie, car sa capacit√© est fortement r√©duite en fonction de la tension qui lui est appliqu√©e. Il convient √©galement de pr√™ter attention √† la d√©pendance aux pulsations - l' </font><sub><font style="vertical-align: inherit;">impulsion</font></sub><font style="vertical-align: inherit;"> V variable</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit de la valeur maximale de l'ondulation √† la sortie, c'est-√†-dire, id√©alement, avec une capacit√© de 147,8 ŒºF, l'amplitude de l'ondulation sera de 0,2 V, c'est-√†-dire que la tension de sortie flottera dans la plage 11,9 ... 12,1 V. Vous voulez r√©duire l'ondulation? R√©duisez-les ensuite dans la formule et la valeur de la capacit√© r√©sultante augmentera en cons√©quence, bien s√ªr, vous n'obtiendrez pas une alimentation √©lectrique de laboratoire simplement en augmentant la capacit√© de sortie. Il est √©galement n√©cessaire de prendre en compte la n√©cessit√© d'un faible ESR, pour cela, ils mettent g√©n√©ralement 1-2 √©lectrolytes en parall√®le et accrochent plusieurs c√©ramiques en parall√®le avec un di√©lectrique X7R, de pr√©f√©rence. Si le budget le permet, il est possible de remplacer le condensateur √©lectrolytique par du tantale polym√®re (comme dans le GPU), et donc la c√©ramique n'est pas n√©cessaire, ils ont un minuscule ESR. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rations de fr√©quence</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, comme je l'ai dit, nous reviendrons sur la question du choix de la fr√©quence de fonctionnement du convertisseur. </font><font style="vertical-align: inherit;">Permettez-moi de diviser les conclusions en quelques r√©flexions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme vous le voyez dans la formule, la fr√©quence appara√Æt, plus la fr√©quence de fonctionnement est √©lev√©e, plus l'inductance de l'inductance sera faible et moins de tours devront √™tre enroul√©s - nous √©conomisons sur le cuivre et simplifions la fabrication des produits de bobinage </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'inductance et le nombre de tours sont pr√©sents dans la formule de calcul de l'induction magn√©tique, bien que, comme vous vous en souvenez, l'inductance a une d√©pendance quadratique sur les tours, ce qui signifie que lorsque le nombre de tours est r√©duit de 2 fois, l'inductance diminue de 4 fois. </font><font style="vertical-align: inherit;">Il en r√©sulte que, avec l'augmentation de la fr√©quence, l'inductance et la valeur de l'induction magn√©tique diminuent, ce qui signifie qu'un noyau plus petit peut √™tre utilis√©, c'est-√†-dire que nous r√©duisons les dimensions</font></font></li><li>      ,     ‚Äî     ,     ,    .  ! </li><li>   ‚Ä¶  ,              .          buck-  mosfet-  200   .    ( )   ?     GaN     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense qu'√† partir de ces th√®ses, il est devenu clair pour vous ce que la fr√©quence de commutation affecte, maintenant vous devez apprendre √† trouver vous-m√™me le "moyen d'or" entre les pertes sur les transistors et la taille de l'appareil. </font><font style="vertical-align: inherit;">Dans l'un des articles suivants je vais vous apprendre √† optimiser la fr√©quence de fonctionnement pour une efficacit√© maximale, l'essentiel est de ne pas oublier que j'allais le faire.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chapitre 3. Assemblage d'une disposition de convertisseur abaisseur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, la partie la plus fastidieuse mais la plus importante est termin√©e, maintenant le mat√©riel et le code dispara√Ætront. Mettons ensemble un sch√©ma sur lequel nous allons impl√©menter des calculs th√©oriques. Pour ce faire, vous aurez besoin de deux modules dont j'ai parl√© dans les articles pr√©c√©dents: le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module de puissance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module de contr√¥le sur le STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vous pouvez √©galement assembler vous-m√™me un demi-pont √† partir de n'importe quelle poubelle improvis√©e de type IR2110 sur une planche √† pain, et utiliser n'importe quel MK comme contr√¥le: STM32-Discovery, LaunchPad, Arduino et simplement adapter la logique de travail et le code √† votre MK pr√©f√©r√©, rien ne sera compliqu√© si vous avez compris dans les deux premiers chapitres comment fonctionne le convertisseur abaisseur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendons maintenant notre diagramme buck plus ¬´r√©aliste¬ª en y ajoutant les valeurs de tous les composants et refl√©tons correctement le nombre de condensateurs, et notons quelle partie mon module d'alimentation peut r√©aliser:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir sur le sch√©ma, le module contient d√©j√† un demi-pont (deux transistors) pour impl√©menter un buck synchrone et un condensateur d'entr√©e, soit dit en passant, il est dans le module avec une √©norme marge - il y a 3 √©lectrolytes de 1000 uF et 100V chacun, cela suffit pour assembler facilement un buck pour 500 -800 watts Il nous reste √† rajouter une self, que nous avons d√©j√† fabriqu√©e et des condensateurs de sortie, ces derniers d'ailleurs d'ailleurs avec une marge, car Je n'ai trouv√© que 4700 uF 25V pour la basse tension, mais ce sont des chinois, j'ai donc d√©cid√© de parall√©liser un couple. En fait, il y a assez de 470 uF l√†-bas, mais je n'avais tout simplement pas une telle bagatelle dans la version de sortie. Il s'av√®re que cette conception:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionn√© pr√©c√©demment, une puissante LED de 20 W est utilis√©e comme charge. </font><font style="vertical-align: inherit;">Je ne sais pas combien de lumi√®re il brille, et ce n'est pas tr√®s int√©ressant, mais il consomme seulement 21 ... 22 W √† 12 V pour lequel mon convertisseur abaisseur est con√ßu. </font><font style="vertical-align: inherit;">La LED elle-m√™me a recouvert le KPT-8 et l'a viss√© au radiateur, bien s√ªr, ce n'est pas suffisant, mais cela dure 5-7 minutes sans probl√®me (il chauffe jusqu'√† +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C), et je n'en ai pas besoin de plus. </font><font style="vertical-align: inherit;">Nous connectons 2 signaux HRPWM, GND du module de commande et, via le diviseur, nous raccordons la sortie buck √† l'ADC, en cons√©quence, nous avons un tel support:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chapitre 4. √âcrire un logiciel et d√©marrer le convertisseur </font></font></h2><br>  Nous avons maintenant tout ce dont nous avons besoin pour commencer √† √©crire du code et √† revitaliser notre convertisseur buck.  Tout d'abord, regardons le brochage du microcontr√¥leur STM32F334R8T6, qui se trouve dans le module de contr√¥le: <br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br>  Nous savons maintenant quelles broches de microcontr√¥leur seront utilis√©es.  Sur le module lui-m√™me, je n'ai besoin que de 1 canal sur 5 pour contr√¥ler le bloc d'alimentation, nous utiliserons le canal ¬´A¬ª.  Ce canal, comme tout le reste, poss√®de 2 sorties PWM de haute pr√©cision (HRPWM), 1 entr√©e d'erreur (nous ne l'utilisons pas), GND pour combiner la masse des cartes et 2 canaux ADC (nous n'en utiliserons qu'une pour la tension). <br><br>  <b>Un peu sur HRPWM</b> <br><br>  Dans les √©tendues du segment de langue russe d'Internet, je n'ai presque pas rencontr√© de mat√©riel de formation sur HRPWM et je n'ai pas du tout rencontr√© de mat√©riel sur le travail avec HRPWM bas√© sur des microcontr√¥leurs STM32, et c'est un p√©riph√©rique tr√®s utile. <br><br>  Je ne m'attarderai pas sur la th√©orie de cette p√©riph√©rie dans le cadre de cet article, je d√©crirai donc l'essentiel.  HRPWM ou PWM haute r√©solution est notre module PWM habituel, qui a une r√©solution accrue pour le r√©glage du facteur de marche et a en outre g√©n√©ralement des param√®tres plus flexibles. <br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li>  Le microcontr√¥leur STM32F334R8T6 poss√®de 10 canaux HRPWM, qui sont combin√©s en 5 groupes de 2 canaux.  Ces 2 canaux au sein du groupe peuvent fonctionner √† la fois ind√©pendamment et former une paire compl√©mentaire - nous avons besoin de ce dernier; </li><li>  √Ä l'int√©rieur de la paire compl√©mentaire entre 2 signaux PWM, il est possible d'installer un temps mort mat√©riel pour la protection contre le courant traversant; </li><li>  Les 10 canaux sont synchronis√©s √† partir d'une seule minuterie - Minuterie principale, de sorte qu'ils sont tous synchronis√©s les uns avec les autres et vous n'avez pas √† configurer manuellement une cha√Æne de temporisateurs.  Il suffit d'activer les temporisateurs Master et Timer A ... E pour en √™tre synchronis√©s; </li><li>  La fr√©quence √† HRPWM est doubl√©e, c'est-√†-dire qu'√† une fr√©quence centrale de 72 MHz, √† HRPWM, elle est de 144 MHz apr√®s un multiplicateur suppl√©mentaire (x2) avec PLL.  Cela permet de contr√¥ler les convertisseurs √† une fr√©quence de centaines de kHz; </li><li>  De nombreux param√®tres pour le contr√¥le PWM, par exemple, ainsi que la possibilit√© de lier la g√©n√©ration PWM au d√©but et √† la fin de la p√©riode, il y a 4 autres √©v√©nements configurables (comp) qui vous permettent de traduire le PWM en 0 ou 1 √† tout moment de la p√©riode autre que le d√©but / la fin de la p√©riode; </li><li>  Il existe des modes pour des topologies sp√©cifiques, par exemple, le mode push-pull, qui vous permet d'impl√©menter de nombreuses topologies push-pull. </li></ul><br>  Et ce n'est qu'une petite partie des fonctionnalit√©s, sur le diagramme de l'appareil HRPWM, vous pouvez voir les capacit√©s de synchronisation avec un tas d'√©v√©nements, DAC, comparateurs int√©gr√©s au MK, et avec ce diagramme, il y a beaucoup plus de possibilit√©s document√©es. <br><br>  Il reste la derni√®re question qui doit √™tre abord√©e - "pourquoi ce bit haut PWM?".  Pour ce faire, consid√©rons un exemple simple.  Imaginez que nous avons d√©cid√© d'utiliser MK sans HRPWM, disons STM32F103C8T6, qui fonctionne √©galement √† une fr√©quence de 72 MHz.  Nous devons contr√¥ler le demi-pont √† une fr√©quence de 70 kHz, nous consid√©rons quel pas de r√©gulation nous pouvons obtenir: 72 000 000/1025 pas = 70 243 Hz.  Oui, nous avons 1025 √©tapes et lors du r√©glage, nous pouvons changer la tension de sortie avec une √©tape th√©orique de 1/1025 = ~ 0,1%.  Maintenant, nous prenons STM32F334, avec une fr√©quence d'horloge de 144 MHz et une largeur de d√©calage de la minuterie de 32 bits, nous obtenons la fr√©quence √©quivalente de 144 MHz * 32 = 4,608 GHz.  Pour ceux qui ont eu peur et ont dout√© du chiffre: <br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br>  Non, ce n'est pas une fr√©quence de fonctionnement, c'est une fr√©quence √©quivalente.  Qu'est-ce que cela nous donne?  On prend la fr√©quence √©quivalente de 4 608 000 000 Hz / 70 300 Hz = 65 535 pas.  Nous pouvons maintenant ajuster la tension (ou le courant) √† la sortie par incr√©ments de 1/65 535 = ~ 0,001%, c'est-√†-dire 100 fois plus pr√©cis! <br><br>  Et maintenant, faisons-le - nous avons une fr√©quence de 700 kHz, ce qui est normal pour un buck multiphas√©, par exemple.  Le F103 obtiendra 72 000 000 Hz / 700 000 Hz = 102 pas, ce qui vous permet d'obtenir au mieux une r√©gulation de 1%, mais c'est 1% pour le service, c'est-√†-dire qu'en r√©alit√© avec autant de pas vous aurez une tension flottante √† la sortie comme si elle se stabilisait et pas vraiment.  Alors que pour F334, le nombre de pas sera d'environ 6500, ce qui vous permet de construire un r√©gulateur de tension ou de courant tr√®s pr√©cis.  Nous obtenons que la r√©solution (√©tape) du param√®tre de rapport cyclique est beaucoup plus √©lev√©e / plus souvent qu'avec un MK conventionnel avec un module PWM standard √† l'int√©rieur. <br><br>  <b>Configuration du syst√®me d'horloge</b> <br><br>  J'ai utilis√© TrueSTUDIO comme environnement de d√©veloppement dans cet article, car il est gratuit, pas aussi mis√©rable que Keil ou IAR <s>oui oui, parlez-moi de son merveilleux d√©bogueur</s> , multiplateforme et peut-√™tre la meilleure solution pour les d√©butants et pas seulement.  √Ä la fin de l'article, il y aura une archive avec le projet sp√©cifiquement pour cet IDE.  Je ne vais pas vous dire comment cr√©er et configurer un projet, je vais juste laisser un lien vers la vid√©o o√π tout est montr√© en d√©tail - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regardez</a> . <br><br>  Apr√®s avoir cr√©√© un projet et fait clignoter une LED, vous devez configurer le syst√®me d'horloge, √† savoir, de 8 MHz augmenter la fr√©quence √† 72 MHz et appliquer au c≈ìur, puis ajuster le diviseur pour r√©duire la fr√©quence fournie √† l'ADC: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Ici, je pense juste que l'algorithme de r√©glage est le suivant: <i>il passe au quartz externe (HSE) -&gt; nous attendons lorsque la transition est termin√©e et le drapeau pr√™t est d√©fini -&gt; nous envoyons le signal du quartz √† l'entr√©e PLL -&gt; nous multiplions 8 MHz par 9 -&gt; nous divisons la fr√©quence par 72 MHz par 10 pour synchroniser l'ADC -&gt; allumez PLL -&gt; attendez qu'il s'allume et d√©finissez le drapeau pr√™t -&gt; envoyez un signal de PLL au bus syst√®me et au c≈ìur -&gt; attendez que le commutateur soit termin√© -&gt; fait.</i> <br><br>  <b>Configuration de HRPWM</b> <br><br>  Ici, tout est un peu plus compliqu√©, car  Ce module a beaucoup de fonctionnalit√©s, un tas de param√®tres et la quantit√© de documentation est tr√®s grande, mais c'est un inconv√©nient et en m√™me temps un plus - vous devez payer pour la flexibilit√©. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  Vous devez sp√©cifier que HRTIM est cadenc√© √† partir de PLL, le multiplicateur x2 est d√©j√† activ√© par d√©faut.  Ensuite, nous allumons simplement l'horloge pour HRTIM, voici la premi√®re fonctionnalit√© - si nous comprenons que la minuterie est cadenc√©e √† partir de PLL, mais nous l'allumons pour APB2.  Ce n'est pas tout √† fait logique, mais il est facilement recherch√© dans le fichier avec CMSIS ou dans la documentation. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 et PA9 sont la sortie du temporisateur A, qui sur mon module va au canal n ¬∞ 1, que vous pouvez voir dans le diagramme et le brochage.  Les jambes sont configur√©es en push-pull avec une fonction alternative, le num√©ro de la fonction elle-m√™me pour les deux jambes est le 13√®me.  Il est √©galement important de r√©gler la fr√©quence GPIO maximale, sinon il y aura un blocage incompr√©hensible du front et de la chute du signal, ce qui est extr√™mement critique pour l'√©lectronique de puissance. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Avant de commencer, vous devez calibrer la minuterie, car  Cela fonctionne avec des d√©lais minimaux, puis attendez simplement le drapeau pr√™t. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  C'est √ßa la flexibilit√©.  Tout d'abord, nous pouvons d√©finir notre propre fr√©quence pour chaque temporisateur A ... E, ici nous enregistrons simplement la p√©riode de notre PWM.  Deuxi√®mement, par d√©faut, nous avons l'alignement PWM au d√©but de la p√©riode, c'est-√†-dire que le signal passe √† log.1 au d√©but d'une nouvelle p√©riode, et maintenant nous devons choisir quand il reviendra √† log.0, dans ce cas, par le comparateur n ¬∞ 1, c'est-√†-dire J'y demande essentiellement le facteur de droit. <br><br>  Par exemple, vous pouvez traduire PWM non pas au d√©but de la p√©riode, mais par le comparateur n ¬∞ 1, et revenir √† log.0 par le comparateur n ¬∞ 2 et ainsi d√©placer en phase le mat√©riel. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  A ce stade, nous activons le temps mort et le configurons, en principe, les commentaires contiennent toutes les formules, elles peuvent √©galement √™tre trouv√©es dans le manuel de r√©f√©rence.  DT avec une dur√©e de ~ 100 ns que vous avez d√©j√† vu sur la forme d'onde dans le chapitre th√©orique de cet article.  Le temps mort peut √™tre r√©gl√© s√©par√©ment sur le bord et sur le d√©clin du signal.  Soit dit en passant, [0] est le temporisateur A, respectivement [1] est le temporisateur B et ainsi de suite. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  Pour moi, ce n'√©tait pas le moment le plus √©vident.  L'essentiel est - je veux m'assurer que pendant 10% de la dur√©e de la p√©riode du temporisateur A, un √©v√©nement est g√©n√©r√© qui d√©clenche la conversion ADC et mesure le signal de r√©troaction.  Pourquoi 10%?  Simplement, id√©alement, la mesure ne devrait pas avoir lieu au moment de la transition du PWM de 0 √† 1 ou vice versa, car  en ce moment dans l'unit√© de puissance il y a des transitoires et des interf√©rences, mais nous n'avons pas besoin de les mesurer.  Par cons√©quent, 10% dans mon cas est optimal, car  √† une sortie de 12 V et √† 30 V, la tension d'entr√©e du facteur de marche ne tombera pas √† 10% et le moment de la commutation du transistor ne correspondra pas exactement √† la mesure ADC. <br><br>  Maintenant, vous devez regarder le syst√®me de communication √©v√©nementielle entre HRTIM et l'ADC: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  Dans la premi√®re ligne, nous choisissons quand le comparateur sera d√©clench√©, dans mon cas c'est 10% de la p√©riode du temporisateur A. Ensuite, nous s√©lectionnons un d√©clencheur sp√©cifique dans l'ADC qui contactera le MK, nous avons acc√®s au 1er ou au 3√®me.  Maintenant, il indique simplement quel √©v√©nement enverra le signal √† l'ADC, dans mon cas, c'est le comparateur n ¬∞ 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  Et l'accord final!  Nous permettons √† HRTIM d'√©mettre des signaux du temporisateur A vers notre GPIO.  Maintenant, nous s√©lectionnons le mode, cela se produit sans fin (je l'ai), mais il arrive que le minuteur soit allum√© pendant 1 p√©riode et apr√®s cela, il doit √™tre red√©marr√©.  Ensuite, d√©finissez la p√©riode de la minuterie principale et allumez-la comme derni√®re √©tape, elle commence √† synchroniser les temporisateurs de canal et le signal PWM appara√Æt √† la sortie. <br><br>  C'√©tait une fonction de r√©glage, il reste √† faire une fonction qui fixera le facteur de marche, c'est avec elle que nous travaillerons lors de la cr√©ation du contr√¥leur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Liste des param√®tres de fonction et d√©finition du cycle de service</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Voyons maintenant si nous allons dans le bon sens.  Dans la fonction <i>principale</i> , initialisez le param√®tre HRTIM et d√©finissez le rapport cyclique, disons 22500. Avec une tension d'entr√©e de 20V et une p√©riode de 45000, notre rapport cyclique sera de 50% et la sortie sera d'environ 10V.  Cela ne suffit pas pour √©tendre la LED au maximum, mais cela devrait s'allumer et nous comprendrons si la section d'alimentation fonctionne, tout est ok avec dt et ainsi de suite.  J'ai tout commenc√© la premi√®re fois: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Vous pouvez voir que tous les calculs th√©oriques pr√©c√©dents ont √©t√© confirm√©s.  Avec un facteur de marche fixe de 50%, la tension de sortie √©tait simplement divis√©e par 2: 20V -&gt; 10V, 22V -&gt; 11V, 18V -&gt; 9V.  Maintenant, rendons la tension de sortie stable et ind√©pendante de l'entr√©e, c'est-√†-dire ajoutons un retour. <br><br>  <b>ADC et r√©glage du contr√¥leur</b> <br><br>  Beaucoup de choses ont d√©j√† √©t√© √©crites sur les ADC dans STM32 avant moi, je ne m'arr√™te que sur la configuration du d√©clencheur associ√© au comparateur HRTIM.  Je vais parler bri√®vement du reste des param√®tres ADC.  Nous regardons la fonction d'initialisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  J'utilise le mode canal normal, je n'ai qu'un canal et il est s√©lectionn√© dans le registre <i>SQR1</i> .  Impliqu√© ADC num√©ro 2, √† savoir son entr√©e IN5, il est rapide et peut fonctionner √† la fr√©quence d'√©chantillonnage maximale, mais pas cette fois.  La fr√©quence d'√©chantillonnage est √©gale √† la fr√©quence PWM, car  1 p√©riode = 1 √©chantillon, en principe, c'est largement suffisant. <br><br>  De plus, dans le registre <i>CFGR</i> , <i>nous</i> devons s√©lectionner l'√©v√©nement par lequel la conversion commencera, c'est-√†-dire l' <i>√©v√©nement 7</i> , pourquoi exactement?  On regarde en RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  Le d√©clencheur 1 du module HRPWM arrive √† l'√©v√©nement 7 pour notre ADC n ¬∞ 2, qui dans ce cas fonctionne comme un esclave, puis il est contr√¥l√© √† partir du module HRPWM.  Je pense que maintenant il est clair comment connecter 2 modules, en principe, l'algorithme est similaire pour n'importe quelle p√©riph√©rie et n'importe quelle minuterie, seul le nom du registre diff√©rera. <br><br>  Lorsque le compteur de p√©riode du temporisateur principal est atteint, une conversion d√©marre, qui apr√®s environ 15 cycles (pour combien exactement voir en RM) provoquera une interruption et vous pourrez y r√©cup√©rer le r√©sultat.  C'est dans cette interruption que nous organisons l'algorithme de contr√¥le.  Oui, √† l'int√©rieur de l'interruption, quelque chose de massif vaut mieux ne pas le faire, il vaut mieux mettre le drapeau et passer l'ex√©cution, mais je me permettrai une telle simplification, car dans ce cas mon contr√¥leur n'est pas particuli√®rement charg√© et il arrivera √† calculer et sortir de l'interruption avec une probabilit√© de 146% √† l'√©mergence d'un nouveau. <br><br>  <b>Un peu sur la gestion</b> <br><br>  Imaginez que vous √™tes entr√© dans la salle de bain et avez d√©cid√© de vous laver les mains dans l'√©vier.  Vous ouvrez l√©g√®rement l'eau, la touchez avec votre main, froide?  Ajouter plus d'eau chaude, plus chaude?  Bon!  Ajouter plus d'eau chaude?  Presque ce dont vous avez besoin?  Bon!  Ajouter plus d'eau chaude, essayer avec la main, se br√ªler?  Baissons un peu le chaud maintenant.  D'accord?  Et donc √† l'infini, vous tournerez le robinet jusqu'√† ce que la temp√©rature de l'eau devienne id√©ale.  C'est le bouton le plus simple! <br><br>  Seulement, nous ne r√©glementons pas la quantit√© d'eau chaude, mais le cycle de service PWM.  Au lieu d'une main, nous avons un ADC avec un r√©sultat mesur√©.  Il ne reste plus qu'√† mettre en ≈ìuvre la logique.  Nous calculerons ce que l'ADC devrait produire √† une sortie 12V, puis en utilisant la condition <i>if</i> , nous forcerons notre contr√¥leur √† maintenir cette valeur en changeant le facteur de marche. <br><br>  Pour commencer, raccrochons un diviseur de tension pour r√©duire le 12V √† 2-2,5V, par exemple, car  L'ADC peut mesurer de 0 √† + 3,3V et si 12V est fourni, le microcontr√¥leur s'√©teindra simplement.  Par cons√©quent, je mettrai un diviseur avec des valeurs nominales de 10 kOhm et 2 kOhm, ce qui donnera un rapport de division de 6 et, en cons√©quence, notre + 12V se transformera en + 2V.  Notre ADC produira le r√©sultat: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12V / 6) / 3.3 * 4095 = 2481. Maintenant, nous √©crivons le code du gestionnaire d'interruption: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  Tout d'abord, apr√®s √™tre entr√© dans le gestionnaire d'interruption, vous devez effacer le drapeau de cette interruption, sinon la deuxi√®me fois, vous n'y entrerez pas.  Ensuite, nous lisons le r√©sultat et l'enregistrons en tant que variable <i>adcResult</i> .  Maintenant, connaissant la tension √† la sortie, vous devez ajuster le rapport cyclique pour le PWM, je l'ai impl√©ment√© simplement via la condition <i>if</i> .  Dans chaque p√©riode PWM, nous prenons une mesure, augmentons ou diminuons le rapport cyclique et d√©finissons le r√©sultat pour la p√©riode suivante.  Tout est simple, rapide et l'essence est visible.  Nous regardons le r√©sultat du travail: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Comme vous pouvez le voir, tout fonctionne et lorsque la tension d'entr√©e change, la sortie elle-m√™me reste stable √† 12V.  Tr√®s attentif, vous remarquerez que de petites aiguilles glissent, alors il vous suffit de suspendre la c√©ramique X7R √† la sortie de 1-10 microfarades et elles partiront, je suis juste trop paresseux pour la chercher et la souder.  Maintenant l'oscillogramme lui-m√™me, pour ne pas g√¢cher les yeux: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Ici, vous pouvez voir comment la tension de sortie augmente.  Le fait est qu'en raison de l'algorithme de contr√¥le, pour que le remplissage atteigne une valeur de 0 √† 10000, par exemple, mille p√©riodes ou environ 10 ms sont n√©cessaires.  Cela me convient car un d√©marrage en douceur, si vous voulez r√©duire le temps de mont√©e, compliquez un peu l'algorithme et ajoutez +1000, pas +10, et plus vous vous rapprochez du 12V sp√©cifi√©, moins vous r√©glez jusqu'√† ce que vous atteigniez +10 .  En g√©n√©ral, beaucoup de choses peuvent √™tre faites en termes de gestion, vous avez donc un champ d'exp√©rimentation. <br><br>  Un autre point int√©ressant est l'oscillation au moment de l'arr√™t, un tel "harmonica".  Le fait est qu'apr√®s avoir coup√© l'alimentation, ma partie num√©rique continue de fonctionner √† partir d'une autre alimentation et essaie de conserver la valeur souhait√©e √† la sortie.  D'o√π vient l'√©nergie?  Oui, √† partir du condensateur d'entr√©e, ce sont ceux qui font d√©j√† 1 000 microfarads en 3 pi√®ces, c'est un ph√©nom√®ne tellement int√©ressant. <br><br><h2>  Conclusion </h2><br>  L'article n'√©tait pas petit, mais vous vouliez tout et imm√©diatement, ils disent: pr√©parons le morceau de fer - faites-le.  J'esp√®re que vous appr√©cierez l'article, j'ai essay√© de le rendre non pas scientifique, mais populaire, afin que le mat√©riel soit accessible √† des personnes ayant diff√©rents niveaux de connaissances et d'exp√©rience.  Peut-√™tre qu'√† l'avenir, j'analyserai de mani√®re similaire d'autres topologies telles que boost, pont complet et autres. <br><br>  √Ä propos, cet article et ce code serviront au nouveau contr√¥leur MPPT sur 20A, que je con√ßois.  J'attends maintenant les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cartes PCBway</a> , qui se sont port√©es volontaires pour parrainer mes projets open-source avec des cartes de circuits imprim√©s, les sources MPPT seront √©galement ouvertes comme pour tous mes modules. <br><br>  J'ai oubli√© la chose la plus importante!  Conservez le projet avec le code TrueSTDIO - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RAR</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432778/">https://habr.com/ru/post/fr432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432768/index.html">√âcouteurs sans fil pour les "marathons en s√©rie": dans Dolby, ils seront offerts pour 599 $</a></li>
<li><a href="../fr432770/index.html">Les botnets et leurs types: ce que l'on sait en 2018</a></li>
<li><a href="../fr432772/index.html">Comment nous avons cr√©√© un service de campagne publicitaire conforme au RGPD</a></li>
<li><a href="../fr432774/index.html">Frontend DevDay. Enregistrement de rapport</a></li>
<li><a href="../fr432776/index.html">Le livre "R√©agissez en action"</a></li>
<li><a href="../fr432780/index.html">Pourquoi l'empathie est n√©cessaire dans le monde de la technologie</a></li>
<li><a href="../fr432782/index.html">Installation multi-serveurs Zimbra Collaboration Suite</a></li>
<li><a href="../fr432784/index.html">Castlevania Bot</a></li>
<li><a href="../fr432786/index.html">.NET - localisation sans douleur. (N) gettext + poedit</a></li>
<li><a href="../fr432788/index.html">Prototypes: comment cr√©er un produit r√©ussi et √©conomiser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>