<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏻 👲🏽 🎷 Render zero-copy sederhana dari video yang dipercepat perangkat keras dalam QML 🥝 👌🏼 🐔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Tujuan artikel ini adalah untuk menunjukkan bagaimana Anda dapat berteman dengan buffer video pihak ketiga dan QML. Gagasan utamanya a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Render zero-copy sederhana dari video yang dipercepat perangkat keras dalam QML</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486062/"><h2 id="vvedenie">  Pendahuluan </h2><br><p> Tujuan artikel ini adalah untuk menunjukkan bagaimana Anda dapat berteman dengan buffer video pihak ketiga dan QML.  Gagasan utamanya adalah menggunakan komponen QML standar dari VideoOutput.  Itu memungkinkan Anda untuk menghilangkan sumber pihak ketiga, itu didokumentasikan dengan baik dan memiliki backend yang mendukung GL_OES_EGL_image_external. </p><br><p>  Gagasan bahwa ini mungkin tiba-tiba berguna muncul setelah saya mencoba menjalankan contoh bekerja dengan kamera di Qt, dan pada platform tertanam mereka bekerja pada kecepatan 3-5 frame per detik.  Menjadi jelas bahwa di luar kotak tidak ada pertanyaan tentang salinan nol, meskipun platform mendukung semua ini dengan sangat baik.  Dalam keadilan, pada desktop, VideoOutput dan Kamera berfungsi, seperti yang diharapkan, cepat dan tanpa penyalinan yang tidak perlu.  Namun dalam tugas saya, sayangnya, itu tidak mungkin dilakukan dengan kelas yang ada untuk merekam video, dan saya ingin mendapatkan video dari sumber pihak ketiga, yang bisa berupa pipa GStreamer sewenang-wenang untuk mendekode video, misalnya, dari file atau aliran RTSP, atau API pihak ketiga yang dapat diintegrasikan ke dalam pangkalan Kelas Qt agak meragukan.  Anda dapat, tentu saja, sekali lagi menemukan kembali roda dan menulis komponen Anda dengan menggambar melalui OpenGL, tetapi segera tampak jalan buntu yang sengaja dan sulit. </p><br><p>  Semuanya mengarah pada fakta bahwa Anda perlu mencari tahu cara kerjanya, dan menulis aplikasi kecil yang mengkonfirmasi teorinya. </p><a name="habracut"></a><br><h2 id="teoriya">  Teori </h2><br><p>  VideoOutput mendukung sumber khusus, asalkan </p><br><ol><li>  objek yang diteruskan dapat menerima QAbstractVideoSurface langsung melalui properti videoSurface </li><li>  atau melalui mediaObject dengan QVideoRendererControl <a href="https://doc.qt.io/qt-5/qml-qtmultimedia-videooutput.html">[tautan]</a> . </li></ol><br><p>  Pencarian dalam sumber dan dokumentasi menunjukkan bahwa QtMultimedia memiliki kelas QAbstractVideoBuffer yang mendukung berbagai jenis pegangan, dari QPixmap hingga GLTexture dan EGLImage.  Pencarian lebih lanjut menyebabkan plugin videonode_egl, yang merender frame yang datang menggunakan shader dengan samplerExternalOES.  Ini berarti bahwa setelah saya berhasil membuat QAbstractVideoBuffer dengan EGLImage, tetap menemukan cara untuk meneruskan buffer ini ke videnode_egl. <br>  Dan jika platform EGLImage tidak didukung, maka Anda dapat membungkus memori dan mengirimkannya untuk dirender, karena shader untuk sebagian besar format piksel telah diterapkan. </p><br><h2 id="realizaciya">  Implementasi </h2><br><p>  Contohnya hampir seluruhnya didasarkan pada tutorial <a href="https://doc.qt.io/qt-5/videooverview.html">Tinjauan Video</a> . </p><br><p>  Agar Qt dapat bekerja dengan OpenGL ES pada desktop, Anda perlu membangun kembali Qt dengan flag yang sesuai.  Secara default, ini tidak diaktifkan untuk desktop. </p><br><p>  Untuk kesederhanaan, kami akan menggunakan metode pertama, dan mengambil pipa GStreamer sederhana sebagai sumber video: </p><br><pre><code class="bash hljs">v4l2src ! appsink</code> </pre> <br><p>  Buat kelas V4L2Source yang akan mengirimkan frame ke QAbstractVideoSurface yang ditentukan olehnya. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V4L2Source</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QQuickItem { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_PROPERTY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QAbstractVideoSurface* videoSurface READ videoSurface WRITE setVideoSurface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_PROPERTY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString device MEMBER m_device READ device WRITE setDevice)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_PROPERTY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString caps MEMBER m_caps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V4L2Source</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QQuickItem* parent = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~V4L2Source(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVideoSurface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QAbstractVideoSurface* surface)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString device)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QQuickWindow* win)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frameReady</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... }</code> </pre> <br><p>  Semuanya cukup sepele, kecuali slot setWinow () - diperlukan untuk mencegat sinyal QQuickItem :: windowChanged () dan mengatur panggilan balik ke QQuickWindow :: beforeSynchronizing (). </p><br><p>  Karena backend VideoOutput tidak selalu tahu cara bekerja dengan EGLImage, Anda perlu bertanya QAbstractVideoSurface format apa untuk QAbstractVideoBuffer :: HandleType yang didukungnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> V4L2Source::setVideoSurface(QAbstractVideoSurface* surface) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_surface != surface &amp;&amp; m_surface &amp;&amp; m_surface-&gt;isActive()) { m_surface-&gt;stop(); } m_surface = surface; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (surface -&gt;supportedPixelFormats( QAbstractVideoBuffer::HandleType::EGLImageHandle) .size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { EGLImageSupported = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { EGLImageSupported = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_surface &amp;&amp; m_device.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { start(); } }</code> </pre> <br><p>  Mari buat pipeline kami dan atur callback yang diperlukan: </p><br><pre> <code class="cpp hljs">GstAppSinkCallbacks V4L2Source::callbacks = {.eos = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, .new_preroll = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, .new_sample = &amp;V4L2Source::on_new_sample}; V4L2Source::V4L2Source(QQuickItem* parent) : QQuickItem(parent) { m_surface = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;QQuickItem::windowChanged, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;V4L2Source::setWindow); pipeline = gst_pipeline_new(<span class="hljs-string"><span class="hljs-string">"V4L2Source::pipeline"</span></span>); v4l2src = gst_element_factory_make(<span class="hljs-string"><span class="hljs-string">"v4l2src"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); appsink = gst_element_factory_make(<span class="hljs-string"><span class="hljs-string">"appsink"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); GstPad* pad = gst_element_get_static_pad(appsink, <span class="hljs-string"><span class="hljs-string">"sink"</span></span>); gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_QUERY_BOTH, appsink_pad_probe, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); gst_object_unref(pad); gst_app_sink_set_callbacks(GST_APP_SINK(appsink), &amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); gst_bin_add_many(GST_BIN(pipeline), v4l2src, appsink, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); gst_element_link(v4l2src, appsink); context = g_main_context_new(); loop = g_main_loop_new(context, FALSE); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> V4L2Source::setWindow(QQuickWindow* win) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (win) { connect(win, &amp;QQuickWindow::beforeSynchronizing, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;V4L2Source::sync, Qt::DirectConnection); } } GstFlowReturn V4L2Source::on_new_sample(GstAppSink* sink, gpointer data) { Q_UNUSED(sink) V4L2Source* self = (V4L2Source*)data; <span class="hljs-function"><span class="hljs-function">QMutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;self-&gt;mutex)</span></span></span></span>; self-&gt;ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; self-&gt;frameReady(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GST_FLOW_OK; } <span class="hljs-comment"><span class="hljs-comment">// Request v4l2src allocator to add GstVideoMeta to buffers static GstPadProbeReturn appsink_pad_probe(GstPad* pad, GstPadProbeInfo* info, gpointer user_data) { if (info-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_BOTH) { GstQuery* query = gst_pad_probe_info_get_query(info); if (GST_QUERY_TYPE(query) == GST_QUERY_ALLOCATION) { gst_query_add_allocation_meta(query, GST_VIDEO_META_API_TYPE, NULL); } } return GST_PAD_PROBE_OK; }</span></span></code> </pre> <br><p>  Di konstruktor, kode standar untuk meluncurkan pipa Anda dibuat oleh GMainContext dan GMainLoop untuk membuat pipa dalam aliran terpisah. </p><br><p>  Perlu memperhatikan Qt :: DirectConnection flag di setWindow () - ini menjamin bahwa panggilan balik akan dipanggil dalam utas yang sama dengan sinyal, yang memberi kita akses ke konteks OpenGL saat ini. </p><br><p>  V4L2Source :: on_new_sample () yang dipanggil ketika frame baru dari v4l2src tiba di appsink cukup set flag yang siap dan memicu sinyal yang sesuai untuk memberi tahu VideoOutput bahwa perlu untuk menggambar ulang konten. </p><br><p>  Probe sink aplikasi diperlukan untuk meminta pengalokasi v4l2src untuk menambahkan informasi meta tentang format video ke setiap buffer.  Ini perlu untuk memperhitungkan situasi akun saat pengemudi mengeluarkan buffer video dengan teguran / offset selain standar. </p><br><p>  Pembaruan bingkai video untuk VideoOutput terjadi di slot sync (): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make sure this callback is invoked from rendering thread void V4L2Source::sync() { { QMutexLocker locker(&amp;mutex); if (!ready) { return; } // reset ready flag ready = false; } // pull available sample and convert GstBuffer into a QAbstractVideoBuffer GstSample* sample = gst_app_sink_pull_sample(GST_APP_SINK(appsink)); GstBuffer* buffer = gst_sample_get_buffer(sample); GstVideoMeta* videoMeta = gst_buffer_get_video_meta(buffer); // if memory is DMABUF and EGLImage is supported by the backend, // create video buffer with EGLImage handle videoFrame.reset(); if (EGLImageSupported &amp;&amp; buffer_is_dmabuf(buffer)) { videoBuffer.reset(new GstDmaVideoBuffer(buffer, videoMeta)); } else { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> support other memory types, probably GL textures? // just map memory videoBuffer.reset(new GstVideoBuffer(buffer, videoMeta)); } QSize size = QSize(videoMeta-&gt;width, videoMeta-&gt;height); QVideoFrame::PixelFormat format = gst_video_format_to_qvideoformat(videoMeta-&gt;format); videoFrame.reset(new QVideoFrame( static_cast&lt;QAbstractVideoBuffer*&gt;(videoBuffer.get()), size, format)); if (!m_surface-&gt;isActive()) { m_format = QVideoSurfaceFormat(size, format); Q_ASSERT(m_surface-&gt;start(m_format) == true); } m_surface-&gt;present(*videoFrame); gst_sample_unref(sample); }</span></span></code> </pre> <br><p>  Dalam fungsi ini, kami mengambil buffer terakhir yang tersedia untuk kami dari appsink, meminta GstVideoMeta untuk mencari tahu informasi tentang offset dan langkah untuk setiap daftar putar (yah, demi kesederhanaan, tidak ada mundur jika tidak ada meta untuk beberapa alasan) dan buat QAbstractVideoBuffer dengan tipe kepala yang diinginkan: EGLImage (GstDmaVideoBuffer) atau None (GstVideoBuffer).  Kemudian bungkus dalam QVideoFrame dan masukkan ke dalam antrian rendering. </p><br><p>  Implementasi GstDmaVideoBuffer dan GstVideoBuffer sendiri cukup sepele: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GST_BUFFER_GET_DMAFD(buffer, plane) \ (((plane) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; gst_buffer_n_memory((buffer))) ? \ gst_dmabuf_memory_get_fd(gst_buffer_peek_memory((buffer), (plane))) : \ gst_dmabuf_memory_get_fd(gst_buffer_peek_memory((buffer), 0))) class GstDmaVideoBuffer : public QAbstractVideoBuffer { public: // This should be called from renderer thread GstDmaVideoBuffer(GstBuffer* buffer, GstVideoMeta* videoMeta) : QAbstractVideoBuffer(HandleType::EGLImageHandle), buffer(gst_buffer_ref(buffer)), m_videoMeta(videoMeta) { static PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR = reinterpret_cast&lt;PFNEGLCREATEIMAGEKHRPROC&gt;( eglGetProcAddress("eglCreateImageKHR")); int idx = 0; EGLint attribs[MAX_ATTRIBUTES_COUNT]; attribs[idx++] = EGL_WIDTH; attribs[idx++] = m_videoMeta-&gt;width; attribs[idx++] = EGL_HEIGHT; attribs[idx++] = m_videoMeta-&gt;height; attribs[idx++] = EGL_LINUX_DRM_FOURCC_EXT; attribs[idx++] = gst_video_format_to_drm_code(m_videoMeta-&gt;format); attribs[idx++] = EGL_DMA_BUF_PLANE0_FD_EXT; attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, 0); attribs[idx++] = EGL_DMA_BUF_PLANE0_OFFSET_EXT; attribs[idx++] = m_videoMeta-&gt;offset[0]; attribs[idx++] = EGL_DMA_BUF_PLANE0_PITCH_EXT; attribs[idx++] = m_videoMeta-&gt;stride[0]; if (m_videoMeta-&gt;n_planes &gt; 1) { attribs[idx++] = EGL_DMA_BUF_PLANE1_FD_EXT; attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, 1); attribs[idx++] = EGL_DMA_BUF_PLANE1_OFFSET_EXT; attribs[idx++] = m_videoMeta-&gt;offset[1]; attribs[idx++] = EGL_DMA_BUF_PLANE1_PITCH_EXT; attribs[idx++] = m_videoMeta-&gt;stride[1]; } if (m_videoMeta-&gt;n_planes &gt; 2) { attribs[idx++] = EGL_DMA_BUF_PLANE2_FD_EXT; attribs[idx++] = GST_BUFFER_GET_DMAFD(buffer, 2); attribs[idx++] = EGL_DMA_BUF_PLANE2_OFFSET_EXT; attribs[idx++] = m_videoMeta-&gt;offset[2]; attribs[idx++] = EGL_DMA_BUF_PLANE2_PITCH_EXT; attribs[idx++] = m_videoMeta-&gt;stride[2]; } attribs[idx++] = EGL_NONE; auto m_qOpenGLContext = QOpenGLContext::currentContext(); QEGLNativeContext qEglContext = qvariant_cast&lt;QEGLNativeContext&gt;(m_qOpenGLContext-&gt;nativeHandle()); EGLDisplay dpy = qEglContext.display(); Q_ASSERT(dpy != EGL_NO_DISPLAY); image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer) nullptr, attribs); Q_ASSERT(image != EGL_NO_IMAGE_KHR); } ... // This should be called from renderer thread ~GstDmaVideoBuffer() override { static PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR = reinterpret_cast&lt;PFNEGLDESTROYIMAGEKHRPROC&gt;( eglGetProcAddress("eglDestroyImageKHR")); auto m_qOpenGLContext = QOpenGLContext::currentContext(); QEGLNativeContext qEglContext = qvariant_cast&lt;QEGLNativeContext&gt;(m_qOpenGLContext-&gt;nativeHandle()); EGLDisplay dpy = qEglContext.display(); Q_ASSERT(dpy != EGL_NO_DISPLAY); eglDestroyImageKHR(dpy, image); gst_buffer_unref(buffer); } private: EGLImage image; GstBuffer* buffer; GstVideoMeta* m_videoMeta; }; class GstVideoBuffer : public QAbstractPlanarVideoBuffer { public: GstVideoBuffer(GstBuffer* buffer, GstVideoMeta* videoMeta) : QAbstractPlanarVideoBuffer(HandleType::NoHandle), m_buffer(gst_buffer_ref(buffer)), m_videoMeta(videoMeta), m_mode(QAbstractVideoBuffer::MapMode::NotMapped) { } QVariant handle() const override { return QVariant(); } void release() override { } int map(MapMode mode, int* numBytes, int bytesPerLine[4], uchar* data[4]) override { int size = 0; const GstMapFlags flags = GstMapFlags(((mode &amp; ReadOnly) ? GST_MAP_READ : 0) | ((mode &amp; WriteOnly) ? GST_MAP_WRITE : 0)); if (mode == NotMapped || m_mode != NotMapped) { return 0; } else { for (int i = 0; i &lt; m_videoMeta-&gt;n_planes; i++) { gst_video_meta_map(m_videoMeta, i, &amp;m_mapInfo[i], (gpointer*)&amp;data[i], &amp;bytesPerLine[i], flags); size += m_mapInfo[i].size; } } m_mode = mode; *numBytes = size; return m_videoMeta-&gt;n_planes; } MapMode mapMode() const override { return m_mode; } void unmap() override { if (m_mode != NotMapped) { for (int i = 0; i &lt; m_videoMeta-&gt;n_planes; i++) { gst_video_meta_unmap(m_videoMeta, i, &amp;m_mapInfo[i]); } } m_mode = NotMapped; } ~GstVideoBuffer() override { unmap(); gst_buffer_unref(m_buffer); } private: GstBuffer* m_buffer; MapMode m_mode; GstVideoMeta* m_videoMeta; GstMapInfo m_mapInfo[4]; };</span></span></span></span></code> </pre> <br><p>  Setelah semua ini, kita dapat membangun halaman QML dari formulir berikut: </p><br><pre> <code class="json hljs">import QtQuick <span class="hljs-number"><span class="hljs-number">2.10</span></span> import QtQuick.Window <span class="hljs-number"><span class="hljs-number">2.10</span></span> import QtQuick.Layouts <span class="hljs-number"><span class="hljs-number">1.10</span></span> import QtQuick.Controls <span class="hljs-number"><span class="hljs-number">2.0</span></span> import QtMultimedia <span class="hljs-number"><span class="hljs-number">5.10</span></span> import v<span class="hljs-number"><span class="hljs-number">4</span></span>l<span class="hljs-number"><span class="hljs-number">2</span></span>source <span class="hljs-number"><span class="hljs-number">1.0</span></span> Window { visible: <span class="hljs-literal"><span class="hljs-literal">true</span></span> width: <span class="hljs-number"><span class="hljs-number">640</span></span> height: <span class="hljs-number"><span class="hljs-number">480</span></span> title: qsTr(<span class="hljs-string"><span class="hljs-string">"qml zero copy rendering"</span></span>) color: <span class="hljs-string"><span class="hljs-string">"black"</span></span> CameraSource { id: camera device: <span class="hljs-string"><span class="hljs-string">"/dev/video0"</span></span> onFrameReady: videoOutput.update() } VideoOutput { id: videoOutput source: camera anchors.fill: parent } onClosing: camera.stop() }</code> </pre> <br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Tujuan artikel ini adalah untuk menunjukkan bagaimana mengintegrasikan API yang ada yang mampu memberikan video akselerasi perangkat keras dengan QML dan menggunakan komponen yang ada untuk rendering tanpa menyalin (baik, atau dalam kasus terburuk, dengan satu, tetapi tanpa konversi perangkat lunak yang mahal ke RGB). </p><br><p>  <a href="https://github.com/Rambden/qml-zero-copy-example/tree/master">Tautan Kode</a> </p><br><h2 id="ssylki">  Referensi </h2><br><ul><li>  <a href="https://habr.com/ru/post/481540/">https://habr.com/en/post/481540/</a> </li><li>  <a href="https://habr.com/ru/post/254625/">https://habr.com/en/post/254625/</a> </li><li>  <a href="https://doc.qt.io/qt-5/videooverview.html">https://doc.qt.io/qt-5/videooverview.html</a> </li><li>  <a href="https://doc.qt.io/qt-5/qml-qtmultimedia-videooutput.html">https://doc.qt.io/qt-5/qml-qtmultimedia-videooutput.html</a> </li><li>  <a href="https://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html">https://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph.html</a> </li><li>  <a href="https://doc.qt.io/qt-5.12/qtquick-scenegraph-openglunderqml-example.html">https://doc.qt.io/qt-5.12/qtquick-scenegraph-openglunderqml-example.html</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486062/">https://habr.com/ru/post/id486062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486048/index.html">Apa itu "ini" dan apa yang dimakannya</a></li>
<li><a href="../id486050/index.html">Perpustakaan Webix JavaScript melalui mata seorang pemula. Bagian 3. Modul, diagram, tabel pohon</a></li>
<li><a href="../id486052/index.html">Bumi hangus adalah ibu dari semua game. Wawancara dengan penciptanya</a></li>
<li><a href="../id486056/index.html">Dari skrip ke platform kami sendiri: bagaimana kami mengotomatiskan pengembangan di Cyan Institute</a></li>
<li><a href="../id486060/index.html">Temukan Ketertiban dalam Kekacauan TI: Mengatur Pengembangan Anda Sendiri</a></li>
<li><a href="../id486064/index.html">Buat tayangan slide animasi dalam CSS murni.</a></li>
<li><a href="../id486066/index.html">Di area akses. Temukan jarak dari titik ke suatu daerah dan kurangi permintaan geocoding terbalik</a></li>
<li><a href="../id486070/index.html">ACL beralih secara detail</a></li>
<li><a href="../id486080/index.html">Izinkan saya memperkenalkan: Veeam Availability Suite v10</a></li>
<li><a href="../id486084/index.html">Mengganti disk yang lebih kecil dengan disk yang lebih besar di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>