<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíª üïã üë©üèø‚ÄçüöÄ Leis de reflex√£o em Go üìê üñäÔ∏è üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo "As Leis da Reflex√£o" do criador da l√≠ngua. 

 Reflex√£o √© a capacidade de um programa explorar sua pr√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leis de reflex√£o em Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"As Leis da Reflex√£o"</a> do criador da l√≠ngua. <br><br>  Reflex√£o √© a capacidade de um programa explorar sua pr√≥pria estrutura, especialmente atrav√©s de tipos.  Esta √© uma forma de metaprograma√ß√£o e uma grande fonte de confus√£o. <br>  No Go, a reflex√£o √© amplamente usada, por exemplo, nos pacotes test e fmt.  Neste artigo, tentaremos nos livrar da "m√°gica" explicando como a reflex√£o funciona no Go. <br><a name="habracut"></a><br><h3>  Tipos e interfaces </h3><br>  Como a reflex√£o √© baseada em um sistema de tipos, vamos atualizar nosso conhecimento de tipos no Go. <br>  Go √© digitado estaticamente.  Cada vari√°vel possui um e apenas um tipo est√°tico fixo em tempo de compila√ß√£o: <code>int, float32, *MyType, []byte</code> ... Se declararmos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  ent√£o <code>i</code> √© do tipo <code>int</code> e <code>j</code> √© do tipo <code>MyInt</code> .  As vari√°veis ‚Äã‚Äãiej t√™m tipos est√°ticos diferentes e, embora tenham o mesmo tipo b√°sico, n√£o podem ser atribu√≠das uma √† outra sem convers√£o. <br><br>  Uma das categorias de tipo importantes s√£o as interfaces, que s√£o conjuntos fixos de m√©todos.  Uma interface pode armazenar qualquer valor espec√≠fico (sem interface), desde que esse valor implemente os m√©todos da interface.  Um par conhecido de exemplos √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">io.Reader e io.Writer</a> , os tipos Reader e Writer do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote io</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Diz-se que qualquer tipo que implemente o m√©todo <code>Read()</code> ou <code>Write()</code> com esta assinatura implementa <code>io.Reader</code> ou <code>io.Writer</code> respectivamente.  Isso significa que uma vari√°vel do tipo <code>io.Reader</code> pode conter qualquer valor do tipo Read (): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  √â importante entender que <code>r</code> pode ser atribu√≠do a qualquer valor que implemente <code>io.Reader</code> .  Go √© digitado estaticamente e o tipo est√°tico <code>r</code> √© <code>io.Reader</code> . <br><br>  Um exemplo extremamente importante de um tipo de interface √© a interface vazia: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  √â um conjunto vazio de m√©todos e √© implementado por qualquer valor. <br>  Alguns dizem que as interfaces Go s√£o vari√°veis ‚Äã‚Äãde tipo din√¢mico, mas isso √© uma fal√°cia.  Eles s√£o digitados estaticamente: uma vari√°vel com um tipo de interface sempre tem o mesmo tipo est√°tico e, embora em tempo de execu√ß√£o, o valor armazenado na vari√°vel da interface possa alterar o tipo, esse valor sempre satisfar√° a interface.  (N√£o √© <code>undefined</code> , <code>NaN</code> ou outras coisas que quebram a l√≥gica do programa.) <br><br>  Isso deve ser entendido - a reflex√£o e as interfaces est√£o intimamente relacionadas. <br><br><h3>  Representa√ß√£o interna da interface </h3><br>  Russ Cox escreveu um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post</a> detalhado sobre como configurar uma interface no Go.  Nenhum artigo menos bom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√© sobre Habr'e</a> .  N√£o h√° necessidade de repetir toda a hist√≥ria, os principais pontos s√£o mencionados. <br><br>  Uma vari√°vel de tipo de interface cont√©m um par: o valor espec√≠fico atribu√≠do √† vari√°vel e um descritor de tipo para esse valor.  Mais precisamente, o valor √© o elemento de dados b√°sico que implementa a interface e o tipo descreve o tipo completo desse elemento.  Por exemplo, depois <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> cont√©m, esquematicamente, um par <code>(, ) --&gt; (tty, *os.File)</code> .  Observe que o tipo <code>*os.File</code> implementa m√©todos diferentes de <code>Read()</code> ;  mesmo que o valor da interface forne√ßa acesso apenas ao m√©todo Read (), o valor interno carregar√° todas as informa√ß√µes sobre o tipo desse valor.  √â por isso que podemos fazer essas coisas: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  A express√£o nesta atribui√ß√£o √© uma declara√ß√£o de tipo;  afirma que o elemento dentro de <code>r</code> tamb√©m implementa <code>io.Writer</code> e, portanto, podemos atribu√≠-lo a <code>w</code> .  Uma vez atribu√≠do, <code>w</code> conter√° um par <code>(tty, *os.File)</code> .  Este √© o mesmo par que em <code>r</code> .  O tipo est√°tico da interface determina quais m√©todos podem ser chamados na vari√°vel da interface, embora um conjunto mais amplo de m√©todos possa ter um valor espec√≠fico. <br><br>  Continuando, podemos fazer o seguinte: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  e o valor vazio do campo vazio conter√° novamente o mesmo par <code>(tty, *os.File)</code> .  Isso √© conveniente: uma interface vazia pode conter qualquer valor e todas as informa√ß√µes que precisaremos dela. <br><br>  N√£o precisamos de uma asser√ß√£o de tipo aqui, porque √© sabido que <code>w</code> satisfaz uma interface vazia.  No exemplo em que transferimos o valor do <code>Reader</code> para o <code>Writer</code> , precisamos usar explicitamente uma asser√ß√£o de tipo, porque <code>Writer</code> m√©todos <code>Writer</code> n√£o s√£o um subconjunto dos do <code>Reader</code> .  Tentar converter um valor que n√£o corresponda √† interface causar√° p√¢nico. <br><br>  Um detalhe importante √© que um par dentro de uma interface sempre tem um formul√°rio (valor, tipo espec√≠fico) e n√£o pode ter um formul√°rio (valor, interface).  As interfaces n√£o suportam interfaces como valores. <br><br>  Agora estamos prontos para estudar refletir. <br><br><h3>  A primeira lei da <s>reflex√£o</s> reflete </h3><br><ul><li>  A reflex√£o se estende da interface para a reflex√£o do objeto. </li></ul><br>  Em um n√≠vel b√°sico, refletir √© apenas um mecanismo para examinar um par de tipo e valor armazenado dentro de uma vari√°vel de interface.  Para come√ßar, existem dois tipos que precisamos conhecer: <code>reflect.Type</code> e <code>reflect.Value</code> .  Esses dois tipos fornecem acesso ao conte√∫do da vari√°vel de interface e s√£o retornados por fun√ß√µes simples, reflect.TypeOf () e reflect.ValueOf (), respectivamente.  Eles extraem partes do significado da interface.  (Al√©m disso, <code>reflect.Value</code> f√°cil de obter <code>reflect.Type</code> , mas n√£o vamos misturar os conceitos de <code>Value</code> e <code>Type</code> no momento.) <br><br>  Vamos come√ßar com <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  O programa produzir√° <br> <code>type: float64</code> <br> <br>  O programa √© semelhante a passar uma vari√°vel simples <code>float64 x</code> para <code>reflect.TypeOf()</code> .  Voc√™ v√™ a interface?  E √© - <code>reflect.TypeOf()</code> aceita uma interface vazia, de acordo com a declara√ß√£o da fun√ß√£o: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Quando chamamos <code>reflect.TypeOf(x)</code> , <code>x</code> armazenado primeiro em uma interface vazia, que √© passada como argumento;  <code>reflect.TypeOf()</code> descompacta essa interface vazia para restaurar informa√ß√µes de tipo. <br><br>  A fun√ß√£o <code>reflect.ValueOf()</code> , √© claro, restaura o valor (a seguir ignoraremos o modelo e focaremos no c√≥digo): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  ir√° imprimir <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Chamamos o m√©todo <code>String()</code> explicitamente porque, por padr√£o, o pacote fmt √© descompactado para <code>reflect.Value</code> e imprime um valor espec√≠fico.) <br>  Ambos <code>reflect.Type</code> e <code>reflect.Value</code> t√™m muitos m√©todos, o que permite explorar e modific√°-los.  Um exemplo importante √© que <code>reflect.Value</code> possui um m√©todo <code>Type()</code> que retorna o tipo de valor.  <code>reflect.Type</code> e <code>reflect.Value</code> t√™m um m√©todo <code>Kind()</code> que retorna uma constante indicando qual elemento primitivo est√° armazenado: <code>Uint, Float64, Slice</code> ... Essas constantes s√£o declaradas na enumera√ß√£o no pacote reflect.  M√©todos de <code>Value</code> com nomes como <code>Int()</code> e <code>Float()</code> nos permitem extrair valores (como int64 e float64) colocados dentro: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  ir√° imprimir <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Existem tamb√©m m√©todos como <code>SetInt()</code> e <code>SetFloat()</code> , mas para us√°-los, precisamos entender a configurabilidade, o t√≥pico da terceira lei da reflex√£o. <br><br>  A biblioteca de reflex√£o possui algumas propriedades que voc√™ precisa destacar.  Primeiro, para manter a API simples, os m√©todos <code>Value</code> "getter" e "setter" atuam no maior tipo que pode conter um valor: <code>int64</code> para todos os n√∫meros inteiros <code>int64</code> .  Ou seja, o m√©todo <code>Int()</code> do valor <code>Value</code> retorna <code>int64</code> e o valor <code>SetInt()</code> recebe <code>int64</code> ;  pode ser necess√°ria a convers√£o para o tipo real: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  ser√° <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Aqui <code>v.Uint()</code> retornar√° <code>uint64</code> , uma declara√ß√£o de tipo expl√≠cita √© necess√°ria. <br><br>  A segunda propriedade √© que o <code>Kind()</code> reflete o objeto descreve o tipo base, n√£o o tipo est√°tico.  Se o objeto de reflex√£o contiver um valor de um tipo inteiro definido pelo usu√°rio, como em <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , embora o tipo est√°tico de <code>x</code> seja <code>MyInt</code> , n√£o <code>int</code> .  Em outras palavras, <code>Kind()</code> n√£o pode distinguir <code>int</code> de <code>MyInt</code> , <code>MyInt</code> <code>Type()</code> .  <code>Kind</code> s√≥ pode aceitar valores de tipos internos. <br><br><h3>  A segunda lei da <s>reflex√£o</s> reflete </h3><br><ul><li>  A reflex√£o se estende do objeto de reflex√£o para a interface. </li></ul><br>  Como a reflex√£o f√≠sica, refletir em Go cria seu oposto. <br><br>  Tendo <code>reflect.Value</code> , podemos restaurar o valor da interface usando o m√©todo <code>Interface()</code> ;  O m√©todo empacota as informa√ß√µes de tipo e valor de volta na interface e retorna o resultado: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  Como exemplo: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  imprime o valor de <code>float64</code> representado pelo objeto de reflex√£o <code>v</code> . <br>  No entanto, podemos fazer ainda melhor.  Os argumentos em <code>fmt.Println()</code> e <code>fmt.Printf()</code> s√£o transmitidos como interfaces vazias, que s√£o descompactadas internamente pelo pacote fmt, como nos exemplos anteriores.  Portanto, tudo o que √© necess√°rio para imprimir o conte√∫do de <code>reflect.Value</code> corretamente √© passar o resultado do m√©todo <code>Interface()</code> para a fun√ß√£o de sa√≠da formatada: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (Por que n√£o <code>fmt.Println(v)</code> ? Como <code>v</code> √© do tipo <code>reflect.Value</code> ; queremos obter o valor contido <code>float64</code> .) Como nosso valor √© <code>float64</code> , podemos usar o formato de ponto flutuante, se desejar: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  produzir√° em um caso espec√≠fico <br> <code>3.4e+00</code> <br> <br>  Novamente, n√£o h√° necessidade de <code>v.Interface()</code> tipo de resultado <code>v.Interface()</code> em <code>float64</code> ;  um valor de interface vazio cont√©m informa√ß√µes sobre um valor espec√≠fico, e <code>fmt.Printf()</code> restaurar√°. <br>  Em resumo, o m√©todo <code>Interface()</code> √© o inverso da fun√ß√£o <code>ValueOf()</code> , exceto que seu resultado √© sempre da <code>interface{}</code> tipo est√°tico <code>interface{}</code> . <br><br>  Repita: a reflex√£o se estende dos valores da interface aos objetos de reflex√£o e vice-versa. <br><br><h3>  Terceira lei da <s>reflex√£o</s> reflex√£o </h3><br><ul><li>  Para alterar o objeto de reflex√£o, o valor deve ser configur√°vel. </li></ul><br>  A terceira lei √© a mais sutil e confusa.  Come√ßamos com os primeiros princ√≠pios. <br>  Este c√≥digo n√£o funciona, mas merece aten√ß√£o. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Se voc√™ executar esse c√≥digo, ele entrar√° em p√¢nico com uma mensagem cr√≠tica: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  O problema n√£o √© que o literal <code>7.1</code> n√£o <code>7.1</code> abordado;  √© isso que <code>v</code> n√£o <code>v</code> instal√°vel.  <code>reflect.Value</code> √© uma propriedade de <code>reflect.Value</code> , e nem todos os <code>reflect.Value</code> possuem. <br>  O m√©todo <code>reflect.Value.CanSet()</code> est√° sendo definido;  no nosso caso: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  ir√° imprimir: <br> <code>settability of v: false</code> <br> <br>  Ocorreu um erro ao chamar o m√©todo <code>Set()</code> em um valor n√£o gerenciado.  Mas o que √© instalabilidade? <br><br>  A sustentabilidade √© um pouco como endere√ßamento, mas mais rigorosa.  Esta √© uma propriedade em que o objeto de reflex√£o pode alterar o valor armazenado que foi usado para criar o objeto de reflex√£o.  A sustentabilidade √© determinada se o objeto de reflex√£o cont√©m o elemento de origem ou apenas uma c√≥pia dele.  Quando escrevemos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  passamos uma c√≥pia de <code>x</code> para <code>reflect.ValueOf()</code> , para que a interface seja criada como um argumento para <code>reflect.ValueOf()</code> - esta √© uma c√≥pia de <code>x</code> , n√£o <code>x</code> si.  Assim, se a afirma√ß√£o: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  se fosse executado, n√£o atualizaria <code>x</code> , embora <code>v</code> pare√ßa que ele foi criado a partir de <code>x</code> .  Em vez disso, ele atualizaria a c√≥pia de <code>x</code> armazenada dentro do valor de <code>v</code> ex n√£o seria afetado.  Isso √© proibido para n√£o causar problemas, e a instalabilidade √© uma propriedade usada para evitar um problema. <br><br>  Isso n√£o deve parecer estranho.  Esta √© uma situa√ß√£o comum em roupas incomuns.  Considere passar <code>x</code> para uma fun√ß√£o: <br> <code>f(x)</code> <br> <br>  N√£o esperamos que <code>f()</code> possa alterar <code>x</code> , porque passamos uma c√≥pia do valor de <code>x</code> , e n√£o <code>x</code> si.  Se queremos que <code>f()</code> mude diretamente <code>x</code> , devemos passar um ponteiro para <code>x</code> para nossa fun√ß√£o: <br> <code>f(&amp;x)</code> <br> <br>  Isso √© direto e familiar, e a reflex√£o funciona da mesma forma.  Se queremos alterar <code>x</code> usando reflex√£o, devemos fornecer √† biblioteca de reflex√£o um ponteiro para o valor que queremos alterar. <br><br>  Vamos fazer isso.  Primeiro, inicializamos <code>x</code> como de costume e depois criamos um <code>reflect.Value p</code> que aponta para ele. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  ir√° produzir <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  O objeto Reflection <code>p</code> n√£o pode ser definido, mas n√£o √© o <code>p</code> que queremos definir, √© o ponteiro <code>*p</code> .  Para obter o que <code>p</code> aponta, chamamos o m√©todo <code>Value.Elem()</code> , que leva o valor indiretamente pelo ponteiro e armazena o resultado em <code>reflect.Value v</code> : <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Agora <code>v</code> √© um objeto instal√°vel; <br> <code>settability of v: true</code> <br>  e como representa <code>x</code> , podemos finalmente usar <code>v.SetFloat()</code> para alterar o valor de <code>x</code> : <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  conclus√£o como esperado <br> <code>7.1 <br> 7.1</code> <br>  Refletir pode ser dif√≠cil de entender, mas faz exatamente o que a linguagem faz, embora com a ajuda de <code>reflection.Value</code> . <code>reflect.Type</code> e <code>reflection.Value</code> , que pode ocultar o que est√° acontecendo.  Lembre-se de que o <code>reflection.Value</code> precisa do endere√ßo de uma vari√°vel para alter√°-lo. <br><br><h3>  Estruturas </h3><br>  No nosso exemplo anterior, <code>v</code> n√£o <code>v</code> um ponteiro, apenas derivava dele.  Uma maneira comum de criar essa situa√ß√£o √© usar a reflex√£o para alterar os campos da estrutura.  Enquanto tivermos o endere√ßo da estrutura, podemos alterar seus campos. <br><br>  Aqui est√° um exemplo simples que analisa o valor da estrutura <code>t</code> .  Criamos um objeto de reflex√£o com o endere√ßo da estrutura para modific√°-lo posteriormente.  Em seguida, defina typeOfT para seu tipo e itere sobre os campos usando chamadas de m√©todo simples (consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote para obter uma descri√ß√£o detalhada</a> ).  Observe que estamos extraindo nomes de campos do tipo de estrutura, mas os pr√≥prios campos s√£o regulares <code>reflect.Value</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  O programa produzir√° <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Mais um ponto sobre a instalabilidade √© mostrado aqui: os nomes dos campos <code>T</code> em mai√∫sculas (exportados), porque apenas os campos exportados s√£o configur√°veis. <br>  Como <code>s</code> cont√©m um objeto de reflex√£o instal√°vel, podemos alterar o campo da estrutura. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  Resultado: <br> <code>t is now {77 Sunset Strip}</code> <br>  Se mudarmos o programa para que <code>s</code> criado de <code>t</code> vez de <code>&amp;t</code> , as chamadas para <code>SetInt()</code> e <code>SetString()</code> terminariam em p√¢nico, uma vez que os campos <code>t</code> n√£o seriam configur√°veis. <br><br><h3>  Conclus√£o </h3><br>  Lembre-se das leis da reflex√£o: <br><br><ul><li>  A reflex√£o se estende da interface para a reflex√£o do objeto. </li><li>  A reflex√£o se estende da reflex√£o de um objeto √† interface. </li><li>  Para alterar o objeto de reflex√£o, o valor deve ser definido. </li></ul><br>  Postado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415171/">https://habr.com/ru/post/pt415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415159/index.html">An√∫ncio da DevOps-conference DevOops 2018</a></li>
<li><a href="../pt415163/index.html">Rede sem fio em uma f√°brica farmac√™utica especialmente protegida e protegida em alguns lugares na R√∫ssia</a></li>
<li><a href="../pt415165/index.html">Vers√£o do Node.js. 10.5: multithreading out of the box</a></li>
<li><a href="../pt415167/index.html">Li√ß√£o aberta ‚ÄúMultithreading em Java. Primitivas b√°sicas de sincroniza√ß√£o ¬ª</a></li>
<li><a href="../pt415169/index.html">Compacta√ß√£o e desduplica√ß√£o: reduza o tamanho do arquivo morto e backup usando o inverno ZxPowerstore</a></li>
<li><a href="../pt415175/index.html">Entrevista com o membro da Augmented World Expo</a></li>
<li><a href="../pt415177/index.html">Bem-vindo</a></li>
<li><a href="../pt415181/index.html">[Yekaterinburg, an√∫ncio] Mitap de analistas - sobre os primeiros analistas e o CBAP, sobre m√©tricas, sobre o setor p√∫blico e tipos de analistas</a></li>
<li><a href="../pt415183/index.html">Extens√£o da Web entre navegadores para scripts personalizados Parte 1</a></li>
<li><a href="../pt415185/index.html">3CX WebMeeting - Videoconfer√™ncia Gratuita: Vis√£o Geral dos Recursos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>