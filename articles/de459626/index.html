<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕙 👩‍💻 👨🏾‍🤝‍👨🏻 Windows Notification Facility: Die am wenigsten dokumentierte Angriffsfläche 👃🏻 👩🏾‍🔧 🏩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter dem Schnitt befindet sich eine Übersetzung der Präsentation "Die Windows-Benachrichtigungsfunktion: Die bisher undokumentierteste Kernel-Angriff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: Die am wenigsten dokumentierte Angriffsfläche</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Unter dem Schnitt befindet sich eine Übersetzung der <strong>Präsentation</strong> "Die Windows-Benachrichtigungsfunktion: Die bisher undokumentierteste Kernel-Angriffsfläche", die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alex Ionescu</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabrielle Viala</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der BlackHat 2018-Konferenz vorgestellt haben</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Was wird in der Veröffentlichung diskutiert</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die Windows Notification Facility (WNF)?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum WNF erschien</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statusnamen WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufrufe für die Arbeit mit WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">High Level User Mode API (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">High Level Kernel Level API (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WNF-Analyse-Dienstprogramme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WNF-Angriffsfläche</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interessante und sensible WNF-Staatsnamen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessinjektion mit WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen für die weitere Forschung</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  Was ist die Windows Notification Facility (WNF)? </h3><br><p>  Die Windows-Benachrichtigungsfunktion ist ein Benachrichtigungsmechanismus (sowohl im Kernel als auch im Benutzermodus verfügbar), der auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Publisher-Subscriber-</a> Modell ( <em>pubsub</em> , Publisher / Subscriber) <em>basiert</em> .  Der Mechanismus wurde in Windows 8 hinzugefügt: teilweise, um einige langjährige Designbeschränkungen im Betriebssystem zu lösen, aber auch, um als Grundlage für die Implementierung von Push-Benachrichtigungen zu dienen, die iOS / Android ähneln. </p><br><p>  Das Hauptmerkmal ist, dass es sich um ein <em>blindes</em> Modell (meistens ohne Registrierung) handelt, das ein ungeordnetes Abonnement und eine ungeordnete Veröffentlichung ermöglicht.  Dies bedeutet, dass ein Verbraucher eine Benachrichtigung abonnieren kann, noch bevor die Benachrichtigung von seiner Quelle veröffentlicht wurde.  Und dass derjenige, der die Ereignisse generiert, nicht verpflichtet ist, die Benachrichtigung im Voraus zu "registrieren". </p><br><p>  Darüber hinaus unterstützt der Mechanismus: </p><br><ul><li>  dauerhafte und vorübergehende Benachrichtigungen </li><li>  monoton zunehmende eindeutige Kennungen </li><li>  Nutzlastpuffer (bis zu 4 Kilobyte) für jedes Ereignis </li><li>  Thread-Pool-Benachrichtigungsmodell mit gruppenbasierter Serialisierung </li><li>  Ein <abbr title="Liste der Systemzugriffskontrollen">bereichsbereichsbasiertes</abbr> Sicherheitsmodell, das Sicherheitsbeschreibungen über den Standard- <abbr title="Liste der diskretionären Zugriffskontrollen">DACL</abbr> / <abbr title="Liste der Systemzugriffskontrollen">SACL-</abbr> Mechanismus <abbr title="Liste der Systemzugriffskontrollen">implementiert</abbr> </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  Warum WNF erschien </h3><br><p>  Stellen Sie sich ein kanonisches Beispiel vor: Es gibt einen Treiber, der wissen möchte, dass ein Volume mit Lese- und Schreibzugriff verbunden wurde.  Um Sie darüber zu informieren, meldet Autochk (ein Analogon von <abbr title="Konsistenzprüfung des Dateisystems">fsck</abbr> unter Windows) ein Ereignis namens VolumesSafeForWriteAccess.  Um ein Ereignis zu melden, müssen Sie jedoch zuerst das Ereignisobjekt selbst erstellen. </p><br><p>  Wir müssen auch wissen, dass Autochk bereits an der Lautstärke arbeitet, aber das Ereignis, auf das wir warten, noch nicht signalisiert hat.  Schlechte Lösung: Setzen Sie sich mit sleep () in eine Schleife, prüfen Sie, ob ein Ereignis vorhanden ist, und warten Sie, wenn das Ereignis erstellt wird. </p><br><p>  Nach dem Beenden der Windows-Anwendung werden jedoch alle Deskriptoren geschlossen.  Und wenn das Objekt keine Deskriptoren hat, wird es zerstört.  Wer wird diese Veranstaltung abhalten? </p><br><p>  Ohne WNF besteht die Lösung darin, dass der Betriebssystemkern ein Ereignis generiert, bevor Treiber geladen werden, und dass Autochk es wie ein Verbraucher öffnet, aber anstatt zu warten, sollte es dieses Ereignis signalisieren. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Statusnamen WNF </h3><br><p>  In der WNF-Welt ist ein Statusname eine 64-Bit-Nummer.  Aber es gibt einen Trick - tatsächlich ist es eine codierte Struktur.  Der Statusname hat eine <em>Version</em> , <em>eine Lebensdauer</em> , einen <em>Bereich</em> , ein <em>Datenpersistenzflag</em> und eine <em>eindeutige Seriennummer</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Diese Daten sind jedoch nur verfügbar, wenn wir eine 64-Bit-Zahl mit einer magischen Konstante pro-XOR verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Lebensdauer des Statusnamens </h4><br><p>  Der WNF-Statusname kann sein (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bekannt </li><li>  permanent </li><li>  hartnäckig </li><li>  vorübergehend </li></ul><br><p>  Die ersten drei sind den entsprechenden Schlüsseln in der Registrierung zugeordnet, in denen Statusinformationen gespeichert werden: </p><br><ul><li>  Bekannte Namen befinden sich in HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notifications </li><li>  Persistente Namen befinden sich in HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notifications </li><li>  Persistente Namen befinden sich in HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Bekannte Namen haben ihre eigene Besonderheit: Sie können nicht registriert werden.  Ein solcher Name sollte bereits zum Zeitpunkt des Systemstarts in der Registrierung vorhanden sein.  Persistente und persistente Namen erfordern das enthaltene SeCreatePermanentPrivilege-Privileg (wie andere globale Objekte), um sie zu erstellen.  Persistente Namen befinden sich außerhalb des Registrierungsprozesses, während persistente Namen einen Systemneustart überleben. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Datenumfang </h4><br><p>  Der Datenbereich definiert die erste Sicherheitsgrenze um den WNF-Statusnamen und bestimmt, wer ihn sieht und Zugriff darauf hat.  Der Gültigkeitsbereich des Statusnamens kann sein: </p><br><ul><li>  das System </li><li>  Auto </li><li>  Benutzersitzung </li><li>  der Benutzer </li><li>  der Prozess </li></ul><br><p>  Zusätzlich zur Bereitstellung von Sicherheitsgrenzen können WNF-Bereiche verwendet werden, um verschiedene Dateninstanzen für denselben Namen bereitzustellen.  Der Kernel umgeht (wie bei anderen Sicherheitsmechanismen) die Statuszugriffsprüfungen.  Das TCB-Privileg ermöglicht den bereichsübergreifenden Zugriff auf WNF-Statusnamen. </p><br><p>  Der Bereich "System" und der Bereich "Maschine" sind globale Bereiche.  Sie haben keine eigenen Bezeichner (sie verwenden unterschiedliche globale Container).  Der Bereich der Benutzersitzung verwendet die Sitzungskennung (Sitzungs-ID) als ID.  Der Bereich eines bestimmten Benutzers verwendet die SID dieses Benutzers als Kennung.  Die Adresse des EPROCESS-Objekts ist die Kennung des Prozessbereichs. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  Sequenznummern </h4><br><p>  Um die Eindeutigkeit sicherzustellen, hat jeder Statusname eine eindeutige 51-Bit-Sequenznummer.  Bekannte Namen enthalten ein 4-stelliges Familien-Tag in ihrer Seriennummer, und die verbleibenden 21 Bits werden als eindeutige Kennung verwendet.  Permanente Namen speichern ihre inkrementelle Nummer mit dem Registrierungswert "SequenceNumber".  Persistente und temporäre Namen verwenden einen gemeinsamen Inkrementierungszähler, der sich in einer globalen Variablen befindet.  Diese Daten werden für jeden Container (pro Silo) separat gespeichert und verarbeitet und sind in PspHostSiloGlobals-&gt; WnfSiloState verfügbar. </p><br><p>  In Microsoft hat jeder WNF-Name eine "freundliche" Kennung, die im Code verwendet wird. Manchmal wird er im globalen Namespace mit demselben Namen gespeichert.  Zum Beispiel das Symbol nt! WNF_BOOT_DIRTY_SHUTDOWN, das den Wert 0x1589012fa3bc0875 hat.  Nach XOR mit der magischen Konstante <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY erhalten</abbr> wir den Wert 0x544f4f4200000801, der bitweise interpretiert werden kann als: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Systemaufrufe für die Arbeit mit WNF </h3><br><p>  Mit Kernel-Systemaufrufen können Sie WNF-Statusnamen registrieren und löschen, WNF-Statusnamendaten veröffentlichen und empfangen sowie verschiedene Benachrichtigungen von WNF erhalten. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Registrieren Sie den WNF-Statusnamen </h4><br><p>  Mit Ausnahme bekannter Namen (wie bereits erwähnt) kann der WNF-Statusname registriert werden, während das Betriebssystem ausgeführt wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Es gibt einen symmetrischen Systemaufruf ZwDeleteWnfStateName, mit dem Sie den registrierten Statusnamen löschen können (außer bei bekannten). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Veröffentlichen Sie WNF-Statusdaten </h4><br><p>  Zum Festlegen oder Ändern der WNF-Statusnamensdaten können Sie den Systemaufruf ZwUpdateWnfStateData verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Es gibt einen symmetrischen Systemaufruf ZwDeleteWnfStateData, um die Daten des WNF-Statusnamens zu löschen (zu bereinigen). </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Abrufen von WNF-Statusdaten </h4><br><p>  Um die WNF-Statusnamensdaten anzufordern, kann der folgende Systemaufruf verwendet werden (die meisten Parameter ähneln der Update-Funktion): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  Die wahre Stärke liegt in der Tatsache, dass für die API-Funktionen Update und Query kein <u>registrierter</u> WNF-Statusname erforderlich ist.  Und wenn der Name nicht temporär ist (und der aufrufende Code über ausreichende Berechtigungen verfügt), kann eine Instanz des Namens in Echtzeit registriert werden! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  WNF-Benachrichtigungen </h4><br><p>  Bisher haben wir angenommen, dass der Verbraucher weiß, wann er die Datenerfassungsfunktion aufrufen muss.  Es gibt aber auch eine <em>Blockierung des Lesens</em> , die mit einem Benachrichtigungssystem funktioniert (das dem tatsächlichen Publisher-Subscriber-Modell näher kommt). </p><br><p>  Zunächst muss der Prozess das Ereignis durch Aufrufen der Funktion ZwSetWnfProcessNotificationEvent registrieren.  Anschließend müssen Sie die Funktion ZwSubscribeWnfStateChange aufrufen und eine Ereignismaske angeben, um die Abonnement-ID für die Ausgabe abzurufen.  Es gibt zwei Arten von Ereignissen: </p><br><ul><li>  Datenbenachrichtigungen: <br><ul><li>  0x01 - Datenauftritt </li><li>  0x10 - Namenszerstörung </li></ul></li><li>  Meta-Metanotifikationen <br><ul><li>  0x02 - Erscheinen eines Teilnehmers, der Datenbenachrichtigungen erhält (Datenabonnent) </li><li>  0x04 - Erscheinen eines Abonnenten, der Meta-Benachrichtigungen erhält (Meta-Abonnent) </li><li>  0x08 - das Erscheinen eines Abonnenten, der Datenbenachrichtigungen und Meta-Benachrichtigungen erhält (generischer Abonnent) </li></ul></li></ul><br><p>  Dann müssen Sie auf das aufgezeichnete Ereignis warten.  Und jedes Mal, wenn das Ereignis zu einem Signal wird, müssen Sie die Funktion ZwGetCompleteWnfStateSubscription aufrufen, die WNF_DELIVERY_DESCRIPTOR zurückgibt. </p><br><p>  Diese Low-Level-API-Funktionen haben jedoch ein Problem (danke an Gabi für die Untersuchung): Jeder Prozess kann nur ein registriertes Ereignis haben. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  High Level User Mode API (ntdll) </h3><br><p>  Wenn es um Benachrichtigungen geht, werden die Dinge kompliziert, sodass die RTL-Ebene von ntdll.dll eine einfachere Oberfläche bietet: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  Tatsächlich müssen Systemdienste nicht direkt aufgerufen werden: Verwenden Sie einfach eine einzelne Ereigniswarteschlange, die von ntdll.dll gesteuert wird. </p><br><p>  Hinter den Kulissen wird der Inhalt von WNF_DELIVERY_DESCRIPTOR in Rückrufparameter konvertiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Für jedes neue Abonnement wird ein Eintrag vorgenommen, der in die Liste aufgenommen wird, auf die die globale Variable RtlpWnfProcessSubscriptions verweist.  Die Liste basiert auf einem der Felder WNF_NAME_SUBSCRIPTION vom Typ LIST_ENTRY.  Jedes von WNF_NAME_SUBSCRIPTION verfügt wiederum über ein anderes LIST_ENTRY-Feld zum Organisieren einer Liste von WNF_USER_SUBSCRIPTION mit einem Rückruf und Kontext. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  High Level Kernel Level API (Ex) </h3><br><p>  WNF bietet auch nahezu identische Funktionen für den Kernelmodus-Code (der vom Treiber verwendet werden kann): sowohl durch exportierte Systemaufrufe als auch über API-Funktionen auf hoher Ebene zur Laufzeit (Ex-Layer). </p><br><p>  Die ExSubscribeWnfStateChange-Funktion akzeptiert den Statusnamen, Typmasken und die Adresse der Rückruffunktion + Kontext als Eingabe und gibt einen Abonnementdeskriptor zurück.  Die Rückruffunktionen erhalten den Zielnamen, die Ereignismaske, die Änderungsbezeichnung, jedoch nicht den Puffer oder dessen Größe. </p><br><p>  Die ExQueryWnfStateData-Funktion liest basierend auf dem übergebenen Abonnementdeskriptor die aktuellen Statusdaten.  Tatsächlich ruft jeder Rückruf die ExQueryWnfStateData-Funktion auf, um die mit der Benachrichtigung verknüpften Daten abzurufen. </p><br><p>  Sowohl für Kernelmodus-Abonnements als auch für Benutzermodus-Abonnements erstellt WNF (zum Verfolgen von Abonnements) eine Instanz der Struktur WNF_SUBSCRIPTION.  Im Benutzermodus werden jedoch einige Felder nicht ausgefüllt, z. B. Rückruf und Kontext, da im Benutzermodus die Adressen der Handler von ntdll.dll gespeichert und verarbeitet werden. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  WNF-Datenstrukturen </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>Von einem Übersetzer</em></u> : siehe nächster Abschnitt. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  WNF-Analyse-Dienstprogramme </h3><br><p>  <u><em>Von einem Übersetzer</em></u> : An dieser Stelle sei noch einmal daran erinnert, dass die Präsentation nicht nur von Alex, sondern auch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabrielle Viala durchgeführt wurde</a> .  Insbesondere gehört seine Urheberschaft zum unten beschriebenen WnfCom-Modul.  Darüber hinaus hat Gabrielle die internen Strukturen von WNF ausreichend detailliert beschrieben (siehe Abbildung im vorherigen Abschnitt).  Die meisten Folien fehlen leider im PDF der Präsentation (als Original angegeben) oder sind ausschließlich durch Überschriften gekennzeichnet.  Aber: </p><br><ul><li>  Dies ist eine hervorragende Gelegenheit, um eine Aufzeichnung ihrer gemeinsamen Leistung anzusehen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows-Benachrichtigungsfunktion: Schälen der Zwiebel der bislang undokumentiertesten Kernel-Angriffsfläche</a> (Beginn von Gabrielle ~ 19: 27).  Dort (neben Datenstrukturen) wird es eine Geschichte darüber geben, wie sie die Debugger-Erweiterung behoben haben! Wnf (Spoiler - unter Verwendung der in NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beheben defekter Debugger-Erweiterungen</a> beschriebenen Methode) </li><li>  Gabrielle hat einen separaten guten Artikel (detailliert, nicht als Präsentation) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielen mit der Windows Notification Facility (WNF)</a> , der auch allen Interessierten zum Lesen empfohlen wird. </li></ul><br><p>  <u><em>Und vom Übersetzer</em></u> : Wenn jemand die aktuelle Übersetzung durch den Inhalt von Gabrielle-Folien ergänzen oder die Übersetzung des wörtlichen Transkripts aus einem beliebigen Teil des Videos der Rede erweitern möchte - willkommen.  Um das Hinzufügen / Ändern großer Blöcke zu vereinfachen, kann ich die Übersetzungsquelle auf github (oder einem anderen Versionskontrollserver) veröffentlichen. </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom ist ein Python-Modul ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Quellcode</a> ), das Interoperabilität über WNF zeigt.  Hauptmerkmale: </p><br><ul><li>  Ermöglicht das Lesen / Schreiben von Daten aus vorhandenen Instanzinstanzen </li><li>  ermöglicht es Ihnen, temporäre Statusnamen zu erstellen (als <em>Server</em> ) </li><li>  Mit dieser <em>Option</em> können Sie eine Instanz eines <em>clientseitigen</em> Objekts <em>abrufen</em> , die Benachrichtigungen zum Ändern einer bestimmten Instanz eines Namens verarbeitet </li></ul><br><p>  Anwendungsbeispiel: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump ist ein in C geschriebenes Befehlszeilenprogramm. Die ausführbare Datei finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ionescu007/wnfun,</a> indem Sie das Unterverzeichnis der erforderlichen Bittiefe auswählen.  Das Dienstprogramm kann verwendet werden, um nach Informationen zu WNF-Statusnamen zu suchen: </p><br><ul><li>  -d ( <u>D</u> ump) Gibt alle WNF-Statusnamen mithilfe einer registrierungsbasierten Aufzählung aus.  Es kann mit folgenden Optionen ergänzt werden: <br><ul><li>  -v ( <u>V</u> erbose) Eine ausführliche Ausgabe, die einen hexadezimalen Speicherauszug von WNF-Statusdaten enthält. </li><li>  -s (Sicherheit) Sicherheitsbeschreibungen - SDDL-Berechtigungszeichenfolgen für den WNF-Statusnamen. </li></ul></li><li>  -b ( <u>B</u> rute-force) Direkte Aufzählung temporärer WNF-Statusnamen (mehr dazu weiter unten) </li><li>  -i (Informationen) Zeigt Informationen zu einem einzelnen angegebenen WNF-Statusnamen an </li><li>  -r (Lesen) Liest Daten aus dem angegebenen WNF-Statusnamen </li><li>  -w (Schreiben) Schreiben Sie Daten in den angegebenen WNF-Statusnamen </li><li>  -n (Benachrichtigung) Registrieren Sie einen Benachrichtigungsteilnehmer für den angegebenen WNF-Statusnamen (im Folgenden wird ein spezifischerer Anwendungsfall mit Edge beschrieben). </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  WNF-Angriffsfläche </h3><br><p>  In diesem Abschnitt (genauer gesagt in seinen Unterabschnitten) werden mögliche Angriffe und interessante sensible WNF-Daten erörtert. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Privilegierte Datenoffenlegung </h4><br><p>  Beim Lesen der Tausenden von WNF-Statusnamen, die im System vorhanden sind, können mehrere festgestellt werden, deren Daten sehr interessant aussehen.  Unter ihnen waren einige, deren Daten Zeigern oder anderen privilegierten Daten verdächtig ähnlich sind. </p><br><p>  Nach dem Spielen auf mehreren Computern war es in einigen Fällen möglich, eine Reihe, einen Stapel und andere privilegierte Informationen zu finden, die über Berechtigungsgrenzen hinweg offengelegt wurden.  Fehler- / Schwachstellenberichte wurden im Juli an MSRC übermittelt, aber im November (nach der Präsentation) korrigiert.  Zum Beispiel: 4 Kilobyte Stapel sind durch das WNF_AUDC * -Ereignis durchgesickert! </p><br><p>  Die Hauptprobleme sind die gleichen wie in früheren Studien von j00ro, taviso und anderen.  Bestimmte WNF-Statusnamen enthalten codierte Datenstrukturen mit verschiedenen Auffüll- und / oder Ausrichtungsproblemen.  In einigen Fällen tritt nicht initialisierter Speicher aus. <br>  <u><em>Vom Übersetzer</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung des einleitenden Teils des Dokuments Erkennen der Offenlegung des Kernelspeichers mit x86-Emulation und Taint-Tracking von Mateusz Jurczyk aka j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Ermittlung von Statusnamen und Berechtigungen </h4><br><p>  Der erste Ansatz bestand darin, alle möglichen Statusnamen zu ermitteln, die böswillig manipuliert werden konnten.  Bei bekannten, dauerhaften und dauerhaften Namen ist die Aufzählung durch Aufzählung von Registrierungsschlüsseln möglich.  Dann können die gefundenen Werte mit benutzerfreundlichen Bezeichnern verglichen werden (es gibt mehrere Stellen, an denen Sie sie finden können :)) </p><br><p>  Dann können wir uns auch den Sicherheitsdeskriptor in der Registrierung ansehen (dies ist das erste, was sich im Datenpuffer befindet).  Die Sicherheitsbeschreibung ist nicht kanonisch: Sie hat keinen Eigentümer und keine Gruppe, ist also technisch nicht gültig.  Es ist jedoch kein Problem, einen falschen Eigentümer und eine falsche Gruppe zu ersetzen, <em>um</em> den Sicherheitsdeskriptor zu <em>reparieren</em> . </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Erkennung von temporären Statusnamen und deren Berechtigungen </h4><br><p>  Bei temporären Namen funktionieren die oben beschriebenen Tricks jedoch nicht: Sie befinden sich nicht in der Registrierung.  Und nur der Kernel speichert Datenstrukturen für sie (! Wnf) im Speicher.  Aber temporäre Namen sind eigentlich gar nicht so schwer zu erzwingen: </p><br><ul><li>  Version ist immer wichtig 1 </li><li>  Die Lebensdauer ist immer wichtig WnfTemporaryStateName </li><li>  Das permanente Flag wird immer gelöscht (der Name des temporären Status kann keine permanenten Daten enthalten). </li><li>  Bereich (Bereich) kann einen von 4 Werten annehmen </li></ul><br><p>  Ja, aber die verbleibende Sequenznummer beträgt 51 Bit!  In der Tat ... aber vergessen Sie nicht, dass die Seriennummern monoton wachsen.  Bei temporären Namen wird die Sequenz bei jedem Start auf 0 zurückgesetzt.  Herkömmlicherweise können Sie ein Fenster mit einer Million Seriennummern erstellen: Überprüfen Sie in einer Schleife die Existenz jedes Namens (beginnend mit 0), indem Sie ZwQueryWnfStateNameInformation mit der angeforderten Informationsklasse WnfInfoStateNameExist aufrufen (vorausgesetzt, der Zugriffsfehler zeigt auch das Vorhandensein eines Namens an).  Wenn keine weiteren Millionen Namen vorhanden sind, können Sie die Suche beenden. </p><br><p>  Temporäre Namenssicherheitsbeschreibungen (wie andere temporäre Namensdaten) werden im Kernel gespeichert.  Daher ist die einzige Möglichkeit, sie anzufordern, die Erweiterung! Wnf beim Debuggen des Kernelmodus.  Aber wir können: </p><br><ul><li>  Machen Sie eine Schlussfolgerung zu den Leseberechtigungen, wenn Sie versuchen, Daten zu lesen. </li><li>  Um zu schließen, dass die Aufzeichnung durch den Versuch, Daten zu schreiben, erlaubt ist.  Es ist jedoch zu bedenken, dass ein erfolgreiches Schreiben von nur 0 Bytes die Daten zerstört, die der echte Verbraucher noch nicht erhalten hat.  Und wieder gibt es einen Trick: Wir können den entsprechenden Änderungsstempel anwenden.  Wir versuchen, mit dem Label 0xFFFFFFFF zu schreiben: Das Label wird nach der Zugriffsprüfung überprüft, daher führt der Fehlerwert zu einem Verlust der Schreibberechtigung. </li></ul><br><p>  Dies gibt uns keine vollständige Sicherheitsbeschreibung, aber wenn wir den Code mit unterschiedlichen Berechtigungen ausführen, können wir uns ein Bild von den Einschränkungen für verschiedene Systemkonten machen (Low IL / User / Admin / SYSTEM). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Abonnenten auflisten </h4><br><p>  In der Struktur WNF_PROCESS_CONTEXT ist eines der Felder der Listenkopf (LIST_ENTRY) aller Abonnements dieses Prozesses.  Jedes Abonnement ist eine separate Instanz von WNF_SUBSCRIPTION. </p><br><p>  Abonnenten im Kernel-Modus gehören in erster Linie dem Systemprozess.  Mit dem Befehl! List debugger können Sie Handler und ihre Parameter ausgeben, die im Systemprozess WNF_SUBSCRIPTION registriert sind.  Es ist erwähnenswert, dass in einigen Fällen ein Ereignisaggregator (CEA.SYS) verwendet wird, der die tatsächlichen Rückrufadressen in seiner Kontextstruktur verbirgt. </p><br><p>  Wir können diesen Ansatz für Prozesse im Benutzermodus wiederholen, aber die Rückrufadresse ist NULL, da dies Abonnenten im Benutzermodus sind.  Daher müssen wir dem Benutzerbereich des Prozesses beitreten, die Tabelle RtlpWnfProcessSubscriptions abrufen und dann die Liste der WNF_USER_SUBSCRIPTION-Instanzen sichern, von denen jede bereits die Rückrufadresse enthält.  Leider ist dieses Zeichen statisch, was bedeutet, dass es sich nicht um offene Zeichen handelt, sondern durch Zerlegen gefunden werden kann.  Auch hier lohnt es sich (analog zum CEA.SYS-Kernelmodus) darauf zu achten, dass viele der Benutzermodus-Handler den Ereignisaggregator (EventAggregation.dll) verwenden, der den Rückruf in seinem Kontext speichert. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Interessante und sensible WNF-Staatsnamen </h3><br><p>  Dieser Abschnitt enthält einige interessante Beispiele dafür, wie einige WNF-Statusnamen Systeminformationen anzeigen. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Ermitteln des Systemstatus und des Benutzerverhaltens mithilfe von WNF </h4><br><p>  Einige WNF-Kennungen können verwendet werden, um Informationen über den Status der Maschine abzurufen, die Sie interessiert: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Drahtloser Status </li><li>  WNF_BLTH_BLUETOOTH_STATUS - ähnlich, aber für Bluetooth (auch WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE - Zeigt die Stromquelle (Batterie oder Netzteil) an. </li><li>  WNF_SEB_BATTERY_LEVEL - enthält den Batteriestand </li><li>  WNF_CELL_ * - unter Windows Phone enthält Informationen über: Netzwerk, Nummer, Signalstärke, EDGE oder 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER —   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT —    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED —    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      —       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE —     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST —   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK — ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND –   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory —    </li><li>   ( ) —               </li><li>   (Atom) —            </li><li>    —  ,   WM_COPYDATA  DDE,       </li><li> GUI  —    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Asynchronous Procedure Call">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " —  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Control Flow Guard">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> github</a> )   explorer (  —  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li>     WNF_USER_SUBSCRIPTION     </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459626/">https://habr.com/ru/post/de459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459616/index.html">MIPT eröffnet Russlands ersten fortgeschrittenen Masterstudiengang in Informatik und Softwaretechnik</a></li>
<li><a href="../de459618/index.html">Einige wenig bekannte Docker-Compose-Funktionen</a></li>
<li><a href="../de459620/index.html">TDDx2, BDD, DDD, FDD, MDD und PDD oder was auch immer Sie über Driven Development wissen möchten</a></li>
<li><a href="../de459622/index.html">Als die Spiele für Sega Saturn wurden 1995 geschrieben</a></li>
<li><a href="../de459624/index.html">Militärische Drohnen</a></li>
<li><a href="../de459628/index.html">Das Open Invention Network hat mehr als dreitausend Lizenznehmer - was bedeutet das für Open Source-Software?</a></li>
<li><a href="../de459630/index.html">Tic Tac Toe Teil 2: Staatenloses Rückgängigmachen / Wiederherstellen</a></li>
<li><a href="../de459638/index.html">Schaffung einer globalen Wissensbasis über Batterien</a></li>
<li><a href="../de459640/index.html">Dokumente als Code. Teil 1: Automatisieren Sie das Update</a></li>
<li><a href="../de459642/index.html">Sicherer Zugriff auf Registerfelder in C ++ ohne Einbußen bei der Effizienz (am Beispiel von CortexM)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>