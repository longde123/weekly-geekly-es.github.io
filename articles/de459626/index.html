<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïô üë©‚Äçüíª üë®üèæ‚Äçü§ù‚Äçüë®üèª Windows Notification Facility: Die am wenigsten dokumentierte Angriffsfl√§che üëÉüèª üë©üèæ‚Äçüîß üè©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter dem Schnitt befindet sich eine √úbersetzung der Pr√§sentation "Die Windows-Benachrichtigungsfunktion: Die bisher undokumentierteste Kernel-Angriff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: Die am wenigsten dokumentierte Angriffsfl√§che</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Unter dem Schnitt befindet sich eine √úbersetzung der <strong>Pr√§sentation</strong> "Die Windows-Benachrichtigungsfunktion: Die bisher undokumentierteste Kernel-Angriffsfl√§che", die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alex Ionescu</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabrielle Viala</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der BlackHat 2018-Konferenz vorgestellt haben</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">Was wird in der Ver√∂ffentlichung diskutiert</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die Windows Notification Facility (WNF)?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum WNF erschien</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statusnamen WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufrufe f√ºr die Arbeit mit WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">High Level User Mode API (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">High Level Kernel Level API (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WNF-Analyse-Dienstprogramme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WNF-Angriffsfl√§che</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interessante und sensible WNF-Staatsnamen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessinjektion mit WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen f√ºr die weitere Forschung</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  Was ist die Windows Notification Facility (WNF)? </h3><br><p>  Die Windows-Benachrichtigungsfunktion ist ein Benachrichtigungsmechanismus (sowohl im Kernel als auch im Benutzermodus verf√ºgbar), der auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Publisher-Subscriber-</a> Modell ( <em>pubsub</em> , Publisher / Subscriber) <em>basiert</em> .  Der Mechanismus wurde in Windows 8 hinzugef√ºgt: teilweise, um einige langj√§hrige Designbeschr√§nkungen im Betriebssystem zu l√∂sen, aber auch, um als Grundlage f√ºr die Implementierung von Push-Benachrichtigungen zu dienen, die iOS / Android √§hneln. </p><br><p>  Das Hauptmerkmal ist, dass es sich um ein <em>blindes</em> Modell (meistens ohne Registrierung) handelt, das ein ungeordnetes Abonnement und eine ungeordnete Ver√∂ffentlichung erm√∂glicht.  Dies bedeutet, dass ein Verbraucher eine Benachrichtigung abonnieren kann, noch bevor die Benachrichtigung von seiner Quelle ver√∂ffentlicht wurde.  Und dass derjenige, der die Ereignisse generiert, nicht verpflichtet ist, die Benachrichtigung im Voraus zu "registrieren". </p><br><p>  Dar√ºber hinaus unterst√ºtzt der Mechanismus: </p><br><ul><li>  dauerhafte und vor√ºbergehende Benachrichtigungen </li><li>  monoton zunehmende eindeutige Kennungen </li><li>  Nutzlastpuffer (bis zu 4 Kilobyte) f√ºr jedes Ereignis </li><li>  Thread-Pool-Benachrichtigungsmodell mit gruppenbasierter Serialisierung </li><li>  Ein <abbr title="Liste der Systemzugriffskontrollen">bereichsbereichsbasiertes</abbr> Sicherheitsmodell, das Sicherheitsbeschreibungen √ºber den Standard- <abbr title="Liste der diskretion√§ren Zugriffskontrollen">DACL</abbr> / <abbr title="Liste der Systemzugriffskontrollen">SACL-</abbr> Mechanismus <abbr title="Liste der Systemzugriffskontrollen">implementiert</abbr> </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  Warum WNF erschien </h3><br><p>  Stellen Sie sich ein kanonisches Beispiel vor: Es gibt einen Treiber, der wissen m√∂chte, dass ein Volume mit Lese- und Schreibzugriff verbunden wurde.  Um Sie dar√ºber zu informieren, meldet Autochk (ein Analogon von <abbr title="Konsistenzpr√ºfung des Dateisystems">fsck</abbr> unter Windows) ein Ereignis namens VolumesSafeForWriteAccess.  Um ein Ereignis zu melden, m√ºssen Sie jedoch zuerst das Ereignisobjekt selbst erstellen. </p><br><p>  Wir m√ºssen auch wissen, dass Autochk bereits an der Lautst√§rke arbeitet, aber das Ereignis, auf das wir warten, noch nicht signalisiert hat.  Schlechte L√∂sung: Setzen Sie sich mit sleep () in eine Schleife, pr√ºfen Sie, ob ein Ereignis vorhanden ist, und warten Sie, wenn das Ereignis erstellt wird. </p><br><p>  Nach dem Beenden der Windows-Anwendung werden jedoch alle Deskriptoren geschlossen.  Und wenn das Objekt keine Deskriptoren hat, wird es zerst√∂rt.  Wer wird diese Veranstaltung abhalten? </p><br><p>  Ohne WNF besteht die L√∂sung darin, dass der Betriebssystemkern ein Ereignis generiert, bevor Treiber geladen werden, und dass Autochk es wie ein Verbraucher √∂ffnet, aber anstatt zu warten, sollte es dieses Ereignis signalisieren. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Statusnamen WNF </h3><br><p>  In der WNF-Welt ist ein Statusname eine 64-Bit-Nummer.  Aber es gibt einen Trick - tats√§chlich ist es eine codierte Struktur.  Der Statusname hat eine <em>Version</em> , <em>eine Lebensdauer</em> , einen <em>Bereich</em> , ein <em>Datenpersistenzflag</em> und eine <em>eindeutige Seriennummer</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Diese Daten sind jedoch nur verf√ºgbar, wenn wir eine 64-Bit-Zahl mit einer magischen Konstante pro-XOR verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Lebensdauer des Statusnamens </h4><br><p>  Der WNF-Statusname kann sein (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bekannt </li><li>  permanent </li><li>  hartn√§ckig </li><li>  vor√ºbergehend </li></ul><br><p>  Die ersten drei sind den entsprechenden Schl√ºsseln in der Registrierung zugeordnet, in denen Statusinformationen gespeichert werden: </p><br><ul><li>  Bekannte Namen befinden sich in HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notifications </li><li>  Persistente Namen befinden sich in HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notifications </li><li>  Persistente Namen befinden sich in HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Bekannte Namen haben ihre eigene Besonderheit: Sie k√∂nnen nicht registriert werden.  Ein solcher Name sollte bereits zum Zeitpunkt des Systemstarts in der Registrierung vorhanden sein.  Persistente und persistente Namen erfordern das enthaltene SeCreatePermanentPrivilege-Privileg (wie andere globale Objekte), um sie zu erstellen.  Persistente Namen befinden sich au√üerhalb des Registrierungsprozesses, w√§hrend persistente Namen einen Systemneustart √ºberleben. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Datenumfang </h4><br><p>  Der Datenbereich definiert die erste Sicherheitsgrenze um den WNF-Statusnamen und bestimmt, wer ihn sieht und Zugriff darauf hat.  Der G√ºltigkeitsbereich des Statusnamens kann sein: </p><br><ul><li>  das System </li><li>  Auto </li><li>  Benutzersitzung </li><li>  der Benutzer </li><li>  der Prozess </li></ul><br><p>  Zus√§tzlich zur Bereitstellung von Sicherheitsgrenzen k√∂nnen WNF-Bereiche verwendet werden, um verschiedene Dateninstanzen f√ºr denselben Namen bereitzustellen.  Der Kernel umgeht (wie bei anderen Sicherheitsmechanismen) die Statuszugriffspr√ºfungen.  Das TCB-Privileg erm√∂glicht den bereichs√ºbergreifenden Zugriff auf WNF-Statusnamen. </p><br><p>  Der Bereich "System" und der Bereich "Maschine" sind globale Bereiche.  Sie haben keine eigenen Bezeichner (sie verwenden unterschiedliche globale Container).  Der Bereich der Benutzersitzung verwendet die Sitzungskennung (Sitzungs-ID) als ID.  Der Bereich eines bestimmten Benutzers verwendet die SID dieses Benutzers als Kennung.  Die Adresse des EPROCESS-Objekts ist die Kennung des Prozessbereichs. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  Sequenznummern </h4><br><p>  Um die Eindeutigkeit sicherzustellen, hat jeder Statusname eine eindeutige 51-Bit-Sequenznummer.  Bekannte Namen enthalten ein 4-stelliges Familien-Tag in ihrer Seriennummer, und die verbleibenden 21 Bits werden als eindeutige Kennung verwendet.  Permanente Namen speichern ihre inkrementelle Nummer mit dem Registrierungswert "SequenceNumber".  Persistente und tempor√§re Namen verwenden einen gemeinsamen Inkrementierungsz√§hler, der sich in einer globalen Variablen befindet.  Diese Daten werden f√ºr jeden Container (pro Silo) separat gespeichert und verarbeitet und sind in PspHostSiloGlobals-&gt; WnfSiloState verf√ºgbar. </p><br><p>  In Microsoft hat jeder WNF-Name eine "freundliche" Kennung, die im Code verwendet wird. Manchmal wird er im globalen Namespace mit demselben Namen gespeichert.  Zum Beispiel das Symbol nt! WNF_BOOT_DIRTY_SHUTDOWN, das den Wert 0x1589012fa3bc0875 hat.  Nach XOR mit der magischen Konstante <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY erhalten</abbr> wir den Wert 0x544f4f4200000801, der bitweise interpretiert werden kann als: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Systemaufrufe f√ºr die Arbeit mit WNF </h3><br><p>  Mit Kernel-Systemaufrufen k√∂nnen Sie WNF-Statusnamen registrieren und l√∂schen, WNF-Statusnamendaten ver√∂ffentlichen und empfangen sowie verschiedene Benachrichtigungen von WNF erhalten. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Registrieren Sie den WNF-Statusnamen </h4><br><p>  Mit Ausnahme bekannter Namen (wie bereits erw√§hnt) kann der WNF-Statusname registriert werden, w√§hrend das Betriebssystem ausgef√ºhrt wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  Es gibt einen symmetrischen Systemaufruf ZwDeleteWnfStateName, mit dem Sie den registrierten Statusnamen l√∂schen k√∂nnen (au√üer bei bekannten). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Ver√∂ffentlichen Sie WNF-Statusdaten </h4><br><p>  Zum Festlegen oder √Ñndern der WNF-Statusnamensdaten k√∂nnen Sie den Systemaufruf ZwUpdateWnfStateData verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  Es gibt einen symmetrischen Systemaufruf ZwDeleteWnfStateData, um die Daten des WNF-Statusnamens zu l√∂schen (zu bereinigen). </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Abrufen von WNF-Statusdaten </h4><br><p>  Um die WNF-Statusnamensdaten anzufordern, kann der folgende Systemaufruf verwendet werden (die meisten Parameter √§hneln der Update-Funktion): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  Die wahre St√§rke liegt in der Tatsache, dass f√ºr die API-Funktionen Update und Query kein <u>registrierter</u> WNF-Statusname erforderlich ist.  Und wenn der Name nicht tempor√§r ist (und der aufrufende Code √ºber ausreichende Berechtigungen verf√ºgt), kann eine Instanz des Namens in Echtzeit registriert werden! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  WNF-Benachrichtigungen </h4><br><p>  Bisher haben wir angenommen, dass der Verbraucher wei√ü, wann er die Datenerfassungsfunktion aufrufen muss.  Es gibt aber auch eine <em>Blockierung des Lesens</em> , die mit einem Benachrichtigungssystem funktioniert (das dem tats√§chlichen Publisher-Subscriber-Modell n√§her kommt). </p><br><p>  Zun√§chst muss der Prozess das Ereignis durch Aufrufen der Funktion ZwSetWnfProcessNotificationEvent registrieren.  Anschlie√üend m√ºssen Sie die Funktion ZwSubscribeWnfStateChange aufrufen und eine Ereignismaske angeben, um die Abonnement-ID f√ºr die Ausgabe abzurufen.  Es gibt zwei Arten von Ereignissen: </p><br><ul><li>  Datenbenachrichtigungen: <br><ul><li>  0x01 - Datenauftritt </li><li>  0x10 - Namenszerst√∂rung </li></ul></li><li>  Meta-Metanotifikationen <br><ul><li>  0x02 - Erscheinen eines Teilnehmers, der Datenbenachrichtigungen erh√§lt (Datenabonnent) </li><li>  0x04 - Erscheinen eines Abonnenten, der Meta-Benachrichtigungen erh√§lt (Meta-Abonnent) </li><li>  0x08 - das Erscheinen eines Abonnenten, der Datenbenachrichtigungen und Meta-Benachrichtigungen erh√§lt (generischer Abonnent) </li></ul></li></ul><br><p>  Dann m√ºssen Sie auf das aufgezeichnete Ereignis warten.  Und jedes Mal, wenn das Ereignis zu einem Signal wird, m√ºssen Sie die Funktion ZwGetCompleteWnfStateSubscription aufrufen, die WNF_DELIVERY_DESCRIPTOR zur√ºckgibt. </p><br><p>  Diese Low-Level-API-Funktionen haben jedoch ein Problem (danke an Gabi f√ºr die Untersuchung): Jeder Prozess kann nur ein registriertes Ereignis haben. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  High Level User Mode API (ntdll) </h3><br><p>  Wenn es um Benachrichtigungen geht, werden die Dinge kompliziert, sodass die RTL-Ebene von ntdll.dll eine einfachere Oberfl√§che bietet: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  Tats√§chlich m√ºssen Systemdienste nicht direkt aufgerufen werden: Verwenden Sie einfach eine einzelne Ereigniswarteschlange, die von ntdll.dll gesteuert wird. </p><br><p>  Hinter den Kulissen wird der Inhalt von WNF_DELIVERY_DESCRIPTOR in R√ºckrufparameter konvertiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  F√ºr jedes neue Abonnement wird ein Eintrag vorgenommen, der in die Liste aufgenommen wird, auf die die globale Variable RtlpWnfProcessSubscriptions verweist.  Die Liste basiert auf einem der Felder WNF_NAME_SUBSCRIPTION vom Typ LIST_ENTRY.  Jedes von WNF_NAME_SUBSCRIPTION verf√ºgt wiederum √ºber ein anderes LIST_ENTRY-Feld zum Organisieren einer Liste von WNF_USER_SUBSCRIPTION mit einem R√ºckruf und Kontext. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  High Level Kernel Level API (Ex) </h3><br><p>  WNF bietet auch nahezu identische Funktionen f√ºr den Kernelmodus-Code (der vom Treiber verwendet werden kann): sowohl durch exportierte Systemaufrufe als auch √ºber API-Funktionen auf hoher Ebene zur Laufzeit (Ex-Layer). </p><br><p>  Die ExSubscribeWnfStateChange-Funktion akzeptiert den Statusnamen, Typmasken und die Adresse der R√ºckruffunktion + Kontext als Eingabe und gibt einen Abonnementdeskriptor zur√ºck.  Die R√ºckruffunktionen erhalten den Zielnamen, die Ereignismaske, die √Ñnderungsbezeichnung, jedoch nicht den Puffer oder dessen Gr√∂√üe. </p><br><p>  Die ExQueryWnfStateData-Funktion liest basierend auf dem √ºbergebenen Abonnementdeskriptor die aktuellen Statusdaten.  Tats√§chlich ruft jeder R√ºckruf die ExQueryWnfStateData-Funktion auf, um die mit der Benachrichtigung verkn√ºpften Daten abzurufen. </p><br><p>  Sowohl f√ºr Kernelmodus-Abonnements als auch f√ºr Benutzermodus-Abonnements erstellt WNF (zum Verfolgen von Abonnements) eine Instanz der Struktur WNF_SUBSCRIPTION.  Im Benutzermodus werden jedoch einige Felder nicht ausgef√ºllt, z. B. R√ºckruf und Kontext, da im Benutzermodus die Adressen der Handler von ntdll.dll gespeichert und verarbeitet werden. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  WNF-Datenstrukturen </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>Von einem √úbersetzer</em></u> : siehe n√§chster Abschnitt. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  WNF-Analyse-Dienstprogramme </h3><br><p>  <u><em>Von einem √úbersetzer</em></u> : An dieser Stelle sei noch einmal daran erinnert, dass die Pr√§sentation nicht nur von Alex, sondern auch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabrielle Viala durchgef√ºhrt wurde</a> .  Insbesondere geh√∂rt seine Urheberschaft zum unten beschriebenen WnfCom-Modul.  Dar√ºber hinaus hat Gabrielle die internen Strukturen von WNF ausreichend detailliert beschrieben (siehe Abbildung im vorherigen Abschnitt).  Die meisten Folien fehlen leider im PDF der Pr√§sentation (als Original angegeben) oder sind ausschlie√ülich durch √úberschriften gekennzeichnet.  Aber: </p><br><ul><li>  Dies ist eine hervorragende Gelegenheit, um eine Aufzeichnung ihrer gemeinsamen Leistung anzusehen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows-Benachrichtigungsfunktion: Sch√§len der Zwiebel der bislang undokumentiertesten Kernel-Angriffsfl√§che</a> (Beginn von Gabrielle ~ 19: 27).  Dort (neben Datenstrukturen) wird es eine Geschichte dar√ºber geben, wie sie die Debugger-Erweiterung behoben haben! Wnf (Spoiler - unter Verwendung der in NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beheben defekter Debugger-Erweiterungen</a> beschriebenen Methode) </li><li>  Gabrielle hat einen separaten guten Artikel (detailliert, nicht als Pr√§sentation) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielen mit der Windows Notification Facility (WNF)</a> , der auch allen Interessierten zum Lesen empfohlen wird. </li></ul><br><p>  <u><em>Und vom √úbersetzer</em></u> : Wenn jemand die aktuelle √úbersetzung durch den Inhalt von Gabrielle-Folien erg√§nzen oder die √úbersetzung des w√∂rtlichen Transkripts aus einem beliebigen Teil des Videos der Rede erweitern m√∂chte - willkommen.  Um das Hinzuf√ºgen / √Ñndern gro√üer Bl√∂cke zu vereinfachen, kann ich die √úbersetzungsquelle auf github (oder einem anderen Versionskontrollserver) ver√∂ffentlichen. </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  WnfCom ist ein Python-Modul ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Quellcode</a> ), das Interoperabilit√§t √ºber WNF zeigt.  Hauptmerkmale: </p><br><ul><li>  Erm√∂glicht das Lesen / Schreiben von Daten aus vorhandenen Instanzinstanzen </li><li>  erm√∂glicht es Ihnen, tempor√§re Statusnamen zu erstellen (als <em>Server</em> ) </li><li>  Mit dieser <em>Option</em> k√∂nnen Sie eine Instanz eines <em>clientseitigen</em> Objekts <em>abrufen</em> , die Benachrichtigungen zum √Ñndern einer bestimmten Instanz eines Namens verarbeitet </li></ul><br><p>  Anwendungsbeispiel: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump ist ein in C geschriebenes Befehlszeilenprogramm. Die ausf√ºhrbare Datei finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ionescu007/wnfun,</a> indem Sie das Unterverzeichnis der erforderlichen Bittiefe ausw√§hlen.  Das Dienstprogramm kann verwendet werden, um nach Informationen zu WNF-Statusnamen zu suchen: </p><br><ul><li>  -d ( <u>D</u> ump) Gibt alle WNF-Statusnamen mithilfe einer registrierungsbasierten Aufz√§hlung aus.  Es kann mit folgenden Optionen erg√§nzt werden: <br><ul><li>  -v ( <u>V</u> erbose) Eine ausf√ºhrliche Ausgabe, die einen hexadezimalen Speicherauszug von WNF-Statusdaten enth√§lt. </li><li>  -s (Sicherheit) Sicherheitsbeschreibungen - SDDL-Berechtigungszeichenfolgen f√ºr den WNF-Statusnamen. </li></ul></li><li>  -b ( <u>B</u> rute-force) Direkte Aufz√§hlung tempor√§rer WNF-Statusnamen (mehr dazu weiter unten) </li><li>  -i (Informationen) Zeigt Informationen zu einem einzelnen angegebenen WNF-Statusnamen an </li><li>  -r (Lesen) Liest Daten aus dem angegebenen WNF-Statusnamen </li><li>  -w (Schreiben) Schreiben Sie Daten in den angegebenen WNF-Statusnamen </li><li>  -n (Benachrichtigung) Registrieren Sie einen Benachrichtigungsteilnehmer f√ºr den angegebenen WNF-Statusnamen (im Folgenden wird ein spezifischerer Anwendungsfall mit Edge beschrieben). </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  WNF-Angriffsfl√§che </h3><br><p>  In diesem Abschnitt (genauer gesagt in seinen Unterabschnitten) werden m√∂gliche Angriffe und interessante sensible WNF-Daten er√∂rtert. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Privilegierte Datenoffenlegung </h4><br><p>  Beim Lesen der Tausenden von WNF-Statusnamen, die im System vorhanden sind, k√∂nnen mehrere festgestellt werden, deren Daten sehr interessant aussehen.  Unter ihnen waren einige, deren Daten Zeigern oder anderen privilegierten Daten verd√§chtig √§hnlich sind. </p><br><p>  Nach dem Spielen auf mehreren Computern war es in einigen F√§llen m√∂glich, eine Reihe, einen Stapel und andere privilegierte Informationen zu finden, die √ºber Berechtigungsgrenzen hinweg offengelegt wurden.  Fehler- / Schwachstellenberichte wurden im Juli an MSRC √ºbermittelt, aber im November (nach der Pr√§sentation) korrigiert.  Zum Beispiel: 4 Kilobyte Stapel sind durch das WNF_AUDC * -Ereignis durchgesickert! </p><br><p>  Die Hauptprobleme sind die gleichen wie in fr√ºheren Studien von j00ro, taviso und anderen.  Bestimmte WNF-Statusnamen enthalten codierte Datenstrukturen mit verschiedenen Auff√ºll- und / oder Ausrichtungsproblemen.  In einigen F√§llen tritt nicht initialisierter Speicher aus. <br>  <u><em>Vom √úbersetzer</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung des einleitenden Teils des Dokuments Erkennen der Offenlegung des Kernelspeichers mit x86-Emulation und Taint-Tracking von Mateusz Jurczyk aka j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Ermittlung von Statusnamen und Berechtigungen </h4><br><p>  Der erste Ansatz bestand darin, alle m√∂glichen Statusnamen zu ermitteln, die b√∂swillig manipuliert werden konnten.  Bei bekannten, dauerhaften und dauerhaften Namen ist die Aufz√§hlung durch Aufz√§hlung von Registrierungsschl√ºsseln m√∂glich.  Dann k√∂nnen die gefundenen Werte mit benutzerfreundlichen Bezeichnern verglichen werden (es gibt mehrere Stellen, an denen Sie sie finden k√∂nnen :)) </p><br><p>  Dann k√∂nnen wir uns auch den Sicherheitsdeskriptor in der Registrierung ansehen (dies ist das erste, was sich im Datenpuffer befindet).  Die Sicherheitsbeschreibung ist nicht kanonisch: Sie hat keinen Eigent√ºmer und keine Gruppe, ist also technisch nicht g√ºltig.  Es ist jedoch kein Problem, einen falschen Eigent√ºmer und eine falsche Gruppe zu ersetzen, <em>um</em> den Sicherheitsdeskriptor zu <em>reparieren</em> . </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Erkennung von tempor√§ren Statusnamen und deren Berechtigungen </h4><br><p>  Bei tempor√§ren Namen funktionieren die oben beschriebenen Tricks jedoch nicht: Sie befinden sich nicht in der Registrierung.  Und nur der Kernel speichert Datenstrukturen f√ºr sie (! Wnf) im Speicher.  Aber tempor√§re Namen sind eigentlich gar nicht so schwer zu erzwingen: </p><br><ul><li>  Version ist immer wichtig 1 </li><li>  Die Lebensdauer ist immer wichtig WnfTemporaryStateName </li><li>  Das permanente Flag wird immer gel√∂scht (der Name des tempor√§ren Status kann keine permanenten Daten enthalten). </li><li>  Bereich (Bereich) kann einen von 4 Werten annehmen </li></ul><br><p>  Ja, aber die verbleibende Sequenznummer betr√§gt 51 Bit!  In der Tat ... aber vergessen Sie nicht, dass die Seriennummern monoton wachsen.  Bei tempor√§ren Namen wird die Sequenz bei jedem Start auf 0 zur√ºckgesetzt.  Herk√∂mmlicherweise k√∂nnen Sie ein Fenster mit einer Million Seriennummern erstellen: √úberpr√ºfen Sie in einer Schleife die Existenz jedes Namens (beginnend mit 0), indem Sie ZwQueryWnfStateNameInformation mit der angeforderten Informationsklasse WnfInfoStateNameExist aufrufen (vorausgesetzt, der Zugriffsfehler zeigt auch das Vorhandensein eines Namens an).  Wenn keine weiteren Millionen Namen vorhanden sind, k√∂nnen Sie die Suche beenden. </p><br><p>  Tempor√§re Namenssicherheitsbeschreibungen (wie andere tempor√§re Namensdaten) werden im Kernel gespeichert.  Daher ist die einzige M√∂glichkeit, sie anzufordern, die Erweiterung! Wnf beim Debuggen des Kernelmodus.  Aber wir k√∂nnen: </p><br><ul><li>  Machen Sie eine Schlussfolgerung zu den Leseberechtigungen, wenn Sie versuchen, Daten zu lesen. </li><li>  Um zu schlie√üen, dass die Aufzeichnung durch den Versuch, Daten zu schreiben, erlaubt ist.  Es ist jedoch zu bedenken, dass ein erfolgreiches Schreiben von nur 0 Bytes die Daten zerst√∂rt, die der echte Verbraucher noch nicht erhalten hat.  Und wieder gibt es einen Trick: Wir k√∂nnen den entsprechenden √Ñnderungsstempel anwenden.  Wir versuchen, mit dem Label 0xFFFFFFFF zu schreiben: Das Label wird nach der Zugriffspr√ºfung √ºberpr√ºft, daher f√ºhrt der Fehlerwert zu einem Verlust der Schreibberechtigung. </li></ul><br><p>  Dies gibt uns keine vollst√§ndige Sicherheitsbeschreibung, aber wenn wir den Code mit unterschiedlichen Berechtigungen ausf√ºhren, k√∂nnen wir uns ein Bild von den Einschr√§nkungen f√ºr verschiedene Systemkonten machen (Low IL / User / Admin / SYSTEM). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Abonnenten auflisten </h4><br><p>  In der Struktur WNF_PROCESS_CONTEXT ist eines der Felder der Listenkopf (LIST_ENTRY) aller Abonnements dieses Prozesses.  Jedes Abonnement ist eine separate Instanz von WNF_SUBSCRIPTION. </p><br><p>  Abonnenten im Kernel-Modus geh√∂ren in erster Linie dem Systemprozess.  Mit dem Befehl! List debugger k√∂nnen Sie Handler und ihre Parameter ausgeben, die im Systemprozess WNF_SUBSCRIPTION registriert sind.  Es ist erw√§hnenswert, dass in einigen F√§llen ein Ereignisaggregator (CEA.SYS) verwendet wird, der die tats√§chlichen R√ºckrufadressen in seiner Kontextstruktur verbirgt. </p><br><p>  Wir k√∂nnen diesen Ansatz f√ºr Prozesse im Benutzermodus wiederholen, aber die R√ºckrufadresse ist NULL, da dies Abonnenten im Benutzermodus sind.  Daher m√ºssen wir dem Benutzerbereich des Prozesses beitreten, die Tabelle RtlpWnfProcessSubscriptions abrufen und dann die Liste der WNF_USER_SUBSCRIPTION-Instanzen sichern, von denen jede bereits die R√ºckrufadresse enth√§lt.  Leider ist dieses Zeichen statisch, was bedeutet, dass es sich nicht um offene Zeichen handelt, sondern durch Zerlegen gefunden werden kann.  Auch hier lohnt es sich (analog zum CEA.SYS-Kernelmodus) darauf zu achten, dass viele der Benutzermodus-Handler den Ereignisaggregator (EventAggregation.dll) verwenden, der den R√ºckruf in seinem Kontext speichert. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Interessante und sensible WNF-Staatsnamen </h3><br><p>  Dieser Abschnitt enth√§lt einige interessante Beispiele daf√ºr, wie einige WNF-Statusnamen Systeminformationen anzeigen. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Ermitteln des Systemstatus und des Benutzerverhaltens mithilfe von WNF </h4><br><p>  Einige WNF-Kennungen k√∂nnen verwendet werden, um Informationen √ºber den Status der Maschine abzurufen, die Sie interessiert: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Drahtloser Status </li><li>  WNF_BLTH_BLUETOOTH_STATUS - √§hnlich, aber f√ºr Bluetooth (auch WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE - Zeigt die Stromquelle (Batterie oder Netzteil) an. </li><li>  WNF_SEB_BATTERY_LEVEL - enth√§lt den Batteriestand </li><li>  WNF_CELL_ * - unter Windows Phone enth√§lt Informationen √ºber: Netzwerk, Nummer, Signalst√§rke, EDGE oder 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER ‚Äî   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT ‚Äî    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED ‚Äî    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      ‚Äî       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE ‚Äî     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST ‚Äî   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK ‚Äî ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND ‚Äì   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory ‚Äî    </li><li>   ( ) ‚Äî               </li><li>   (Atom) ‚Äî            </li><li>    ‚Äî  ,   WM_COPYDATA  DDE,       </li><li> GUI  ‚Äî    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Asynchronous Procedure Call">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " ‚Äî  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Control Flow Guard">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> github</a> )   explorer (  ‚Äî  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li>     WNF_USER_SUBSCRIPTION     </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459626/">https://habr.com/ru/post/de459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459616/index.html">MIPT er√∂ffnet Russlands ersten fortgeschrittenen Masterstudiengang in Informatik und Softwaretechnik</a></li>
<li><a href="../de459618/index.html">Einige wenig bekannte Docker-Compose-Funktionen</a></li>
<li><a href="../de459620/index.html">TDDx2, BDD, DDD, FDD, MDD und PDD oder was auch immer Sie √ºber Driven Development wissen m√∂chten</a></li>
<li><a href="../de459622/index.html">Als die Spiele f√ºr Sega Saturn wurden 1995 geschrieben</a></li>
<li><a href="../de459624/index.html">Milit√§rische Drohnen</a></li>
<li><a href="../de459628/index.html">Das Open Invention Network hat mehr als dreitausend Lizenznehmer - was bedeutet das f√ºr Open Source-Software?</a></li>
<li><a href="../de459630/index.html">Tic Tac Toe Teil 2: Staatenloses R√ºckg√§ngigmachen / Wiederherstellen</a></li>
<li><a href="../de459638/index.html">Schaffung einer globalen Wissensbasis √ºber Batterien</a></li>
<li><a href="../de459640/index.html">Dokumente als Code. Teil 1: Automatisieren Sie das Update</a></li>
<li><a href="../de459642/index.html">Sicherer Zugriff auf Registerfelder in C ++ ohne Einbu√üen bei der Effizienz (am Beispiel von CortexM)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>