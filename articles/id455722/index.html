<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 👩🏻‍🏫 🚄 Python menghabiskan banyak memori atau cara mengurangi ukuran objek? 🗽 🌉 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Masalah memori dapat muncul ketika Anda perlu memiliki sejumlah besar objek selama eksekusi program, terutama jika ada batasan pada ukuran total RAM y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python menghabiskan banyak memori atau cara mengurangi ukuran objek?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455722/"><p>  Masalah memori dapat muncul ketika Anda perlu memiliki sejumlah besar objek selama eksekusi program, terutama jika ada batasan pada ukuran total RAM yang tersedia. </p><br><p>  Berikut ini adalah ikhtisar dari beberapa metode untuk mengurangi ukuran objek, yang secara signifikan dapat mengurangi jumlah RAM yang diperlukan untuk program dalam Python murni. </p><a name="habracut"></a><br><p> Untuk kesederhanaan, kami akan mempertimbangkan struktur dalam Python untuk mewakili titik dengan koordinat <code>x</code> , <code>y</code> , <code>z</code> dengan akses untuk mengoordinasikan nilai berdasarkan nama. </p><br><h3 id="dict">  Diktik </h3><br><p>  Dalam program kecil, terutama skrip, cukup sederhana dan nyaman untuk menggunakan <code>dict</code> untuk mewakili informasi struktural: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Dengan munculnya implementasi yang lebih "kompak" di Python 3.6 dengan serangkaian kunci yang diperintahkan, <code>dict</code> menjadi lebih menarik.  Namun, lihat ukuran jejaknya di RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Membutuhkan banyak memori, terutama jika Anda tiba-tiba harus membuat banyak contoh: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  240 Mb </td></tr><tr><td>  10.000.000 </td><td>  2,40 GB </td></tr><tr><td>  100.000.000 </td><td>  24 GB </td></tr></tbody></table></div><br><h3 id="class-instance">  Contoh kelas </h3><br><p>  Bagi mereka yang suka berpakaian segala sesuatu di kelas, lebih baik untuk mendefinisikannya sebagai kelas dengan akses dengan nama atribut: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  Struktur instance kelas menarik: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Di sini <code>__weakref__</code> adalah tautan ke daftar yang disebut <em>referensi lemah</em> ke objek ini, bidang <code>__dict__</code> adalah tautan ke kamus instan kelas yang berisi nilai-nilai atribut instance (perhatikan bahwa tautan pada platform 64-bit menempati 8 byte).  Dimulai dengan Python 3.3, ruang kunci kamus bersama digunakan untuk semua instance kelas.  Ini mengurangi ukuran jejak instance dalam memori: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Akibatnya, sejumlah besar instance kelas meninggalkan jejak yang lebih kecil dalam memori daripada kamus biasa ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  168 Mb </td></tr><tr><td>  10.000.000 </td><td>  1,68 GB </td></tr><tr><td>  100.000.000 </td><td>  16,8 GB </td></tr></tbody></table></div><br><p>  Sangat mudah untuk melihat bahwa jejak instance dalam memori masih besar karena ukuran kamus instance. </p><br><h3 id="instance-of-class-with--__slots__">  Instance kelas dengan __slots__ </h3><br><p>  Pengurangan yang signifikan dalam jejak instance dalam memori dicapai dengan menghilangkan <code>__dict__</code> dan <code>__weakref__</code> .  Ini dimungkinkan dengan "trik" dengan <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  Jejak dalam memori menjadi jauh lebih padat: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  Menggunakan <code>__slots__</code> dalam definisi kelas mengarah pada fakta bahwa jejak sejumlah besar contoh dalam memori berkurang secara signifikan: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  64 Mb </td></tr><tr><td>  10.000.000 </td><td>  640 Mb </td></tr><tr><td>  100.000.000 </td><td>  6,4 GB </td></tr></tbody></table></div><br><p>  Saat ini, ini adalah metode utama untuk secara signifikan mengurangi jejak instance kelas dalam memori program. </p><br><p>  Pengurangan ini dicapai oleh fakta bahwa dalam memori setelah judul objek referensi ke objek disimpan, dan akses ke mereka dilakukan menggunakan deskriptor khusus yang ada di kamus kelas: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Ada perpustakaan daftar nama untuk mengotomatiskan proses membuat kelas dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">__slots__</a> .  Fungsi <code>namedlist.namedlist</code> membuat struktur kelas yang identik dengan kelas dengan <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">attrs</a> lain memungkinkan Anda untuk mengotomatiskan proses membuat kelas dengan dan tanpa <code>__slots__</code> . </p><br><h3 id="tuple">  Tuple </h3><br><p>  Python juga memiliki tipe <code>tuple</code> untuk mewakili set data.  Tuple adalah struktur atau catatan tetap, tetapi tanpa nama bidang.  Untuk mengakses bidang, indeks bidang digunakan.  Bidang tuple adalah sekali dan untuk semua yang terkait dengan objek nilai pada saat tuple dipakai: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # </code> </pre> <br><p>  Instance Tuple cukup kompak: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Mereka menempati 8 byte lebih banyak dalam memori daripada instance kelas dengan <code>__slots__</code> , karena jejak tuple dalam memori juga berisi jumlah bidang: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Karena tuple digunakan dengan sangat luas, suatu hari ada permintaan untuk dapat tetap memiliki akses ke bidang dengan nama juga.  Respons terhadap permintaan ini adalah modul <code>collections.namedtuple</code> . </p><br><p>  Fungsi <code>namedtuple</code> dirancang untuk mengotomatiskan proses menghasilkan kelas-kelas ini: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Itu menciptakan subkelas tuple, yang mendefinisikan pegangan untuk mengakses bidang dengan nama.  Sebagai contoh kita, akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_y(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Semua instance kelas tersebut memiliki jejak dalam memori yang identik dengan tuple.  Sejumlah besar contoh meninggalkan jejak memori yang sedikit lebih besar: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  72 Mb </td></tr><tr><td>  10.000.000 </td><td>  720 Mb </td></tr></tbody></table></div><br><h3 id="recordclass-mutiruemyy-namedtuple-bez-gc">  Recordclass: bermutasi nameduple tanpa GC </h3><br><p>  Sejak <code>tuple</code> dan, dengan demikian, kelas <code>namedtuple</code> menghasilkan objek yang tidak bisa berubah dalam arti bahwa objek nilai <code>ob.x</code> tidak lagi dapat dikaitkan dengan objek nilai lain, permintaan untuk varian namtuple yang termutasi telah muncul.  Karena Python tidak memiliki tipe bawaan yang identik dengan tuple yang mendukung penugasan, banyak variasi telah dibuat.  Kami akan fokus pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">recordclass</a> , yang menerima peringkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stackoverflow</a> .  Selain itu, dengan bantuannya dimungkinkan untuk mengurangi ukuran jejak suatu objek dalam memori dibandingkan dengan ukuran jejak objek jenis <code>tuple</code> . </p><br><p>  Dalam paket <strong>recordclass</strong> , <strong>tipe recordclass.mutabletuple</strong> diperkenalkan, yang hampir identik dengan tuple tetapi juga mendukung penugasan.  Pada dasarnya, subclass dibuat yang hampir identik dengan namedtuple, tetapi juga mendukung penugasan nilai baru ke bidang (tanpa membuat instance baru).  Fungsi <code>recordclass</code> , seperti fungsi <code>namedtuple</code> , mengotomatiskan pembuatan kelas-kelas tersebut: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  Contoh kelas memiliki struktur yang sama dengan <code>tuple</code> , tetapi hanya tanpa <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Secara default, fungsi <code>recordclass</code> memunculkan kelas yang tidak terlibat dalam mekanisme pengumpulan sampah melingkar.  Biasanya, <code>namedtuple</code> dan <code>recordclass</code> digunakan untuk menelurkan kelas yang mewakili catatan atau struktur data sederhana (non-rekursif).  Penggunaannya yang benar dalam Python tidak menghasilkan referensi melingkar.  Untuk alasan ini, jejak instance kelas yang dihasilkan oleh <code>PyGC_Head</code> default <code>PyGC_Head</code> fragmen <code>PyGC_Head</code> , yang diperlukan untuk kelas yang mendukung mekanisme pengumpulan sampah siklik (lebih tepatnya: bendera <code>PyTypeObject</code> tidak disetel dalam bidang <code>flags</code> pada struktur <code>PyTypeObject</code> yang sesuai dengan kelas yang dibuat). </p><br><p>  Ukuran jejak sejumlah besar instance lebih kecil dari instance kelas dengan <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  48 Mb </td></tr><tr><td>  10.000.000 </td><td>  480 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,8 GB </td></tr></tbody></table></div><br><h3 id="dataobject">  Objek data </h3><br><p>  Solusi lain yang diusulkan dalam perpustakaan <code>recordclass</code> didasarkan pada ide: untuk menggunakan struktur penyimpanan dalam memori, seperti dalam contoh kelas dengan <code>__slots__</code> , tetapi tidak untuk berpartisipasi dalam mekanisme pengumpulan sampah siklik.  Kelas <code>recordclass.make_dataclass</code> menggunakan fungsi <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Kelas default yang dibuat dengan cara ini membuat instance bermutasi. </p><br><p>  Cara lain adalah dengan menggunakan deklarasi kelas dengan mewarisi dari <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Kelas yang dibuat dengan cara ini akan menghasilkan instance yang tidak berpartisipasi dalam mekanisme pengumpulan sampah melingkar.  Struktur instance dalam memori sama dengan <code>__slots__</code> , tetapi tanpa header <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Untuk mengakses bidang, deskriptor khusus juga digunakan untuk mengakses bidang dengan offsetnya relatif terhadap awal objek, yang ditempatkan di kamus kelas: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  Ukuran jejak sejumlah besar contoh adalah yang sekecil mungkin untuk CPython: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  40 Mb </td></tr><tr><td>  10.000.000 </td><td>  400 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,0 GB </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Ada satu pendekatan yang didasarkan pada penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cython</a> .  Keuntungannya adalah bidang dapat mengambil nilai tipe bahasa C. Penjelas untuk mengakses bidang dari Python murni dibuat secara otomatis.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  Dalam hal ini, instans memiliki ukuran memori yang lebih kecil: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  Jejak contoh dalam memori memiliki struktur berikut: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Lapangan </th><th>  Ukuran (byte) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  kosong </td><td>  4 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  Ukuran jejak sejumlah besar salinan lebih kecil: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  32 Mb </td></tr><tr><td>  10.000.000 </td><td>  320 Mb </td></tr><tr><td>  100.000.000 </td><td>  3,2 GB </td></tr></tbody></table></div><br><p>  Namun, harus diingat bahwa ketika mengakses dari kode Python, konversi dari <code>int</code> ke objek Python dan sebaliknya akan dilakukan setiap kali. </p><br><h3 id="numpy">  Numpy </h3><br><p>  Penggunaan multidimensi atau array rekaman untuk sejumlah besar data memberikan keuntungan dalam memori.  Namun, untuk pemrosesan efisien dalam Python murni, Anda harus menggunakan metode pemrosesan yang fokus pada penggunaan fungsi dari paket <code>numpy</code> . </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Array dan elemen <code>N</code> diinisialisasi dengan nol dibuat menggunakan fungsi: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  Ukuran array adalah yang sekecil mungkin: </p><br><div class="scrollable-table"><table><thead><tr><th>  Jumlah salinan </th><th>  Ukuran jejak </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  12 Mb </td></tr><tr><td>  10.000.000 </td><td>  120 Mb </td></tr><tr><td>  100.000.000 </td><td>  1,20 GB </td></tr></tbody></table></div><br><p>  Akses reguler ke elemen dan string array akan memerlukan konversi objek Python <br>  ke dalam nilai C <code>int</code> dan sebaliknya.  Mengekstrak satu baris menghasilkan dalam array yang mengandung elemen tunggal.  Jejaknya tidak akan begitu padat: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Oleh karena itu, seperti disebutkan di atas, dalam kode Python, perlu untuk memproses array menggunakan fungsi dari paket <code>numpy</code> . </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Dengan menggunakan contoh yang jelas dan sederhana, dimungkinkan untuk memverifikasi bahwa komunitas pengembang dan pengguna bahasa pemrograman Python (CPython) memiliki peluang nyata untuk secara signifikan mengurangi jumlah memori yang digunakan oleh objek. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455722/">https://habr.com/ru/post/id455722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455702/index.html">Pembuatan angka efektif dalam interval yang diberikan</a></li>
<li><a href="../id455710/index.html">Mengapa kita di Leroy Merlin membutuhkan departemen pengembangan Rusia kita sendiri untuk 200 orang</a></li>
<li><a href="../id455714/index.html">Ekspor Formulir Google secara otomatis ke Notion menggunakan IFTTT dan Django</a></li>
<li><a href="../id455716/index.html">15 Praktik Terbaik untuk Menyebarkan Perangkat Lunak Business Intelligence</a></li>
<li><a href="../id455720/index.html">Bagaimana kami membangun UI untuk sistem iklan</a></li>
<li><a href="../id455726/index.html">C ++ Edisi Perusahaan. Apakah mungkin?</a></li>
<li><a href="../id455728/index.html">Membuat Tombol Aksi Mengambang Anda Hampir Diperpanjang</a></li>
<li><a href="../id455730/index.html">Instal MacOS High Sierra ketika hanya tersedia WiFi</a></li>
<li><a href="../id455734/index.html">Kebiasaan melakukan sekarang</a></li>
<li><a href="../id455736/index.html">Konsensus dalam cryptocurrency dengan penambangan hybrid dan Multi-PoW</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>