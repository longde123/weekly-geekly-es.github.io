<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 😼 ™️ SObjectizer-5.6.0: Live schneiden, um weiter zu wachsen 🌆 👨🏾‍💼 👶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am dritten Tag wurde eine neue Version von SObjectizer verfügbar : 5.6.0 . Das Hauptmerkmal ist die Ablehnung der Kompatibilität mit dem vorherigen st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SObjectizer-5.6.0: Live schneiden, um weiter zu wachsen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453256/"><p><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p>  Am dritten Tag wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">neue Version von SObjectizer</a> verfügbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">: 5.6.0</a> .  Das Hauptmerkmal ist die Ablehnung der Kompatibilität mit dem vorherigen stabilen Zweig 5.5, der sich im Laufe von viereinhalb Jahren stetig weiterentwickelt hat. </p><br><p>  Die Grundprinzipien des Betriebs von SObjectizer-5 blieben unverändert.  Kommunikation, Agenten, Kooperationen und Disponenten sind immer noch bei uns.  Aber etwas ernsthaft geändert, etwas wurde allgemein weggeworfen.  Daher schlägt es fehl, nur SO-5.6.0 zu verwenden und Ihren Code neu zu kompilieren.  Etwas muss neu geschrieben werden.  Möglicherweise muss etwas neu gestaltet werden. </p><br><p>  Warum haben wir uns mehrere Jahre lang um die Kompatibilität gekümmert und dann beschlossen, alles zu nehmen und zu brechen?  Und was ist am gründlichsten kaputt gegangen? </p><br><p>  Ich werde versuchen, in diesem Artikel darüber zu sprechen. </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat">  Warum musstest du etwas kaputt machen? </h1><br><p>  So einfach ist das. </p><a name="habracut"></a><br><p>  SObjectizer-5.5 hat während seiner Entwicklung so viel von jedem anderen und vielfältigen aufgenommen, was ursprünglich nicht geplant war, dass es zu viele Krücken und Requisiten im Inneren gebildet hat.  Mit jeder neuen Version wurde es immer schwieriger, SO-5.5 etwas Neues hinzuzufügen.  Und schließlich zur Frage "Warum brauchen wir das alles?"  Es wurde keine passende Antwort gefunden. </p><br><p>  Der erste Grund ist also die erneute Komplikation der Innereien von SObjectizer. </p><br><p>  Der zweite Grund ist, dass wir es dumm sind, uns auf alte C ++ - Compiler zu konzentrieren.  Zweig 5.5 begann 2014, als wir, wenn ich mich nicht irre, gcc-4.8 und MSVS2013 hatten.  Auf dieser Ebene haben wir die Anforderungen an die Unterstützung des C ++ - Standards weiterhin beibehalten. </p><br><p>  Anfangs hatten wir „egoistisches Interesse“ daran.  Darüber hinaus betrachteten wir einige Zeit die geringen Anforderungen an die Qualität der Unterstützung für den C ++ - Standard als unseren "Wettbewerbsvorteil". </p><br><p>  Aber die Zeit vergeht, "egoistisches Interesse" ist vorbei.  Einige Vorteile eines solchen "Wettbewerbsvorteils" sind nicht sichtbar.  Vielleicht wären sie, wenn wir überhaupt mit C ++ 98 arbeiten würden, an blutigen Unternehmungen interessiert.  Aber das blutige Unternehmen in solchen wie uns ist im Prinzip nicht interessiert.  Daher wurde beschlossen, uns nicht mehr einzuschränken und etwas Frischeres zu nehmen.  Also haben wir im Moment den frischesten aus dem Stall genommen: C ++ 17. </p><br><p>  Offensichtlich wird diese Lösung nicht jedem gefallen, denn für viele C ++ 17 ist dies jetzt eine unerreichbare Vorderkante, die immer noch sehr, sehr weit entfernt ist. </p><br><p>  Trotzdem haben wir uns für ein solches Risiko entschieden.  Trotzdem geht der Prozess der Popularisierung von SObjectizer nicht schnell voran. Wenn SObjectizer mehr oder weniger gefragt ist, wird C ++ 17 keine "führende Kante" mehr sein.  Vielmehr wird es genauso behandelt wie jetzt in C ++ 11. </p><br><p>  Anstatt weiterhin Krücken mit einer Teilmenge von C ++ 11 zu bauen, haben wir uns im Allgemeinen entschlossen, die Interna von SObjectizer mit C ++ 17 ernsthaft neu zu gestalten.  Aufbau einer Basis, auf der sich SObjectizer in den nächsten vier oder fünf Jahren schrittweise entwickeln kann. </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56">  Was hat sich in SObjectizer-5.6 ernsthaft geändert? </h1><br><p>  Lassen Sie uns nun einige der auffälligsten Änderungen kurz betrachten. </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen">  Agentenkooperationen haben keine Zeichenfolgennamen mehr </h2><br><h3 id="problema">  Das Problem </h3><br><p>  SObjectizer-5 forderte von Anfang an, dass jede Kooperation einen eigenen eindeutigen Stringnamen hat.  Diese Funktion wurde vom fünften SObjectizer vom vorherigen vierten SObjectizer übernommen. </p><br><p>  Dementsprechend musste SObjectizer die Namen registrierter Kooperationen speichern.  Überprüfen Sie ihre Eindeutigkeit bei der Registrierung.  Suche nach namentlicher Zusammenarbeit bei der Abmeldung usw. usw. </p><br><p>  Seit den ersten Versionen wurde in SObjectzer-5 ein einfaches Schema verwendet: ein einziges Wörterbuch registrierter Kooperationen, die durch Mutex geschützt sind.  Bei der Registrierung einer Kooperation wird der Mutex erfasst, die Eindeutigkeit des Namens der Kooperation, die Anwesenheit eines Elternteils usw.  Nach der Überprüfung wird das Wörterbuch geändert, woraufhin der Mutex freigegeben wird.  Dies bedeutet, dass, wenn gleichzeitig die Registrierung / Abmeldung mehrerer Kooperationen gleichzeitig beginnt, sie an einigen Stellen pausieren und warten, bis eine der Operationen die Arbeit mit dem kooperativen Wörterbuch abgeschlossen hat.  Aus diesem Grund waren die kooperativen Operationen nicht gut skalierbar. </p><br><p>  Das wollte ich loswerden, um die Situation mit der Geschwindigkeit der Registrierung von Kooperationen zu verbessern. </p><br><h3 id="reshenie">  Lösung </h3><br><p>  Es wurden zwei Hauptwege zur Lösung dieses Problems in Betracht gezogen. </p><br><p>  Erstens das Speichern von Zeichenfolgennamen, aber das Ändern der Art und Weise, wie das Wörterbuch gespeichert wird, damit die Kooperationsregistrierungsoperation skaliert werden kann.  Zum Beispiel Wörterbuch-Sharding, d.h.  Brechen Sie es in mehrere Teile, von denen jedes durch seinen Mutex geschützt wäre. </p><br><p>  Zweitens eine vollständige Ablehnung von Zeichenfolgennamen und die Verwendung einiger von SObjectizer zugewiesener Bezeichner. </p><br><p> Infolgedessen haben wir uns für die zweite Methode entschieden und die Benennung von Genossenschaften vollständig aufgegeben.  Jetzt gibt es in SObjectizer so etwas wie <code>coop_handle</code> , d.h.  Ein Handle, dessen Inhalt dem Benutzer verborgen <code>std::weak_ptr</code> , das jedoch mit <code>std::weak_ptr</code> verglichen werden <code>std::weak_ptr</code> . </p><br><p>  SObjectizer gibt <code>coop_handle</code> wenn eine Zusammenarbeit registriert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p>  Dieser Handle sollte für die Abmeldung der Zusammenarbeit verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p>  Dieses Handle sollte auch beim Aufbau einer Eltern-Kind-Beziehung verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p>  Die Struktur des Repositorys für die Zusammenarbeit innerhalb der SObjectizer-Umgebung hat sich ebenfalls dramatisch geändert.  Wenn es vor Version 5.5 einschließlich ein gemeinsames Wörterbuch war, ist jetzt jede Kooperation ein Repository mit Links zu untergeordneten Kooperationen.  Das heißt,  Genossenschaften bilden einen Baum mit einer Wurzel in einer speziellen Wurzelgenossenschaft, die dem Benutzer verborgen bleibt. </p><br><p>  Eine solche Struktur ermöglicht es, die <code>deregister_coop</code> <code>register_coop</code> und <code>deregister_coop</code> viel besser zu skalieren: Die gegenseitige Blockierung paralleler Operationen erfolgt nur, wenn beide zur gleichen übergeordneten Zusammenarbeit gehören.  Der Klarheit halber ist hier das Ergebnis der Einführung eines <a href="" rel="nofollow">speziellen Benchmarks</a> , der die Leistung von Operationen mit Kooperationen auf meinem alten Laptop mit Ubuntu 16.04 und GCC-7.3 misst: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Das heißt,  Version 5.6.0 bewältigte fast 2 Millionen Kooperationen in ~ 15,5 Sekunden. </p><br><p>  Und hier ist Version 5.5.24.4, die letzte von Zweig 5.5 im Moment: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Das gleiche Szenario, aber das Ergebnis ist dreimal schlechter. </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov">  Es gibt nur noch eine Art von Disponenten </h2><br><p>  Dispatcher sind einer der Eckpfeiler von SObjectizer.  Es sind die Disponenten, die bestimmen, wo und wie Agenten ihre Nachrichten verarbeiten.  Ohne die Idee der Disponenten hätte es wahrscheinlich keinen SObjectizer gegeben. </p><br><p>  Die Disponenten selbst haben sich jedoch so weit entwickelt, dass es für uns nicht einmal schwierig war, einen neuen Dispatcher für SObjectizer-5.5 zu entwickeln.  Aber sehr mühsam.  Nehmen wir es jedoch in Ordnung. </p><br><p>  Zunächst konnten alle Dispatcher, die die Anwendung benötigte, erst zu Beginn des SObjectizer erstellt werden: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p>  Ich habe vor dem Start nicht den erforderlichen Dispatcher erstellt - alles, es ist meine Schuld, Sie können nichts ändern. </p><br><p>  Es ist klar, dass dies unpraktisch ist, und als die Verwendungsszenarien für SObjectizer erweitert wurden, musste dieses Problem gelöst werden.  Daher wurde die Methode <code>add_dispatcher_if_not_exists</code> , die das Vorhandensein eines Dispatchers prüfte und, falls keine vorhanden war, eine neue Instanz erstellen durfte: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Solche Disponenten wurden als öffentlich bezeichnet.  Öffentliche Disponenten hatten eindeutige Namen.  Und unter diesen Namen waren die Agenten an die Disponenten gebunden: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Aber öffentliche Disponenten hatten eine unangenehme Eigenschaft.  Sie begannen sofort nach dem Hinzufügen zur SObjectizer-Umgebung mit der Arbeit und arbeiteten weiter, bis die SObjectizer-Umgebung ihre Arbeit abgeschlossen hatte. </p><br><p>  Im Laufe der Zeit begann es wieder zu stören.  Es musste sichergestellt werden, dass Disponenten nach Bedarf hinzugefügt werden konnten und dass unnötige Disponenten automatisch gelöscht wurden. </p><br><p>  Es gab also "private" Disponenten.  Diese Disponenten hatten keine Namen und lebten, solange es Hinweise auf sie gab.  Private Dispatcher konnten jederzeit nach dem Start der SObjectizer-Umgebung erstellt werden, sie wurden automatisch zerstört. </p><br><p>  Im Allgemeinen erwiesen sich private Disponenten als sehr erfolgreiches Bindeglied in der Entwicklung der Disponenten, aber die Zusammenarbeit mit ihnen unterschied sich stark von der Arbeit mit öffentlichen Dispatchern: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Noch mehr private und öffentliche Disponenten unterschieden sich in der Umsetzung.  Um den Code nicht zu duplizieren und den öffentlichen und den privaten Dispatcher des gleichen Typs nicht getrennt zu schreiben, musste ich daher ziemlich komplexe Konstruktionen mit Vorlagen und Vererbung verwenden. </p><br><p>  Infolgedessen war diese ganze Sorte der Begleitung überdrüssig, und in SObjectizer-5.6 gab es nur noch eine Art von Dispatchern.  In der Tat ist dies ein Analogon von privaten Dispatchern.  Aber nur ohne ausdrückliche Erwähnung des Wortes "privat".  Das oben gezeigte Fragment wird nun wie folgt geschrieben: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic">  Es sind nur noch freie Funktionen send, send_delayed und send_periodic übrig </h2><br><p>  Die Entwicklung der API zum Senden von Nachrichten an SObjectizer ist wahrscheinlich das auffälligste Beispiel dafür, wie sich SObjectizer geändert hat, da sich die Unterstützung für C ++ 11 in den uns zur Verfügung stehenden Compilern verbessert hat. </p><br><p>  Zuerst wurden Nachrichten wie folgt gesendet: </p><br><pre> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p>  Oder wenn Sie den "Empfehlungen der besten Hundezüchter" (c) folgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p>  Dann standen uns jedoch Compiler mit Unterstützung für verschiedene Vorlagen zur Verfügung, und es erschienen Sendefunktionen.  Es wurde möglich, so zu schreiben: </p><br><pre> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p>  Es ist wahr, dass es eine ganze <code>send_to_agent</code> <code>send_delayed_to_agent</code> , bis eine ganze Familie aus dem einfachen <code>send</code> , einschließlich <code>send_to_agent</code> , <code>send_delayed_to_agent</code> usw.  Und um diese Familie auf den bekannten Satz von <code>send</code> , <code>send_delayed</code> und <code>send_periodic</code> . </p><br><p>  Trotz der Tatsache, dass die Familie der <code>deliver_message</code> langer Zeit gegründet wurde und seit mehreren Jahren die empfohlene Methode zum Senden von Nachrichten ist, standen dem Benutzer immer noch alte Methoden wie <code>deliver_message</code> , <code>schedule_timer</code> und <code>single_timer</code> zur Verfügung. </p><br><p>  In Version 5.6.0 wurden jedoch nur die Funktionen free <code>send</code> , <code>send_delayed</code> und <code>send_periodic</code> in der öffentlichen SObjectizer-API gespeichert.  Alles andere wurde entweder vollständig gelöscht oder in interne SObjectizer-Namespaces übertragen. </p><br><p>  In SObjectizer-5.6 ist die Schnittstelle zum Senden von Nachrichten endlich so geworden, wie es gewesen wäre, wenn wir von Anfang an Compiler mit normaler C ++ 11-Unterstützung gehabt hätten.  Nun, außerdem, wenn wir Erfahrung mit diesem ganz normalen C ++ 11 hatten. </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic">  Einzelformat send_delayed und send_periodic </h2><br><p>  Bei den <code>send_periodic</code> <code>send_delayed</code> und <code>send_periodic</code> in früheren Versionen von SObjectizer gab es einen weiteren Vorfall. </p><br><p>  Um den Timer verwenden zu können, müssen Sie Zugriff auf die SObjectizer-Umgebung haben.  Innerhalb des Agenten gibt es einen Link zur SObjectizer-Umgebung.  Und innerhalb von mchain gibt es einen solchen Link.  Aber in der Mbox war sie nicht da.  Wenn daher eine ausstehende Nachricht an einen Agenten oder an mchain <code>send_delayed</code> , <code>send_delayed</code> der Aufruf <code>send_delayed</code> : </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p>  Für den Fall von mbox mussten wir von irgendwo anders einen Link zur SObjectizer-Umgebung nehmen: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p>  Diese Funktion von <code>send_delayed</code> und <code>send_periodic</code> war ein kleiner Splitter.  Welches ist nicht so viel stören, aber nervig hübsch.  Und das alles, weil wir anfangs nicht damit begonnen haben, den Link zur SObjectizer-Umgebung in mbox-ahs zu speichern. </p><br><p>  Die Verletzung der Kompatibilität mit früheren Versionen war ein guter Grund, diesen Splitter loszuwerden. </p><br><p>  Jetzt können Sie in mbox herausfinden, für welche SObjectizer-Umgebung sie erstellt wurde.  Dies ermöglichte es, die einzelnen <code>send_periodic</code> <code>send_delayed</code> und <code>send_periodic</code> für jede Art von Timer-Nachrichtenempfänger zu verwenden: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p>  Im wahrsten Sinne des Wortes "eine Kleinigkeit, aber nett". </p><br><h2 id="net-bolshe-ad-hoc-agentov">  Keine Ad-hoc-Agenten mehr </h2><br><p>  Wie das Sprichwort sagt: "Jeder Unfall hat einen Vornamen, einen zweiten Vornamen und einen Nachnamen."  Bei Ad-hoc-Agenten ist dies mein Vor- und Nachname sowie mein Nachname :( </p><br><p>  Der Punkt ist dies.  Als wir in der Öffentlichkeit über SObjectizer-5 sprachen, hörten wir viele Vorwürfe über die Ausführlichkeit des Codes für die Beispiele von SObjectizer.  Und persönlich schien mir diese Ausführlichkeit ein ernstes Problem zu sein, mit dem ich mich ernsthaft befassen muss. </p><br><p>  Eine Quelle der Ausführlichkeit ist die Notwendigkeit, dass Agenten vom speziellen Basistyp <code>agent_t</code> .  Und davon scheint es kein Entrinnen zu geben.  Oder nicht? </p><br><p>  Es gab also Ad-hoc-Agenten, d.h.  Agenten, für deren Bestimmung es nicht notwendig war, eine separate Klasse zu schreiben, genügte es, nur die Reaktion auf Nachrichten in Form von Lambda-Funktionen einzustellen.  Das klassische Ping-Pong-Beispiel für Ad-hoc-Agenten könnte beispielsweise folgendermaßen geschrieben werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p>  Das heißt,  keine eigenen Klassen.  Wir rufen einfach <code>define_agent()</code> für die Zusammenarbeit auf und erhalten eine Art <code>define_agent()</code> , mit dem Sie eingehende Nachrichten abonnieren können. </p><br><p>  In SObjectizer-5 gab es also eine Trennung in reguläre und Ad-hoc-Agenten. </p><br><p>  Was keine sichtbaren Boni brachte, nur die zusätzlichen Arbeitskosten, die mit einer solchen Trennung einhergingen.  Und im Laufe der Zeit wurde klar, dass Ad-hoc-Agenten wie ein Koffer ohne Griff sind: Es ist schwer zu tragen und es ist schade, zu gehen.  Während der Arbeit an SObjectizer-5.6 wurde jedoch beschlossen, das Programm zu beenden. </p><br><p>  Gleichzeitig wurde eine weitere, vielleicht sogar noch wichtigere Lektion gelernt: An jeder öffentlichen Diskussion über das Tool im Internet wird eine große Anzahl von Personen teilnehmen, denen es gleichgültig ist, was das Tool ist, warum es benötigt wird, warum es so ist, wie es verwendet werden soll usw.  Es ist einfach wichtig für sie, ihre starke Meinung zu äußern.  Darüber hinaus ist es im russischsprachigen Segment des Internets nach wie vor sehr wichtig, den Entwicklern des Tools zu vermitteln, wie verrückt und ungebildet sie sind und wie sehr das Ergebnis ihrer Arbeit nicht benötigt wird. </p><br><p>  Daher sollten Sie sehr vorsichtig sein, was Ihnen gesagt wird.  Und Sie können nur genau das hören (und dann genau hören), was hier in diesem Sinne gesagt wird: "Ich habe versucht, dies auf Ihrem Instrument zu tun, und mir gefällt nicht, wie viel Code es hier hat."  Auch solche Wünsche sollten sehr sorgfältig behandelt werden: "Ich würde Ihre Entwicklung nehmen, wenn es hier und hier einfacher wäre." </p><br><p>  Leider war die Fähigkeit zum "Filtern", die "Gratulanten" im Internet vor etwa fünf Jahren sagten, viel geringer als heute.  Daher ein solches spezifisches Experiment wie Ad-hoc-Agenten in SObjectizer. </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov">  SObjectizer-5.6 unterstützt keine synchronisierte Agenteninteraktion mehr </h2><br><p>  Das Thema der synchronisierten Interaktion zwischen Agenten ist sehr alt und wund. </p><br><p>  Es begann in den Tagen von SObjectizer-4.  Und in SObjectizer-5 weiter.  Soweit endlich das sogenannte  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Serviceanfragen</a> .  Was anfangs zugegebenermaßen beängstigend war wie der Tod.  Aber dann habe ich es geschafft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">, ihnen einen mehr oder weniger anständigen Blick zu geben</a> . </p><br><p>  Dies stellte sich jedoch als der Fall heraus, als der erste Pfannkuchen klumpig herauskam :( </p><br><p>  In SObjectizer musste ich die Zustellung und Verarbeitung regulärer Nachrichten auf die eine und die Zustellung und Verarbeitung synchroner Anforderungen auf eine andere Weise implementieren.  Es ist besonders traurig, dass diese Funktionen berücksichtigt werden mussten, auch bei der Implementierung Ihrer eigenen mbox-s. </p><br><p>  Und nachdem die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionalität von Umschlagnachrichten</a> zu SObjectizer hinzugefügt wurde, wurde es notwendig, die Unterschiede zwischen regulären Nachrichten und synchronen Anforderungen noch häufiger und gründlicher zu untersuchen. </p><br><p>  Im Allgemeinen gab es bei synchronen Anforderungen während der Wartung / Entwicklung von SObjectizer zu viele Kopfschmerzen.  So sehr, dass zunächst der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">konkrete Wunsch bestand, diese sehr synchronen Anfragen loszuwerden</a> .  Und dann wurde dieser Wunsch verwirklicht. </p><br><p>  In SObjectizer-5.6 können Agenten also nur über asynchrone Nachrichten wieder interagieren. </p><br><p>  Und da manchmal noch so etwas wie synchrone Interaktion benötigt wird, wurde die Unterstützung für diese Art der Interaktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">an das begleitende so5extra-Projekt übermittelt</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p>  Das heißt,  Die Arbeit mit synchronen Anforderungen unterscheidet sich grundlegend darin, dass der Anforderungshandler keinen Wert wie zuvor von der Handler-Methode zurückgibt.  Stattdessen wird die Methode <code>make_reply</code> . </p><br><p>  Die neue Implementierung ist insofern gut, als sowohl die Anforderung als auch die Antwort wie normale asynchrone Nachrichten im SObjectizer gesendet werden.  Tatsächlich ist <code>make_reply</code> eine etwas spezifischere Implementierung von <code>send</code> . </p><br><p>  Und vor allem ermöglichte uns die neue Implementierung, Funktionen zu erhalten, die zuvor nicht erreichbar waren: </p><br><ul><li>  Synchrone Anforderungen (d. <code>request_reply_t&lt;Request, Reply&gt;</code> -Objekte) können jetzt gespeichert und / oder an andere Handler weitergeleitet werden.  Was macht es möglich, verschiedene Lastausgleichsschemata zu implementieren? </li><li>  Sie können die Antwort auf die Anfrage in einer regulären mbox des Agenten erhalten, der die Anfrage initiiert.  Und der initiierende Agent verarbeitet die Antwort wie jede andere Nachricht auf die übliche Weise. </li><li>  Sie können mehrere Anfragen gleichzeitig an verschiedene Empfänger senden und dann die Antworten von ihnen in der Reihenfolge analysieren, in der sie empfangen wurden: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p>  Wir können also sagen, dass bei der synchronen Interaktion in SObjectizer Folgendes passiert ist: </p><br><ul><li>  lange Zeit war er aus ideologischen Gründen weg; </li><li>  dann wurde es hinzugefügt und es stellte sich heraus, dass manchmal eine solche Interaktion nützlich ist; </li><li>  Die Erfahrung hat jedoch gezeigt, dass die erste Implementierung nicht sehr erfolgreich ist. </li><li>  Die alte Implementierung wurde komplett weggeworfen, und im Gegenzug wurde eine neue Implementierung vorgeschlagen. </li></ul><br><p>  Sie haben im Allgemeinen an ihren eigenen Fehlern gearbeitet. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  In diesem Artikel wurden ganz kurz einige Änderungen in SObjectizer-5.6.0 und die Gründe für diese Änderungen erläutert. </p><br><p>  Eine vollständigere Liste der Änderungen finden Sie <a href="" rel="nofollow">hier</a> . </p><br><p>  Abschließend möchte ich denjenigen, die SObjectizer noch nicht ausprobiert haben, anbieten, es zu nehmen und auszuprobieren.  Und teilen Sie uns Ihre Gefühle mit: Was Ihnen gefallen hat, was Ihnen nicht gefallen hat, was gefehlt hat. </p><br><p>  Wir hören uns alle konstruktiven Kommentare / Vorschläge genau an.  Darüber hinaus ist in SObjectizer in den letzten Jahren nur das enthalten, was jemand benötigt.  Wenn Sie uns also nicht mitteilen, was Sie in SObjectizer haben möchten, wird dies nicht angezeigt.  Und wenn du es mir sagst, wer weiß dann ...;) </p><br><p>  Das Projekt lebt und entwickelt sich jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> .  Und für diejenigen, die es gewohnt sind, nur GitHub zu verwenden, gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub-Spiegel</a> .  Dieser Spiegel ist völlig neu, so dass Sie den Mangel an Sternen ignorieren können. </p><br><p>  PS.  Sie können SObjectizer-bezogene Nachrichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">in dieser Google-Gruppe</a> verfolgen.  Dort können Sie Probleme im Zusammenhang mit SObjectizer ansprechen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453256/">https://habr.com/ru/post/de453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453242/index.html">Spielplatz für Sommerveranstaltungen</a></li>
<li><a href="../de453246/index.html">ERP - Continuous Degradation System</a></li>
<li><a href="../de453248/index.html">Artemis Lunar Mission - Produktion des Hauptelements der Mondorbitalstation Lunar Gateway gestartet</a></li>
<li><a href="../de453252/index.html">Wie wir das Sportmaster Club Programm gemacht haben</a></li>
<li><a href="../de453254/index.html">Über GOSTs Code, Grasshopper, seine SBox und verlorene Samen</a></li>
<li><a href="../de453258/index.html">Erstellen eines Reverb-Pedals mit PT2399-Chips (Teil 1)</a></li>
<li><a href="../de453260/index.html">DPI-Einstellungsfunktionen</a></li>
<li><a href="../de453262/index.html">Wo sind Ihre Konstanten auf dem CortexM-Mikrocontroller gespeichert (am Beispiel des C ++ IAR-Compilers)?</a></li>
<li><a href="../de453264/index.html">Virtuali-Tee: Ein „medizinisches T-Shirt“, das nicht bedeckt, sondern freilegt</a></li>
<li><a href="../de453272/index.html">GitHub-Sponsoren: Ein neuer Weg, um zu Open Source beizutragen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>