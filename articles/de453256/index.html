<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåù üòº ‚Ñ¢Ô∏è SObjectizer-5.6.0: Live schneiden, um weiter zu wachsen üåÜ üë®üèæ‚Äçüíº üë∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am dritten Tag wurde eine neue Version von SObjectizer verf√ºgbar : 5.6.0 . Das Hauptmerkmal ist die Ablehnung der Kompatibilit√§t mit dem vorherigen st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SObjectizer-5.6.0: Live schneiden, um weiter zu wachsen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453256/"><p><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p>  Am dritten Tag wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">neue Version von SObjectizer</a> verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">: 5.6.0</a> .  Das Hauptmerkmal ist die Ablehnung der Kompatibilit√§t mit dem vorherigen stabilen Zweig 5.5, der sich im Laufe von viereinhalb Jahren stetig weiterentwickelt hat. </p><br><p>  Die Grundprinzipien des Betriebs von SObjectizer-5 blieben unver√§ndert.  Kommunikation, Agenten, Kooperationen und Disponenten sind immer noch bei uns.  Aber etwas ernsthaft ge√§ndert, etwas wurde allgemein weggeworfen.  Daher schl√§gt es fehl, nur SO-5.6.0 zu verwenden und Ihren Code neu zu kompilieren.  Etwas muss neu geschrieben werden.  M√∂glicherweise muss etwas neu gestaltet werden. </p><br><p>  Warum haben wir uns mehrere Jahre lang um die Kompatibilit√§t gek√ºmmert und dann beschlossen, alles zu nehmen und zu brechen?  Und was ist am gr√ºndlichsten kaputt gegangen? </p><br><p>  Ich werde versuchen, in diesem Artikel dar√ºber zu sprechen. </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat">  Warum musstest du etwas kaputt machen? </h1><br><p>  So einfach ist das. </p><a name="habracut"></a><br><p>  SObjectizer-5.5 hat w√§hrend seiner Entwicklung so viel von jedem anderen und vielf√§ltigen aufgenommen, was urspr√ºnglich nicht geplant war, dass es zu viele Kr√ºcken und Requisiten im Inneren gebildet hat.  Mit jeder neuen Version wurde es immer schwieriger, SO-5.5 etwas Neues hinzuzuf√ºgen.  Und schlie√ülich zur Frage "Warum brauchen wir das alles?"  Es wurde keine passende Antwort gefunden. </p><br><p>  Der erste Grund ist also die erneute Komplikation der Innereien von SObjectizer. </p><br><p>  Der zweite Grund ist, dass wir es dumm sind, uns auf alte C ++ - Compiler zu konzentrieren.  Zweig 5.5 begann 2014, als wir, wenn ich mich nicht irre, gcc-4.8 und MSVS2013 hatten.  Auf dieser Ebene haben wir die Anforderungen an die Unterst√ºtzung des C ++ - Standards weiterhin beibehalten. </p><br><p>  Anfangs hatten wir ‚Äûegoistisches Interesse‚Äú daran.  Dar√ºber hinaus betrachteten wir einige Zeit die geringen Anforderungen an die Qualit√§t der Unterst√ºtzung f√ºr den C ++ - Standard als unseren "Wettbewerbsvorteil". </p><br><p>  Aber die Zeit vergeht, "egoistisches Interesse" ist vorbei.  Einige Vorteile eines solchen "Wettbewerbsvorteils" sind nicht sichtbar.  Vielleicht w√§ren sie, wenn wir √ºberhaupt mit C ++ 98 arbeiten w√ºrden, an blutigen Unternehmungen interessiert.  Aber das blutige Unternehmen in solchen wie uns ist im Prinzip nicht interessiert.  Daher wurde beschlossen, uns nicht mehr einzuschr√§nken und etwas Frischeres zu nehmen.  Also haben wir im Moment den frischesten aus dem Stall genommen: C ++ 17. </p><br><p>  Offensichtlich wird diese L√∂sung nicht jedem gefallen, denn f√ºr viele C ++ 17 ist dies jetzt eine unerreichbare Vorderkante, die immer noch sehr, sehr weit entfernt ist. </p><br><p>  Trotzdem haben wir uns f√ºr ein solches Risiko entschieden.  Trotzdem geht der Prozess der Popularisierung von SObjectizer nicht schnell voran. Wenn SObjectizer mehr oder weniger gefragt ist, wird C ++ 17 keine "f√ºhrende Kante" mehr sein.  Vielmehr wird es genauso behandelt wie jetzt in C ++ 11. </p><br><p>  Anstatt weiterhin Kr√ºcken mit einer Teilmenge von C ++ 11 zu bauen, haben wir uns im Allgemeinen entschlossen, die Interna von SObjectizer mit C ++ 17 ernsthaft neu zu gestalten.  Aufbau einer Basis, auf der sich SObjectizer in den n√§chsten vier oder f√ºnf Jahren schrittweise entwickeln kann. </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56">  Was hat sich in SObjectizer-5.6 ernsthaft ge√§ndert? </h1><br><p>  Lassen Sie uns nun einige der auff√§lligsten √Ñnderungen kurz betrachten. </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen">  Agentenkooperationen haben keine Zeichenfolgennamen mehr </h2><br><h3 id="problema">  Das Problem </h3><br><p>  SObjectizer-5 forderte von Anfang an, dass jede Kooperation einen eigenen eindeutigen Stringnamen hat.  Diese Funktion wurde vom f√ºnften SObjectizer vom vorherigen vierten SObjectizer √ºbernommen. </p><br><p>  Dementsprechend musste SObjectizer die Namen registrierter Kooperationen speichern.  √úberpr√ºfen Sie ihre Eindeutigkeit bei der Registrierung.  Suche nach namentlicher Zusammenarbeit bei der Abmeldung usw. usw. </p><br><p>  Seit den ersten Versionen wurde in SObjectzer-5 ein einfaches Schema verwendet: ein einziges W√∂rterbuch registrierter Kooperationen, die durch Mutex gesch√ºtzt sind.  Bei der Registrierung einer Kooperation wird der Mutex erfasst, die Eindeutigkeit des Namens der Kooperation, die Anwesenheit eines Elternteils usw.  Nach der √úberpr√ºfung wird das W√∂rterbuch ge√§ndert, woraufhin der Mutex freigegeben wird.  Dies bedeutet, dass, wenn gleichzeitig die Registrierung / Abmeldung mehrerer Kooperationen gleichzeitig beginnt, sie an einigen Stellen pausieren und warten, bis eine der Operationen die Arbeit mit dem kooperativen W√∂rterbuch abgeschlossen hat.  Aus diesem Grund waren die kooperativen Operationen nicht gut skalierbar. </p><br><p>  Das wollte ich loswerden, um die Situation mit der Geschwindigkeit der Registrierung von Kooperationen zu verbessern. </p><br><h3 id="reshenie">  L√∂sung </h3><br><p>  Es wurden zwei Hauptwege zur L√∂sung dieses Problems in Betracht gezogen. </p><br><p>  Erstens das Speichern von Zeichenfolgennamen, aber das √Ñndern der Art und Weise, wie das W√∂rterbuch gespeichert wird, damit die Kooperationsregistrierungsoperation skaliert werden kann.  Zum Beispiel W√∂rterbuch-Sharding, d.h.  Brechen Sie es in mehrere Teile, von denen jedes durch seinen Mutex gesch√ºtzt w√§re. </p><br><p>  Zweitens eine vollst√§ndige Ablehnung von Zeichenfolgennamen und die Verwendung einiger von SObjectizer zugewiesener Bezeichner. </p><br><p> Infolgedessen haben wir uns f√ºr die zweite Methode entschieden und die Benennung von Genossenschaften vollst√§ndig aufgegeben.  Jetzt gibt es in SObjectizer so etwas wie <code>coop_handle</code> , d.h.  Ein Handle, dessen Inhalt dem Benutzer verborgen <code>std::weak_ptr</code> , das jedoch mit <code>std::weak_ptr</code> verglichen werden <code>std::weak_ptr</code> . </p><br><p>  SObjectizer gibt <code>coop_handle</code> wenn eine Zusammenarbeit registriert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p>  Dieser Handle sollte f√ºr die Abmeldung der Zusammenarbeit verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p>  Dieses Handle sollte auch beim Aufbau einer Eltern-Kind-Beziehung verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p>  Die Struktur des Repositorys f√ºr die Zusammenarbeit innerhalb der SObjectizer-Umgebung hat sich ebenfalls dramatisch ge√§ndert.  Wenn es vor Version 5.5 einschlie√ülich ein gemeinsames W√∂rterbuch war, ist jetzt jede Kooperation ein Repository mit Links zu untergeordneten Kooperationen.  Das hei√üt,  Genossenschaften bilden einen Baum mit einer Wurzel in einer speziellen Wurzelgenossenschaft, die dem Benutzer verborgen bleibt. </p><br><p>  Eine solche Struktur erm√∂glicht es, die <code>deregister_coop</code> <code>register_coop</code> und <code>deregister_coop</code> viel besser zu skalieren: Die gegenseitige Blockierung paralleler Operationen erfolgt nur, wenn beide zur gleichen √ºbergeordneten Zusammenarbeit geh√∂ren.  Der Klarheit halber ist hier das Ergebnis der Einf√ºhrung eines <a href="" rel="nofollow">speziellen Benchmarks</a> , der die Leistung von Operationen mit Kooperationen auf meinem alten Laptop mit Ubuntu 16.04 und GCC-7.3 misst: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Das hei√üt,  Version 5.6.0 bew√§ltigte fast 2 Millionen Kooperationen in ~ 15,5 Sekunden. </p><br><p>  Und hier ist Version 5.5.24.4, die letzte von Zweig 5.5 im Moment: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Das gleiche Szenario, aber das Ergebnis ist dreimal schlechter. </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov">  Es gibt nur noch eine Art von Disponenten </h2><br><p>  Dispatcher sind einer der Eckpfeiler von SObjectizer.  Es sind die Disponenten, die bestimmen, wo und wie Agenten ihre Nachrichten verarbeiten.  Ohne die Idee der Disponenten h√§tte es wahrscheinlich keinen SObjectizer gegeben. </p><br><p>  Die Disponenten selbst haben sich jedoch so weit entwickelt, dass es f√ºr uns nicht einmal schwierig war, einen neuen Dispatcher f√ºr SObjectizer-5.5 zu entwickeln.  Aber sehr m√ºhsam.  Nehmen wir es jedoch in Ordnung. </p><br><p>  Zun√§chst konnten alle Dispatcher, die die Anwendung ben√∂tigte, erst zu Beginn des SObjectizer erstellt werden: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p>  Ich habe vor dem Start nicht den erforderlichen Dispatcher erstellt - alles, es ist meine Schuld, Sie k√∂nnen nichts √§ndern. </p><br><p>  Es ist klar, dass dies unpraktisch ist, und als die Verwendungsszenarien f√ºr SObjectizer erweitert wurden, musste dieses Problem gel√∂st werden.  Daher wurde die Methode <code>add_dispatcher_if_not_exists</code> , die das Vorhandensein eines Dispatchers pr√ºfte und, falls keine vorhanden war, eine neue Instanz erstellen durfte: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Solche Disponenten wurden als √∂ffentlich bezeichnet.  √ñffentliche Disponenten hatten eindeutige Namen.  Und unter diesen Namen waren die Agenten an die Disponenten gebunden: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Aber √∂ffentliche Disponenten hatten eine unangenehme Eigenschaft.  Sie begannen sofort nach dem Hinzuf√ºgen zur SObjectizer-Umgebung mit der Arbeit und arbeiteten weiter, bis die SObjectizer-Umgebung ihre Arbeit abgeschlossen hatte. </p><br><p>  Im Laufe der Zeit begann es wieder zu st√∂ren.  Es musste sichergestellt werden, dass Disponenten nach Bedarf hinzugef√ºgt werden konnten und dass unn√∂tige Disponenten automatisch gel√∂scht wurden. </p><br><p>  Es gab also "private" Disponenten.  Diese Disponenten hatten keine Namen und lebten, solange es Hinweise auf sie gab.  Private Dispatcher konnten jederzeit nach dem Start der SObjectizer-Umgebung erstellt werden, sie wurden automatisch zerst√∂rt. </p><br><p>  Im Allgemeinen erwiesen sich private Disponenten als sehr erfolgreiches Bindeglied in der Entwicklung der Disponenten, aber die Zusammenarbeit mit ihnen unterschied sich stark von der Arbeit mit √∂ffentlichen Dispatchern: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Noch mehr private und √∂ffentliche Disponenten unterschieden sich in der Umsetzung.  Um den Code nicht zu duplizieren und den √∂ffentlichen und den privaten Dispatcher des gleichen Typs nicht getrennt zu schreiben, musste ich daher ziemlich komplexe Konstruktionen mit Vorlagen und Vererbung verwenden. </p><br><p>  Infolgedessen war diese ganze Sorte der Begleitung √ºberdr√ºssig, und in SObjectizer-5.6 gab es nur noch eine Art von Dispatchern.  In der Tat ist dies ein Analogon von privaten Dispatchern.  Aber nur ohne ausdr√ºckliche Erw√§hnung des Wortes "privat".  Das oben gezeigte Fragment wird nun wie folgt geschrieben: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic">  Es sind nur noch freie Funktionen send, send_delayed und send_periodic √ºbrig </h2><br><p>  Die Entwicklung der API zum Senden von Nachrichten an SObjectizer ist wahrscheinlich das auff√§lligste Beispiel daf√ºr, wie sich SObjectizer ge√§ndert hat, da sich die Unterst√ºtzung f√ºr C ++ 11 in den uns zur Verf√ºgung stehenden Compilern verbessert hat. </p><br><p>  Zuerst wurden Nachrichten wie folgt gesendet: </p><br><pre> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p>  Oder wenn Sie den "Empfehlungen der besten Hundez√ºchter" (c) folgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p>  Dann standen uns jedoch Compiler mit Unterst√ºtzung f√ºr verschiedene Vorlagen zur Verf√ºgung, und es erschienen Sendefunktionen.  Es wurde m√∂glich, so zu schreiben: </p><br><pre> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p>  Es ist wahr, dass es eine ganze <code>send_to_agent</code> <code>send_delayed_to_agent</code> , bis eine ganze Familie aus dem einfachen <code>send</code> , einschlie√ülich <code>send_to_agent</code> , <code>send_delayed_to_agent</code> usw.  Und um diese Familie auf den bekannten Satz von <code>send</code> , <code>send_delayed</code> und <code>send_periodic</code> . </p><br><p>  Trotz der Tatsache, dass die Familie der <code>deliver_message</code> langer Zeit gegr√ºndet wurde und seit mehreren Jahren die empfohlene Methode zum Senden von Nachrichten ist, standen dem Benutzer immer noch alte Methoden wie <code>deliver_message</code> , <code>schedule_timer</code> und <code>single_timer</code> zur Verf√ºgung. </p><br><p>  In Version 5.6.0 wurden jedoch nur die Funktionen free <code>send</code> , <code>send_delayed</code> und <code>send_periodic</code> in der √∂ffentlichen SObjectizer-API gespeichert.  Alles andere wurde entweder vollst√§ndig gel√∂scht oder in interne SObjectizer-Namespaces √ºbertragen. </p><br><p>  In SObjectizer-5.6 ist die Schnittstelle zum Senden von Nachrichten endlich so geworden, wie es gewesen w√§re, wenn wir von Anfang an Compiler mit normaler C ++ 11-Unterst√ºtzung gehabt h√§tten.  Nun, au√üerdem, wenn wir Erfahrung mit diesem ganz normalen C ++ 11 hatten. </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic">  Einzelformat send_delayed und send_periodic </h2><br><p>  Bei den <code>send_periodic</code> <code>send_delayed</code> und <code>send_periodic</code> in fr√ºheren Versionen von SObjectizer gab es einen weiteren Vorfall. </p><br><p>  Um den Timer verwenden zu k√∂nnen, m√ºssen Sie Zugriff auf die SObjectizer-Umgebung haben.  Innerhalb des Agenten gibt es einen Link zur SObjectizer-Umgebung.  Und innerhalb von mchain gibt es einen solchen Link.  Aber in der Mbox war sie nicht da.  Wenn daher eine ausstehende Nachricht an einen Agenten oder an mchain <code>send_delayed</code> , <code>send_delayed</code> der Aufruf <code>send_delayed</code> : </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p>  F√ºr den Fall von mbox mussten wir von irgendwo anders einen Link zur SObjectizer-Umgebung nehmen: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p>  Diese Funktion von <code>send_delayed</code> und <code>send_periodic</code> war ein kleiner Splitter.  Welches ist nicht so viel st√∂ren, aber nervig h√ºbsch.  Und das alles, weil wir anfangs nicht damit begonnen haben, den Link zur SObjectizer-Umgebung in mbox-ahs zu speichern. </p><br><p>  Die Verletzung der Kompatibilit√§t mit fr√ºheren Versionen war ein guter Grund, diesen Splitter loszuwerden. </p><br><p>  Jetzt k√∂nnen Sie in mbox herausfinden, f√ºr welche SObjectizer-Umgebung sie erstellt wurde.  Dies erm√∂glichte es, die einzelnen <code>send_periodic</code> <code>send_delayed</code> und <code>send_periodic</code> f√ºr jede Art von Timer-Nachrichtenempf√§nger zu verwenden: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p>  Im wahrsten Sinne des Wortes "eine Kleinigkeit, aber nett". </p><br><h2 id="net-bolshe-ad-hoc-agentov">  Keine Ad-hoc-Agenten mehr </h2><br><p>  Wie das Sprichwort sagt: "Jeder Unfall hat einen Vornamen, einen zweiten Vornamen und einen Nachnamen."  Bei Ad-hoc-Agenten ist dies mein Vor- und Nachname sowie mein Nachname :( </p><br><p>  Der Punkt ist dies.  Als wir in der √ñffentlichkeit √ºber SObjectizer-5 sprachen, h√∂rten wir viele Vorw√ºrfe √ºber die Ausf√ºhrlichkeit des Codes f√ºr die Beispiele von SObjectizer.  Und pers√∂nlich schien mir diese Ausf√ºhrlichkeit ein ernstes Problem zu sein, mit dem ich mich ernsthaft befassen muss. </p><br><p>  Eine Quelle der Ausf√ºhrlichkeit ist die Notwendigkeit, dass Agenten vom speziellen Basistyp <code>agent_t</code> .  Und davon scheint es kein Entrinnen zu geben.  Oder nicht? </p><br><p>  Es gab also Ad-hoc-Agenten, d.h.  Agenten, f√ºr deren Bestimmung es nicht notwendig war, eine separate Klasse zu schreiben, gen√ºgte es, nur die Reaktion auf Nachrichten in Form von Lambda-Funktionen einzustellen.  Das klassische Ping-Pong-Beispiel f√ºr Ad-hoc-Agenten k√∂nnte beispielsweise folgenderma√üen geschrieben werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p>  Das hei√üt,  keine eigenen Klassen.  Wir rufen einfach <code>define_agent()</code> f√ºr die Zusammenarbeit auf und erhalten eine Art <code>define_agent()</code> , mit dem Sie eingehende Nachrichten abonnieren k√∂nnen. </p><br><p>  In SObjectizer-5 gab es also eine Trennung in regul√§re und Ad-hoc-Agenten. </p><br><p>  Was keine sichtbaren Boni brachte, nur die zus√§tzlichen Arbeitskosten, die mit einer solchen Trennung einhergingen.  Und im Laufe der Zeit wurde klar, dass Ad-hoc-Agenten wie ein Koffer ohne Griff sind: Es ist schwer zu tragen und es ist schade, zu gehen.  W√§hrend der Arbeit an SObjectizer-5.6 wurde jedoch beschlossen, das Programm zu beenden. </p><br><p>  Gleichzeitig wurde eine weitere, vielleicht sogar noch wichtigere Lektion gelernt: An jeder √∂ffentlichen Diskussion √ºber das Tool im Internet wird eine gro√üe Anzahl von Personen teilnehmen, denen es gleichg√ºltig ist, was das Tool ist, warum es ben√∂tigt wird, warum es so ist, wie es verwendet werden soll usw.  Es ist einfach wichtig f√ºr sie, ihre starke Meinung zu √§u√üern.  Dar√ºber hinaus ist es im russischsprachigen Segment des Internets nach wie vor sehr wichtig, den Entwicklern des Tools zu vermitteln, wie verr√ºckt und ungebildet sie sind und wie sehr das Ergebnis ihrer Arbeit nicht ben√∂tigt wird. </p><br><p>  Daher sollten Sie sehr vorsichtig sein, was Ihnen gesagt wird.  Und Sie k√∂nnen nur genau das h√∂ren (und dann genau h√∂ren), was hier in diesem Sinne gesagt wird: "Ich habe versucht, dies auf Ihrem Instrument zu tun, und mir gef√§llt nicht, wie viel Code es hier hat."  Auch solche W√ºnsche sollten sehr sorgf√§ltig behandelt werden: "Ich w√ºrde Ihre Entwicklung nehmen, wenn es hier und hier einfacher w√§re." </p><br><p>  Leider war die F√§higkeit zum "Filtern", die "Gratulanten" im Internet vor etwa f√ºnf Jahren sagten, viel geringer als heute.  Daher ein solches spezifisches Experiment wie Ad-hoc-Agenten in SObjectizer. </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov">  SObjectizer-5.6 unterst√ºtzt keine synchronisierte Agenteninteraktion mehr </h2><br><p>  Das Thema der synchronisierten Interaktion zwischen Agenten ist sehr alt und wund. </p><br><p>  Es begann in den Tagen von SObjectizer-4.  Und in SObjectizer-5 weiter.  Soweit endlich das sogenannte  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Serviceanfragen</a> .  Was anfangs zugegebenerma√üen be√§ngstigend war wie der Tod.  Aber dann habe ich es geschafft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">, ihnen einen mehr oder weniger anst√§ndigen Blick zu geben</a> . </p><br><p>  Dies stellte sich jedoch als der Fall heraus, als der erste Pfannkuchen klumpig herauskam :( </p><br><p>  In SObjectizer musste ich die Zustellung und Verarbeitung regul√§rer Nachrichten auf die eine und die Zustellung und Verarbeitung synchroner Anforderungen auf eine andere Weise implementieren.  Es ist besonders traurig, dass diese Funktionen ber√ºcksichtigt werden mussten, auch bei der Implementierung Ihrer eigenen mbox-s. </p><br><p>  Und nachdem die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionalit√§t von Umschlagnachrichten</a> zu SObjectizer hinzugef√ºgt wurde, wurde es notwendig, die Unterschiede zwischen regul√§ren Nachrichten und synchronen Anforderungen noch h√§ufiger und gr√ºndlicher zu untersuchen. </p><br><p>  Im Allgemeinen gab es bei synchronen Anforderungen w√§hrend der Wartung / Entwicklung von SObjectizer zu viele Kopfschmerzen.  So sehr, dass zun√§chst der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">konkrete Wunsch bestand, diese sehr synchronen Anfragen loszuwerden</a> .  Und dann wurde dieser Wunsch verwirklicht. </p><br><p>  In SObjectizer-5.6 k√∂nnen Agenten also nur √ºber asynchrone Nachrichten wieder interagieren. </p><br><p>  Und da manchmal noch so etwas wie synchrone Interaktion ben√∂tigt wird, wurde die Unterst√ºtzung f√ºr diese Art der Interaktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">an das begleitende so5extra-Projekt √ºbermittelt</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p>  Das hei√üt,  Die Arbeit mit synchronen Anforderungen unterscheidet sich grundlegend darin, dass der Anforderungshandler keinen Wert wie zuvor von der Handler-Methode zur√ºckgibt.  Stattdessen wird die Methode <code>make_reply</code> . </p><br><p>  Die neue Implementierung ist insofern gut, als sowohl die Anforderung als auch die Antwort wie normale asynchrone Nachrichten im SObjectizer gesendet werden.  Tats√§chlich ist <code>make_reply</code> eine etwas spezifischere Implementierung von <code>send</code> . </p><br><p>  Und vor allem erm√∂glichte uns die neue Implementierung, Funktionen zu erhalten, die zuvor nicht erreichbar waren: </p><br><ul><li>  Synchrone Anforderungen (d. <code>request_reply_t&lt;Request, Reply&gt;</code> -Objekte) k√∂nnen jetzt gespeichert und / oder an andere Handler weitergeleitet werden.  Was macht es m√∂glich, verschiedene Lastausgleichsschemata zu implementieren? </li><li>  Sie k√∂nnen die Antwort auf die Anfrage in einer regul√§ren mbox des Agenten erhalten, der die Anfrage initiiert.  Und der initiierende Agent verarbeitet die Antwort wie jede andere Nachricht auf die √ºbliche Weise. </li><li>  Sie k√∂nnen mehrere Anfragen gleichzeitig an verschiedene Empf√§nger senden und dann die Antworten von ihnen in der Reihenfolge analysieren, in der sie empfangen wurden: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p>  Wir k√∂nnen also sagen, dass bei der synchronen Interaktion in SObjectizer Folgendes passiert ist: </p><br><ul><li>  lange Zeit war er aus ideologischen Gr√ºnden weg; </li><li>  dann wurde es hinzugef√ºgt und es stellte sich heraus, dass manchmal eine solche Interaktion n√ºtzlich ist; </li><li>  Die Erfahrung hat jedoch gezeigt, dass die erste Implementierung nicht sehr erfolgreich ist. </li><li>  Die alte Implementierung wurde komplett weggeworfen, und im Gegenzug wurde eine neue Implementierung vorgeschlagen. </li></ul><br><p>  Sie haben im Allgemeinen an ihren eigenen Fehlern gearbeitet. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  In diesem Artikel wurden ganz kurz einige √Ñnderungen in SObjectizer-5.6.0 und die Gr√ºnde f√ºr diese √Ñnderungen erl√§utert. </p><br><p>  Eine vollst√§ndigere Liste der √Ñnderungen finden Sie <a href="" rel="nofollow">hier</a> . </p><br><p>  Abschlie√üend m√∂chte ich denjenigen, die SObjectizer noch nicht ausprobiert haben, anbieten, es zu nehmen und auszuprobieren.  Und teilen Sie uns Ihre Gef√ºhle mit: Was Ihnen gefallen hat, was Ihnen nicht gefallen hat, was gefehlt hat. </p><br><p>  Wir h√∂ren uns alle konstruktiven Kommentare / Vorschl√§ge genau an.  Dar√ºber hinaus ist in SObjectizer in den letzten Jahren nur das enthalten, was jemand ben√∂tigt.  Wenn Sie uns also nicht mitteilen, was Sie in SObjectizer haben m√∂chten, wird dies nicht angezeigt.  Und wenn du es mir sagst, wer wei√ü dann ...;) </p><br><p>  Das Projekt lebt und entwickelt sich jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> .  Und f√ºr diejenigen, die es gewohnt sind, nur GitHub zu verwenden, gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub-Spiegel</a> .  Dieser Spiegel ist v√∂llig neu, so dass Sie den Mangel an Sternen ignorieren k√∂nnen. </p><br><p>  PS.  Sie k√∂nnen SObjectizer-bezogene Nachrichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">in dieser Google-Gruppe</a> verfolgen.  Dort k√∂nnen Sie Probleme im Zusammenhang mit SObjectizer ansprechen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453256/">https://habr.com/ru/post/de453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453242/index.html">Spielplatz f√ºr Sommerveranstaltungen</a></li>
<li><a href="../de453246/index.html">ERP - Continuous Degradation System</a></li>
<li><a href="../de453248/index.html">Artemis Lunar Mission - Produktion des Hauptelements der Mondorbitalstation Lunar Gateway gestartet</a></li>
<li><a href="../de453252/index.html">Wie wir das Sportmaster Club Programm gemacht haben</a></li>
<li><a href="../de453254/index.html">√úber GOSTs Code, Grasshopper, seine SBox und verlorene Samen</a></li>
<li><a href="../de453258/index.html">Erstellen eines Reverb-Pedals mit PT2399-Chips (Teil 1)</a></li>
<li><a href="../de453260/index.html">DPI-Einstellungsfunktionen</a></li>
<li><a href="../de453262/index.html">Wo sind Ihre Konstanten auf dem CortexM-Mikrocontroller gespeichert (am Beispiel des C ++ IAR-Compilers)?</a></li>
<li><a href="../de453264/index.html">Virtuali-Tee: Ein ‚Äûmedizinisches T-Shirt‚Äú, das nicht bedeckt, sondern freilegt</a></li>
<li><a href="../de453272/index.html">GitHub-Sponsoren: Ein neuer Weg, um zu Open Source beizutragen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>