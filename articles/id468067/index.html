<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👜 🤦🏼 🤾🏽 Cara kerja penggabungan alfa 💪🏿 🚌 🤽🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transparansi mungkin tidak tampak seperti topik yang menarik. Format GIF, yang memungkinkan beberapa piksel bersinar melalui latar belakang, diterbitk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja penggabungan alfa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="gambar"></div><br>  Transparansi mungkin tidak tampak seperti topik yang menarik.  Format GIF, yang memungkinkan beberapa piksel bersinar melalui latar belakang, diterbitkan lebih dari 30 tahun yang lalu.  Hampir setiap aplikasi desain grafis yang dirilis selama dua dekade terakhir mendukung pembuatan konten yang tembus cahaya.  Konsep-konsep ini telah lama berhenti menjadi sesuatu yang baru. <br><br>  Dalam artikel saya, saya ingin menunjukkan bahwa sebenarnya transparansi dalam gambar digital jauh lebih menarik daripada yang terlihat - dalam apa yang kita anggap remeh, ada kedalaman dan keindahan yang tidak terlihat. <br><a name="habracut"></a><br><h1>  Opacity </h1><br>  Jika Anda pernah melihat melalui kacamata merah muda, maka Anda bisa melihat sesuatu yang mirip dengan apa yang ditunjukkan pada gambar di bawah ini.  [Dalam artikel asli, banyak gambar bersifat interaktif.] Coba gerakkan kacamata untuk melihat bagaimana mereka memengaruhi apa yang terlihat melalui mereka: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br>  Kacamata seperti ini berfungsi sebagai berikut: kacamata kehilangan warna merah, warna biru yang layak dan sedikit sekali warna hijau.  Matematika poin-poin ini dapat ditulis dalam satu set tiga persamaan.  Huruf <strong>R</strong> menunjukkan hasil operasi, dan huruf <strong>D</strong> menjelaskan poin yang sedang kita lihat.  Indeks RGB menunjukkan komponen merah, hijau, dan biru: <br><br><blockquote><code>R <sub>R</sub> = D <sub>R</sub> × 1.0 <br> R <sub>G</sub> = D <sub>G</sub> × 0.7 <br> R <sub>B</sub> = D <sub>B</sub> × 0.9</code> </blockquote> <br>  Kaca patri ini mentransmisikan komponen latar belakang merah, hijau, dan biru dengan berbagai kekuatan.  Dengan kata lain, <em>transparansi</em> kacamata merah muda tergantung pada warna cahaya yang terjadi.  Secara umum, transparansi dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bervariasi tergantung pada panjang gelombang cahaya</a> , tetapi dalam contoh sederhana ini, kami hanya tertarik pada bagaimana kacamata mempengaruhi komponen RGB klasik. <br><br>  Mensimulasikan perilaku kacamata hitam biasa jauh lebih sederhana, mereka biasanya hanya menipiskan cahaya kejadian dengan sejumlah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br>  Kacamata ini memungkinkan hanya 30% dari cahaya yang melewatinya.  Perilaku mereka dapat dijelaskan oleh persamaan berikut: <br><br><blockquote> <code>R <sub>R</sub> = D <sub>R</sub> × 0.3 <br> R <sub>G</sub> = D <sub>G</sub> × 0.3 <br> R <sub>B</sub> = D <sub>B</sub> × 0.3</code> </blockquote> <br>  Ketiga komponen warna dikurangi dengan nilai yang sama - penyerapan cahaya insiden adalah sama.  Kita dapat mengatakan bahwa kacamata gelap 30% transparan (buram) atau 70% buram.  <em>Opacity suatu</em> objek menentukan berapa banyak warna yang diblok.  Dalam grafik komputer, kami biasanya berurusan dengan model yang disederhanakan di mana hanya satu nilai yang diperlukan untuk menggambarkan properti ini.  Opacity dapat bervariasi secara spasial.  seperti, misalnya, kolom asap yang menjadi lebih tinggi dan lebih transparan. <br><br>  Di dunia nyata, objek dengan opacity 100% hanyalah buram dan mereka tidak mentransmisikan cahaya sama sekali.  Dunia gambar digital sedikit berbeda.  Ada kasus batas di dalamnya ketika bahkan benda buram padat melewati sejumlah cahaya. <br><br><h1>  Cakupan </h1><br>  Grafik vektor berhubungan dengan deskripsi bentuk yang jelas dan akurat tanpa batas yang didefinisikan menggunakan titik, segmen garis, kurva Bezier, dan matematika primitif lainnya.  Saat Anda perlu menampilkan gambar di layar komputer, entitas yang sempurna ini harus dirasterisasi menjadi bitmap: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>  <i>Rasterisasi bentuk vektor ke bitmap</i> <br><br>  Cara yang paling primitif untuk merasterisasi adalah memeriksa di mana sampel piksel berada - di dalam atau di luar bentuk vektor.  Pada contoh di bawah ini, Anda dapat menarik segitiga, dalam tampilan yang diperbesar, gerakannya akan lebih akurat.  Garis biru menunjukkan geometri vektor asli.  Seperti yang Anda lihat, tangga di tepi segitiga terlihat jelek dan sering berkedip ketika memindahkan geometri: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br>  Kerugian dari pendekatan ini adalah bahwa kami hanya melakukan satu pemeriksaan untuk setiap piksel yang ditampilkan, dan hasilnya didiskritkan ke salah satu dari dua nilai yang mungkin - di dalam atau di luar. <br><br>  Anda dapat mencicipi geometri vektor beberapa kali per piksel untuk mendapatkan gradasi langkah besar dan memutuskan bahwa beberapa piksel hanya ditutup <em>sebagian</em> .  Salah satu solusi yang mungkin adalah dengan menggunakan empat titik pengambilan sampel untuk mewakili lima tingkat cakupan: 0, <sup>1</sup> ⁄ <sub>4</sub> , <sup>2</sup> ⁄ <sub>4</sub> , <sup>3</sup> ⁄ <sub>4,</sub> dan 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br>  Kualitas tepi segitiga telah meningkat, tetapi hanya lima tingkat cakupan yang mungkin sering tidak cukup dan kita dapat dengan mudah mencapai hasil yang lebih baik.  Meskipun pandangan piksel sebagai kotak kecil di dunia pemrosesan sinyal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipandang dengan ketidaksetujuan</a> , dalam beberapa konteks itu adalah model yang berguna yang memungkinkan kita untuk menghitung cakupan tepat suatu piksel dengan geometri vektor.  Perpotongan garis dan bujur sangkar selalu dapat didekomposisi menjadi <i>trapesium</i> dan <i>persegi panjang</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="gambar"></div><br>  <i>Segmen garis membagi persegi menjadi trapesium dan persegi panjang</i> <br><br>  Anda dapat dengan mudah menghitung luas kedua bagian, dan jumlah mereka dibagi dengan luas persegi menentukan persentase cakupan piksel.  Dengan demikian, pertanggungan dihitung sebagai angka pasti dengan akurasi sewenang-wenang.  Dalam demo yang ditunjukkan di bawah ini, metode ini digunakan untuk membuat tepian yang jauh lebih baik yang tetap mulus bahkan ketika menyeret segitiga: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br>  Ketika datang ke bentuk yang lebih kompleks, misalnya, elips atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beziers</a> , mereka sering dibagi menjadi segmen garis lurus sederhana yang memungkinkan Anda untuk menghitung cakupan dengan akurasi yang tepat. <br><br>  Konsep cakupan parsial sangat penting untuk rendering grafik vektor berkualitas tinggi dan, yang lebih penting, untuk rendering teks.  Jika Anda mengambil tangkapan layar dari artikel ini dan mempertimbangkannya dengan saksama, Anda akan melihat bahwa hampir semua tepi piksel glyph hanya mencakup sebagian: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>  <i>Cakupan sebagian digunakan secara aktif dalam rendering teks</i> <br><br>  Memiliki opacity objek dan menutupinya dengan piksel individual, Anda dapat menggabungkannya menjadi satu nilai. <br><br><h1>  Alfa </h1><br>  Produk dari opacity dari suatu objek dan cakupan pixel-nya disebut <em>alpha</em> : <br><br><blockquote> <code> =  × </code> </blockquote> <br>  Objek dengan 60% opacity, mencakup 30% dari area pixel, memiliki nilai alpha 18% dalam pixel ini.  Secara alami, ketika objek transparan atau sepenuhnya tidak menutupi piksel, maka nilai alfa dalam piksel ini adalah 0. Setelah perkalian, perbedaan antara opacity dan coating menghilang, yang dalam arti membenarkan fakta bahwa konsep "alpha" dan "opacity" digunakan sebagai sinonim. <br><br>  Alpha sering direpresentasikan sebagai saluran keempat dari gambar bitmap.  Nilai biasa merah, hijau dan biru dilengkapi dengan nilai alpha, membentuk empat nilai RGBA. <br><br>  Ketika datang untuk menyimpan nilai alpha dalam memori, ada godaan untuk menggunakan hanya beberapa bit untuk ini.  Dalam hal menutupi piksel tepi benda-benda buram, tampaknya 4 atau bahkan 3 bit akan cukup, tergantung pada kerapatan piksel layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br>  Namun, opacity juga mempengaruhi nilai alfa, sehingga kedalaman bit yang rendah dapat menjadi bencana dalam beberapa kasus transparansi yang berubah dengan lancar.  Gambar di bawah ini menunjukkan gradien dari buram hitam menjadi putih, yang menunjukkan bahwa kedalaman bit rendah menghasilkan variasi warna yang sangat kuat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br>  Jelas, semakin banyak bit, semakin baik, dan paling sering alpha 8 menggunakan kedalaman 8 bit untuk mencocokkan akurasi komponen warna, itulah sebabnya mengapa banyak buffer RGBA menempati 32 bit per pixel.  Perlu juga dicatat bahwa, tidak seperti komponen warna, yang sering dikodekan menggunakan transformasi non-linear, alpha disimpan secara linier - nilai yang dikodekan dari 0,5 sesuai dengan nilai alpha dari 0,5. <br><br>  Berbicara tentang alfa, kami sepenuhnya mengabaikan semua komponen warna lainnya, tetapi selain memblokir warna latar belakang, piksel itu sendiri dapat menambahkan sedikit warna.  Idenya cukup sederhana - objek merah muda yang tembus cahaya menghalangi bagian dari pencahayaan latar belakang yang masuk dan memancarkan atau memantulkan sedikit cahaya merah muda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br>  Perhatikan bahwa itu <em>tidak</em> berperilaku seperti kaca patri.  Kaca hanya menghalangi bagian dari pencahayaan latar belakang dengan kecerahan yang berbeda.  Jika Anda melihat benda yang sepenuhnya hitam melalui kaca merah muda, maka kegelapannya akan tetap ada, karena benda hitam itu tidak memancarkan dan tidak memantulkan cahaya apa pun.  Namun, objek merah muda yang tembus cahaya <em>menambah</em> cahayanya sendiri.  Jika Anda meletakkannya di atas objek hitam, hasilnya akan menjadi merah muda.  Analog yang baik dari perilaku ini adalah bahan halus yang menggantung di udara, seperti kabut, asap, kabut, atau bubuk berwarna. <br><br>  Rendering saluran alpha sedikit lebih sulit - objek transparan sempurna tidak terlihat oleh definisi, jadi untuk membedakan antara objek, kita perlu menggunakan dua trik.  Latar belakang kotak-kotak menunjukkan bagian gambar mana yang transparan;  Pola ini digunakan dalam banyak aplikasi grafis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>  <i>Pola catur menunjukkan potongan transparan.</i> <br><br>  Empat kotak kecil di bawah gambar memberi tahu kita bahwa kita melihat komponen merah, hijau, biru dan alfa dari gambar.  Dalam beberapa kasus, akan berguna untuk melihat langsung nilai kanal alfa, dan cara termudah untuk menampilkannya menggunakan nuansa abu-abu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>  <i>Tampilkan nilai RGB dan A pada permukaan yang berbeda</i> <br><br>  Semakin cerah warna abu-abu, semakin tinggi nilai alfa, yaitu, hitam murni sesuai dengan 0% alfa, dan putih murni menjadi 100% alfa.  Kotak kecil menunjukkan bahwa komponen RGB dan A dari gambar dibagi menjadi dua bagian. <br><br>  Komponen alfa itu sendiri tidak terlalu berguna, tetapi menjadi sangat penting ketika kita berbicara tentang pengomposisian. <br><br><h1>  Pengomposisian sederhana </h1><br>  Sangat sedikit efek rendering 2D yang dapat diimplementasikan dalam satu operasi, dan untuk membuat hasil yang selesai, kami menggunakan proses penggabungan yang menggabungkan berbagai gambar.  Misalnya, tombol "Batal" sederhana dapat dibuat dengan mengomposisikan lima elemen terpisah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div><br>  <i>Elemen Pengomposisian untuk Tombol Batal</i> <br><br>  Pengomposisian sering dilakukan dalam beberapa tahap, di mana masing-masing dua gambar digabungkan.  Gambar latar depan yang digunakan dalam pengomposisian biasanya disebut <em>sumber</em> .  Gambar latar belakang yang digunakan dalam pengomposisian, di mana sumber dilapiskan, biasanya disebut <em>tujuan</em> . <br><br>  Kami akan mulai dengan mengomposisikan pada latar belakang buram, karena ini adalah kasus yang sangat umum.  Segala sesuatu yang Anda lihat di layar pada akhirnya ditumpangkan dengan mengkomposisikan pada tujuan buram. <br><br>  Ketika nilai alfa sumber adalah 100%, maka sumber itu buram dan harus sepenuhnya mencakup tujuan.  Jika nilai alfa adalah 0%, maka sumber sepenuhnya transparan dan tidak mempengaruhi tujuan dengan cara apa pun.  Nilai alfa 25% memungkinkan objek memancarkan 25% cahayanya dan melewatkan 75% cahayanya dari latar belakang, dan seterusnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>  <i>Menyusun sumber ungu dengan nilai alfa yang berbeda untuk tujuan kuning</i> <br><br>  Anda sudah dapat memahami apa yang akan terjadi - kasus sederhana pengomposisian alfa pada latar belakang buram - itu hanya interpolasi linier antara warna tujuan dan sumber.  Pada grafik di bawah ini, slider mengontrol nilai alpha dari sumber, dan grafik merah, hijau, dan biru menampilkan nilai-nilai komponen RGB.  Hasil <strong>R</strong> hanyalah campuran antara sumber <strong>S</strong> dan tujuan <strong>D</strong> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br>  Apa yang terjadi di sini dapat dijelaskan oleh persamaan yang ditunjukkan di bawah ini.  Seperti sebelumnya, indeks menunjukkan komponen, yaitu, S <sub>A</sub> adalah nilai alpha dalam sumber, dan <sub>DG</sub> adalah nilai hijau di tujuan: <br><br><blockquote> <code>R <sub>R</sub> = S <sub>R</sub> × S <sub>A</sub> + D <sub>R</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>G</sub> = S <sub>G</sub> × S <sub>A</sub> + D <sub>G</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>B</sub> = S <sub>B</sub> × S <sub>A</sub> + D <sub>B</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  Persamaan untuk komponen merah, hijau, dan biru memiliki penampilan yang sama, jadi Anda cukup menggunakan indeks <sub>RGB</sub> dan menggabungkannya menjadi satu baris: <br><br><blockquote> <code>R <sub>RGB</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  Selain itu, karena tujuan buram dan sudah memblokir semua cahaya latar belakang, kita tahu bahwa nilai alpha dari hasilnya selalu 1: <br><br><blockquote> <code>R <sub>A</sub> = 1</code> </blockquote> <br>  Pengomposisian pada latar belakang buram itu sederhana, tetapi kemampuannya cukup terbatas.  Dalam banyak kasus, diperlukan solusi yang lebih andal. <br><br><h1>  Buffer menengah </h1><br>  Gambar di bawah ini menunjukkan proses dua langkah pengomposisian tiga lapisan yang berbeda, berlabel A, B, dan C. Simbol mean akan berarti "ditumpangkan oleh pengomposisian pada": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>  <i>Hasil pengomposisian dua tahap dari tiga lapisan</i> <br><br>  Pertama kita overlay B dengan C dengan menyusun, dan kemudian overlay A dengan mereka untuk mendapatkan gambar selesai.  Dalam contoh berikut, kami akan melakukan hal-hal sedikit berbeda.  Pertama, kita akan menghubungkan dua lapisan teratas dengan mengkomposisikan, dan kemudian menampilkan hasilnya pada tujuan terakhir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>  <i>Hasil pengomposisian dua tahap dari tiga lapisan dalam urutan yang berbeda</i> <br><br>  Anda mungkin bertanya-tanya apakah situasi seperti itu muncul dalam praktik, tetapi sebenarnya itu sangat umum.  Banyak operasi pengomposisian non-sepele dan efek rendering, seperti masking dan blur, mengharuskan melewati buffer perantara yang hanya berisi sebagian hasil pengompositan.  Konsep ini memiliki nama yang berbeda: melewati layar, lapisan transparansi, atau penyangga samping, tetapi biasanya mereka didasarkan pada ide yang sama. <br><br>  Yang lebih penting bagi kami adalah bahwa hampir <em>semua</em> gambar dengan transparansi dapat dianggap sebagai hasil parsial dari beberapa rendering, yang nantinya akan ditumpangkan dengan mengkomposisikan pada tujuan terakhir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>  <i>Pengomposisian sebagian tombol ke clipboard</i> <br><br>  Kita perlu memahami bagaimana cara mengganti penggabungan gambar tembus A dan B dengan satu gambar (A (B) yang memiliki warna dan opacity yang sama.  Mari kita mulai dengan menghitung nilai alpha buffer akhir. <br><br><h1>  Menggabungkan nilai alpha </h1><br>  Mungkin tidak jelas bagi Anda cara menggabungkan opacity dari dua objek, tetapi lebih mudah untuk membicarakan tugas ini jika kita berbicara tentang transparansi. <br><br>  Misalkan sejumlah cahaya melewati objek pertama, dan kemudian melalui objek kedua.  Jika transparansi objek pertama adalah 80%, maka akan melewati 80% dari cahaya insiden.  Demikian pula, objek kedua dengan transparansi 60% akan memungkinkan 60% dari cahaya melewatinya, yang memberi kita 60% × 80% = 48% dari cahaya asli.  Anda dapat bereksperimen dengan transparansi di artikel asli;  jangan lupa bahwa slider mengontrol <em>transparansi</em> dan bukan opacity objek di jalur cahaya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br>  Secara alami, ketika objek pertama atau kedua buram, tidak ada cahaya yang melewati mereka, bahkan yang lain benar-benar transparan. <br><br>  Jika objek D memiliki transparansi D <sub>T</sub> , dan objek S memiliki transparansi S <sub>T</sub> , maka transparansi umum akhir RT <sub>dari</sub> kedua objek ini sama dengan produk mereka: <br><br><blockquote>  R <sub>T</sub> = D <sub>T</sub> × S <sub>T</sub> </blockquote><br>  Namun, transparansi hanyalah unit minus alpha, jadi substitusi memberi kita yang berikut: <br><br><blockquote>  1 - R <sub>A</sub> = (1 - D <sub>A</sub> ) × (1 - S <sub>A</sub> ) </blockquote><br>  Ungkapan ini dapat diperluas menjadi: <br><br><blockquote>  1 - R <sub>A</sub> = 1 - D <sub>A</sub> - S <sub>A</sub> + D <sub>A</sub> × S <sub>A</sub> </blockquote><br>  Dan sederhanakan seperti ini: <br><br><blockquote>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> - D <sub>A</sub> × S <sub>A</sub> </blockquote><br>  Itu dapat direduksi menjadi satu dari dua jenis yang serupa: <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> × (1 - S <sub>A</sub> ) <br><br>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> × (1 - D <sub>A</sub> ) </blockquote><br>  Segera kita akan melihat bahwa yang kedua lebih sering digunakan.  Menarik juga untuk dicatat bahwa nilai alpha yang dihasilkan tidak tergantung pada urutan relatif objek - opacity dari piksel yang dihasilkan adalah sama, bahkan jika Anda menukar sumber dan tujuan.  Ini sangat logis.  Cahaya yang melewati dua objek harus memudar dengan cara yang sama, dari sisi bintang mana pun, dari depan atau dari belakang. <br><br><h1>  Kombinasi warna </h1><br>  Menghitung alpha tidak begitu sulit, jadi mari kita coba memahami perhitungan komponen RGB.  Gambar sumber memiliki warna S <sub>RGB</sub> , tetapi opacity S <sub>A</sub> hanya memaksa produk dari kedua nilai ini ke dalam hasil akhir: <br><br><blockquote>  S <sub>RGB</sub> × S <sub>A</sub> </blockquote><br>  Gambar tujuan memiliki warna D <sub>RGB</sub> , opacity membuatnya memancarkan cahaya D <sub>RGB</sub> × D <sub>A</sub> , namun, bagian dari cahaya diblokir oleh opacity gambar S, sehingga semua pengaruh tujuan sama dengan: <br><br><blockquote>  D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  Kontribusi total cahaya dari S dan D sama dengan jumlah mereka: <br><br><blockquote>  S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  Demikian pula, kontribusi dari layer yang digabungkan sama dengan warna mereka kali opacity mereka: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> </blockquote><br>  Kami ingin kedua nilai ini cocok: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  Apa yang memberi kita persamaan terakhir: <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> × (1 - S <sub>A</sub> ) <br><br>  R <sub>RGB</sub> = (S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> )) / R <sub>A</sub> </blockquote><br>  Lihat betapa rumitnya persamaan kedua!  Perhatikan bahwa untuk mendapatkan nilai RGB dari hasil, kita perlu membaginya dengan nilai alpha.  Namun, untuk tahap berikutnya dari compositin, perkalian dengan nilai alpha akan diperlukan lagi, karena hasil dari operasi saat ini akan menjadi sumber atau tujuan baru dari operasi selanjutnya.  Itu hanya jelek. <br><br>  Mari kita kembali ke bentuk hampir akhir R <sub>RGB</sub> sebentar: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  Sumber, tujuan, <em>dan</em> hasil dikalikan dengan komponen alfa mereka.  Ini membuat kita mengerti bahwa warna dan alpha dari pixel "suka" untuk bersama, jadi kita perlu mengambil langkah mundur dan memikirkan kembali cara kita menyimpan informasi warna. <br><br><h1>  Alfa prapultiplied </h1><br>  Ingatlah bahwa kita berbicara tentang opacity - jika objek sebagian buram, maka kontribusinya terhadap hasil juga akan parsial.  Konsep Premultiplied alpha (“pre-multiplication by alpha”) mengimplementasikan ide ini.  Nilai-nilai komponen RGB, seperti namanya, adalah pra-dikalikan dengan komponen alpha.  Mari kita mulai dengan warna tanpa multiplikasi awal: <br><br><blockquote>  (1,00, 0,80, 0,30, 0,40) </blockquote><br>  Perkalian awal oleh alpha memberi kita hal berikut: <br><br><blockquote>  (0,40, 0,32, 0,12, 0,40) </blockquote><br>  Mari kita lihat beberapa piksel sekaligus.  Gambar di bawah ini menunjukkan bagaimana informasi warna disimpan tanpa terlebih dahulu mengalikan alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>  <i>Informasi RGB dan A dalam gambar tanpa perkalian sebelumnya</i> <br><br>  Perhatikan bahwa area di mana alfa adalah 0 dapat memiliki nilai RGB sewenang-wenang, seperti yang dapat dilihat dari gangguan hijau dan biru pada gambar.  Dalam kasus perkalian awal dengan alpha, informasi warna juga menyimpan nilai opacity pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>  <i>Informasi RGB dan A dalam gambar yang sudah dikalikan</i> <br><br>  Alfa prapultiplied kadang-kadang disebut alpha yang berasosiasi, dan alfa non-premultiplied kadang-kadang disebut alfa lurus atau tidak berhubungan. <br><br>  Ketika komponen alfa warna adalah 0, perkalian awal mengatur ulang semua komponen lain, terlepas dari nilainya: <br><br><blockquote>  (0,0, 0,0, 0,0, 0,0) </blockquote><br>  Dalam kasus alfa yang telah ditiru sebelumnya, hanya ada <em>satu</em> warna yang benar-benar transparan, dan ini menawan. <br><br>  Keuntungan dari pemrosesan komponen warna ini secara bertahap akan menjadi jelas bagi Anda, tetapi sebelum kita kembali ke contoh pengomposisian, mari kita lihat bagaimana alfa yang dikultipultasikan sebelumnya membantu memecahkan beberapa masalah rendering lainnya. <br><br><h2>  Penyaringan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaussian blur</a> adalah cara populer untuk membuat latar belakang yang tidak fokus dengan menarik atau untuk mengurangi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frekuensi tinggi</a> bagian latar belakang dari isi beberapa elemen UI.  Seperti yang akan kita lihat, pra-mengalikan alpha sangat penting untuk menciptakan blur yang tampak benar. <br><br>  Gambar yang akan kita analisis dibuat dengan mengisi latar belakang dengan 1% biru buram, di mana lingkaran merah buram digambar.  Pertama, mari kita lihat sebuah contoh tanpa multiplikasi awal.  Saya memisahkan saluran RGB dari saluran alfa untuk memahami apa yang sedang terjadi.  Tanda panah menunjukkan operasi blur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>  <i>Mengaburkan konten tanpa multiplikasi sebelumnya</i> <br><br>  Hasil akhirnya memiliki lingkaran cahaya biru jelek.  Itu terjadi karena latar belakang biru bocor ke area merah selama blur, dan hanya pada <em>saat itu</em> , selama pengomposisian, bobot alfa ditambahkan ke dalamnya. <br><br>  Ketika warna dikalikan dengan alpha, hasilnya benar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konten buram pra-dikalikan</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena pra-multiplikasi, warna biru gambar dikurangi menjadi 1% dari kekuatan aslinya, sehingga pengaruhnya pada warna lingkaran kabur sangat kecil.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merender gambar yang pikselnya cocok dengan tujuan adalah tugas sederhana karena kita perlu melakukan pemetaan satu-ke-satu yang sepele antara sampel. </font><font style="vertical-align: inherit;">Masalah muncul ketika tidak ada pemetaan sederhana, misalnya, karena rotasi, penskalaan, atau tanda hubung. </font><font style="vertical-align: inherit;">Gambar di bawah ini menunjukkan bahwa piksel gambar yang diputar yang ditunjukkan oleh garis merah tidak lagi sesuai dengan tujuan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orientasi gambar relatif dan piksel tujuan sebelum dan sesudah rotasi.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada banyak cara untuk memilih warna dari gambar yang akan ditulis ke piksel tujuan, dan yang paling sederhana adalah yang disebut interpolasi tetangga terdekat, di mana sebagai piksel terakhir, sampel terdekat dalam tekstur dipilih secara sederhana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam demonstrasi di bawah ini, garis merah menunjukkan posisi gambar di tujuan. Sisi kanan menunjukkan posisi sampel dari sudut pandang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gambar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dengan menyeret bilah geser (dalam artikel asli), Anda dapat memutar segi empat dan mengamati bagaimana sampel memilih warna dari bitmap. Saya menyoroti satu piksel dalam sumber dan tujuan, sehingga hubungan mereka lebih jelas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi ini cukup fungsional dan pikselnya memiliki warna holistik, tetapi kualitasnya tidak dapat diterima. Akan lebih baik menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolasi bilinear</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menghitung rata-rata tertimbang dari empat piksel terdekat dari gambar sampel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berfungsi lebih baik, tetapi tepi di sekitar persegi panjang tidak terlihat benar, isi piksel bergabung tanpa perkalian, karena alpha "diterapkan" setelah interpolasi. Terkadang solusi yang disarankan untuk menggabungkan warna konten yang tepat, yang ditunjukkan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel menakjubkan oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adrian Correger [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjemahan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Habré], jauh dari ideal - tidak ada satu warna pun di celah antara persegi panjang merah dan biru yang akan terlihat benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat bagaimana semuanya akan terlihat dalam gambar dengan alfa yang sudah di-preultiplied dan pengomposisian dengan rumus lanjutan, yang akan segera kita dapatkan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempurna - kami menyingkirkan semua perpaduan warna dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gigi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak terlihat </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, masalah yang terkait dengan blur dan interpolasi terkait erat. </font><font style="vertical-align: inherit;">Operasi apa pun yang membutuhkan kombinasi warna tembus cahaya, tanpa terlebih dahulu mengalikan warna dengan alfa, cenderung memberikan hasil yang salah.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengomposisian yang tepat </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke penggabungan. </font><font style="vertical-align: inherit;">Kami menetapkan persamaan yang hampir diturunkan:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda membayangkan warna menggunakan alfa yang telah ditiru sebelumnya, maka semua perkalian yang tidak nyaman ini akan hilang, karena alfa sudah menjadi bagian dari nilai warna. </font><font style="vertical-align: inherit;">Lalu kami mendapatkan yang berikut:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita lihat persamaan alfa: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koefisien untuk saluran merah, hijau, biru, dan alfa adalah sama, sehingga kami dapat mengekspresikan seluruh ekspresi dengan satu persamaan dan hanya ingat bahwa setiap komponen menjalani operasi yang sama: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat bagaimana alpha yang di-preultiplied membuat segalanya mudah. </font><font style="vertical-align: inherit;">Saat kami menganalisis komponen persamaan, semuanya ada di tempatnya. </font><font style="vertical-align: inherit;">Operasi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menutupi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bagian dari cahaya latar belakang dan menambahkan cahaya baru:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi pencampuran ini disebut source-over, sover atau hanya normal, dan itu tanpa diragukan lagi adalah mode penggabungan yang paling umum. </font><font style="vertical-align: inherit;">Hampir semua yang Anda lihat di situs web saya tercampur dalam mode ini.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asosiatif </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti source-over penting yang dilakukan pada warna pra-alfa dikalikan adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asosiatif dari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operasi ini. </font><font style="vertical-align: inherit;">Berkat dia, dalam persamaan pencampuran kompleks, kita dapat menempatkan tanda kurung sepenuhnya secara sewenang-wenang. </font><font style="vertical-align: inherit;">Semua komposisi yang ditunjukkan di bawah ini adalah setara:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (((A⇨B) ⇨C) ⇨D) ⇨E </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (A⇨B) ⇨ (C⇨ (D⇨E)) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = A⇨ (B⇨ (C⇨ (D⇨E)) )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buktinya cukup sederhana, tapi saya tidak akan membebani Anda dengan manipulasi aljabar. </font><font style="vertical-align: inherit;">Dalam praktiknya, ini berarti bahwa kita dapat membuat sebagian gambar yang kompleks tanpa takut bahwa komposisi akhir akan terlihat salah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam sebagian besar kasus, alpha digunakan hanya untuk pengomposisian menggunakan source-over, tetapi keuntungannya tidak berakhir di situ. </font><font style="vertical-align: inherit;">Nilai alfa juga dapat digunakan untuk operasi rendering lain yang bermanfaat.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter-Duff Compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada Juli 1984, Thomas Porter dan Tom Duff menerbitkan artikel aslinya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Compositing Digital Images</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">" </font></a><font style="vertical-align: inherit;">Para penulis tidak hanya pertama-tama memperkenalkan konsep alfa yang diultipultipulasikan dan menurunkan persamaan pengompositian sumber, tetapi juga mempresentasikan seluruh keluarga operasi pengompositan alfa, banyak di antaranya sedikit diketahui, meskipun sangat bermanfaat. </font><font style="vertical-align: inherit;">Fungsi baru juga disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena, seperti menambah atau mengalikan, mereka melakukan tindakan pada nilai input untuk membuat nilai output.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berakhir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh di masa mendatang, kami akan menggunakan demo interaktif yang menunjukkan operasi berbagai mode campuran. </font><font style="vertical-align: inherit;">Gambar tujuan akan menjadi simbol "klub" hitam, dan gambar sumber akan menjadi simbol "cacing" merah. </font><font style="vertical-align: inherit;">Anda dapat menarik hati ke atas gambar dan mengamati bagaimana bentuk tumpang tindih berperilaku di bawah berbagai operator pengomposit. </font><font style="vertical-align: inherit;">Perhatikan minimap kecil di sudut. </font><font style="vertical-align: inherit;">Beberapa blending mode sangat merusak dan mudah membingungkan. </font><font style="vertical-align: inherit;">Minimalap selalu menunjukkan hasil pengomposisian sumber-sederhana, yang menyederhanakan pemahaman:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda beralih ke tujuan-lebih, maka Anda akan segera menyadari bahwa itu hanya "membalik" sumber-lebih - tujuan dan sumber ditukar dalam persamaan dan hasilnya setara dengan apa yang akan kita anggap tujuan sebagai gambar sumber. </font><font style="vertical-align: inherit;">Meskipun tampak berlebihan, operator tujuan-lebih sangat berguna karena memungkinkan Anda untuk membuat objek yang berada di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bawah</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konten yang ada.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keluar </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pernyataan sumber-keluar dan tujuan-keluar sangat bagus untuk meninju lubang pada sumber atau tujuan: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari dua operator ini, Destination-out lebih nyaman karena menggunakan saluran alpha untuk membuat lubang di formulir tujuan. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masuk </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator source-in dan destination-in pada dasarnya adalah masking operator: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mereka membuatnya cukup mudah untuk membuat persimpangan geometri nontrivial yang kompleks tanpa menyelesaikan persimpangan vektor kontur yang relatif sulit. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di atas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator </font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan Anda untuk overlay konten baru pada yang sudah ada, sambil menyembunyikannya di sepanjang jalur tujuan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR operator ( </font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) toko </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber, atau tujuan, dan daerah tumpang tindih mereka menghilang:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber, Tujuan, Jelas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga mode pengomposisian klasik terakhir cukup membosankan. </font></font><code>Source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, juga disebut </font></font><code>copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hanya mengambil sumber warna. </font><font style="vertical-align: inherit;">Demikian pula, ia </font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengabaikan sumber warna dan hanya mengembalikan </font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Operator </font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya membersihkan semuanya:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = S </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = D </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = 0 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan mode-mode ini terbatas. </font><font style="vertical-align: inherit;">Dengan menggunakannya </font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat membersihkan buffer yang terisi, tetapi operasi ini dapat dioptimalkan dengan hanya mengisi memori dengan nol. </font><font style="vertical-align: inherit;">Selain itu, dalam beberapa kasus </font></font><code>source</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih ekonomis dalam perhitungan, karena tidak memerlukan pencampuran, tetapi hanya mengganti isi buffer dengan informasi sumber.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter Duff beraksi </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah berurusan dengan masing-masing operator, mari kita lihat bagaimana Anda dapat menggabungkannya. </font><font style="vertical-align: inherit;">Pada contoh di bawah ini, kita akan menggambar logo laut tanpa menggunakan masking atau bentuk geometris yang kompleks. </font><font style="vertical-align: inherit;">Garis biru menunjukkan geometri sederhana yang sedang dibuat. </font><font style="vertical-align: inherit;">Anda dapat menelusuri langkah-langkah dengan mengklik di sisi kanan gambar, dan kembali dengan mengklik di sebelah kiri:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentu saja, kita sama sekali tidak berkewajiban untuk meninggalkan topeng dan memangkas kontur, tetapi kita sering melupakan alat seperti mode pengomposisian Porter-Duff, meskipun jauh lebih mudah untuk membuat beberapa efek visual dengan bantuan mereka. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda melihat lebih dekat pada operator Porter-Duff, Anda akan melihat bahwa mereka semua memiliki bentuk yang sama. </font><font style="vertical-align: inherit;">Sumber selalu dikalikan dengan faktor F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan ditambahkan ke tujuan, dikalikan dengan faktor F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D × F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat mengambil nilai-nilai 0, 1, D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin sama dengan 0, 1, S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau 1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tidak masuk akal untuk melipatgandakan sumber atau tujuan dengan alpha mereka sendiri, karena mereka sudah pra-dikalikan, dan kami hanya mendapatkan efek mewah, tetapi tidak sangat berguna dari alpha kuadrat. </font><font style="vertical-align: inherit;">Semua operator dapat direpresentasikan dalam bentuk tabel:</font></font><br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  0 </td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jelas </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber-in </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber-keluar </font></font></td></tr><tr><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan </font></font></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan-lebih </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan-dalam </font></font></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan-di atas </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan-keluar </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber-lebih </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sumber di atas </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xor </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan simetri operator pada diagonal. </font><font style="vertical-align: inherit;">Empat elemen sentral dalam tabel hilang dan itu terjadi karena mereka berbeda dari yang lain.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencahayaan tambahan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel mereka, Porter dan Duff menghadirkan operator lain di mana F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 1. Dikenal dengan namanya </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>plus-lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = S + D </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi ini pada dasarnya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambahkan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penerangan sumber ke tujuan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencahayaan tambahan diimplementasikan dengan operator</font></font><code><em>plus</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hijau dan merah dengan benar membentuk kuning, sedangkan hijau dan biru membentuk cyan. </font><font style="vertical-align: inherit;">Hitam adalah tidak adanya operasi, itu tidak mengubah nilai warna dengan cara apa pun, karena menambahkan nol ke angka tidak mengubah apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga operator yang tersisa tidak diberi nama karena mereka tidak terlalu berguna. </font><font style="vertical-align: inherit;">Mereka hanya kombinasi masker dan campuran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu juga dicatat bahwa alfa yang di-preultipip memungkinkan kita untuk menggunakan operator dengan </font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cara yang tidak terduga. </font><font style="vertical-align: inherit;">Mari kita lihat persamaannya lagi:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami berhasil membuat nilai alpha di sumber sama dengan nol, maka jika ada nilai-nilai non-nol di saluran RGB, kami dapat mencapai pencahayaan tambahan tanpa menggunakan operator </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencahayaan tambahan yang diterapkan menggunakan operator.</font></font><code><em>source-over</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhatikan bahwa Anda harus berhati-hati di sini - nilainya tidak lagi dikalikan dengan alpha dengan benar. Dalam beberapa program, mungkin ada optimasi yang benar-benar menghindari pencampuran warna dengan nol alpha, sementara program lain dapat membalikkan pra-kalikan dengan nilai alpha, melakukan beberapa operasi warna, dan kemudian dikalikan lagi dengan alpha, yang sepenuhnya menghancurkan saluran warna. Mungkin juga sulit untuk mengekspor sumber daya dalam format ini, jadi jika Anda tidak memiliki kendali penuh atas pipa render, maka Anda harus tetap menggunakan operator </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua elemen yang kita diskusikan sejauh ini telah dikombinasikan dengan baik. </font><font style="vertical-align: inherit;">Sekarang, lepaskan kacamata merah muda kami dan diskusikan beberapa masalah yang perlu dipertimbangkan ketika bekerja dengan alpha compositing.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keburaman grup </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita lihat gambar pil sederhana ini yang terdiri dari hanya enam primitif: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar pil menggunakan bentuk sederhana.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kita diminta membuat pil dengan opacity 50%, maka kita mungkin tergoda untuk hanya membagi opacity menjadi setengah dari setiap operasi draw, tetapi ini akan berubah menjadi keputusan yang salah:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil tak terduga dari membuat pil dengan setengah opacity.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk mencapai hasil yang benar, kita tidak bisa hanya mendistribusikan opacity suatu objek ke masing-masing komponen individualnya. </font><font style="vertical-align: inherit;">Pertama-tama kita perlu membuat objek, merendernya menjadi bitmap, dan baru </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemudian</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengubah opacity bitmap, dan akhirnya melakukan penggabungan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil yang diharapkan dari pemberian pil dengan setengah opacity.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah kasus lain yang menunjukkan kegunaan konsep rendering ke dalam buffer sisi.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cakupan Pengomposisian </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengubah tutup geometrik menjadi nilai alpha tunggal memiliki konsekuensi yang tidak nyaman. </font><font style="vertical-align: inherit;">Pertimbangkan kasus ketika dua sisi geometri vektor yang cocok, yang ditunjukkan pada gambar di bawah ini dengan kontur oranye dan biru, dirender menjadi bitmap. </font><font style="vertical-align: inherit;">Di dunia yang ideal, hasilnya akan terlihat seperti ini, karena setiap piksel benar-benar tertutup:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil render yang ideal dengan cakupan yang benar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namun, jika kita pertama kali membuat geometri oranye dan kemudian biru, maka pada gambar akhir sedikit latar belakang putih masih akan bocor ke piksel batas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil penggabungan dua tahap</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Segera setelah lapisan disimpan dalam saluran alfa, semua informasi geometrisnya hilang, dan kami tidak dapat memulihkannya dengan cara apa pun. Geometri biru hanya bercampur dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> isi buffer, tetapi tidak tahu bahwa geometri yang diwakili oleh piksel kemerahan harus cocok dengan itu. Masalah ini terutama terlihat ketika geometri saling tumpang tindih satu sama lain. Pada gambar di bawah ini, lingkaran putih digambar di atas yang hitam. Tepi gelap terlihat, meskipun kedua lingkaran memiliki </font><font style="vertical-align: inherit;">jari-jari dan posisi yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama persis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkaran putih yang digambar di atas lingkaran hitam.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salah satu cara untuk memperbaiki masalah ini adalah dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menghitung cakupan parsial piksel dan menggunakan buffer yang jauh lebih besar. Dengan rasterisasi vektor geometri dengan lapisan masuk / keluar sederhana, dan kemudian mengurangi skala hasil ke ukuran gambar asli, Anda dapat mencapai hasil yang diharapkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, untuk perbandingan sempurna kualitas rendering tepi saluran alpha 8-bit, buffer harus 256 kali lebih besar di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedua</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arah, yaitu, jumlah piksel harus meningkat 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kali. </font><font style="vertical-align: inherit;">Seperti yang kita lihat di atas, sambil mengurangi kedalaman bit untuk nilai cakupan, Anda masih bisa mendapatkan hasil yang memuaskan, jadi dalam praktiknya Anda dapat menggunakan skala yang lebih kecil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu juga dicatat bahwa masalah seperti itu seringkali relatif mudah dihindari tanpa menggunakan bitmap yang besar. </font><font style="vertical-align: inherit;">Misalnya, alih-alih menggambar dua lingkaran yang dilapiskan, Anda bisa menggambar dua kotak di atas satu sama lain, dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemudian</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menutupi hasilnya untuk membentuk lingkaran.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nilai linear </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda telah memperbarui pengetahuan tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang warna</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda dapat mengingat bahwa sebagian besar dari mereka mengkodekan nilai warna secara non-linear, dan linierisasi awal diperlukan untuk melakukan operasi matematika yang benar. </font><font style="vertical-align: inherit;">Ketika tahap ini selesai, hasil pengomposisian adalah sebagai berikut; </font><font style="vertical-align: inherit;">perhatikan warna kekuningan yang indah dari bagian yang saling menempel:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkaran merah fuzzy ditumpangkan dengan mengkomposisikan pada latar belakang hijau menggunakan nilai-nilai linier.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namun, dalam kebanyakan kasus, pengomposisian </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demikian. </font><font style="vertical-align: inherit;">Cara standar untuk web dan sebagian besar perangkat lunak grafis adalah dengan langsung mencampurkan nilai-nilai non-linear:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkaran merah kabur yang ditumpangkan oleh komposer pada latar belakang hijau menggunakan nilai-nilai non-linear.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhatikan bahwa area di mana overlay merah pada hijau jauh lebih gelap. </font><font style="vertical-align: inherit;">Mereka jauh dari ideal, tetapi dalam beberapa kasus, operasi yang salah berakar dalam memahami bagaimana kita memandang warna. </font><font style="vertical-align: inherit;">Misalnya, 50% abu-abu buram dari ruang sRGB terlihat persis seperti hitam murni dengan 50% opacity dicampur dengan latar belakang putih:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengomposisian dua warna pada latar belakang putih</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tanpa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linierisasi</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada gambar di bawah ini, warna sRGB gambar sumber dan tujuan dilinearisasi dan kemudian dikonversi kembali ke pengkodean non-linear untuk tampilan. </font><font style="vertical-align: inherit;">Begini tampilan warna-warna ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komposisi dua warna pada latar belakang putih</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linierisasi.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memiliki perbedaan yang tidak memenuhi harapan kami. </font><font style="vertical-align: inherit;">Satu-satunya cara untuk mendapatkan keseragaman visual menggunakan metode ini adalah dengan memilih semua warna menggunakan nilai linier, tetapi ini sangat berbeda dari apa yang digunakan semua orang. </font><font style="vertical-align: inherit;">50% abu-abu dengan nilai linier terlihat seperti abu-abu di 73,5% dari ruang sRGB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, Anda harus sangat berhati-hati saat bekerja dengan alfa yang telah di-preultiplied. </font><font style="vertical-align: inherit;">Pra-penggandaan harus dilakukan dengan </font><font style="vertical-align: inherit;">nilai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu </font><font style="vertical-align: inherit;">sebelum coding ke non-linear. </font><font style="vertical-align: inherit;">Karena ini, langkah linierisasi akan berakhir dengan benar dengan nilai linier yang benar, yang sebelumnya dikalikan dengan alpha.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Premultiplied Alpha dan Bit Depth </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun memiliki kegunaan yang bagus untuk mengomposit, memfilter, dan interpolasi, alpha yang di-pra-tipipkan bukanlah “peluru perak” dan memiliki kekurangannya. </font><font style="vertical-align: inherit;">Yang paling serius adalah pengurangan kedalaman warna yang bisa dibayangkan. </font><font style="vertical-align: inherit;">Bayangkan penyandian 8-bit dari nilai 150, yang dikalikan dengan alpha 20%. </font><font style="vertical-align: inherit;">Setelah perkalian awal dengan alpha, kita dapatkan</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bulat (150 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kami mengulangi prosedur yang sama dengan nilai 151, kami mendapatkan: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bulat (151 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai yang dikodekan akan sama, meskipun ada perbedaan dalam nilai awal. </font><font style="vertical-align: inherit;">Bahkan, setelah dikalikan dengan alpha, nilai 148, 149, 150, 151 dan 152 dikodekan menjadi 30, dan perbedaan asli antara lima warna unik ini hilang:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pra-penggandaan dengan alfa 20% mengurangi berbagai nilai 8-bit menjadi satu.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara alami, semakin kecil alfa, semakin destruktif efeknya. Dari kisaran yang mungkin 256 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sekitar 4,3 miliar) dari berbagai kombinasi nilai RGBA 8-bit, setelah perkalian awal dengan alpha, hanya 25,2% yang mempertahankan representasi unik; pada kenyataannya, kita kehilangan hampir 2 bit dari kisaran 32-bit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengkonversi warna antara ruang warna yang berbeda, kadang-kadang perlu untuk membalikkan perkalian awal, yaitu, membagi nilai dengan komponen alfa untuk mendapatkan kecerahan warna asli. Langkah ini diperlukan karena, sebagaimana disebutkan di atas, pengkodean dilakukan secara non-linear. Adanya pra-penggandaan mengurangi keakuratan representasi warna dan konversi antara ruang warna bisa tidak sempurna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam praktiknya, mengurangi kedalaman bit jarang penting, terutama dalam penggabungan. Semakin rendah nilai alfa, semakin sedikit warna yang terlihat, dan semakin sedikit pengaruhnya pada pengomposisian. Pada akhirnya, jika Anda berusaha keras untuk operasi warna yang akurat, Anda tidak akan menggunakan representasi 8-bit - untuk tujuan ini, format jauh lebih cocok.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">titik mengambang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bacaan tambahan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep saluran alpha diciptakan oleh pendiri studio Pixar, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Artikel Smith </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Alpha and History of Digital Compositing”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjelaskan sejarah penemuan dan sumber-sumber nama “alpha”, serta bagaimana konsep-konsep ini berevolusi dan secara bertahap menggantikan konsep </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topeng</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam produksi film </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami arti alfa, saya sangat menyarankan Anda membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Interpreting Alpha"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karya Andrew Glassner </font><font style="vertical-align: inherit;">. Artikel ini memberikan derivasi matematis alfa yang ketat tetapi sangat mudah diakses sebagai ukuran interaksi antara opacity dan cakupan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskusi terperinci tentang alfa yang telah diultipultipulasikan dapat dieksplorasi</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"GPU lebih suka premultiplikasi" oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eric Haines. </font><font style="vertical-align: inherit;">Artikel ini tidak hanya memberikan gambaran yang sangat baik tentang masalah yang disebabkan oleh </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurangnya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perkalian awal, terutama dalam rendering 3D, tetapi juga menyediakan tautan ke banyak artikel lain tentang topik ini.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulannya </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, artikel ini dimaksudkan sebagai penjelasan dari operator pengomposisian Porter-Duff, tetapi semua konsep lain yang terkait dengan pengomposisian alfa ternyata sangat menarik sehingga saya tidak dapat melewatkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang paling saya sukai dari alpha adalah itu hanya angka tambahan yang menyertai komponen RGB, tetapi pada saat yang sama ia menciptakan banyak kemampuan rendering yang unik. </font><font style="vertical-align: inherit;">Alpha benar-benar menciptakan perubahan peluang baru di dunia lama yang membosankan dari penggabungan dan rendering 2D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lain kali Anda melihat tepi halus bentuk vektor atau melihat overlay gelap yang menggelapkan beberapa bagian antarmuka pengguna, pikirkan komponen kecil namun kuat yang memungkinkan semuanya terjadi.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468067/">https://habr.com/ru/post/id468067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468053/index.html">Pembelajaran Mesin untuk berburu flat Anda. Bagian 1</a></li>
<li><a href="../id468057/index.html">Pengembangan OS seperti Unix - Multitasking dan panggilan sistem (7)</a></li>
<li><a href="../id468061/index.html">Cron di Linux: History, Usage, dan Device</a></li>
<li><a href="../id468063/index.html">Angulareact</a></li>
<li><a href="../id468065/index.html">Model manajemen produk mental untuk semua orang</a></li>
<li><a href="../id468071/index.html">Eduard Medvedev, CTO di Tungsten Labs: "Kami telah berkembang ke titik di mana teknologi dapat menyebabkan kerusakan besar"</a></li>
<li><a href="../id468073/index.html">Andrei Terekhov: "Anda dapat mengatakan sebanyak mungkin bahwa orang Amerika itu lebih baik, tetapi mobil kami tidak pernah mogok"</a></li>
<li><a href="../id468075/index.html">Penggunaan jaringan saraf siam dalam pencarian</a></li>
<li><a href="../id468077/index.html">Posit tes dengan cara dewasa. Analisis spektral</a></li>
<li><a href="../id468079/index.html">Dimensi khusus di Google Analytics yang menyelamatkan kami lebih dari sekali</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>