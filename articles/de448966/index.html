<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèø üòø üö∞ Android App im Speicher. Optimierungsbericht f√ºr Yandex.Luncher üöá üëØ üìã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das leichte Android Go-System stellt erh√∂hte Anforderungen an vorinstallierte Anwendungen - Gr√∂√üe und Speicher. Wir standen vor der Herausforderung, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android App im Speicher. Optimierungsbericht f√ºr Yandex.Luncher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/448966/">  Das leichte Android Go-System stellt erh√∂hte Anforderungen an vorinstallierte Anwendungen - Gr√∂√üe und Speicher.  Wir standen vor der Herausforderung, diese Anforderungen zu erf√ºllen.  Wir haben eine Reihe von Optimierungen durchgef√ºhrt und beschlossen, die Architektur unserer grafischen Shell - Yandex.Luncher - ernsthaft zu √§ndern.  Der Leiter des Entwicklungsteams f√ºr mobile Anwendungen, Alexander Starchenko, teilte diese Erfahrung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N0KQBUZE78E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Mein Name ist Alexander, ich komme aus St. Petersburg, aus dem Team, das Yandex.Loncher und Yandex.Phone entwickelt.  Heute werde ich Ihnen erz√§hlen, wie wir den Speicher in Launcher optimiert haben.  Zun√§chst erkl√§re ich kurz, was Launcher ist.  Als n√§chstes diskutieren wir die Gr√ºnde, warum wir den Speicher optimieren m√ºssen.  Danach werden wir √ºberlegen, wie das Ged√§chtnis richtig gemessen wird und woraus es besteht.  Dann lass uns weiter √ºben.  Ich werde dar√ºber sprechen, wie wir das Ged√§chtnis in Launcher optimiert haben und wie wir zu einer radikalen L√∂sung des Problems gekommen sind.  Und am Ende werde ich dar√ºber sprechen, wie wir die Speichernutzung √ºberwachen und wie wir sie unter Kontrolle halten. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/xr/t0/xs/xrt0xsqk_pktna1g_ggaf3rd780.jpeg"><br><br>  "Launcher" oder "Launcher" - nicht so wichtig.  Wir bei Yandex haben ihn Launcher genannt, und im Bericht werde ich das Wort "Launcher" verwenden. <br><br><img src="https://habrastorage.org/webt/h8/dr/cg/h8drcg1kc0mm6cmr6zxew8g60gs.jpeg"><br><br>  Ein weiterer wichtiger Punkt: Launcher ist √ºber Voreinstellungen weit verbreitet, dh wenn Sie ein neues Telefon kaufen, kann sich Yandex.Loncher h√§ufig als der einzige Anwendungsmanager und Home-Desktop-Manager auf Ihrem Telefon herausstellen. <br><br>  Nun zu den Gr√ºnden, warum wir den Speicher optimieren m√ºssen.  Ich werde mit unserem Grund beginnen.  Kurz gesagt, das ist Android Go.  Und jetzt l√§nger.  Ende 2017 stellte Google Android Oreo und seine spezielle Version, die Android Oreo Go Edition, vor.  Was ist das Besondere daran?  Diese Version wurde f√ºr Low-End-Telefone mit bis zu einem Gigabyte RAM entwickelt.  Was ist sie sonst noch besonders?  F√ºr Anwendungen, die auf dieser Android-Version vorinstalliert sind, stellt Google zus√§tzliche Anforderungen.  Insbesondere - die Anforderungen an den RAM-Verbrauch.  Grob gesagt wird einige Zeit nach dem Start der Speicher der Anwendung entfernt, und die Gr√∂√üe sollte f√ºr Launcher 30-50 Megabyte nicht √ºberschreiten, abh√§ngig von der Gr√∂√üe des Telefonbildschirms.  30 auf den kleinsten, 50 auf den gro√üen Bildschirmen. <br><br>  Es sollte auch beachtet werden, dass Google diesen Bereich weiterentwickelt und es bereits eine Android Pie Go-Edition gibt. <br><br>  Welche anderen Gr√ºnde k√∂nnte es f√ºr die Optimierung der Speichernutzung geben?  Erstens ist es weniger wahrscheinlich, dass Ihre Anwendung heruntergeladen wird.  Zweitens wird es schneller funktionieren, da es weniger wahrscheinlich ist, dass der Garbage Collector funktioniert und der Speicher weniger h√§ufig zugewiesen wird.  Zus√§tzliche Objekte werden nicht erstellt, zus√§tzliche Ansichten werden nicht aufgeblasen usw. Nach unserer Erfahrung f√ºhrt dies indirekt zu einer Verringerung der apk-Gr√∂√üe Ihrer Anwendung.  All dies zusammen bietet Ihnen mehr Installationen und bessere Bewertungen bei Google Play. <br><br>  Ok, jetzt wissen wir, warum wir den Speicher optimieren m√ºssen.  Mal sehen, mit welchen Mitteln man es misst und woraus es besteht. <br><br><img src="https://habrastorage.org/webt/k5/ne/mc/k5nemcimfyrquzgc_jdeijvo0mq.jpeg"><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sub></sup> </h5><br>  Wahrscheinlich haben viele von Ihnen dieses Bild gesehen.  Dies ist ein Screenshot von Android Studio Profile aus einer Speicheransicht.  Dieses Tool wird auf developer.android.com ausf√ºhrlich beschrieben.  Wahrscheinlich haben viele von Ihnen sie benutzt.  Wer nicht benutzt - versuchen. <br><br>  Was ist hier gut?  Es ist immer zur Hand.  Es ist bequem im Entwicklungsprozess zu verwenden.  Es hat jedoch einige Nachteile.  Hier sind nicht alle Zuordnungen Ihrer Anwendung sichtbar.  Beispielsweise sind heruntergeladene Schriftarten hier nicht sichtbar.  Mit Hilfe dieses Tools ist es auch unpraktisch zu sehen, welche Klassen in den Speicher geladen werden, und Sie k√∂nnen dieses Tool nicht im automatischen Modus verwenden, dh Sie k√∂nnen keine Art von automatischem Test basierend auf dem Android Studio-Profil konfigurieren. <br><br><img src="https://habrastorage.org/webt/-g/hh/gz/-ghhgzcyruqxpu3trjt_ipssimi.jpeg"><h5>  <sup><sub>Links von der Folie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitens</a></sub></sup> </h5><br>  Das folgende Tool existiert seit der Android-Entwicklung in Eclipse, kurz Memory Analyzer, MAT.  Es wird als eigenst√§ndige Anwendung bereitgestellt und ist mit Speicherabbildern kompatibel, die Sie in Android Studio speichern k√∂nnen. <br><br>  Dazu ben√∂tigen Sie ein kleines Dienstprogramm, einen professionellen Konverter.  Es kommt mit der Android Go Edition und hat mehrere Vorteile.  Beispielsweise k√∂nnen Pfade zu gs-Wurzeln erstellt werden.  Es hat uns sehr geholfen, genau zu sehen, welche Klassen von Launcher geladen werden und wann sie geladen werden.  Mit dem Android Studio Profiler konnten wir dies nicht tun. <br><br><img src="https://habrastorage.org/webt/4r/uj/gz/4rujgzsgzvpcrxk6f5izyljrb8y.jpeg"><br><br>  Das n√§chste Tool ist das Dienstprogramm dumpsys, insbesondere dumpsys meminfo.  Hier sehen Sie einen Teil der Ausgabe dieses Befehls.  Es bietet ein ziemlich hohes Wissen √ºber den Speicherverbrauch.  Es hat jedoch bestimmte Vorteile.  Es ist bequem im automatischen Modus zu verwenden.  Sie k√∂nnen problemlos Tests konfigurieren, die diesen Befehl einfach aufrufen.  Au√üerdem wird der Speicher f√ºr alle Prozesse sofort angezeigt.  Und zeigt alle Standorte.  Soweit wir wissen, verwendet Google den Testwert dieses Tools im Testprozess. <br><br>  Lassen Sie uns anhand eines Ausgabebeispiels kurz beschreiben, woraus der Anwendungsspeicher besteht.  Der erste ist Java Heap, alle Speicherorte Ihres Java- und Kotlin-Codes.  Normalerweise ist dieser Abschnitt gro√ü genug.  Als n√§chstes kommt der Native Heap.  Hier sind Zuordnungen aus dem nativen Code.  Auch wenn Sie in Ihrer Anwendung keinen expliziten nativen Code verwenden, sind hier Zuordnungen vorhanden, da viele Android-Objekte - dieselbe Ansicht - nativen Speicher zuweisen.  Der n√§chste Abschnitt ist Code.  Alles, was mit dem Code zu tun hat, wird hier angezeigt: Bytecode, Schriftarten.  Code kann auch sehr gro√ü sein, wenn Sie viele nicht optimierte Bibliotheken von Drittanbietern verwenden.  Das Folgende ist der Software-Stack aus Java und nativem Code, normalerweise klein.  Als n√§chstes kommt der Grafikspeicher.  Dazu geh√∂ren Oberfl√§chen, Texturen, dh der Speicher, der sich zwischen der CPU und der GPU verteilt, wird zum Rendern verwendet.  Als n√§chstes folgt der Abschnitt Private Andere.  Dies schlie√üt alles ein, was nicht in die obigen Abschnitte f√§llt, alles, was das System nicht dar√ºber streuen konnte.  Normalerweise handelt es sich hierbei um native Zuordnungen.  Als n√§chstes folgt der Abschnitt System. Dies ist der Teil des Systemspeichers, der Ihrer Anwendung zugeordnet ist. <br><br>  Und am Ende haben wir GESAMT, das ist die Summe aller aufgelisteten Abschnitte.  Wir wollen es reduzieren. <br><br><img src="https://habrastorage.org/webt/py/uo/bk/pyuobklgdmuxby3witoq9fltrve.jpeg"><br><br>  Was ist sonst noch wichtig √ºber die Speichermessung zu wissen?  Erstens kontrolliert unsere Anwendung nicht alle Zuordnungen vollst√§ndig.  Das hei√üt, wir als Entwickler haben nicht die volle Kontrolle dar√ºber, welcher Code heruntergeladen wird. <br><br>  Folgendes.  Der Anwendungsspeicher kann viel springen.  W√§hrend des Messvorgangs k√∂nnen Sie starke Messunterschiede feststellen.  Dies kann sowohl auf die ben√∂tigte Zeit als auch auf verschiedene Szenarien zur√ºckzuf√ºhren sein.  In dieser Hinsicht ist es sehr wichtig, das Ged√§chtnis unter den gleichen Bedingungen zu optimieren, wenn wir es optimieren und analysieren.  Idealerweise auf demselben Ger√§t.  Noch besser, wenn Sie die M√∂glichkeit haben, den Garbage Collector aufzurufen. <br><br>  Gro√üartig.  Wir wissen, warum wir das Ged√§chtnis optimieren m√ºssen, wie wir es richtig messen k√∂nnen und woraus es besteht.  Lassen Sie uns √ºben, und ich werde Ihnen erkl√§ren, wie wir den Speicher in Launcher optimiert haben. <br><br><img src="https://habrastorage.org/webt/zy/t3/1q/zyt31qv6xboliaaetsqazvim8bi.jpeg"><br><br>  Das war zun√§chst die Situation.  Wir hatten drei Prozesse, die insgesamt etwa 120 Megabyte zugewiesen haben.  Dies ist fast viermal mehr, als wir erhalten m√∂chten. <br><br><img src="https://habrastorage.org/webt/xe/yt/tz/xeyttza29z1cbtkjhtwhanq2owm.jpeg"><br><br>  In Bezug auf die Zuweisung des Hauptprozesses gab es einen gro√üen Abschnitt von Java Heap, viele Grafiken, gro√üen Code und einen ziemlich gro√üen nativen Heap. <br><br><img src="https://habrastorage.org/webt/yl/8o/d6/yl8od64p4hs9jorsk5iftlexh-s.jpeg"><br><br>  Zuerst gingen wir das Problem ziemlich naiv an und beschlossen, einige Empfehlungen von Google aus einigen Quellen zu befolgen und zu versuchen, das Problem schnell zu l√∂sen.  Wir haben auf die Synthesemethoden hingewiesen, die w√§hrend des Kompilierungsprozesses generiert werden.  Wir hatten mehr als zweitausend von ihnen.  In ein paar Stunden haben wir sie alle gel√∂scht und den Speicher entfernt. <br><br><img src="https://habrastorage.org/webt/-n/k5/sx/-nk5sxehumnmvysfxp79-yjecq0.jpeg"><br><br>  Und sie haben im Code-Bereich einen Gewinn von ungef√§hr ein oder zwei Megabyte.  Gro√üartig. <br><br>  Als n√§chstes wandten wir uns der Aufz√§hlung zu.  Wie Sie wissen, ist Enum eine Klasse.  Und wie Google schlie√ülich zugab, ist enum nicht sehr speichereffizient.  Wir haben alle Aufz√§hlungen in InDef und StringDef √ºbersetzt.  Hier k√∂nnen Sie mir widersprechen, dass ProgArt hier helfen wird.  Tats√§chlich wird ProgArt jedoch nicht alle Aufz√§hlungen durch primitive Typen ersetzen.  Es ist besser, es selbst zu tun.  √úbrigens hatten wir mehr als 90 Aufz√§hlungen, ziemlich viel. <br><br><img src="https://habrastorage.org/webt/cs/na/lo/csnalohjmgwggcngzvyhk3p57wo.jpeg"><br><br>  Diese Optimierung hat bereits Tage gedauert, da die meisten manuell durchgef√ºhrt werden mussten und wir im Java-Heap-Bereich etwa drei bis sechs Megabyte gewonnen haben. <br><br>  Als n√§chstes machten wir auf die Sammlung aufmerksam.  Wir haben ziemlich standardm√§√üige Java-Sammlungen wie HashMap verwendet.  Wir hatten mehr als 150 davon und alle wurden zu Beginn von Launcher erstellt.  Wir haben sie durch SparseArray, SimpleArrayMap und ArrayMap ersetzt und begonnen, Sammlungen mit einer vorgegebenen Gr√∂√üe zu erstellen, damit keine leeren Slots zugewiesen werden.  Das hei√üt, wir √ºbergeben die Gr√∂√üe der Sammlung an den Konstruktor. <br><br><img src="https://habrastorage.org/webt/dl/rt/k9/dlrtk9aikfqhhp1d5mduorrq2wy.jpeg"><br><br>  Dies gab auch einen gewissen Gewinn, und diese Optimierung dauerte auch Tage, von denen wir die meisten manuell durchf√ºhrten. <br><br>  Dann haben wir einen genaueren Schritt gemacht.  Wir haben gesehen, dass wir drei Prozesse haben.  Wie wir wissen, ben√∂tigt selbst ein leerer Prozess in Android ungef√§hr 8-10 Megabyte Speicher, ziemlich viel. <br><br>  Details zu den Prozessen wurden von meinem Kollegen Arthur Vasilov mitgeteilt.  Vor nicht allzu langer Zeit war auf der Mosdroid-Konferenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sein Bericht</a> , auch √ºber Android Go. <br><br><img src="https://habrastorage.org/webt/16/i-/z-/16i-z-on0lf0lvdu5vk6fv0yilm.jpeg"><br><br>  Was hatten wir nach diesen Optimierungen?  Auf dem Haupttestger√§t beobachteten wir einen Speicherverbrauch im Bereich von 80 bis 100 Megabyte, nicht schlecht genug, aber immer noch nicht genug.  Wir haben begonnen, den Speicher auf anderen Ger√§ten zu messen.  Wir haben festgestellt, dass auf schnelleren Ger√§ten der Speicherverbrauch viel h√∂her war.  Es stellte sich heraus, dass wir viele verschiedene ausstehende Initialisierungen hatten.  Nach einiger Zeit hat Launcher einige Ansichten aufgeblasen, einige Bibliotheken initiiert usw. <br><br><img src="https://habrastorage.org/webt/qh/ql/ci/qhqlcieho2jhn-xhewlehklbg_s.jpeg"><br><br>  Was haben wir getan  Zuerst gingen wir die Ansicht durch, alle Layouts.  Alle Ansichten, die mit sichtbarer Sicht aufgeblasen wurden, wurden entfernt.  Sie brachten sie in separate Layouts und begannen, sie programmgesteuert aufzublasen.  Diejenigen, die wir nicht brauchten, h√∂rten wir im Allgemeinen auf zu blasen, bis der Benutzer sie brauchte.  Wir haben auf die Bildoptimierung geachtet.  Wir haben das Laden von Bildern gestoppt, die der Benutzer derzeit nicht sieht.  Im Fall von Launcher waren dies Bilder-Symbole von Anwendungen in der vollst√§ndigen Liste der Anwendungen.  Bis zur Er√∂ffnung versenden wir sie nicht.  Dies gab uns einen sehr guten Gewinn in der Grafiksektion. <br><br>  Wir haben auch unsere Bildcaches im Speicher √ºberpr√ºft.  Es stellte sich heraus, dass nicht alle optimal waren und nicht alle Bilder, die dem Bildschirm des Telefons entsprachen, auf dem Launcher ausgef√ºhrt wurde, im Speicher gespeichert waren. <br><br>  Danach begannen wir, den Codeabschnitt zu analysieren und stellten fest, dass wir von irgendwoher ziemlich viele ziemlich schwere Klassen hatten.  Es stellte sich heraus, dass dies haupts√§chlich Bibliotheksklassen sind.  In einigen Bibliotheken haben wir einige seltsame Dinge gefunden.  Eine der Bibliotheken hat HashMap erstellt und in einem statischen Initialisierer mit einer ausreichend gro√üen Anzahl von Objekten verstopft. <br><br><img src="https://habrastorage.org/webt/l4/vz/tf/l4vztfbwdffshzw5jf9ltshzjbs.jpeg"><br><br>  Eine andere Bibliothek lud auch Audiodateien in einen statischen Block, der etwa 700 Kilobyte Speicherplatz belegte. <br><br><img src="https://habrastorage.org/webt/uz/ku/-p/uzku-pmqzppvtwsdiexoxm3cs6q.jpeg"><br><br>  Wir haben die Initialisierung solcher Bibliotheken eingestellt und erst begonnen, mit ihnen zu arbeiten, wenn diese Funktionen von den Benutzern wirklich ben√∂tigt werden.  Alle diese Optimierungen dauerten mehrere Wochen.  Wir haben viel getestet und √ºberpr√ºft, dass wir keine zus√§tzlichen Probleme eingef√ºhrt haben.  Aber wir haben auch einen ziemlich guten Gewinn erzielt, etwa 25 von 40 Megabyte in den Abschnitten Native, Heap, Code und Java Heap. <br><br>  Das war aber nicht genug.  Der Speicherverbrauch ist immer noch nicht auf 30 Megabyte gesunken.  Es schien, als h√§tten wir alle Optionen f√ºr einige einfache automatische und sichere Optimierungen ausgesch√∂pft. <br><br>  Wir haben uns entschlossen, radikale L√∂sungen in Betracht zu ziehen.  Hier sahen wir zwei Optionen - die Erstellung einer separaten Lite-Anwendung oder die Verarbeitung der Launcher-Architektur und den √úbergang zu einer modularen Architektur mit der M√∂glichkeit, Launcher-Assemblys ohne zus√§tzliche Module zu erstellen.  Die erste Option ist ziemlich lang und teuer.  H√∂chstwahrscheinlich f√ºhrt die Erstellung einer solchen Anwendung zu einer vollst√§ndigen separaten Anwendung f√ºr Sie, die vollst√§ndig unterst√ºtzt und entwickelt werden muss.  Andererseits ist die Option mit einer modularen Architektur auch ziemlich teuer, ziemlich riskant, aber dennoch schneller, da Sie bereits mit einer bekannten Codebasis arbeiten und bereits √ºber eine Reihe von automatischen Komponententests, Integrationstests und manuellen Tests verf√ºgen F√§lle. <br><br>  Es sollte beachtet werden, dass Sie unabh√§ngig von der gew√§hlten Option einen Teil der Funktionen Ihrer Anwendung in der Version f√ºr Android Go irgendwie aufgeben m√ºssen.  Es ist in Ordnung.  Google macht dasselbe in seinen Go-Apps. <br><br>  Nachdem wir eine modulare Architektur implementiert hatten, l√∂sten wir unsere Speicherprobleme ziemlich zuverl√§ssig und begannen, Tests auch auf Ger√§ten mit einem kleinen Bildschirm zu bestehen, dh wir reduzierten den Speicherverbrauch auf 30 Megabyte. <br><br><img src="https://habrastorage.org/webt/jy/n1/hc/jyn1hce7pywfquvccv4w8n1bfl4.jpeg"><br><br>  Ein bisschen √ºber die Speicher√ºberwachung, dar√ºber, wie wir die Speichernutzung unter Kontrolle halten.  Zun√§chst richten wir statische Analyseger√§te ein, die in F√§llen, in denen wir Enum verwenden, Synthesemethoden erstellen oder nicht optimierte Sammlungen verwenden, denselben Fehler enthalten. <br><br>  Weiter schwieriger.  Wir haben automatische Integrationstests eingerichtet, die Launcher auf Emulatoren ausf√ºhren und nach einer Weile den Speicherverbrauch verringern.  Wenn es sich stark vom vorherigen Build unterscheidet, werden Warnungen und Warnungen ausgel√∂st.  Dann untersuchen wir das Problem und ver√∂ffentlichen keine √Ñnderungen, die die Verwendung des Launcher-Speichers erh√∂hen. <br><br>  Zusammenfassend.  Es gibt verschiedene Tools zur √úberwachung des Speichers und zur Messung des Speichers f√ºr einen schnellen und effizienten Betrieb.  Es ist besser, sie alle zu verwenden, da sie ihre Vor- und Nachteile haben. <br><br>  Radikale L√∂sungen mit modularer Architektur erwiesen sich f√ºr uns als zuverl√§ssiger und effizienter.  Wir bedauern, dass wir sie nicht sofort genommen haben.  Aber die Schritte, √ºber die ich ganz am Anfang des Berichts gesprochen habe, waren nicht umsonst.  Wir haben festgestellt, dass die Hauptversion der Anwendung den Speicher optimal nutzt, um schneller zu arbeiten.  Vielen Dank. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448966/">https://habr.com/ru/post/de448966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448956/index.html">Wut √ºber Code: Programmierer und Negativit√§t</a></li>
<li><a href="../de448958/index.html">Wie Amazon seine scheinbar zuf√§lligen Angebote des Tages ausw√§hlt. Und warum jagen Verk√§ufer ihnen so nach?</a></li>
<li><a href="../de448960/index.html">Unbegrenzte XR-Technologie im Zeitalter des verteilten Rechnens</a></li>
<li><a href="../de448962/index.html">Die Wirksamkeit des Marketing-Trichters AARRR</a></li>
<li><a href="../de448964/index.html">Der Toaster gibt Benutzern mehr Rechte</a></li>
<li><a href="../de448968/index.html">Asynchrones PHP. Warum?</a></li>
<li><a href="../de448970/index.html">Zwei-Faktor-Authentifizierung f√ºr SSH</a></li>
<li><a href="../de448976/index.html">Gamedev Fr√ºhlingsveranstaltungen bei HSE</a></li>
<li><a href="../de448980/index.html">Unser erstes gemeinsames Mittagessen: Warum und wie verbringen wir unseren Testtag?</a></li>
<li><a href="../de448982/index.html">Kopfloses CMS. Warum schreibe ich meine?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>