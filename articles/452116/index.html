<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üë¶ üèéÔ∏è √çndices en PostgreSQL - 8 (RUM) ‚è´ üßó üë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hemos discutido el motor de indexaci√≥n PostgreSQL, la interfaz de los m√©todos de acceso y los principales m√©todos de acceso, tales como: √≠ndices ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 8 (RUM)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452116/">  Ya hemos discutido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci√≥n</a> PostgreSQL, la interfaz de los m√©todos de acceso y los principales m√©todos de acceso, tales como: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndices hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP-GiST</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GIN</a> .  En este art√≠culo, veremos c√≥mo la ginebra se convierte en ron. <br><br><h1>  Ron </h1><br>  Aunque los autores afirman que la ginebra es un genio poderoso, el tema de las bebidas finalmente ha ganado: la pr√≥xima generaci√≥n de GIN se ha llamado RUM. <br><br>  Este m√©todo de acceso ampl√≠a el concepto que subyace a GIN y nos permite realizar b√∫squedas de texto completo a√∫n m√°s r√°pido.  En esta serie de art√≠culos, este es el √∫nico m√©todo que no se incluye en una entrega est√°ndar de PostgreSQL y es una extensi√≥n externa.  Hay varias opciones de instalaci√≥n disponibles para ello: <br><br><ul><li>  Tome el paquete "yum" o "apt" del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio PGDG</a> .  Por ejemplo, si instal√≥ PostgreSQL desde el paquete "postgresql-10", tambi√©n instale "postgresql-10-rum". </li><li>  Construya a partir del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente en github</a> e inst√°lelo usted mismo (la instrucci√≥n tambi√©n est√° all√≠). </li><li>  √öselo como parte de Postgres Pro Enterprise (o al menos lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la documentaci√≥n</a> desde all√≠). </li></ul><br><h2>  Limitaciones de la ginebra </h2><br>  ¬øQu√© limitaciones de GIN nos permite RUM trascender? <br><br>  Primero, el tipo de datos "tsvector" contiene no solo lexemas, sino tambi√©n informaci√≥n sobre sus posiciones dentro del documento.  Como observamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima vez</a> , el √≠ndice GIN no almacena esta informaci√≥n.  Por esta raz√≥n, las operaciones para buscar frases, que aparecieron en la versi√≥n 9.6, son compatibles con el √≠ndice GIN de manera ineficiente y tienen que acceder a los datos originales para volver a verificar. <br><br>  En segundo lugar, los sistemas de b√∫squeda generalmente devuelven los resultados ordenados por relevancia (lo que sea que eso signifique).  Podemos utilizar las funciones de clasificaci√≥n "ts_rank" y "ts_rank_cd" para este fin, pero deben calcularse para cada fila del resultado, lo que sin duda es lento. <br><br>  Para una primera aproximaci√≥n, el m√©todo de acceso RUM puede considerarse como GIN que adem√°s almacena informaci√≥n de posici√≥n y puede devolver los resultados en el orden necesario (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> puede devolver los vecinos m√°s cercanos).  Mov√°monos paso a paso. <br><a name="habracut"></a><br><h2>  Buscando frases </h2><br>  Una consulta de b√∫squeda de texto completo puede contener operadores especiales que tengan en cuenta la distancia entre lexemas.  Por ejemplo, podemos encontrar documentos en los que "mano" se separa de "muslo" con dos palabras m√°s: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;3&gt; thigh'</span></span>);</code> </pre> <pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  O podemos indicar que las palabras deben ubicarse una tras otra: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;-&gt; slap'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  El √≠ndice GIN normal puede devolver los documentos que contienen ambos lexemas, pero podemos verificar la distancia entre ellos solo mirando tsvector: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector -------------------------------------- 'clap':1 'hand':3 'slap':4 'thigh':6 (1 row)</code> </pre><br>  En el √≠ndice RUM, cada lexema no solo hace referencia a las filas de la tabla: cada TID se suministra con la lista de posiciones donde se produce el lexema en el documento.  As√≠ es como podemos imaginar el √≠ndice creado en la tabla "hoja de corte", que ya nos es bastante familiar (la clase de operador "rum_tsvector_ops" se usa para tsvector por defecto): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> rum; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(doc_tsv);</code> </pre><br><br><img src="https://habrastorage.org/webt/k0/up/gn/k0upgnbhka1wfwq6oozy9qo24ka.png"><br><br>  Los cuadrados grises en la figura contienen la informaci√≥n de posici√≥n agregada: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  GIN tambi√©n proporciona una inserci√≥n pospuesta cuando se especifica el par√°metro "fastupdate";  Esta funcionalidad se elimina de RUM. <br><br>  Para ver c√≥mo funciona el √≠ndice en los datos en vivo, usemos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo</a> familiar de la lista de correo pgsql-hackers. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> default_text_search_config = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">... UPDATE 356125</code> </pre><br>  As√≠ es como se realiza una consulta que usa la b√∫squeda de frases con el √≠ndice GIN: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv); fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Rows Removed by Index Recheck: 1517 Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual time=2.204..2.204 rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.266 ms Execution time: 18.151 ms (8 rows)</code> </pre><br>  Como podemos ver en el plan, se utiliza el √≠ndice GIN, pero devuelve 1776 coincidencias potenciales, de las cuales quedan 259 y 1517 se eliminan en la etapa de verificaci√≥n. <br><br>  Eliminemos el √≠ndice GIN y creemos RUM. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin; fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_rum <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv);</code> </pre><br>  El √≠ndice ahora contiene toda la informaci√≥n necesaria, y la b√∫squeda se realiza con precisi√≥n: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Heap Blocks: exact=250 -&gt; Bitmap Index Scan on tsv_rum (actual time=2.768..2.768 rows=259 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.245 ms Execution time: 3.053 ms (7 rows)</code> </pre><br><h2>  Ordenar por relevancia </h2><br>  Para devolver documentos f√°cilmente en el orden necesario, el √≠ndice RUM admite operadores de pedidos, que discutimos en el art√≠culo relacionado con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> .  La extensi√≥n RUM define dicho operador, <code>&lt;=&gt;</code> , que devuelve cierta distancia entre el documento ("tsvector") y la consulta ("tsquery").  Por ejemplo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&amp;gtl to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 16.4493 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'sheet'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 13.1595 (1 row)</code> </pre><br>  El documento parec√≠a ser m√°s relevante para la primera consulta que para la segunda: cuanto m√°s a menudo aparece la palabra, menos "valiosa" es. <br><br>  Intentemos nuevamente comparar GIN y RUM en un tama√±o de datos relativamente grande: seleccionaremos los diez documentos m√°s relevantes que contienen "hola" y "piratas inform√°ticos". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ts_rank(tsv,to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------- Limit (actual time=27.076..27.078 rows=10 loops=1) -&gt; Sort (actual time=27.075..27.076 rows=10 loops=1) Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) Sort Method: top-N heapsort Memory: 29kB -&gt; Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual ... rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Planning time: 0.276 ms Execution time: 27.121 ms (11 rows)</code> </pre><br>  El √≠ndice GIN devuelve 1776 coincidencias, que luego se ordenan como un paso separado para seleccionar los diez mejores √©xitos. <br><br>  Con el √≠ndice RUM, la consulta se realiza mediante un escaneo de √≠ndice simple: no se examinan documentos adicionales y no se requiere una clasificaci√≥n por separado: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> tsv &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------- Limit (actual time=5.083..5.171 rows=10 loops=1) -&gt; Index Scan using tsv_rum on mail_messages (actual ... rows=10 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) Planning time: 0.244 ms Execution time: 5.207 ms (6 rows)</code> </pre><br><h2>  Informaci√≥n adicional </h2><br>  El √≠ndice RUM, as√≠ como el GIN, se pueden construir en varios campos.  Pero mientras GIN almacena lexemas de cada columna independientemente de los de otra columna, RUM nos permite "asociar" el campo principal ("tsvector" en este caso) con uno adicional.  Para hacer esto, necesitamos usar una clase de operador especializada "rum_tsvector_addon_ops": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv RUM_TSVECTOR_ADDON_OPS, sent) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (ATTACH=<span class="hljs-string"><span class="hljs-string">'sent'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span>=<span class="hljs-string"><span class="hljs-string">'tsv'</span></span>);</code> </pre><br>  Podemos usar este √≠ndice para devolver los resultados ordenados en el campo adicional: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | sent | ?column? ---------+---------------------+---------- 2298548 | 2017-01-01 15:03:22 | 202 2298547 | 2017-01-01 14:53:13 | 407 2298545 | 2017-01-01 13:28:12 | 5508 2298554 | 2017-01-01 18:30:45 | 12645 2298530 | 2016-12-31 20:28:48 | 66672 2298587 | 2017-01-02 12:39:26 | 77966 2298588 | 2017-01-02 12:43:22 | 78202 2298597 | 2017-01-02 13:48:02 | 82082 2298606 | 2017-01-02 15:50:50 | 89450 2298628 | 2017-01-02 18:55:49 | 100549 (10 rows)</code> </pre><br>  Aqu√≠ buscamos que las filas coincidentes est√©n lo m√°s cerca posible de la fecha especificada, sin importar antes o despu√©s.  Para obtener los resultados que son estrictamente anteriores (o siguientes) a la fecha especificada, necesitamos usar <code>&lt;=|</code>  (o <code>|=&gt;</code> ) operador. <br><br>  Como esperamos, la consulta se realiza simplemente mediante un escaneo de √≠ndice simple: <br><br><pre> <code class="pgsql hljs">ts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Limit -&gt; Index Scan using mail_messages_tsv_sent_idx on mail_messages Index Cond: (tsv @@ to_tsquery('hello'::text)) Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) (4 rows)</code> </pre><br>  Si cre√°ramos el √≠ndice sin la informaci√≥n adicional sobre la asociaci√≥n de campo, para una consulta similar, tendr√≠amos que ordenar todos los resultados de la exploraci√≥n del √≠ndice. <br><br>  Adem√°s de la fecha, ciertamente podemos agregar campos de otros tipos de datos al √≠ndice RUM.  Pr√°cticamente todos los tipos base son compatibles.  Por ejemplo, una tienda en l√≠nea puede mostrar r√°pidamente productos por novedad (fecha), precio (num√©rico) y popularidad o valor de descuento (entero o punto flotante). <br><br><h2>  Otras clases de operador </h2><br>  Para completar la imagen, debemos mencionar otras clases de operadores disponibles. <br><br>  Comencemos con <strong>"rum_tsvector_hash_ops"</strong> y <strong>"rum_tsvector_hash_addon_ops"</strong> .  Son similares a los ya discutidos "rum_tsvector_ops" y "rum_tsvector_addon_ops", pero el √≠ndice almacena el c√≥digo hash del lexema en lugar del lexema mismo.  Esto puede reducir el tama√±o del √≠ndice, pero, por supuesto, la b√∫squeda se vuelve menos precisa y requiere una nueva verificaci√≥n.  Adem√°s, el √≠ndice ya no admite la b√∫squeda de una coincidencia parcial. <br><br>  Es interesante observar la clase de operador <strong>"rum_tsquery_ops"</strong> .  Nos permite resolver un problema "inverso": buscar consultas que coincidan con el documento.  ¬øPor qu√© podr√≠a ser necesario?  Por ejemplo, para suscribir a un usuario a nuevos productos de acuerdo con su filtro o para clasificar autom√°ticamente nuevos documentos.  Mira este sencillo ejemplo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> categories(query <span class="hljs-type"><span class="hljs-type">tsquery</span></span>, category <span class="hljs-type"><span class="hljs-type">text</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (to_tsquery(<span class="hljs-string"><span class="hljs-string">'vacuum | autovacuum | freeze'</span></span>), <span class="hljs-string"><span class="hljs-string">'vacuum'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'xmin | xmax | snapshot | isolation'</span></span>), <span class="hljs-string"><span class="hljs-string">'mvcc'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'wal | (write &amp; ahead &amp; log) | durability'</span></span>), <span class="hljs-string"><span class="hljs-string">'wal'</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(query); fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> array_agg(category) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector( <span class="hljs-string"><span class="hljs-string">'Hello hackers, the attached patch greatly improves performance of tuple freezing and also reduces size of generated write-ahead logs.'</span></span> ) @@ query;</code> </pre><pre> <code class="plaintext hljs"> array_agg -------------- {vacuum,wal} (1 row)</code> </pre><br>  Las clases de operador restantes <strong>"rum_anyarray_ops"</strong> y <strong>"rum_anyarray_addon_ops"</strong> est√°n dise√±adas para manipular matrices en lugar de "tsvector".  Esto ya se discuti√≥ para GIN la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima vez</a> y no necesita repetirse. <br><br><h2>  Los tama√±os del √≠ndice y el registro de escritura anticipada (WAL) </h2><br>  Est√° claro que dado que RUM almacena m√°s informaci√≥n que GIN, debe tener un tama√±o mayor.  Est√°bamos comparando los tama√±os de diferentes √≠ndices la √∫ltima vez;  agreguemos RUM a esta tabla: <br><br><pre> <code class="plaintext hljs"> rum | gin | gist | btree --------+--------+--------+-------- 457 MB | 179 MB | 125 MB | 546 MB</code> </pre><br>  Como podemos ver, el tama√±o creci√≥ significativamente, que es el costo de la b√∫squeda r√°pida. <br><br>  Vale la pena prestar atenci√≥n a un punto m√°s obvio: RUM es una extensi√≥n, es decir, se puede instalar sin modificaciones en el n√∫cleo del sistema.  Esto fue habilitado en la versi√≥n 9.6 gracias a un parche de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Korotkov</a> .  Uno de los problemas que tuvo que resolverse con este fin fue la generaci√≥n de registros de anotaciones.  Una t√©cnica para el registro de operaciones debe ser absolutamente confiable, por lo tanto, no se puede permitir una extensi√≥n en esta cocina.  En lugar de permitir que la extensi√≥n cree sus propios tipos de registros, se establece lo siguiente: el c√≥digo de la extensi√≥n comunica su intenci√≥n de modificar una p√°gina, le hace cambios y se√±ala la finalizaci√≥n, y es el n√∫cleo del sistema, que compara las versiones antiguas y nuevas de la p√°gina y genera los registros de registro unificados necesarios. <br><br>  El algoritmo actual de generaci√≥n de registros compara p√°ginas byte a byte, detecta fragmentos actualizados y registra cada uno de estos fragmentos, junto con su desplazamiento desde el inicio de la p√°gina.  Esto funciona bien cuando se actualizan solo varios bytes o toda la p√°gina.  Pero si agregamos un fragmento dentro de una p√°gina, moviendo el resto del contenido hacia abajo (o viceversa, eliminando un fragmento, moviendo el contenido hacia arriba), cambiar√°n significativamente m√°s bytes de los que realmente se agregaron o eliminaron. <br><br>  Debido a esto, el cambio intenso del √≠ndice RUM puede generar registros de registro de un tama√±o significativamente mayor que GIN (que, al no ser una extensi√≥n, sino una parte del n√∫cleo, administra el registro por s√≠ solo).  El alcance de este efecto molesto depende en gran medida de una carga de trabajo real, pero para obtener una idea del problema, intentemos eliminar y agregar varias filas varias veces, intercalando estas operaciones con "vac√≠o".  Podemos evaluar el tama√±o de los registros de registro de la siguiente manera: al principio y al final, recuerde la posici√≥n en el registro utilizando la funci√≥n "pg_current_wal_location" ("pg_current_xlog_location" en versiones anteriores a la diez) y luego observe la diferencia. <br><br>  Pero, por supuesto, deber√≠amos considerar muchos aspectos aqu√≠.  Debemos asegurarnos de que solo un usuario trabaje con el sistema (de lo contrario, se tendr√°n en cuenta los registros "adicionales").  Incluso si este es el caso, tenemos en cuenta no solo RUM, sino tambi√©n actualizaciones de la tabla en s√≠ y del √≠ndice que admite la clave primaria.  Los valores de los par√°metros de configuraci√≥n tambi√©n afectan el tama√±o (aqu√≠ se utiliz√≥ el nivel de registro "r√©plica", sin compresi√≥n).  Pero intentemos de todos modos. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> start_lsn \gset</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3576</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3590</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3605</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">98</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3637</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3625</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">97</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3668</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> end_lsn \gset fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(:<span class="hljs-string"><span class="hljs-string">'end_lsn'</span></span>::pg_lsn - :<span class="hljs-string"><span class="hljs-string">'start_lsn'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 3114 MB (1 row)</code> </pre><br>  Entonces, obtenemos alrededor de 3 GB.  Pero si repetimos el mismo experimento con el √≠ndice GIN, esto generar√° solo alrededor de 700 MB. <br><br>  Por lo tanto, es deseable tener un algoritmo diferente, que encontrar√° el n√∫mero m√≠nimo de operaciones de inserci√≥n y eliminaci√≥n que pueden transformar un estado de la p√°gina en otro.  La utilidad "Diff" funciona de manera similar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Oleg Ivanov</a> ya ha implementado dicho algoritmo, y se est√° discutiendo su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> .  En el ejemplo anterior, este parche nos permite reducir el tama√±o de los registros en 1.5 veces, a 1900 MB, a costa de una peque√±a desaceleraci√≥n. <br><br><blockquote>  Desafortunadamente, el parche se ha pegado y no hay actividad a su alrededor. <br></blockquote><br><h2>  Propiedades </h2><br>  Como de costumbre, echemos un vistazo a las propiedades del m√©todo de acceso RUM, prestando atenci√≥n a las diferencias de GIN ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya se han proporcionado consultas</a> ). <br><br>  Las siguientes son las propiedades del m√©todo de acceso: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- rum | can_order | f rum | can_unique | f rum | can_multi_col | t rum | can_exclude | t -- f for gin</code> </pre><br>  Las siguientes propiedades de capa de √≠ndice est√°n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t -- f for gin bitmap_scan | t backward_scan | f</code> </pre><br>  Tenga en cuenta que, a diferencia de GIN, RUM admite la exploraci√≥n de √≠ndice; de ‚Äã‚Äãlo contrario, no habr√≠a sido posible devolver exactamente el n√∫mero requerido de resultados en consultas con la cl√°usula "l√≠mite".  No hay necesidad de la contraparte del par√°metro "gin_fuzzy_search_limit" en consecuencia.  Y como consecuencia, el √≠ndice se puede utilizar para admitir restricciones de exclusi√≥n. <br><br>  Las siguientes son propiedades de capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | t -- f for gin returnable | f search_array | f search_nulls | f</code> </pre><br>  La diferencia aqu√≠ es que RUM admite operadores de pedidos.  Sin embargo, esto no es cierto para todas las clases de operadores: por ejemplo, esto es falso para "tsquery_ops". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452116/">https://habr.com/ru/post/452116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452106/index.html">Invitamos a los oradores a la reuni√≥n de verano de bricolaje el 16 de junio de 2019</a></li>
<li><a href="../452108/index.html">Docker: consejos inofensivos</a></li>
<li><a href="../452110/index.html">Automatice el reemplazo del disco con Ansible</a></li>
<li><a href="../452112/index.html">CRM ++</a></li>
<li><a href="../452114/index.html">HolyJS 2019: Informe de SEMrush (Parte 1)</a></li>
<li><a href="../452118/index.html">Cient√≠fico rompe el c√≥digo del misterioso manuscrito de Voynich</a></li>
<li><a href="../452122/index.html">"P√≠ldora del demonio" en movimiento</a></li>
<li><a href="../452124/index.html">‚ÄúNecesitamos hambre de conocimiento y logros‚Äù: ¬øc√≥mo es ser un probador en Alfa-Bank?</a></li>
<li><a href="../452128/index.html">Conceptos err√≥neos populares sobre la resistencia a la radiaci√≥n de los microcircuitos</a></li>
<li><a href="../452130/index.html">La luna se est√° encogiendo, causa terremotos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>