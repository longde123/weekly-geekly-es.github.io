<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçï üßóüèª üàØÔ∏è Indizes in PostgreSQL - 1 üëçüèΩ ‚ôàÔ∏è üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Diese Artikelserie befasst sich haupts√§chlich mit Indizes in PostgreSQL. 

 Jedes Thema kann aus verschiedenen Perspektiven betrachtet we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/441962/"><h1>  Einf√ºhrung </h1><br>  Diese Artikelserie befasst sich haupts√§chlich mit Indizes in PostgreSQL. <br><br>  Jedes Thema kann aus verschiedenen Perspektiven betrachtet werden.  Wir werden Dinge diskutieren, die einen Anwendungsentwickler interessieren sollten, der DBMS verwendet: Welche Indizes sind verf√ºgbar, warum gibt es so viele verschiedene Arten von Indizes und wie k√∂nnen sie verwendet werden, um Abfragen zu beschleunigen.  Das Thema kann wahrscheinlich in weniger Worten behandelt werden, aber im Geheimen hoffen wir auf einen neugierigen Entwickler, der sich auch f√ºr Details der Interna interessiert, zumal das Verst√§ndnis solcher Details es Ihnen erm√∂glicht, nicht nur auf das Urteil anderer zu verzichten, sondern auch Schlussfolgerungen zu ziehen von dir. <br><br>  Die Entwicklung neuer Arten von Indizes liegt au√üerhalb des Anwendungsbereichs.  Dies erfordert Kenntnisse der Programmiersprache C und bezieht sich eher auf das Fachwissen eines Systemprogrammierers als eines Anwendungsentwicklers.  Aus dem gleichen Grund werden wir Programmierschnittstellen fast nicht diskutieren, sondern uns nur auf das konzentrieren, was f√ºr die Arbeit mit gebrauchsfertigen Indizes wichtig ist. <br><br>  In diesem Artikel werden wir die Verteilung der Verantwortlichkeiten zwischen der <strong>allgemeinen Indexierungs-Engine in</strong> Bezug auf den DBMS-Kern und den einzelnen Indexzugriffsmethoden erl√§utern, die PostgreSQL als Erweiterungen hinzuf√ºgen kann.  Im n√§chsten Artikel werden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle der Zugriffsmethode</a> und kritische Konzepte wie Klassen und Operatorfamilien diskutieren.  Nach dieser langen, aber notwendigen Einf√ºhrung werden wir Details der Struktur und Anwendung verschiedener Arten von Indizes betrachten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Baum</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RUM</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BRIN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloom</a> . <br><br><blockquote>  Bevor wir beginnen, m√∂chte ich Elena Indrupskaya f√ºr die √úbersetzung der Artikel ins Englische danken. <br>  Die Dinge haben sich seit der urspr√ºnglichen Ver√∂ffentlichung ein wenig ge√§ndert.  Meine Kommentare zum aktuellen Stand der Dinge sind so angegeben. </blockquote><a name="habracut"></a><br><h2>  Indizes </h2><br>  In PostgreSQL sind Indizes spezielle Datenbankobjekte, die haupts√§chlich dazu dienen, den Datenzugriff zu beschleunigen.  Es handelt sich um Hilfsstrukturen: Jeder Index kann gel√∂scht und aus den Informationen in der Tabelle wiederhergestellt werden.  Es kann vorkommen, dass Sie h√∂ren, dass ein DBMS nur langsam ohne Indizes arbeiten kann.  Dies ist jedoch nicht der Fall, da Indizes auch dazu dienen, einige Integrit√§tsbeschr√§nkungen durchzusetzen. <br><br>  Derzeit sind sechs verschiedene Arten von Indizes in PostgreSQL 9.6 integriert, und ein weiterer Index ist als Erweiterung verf√ºgbar - dank erheblicher √Ñnderungen in Version 9.6.  Erwarten Sie also in naher Zukunft neue Arten von Indizes. <br><br>  Trotz aller Unterschiede zwischen den Indextypen (auch als Zugriffsmethoden bezeichnet) ordnet jeder von ihnen schlie√ülich einen Schl√ºssel (z. B. den Wert der indizierten Spalte) Tabellenzeilen zu, die diesen Schl√ºssel enthalten.  Jede Zeile wird durch TID (Tupel-ID) identifiziert, die aus der Anzahl der Bl√∂cke in der Datei und der Position der Zeile innerhalb des Blocks besteht.  Mit dem bekannten Schl√ºssel oder einigen Informationen dar√ºber k√∂nnen wir jedoch schnell die Zeilen lesen, die die Informationen von Interesse enthalten k√∂nnen, ohne die gesamte Tabelle zu scannen. <br><br>  Es ist wichtig zu verstehen, dass ein Index den Datenzugriff bei bestimmten Wartungskosten beschleunigt.  F√ºr jede Operation an indizierten Daten, sei es das Einf√ºgen, L√∂schen oder Aktualisieren von Tabellenzeilen, m√ºssen auch die Indizes f√ºr diese Tabelle und in derselben Transaktion aktualisiert werden.  Beachten Sie, dass die Aktualisierung von Tabellenfeldern, f√ºr die keine Indizes erstellt wurden, nicht zu einer Indexaktualisierung f√ºhrt.  Diese Technik wird als HOT (Heap-Only Tuples) bezeichnet. <br><br>  Die Erweiterbarkeit hat einige Auswirkungen.  Um das Hinzuf√ºgen einer neuen Zugriffsmethode zum System zu vereinfachen, wurde eine Schnittstelle der allgemeinen Indexierungs-Engine implementiert.  Die Hauptaufgabe besteht darin, TIDs von der Zugriffsmethode abzurufen und mit ihnen zu arbeiten: <br><br><ul><li>  Lesen Sie Daten aus entsprechenden Versionen von Tabellenzeilen. </li><li>  Abrufen von Zeilenversionen TID f√ºr TID oder in einem Stapel mithilfe einer vorgefertigten Bitmap. </li><li>  √úberpr√ºfen Sie die Sichtbarkeit der Zeilenversionen f√ºr die aktuelle Transaktion unter Ber√ºcksichtigung ihrer Isolationsstufe. </li></ul><br>  Die Indizierungs-Engine ist an der Durchf√ºhrung von Abfragen beteiligt.  Es wird nach einem Plan aufgerufen, der in der Optimierungsphase erstellt wurde.  Das Optimierungsprogramm, das verschiedene Methoden zum Ausf√ºhren der Abfrage aussortiert und bewertet, sollte die Funktionen aller potenziell anwendbaren Zugriffsmethoden verstehen.  Kann die Methode Daten in der erforderlichen Reihenfolge zur√ºckgeben oder sollten wir mit dem Sortieren rechnen?  K√∂nnen wir diese Methode verwenden, um nach NULL zu suchen?  Dies sind Probleme, die der Optimierer regelm√§√üig l√∂st. <br><br>  Nicht nur der Optimierer ben√∂tigt Informationen zur Zugriffsmethode.  Beim Erstellen eines Index muss das System entscheiden, ob der Index auf mehreren Spalten erstellt werden kann und ob dieser Index die Eindeutigkeit sicherstellt. <br><br>  Daher sollte jede Zugriffsmethode alle erforderlichen Informationen √ºber sich selbst bereitstellen.  Versionen unter 9.6 verwendeten hierf√ºr die Tabelle "pg_am", w√§hrend ab Version 9.6 die Daten innerhalb spezieller Funktionen auf tiefere Ebenen verschoben wurden.  Wir werden diese Schnittstelle etwas weiter kennenlernen. <br><br>  Der Rest ist Aufgabe der Zugriffsmethode: <br><br><ul><li>  Implementieren Sie einen Algorithmus zum Erstellen des Index und ordnen Sie die Daten Seiten zu (damit der Puffer-Cache-Manager jeden Index einheitlich verarbeitet). </li><li>  Suchen Sie Informationen im Index nach einem Pr√§dikat in der Form " <em>Ausdruck des Operators f√ºr indizierte Felder</em> ". </li><li>  Bewerten Sie die Indexnutzungskosten. </li><li>  Bearbeiten Sie die f√ºr eine korrekte Parallelverarbeitung erforderlichen Sperren. </li><li>  Generieren Sie WAL-Datens√§tze (Write-Ahead-Protokoll). </li></ul><br>  Wir werden zuerst die Funktionen der allgemeinen Indizierungs-Engine betrachten und dann verschiedene Zugriffsmethoden betrachten. <br><br><h2>  Indizierungsmaschine </h2><br>  Mit der Indizierungs-Engine kann PostgreSQL einheitlich mit verschiedenen Zugriffsmethoden arbeiten, wobei jedoch deren Funktionen ber√ºcksichtigt werden. <br><br><h3>  Haupt-Scan-Techniken </h3><br><h4>  Index-Scan </h4><br>  Wir k√∂nnen anders mit TIDs arbeiten, die von einem Index bereitgestellt werden.  Betrachten wir ein Beispiel: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(a <span class="hljs-type"><span class="hljs-type">integer</span></span>, b <span class="hljs-type"><span class="hljs-type">text</span></span>, c <span class="hljs-type"><span class="hljs-type">boolean</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(a,b,c) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.id, chr((<span class="hljs-number"><span class="hljs-number">32</span></span>+random()*<span class="hljs-number"><span class="hljs-number">94</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), random() &lt; <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s(id) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre> <br>  Wir haben eine Tabelle mit drei Feldern erstellt.  Das erste Feld enth√§lt Zahlen von 1 bis 100.000, und f√ºr dieses Feld wird ein Index (unabh√§ngig vom Typ) erstellt.  Das zweite Feld enth√§lt verschiedene ASCII-Zeichen au√üer nicht druckbaren.  Schlie√ülich enth√§lt das dritte Feld einen logischen Wert, der f√ºr etwa 1% der Zeilen wahr und f√ºr den Rest falsch ist.  Zeilen werden in zuf√§lliger Reihenfolge in die Tabelle eingef√ºgt. <br><br>  Versuchen wir, einen Wert durch die Bedingung "a = 1" auszuw√§hlen.  Beachten Sie, dass die Bedingung wie " <em>Operatorausdruck f√ºr indizierte Felder</em> " aussieht, wobei der <em>Operator</em> "gleich" und der <em>Ausdruck</em> (Suchschl√ºssel) "1" ist.  In den meisten F√§llen muss die Bedingung so aussehen, damit der Index verwendet werden kann. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t Index Cond: (a = 1) (2 rows)</code> </pre><br>  In diesem Fall entschied sich der Optimierer f√ºr die Verwendung des <em>Index-Scans</em> .  Beim Index-Scannen gibt die Zugriffsmethode nacheinander TID-Werte zur√ºck, bis die letzte √ºbereinstimmende Zeile erreicht ist.  Die Indizierungs-Engine greift nacheinander auf die durch TIDs angegebenen Tabellenzeilen zu, ruft die Zeilenversion ab, √ºberpr√ºft ihre Sichtbarkeit anhand von Multiversions-Parallelit√§tsregeln und gibt die erhaltenen Daten zur√ºck. <br><br><h4>  Bitmap-Scan </h4><br>  Der Index-Scan funktioniert einwandfrei, wenn nur wenige Werte verarbeitet werden.  Wenn jedoch die Anzahl der abgerufenen Zeilen zunimmt, ist es wahrscheinlicher, dass Sie mehrmals zur gleichen Tabellenseite zur√ºckkehren.  Daher wechselt der Optimierer zum <em>Bitmap-Scan</em> . <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  Die Zugriffsmethode gibt zuerst alle TIDs zur√ºck, die der Bedingung entsprechen (Bitmap-Index-Scan-Knoten), und die Bitmap der Zeilenversionen wird aus diesen TIDs erstellt.  Zeilenversionen werden dann aus der Tabelle gelesen (Bitmap Heap Scan), wobei jede Seite nur einmal gelesen wird. <br><br>  Beachten Sie, dass im zweiten Schritt die Bedingung m√∂glicherweise erneut √ºberpr√ºft wird (Cond erneut pr√ºfen).  Die Anzahl der abgerufenen Zeilen kann zu gro√ü sein, als dass die Bitmap der Zeilenversionen vollst√§ndig in den RAM passen k√∂nnte (begrenzt durch den Parameter "work_mem").  In diesem Fall wird die Bitmap nur f√ºr Seiten erstellt, die mindestens eine √ºbereinstimmende Zeilenversion enthalten.  Diese "verlustbehaftete" Bitmap ben√∂tigt weniger Speicherplatz, aber beim Lesen einer Seite m√ºssen wir die Bedingungen f√ºr jede dort enthaltene Zeile erneut √ºberpr√ºfen.  Beachten Sie, dass selbst f√ºr eine kleine Anzahl von abgerufenen Zeilen und daher eine "exakte" Bitmap (wie in unserem Beispiel) der Schritt "Cond erneut pr√ºfen" ohnehin im Plan dargestellt wird, obwohl er nicht tats√§chlich ausgef√ºhrt wird. <br><br>  Wenn Bedingungen f√ºr mehrere Tabellenfelder festgelegt und diese Felder indiziert werden, erm√∂glicht der Bitmap-Scan die gleichzeitige Verwendung mehrerer Indizes (wenn der Optimierer dies f√ºr effizient h√§lt).  F√ºr jeden Index werden Bitmaps von Zeilenversionen erstellt, f√ºr die dann eine bitweise boolesche Multiplikation (wenn die Ausdr√ºcke durch UND verbunden sind) oder eine boolesche Addition (wenn die Ausdr√ºcke durch ODER verbunden sind) durchgef√ºhrt wird.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) -&gt; BitmapAnd -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_b_idx Index Cond: (b = 'a'::text) (7 rows)</code> </pre><br>  Hier verbindet der BitmapAnd-Knoten zwei Bitmaps durch die bitweise "und" -Operation. <br><br>  Mit dem Bitmap-Scan k√∂nnen wir wiederholte Zugriffe auf dieselbe Datenseite vermeiden.  Was aber, wenn die Daten in Tabellenseiten physisch genauso geordnet sind wie Indexdatens√§tze?  Es steht au√üer Zweifel, dass wir uns nicht vollst√§ndig auf die physische Reihenfolge der Daten auf den Seiten verlassen k√∂nnen.  Wenn sortierte Daten ben√∂tigt werden, m√ºssen wir die ORDER BY-Klausel in der Abfrage explizit angeben.  Es ist jedoch wahrscheinlich, dass tats√§chlich "fast alle" Daten geordnet sind: Zum Beispiel, wenn Zeilen in der erforderlichen Reihenfolge hinzugef√ºgt werden und sich danach oder nach Ausf√ºhrung des Befehls CLUSTER nicht √§ndern.  In solchen F√§llen ist das Erstellen einer Bitmap ein √ºberm√§√üiger Schritt, und ein regelm√§√üiger Index-Scan ist genauso gut (es sei denn, wir ber√ºcksichtigen die M√∂glichkeit, mehrere Indizes zu verbinden).  Daher untersucht der Planer bei der Auswahl einer Zugriffsmethode eine spezielle Statistik, die die Korrelation zwischen der physischen Zeilenreihenfolge und der logischen Reihenfolge der Spaltenwerte zeigt: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------+------------- b | 0.533512 c | 0.942365 a | -0.00768816 (3 rows)</code> </pre><br>  Absolutwerte nahe eins zeigen eine hohe Korrelation an (wie f√ºr Spalte "c"), w√§hrend Werte nahe Null im Gegensatz dazu eine chaotische Verteilung anzeigen (Spalte "a"). <br><br><h4>  Sequentieller Scan </h4><br>  Um das Bild zu vervollst√§ndigen, sollten wir beachten, dass der Optimierer bei einer nicht selektiven Bedingung zu Recht den sequentiellen Scan der gesamten Tabelle der Verwendung des Index vorzieht: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">40000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------ Seq Scan on t Filter: (a &lt;= 40000) (2 rows)</code> </pre><br>  Die Sache ist, dass Indizes umso besser funktionieren, je h√∂her die Bedingungsselektivit√§t ist, dh je weniger Zeilen damit √ºbereinstimmen.  Die Zunahme der Anzahl der abgerufenen Zeilen erh√∂ht die Gemeinkosten f√ºr das Lesen von Indexseiten. <br><br>  Sequentielle Scans sind schneller als zuf√§llige Scans.  Dies gilt insbesondere f√ºr Festplatten, bei denen der mechanische Vorgang, einen Magnetkopf auf eine Spur zu bringen, erheblich l√§nger dauert als das Lesen der Daten selbst.  Dieser Effekt macht sich bei SSD weniger bemerkbar.  Zur Ber√ºcksichtigung der Unterschiede bei den Zugriffskosten stehen zwei Parameter zur Verf√ºgung: "seq_page_cost" und "random_page_cost", die wir nicht nur global, sondern auch auf der Ebene der Tablespaces festlegen k√∂nnen, um sie an die Eigenschaften verschiedener Festplattensubsysteme anzupassen. <br><br><h3>  Indizes abdecken </h3><br>  In der Regel besteht die Hauptaufgabe einer Zugriffsmethode darin, die Bezeichner √ºbereinstimmender Tabellenzeilen zur√ºckzugeben, damit die Indexierungsmaschine die erforderlichen Daten aus diesen Zeilen lesen kann.  Was aber, wenn der Index bereits alle f√ºr die Abfrage ben√∂tigten Daten enth√§lt?  Ein solcher Index wird als <em>Abdeckung bezeichnet</em> . In diesem Fall kann der Optimierer den <em>Nur-Index-Scan</em> anwenden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Index Only Scan using t_a_idx on t Index Cond: (a &lt; 100) (2 rows)</code> </pre><br>  Dieser Name kann darauf hindeuten, dass die Indizierungs-Engine √ºberhaupt nicht auf die Tabelle zugreift und alle erforderlichen Informationen allein von der Zugriffsmethode erh√§lt.  Dies ist jedoch nicht genau der Fall, da Indizes in PostgreSQL keine Informationen speichern, mit denen wir die Zeilensichtbarkeit beurteilen k√∂nnen.  Daher gibt eine Zugriffsmethode Versionen von Zeilen zur√ºck, die der Suchbedingung entsprechen, unabh√§ngig von ihrer Sichtbarkeit in der aktuellen Transaktion. <br><br>  Wenn die Indizierungs-Engine jedoch jedes Mal in der Tabelle nach Sichtbarkeit suchen m√ºsste, h√§tte sich diese Scanmethode nicht von einem regul√§ren Index-Scan unterschieden. <br><br>  Um das Problem zu l√∂sen, verwaltet PostgreSQL f√ºr Tabellen eine sogenannte <em>Sichtbarkeitskarte,</em> in der das Staubsaugen die Seiten markiert, auf denen Daten nicht lange genug ge√§ndert wurden, damit diese Daten f√ºr alle Transaktionen unabh√§ngig von Startzeit und Isolationsstufe sichtbar sind.  Wenn sich die Kennung einer vom Index zur√ºckgegebenen Zeile auf eine solche Seite bezieht, kann eine Sichtbarkeitspr√ºfung vermieden werden. <br><br>  Daher erh√∂ht regelm√§√üiges Staubsaugen die Effizienz der Abdeckindizes.  Dar√ºber hinaus ber√ºcksichtigt der Optimierer die Anzahl der toten Tupel und kann entscheiden, den Nur-Index-Scan nicht zu verwenden, wenn er hohe Overhead-Kosten f√ºr die Sichtbarkeitspr√ºfung vorhersagt. <br><br>  Mit dem Befehl EXPLAIN ANALYZE k√∂nnen wir die Anzahl der erzwungenen Zugriffe auf eine Tabelle ermitteln: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------- Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) Index Cond: (a &lt; 100) Heap Fetches: 0 Planning time: 0.092 ms Execution time: 0.059 ms (5 rows)</code> </pre><br>  In diesem Fall war es nicht erforderlich, auf die Tabelle zuzugreifen (Heap Fetches: 0), da gerade gesaugt wurde.  Im Allgemeinen ist es umso besser, je n√§her diese Zahl an Null liegt. <br><br>  Nicht alle Indizes speichern indizierte Werte zusammen mit Zeilenbezeichnern.  Wenn die Zugriffsmethode die Daten nicht zur√ºckgeben kann, kann sie nicht f√ºr Nur-Index-Scans verwendet werden. <br><br><blockquote>  PostgreSQL 11 hat eine neue Funktion eingef√ºhrt: INCLUDE-Indizes.  Was ist, wenn es einen eindeutigen Index gibt, dem einige Spalten fehlen, die als Deckungsindex f√ºr eine Abfrage verwendet werden k√∂nnen?  Sie k√∂nnen die Spalten nicht einfach zum Index hinzuf√ºgen, da dies die Eindeutigkeit beeintr√§chtigt.  Die Funktion erm√∂glicht das Einschlie√üen von <em>Nicht-Schl√ºsselspalten</em> , die die Eindeutigkeit nicht beeinflussen und nicht in Suchpr√§dikaten verwendet werden k√∂nnen, aber dennoch nur Index-Scans erm√∂glichen.  Der Patch wurde von meiner Kollegin Anastasia Lubennikova entwickelt. <br></blockquote><br><h3>  Null </h3><br>  NULL-Werte spielen in relationalen Datenbanken eine wichtige Rolle, um einen nicht vorhandenen oder unbekannten Wert bequem darzustellen. <br><br>  Aber ein besonderer Wert ist etwas Besonderes.  Eine regul√§re boolesche Algebra wird tern√§r;  Es ist unklar, ob NULL kleiner oder gr√∂√üer als regul√§re Werte sein soll (dies erfordert spezielle Konstrukte zum Sortieren, NULLS FIRST und NULLS LAST).  Es ist nicht ersichtlich, ob Aggregatfunktionen NULL ber√ºcksichtigen sollten oder nicht.  F√ºr den Planer wird eine spezielle Statistik ben√∂tigt ... <br><br>  Aus Sicht der Indexunterst√ºtzung ist auch unklar, ob wir diese Werte indizieren m√ºssen oder nicht.  Wenn NULL-Werte nicht indiziert sind, ist der Index m√∂glicherweise kompakter.  Wenn jedoch NULL-Werte indiziert werden, k√∂nnen wir den Index f√ºr Bedingungen wie "Indexfeld IS [NOT] NULL" und auch als Deckungsindex verwenden, wenn f√ºr die Tabelle √ºberhaupt keine Bedingungen angegeben sind (da in diesem Fall die Der Index muss die Daten aller Tabellenzeilen zur√ºckgeben, einschlie√ülich derer mit NULL-Werten. <br><br>  F√ºr jede Zugriffsmethode treffen die Entwickler eine individuelle Entscheidung, ob NULLs indiziert werden sollen oder nicht.  In der Regel werden sie jedoch indiziert. <br><br><h3>  Indizes f√ºr mehrere Felder </h3><br>  Um die Bedingungen f√ºr mehrere Felder zu unterst√ºtzen, k√∂nnen <em>mehrspaltige Indizes</em> verwendet werden.  Zum Beispiel k√∂nnten wir einen Index f√ºr zwei Felder unserer Tabelle erstellen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a,b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  Der Optimierer wird diesen Index h√∂chstwahrscheinlich dem Verbinden von Bitmaps vorziehen, da wir hier leicht die erforderlichen TIDs ohne Hilfsoperationen erhalten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Scan using t_a_b_idx on t Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) (2 rows)</code> </pre><br>  Ein mehrspaltiger Index kann auch verwendet werden, um das Abrufen von Daten durch eine Bedingung f√ºr einige der Felder zu beschleunigen, beginnend mit dem ersten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------- Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_b_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  Wenn die Bedingung nicht f√ºr das erste Feld festgelegt ist, wird der Index im Allgemeinen nicht verwendet.  Manchmal betrachtet der Optimierer die Verwendung des Index jedoch als effizienter als den sequentiellen Scan.  Wir werden dieses Thema erweitern, wenn wir "btree" -Indizes betrachten. <br><br>  Nicht alle Zugriffsmethoden unterst√ºtzen das Erstellen von Indizes f√ºr mehrere Spalten. <br><br><h3>  Indizes zu Ausdr√ºcken </h3><br>  Wir haben bereits erw√§hnt, dass die Suchbedingung wie " <em>Operatorausdruck f√ºr indizierte Felder</em> " aussehen muss.  Im folgenden Beispiel wird der Index nicht verwendet, da anstelle des Feldnamens selbst ein Ausdruck verwendet wird, der den Feldnamen enth√§lt: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------ Seq Scan on t Filter: (lower((b)::text) = 'a'::text) (2 rows)</code> </pre><br>  Das Umschreiben dieser spezifischen Abfrage erfordert nicht viel, sodass nur der Feldname links vom Operator geschrieben wird.  Ist dies jedoch nicht m√∂glich, helfen Indizes f√ºr Ausdr√ºcke (Funktionsindizes): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(lower(b)); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: (lower((b)::text) = 'a'::text) -&gt; Bitmap Index Scan on t_lower_idx Index Cond: (lower((b)::text) = 'a'::text) (4 rows)</code> </pre><br>  Der Funktionsindex basiert nicht auf einem Tabellenfeld, sondern auf einem beliebigen Ausdruck.  Das Optimierungsprogramm ber√ºcksichtigt diesen Index f√ºr Bedingungen wie " <em>Operatorausdruck</em> f√ºr <em>indizierte Ausdr√ºcke</em> ".  Wenn die Berechnung des zu indizierenden Ausdrucks eine kostspielige Operation ist, erfordert die Aktualisierung des Index auch erhebliche Rechenressourcen. <br><br>  Beachten Sie auch, dass f√ºr den indizierten Ausdruck eine individuelle Statistik erfasst wird.  Wir k√∂nnen diese Statistik in der Ansicht "pg_stats" anhand des Indexnamens kennenlernen: <br><br><pre> <code class="pgsql hljs">postgres=# \dt</code> </pre><pre> <code class="plaintext hljs"> Table "public.t" Column | Type | Modifiers --------+---------+----------- a | integer | b | text | c | boolean | Indexes: "t_a_b_idx" btree (a, b) "t_a_idx" btree (a) "t_b_idx" btree (b) "t_lower_idx" btree (lower(b))</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t_lower_idx'</span></span>;</code> </pre><br>  Falls erforderlich, k√∂nnen Sie die Anzahl der Histogrammk√∂rbe auf dieselbe Weise wie bei regul√§ren Datenfeldern steuern (wobei zu beachten ist, dass der Spaltenname je nach indiziertem Ausdruck unterschiedlich sein kann): <br><br><pre> <code class="pgsql hljs">postgres=# \d t_lower_idx</code> </pre><pre> <code class="plaintext hljs"> Index "public.t_lower_idx" Column | Type | Definition --------+------+------------ lower | text | lower(b) btree, for table "public.t"</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_lower_idx <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> "lower" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>;</code> </pre><br><blockquote>  PostgreSQL 11 bietet eine √ºbersichtlichere Methode zur Steuerung des Statistikziels f√ºr Indizes, indem die Spaltennummer im Befehl ALTER INDEX ... SET STATISTICS angegeben wird.  Der Patch wurde von meinem Kollegen Alexander Korotkov und Adrien Nayrat entwickelt. </blockquote><br><h3>  Teilindizes </h3><br>  Manchmal besteht die Notwendigkeit, nur einen Teil der Tabellenzeilen zu indizieren.  Dies h√§ngt normalerweise mit einer sehr ungleichm√§√üigen Verteilung zusammen: Es ist sinnvoll, anhand eines Index nach einem seltenen Wert zu suchen, aber es ist einfacher, einen h√§ufigen Wert durch vollst√§ndiges Scannen der Tabelle zu finden. <br><br>  Wir k√∂nnen sicherlich einen regul√§ren Index f√ºr die Spalte "c" erstellen, der so funktioniert, wie wir es erwarten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_c_idx on t Index Cond: (c = true) Filter: c (3 rows)</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------- Seq Scan on t Filter: (NOT c) (2 rows)</code> </pre><br>  Und die Indexgr√∂√üe betr√§gt 276 Seiten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 276 (1 row)</code> </pre><br>  Da die Spalte "c" jedoch nur f√ºr 1% der Zeilen den Wert "true" hat, werden 99% des Index tats√§chlich nie verwendet.  In diesem Fall k√∂nnen wir einen Teilindex erstellen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  Die Gr√∂√üe des Index wird auf 5 Seiten reduziert: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx1'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 5 (1 row)</code> </pre><br>  Manchmal kann der Unterschied in Gr√∂√üe und Leistung ziemlich bedeutend sein. <br><br><h3>  Sortieren </h3><br>  Wenn eine Zugriffsmethode Zeilenbezeichner in einer bestimmten Reihenfolge zur√ºckgibt, bietet dies dem Optimierer zus√§tzliche Optionen zum Ausf√ºhren der Abfrage. <br><br>  Wir k√∂nnen die Tabelle scannen und dann die Daten sortieren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------- Sort Sort Key: a -&gt; Seq Scan on t (3 rows)</code> </pre><br>  Aber wir k√∂nnen die Daten unter Verwendung des Index leicht in einer gew√ºnschten Reihenfolge lesen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t (1 row)</code> </pre><br>  Nur "btree" aller Zugriffsmethoden kann sortierte Daten zur√ºckgeben. Lassen Sie uns daher eine ausf√ºhrlichere Diskussion verschieben, bis dieser Indextyp ber√ºcksichtigt wird. <br><br><h3>  Gleichzeitiges Bauen </h3><br>  Normalerweise erh√§lt das Erstellen eines Index eine SHARE-Sperre f√ºr die Tabelle.  Diese Sperre erm√∂glicht das Lesen von Daten aus der Tabelle, verhindert jedoch √Ñnderungen w√§hrend der Indexerstellung. <br><br>  Dies k√∂nnen wir sicherstellen, wenn wir beispielsweise beim Erstellen eines Index f√ºr die Tabelle "t" die folgende Abfrage in einer anderen Sitzung ausf√ºhren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> mode, granted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relation = <span class="hljs-string"><span class="hljs-string">'t'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> mode | granted -----------+--------- ShareLock | t (1 row)</code> </pre><br>  Wenn die Tabelle gro√ü genug ist und h√§ufig zum Einf√ºgen, Aktualisieren oder L√∂schen verwendet wird, scheint dies unzul√§ssig zu sein, da √Ñnderungsprozesse lange auf eine Sperrfreigabe warten. <br><br>  In diesem Fall k√∂nnen wir gleichzeitig einen Index erstellen. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">concurrently</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a);</code> </pre><br>  Dieser Befehl sperrt die Tabelle im SHARE UPDATE EXCLUSIVE-Modus, der sowohl das Lesen als auch das Aktualisieren erm√∂glicht (nur das √Ñndern der Tabellenstruktur ist verboten sowie das gleichzeitige Staubsaugen, Analysieren oder Erstellen eines anderen Index f√ºr diese Tabelle). <br><br>  Es gibt jedoch auch eine Kehrseite.  Erstens wird der Index langsamer als gew√∂hnlich erstellt, da zwei Durchg√§nge √ºber die Tabelle anstelle von einem durchgef√ºhrt werden, und es ist auch erforderlich, auf den Abschluss paralleler Transaktionen zu warten, die die Daten √§ndern. <br><br>  Zweitens kann bei gleichzeitiger Erstellung des Index ein Deadlock auftreten oder eindeutige Einschr√§nkungen k√∂nnen verletzt werden.  Der Index wird jedoch erstellt, obwohl er nicht funktioniert.  Ein solcher Index muss gel√∂scht und neu erstellt werden.  Nicht betriebsbereite Indizes werden in der Ausgabe des Befehls psql \ d mit dem Wort INVALID markiert, und die folgende Abfrage gibt eine vollst√§ndige Liste dieser zur√ºck: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> index_name, indrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> indisvalid;</code> </pre><pre> <code class="plaintext hljs"> index_name | table_name ------------+------------ t_a_idx | t (1 row)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441962/">https://habr.com/ru/post/de441962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441946/index.html">REST-API auf Laravel in 100 Codezeilen</a></li>
<li><a href="../de441950/index.html">Eclipse Che 7 ist schon da</a></li>
<li><a href="../de441952/index.html">Auswahl eines Dateispeichersystems f√ºr die Teamarbeit</a></li>
<li><a href="../de441954/index.html">Benutzerbelohnung an Habrs Autoren</a></li>
<li><a href="../de441956/index.html">Einheitliche Fehlerbehandlung (C ++ - Option f√ºr Mikrocontroller)</a></li>
<li><a href="../de441964/index.html">Tipps und Tricks von Kubernetes: Verschieben von Clusterressourcen auf Helm 2</a></li>
<li><a href="../de441966/index.html">Starter Kit zum Testen der Web-Sicherheit</a></li>
<li><a href="../de441968/index.html">Entwicklung einer neuen Produktbranche: Wie man Unpraktisches loswird und n√ºtzlich bleibt</a></li>
<li><a href="../de441970/index.html">FinFisher Butkit-Analyse</a></li>
<li><a href="../de441972/index.html">Invidious - alternatives YouTube-Frontend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>