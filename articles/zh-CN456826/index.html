<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟 💈 🧓🏿 使用AWX，Ansible，haproxy和CROC Cloud进行DIY自动缩放 👇🏼 👛 ⬇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不久前，我们为此进行了无代理监视和警报。 这与具有兼容API的AWS中的CloudWatch类似。 现在，我们正在研究平衡器和自动缩放。 但是，尽管我们不提供此类服务，但我们还是通过使用我们的监视和标签（AWS资源标签API）作为简单的服务发现作为数据源，让客户自己完成这项服务。 我们将在本文中展示...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用AWX，Ansible，haproxy和CROC Cloud进行DIY自动缩放</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/456826/"><p><img src="https://habrastorage.org/webt/6f/nt/tj/6fnttjgdk8vat9bbsahsnck_rfa.jpeg" alt="图片"></p><br><p> 不久前，我们为此进行了无代理监视和警报。 这与具有兼容API的AWS中的CloudWatch类似。 现在，我们正在研究平衡器和自动缩放。 但是，尽管我们不提供此类服务，但我们还是通过使用我们的监视和标签（AWS资源标签API）作为简单的服务发现作为数据源，让客户自己完成这项服务。 我们将在本文中展示如何执行此操作。 </p><a name="habracut"></a><br><p> 简单Web服务的最小基础结构的示例：DNS-&gt; 2个均衡器-&gt; 2个后端。 可以将这种基础结构视为容错操作和维护的最低要求。 因此，我们不会再“压缩”该基础架构，例如只剩下一个后端。 但是我想增加后端服务器的数量并减少到两个。 这将是我们的任务。 所有示例都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">资源库中找到</a> 。 </p><br><h3 id="bazovaya-infrastruktura"> 基本基础设施 </h3><br><p> 我们不会详细介绍上述基础结构的配置，只会显示如何创建它。 我们更喜欢使用Terraform部署基础架构。 它有助于快速创建所需的一切（VPC，子网，安全组，VM），并一次又一次地重复此过程。 </p><br><p> 用于提高基本基础结构的脚本： </p><br><div class="spoiler">  <b class="spoiler_title">主文件</b> <div class="spoiler_text"><pre><code class="bash hljs">variable <span class="hljs-string"><span class="hljs-string">"ec2_url"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"access_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"secret_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"region"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"vpc_cidr_block"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"big_instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"az"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"ami"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"client_ip"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"material"</span></span> {} provider <span class="hljs-string"><span class="hljs-string">"aws"</span></span> { endpoints { ec2 = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ec2_url}</span></span></span><span class="hljs-string">"</span></span> } skip_credentials_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_requesting_account_id = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_region_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.access_key}</span></span></span><span class="hljs-string">"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.secret_key}</span></span></span><span class="hljs-string">"</span></span> region = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.region}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_vpc"</span></span> <span class="hljs-string"><span class="hljs-string">"vpc"</span></span> { cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.vpc_cidr_block}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_subnet"</span></span> <span class="hljs-string"><span class="hljs-string">"subnet"</span></span> { availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_security_group"</span></span> <span class="hljs-string"><span class="hljs-string">"sg"</span></span> { name = <span class="hljs-string"><span class="hljs-string">"auto-scaling"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> ingress { from_port = 22 to_port = 22 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } ingress { from_port = 80 to_port = 80 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } ingress { from_port = 8080 to_port = 8080 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } egress { from_port = 0 to_port = 0 protocol = <span class="hljs-string"><span class="hljs-string">"-1"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } } resource <span class="hljs-string"><span class="hljs-string">"aws_key_pair"</span></span> <span class="hljs-string"><span class="hljs-string">"key"</span></span> { key_name = <span class="hljs-string"><span class="hljs-string">"auto-scaling-new"</span></span> public_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.material}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_instance"</span></span> <span class="hljs-string"><span class="hljs-string">"compute"</span></span> { count = 5 ami = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ami}</span></span></span><span class="hljs-string">"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${count.index == 0 ? var.big_instance_type : var.instance_type}</span></span></span><span class="hljs-string">"</span></span> key_name = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_key_pair.key.key_name}</span></span></span><span class="hljs-string">"</span></span> subnet_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_subnet.subnet.id}</span></span></span><span class="hljs-string">"</span></span> availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> security_groups = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_security_group.sg.id}</span></span></span><span class="hljs-string">"</span></span>] } resource <span class="hljs-string"><span class="hljs-string">"aws_eip"</span></span> <span class="hljs-string"><span class="hljs-string">"pub_ip"</span></span> { instance = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> vpc = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } output <span class="hljs-string"><span class="hljs-string">"awx"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_eip.pub_ip.public_ip}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"haproxy_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 1, 3)}</span></span></span><span class="hljs-string">"</span></span>] } output <span class="hljs-string"><span class="hljs-string">"awx_id"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"backend_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 3, 5)}</span></span></span><span class="hljs-string">"</span></span>] }</code> </pre> </div></div><br><p> 现代云的普通用户似乎应该理解此配置中描述的所有实体。 特定于我们的云和特定任务的变量将移至单独的文件-terraform.tfvars： </p><br><div class="spoiler">  <b class="spoiler_title">terraform.tfvars</b> <div class="spoiler_text"><pre> <code class="bash hljs">ec2_url = <span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"project:user@customer"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"secret-key"</span></span> region = <span class="hljs-string"><span class="hljs-string">"croc"</span></span> az = <span class="hljs-string"><span class="hljs-string">"ru-msk-vol51"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"m1.2small"</span></span> big_instance_type = <span class="hljs-string"><span class="hljs-string">"m1.large"</span></span> vpc_cidr_block = <span class="hljs-string"><span class="hljs-string">"10.10.0.0/16"</span></span> ami = <span class="hljs-string"><span class="hljs-string">"cmi-3F5B011E"</span></span></code> </pre> </div></div><br><p> 启动Terraform： </p><br><div class="spoiler">  <b class="spoiler_title">terraform适用</b> <div class="spoiler_text"><pre> <code class="bash hljs">yes yes | terraform apply -var client_ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(curl -s ipinfo.io/ip)</span></span></span><span class="hljs-string">/32"</span></span> -var material=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat &lt;ssh_publick_key_path&gt;)</span></span></span><span class="hljs-string">"</span></span></code> </pre> </div></div><br><h3 id="nastroyka-monitoringa"> 监控设置 </h3><br><p> 上面启动的VM由我们的云自动监视。 此监视数据将成为将来自动缩放的信息源。 依靠某些指标，我们可以增加或减少功率。 </p><br><p> 在我们的云中进行监视可以使您根据不同条件针对不同指标配置警报。 非常方便。 我们不需要任何时间间隔分析指标并做出决定-这将通过云监控来完成。 在此示例中，我们将使用警报作为CPU指标，但在我们的监控中，也可以针对以下指标配置警报：网络利用率（速度/ pps），磁盘利用率（速度/ iops）。 </p><br><div class="spoiler">  <b class="spoiler_title">cloudwatch put-metric-alarm</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CLOUDWATCH_URL=https://monitoring.cloud.croc.ru <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm \ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-low_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average \ --period 60 --evaluation-periods 3 --threshold 15 --comparison-operator LessThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm\ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-high_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average\ --period 60 --evaluation-periods 3 --threshold 80 --comparison-operator GreaterThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br><p> 一些可能难以理解的参数的描述： </p><br><p>  --profile-aws-cli设置配置文件，在〜/ .aws / config中描述。 通常，在不同的配置文件中设置不同的访问密钥。 </p><br><p>  --dimensions-在上面的示例中，该参数确定将针对哪个资源创建警报，该实例的标识符来自变量$ instance_id。 </p><br><p>  --namespace-从中选择监视指标的名称空间。 </p><br><p>  --metric-name-监视指标的名称。 </p><br><p>  --statistic-指标值聚合方法的名称。 </p><br><p>  --period-监视值收集事件之间的时间间隔。 </p><br><p>  --evaluation-periods-触发警报所需的时间间隔数。 </p><br><p>  --threshold-用于评估警报状态的度量标准阈值。 </p><br><p>  --comparison-operator-一种用于评估相对于阈值的指标值的方法。 </p></div></div><br><p> 在上面的示例中，为每个后端实例创建了两个警报。 当CPU负载小于15％的时间持续3分钟时，Scaling-low- &lt;instance-id&gt;将进入“警报”状态。 当CPU负载超过80％3分钟后，Scaling-high- &lt;instance-id&gt;将进入报警状态。 </p><br><h3 id="nastroyka-tegov"> 标签定制 </h3><br><p> 设置监视后，我们面临以下任务-实例及其名称的发现（服务发现）。 我们需要以某种方式了解我们现在已经启动了多少个后端实例，我们还需要知道它们的名称。 例如，在云之外的世界中，领事和领事模板将非常适合生成平衡器配置。 但是我们的云中有标签。 标签将帮助我们对资源进行分类。 通过请求有关特定标记（描述标记）的信息，我们可以了解池中当前有多少个实例以及它们具有什么ID。 默认情况下，唯一的实例ID用作主机名。 由于VPC内部有内部DNS，这些ID /主机名解析为内部IP实例。 </p><br><p> 我们为后端实例和平衡器设置标签： </p><br><div class="spoiler">  <b class="spoiler_title">ec2创建标签</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> EC2_URL=<span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"&lt;awx_instance_id&gt;"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=awx <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=backend ; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;haproxy_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=haproxy; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>;</code> </pre> <br><p> 其中： </p><br><p>  --resources-将设置标签的资源标识符的列表。 </p><br><p>  --tags是键值对的列表。 </p></div></div><br><p>  CROC Cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>提供了一个示例描述标签。 </p><br><h3 id="nastroyka-avtoskeylinga"> 自动缩放设置 </h3><br><p> 现在云正在监视，并且我们知道如何使用标签，我们只能轮询已配置警报的状态以进行触发。 在这里，我们需要一个实体，该实体将参与定期监视，监视和启动创建/删除实例的任务。 在这里可以应用各种自动化工具。 我们将使用AWX。  AWX是商业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ansible Tower</a>的开源版本，该产品用于集中管理Ansible基础架构。 主要任务是定期启动我们的ansible剧本。 </p><br><p>  AWX部署的示例可在官方存储库的<a href="">Wiki</a>页面上找到。  Ansible Tower文档中也描述了AWX配置。 为了使AWX开始运行自定义剧本，您必须通过创建以下实体对其进行配置： </p><br><ul><li> 三种类型的凭证： <br>  <em>-AWS凭证-授权与CROC云相关的操作。</em> <em><br></em>  -机器凭据-用于访问新创建实例的ssh密钥。 <br>  -SCM凭证-用于版本控制系统中的授权。 </li><li>  Project是一个实体，它将从剧本中推送git存储库。 </li><li> 脚本-动态清单脚本。 </li><li> 库存是一个实体，它将在启动剧本之前调用动态库存脚本。 </li><li> 模板-特定剧本调用的配置，由Project的一组凭据，清单和剧本组成。 </li><li> 工作流程-对剧本的一系列调用。 </li></ul><br><p> 自动缩放过程可以分为两个部分： </p><br><ul><li>  scale_up-至少触发一个高警报时创建一个实例； </li><li>  scale_down-如果低警报对其起作用，则终止该实例。 </li></ul><br><p> 作为scale_up部分的一部分，您将需要： </p><br><ul><li> 向云监视服务询问“警报”状态下是否存在高警报； </li><li> 如果所有高警报都处于“ OK”状态，则提前停止scale_up； </li><li> 创建具有必要属性（标签，子网，security_group等）的新实例； </li><li> 为正在运行的实例创建高低警报； </li><li> 在新实例中配置我们的应用程序（在我们的例子中，它只是带有测试页的nginx）； </li><li> 更新haproxy配置，重新加载，以使请求开始进入新实例。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">create-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: get alarm statuses describe_alarms: region: "croc" alarm_name_prefix: "scaling-high" alarm_state: "alarm" register: describe_alarms_query - name: stop if no alarms fired fail: msg: zero high alarms in alarm state when: describe_alarms_query.meta | length == 0 - name: create instance ec2: region: "croc" wait: yes state: present count: 1 key_name: "{{ hostvars[groups['tag_role_backend'][0]].ec2_key_name }}" instance_type: "{{ hostvars[groups['tag_role_backend'][0]].ec2_instance_type }}" image: "{{ hostvars[groups['tag_role_backend'][0]].ec2_image_id }}" group_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_security_group_ids }}" vpc_subnet_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_subnet_id }}" user_data: | #!/bin/sh sudo yum install epel-release -y sudo yum install nginx -y cat &lt;&lt;EOF &gt; /etc/nginx/conf.d/dummy.conf server { listen 8080; location / { return 200 '{"message": "$HOSTNAME is up"}'; } } EOF sudo systemctl restart nginx loop: "{{ hostvars[groups['tag_role_backend'][0]] }}" register: new - name: create tag entry ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc state: present resource: "{{ item.id }}" tags: role: backend loop: "{{ new.instances }}" - name: create low alarms ec2_metric_alarm: state: present region: croc name: "scaling-low_{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&lt;=" threshold: 15 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}" - name: create high alarms ec2_metric_alarm: state: present region: croc name: "scaling-high_{{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&gt;=" threshold: 80.0 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}"</code> </pre> </div></div><br><p> 在create-instance.yaml中，发生的事情是：使用正确的参数创建一个实例，对该实例进行标记并创建必要的警报。  Nginx安装和配置脚本也通过用户数据传递。 用户数据由cloud-init服务处理，该服务可在启动过程中灵活配置实例，而无需借助其他自动化工具。 </p><br><p> 在update-lb.yaml中，在haproxy实例和重新加载haproxy服务上重新创建/etc/haproxy/haproxy.cfg文件： </p><br><div class="spoiler">  <b class="spoiler_title">update-lb.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: update haproxy configs template: src: haproxy.cfg.j2 dest: /etc/haproxy/haproxy.cfg - name: add new backend host to haproxy systemd: name: haproxy state: restarted</code> </pre> </div></div><br><p> 其中haproxy.cfg.j2是haproxy服务配置文件模板： </p><br><div class="spoiler">  <b class="spoiler_title">haproxy.cfg.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># {{ ansible_managed }} global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats timeout 30s user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend loadbalancing bind *:80 mode http default_backend backendnodes backend backendnodes balance roundrobin option httpchk HEAD / {% for host in groups['tag_role_backend'] %} server {{hostvars[host]['ec2_id']}} {{hostvars[host]['ec2_private_ip_address']}}:8080 check {% endfor %}</code> </pre> </div></div><br><p> 由于选项httpchk选项是在haproxy后端部分中定义的，因此haproxy服务将自动轮询后端实例的状态，并且仅平衡过去运行状况检查之间的流量。 </p><br><p> 在scale_down部分中，您需要： </p><br><ul><li> 检查状态低报警； </li><li> 如果在“警报”状态下没有低警报，则过早终止播放； </li><li> 终止所有属于低警报级别的实例； </li><li> 禁止终止最后一对实例，即使它们的警报处于“警报”状态； </li><li> 删除我们从负载均衡器配置中删除的实例。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">destroy-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: look for alarm status describe_alarms: region: "croc" alarm_name_prefix: "scaling-low" alarm_state: "alarm" register: describe_alarms_query - name: count alarmed instances set_fact: alarmed_count: "{{ describe_alarms_query.meta | length }}" alarmed_ids: "{{ describe_alarms_query.meta }}" - name: stop if no alarms fail: msg: no alarms fired when: alarmed_count | int == 0 - name: count all described instances set_fact: all_count: "{{ groups['tag_role_backend'] | length }}" - name: fail if last two instance remaining fail: msg: cant destroy last two instances when: all_count | int == 2 - name: destroy tags for marked instances ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc resource: "{{ alarmed_ids[0].split('_')[1] }}" state: absent tags: role: backend - name: destroy instances ec2: region: croc state: absent instance_ids: "{{ alarmed_ids[0].split('_')[1] }}" - name: destroy low alarms ec2_metric_alarm: state: absent region: croc name: "scaling-low_{{ alarmed_ids[0].split('_')[1] }}" - name: destroy high alarms ec2_metric_alarm: state: absent region: croc name: "scaling-high_{{ alarmed_ids[0].split('_')[1] }}"</code> </pre> </div></div><br><p> 在destroy-instance.yaml中，删除警报，终止实例及其标签，并检查禁止终止最近实例的条件。 </p><br><p> 由于删除实例后，与之关联的标签将被推迟删除并且可以再使用一分钟，因此我们在删除实例后显式删除标签。 <br>  AWX </p><br><h3 id="nastroyka-zadach-shablonov"> 设置任务，模板 </h3><br><p> 以下任务集将在AWX中创建必要的实体： </p><br><div class="spoiler">  <b class="spoiler_title">awx-configure.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: Create tower organization tower_organization: name: "scaling-org" description: "scaling-org organization" state: present - name: Add tower cloud credential tower_credential: name: cloud description: croc cloud api creds organization: scaling-org kind: aws state: present username: "{{ croc_user }}" password: "{{ croc_password }}" - name: Add tower github credential tower_credential: name: ghe organization: scaling-org kind: scm state: present username: "{{ ghe_user }}" password: "{{ ghe_password }}" - name: Add tower ssh credential tower_credential: name: ssh description: ssh creds organization: scaling-org kind: ssh state: present username: "ec2-user" ssh_key_data: "{{ lookup('file', 'private.key') }}" - name: Add tower project tower_project: name: "auto-scaling" scm_type: git scm_credential: ghe scm_url: &lt;repo-name&gt; organization: "scaling-org" scm_branch: master state: present - name: create inventory tower_inventory: name: dynamic-inventory organization: "scaling-org" state: present - name: copy inventory script to awx copy: src: "{{ role_path }}/files/ec2.py" dest: /root/ec2.py - name: create inventory source shell: | export SCRIPT=$(tower-cli inventory_script create -n "ec2-script" --organization "scaling-org" --script @/root/ec2.py | grep ec2 | awk '{print $1}') tower-cli inventory_source create --update-on-launch True --credential cloud --source custom --inventory dynamic-inventory -n "ec2-source" --source-script $SCRIPT --source-vars '{"EC2_URL":"api.cloud.croc.ru","AWS_REGION": "croc"}' --overwrite True - name: Create create-instance template tower_job_template: name: "create-instance" job_type: "run" inventory: "dynamic-inventory" credential: "cloud" project: "auto-scaling" playbook: "create-instance.yaml" state: "present" register: create_instance - name: Create update-lb template tower_job_template: name: "update-lb" job_type: "run" inventory: "dynamic-inventory" credential: "ssh" project: "auto-scaling" playbook: "update-lb.yaml" credential: "ssh" state: "present" register: update_lb - name: Create destroy-instance template tower_job_template: name: "destroy-instance" job_type: "run" inventory: "dynamic-inventory" project: "auto-scaling" credential: "cloud" playbook: "destroy-instance.yaml" credential: "ssh" state: "present" register: destroy_instance - name: create workflow tower_workflow_template: name: auto_scaling organization: scaling-org schema: "{{ lookup('template', 'schema.j2')}}" - name: set scheduling shell: | tower-cli schedule create -n "3min" --workflow "auto_scaling" --rrule "DTSTART:$(date +%Y%m%dT%H%M%SZ) RRULE:FREQ=MINUTELY;INTERVAL=3"</code> </pre> </div></div><br><p> 上一片段将为每个使用的ansible剧本创建一个模板。 每个模板都使用一组已定义的凭据和清单来配置一个剧本的启动。 </p><br><p> 要构建用于调用剧本的管道，将允许工作流程模板。 设置自动缩放的工作流程如下： </p><br><div class="spoiler">  <b class="spoiler_title">schema.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- failure_nodes: - id: 101 job_template: {{ destroy_instance.id }} success_nodes: - id: 102 job_template: {{ update_lb.id }} id: 103 job_template: {{ create_instance.id }} success_nodes: - id: 104 job_template: {{ update_lb.id }}</code> </pre> </div></div><br><p> 上一个模板显示了工作流程图，即 模板执行的顺序。 在此工作流程中，仅在成功完成上一个步骤之后，才执行每个下一个步骤（success_nodes）。 图中显示了工作流程的图形表示： <br><img src="https://habrastorage.org/webt/po/l-/vb/pol-vbfpulv4hoimk99mvbtig-u.png" alt="工作流程"></p><br><p> 结果，创建了一个通用的工作流，该工作流执行create-instace剧本，并根据执行状态，销毁实例和/或update-lb剧本。 集成的工作流程便于按给定的时间表运行。 自动缩放过程将每三分钟启动一次，根据警报状态启动和终止实例。 </p><br><h3 id="testirovanie-raboty"> 工作测试 </h3><br><p> 现在检查配置的系统的操作。 首先，安装用于http基准测试的wrk实用程序。 </p><br><div class="spoiler">  <b class="spoiler_title">wrk安装</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;aws_instance_ip&gt; sudo su - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt yum groupinstall <span class="hljs-string"><span class="hljs-string">'Development Tools'</span></span> yum install -y openssl-devel git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/wg/wrk.git wrk <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> wrk make install wrk /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p> 我们将使用云监视来监视负载期间实例资源的使用： </p><br><div class="spoiler">  <b class="spoiler_title">监控</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function CPUUtilizationMonitoring() { local AWS_CLI_PROFILE="&lt;aws_cli_profile&gt;" local CLOUDWATCH_URL="https://monitoring.cloud.croc.ru" local API_URL="https://api.cloud.croc.ru" local STATS="" local ALARM_STATUS="" local IDS=$(aws --profile $AWS_CLI_PROFILE --endpoint-url $API_URL ec2 describe-instances --filter Name=tag:role,Values=backend | grep -i instanceid | grep -oE 'i-[a-zA-Z0-9]*' | tr '\n' ' ') for instance_id in $IDS; do STATS="$STATS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch get-metric-statistics --dimensions Name=InstanceId,Value=$instance_id --namespace "AWS/EC2" --metric CPUUtilization --end-time $(date --iso-8601=minutes) --start-time $(date -d "$(date --iso-8601=minutes) - 1 min" --iso-8601=minutes) --period 60 --statistics Average | grep -i average)"; ALARMS_STATUS="$ALARMS_STATUS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch describe-alarms --alarm-names scaling-high-$instance_id | grep -i statevalue)" done echo $STATS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t echo $ALARMS_STATUS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t } export -f CPUUtilizationMonitoring watch -n 60 bash -c CPUUtilizationMonitoring</code> </pre> </div></div><br><p> 前一个脚本每60秒一次获取有关最后一分钟的CPUUtilization指标平均值的信息，并轮询后端实例的警报状态。 </p><br><p> 现在，您可以运行wrk并查看负载下的后端实例的资源利用率： </p><br><div class="spoiler">  <b class="spoiler_title">运行</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;awx_instance_ip&gt; wrk -t12 -c100 -d500s http://&lt;haproxy_instance_id&gt; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p> 最后一条命令将使用12个线程并打开100个http连接来启动基准测试500秒。 </p><br><p> 随着时间的流逝，监视脚本应显示在基准测试期间，CPUUtilization指标的统计信息值会增加，直到达到300％。 基准测试开始后180秒，StateValue标志应切换到“警报”状态。 每两分钟一次，自动缩放工作流程开始。 默认情况下，禁止并行执行同一工作流程。 也就是说，每两分钟，将执行工作流程的任务添加到队列中，并且仅在前一个任务完成后才启动。 因此，当wrk运行时，资源将不断增加，直到所有后端实例的高警报进入OK状态为止。 完成后，wrk scale_down工作流程将终止除两个后端实例之外的所有实例。 </p><br><p> 监视脚本的示例输出： </p><br><div class="spoiler">  <b class="spoiler_title">监测结果</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># start test i-43477460 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # start http load i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 111.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # alarm state i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 282.0 i-43477460 |i-AC5D9EE0 "StateValue": "alarm"| "StateValue": "alarm" # two new instances created i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "Average": 185.0 | "Average": 215.0 | "Average": 245.0 | i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "StateValue": "insufficient_data"| "StateValue": "insufficient_data"| "StateValue": "alarm"| "StateValue": "alarm" # only two instances left after load has been stopped i-935BAB40 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-935BAB40 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok"</code> </pre> </div></div><br><p> 同样在CROC Cloud中，您可以在相应选项卡的实例页面上查看监视帖子中使用的图形。 </p><br><p> 查看警报可在“警报”选项卡的“监视”页面上找到。 </p><br><h3 id="zaklyuchenie"> 结论 </h3><br><p> 自动缩放是一种非常流行的方案，但是不幸的是，它尚未出现在我们的云中（但仅在现在）。 但是，我们有许多强大的API可以使用流行的，几乎标准的工具（例如Terraform，ansible，aws-cli等）来执行类似操作以及许多其他操作。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456826/">https://habr.com/ru/post/zh-CN456826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456812/index.html">ITMO大学有什么-IT节，黑客马拉松，会议和公开研讨会</a></li>
<li><a href="../zh-CN456814/index.html">在10分钟内学习Python中的函数式编程</a></li>
<li><a href="../zh-CN456818/index.html">一家无法接近的公司的系统管理员。 难以承受的负担？</a></li>
<li><a href="../zh-CN456820/index.html">黏土→砖→火炉</a></li>
<li><a href="../zh-CN456824/index.html">什么是概率以及如何计算</a></li>
<li><a href="../zh-CN456828/index.html">印刷电路板的调整过孔</a></li>
<li><a href="../zh-CN456830/index.html">Vivaldi 2.6-夏日娱乐</a></li>
<li><a href="../zh-CN456836/index.html">选择：您可能不知道的5种显而易见的竞争分析工具</a></li>
<li><a href="../zh-CN456838/index.html">ICE评分介绍产品功能优先级</a></li>
<li><a href="../zh-CN456840/index.html">SDL 2课：第6课-原语</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>