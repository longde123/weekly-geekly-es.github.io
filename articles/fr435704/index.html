<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 💂 👷🏼 Solutions architecturales pour un jeu mobile. Partie 2: commande et leurs files d'attente 🍔 👨🏽‍🤝‍👨🏼 👩🏽‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la première partie de l'article, nous avons examiné comment le modèle doit être organisé de manière à être facile à utiliser, mais le débogage et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solutions architecturales pour un jeu mobile. Partie 2: commande et leurs files d'attente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435704/"><img src="https://habrastorage.org/webt/1n/ji/xq/1njixqpyay22mmuyckufhgouye8.jpeg"><br><br>  Dans la première partie de l'article, nous avons examiné comment le modèle doit être organisé de manière à être facile à utiliser, mais le débogage et le vissage des interfaces sont simples.  Dans cette partie, nous considérerons le retour des commandes de changements dans le modèle, dans toute sa beauté et sa diversité.  Comme précédemment, la priorité pour nous sera la commodité du débogage, en minimisant les gestes qu'un programmeur doit faire pour créer une nouvelle fonctionnalité, ainsi que la lisibilité du code pour une personne. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solutions architecturales pour un jeu mobile.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: Modèle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solutions architecturales pour un jeu mobile.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: Vue sur la poussée du jet</a> <br><a name="habracut"></a><br><h2>  Pourquoi commander </h2><br>  Le modèle de commande sonne fort, mais en fait c'est juste un objet dans lequel tout ce qui est nécessaire pour l'opération demandée y est ajouté et stocké.  Nous choisissons cette approche, au moins parce que nos équipes seront envoyées sur le réseau, et même nous obtiendrons quelques copies de l'état du jeu pour un usage officiel.  Ainsi, lorsque l'utilisateur clique sur le bouton, une instance de la classe de commandes est créée et envoyée au destinataire.  La signification de la lettre C dans l'abréviation MVC est quelque peu différente. <br><br><h2>  Prédiction des résultats et vérification des commandes sur le réseau </h2><br>  Dans ce cas, le code spécifique est moins important que l'idée.  Et voici l'idée: <br><br>  Un jeu qui se respecte ne peut pas attendre une réponse du serveur avant de réagir au bouton.  Bien sûr, Internet s'améliore et vous pouvez avoir un tas de serveurs partout dans le monde, et je connais même quelques jeux réussis en attente d'une réponse du serveur, l'un d'eux est même Summoning Wars, mais vous n'avez toujours pas besoin de le faire.  Parce que pour l'internet mobile, des retards de 5 à 15 secondes sont plus susceptibles d'être la norme qu'une exception, à Moscou au moins, le jeu devrait être vraiment génial pour que les joueurs n'y fassent pas attention. <br><br>  En conséquence, nous avons un état de jeu qui représente toutes les informations nécessaires à l'interface, et les commandes lui sont appliquées immédiatement, et seulement après cela, elles sont envoyées au serveur.  Habituellement, les programmeurs java assidus sont assis sur le serveur, dupliquant toutes les nouvelles fonctionnalités une à une dans une autre langue.  Sur notre projet «cerfs», leur nombre a atteint 3 personnes, et les erreurs commises lors du portage ont été une source constante de joie insaisissable.  Au lieu de cela, nous pouvons le faire différemment.  Nous exécutons sur le serveur .Net et exécutons côté serveur le même code de commande que sur le client. <br><br>  Le modèle décrit dans le dernier article nous offre une nouvelle opportunité intéressante pour l'auto-test.  Après avoir exécuté la commande sur le client, nous calculerons le hachage de la modification survenue dans l'arborescence GameState et l'appliquerons à l'équipe.  Si le serveur exécute le même code de commande et que le hachage des modifications ne correspond pas, alors quelque chose s'est mal passé. <br><br>  Premiers avantages: <br><br><ul><li>  Cette solution accélère considérablement le développement et minimise le nombre de programmeurs de serveurs. </li><li>  Si le programmeur a fait des erreurs conduisant à un comportement non déterministe, par exemple, il a obtenu la première valeur du dictionnaire, ou a utilisé DateTime.now, et a généralement utilisé certaines valeurs non écrites explicitement dans les champs de commande, puis quand heh démarre sur le serveur, elles ne correspondront pas, et nous le découvrirons. </li><li>  Le développement client peut pour l'instant se faire sans serveur du tout.  Vous pouvez même passer en alpha convivial sans avoir de serveur.  C'est utile non seulement pour les développeurs indépendants qui manquent leur jeu de rêve la nuit.  Quand j'étais à Piksonik, il y a eu un cas où le programmeur du serveur a perdu tous les polymères, et notre jeu a été contraint de subir une modération, ayant au lieu du serveur un mannequin défendant stupidement tout l'état du jeu de temps en temps. </li></ul><br>  Un inconvénient qui, pour une raison quelconque, est systématiquement sous-estimé: <br><br><ul><li>  Si le programmeur client a fait quelque chose de mal et qu'il est invisible pendant le test, par exemple, la probabilité de marchandises dans les boîtes mystérieuses, alors personne ne peut écrire la même chose une deuxième fois et trouver une erreur.  Le code autoportable nécessite une attitude beaucoup plus responsable envers les tests. </li></ul><br><h2>  Informations de débogage détaillées </h2><br>  L'une de nos priorités déclarées est la commodité du débogage.  Si lors de l'exécution de l'équipe, nous avons attrapé l'exécution - tout est clair, nous rétrogradons l'état du jeu, envoyons l'état complet aux journaux et sérialisons la commande qui l'a déposé, tout est pratique et beau.  La situation est plus compliquée si nous avons une désynchronisation avec le serveur.  Parce que le client a déjà exécuté plusieurs autres commandes depuis lors, et il s'avère non seulement de savoir dans quel état était le modèle avant d'exécuter la commande qui a conduit à la catastrophe, mais je le veux vraiment.  Cloner un gamestate devant chaque équipe est trop compliqué et trop cher.  Pour résoudre le problème, nous compliquons le schéma cousu sous le capot du moteur. <br><br>  Chez le client, nous n'aurons pas un État gamest, mais deux.  Le premier sert d'interface principale pour le rendu, les commandes lui sont appliquées immédiatement.  Après cela, les commandes appliquées sont mises en file d'attente pour être envoyées au serveur.  Le serveur effectue la même action de son côté et confirme que tout va bien et est correct.  Après avoir reçu la confirmation, le client prend la même commande et l'applique au deuxième gamestate, l'amenant à l'état qui a déjà été confirmé par le serveur comme correct.  Dans le même temps, nous avons également la possibilité de comparer le hachage des modifications apportées pour être sûr, et nous pouvons également comparer le hachage complet de l'arborescence entière sur le client, que nous pouvons calculer après l'exécution de la commande, il pèse un peu et est considéré comme assez rapide.  Si le serveur ne dit pas que tout va bien, il demande au client des détails sur ce qui s'est passé, et le client peut lui envoyer un deuxième état de jeu sérialisé exactement tel qu'il était avant que la commande ne soit exécutée avec succès sur le client. <br>  La solution semble très attrayante, mais elle pose deux problèmes qui doivent être résolus au niveau du code: <br><br><ul><li>  Parmi les paramètres de commande, il peut y avoir non seulement des types simples, mais aussi des liens vers des modèles.  Dans un autre État de jeu, au même endroit exact se trouvent d'autres objets du modèle.  Nous résolvons ce problème de la manière suivante: Avant l'exécution de la commande sur le client, nous sérialisons toutes ses données.  Parmi eux, il peut y avoir des liens vers des modèles, que nous écrirons sous forme de chemin vers le modèle depuis la racine de l'état du jeu.  Nous le faisons avant l'équipe, car après son exécution, les chemins peuvent changer.  Ensuite, nous envoyons ce chemin au serveur, et le gamestate du serveur pourra obtenir un lien vers son modèle en cours de route.  De même, lorsqu'une équipe est appliquée au deuxième état de jeu, le modèle peut être obtenu à partir du deuxième état de jeu. </li><li>  En plus des types et modèles élémentaires, une équipe peut avoir des liens vers des collections.  Dictionnaire &lt;clé, modèle&gt;, Dictionnaire &lt;modèle, clé&gt;, Liste &lt;Modèle&gt;, Liste &lt;Valeur&gt;.  Pour chacun d'eux, ils doivent écrire des sérialiseurs.  Certes, vous ne pouvez pas vous précipiter là-dedans, dans un vrai projet, de tels domaines surviennent étonnamment rarement. </li><li>  L'envoi de commandes au serveur une à la fois n'est pas une bonne idée, car l'utilisateur peut les produire plus rapidement qu'Internet ne peut les faire glisser d'avant en arrière, sur un Internet médiocre, le pool de commandes non élaboré par le serveur augmentera.  Au lieu d'envoyer des commandes une par une, nous les enverrons par lots de plusieurs pièces.  Dans ce cas, après avoir reçu une réponse du serveur que quelque chose s'est mal passé, vous devrez d'abord appliquer au deuxième état toutes les commandes précédentes du même package qui ont été confirmées par le serveur, puis seulement effacer et envoyer le deuxième état de contrôle au serveur. </li></ul><br><h2>  Commodité et facilité d'écriture des commandes </h2><br>  Le code d'exécution des commandes est le deuxième plus grand et le premier code le plus responsable du jeu.  Plus ce sera simple et clair, et moins le programmeur aura besoin de faire plus avec ses mains pour l'écrire, plus le code sera écrit rapidement, moins il y aura d'erreurs et, de manière très inattendue, plus le programmeur sera heureux.  Je place le code d'exécution directement dans la commande elle-même, en plus des pièces et fonctions générales qui se trouvent dans des classes de règles statiques distinctes, le plus souvent sous la forme d'extensions aux classes de modèle avec lesquelles elles fonctionnent.  Je vais vous montrer quelques exemples de commandes de mon projet pour animaux de compagnie, l'une très simple et l'autre un peu plus compliquée: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetSideCostCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//              protected override bool DetaliedLog { get { return true; } } public FCMatchModel match; public int newCost; protected override void HexApply(HexKingdomsRoot root) { match.sideCost = newCost; match.CalculateAssignments(); match.CalculateNextUnassignedPlayer(); } } }</span></span></code> </pre> <br>  Et voici le journal que cette commande laisse après elle-même, si ce journal n'est pas désactivé pour cela. <br><br><pre> <code class="json hljs">[FCSetSideCostCommand id=<span class="hljs-number"><span class="hljs-number">1</span></span> match=FCMatchModel[<span class="hljs-number"><span class="hljs-number">0</span></span>] newCost=<span class="hljs-number"><span class="hljs-number">260</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0027546</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0008689</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"0"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"SIDE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"1"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}}}}</code> </pre> <br>  La première fois indiquée dans le journal est le temps pendant lequel toutes les modifications nécessaires ont été apportées au modèle, et la seconde est le temps pendant lequel toutes les modifications ont été effectuées par les contrôleurs d'interface.  Cela devrait être indiqué dans le journal afin de ne pas faire accidentellement quelque chose de terriblement lent, ou de remarquer à temps si les opérations commencent à prendre trop de temps simplement en raison de la taille du modèle lui-même. <br><br>  Mis à part les appels à des objets persistants sur Id-shniks, qui réduisent considérablement la lisibilité du journal, ce qui aurait d'ailleurs pu être évité ici, le code de commande lui-même et le journal qu'il a fait avec l'état du jeu sont incroyablement clairs.  Veuillez noter que dans le texte de la commande, le programmeur ne fait aucun mouvement supplémentaire.  Tout ce dont vous avez besoin est fait par le moteur sous le capot. <br><br>  Voyons maintenant un exemple d'une plus grande équipe <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetUnitForPlayerCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//            protected override bool DetaliedLog { get { return true; } } public FCSelectArmyScreenModel screen; public string unit; public int count; protected override void HexApply(HexKingdomsRoot root) { if (count == 0 &amp;&amp; screen.player.units.ContainsKey(unit)) { screen.player.units.Remove(unit); screen.selectedUnits.Remove(unit); } else if (count != 0) { if (screen.player.units.ContainsKey(unit)) { screen.player.units[unit] = count; screen.selectedUnits[unit].count = count; } else { screen.player.units.Add(unit, count); screen.selectedUnits[unit] = new ReferenceUnitModel() { type = unit, count = count }; } } screen.SetSelectedReferenceUnits(); screen.player.CalculateUnitsCost(); var side = screen.match.sides[screen.side]; screen.match.CalculatePlayerAssignmentsAcceptablity(side); screen.match.CalculateNextUnassignedPlayer(screen.player); } } }</span></span></code> </pre> <br>  Et voici le journal laissé par l'équipe: <br><br><pre> <code class="json hljs">[FCSetUnitForPlayerCommand id=<span class="hljs-number"><span class="hljs-number">3</span></span> screen=/UI_SCREENS[main] unit=militia count=<span class="hljs-number"><span class="hljs-number">1</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0065625</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0004573</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}}, <span class="hljs-attr"><span class="hljs-attr">"ASSIGNED"</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>}}}, <span class="hljs-attr"><span class="hljs-attr">"UI_SCREENS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"SELECTED_UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"@new"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"TYPE"</span></span>:<span class="hljs-string"><span class="hljs-string">"militia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"REMARK"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"COUNT"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SELECTED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"DISABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_GREEN"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_RED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"BUTTON_ENABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}}}}}}}</code> </pre> <br>  Comme on dit, c'est beaucoup plus clair.  Prenez le temps d'équiper l'équipe d'un journal pratique, compact et informatif.  C'est la clé de votre bonheur.  Le modèle doit fonctionner très rapidement, nous y avons donc utilisé une variété d'astuces avec des méthodes de stockage et d'accès aux champs.  Les commandes sont exécutées dans le pire des cas une fois par trame, en fait, plusieurs fois moins souvent, nous allons donc effectuer la sérialisation et la désérialisation des champs de commande sans aucune fantaisie, juste par réflexion.  Nous ne trions les champs que par nom afin que l'ordre soit fixe, eh bien, nous compilerons la liste des champs une fois pendant la durée de vie de la commande, et nous lirons en utilisant des méthodes natives C #. <br><br><h2>  Modèle d'information pour l'interface. </h2><br>  Prenons la prochaine étape pour compliquer notre moteur, une étape qui semble effrayante, mais qui simplifie considérablement l'écriture et le débogage des interfaces.  Très souvent, en particulier dans le modèle MVP associé, le modèle ne contient que la logique métier contrôlée par le serveur et les informations sur l'état de l'interface sont stockées dans le présentateur.  Par exemple, vous souhaitez commander cinq billets.  Vous avez déjà sélectionné leur numéro, mais vous n'avez pas encore cliqué sur le bouton "commander".  Les informations sur le nombre exact de billets que vous avez choisis dans le formulaire peuvent être stockées quelque part dans les coins secrets de la classe, qui sert de joint entre le modèle et son affichage.  Ou, par exemple, le joueur passe d'un écran à un autre, mais rien ne change dans le modèle, et où il se trouvait lorsque la tragédie s'est produite, le programmeur de débogage ne sait que par les mots d'un testeur extrêmement discipliné.  L'approche est simple, compréhensible, presque toujours utilisée et un peu malveillante, à mon avis.  Parce que si quelque chose a mal tourné, l'état de ce présentateur, qui a conduit à une erreur, est absolument impossible à découvrir.  Surtout si l'erreur s'est produite sur le serveur de combat lors de l'opération pour 1000 $, et non sur le testeur dans un environnement contrôlé et reproductible. <br><br>  Au lieu de cette approche habituelle, nous interdisons à quiconque, à l'exception du modèle, de contenir des informations sur l'état de l'interface.  Cela a, comme d'habitude, des avantages et des inconvénients qui doivent être combattus. <br><br><ul><li>  <b>(+1)</b> L'avantage le plus important, économiser des mois de travail de programmation - en cas de problème, le programmeur charge simplement l'état du jeu avant l'accident et reçoit exactement le même état non seulement du modèle commercial, mais de l'interface entière jusqu'au dernier bouton de l'écran. </li><li>  <b>(+2)</b> Si une équipe a changé quelque chose dans l'interface, le programmeur peut facilement aller dans le journal et voir exactement ce qui a changé sous une forme json pratique, comme dans la section précédente. </li><li>  <b>(-1)</b> Beaucoup d'informations redondantes apparaissent dans le modèle qui ne sont pas nécessaires pour comprendre la logique métier du jeu et ne sont pas nécessaires deux fois par le serveur. </li></ul><br>  Pour résoudre ce problème, nous marquerons certains champs comme notServerVerified, cela ressemble à ceci, par exemple, comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EDictionary&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; uiScreens { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UI_SCREENS.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; UI_SCREENS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt;() { notServerVerified = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre> <br>  Cette partie du modèle et tout ce qui se trouve en dessous concernera exclusivement le client. <br><br>  Si vous vous souvenez encore, les indicateurs de ce que vous devez exporter et de ce qui ne ressemble pas à ceci: <br><br><pre> <code class="cpp hljs">[Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ExportMode { all = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, changes = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, serverVerified = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }</code> </pre> <br>  Par conséquent, lors de l'exportation ou du calcul d'un hachage, vous pouvez spécifier s'il faut exporter la totalité de l'arborescence ou uniquement la partie de celle-ci qui est vérifiée par le serveur. <br><br>  La première complication évidente qui en résulte est la nécessité de créer des commandes distinctes qui doivent être vérifiées par le serveur et celles qui ne sont pas nécessaires, mais il y a aussi celles qui doivent être vérifiées pas entièrement.  Afin de ne pas charger le programmeur avec des opérations inutiles pour configurer la commande, nous essaierons à nouveau de faire tout ce qui est nécessaire avec le capot moteur. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;    ,      &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;         &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyClientSide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  Le programmeur qui crée la commande peut remplacer l'une ou les deux de ces fonctions.  Bien sûr, tout cela est merveilleux, mais comment puis-je m'assurer que le programmeur n'a rien gâché et s'il a gâché quelque chose - comment peut-il l'aider rapidement et facilement à le réparer?  Il y a deux façons.  J'ai appliqué le premier, mais vous aimerez peut-être davantage le second. <br><br><h3>  Première voie </h3><br>  Nous utilisons les fonctionnalités intéressantes de notre modèle: <br><br><ol><li>  Le moteur appelle la première fonction, après quoi il reçoit un hachage de changements dans la partie vérifiée par le serveur de l'état du jeu.  S'il n'y a pas de changement, nous traitons exclusivement avec l'équipe client. </li><li>  Nous obtenons le hachage du modèle des changements dans le modèle entier, pas seulement celui vérifié par le serveur.  S'il diffère du hachage précédent, le programmeur a foiré et changé quelque chose dans la partie du modèle qui n'a pas été vérifiée par le serveur.  Nous parcourons l'arbre d'état et vidons le programmeur en tant qu'exécution d'une liste complète des champs notServerVerified = true et de ceux situés en dessous de l'arbre qu'il a changé. </li><li>  Nous appelons la deuxième fonction.  Nous obtenons du modèle un hachage des changements survenus dans la partie vérifiée.  S'il ne coïncide pas avec le hachage après le premier appel, alors dans la deuxième fonction, le programmeur a fait n'importe quoi.  Si nous voulons obtenir un journal très informatif dans ce cas, nous restaurons le modèle entier à son état d'origine, le sérialisons dans un fichier, puis le programmeur sera utile pour le débogage, puis le clonera en entier (deux lignes - sérialisation-désérialisation), et maintenant nous appliquons d'abord le premier , nous validons les modifications afin que le modèle ne change pas, après quoi nous appliquons la deuxième fonction.  Et puis nous exportons toutes les modifications dans la partie vérifiée par le serveur sous la forme de JSON et l'incluons dans l'exécution abusive, afin que le programmeur honteux puisse immédiatement voir ce qu'il a changé et où il a changé, ce qui ne devrait pas être changé. </li></ol><br>  Cela a l'air bien sûr effrayant, mais en fait c'est 7 lignes, parce que les fonctions qui font tout cela (sauf traverser l'arbre depuis le deuxième paragraphe), nous sommes prêts.  Et comme il s'agit de réception, nous pouvons nous permettre d'agir de manière non optimale. <br><br><h3>  Deuxième voie </h3><br>  Un peu plus brutal, maintenant dans ModelRoot, nous avons un champ de verrouillage, mais nous pouvons le diviser en deux, l'un ne verrouillera que les champs vérifiés sur le serveur, l'autre uniquement les champs vérifiés.  Dans ce cas, le programmeur qui a fait quelque chose de mal recevra immédiatement une explication à ce sujet avec un lien avec l'endroit où il l'a fait.  Le seul inconvénient de cette approche est que si dans notre arbre une propriété de modèle est marquée comme non vérifiable, alors tout ce qui se trouve dans l'arbre en dessous concernant le calcul des hachages et le contrôle des modifications ne sera pas inspecté, même si chaque champ n'a pas été marqué.  Un verrou, bien sûr, ne regardera pas dans la hiérarchie, ce qui signifie que tous les champs de la partie non contrôlée de l'arbre devront être marqués, et il ne fonctionnera pas à certains endroits pour utiliser les mêmes classes dans l'interface utilisateur et la partie habituelle de l'arbre.  En option, une telle construction est possible (je l'écrirai simplifiée): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameState</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelData data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelLocal local; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> locked { get; } }</code> </pre> <br>  Il s'avère ensuite que chaque sous-arbre a son propre verrou.  GameState hérite des modèles, car il est plus facile que de proposer une implémentation distincte de toutes les mêmes fonctionnalités pour lui. <br><br><h3>  Améliorations nécessaires </h3><br>  Bien entendu, le responsable du traitement des équipes devra ajouter de nouvelles fonctionnalités.  L'essence des modifications sera que toutes les commandes ne seront pas envoyées au serveur, mais uniquement celles qui créent les modifications vérifiées.  Le serveur de son côté ne soulèvera pas l'arborescence d'état du jeu entier, mais uniquement la partie vérifiée, et en conséquence le hachage ne coïncidera que pour la partie vérifiée.  Lorsqu'une commande est exécutée sur le serveur, seule la première des deux fonctions de la commande sera lancée, et lors de la résolution des références aux modèles dans le gamestate, si le chemin mène à une partie non vérifiable de l'arborescence, null sera placé dans la variable de commande au lieu du modèle.  Toutes les équipes non envoyeuses se conformeront honnêtement aux équipes habituelles, mais seront considérées comme déjà confirmées.  Dès qu'ils atteignent la ligne et qu'il n'y en a pas non confirmés devant eux, ils seront immédiatement appliqués au deuxième état. <br><br>  Il n'y a rien de fondamentalement compliqué dans la mise en œuvre.  C'est juste que la propriété de chaque champ du modèle a une autre condition, une traversée d'arbre. <br><br>  Un autre raffinement nécessaire - vous aurez besoin de Factory for ParsistentModel distinct dans les parties vérifiées et non vérifiées de l'arborescence et NextFreeId sera différent pour elles. <br><br><h2>  Commandes lancées par le serveur </h2><br>  Il y a un problème si le serveur veut envoyer sa commande au client, car l'état du client par rapport au serveur peut déjà avancer de quelques pas.  L'idée principale est que si le serveur devait envoyer sa commande, il envoie la notification du serveur au client avec la réponse suivante et l'écrit dans le champ des notifications envoyées à ce client.  Le client reçoit une notification, forme une commande sur sa base et la place à la fin de sa file d'attente, après celles qui se sont terminées sur le client mais qui n'ont pas encore atteint le serveur.  Après un certain temps, la commande est envoyée au serveur dans le cadre du processus normal de travail avec le modèle.  Ayant reçu cette commande pour traitement, le serveur jette la notification hors de la file d'attente sortante.  Si le client n'a pas répondu à la notification dans le délai défini avec le package suivant, une commande de redémarrage lui est envoyée.  Si le client qui a reçu la notification est tombé, se connecte plus tard ou, pour une raison quelconque, charge le jeu, le serveur transformera toutes les notifications en commandes avant de lui donner l'état, les exécutera de son côté, et ce n'est qu'après cela que le client rejoignant son nouvel état.  Veuillez noter qu'un joueur peut avoir un état conflictuel avec des ressources négatives lorsque le joueur a réussi à dépenser l'argent exactement au moment où le serveur les lui a pris.  La coïncidence est peu probable, mais avec une grande DAU, elle est presque inévitable.  Par conséquent, l'interface et les règles du jeu ne devraient pas tomber à mort dans une telle situation. <br><br><h2>  Commandes à exécuter dont vous avez besoin de connaître la réponse du serveur </h2><br>  Une erreur typique est de penser qu'un nombre aléatoire ne peut être obtenu qu'à partir du serveur.  Rien ne vous empêche d'avoir le même générateur de nombres pseudo-aléatoires fonctionnant simultanément à partir du client et du serveur, à partir d'un sid commun.  De plus, la graine actuelle peut être stockée directement dans le gamestate.  Certains peuvent trouver difficile de synchroniser la réponse de ce générateur.  En fait, pour cela, il suffit d'avoir un numéro de plus dans le même article - exactement combien de numéros ont été reçus du générateur à ce moment.  Si votre générateur pour une raison quelconque ne converge pas, alors vous avez quelque part une erreur et le code ne fonctionne pas de manière déterministe.  Et ce fait ne doit pas être caché sous le tapis, mais trié et rechercher une erreur.  Pour la grande majorité des cas, y compris même les boîtes mystérieuses, cette approche est suffisante. <br><br>  Cependant, il y a des moments où cette option ne convient pas.  Par exemple, vous jouez un prix très cher et ne voulez pas que le camarade rusé décompile le jeu, et écrivez un bot qui vous indique à l'avance ce qui tombera de la boîte de diamants si vous l'ouvrez maintenant, et si vous faites tourner le tambour dans un autre endroit avant cela.  Vous pouvez stocker des graines pour chaque variable aléatoire séparément, cela protégera contre le piratage frontal, mais cela n'aidera en rien d'un bot qui vous indique combien de boîtes le produit dont vous avez besoin se trouve actuellement.  Eh bien, le cas le plus évident est que vous ne voudrez peut-être pas briller dans la configuration client avec des informations sur la probabilité d'un événement rare.  Bref, il est parfois nécessaire d'attendre une réponse du serveur. <br>  De telles situations ne devraient pas être résolues grâce aux capacités supplémentaires du moteur, mais en divisant l'équipe en deux - le premier prépare la situation et met l'interface en attente de notifications, le second en fait, avec la réponse dont vous avez besoin.  Même si vous bloquez étroitement l'interface entre eux sur le client, une autre commande peut passer à travers - par exemple, une unité d'énergie sera restaurée à temps. <br><br>  Il est important de comprendre que de telles situations ne sont pas la règle, mais l'exception.  En fait, la plupart des jeux n'ont besoin que d'une seule équipe en attente d'une réponse - GetInitialGameState.  Un autre pack de ces commandes est l'interaction entre les joueurs dans un méta-jeu, GetLeaderboard, par exemple.  Les deux cents autres pièces sont déterministes. <br><br><h2>  Stockage des données du serveur et sujet boueux de l'optimisation du serveur </h2><br>  J'avoue tout de suite que je suis un client, et parfois j'ai entendu de telles idées et algorithmes de la part de serveurs familiers qu'ils ne se seraient même pas glissés dans ma tête.  En communiquant avec mes collègues, j'ai en quelque sorte développé une image du fonctionnement de mon architecture côté serveur dans le cas idéal.  Cependant: il existe des contre-indications, il est nécessaire de consulter un serveur spécialisé. <br><br>  Tout d'abord sur le stockage des données.  C'est votre côté serveur qui peut avoir des restrictions supplémentaires.  Par exemple, vous pouvez être interdit d'utiliser des champs statiques.  De plus, le code des commandes et des modèles est autoportable, mais le code de propriété sur le client et sur le serveur n'a pas du tout à coïncider.  Tout peut y être caché, jusqu'à l'initialisation paresseuse des valeurs de champ du memcache, par exemple.  Les champs de propriété peuvent également recevoir des paramètres supplémentaires utilisés par le serveur, mais n'affectent pas le travail du client. <br><br>  La première différence cardinale du serveur: où les champs sont sérialisés et désérialisés.  Une solution raisonnable est que la plupart de l'arbre d'état est sérialisé en un immense champ binaire ou json.  Dans le même temps, certains champs sont extraits des tables.  Cela est nécessaire car les valeurs de certains champs seront constamment nécessaires au fonctionnement des services d'interaction entre les joueurs.  Par exemple, l'icône et le niveau sont constamment secoués par une variété de personnes.  Il vaut mieux les conserver dans une base de données régulière.  Et l'état complet ou partiel, mais détaillé d'une personne aura très rarement besoin de quelqu'un d'autre que lui, quand quelqu'un décide de se pencher sur son territoire. <br><br>  De plus, tirer des champs de la base un à la fois n'est pas pratique, et il peut s'avérer que tout traîne pendant longtemps.  Une solution très non standard, disponible uniquement pour notre architecture, peut consister dans le fait que le client, lors de l'exécution d'une commande, collecte des informations sur tous les champs stockés séparément dans des tables dont les getters ont réussi à toucher, et ajoute ces informations à la commande pour que le serveur puisse lever ce groupe de champs une demande à la base de données.  Bien sûr, avec des restrictions raisonnables, afin de ne pas mendier pour DDOS causé par des programmeurs aux mains courbées qui ont touché à tout de manière inattentive. <br><br>  Avec un tel stockage séparé, on devrait considérer les mécanismes de transactionnalité lorsqu'un joueur rampe dans les données d'un autre, par exemple, lui vole de l'argent.  Mais dans le cas général, nous le faisons par notification.  Autrement dit, le voleur reçoit son argent immédiatement, et la personne volée reçoit une notification avec des instructions pour radier de l'argent quand il s'agit de cela. <br><br><h2>  Comment les équipes sont réparties entre les serveurs </h2><br>  Maintenant, le deuxième moment important pour le serveur.  Il existe deux approches.  Au début, pour le traitement de toute demande (ou d'un paquet de demandes), l'état entier est élevé de la base de données ou du cache vers la mémoire, traité, puis renvoyé à la base de données.  Les opérations sont élaborées de manière atomique sur un tas de serveurs d'exécution différents, et ils n'ont qu'une base commune, et même pas toujours.  En tant que client, élever l'état entier à chaque équipe est choquant, mais j'ai vu comment cela fonctionne, et cela fonctionne de manière très fiable et évolutive.  La deuxième option est que l'état monte une fois en mémoire et y habite jusqu'à ce que le client ne tombe qu'occasionnellement en ajoutant son état actuel à la base de données.            .    -           .        ,       .     ,     ,   .          10 .       ,     ,       —          .         ,                .     —    . <br><br><h2>    </h2><br>   ,        :       ,      .      .              .   ,          .     ,          .            —          —            . <br><br>         ,   ,       -                     .     ,    .          ,     VR   CS,  -           . ,  ,         ,          30%. <br><br>   ,      —    ,     .          ,      .     ,  , ,     ,    ,       . <br><br> , , -      ,     :       .     ,       .      ,   35                 .     ,       ,    . ,   ,                 ,    —         . <br>     :       — 30 .          ?  №1:   .  №2:       ,        3000      . <br><br>  ,                   —  .  Quelque chose comme ça: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Command { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; }</code> </pre> <br>    , ,     Unity     — .    UnixTime   ,         ,         PTime,   PValue&lt;long&gt;  ,     JSON         :   - .    .   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quatrième situation: Dans l'état de jeu, il y a des situations où une équipe doit être initiée sans la participation d'un joueur, à temps, par exemple, la récupération d'énergie. Une situation très courante, en fait. Je veux avoir un champ, c'est un exercice pratique. Par exemple PTimeOut, dans lequel il sera possible d'enregistrer un point dans le temps après lequel une commande doit être créée et exécutée. Dans le code, cela peut ressembler à ceci:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PTimeOut RESTORE_ENERGY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PTimeOut() {command = (model, property) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestoreEnergyCommand() { model = model}} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> restoreEnergy { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RESTORE_ENERGY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { RESTORE_ENERGY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); }} }</code> </pre> <br>                ,      .     ,       ,       .            ,       ,      ,      ,      .          ,         ,              . <br><br>     -   ,        .   ,      ,       ,     ,      ,    .            ,               currentTime,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; } vs <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> event Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; setCurrentTime; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est bien, mais le problème est que les modèles qui sont supprimés de l'arborescence des modèles pour toujours et contiennent un tel champ resteront abonnés à cet événement et devront le résoudre correctement. </font><font style="vertical-align: inherit;">Avant d'envoyer une commande, vérifiez si elles sont toujours dans l'arborescence et ont un lien faible avec cet événement ou inversion de contrôle, de sorte qu'elles ne restent pas inaccessibles au GC.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Annexe 1, un cas typique tiré de la vie réelle </font></font></h3><br>      .             ,    - .       ,    ,           .        ,      ,   ,  ,      callback,       . , .      ,           ,               ,  ,    «  » , ,    .    ,   ,             . <br><br>  ,    .       ,        inventory,      .     ,   ,      -,  ,     .          ,       « »      ,      ,      ,    .     «    ».         ,        .        ,       ,                 .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenMisterBox</span></span></span><span class="hljs-class"> :</span></span> Command { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BoxItemModel item; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slot; <span class="hljs-comment"><span class="hljs-comment">//        ,  . public override void Apply(GameState state) { state.inventory[item.revardKey] += item.revardCount; } //       . public override void Apply(GameState state) { var cause = state.NewPersistent&lt;WaitForCommand&gt;(); cause.key = item.key; cause.value = item.value; state.ui.delayedInventoryVisualization.Add(cause); state.ui.mysteryBoxScreen.animations.Add(new Animation() {cause = item, slot = slot})); } } public class MysteryBoxView : View { /* ... */ public override void ConnectModel(MysteryBoxScreenModel model, List&lt;Control&gt; c) { model.Get(c, MysteryBoxScreenModel.ANIMATIONS) .Control(c, onAdd = item =&gt; animationFactory(item, OnComleteOrAbort =&gt; { AsincQueue(new RemoveAnimation() {cause = item.cause, animation = item}) }), onRemove = item =&gt; {} ) } } public class InventoryView : View&lt;InventoryItem&gt; { public Text text; public override void ConnectModel(InventoryItem model, List&lt;Control&gt; c) { model.GameState.ui.Get(c, UIModel.DELAYED_INVENTORY_VISUALIZATION). .Where(c, item =&gt; item.key == model.key) .Expression(c, onChange = (IList&lt;InventoryItem&gt; list) =&gt; { int sum = 0; for (int i = 0; i &lt; list.Count; i++) sum += list[i].value; return sum; }, onAdd = null, onRemove = null ) //      .Join (c, model.GameState.Get(GameState.INVENTORY).ItemByKey(model.key)) .Expression(c, (delay, count) =&gt; count - delay) .SetText(c, text); //     ,      ,   ,  ,   ,       ,     : model.inventory.CreateVisibleInventoryItemCount(c, model.key).SetText(c, text); } } public class RemoveDelayedInventoryVisualization : Command { public DelayCauseModel cause; public override void Apply(GameState state) { state.ui.delayedInventoryVisualization.Remove(cause); } } public class RemoveAnimation : RemoveDelayedInventoryVisualization { public Animation animation public override void Apply(GameState state) { base.Apply(state); state.ui.mysteryBoxScreen.animations.Remove(animation); } }</span></span></code> </pre> <br>  Qu'avons-nous finalement?   View,       ,         ,           .  .          GameState        ,    ,      .    ,       ,    ,    . <br><br><h2>  Total </h2><br>  -   ,      ,                  ,     , ,   ,      .              .    , ,                        .              ,         ,       . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant je vous demande de répondre à des questions très importantes pour moi. </font><font style="vertical-align: inherit;">Si vous avez des idées sur la façon de faire ce que j'ai mal fait, ou si vous voulez simplement commenter mes réponses, je vous attends dans les commentaires. </font><font style="vertical-align: inherit;">Une proposition de coopération et des instructions sur de nombreuses erreurs de syntaxe, veuillez en PM.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435704/">https://habr.com/ru/post/fr435704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435694/index.html">Comment et pourquoi nous avons optimisé l'algorithme de nettoyage des caches SLAB dans le noyau Linux</a></li>
<li><a href="../fr435696/index.html">Antiquités: publicité informatique 1997</a></li>
<li><a href="../fr435698/index.html">Écrire votre propre bon gestionnaire de mémoire</a></li>
<li><a href="../fr435700/index.html">Questions d'entretiens chez 8 Worst Vue.js</a></li>
<li><a href="../fr435702/index.html">Les trolls brevetés commencent et gagnent: comment je suis resté sans jeu</a></li>
<li><a href="../fr435706/index.html">Nous utilisons rcm pour déployer la configuration dans n'importe quel dossier</a></li>
<li><a href="../fr435708/index.html">Fayal: un lieu de rencontre dans l'Atlantique</a></li>
<li><a href="../fr435712/index.html">Procter & Gamble lance une imprimante pour la peau anti-âge</a></li>
<li><a href="../fr435714/index.html">Les développeurs ukrainiens ont eu accès aux fichiers de toutes les caméras Ring du monde</a></li>
<li><a href="../fr435718/index.html">Nous pompons Angular NGSW en utilisant une logique personnalisée dans Service Worker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>