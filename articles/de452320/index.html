<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ üñêüèª üçñ MVCC-6. Reinigung „Ä∞Ô∏è üöè üë©üèæ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs √ºber das Organisieren von Daten auf niedriger Ebene und sprachen d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Reinigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> , machten einen Exkurs √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene</a> und sprachen dann ausf√ºhrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Zeilenversionen</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir √ºber HOT-Updates und In-Page-Reinigung gesprochen. Heute werfen wir einen Blick auf die bekannte normale Reinigung, <em>Vakuum vulgaris</em> .  Ja, es wurde bereits so viel √ºber sie geschrieben, dass ich wahrscheinlich nichts Neues sagen werde, aber die Vollst√§ndigkeit des Bildes erfordert Opfer.  Sei geduldig. <br><br><h1>  Normale Reinigung (Vakuum) </h1><br><h2>  Was macht die Reinigung? </h2><br>  Die Intra-Page-Reinigung ist schnell, macht aber nur einen Bruchteil des Speicherplatzes frei.  Es funktioniert auf derselben Tabellenseite und wirkt sich nicht auf Indizes aus. <br><br>  Die "normale" Hauptreinigung wird vom Befehl VACUUM durchgef√ºhrt, und wir nennen sie einfach "Reinigung" (und wir werden separat √ºber die automatische Reinigung sprechen). <br><br>  Die Bereinigung verarbeitet die Tabelle also vollst√§ndig.  Es werden nicht nur unn√∂tige Versionen von Zeichenfolgen bereinigt, sondern auch Verweise auf sie aus allen Indizes. <br><br>  Die Verarbeitung erfolgt parallel zu anderen Aktivit√§ten im System.  In diesem Fall k√∂nnen die Tabelle und die Indizes auf die √ºbliche Weise sowohl zum Lesen als auch zum Bearbeiten verwendet werden (eine gleichzeitige Ausf√ºhrung von Befehlen wie CREATE INDEX, ALTER TABLE und einigen anderen ist jedoch nicht m√∂glich). <br><br>  In der Tabelle werden nur die Seiten angezeigt, auf denen eine Aktivit√§t aufgetreten ist.  Hierzu wird eine Sichtbarkeitskarte verwendet (ich erinnere Sie daran, dass Seiten, die nur ziemlich alte Versionen von Zeilen enthalten, die garantiert in allen Datenschnappsch√ºssen sichtbar sind, darin markiert sind).  Es werden nur Seiten verarbeitet, die nicht auf der Karte markiert sind, w√§hrend die Karte selbst aktualisiert wird. <br><br>  Dabei wird die Freiraumkarte aktualisiert, um den auf den Seiten angezeigten Freiraum widerzuspiegeln. <br><a name="habracut"></a><br>  Erstellen Sie wie gewohnt eine Tabelle: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Mit dem Parameter <em>autovacuum_enabled deaktivieren</em> wir die automatische Reinigung.  Wir werden das n√§chste Mal dar√ºber sprechen, aber f√ºr Experimente ist es vorerst wichtig, die Reinigung manuell durchzuf√ºhren. <br><br>  Die Tabelle enth√§lt jetzt drei Versionen der Zeile, von denen jede √ºber einen Index verkn√ºpft ist: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Nach der Reinigung verschwinden die "toten" Versionen und es gibt nur eine relevante.  Und der Index hat noch einen Link √ºbrig: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Bitte beachten Sie, dass die ersten beiden Zeiger den Status unbenutzt und nicht tot erhalten haben, wie dies bei der Bereinigung innerhalb einer Seite der Fall w√§re. <br><br><h2>  Und noch einmal zum Transaktionshorizont </h2><br>  Wie bestimmt PostgreSQL, welche Zeilenversionen als "tot" angesehen werden k√∂nnen?  Wir haben das Konzept eines Transaktionshorizonts bereits in Betracht gezogen, als wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Datenschnappsch√ºsse gesprochen haben</a> , aber dies ist ein so wichtiges Thema, dass es keine S√ºnde ist, es zu wiederholen. <br><br>  Beginnen wir noch einmal mit der vorherigen Erfahrung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Bevor Sie die Zeile erneut aktualisieren, lassen Sie eine weitere Transaktion beginnen (aber nicht enden).  In unserem Beispiel funktioniert es auf der Ebene "Commit lesen", sollte jedoch eine reale (nicht virtuelle) Transaktionsnummer erhalten.  Zum Beispiel kann es einige Zeilen in einer beliebigen Tabelle √§ndern oder sogar nur sperren, nicht unbedingt in vac: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Die Tabelle enth√§lt drei Zeilen und den Index drei Links.  Was passiert nach der Reinigung? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Die Tabelle enth√§lt noch zwei Versionen der Zeile: Bei der Bereinigung wurde entschieden, dass Version (0.2) noch nicht gel√∂scht werden konnte.  Der Grund liegt nat√ºrlich im Datenbanktransaktionshorizont, der in unserem Beispiel durch eine unvollst√§ndige Transaktion bestimmt wird: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Sie k√∂nnen um Reinigung bitten, um dar√ºber zu sprechen, was passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Beachten Sie: <br><br><ul><li>  2 nicht entfernbare Zeilenversionen - In der Tabelle wurden 2 Versionen gefunden, die nicht gel√∂scht werden k√∂nnen. </li><li>  1 Dead Row-Versionen k√∂nnen noch nicht entfernt werden - einschlie√ülich 1 "Dead", </li><li>  Das √§lteste xmin zeigt den aktuellen Horizont. </li></ul><br>  Wir wiederholen die Schlussfolgerung noch einmal: Das Vorhandensein langlebiger Transaktionen in der Datenbank (nicht abgeschlossen oder sehr lange) kann zur Erweiterung von (aufgebl√§hten) Tabellen f√ºhren, unabh√§ngig davon, wie oft die Bereinigung durchgef√ºhrt wird.  Daher werden in PostgreSQL OLTP- und OLAP-Workloads in einer Datenbank schlecht kombiniert: Berichte, die stundenlang ausgef√ºhrt werden, erm√∂glichen es nicht, h√§ufig aktualisierte Tabellen rechtzeitig zu l√∂schen.  Eine m√∂gliche L√∂sung w√§re die Erstellung eines separaten "Berichts" -Replikats. <br><br>  Nach Abschluss einer offenen Transaktion verschiebt sich der Horizont und die Situation wird korrigiert: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Jetzt hat die Seite nur die neueste aktuelle Version der Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Es gibt auch nur einen Eintrag im Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Was ist drinnen los? </h2><br>  Bei der Bereinigung sollten sowohl die Tabelle als auch die Indizes gleichzeitig verarbeitet werden, und zwar so, dass der Betrieb anderer Prozesse nicht blockiert wird.  Wie macht sie das? <br><br>  Alles beginnt mit <strong>einem Tabellenscan</strong> (unter Ber√ºcksichtigung der Sichtbarkeitskarte, wie bereits erw√§hnt).  Auf den gelesenen Seiten werden unn√∂tige Versionen von Zeichenfolgen ermittelt und ihre Bezeichner (tid) in ein spezielles Array geschrieben.  Das Array befindet sich im lokalen Speicher des Reinigungsprozesses.  Daf√ºr wird ein Fragment der Gr√∂√üe "tenance_work_mem "zugewiesen.  Der Standardwert f√ºr diesen Parameter ist 64 MB.  Beachten Sie, dass dieser Speicher sofort vollst√§ndig und nicht nach Bedarf zugewiesen wird.  Richtig, wenn die Tabelle klein ist, wird dem Fragment weniger zugewiesen. <br><br>  Als n√§chstes eines von zwei Dingen: Entweder erreichen wir das Ende der Tabelle oder der f√ºr das Array zugewiesene Speicher endet.  In beiden F√§llen beginnt <strong>die Indexbereinigungsphase</strong> .  Zu diesem Zweck wird <em>jeder</em> der in der Tabelle erstellten Indizes <em>vollst√§ndig</em> nach Datens√§tzen durchsucht, die auf gespeicherte Versionen von Zeilen verweisen.  Gefundene Datens√§tze werden von Indexseiten gel√∂scht. <br><br>  An dieser Stelle erhalten wir das folgende Bild: In den Indizes gibt es keine Links mehr zu unn√∂tigen Versionen von Zeilen, aber sie sind immer noch in der Tabelle vorhanden.  Dies widerspricht nichts: Bei der Ausf√ºhrung einer Abfrage gelangen wir entweder √ºberhaupt nicht zu toten Versionen von Zeilen (mit Indexzugriff) oder markieren sie bei der √úberpr√ºfung der Sichtbarkeit (beim Scannen einer Tabelle). <br><br>  Danach beginnt <strong>die Tischreinigungsphase</strong> .  Die Tabelle wird erneut gescannt, um die erforderlichen Seiten zu lesen, die gespeicherten Versionen der Zeilen daraus zu entfernen und die Zeiger freizugeben.  Wir k√∂nnen dies tun, weil es keine Links mehr aus Indizes gibt. <br><br>  Wenn die Tabelle im ersten Durchgang nicht vollst√§ndig gelesen wurde, wird das Array gel√∂scht und alles wird an der Stelle wiederholt, an der wir aufgeh√∂rt haben. <br><br>  Auf diese Weise: <br><br><ul><li>  Die Tabelle wird immer zweimal gescannt. </li><li>  Wenn w√§hrend der Bereinigung so viele Zeilenversionen gel√∂scht werden, dass nicht alle in den Speicher vontenance_work_mem passen, werden alle Indizes so oft wie n√∂tig vollst√§ndig gescannt. </li></ul><br>  Bei gro√üen Tischen kann dies viel Zeit in Anspruch nehmen und das System erheblich belasten.  Nat√ºrlich werden Anfragen nicht blockiert, aber die "zus√§tzliche" E / A ist auch unangenehm. <br><br>  Um den Prozess zu beschleunigen, ist es sinnvoll, entweder h√§ufiger zu bereinigen (damit nicht jedes Mal eine sehr gro√üe Anzahl von Zeilenversionen gel√∂scht wird) oder mehr Speicher zuzuweisen. <br><br>  Ich stelle in Klammern fest, dass PostgreSQL ab Version 11 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Index-Scans √ºberspringen kann,</a> wenn dies nicht unbedingt erforderlich ist.  Dies sollte den Besitzern gro√üer Tabellen, in denen Zeilen nur hinzugef√ºgt (aber nicht ge√§ndert) werden, das Leben erleichtern. <br><br><h2>  √úberwachung </h2><br>  Wie kann man verstehen, dass die Reinigung nicht mit der Arbeit in einem Durchgang fertig wird? <br><br>  Wir haben bereits die erste Methode gesehen: Sie k√∂nnen den Befehl VACUUM mit VERBOSE aufrufen.  Anschlie√üend werden Informationen zu den Arbeitsphasen auf der Konsole angezeigt. <br><br>  Zweitens gibt es ab Version 9.6 eine Ansicht pg_stat_progress_vacuum, die auch alle notwendigen Informationen enth√§lt. <br><br>  (Es gibt eine dritte M√∂glichkeit: Informationen im Nachrichtenprotokoll anzuzeigen. Dies funktioniert jedoch nur f√ºr die automatische Reinigung, die beim n√§chsten Mal erl√§utert wird.) <br><br>  Wir werden weitere Zeilen in die Tabelle einf√ºgen, damit die Reinigung sp√ºrbar lange dauert, und wir werden alle aktualisieren, damit etwas mit der Reinigung zu tun hat. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzieren Sie die Gr√∂√üe des f√ºr das Bezeichnerarray zugewiesenen Speichers: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Wir beginnen mit der Reinigung und wenden uns, w√§hrend dies funktioniert, mehrmals der Ansicht pg_stat_progress_vacuum zu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Hier sehen wir insbesondere: <br><br><ul><li>  Name der aktuellen Phase (Phase) - wir haben √ºber drei Hauptphasen gesprochen, aber im Allgemeinen gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> davon; </li><li>  Gesamtzahl der Tabellenseiten (heap_blks_total); </li><li>  die Anzahl der gecrawlten Seiten (heap_blks_scanned); </li><li>  die Anzahl der bereits gel√∂schten Seiten (heap_blks_vacuumed); </li><li>  Die Anzahl der Durchg√§nge pro Index (index_vacuum_count). </li></ul><br>  Der Gesamtfortschritt wird durch das Verh√§ltnis von heap_blks_vacuumed zu heap_blks_total bestimmt. Beachten Sie jedoch, dass sich dieser Wert nicht reibungslos √§ndert, sondern aufgrund von Index-Scans ‚Äûruckartig‚Äú.  Das Hauptaugenmerk sollte jedoch auf die Anzahl der Reinigungszyklen gelegt werden - ein Wert gr√∂√üer als 1 bedeutet, dass der zugewiesene Speicher nicht ausreicht, um die Reinigung in einem Durchgang abzuschlie√üen. <br><br>  Die Ausgabe des Befehls VACUUM VERBOSE, die zu diesem Zeitpunkt abgeschlossen ist, zeigt das Gesamtbild: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Hier k√∂nnen Sie sehen, dass es insgesamt drei Durchg√§nge durch die Indizes gab, von denen jeder 174.480 Zeiger auf tote Versionen von Zeichenfolgen l√∂schte.  Woher kommt diese Nummer?  Ein Link (tid) ben√∂tigt 6 Bytes und 1024 * 1024/6 = 174762 ist die Nummer, die wir in pg_stat_progress_vacuum.max_dead_tuples sehen.  Tats√§chlich kann es etwas weniger verwendet werden: Es ist garantiert, dass beim Lesen der n√§chsten Seite alle Zeiger auf die "toten" Versionen genau in den Speicher passen. <br><br><h2>  Analyse </h2><br>  Die Analyse oder mit anderen Worten die Erfassung statistischer Informationen f√ºr den Abfrageplaner ist formal nicht mit der Bereinigung verbunden.  Trotzdem k√∂nnen wir die Analyse nicht nur mit dem ANALYZE-Team durchf√ºhren, sondern auch die Reinigung mit der Analyse kombinieren: VACUUM ANALYZE.  In diesem Fall wird zuerst die Reinigung und dann die Analyse durchgef√ºhrt - es werden keine Einsparungen erzielt. <br><br>  Wie wir sp√§ter sehen werden, werden die automatische Reinigung und die automatische Analyse in einem Prozess durchgef√ºhrt und auf √§hnliche Weise verwaltet. <br><br><h1>  Vollreinigung (Vakuum voll) </h1><br>  Wie wir gesehen haben, gibt die herk√∂mmliche Reinigung mehr Platz frei als die Reinigung innerhalb einer Seite, aber selbst sie l√∂st das Problem nicht immer vollst√§ndig. <br><br>  Wenn eine Tabelle oder ein Index aus irgendeinem Grund erheblich gr√∂√üer geworden ist, wird durch regelm√§√üige Bereinigung Speicherplatz auf vorhandenen Seiten frei: Sie haben L√∂cher, die dann zum Einf√ºgen neuer Versionen von Zeilen verwendet werden.  Die Anzahl der Seiten √§ndert sich jedoch nicht. Aus Sicht des Betriebssystems belegen die Dateien daher genau so viel Speicherplatz wie vor dem Bereinigen.  Und das ist schlecht, weil: <br><br><ul><li>  Das vollst√§ndige Scannen einer Tabelle (oder eines Index) wird verlangsamt. </li><li>  M√∂glicherweise ist ein gr√∂√üerer Puffercache erforderlich (da Seiten gespeichert werden und die Dichte n√ºtzlicher Informationen abnimmt). </li><li>  Im Indexbaum wird m√∂glicherweise eine zus√§tzliche Ebene angezeigt, die den Indexzugriff verlangsamt. </li><li>  Dateien belegen zus√§tzlichen Speicherplatz und Backups. </li></ul><br>  (Die einzige Ausnahme sind die vollst√§ndig bereinigten Seiten am Ende der Datei. Diese Seiten ‚Äûbei√üen‚Äú die Datei ab und kehren zum Betriebssystem zur√ºck.) <br><br>  Wenn der Anteil n√ºtzlicher Informationen in den Dateien einen angemessenen Grenzwert unterschreitet, kann der Administrator eine vollst√§ndige Tabellenbereinigung durchf√ºhren.  Gleichzeitig werden die Tabelle und alle ihre Indizes vollst√§ndig von Grund auf neu erstellt, und die Daten werden so kompakt wie m√∂glich gepackt (nat√ºrlich unter Ber√ºcksichtigung des F√ºllfaktorparameters).  Bei der Neuerstellung erstellt PostgreSQL zuerst die Tabelle und dann jeden ihrer Indizes nacheinander neu.  F√ºr jedes Objekt werden neue Dateien erstellt, und am Ende der Neuerstellung werden alte Dateien gel√∂scht.  Bitte beachten Sie, dass w√§hrend der Arbeit an der Festplatte zus√§tzlicher Speicherplatz ben√∂tigt wird. <br><br>  F√ºgen Sie zur Veranschaulichung erneut eine Reihe von Zeilen in die Tabelle ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Wie bewertet man die Informationsdichte?  Verwenden Sie dazu bequem die spezielle Erweiterung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Die Funktion liest die gesamte Tabelle und zeigt Statistiken dar√ºber an, wie viel Speicherplatz welche Daten in den Dateien belegen.  Die Hauptinformation, die uns jetzt interessiert, ist das Feld tuple_percent: der Prozentsatz, der von n√ºtzlichen Daten belegt wird.  Es ist weniger als 100 aufgrund des unvermeidlichen Overheads an Serviceinformationen auf der Seite, aber dennoch ziemlich hoch. <br><br>  F√ºr den Index werden andere Informationen angezeigt, aber das Feld avg_leaf_density hat dieselbe Bedeutung: den Prozentsatz n√ºtzlicher Informationen (auf Blattseiten). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Und hier ist die Gr√∂√üe der Tabelle und des Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  L√∂schen Sie jetzt 90% aller Zeilen.  Wir w√§hlen die zu l√∂schenden Zeilen zuf√§llig aus, so dass auf jeder Seite mit hoher Wahrscheinlichkeit mindestens eine Zeile √ºbrig bleibt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Welche Gr√∂√üe haben Objekte nach der normalen Reinigung? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Wir sehen, dass sich die Gr√∂√üe nicht ge√§ndert hat: Durch regelm√§√üige Reinigung kann die Gr√∂√üe der Dateien in keiner Weise verringert werden.  Obwohl die Informationsdichte offensichtlich um das Zehnfache abgenommen hat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  √úberpr√ºfen Sie nun, was nach einer vollst√§ndigen Bereinigung passiert.  Hier sind die Dateien, die jetzt von der Tabelle und den Indizes verwendet werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Jetzt werden die Dateien durch neue ersetzt.  Die Gr√∂√üe der Tabelle und des Index hat erheblich abgenommen, und die Informationsdichte hat entsprechend zugenommen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Bitte beachten Sie, dass die Informationsdichte im Index im Vergleich zum Original sogar gestiegen ist.  Das erneute Erstellen eines Index (B-Baum) aus den verf√ºgbaren Daten ist rentabler als das zeilenweise Einf√ºgen von Daten in einen vorhandenen Index. <br><br>  Die von uns verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgstattuple-</a> Erweiterungsfunktionen lesen die gesamte Tabelle.  Wenn die Tabelle gro√ü ist, ist dies unpraktisch, und daher gibt es dort eine Funktion pgstattuple_approx, die die in der Sichtbarkeitskarte markierten Seiten √ºberspringt und ungef√§hre Zahlen anzeigt. <br><br>  Eine noch schnellere, aber noch weniger genaue Methode besteht darin, das Verh√§ltnis von Datenvolumen zu Dateigr√∂√üe im Systemverzeichnis zu sch√§tzen.  Optionen f√ºr solche Abfragen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Wiki</a> . <br><br>  Eine vollst√§ndige Bereinigung erfordert keine regelm√§√üige Verwendung, da alle Arbeiten mit der Tabelle (einschlie√ülich der Abfrage) f√ºr die gesamte Dauer ihrer Arbeit vollst√§ndig blockiert werden.  Es ist klar, dass dies auf einem aktiv genutzten System m√∂glicherweise nicht akzeptabel ist.  Sperren werden separat betrachtet, aber wir beschr√§nken uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorerst darauf</a> , die Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_repack</a> zu erw√§hnen, die die Tabelle am Ende der Arbeit nur f√ºr kurze Zeit sperrt. <br><br><h2>  √Ñhnliche Teams </h2><br>  Es gibt mehrere Befehle, mit denen Tabellen und Indizes ebenfalls vollst√§ndig neu erstellt werden. Dies √§hnelt einer vollst√§ndigen Bereinigung.  Alle blockieren die Arbeit mit der Tabelle vollst√§ndig, alle l√∂schen die alten Datendateien und erstellen neue. <br><br>  Der Befehl CLUSTER √§hnelt in allen Punkten VACUUM FULL, ordnet jedoch zus√§tzlich die Version der Zeichenfolgen physisch nach einem der verf√ºgbaren Indizes an.  Dies gibt dem Scheduler in einigen F√§llen die M√∂glichkeit, den Indexzugriff effektiver zu nutzen.  Es versteht sich jedoch, dass Clustering nicht unterst√ºtzt wird: Bei nachfolgenden √Ñnderungen an der Tabelle wird die physische Reihenfolge der Zeilenversionen verletzt. <br><br>  Der Befehl REINDEX erstellt einen einzelnen Index f√ºr eine Tabelle neu.  Tats√§chlich verwenden VACUUM FULL und CLUSTER diesen Befehl, um Indizes neu zu erstellen. <br><br>  Der Befehl TRUNCATE funktioniert logischerweise genauso wie DELETE - er l√∂scht alle Tabellenzeilen.  Wie bereits erw√§hnt, markiert DELETE jedoch nur die Version der Zeilen als gel√∂scht, was eine weitere Reinigung erfordert.  TRUNCATE erstellt nur eine neue, saubere Datei.  Dies funktioniert in der Regel schneller. Beachten Sie jedoch, dass TRUNCATE die Arbeit mit der Tabelle f√ºr die gesamte Zeit bis zum Ende der Transaktion vollst√§ndig blockiert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452320/">https://habr.com/ru/post/de452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452310/index.html">Einrichten von Netzwerkvertriebskan√§len f√ºr DO-RA-Ger√§te</a></li>
<li><a href="../de452312/index.html">Die britische Telekommunikation zahlt den Abonnenten eine Entsch√§digung f√ºr Verbindungsabbr√ºche</a></li>
<li><a href="../de452314/index.html">Das Design von Levels und Gameplay ist am Beispiel von Cogmind roguelartig</a></li>
<li><a href="../de452316/index.html">Die Chang'e-4-Mission - die Ergebnisse des f√ºnften Mondtages: Probleme mit dem Yutu-2-Rover und eine neue wissenschaftliche Entdeckung</a></li>
<li><a href="../de452318/index.html">Verwenden von Firebase als Bildspeicher f√ºr eine Android-Anwendung</a></li>
<li><a href="../de452322/index.html">Aus dem Epizentrum von Google Cloud Next '19: Feldnotizen des CEO</a></li>
<li><a href="../de452328/index.html">Matroschka C. Schichtprogramm-Sprachsystem</a></li>
<li><a href="../de452330/index.html">Wie kann man eine verteilte papierlose viertelj√§hrliche Planung durchf√ºhren und nicht vermasseln?</a></li>
<li><a href="../de452332/index.html">Es ist schwer, ein Open Source-Projektbetreuer zu sein</a></li>
<li><a href="../de452334/index.html">So verkleiden Sie sich im Internet: Vergleichen Sie Server- und residente Proxys</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>