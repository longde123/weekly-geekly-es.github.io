<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💲 🖐🏻 🍖 MVCC-6. Reinigung 〰️ 🚏 👩🏾‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs über das Organisieren von Daten auf niedriger Ebene und sprachen d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Reinigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> , machten einen Exkurs über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene</a> und sprachen dann ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Zeilenversionen</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir über HOT-Updates und In-Page-Reinigung gesprochen. Heute werfen wir einen Blick auf die bekannte normale Reinigung, <em>Vakuum vulgaris</em> .  Ja, es wurde bereits so viel über sie geschrieben, dass ich wahrscheinlich nichts Neues sagen werde, aber die Vollständigkeit des Bildes erfordert Opfer.  Sei geduldig. <br><br><h1>  Normale Reinigung (Vakuum) </h1><br><h2>  Was macht die Reinigung? </h2><br>  Die Intra-Page-Reinigung ist schnell, macht aber nur einen Bruchteil des Speicherplatzes frei.  Es funktioniert auf derselben Tabellenseite und wirkt sich nicht auf Indizes aus. <br><br>  Die "normale" Hauptreinigung wird vom Befehl VACUUM durchgeführt, und wir nennen sie einfach "Reinigung" (und wir werden separat über die automatische Reinigung sprechen). <br><br>  Die Bereinigung verarbeitet die Tabelle also vollständig.  Es werden nicht nur unnötige Versionen von Zeichenfolgen bereinigt, sondern auch Verweise auf sie aus allen Indizes. <br><br>  Die Verarbeitung erfolgt parallel zu anderen Aktivitäten im System.  In diesem Fall können die Tabelle und die Indizes auf die übliche Weise sowohl zum Lesen als auch zum Bearbeiten verwendet werden (eine gleichzeitige Ausführung von Befehlen wie CREATE INDEX, ALTER TABLE und einigen anderen ist jedoch nicht möglich). <br><br>  In der Tabelle werden nur die Seiten angezeigt, auf denen eine Aktivität aufgetreten ist.  Hierzu wird eine Sichtbarkeitskarte verwendet (ich erinnere Sie daran, dass Seiten, die nur ziemlich alte Versionen von Zeilen enthalten, die garantiert in allen Datenschnappschüssen sichtbar sind, darin markiert sind).  Es werden nur Seiten verarbeitet, die nicht auf der Karte markiert sind, während die Karte selbst aktualisiert wird. <br><br>  Dabei wird die Freiraumkarte aktualisiert, um den auf den Seiten angezeigten Freiraum widerzuspiegeln. <br><a name="habracut"></a><br>  Erstellen Sie wie gewohnt eine Tabelle: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Mit dem Parameter <em>autovacuum_enabled deaktivieren</em> wir die automatische Reinigung.  Wir werden das nächste Mal darüber sprechen, aber für Experimente ist es vorerst wichtig, die Reinigung manuell durchzuführen. <br><br>  Die Tabelle enthält jetzt drei Versionen der Zeile, von denen jede über einen Index verknüpft ist: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Nach der Reinigung verschwinden die "toten" Versionen und es gibt nur eine relevante.  Und der Index hat noch einen Link übrig: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Bitte beachten Sie, dass die ersten beiden Zeiger den Status unbenutzt und nicht tot erhalten haben, wie dies bei der Bereinigung innerhalb einer Seite der Fall wäre. <br><br><h2>  Und noch einmal zum Transaktionshorizont </h2><br>  Wie bestimmt PostgreSQL, welche Zeilenversionen als "tot" angesehen werden können?  Wir haben das Konzept eines Transaktionshorizonts bereits in Betracht gezogen, als wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Datenschnappschüsse gesprochen haben</a> , aber dies ist ein so wichtiges Thema, dass es keine Sünde ist, es zu wiederholen. <br><br>  Beginnen wir noch einmal mit der vorherigen Erfahrung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Bevor Sie die Zeile erneut aktualisieren, lassen Sie eine weitere Transaktion beginnen (aber nicht enden).  In unserem Beispiel funktioniert es auf der Ebene "Commit lesen", sollte jedoch eine reale (nicht virtuelle) Transaktionsnummer erhalten.  Zum Beispiel kann es einige Zeilen in einer beliebigen Tabelle ändern oder sogar nur sperren, nicht unbedingt in vac: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Die Tabelle enthält drei Zeilen und den Index drei Links.  Was passiert nach der Reinigung? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Die Tabelle enthält noch zwei Versionen der Zeile: Bei der Bereinigung wurde entschieden, dass Version (0.2) noch nicht gelöscht werden konnte.  Der Grund liegt natürlich im Datenbanktransaktionshorizont, der in unserem Beispiel durch eine unvollständige Transaktion bestimmt wird: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Sie können um Reinigung bitten, um darüber zu sprechen, was passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Beachten Sie: <br><br><ul><li>  2 nicht entfernbare Zeilenversionen - In der Tabelle wurden 2 Versionen gefunden, die nicht gelöscht werden können. </li><li>  1 Dead Row-Versionen können noch nicht entfernt werden - einschließlich 1 "Dead", </li><li>  Das älteste xmin zeigt den aktuellen Horizont. </li></ul><br>  Wir wiederholen die Schlussfolgerung noch einmal: Das Vorhandensein langlebiger Transaktionen in der Datenbank (nicht abgeschlossen oder sehr lange) kann zur Erweiterung von (aufgeblähten) Tabellen führen, unabhängig davon, wie oft die Bereinigung durchgeführt wird.  Daher werden in PostgreSQL OLTP- und OLAP-Workloads in einer Datenbank schlecht kombiniert: Berichte, die stundenlang ausgeführt werden, ermöglichen es nicht, häufig aktualisierte Tabellen rechtzeitig zu löschen.  Eine mögliche Lösung wäre die Erstellung eines separaten "Berichts" -Replikats. <br><br>  Nach Abschluss einer offenen Transaktion verschiebt sich der Horizont und die Situation wird korrigiert: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Jetzt hat die Seite nur die neueste aktuelle Version der Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Es gibt auch nur einen Eintrag im Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Was ist drinnen los? </h2><br>  Bei der Bereinigung sollten sowohl die Tabelle als auch die Indizes gleichzeitig verarbeitet werden, und zwar so, dass der Betrieb anderer Prozesse nicht blockiert wird.  Wie macht sie das? <br><br>  Alles beginnt mit <strong>einem Tabellenscan</strong> (unter Berücksichtigung der Sichtbarkeitskarte, wie bereits erwähnt).  Auf den gelesenen Seiten werden unnötige Versionen von Zeichenfolgen ermittelt und ihre Bezeichner (tid) in ein spezielles Array geschrieben.  Das Array befindet sich im lokalen Speicher des Reinigungsprozesses.  Dafür wird ein Fragment der Größe "tenance_work_mem "zugewiesen.  Der Standardwert für diesen Parameter ist 64 MB.  Beachten Sie, dass dieser Speicher sofort vollständig und nicht nach Bedarf zugewiesen wird.  Richtig, wenn die Tabelle klein ist, wird dem Fragment weniger zugewiesen. <br><br>  Als nächstes eines von zwei Dingen: Entweder erreichen wir das Ende der Tabelle oder der für das Array zugewiesene Speicher endet.  In beiden Fällen beginnt <strong>die Indexbereinigungsphase</strong> .  Zu diesem Zweck wird <em>jeder</em> der in der Tabelle erstellten Indizes <em>vollständig</em> nach Datensätzen durchsucht, die auf gespeicherte Versionen von Zeilen verweisen.  Gefundene Datensätze werden von Indexseiten gelöscht. <br><br>  An dieser Stelle erhalten wir das folgende Bild: In den Indizes gibt es keine Links mehr zu unnötigen Versionen von Zeilen, aber sie sind immer noch in der Tabelle vorhanden.  Dies widerspricht nichts: Bei der Ausführung einer Abfrage gelangen wir entweder überhaupt nicht zu toten Versionen von Zeilen (mit Indexzugriff) oder markieren sie bei der Überprüfung der Sichtbarkeit (beim Scannen einer Tabelle). <br><br>  Danach beginnt <strong>die Tischreinigungsphase</strong> .  Die Tabelle wird erneut gescannt, um die erforderlichen Seiten zu lesen, die gespeicherten Versionen der Zeilen daraus zu entfernen und die Zeiger freizugeben.  Wir können dies tun, weil es keine Links mehr aus Indizes gibt. <br><br>  Wenn die Tabelle im ersten Durchgang nicht vollständig gelesen wurde, wird das Array gelöscht und alles wird an der Stelle wiederholt, an der wir aufgehört haben. <br><br>  Auf diese Weise: <br><br><ul><li>  Die Tabelle wird immer zweimal gescannt. </li><li>  Wenn während der Bereinigung so viele Zeilenversionen gelöscht werden, dass nicht alle in den Speicher vontenance_work_mem passen, werden alle Indizes so oft wie nötig vollständig gescannt. </li></ul><br>  Bei großen Tischen kann dies viel Zeit in Anspruch nehmen und das System erheblich belasten.  Natürlich werden Anfragen nicht blockiert, aber die "zusätzliche" E / A ist auch unangenehm. <br><br>  Um den Prozess zu beschleunigen, ist es sinnvoll, entweder häufiger zu bereinigen (damit nicht jedes Mal eine sehr große Anzahl von Zeilenversionen gelöscht wird) oder mehr Speicher zuzuweisen. <br><br>  Ich stelle in Klammern fest, dass PostgreSQL ab Version 11 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Index-Scans überspringen kann,</a> wenn dies nicht unbedingt erforderlich ist.  Dies sollte den Besitzern großer Tabellen, in denen Zeilen nur hinzugefügt (aber nicht geändert) werden, das Leben erleichtern. <br><br><h2>  Überwachung </h2><br>  Wie kann man verstehen, dass die Reinigung nicht mit der Arbeit in einem Durchgang fertig wird? <br><br>  Wir haben bereits die erste Methode gesehen: Sie können den Befehl VACUUM mit VERBOSE aufrufen.  Anschließend werden Informationen zu den Arbeitsphasen auf der Konsole angezeigt. <br><br>  Zweitens gibt es ab Version 9.6 eine Ansicht pg_stat_progress_vacuum, die auch alle notwendigen Informationen enthält. <br><br>  (Es gibt eine dritte Möglichkeit: Informationen im Nachrichtenprotokoll anzuzeigen. Dies funktioniert jedoch nur für die automatische Reinigung, die beim nächsten Mal erläutert wird.) <br><br>  Wir werden weitere Zeilen in die Tabelle einfügen, damit die Reinigung spürbar lange dauert, und wir werden alle aktualisieren, damit etwas mit der Reinigung zu tun hat. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzieren Sie die Größe des für das Bezeichnerarray zugewiesenen Speichers: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Wir beginnen mit der Reinigung und wenden uns, während dies funktioniert, mehrmals der Ansicht pg_stat_progress_vacuum zu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Hier sehen wir insbesondere: <br><br><ul><li>  Name der aktuellen Phase (Phase) - wir haben über drei Hauptphasen gesprochen, aber im Allgemeinen gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> davon; </li><li>  Gesamtzahl der Tabellenseiten (heap_blks_total); </li><li>  die Anzahl der gecrawlten Seiten (heap_blks_scanned); </li><li>  die Anzahl der bereits gelöschten Seiten (heap_blks_vacuumed); </li><li>  Die Anzahl der Durchgänge pro Index (index_vacuum_count). </li></ul><br>  Der Gesamtfortschritt wird durch das Verhältnis von heap_blks_vacuumed zu heap_blks_total bestimmt. Beachten Sie jedoch, dass sich dieser Wert nicht reibungslos ändert, sondern aufgrund von Index-Scans „ruckartig“.  Das Hauptaugenmerk sollte jedoch auf die Anzahl der Reinigungszyklen gelegt werden - ein Wert größer als 1 bedeutet, dass der zugewiesene Speicher nicht ausreicht, um die Reinigung in einem Durchgang abzuschließen. <br><br>  Die Ausgabe des Befehls VACUUM VERBOSE, die zu diesem Zeitpunkt abgeschlossen ist, zeigt das Gesamtbild: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Hier können Sie sehen, dass es insgesamt drei Durchgänge durch die Indizes gab, von denen jeder 174.480 Zeiger auf tote Versionen von Zeichenfolgen löschte.  Woher kommt diese Nummer?  Ein Link (tid) benötigt 6 Bytes und 1024 * 1024/6 = 174762 ist die Nummer, die wir in pg_stat_progress_vacuum.max_dead_tuples sehen.  Tatsächlich kann es etwas weniger verwendet werden: Es ist garantiert, dass beim Lesen der nächsten Seite alle Zeiger auf die "toten" Versionen genau in den Speicher passen. <br><br><h2>  Analyse </h2><br>  Die Analyse oder mit anderen Worten die Erfassung statistischer Informationen für den Abfrageplaner ist formal nicht mit der Bereinigung verbunden.  Trotzdem können wir die Analyse nicht nur mit dem ANALYZE-Team durchführen, sondern auch die Reinigung mit der Analyse kombinieren: VACUUM ANALYZE.  In diesem Fall wird zuerst die Reinigung und dann die Analyse durchgeführt - es werden keine Einsparungen erzielt. <br><br>  Wie wir später sehen werden, werden die automatische Reinigung und die automatische Analyse in einem Prozess durchgeführt und auf ähnliche Weise verwaltet. <br><br><h1>  Vollreinigung (Vakuum voll) </h1><br>  Wie wir gesehen haben, gibt die herkömmliche Reinigung mehr Platz frei als die Reinigung innerhalb einer Seite, aber selbst sie löst das Problem nicht immer vollständig. <br><br>  Wenn eine Tabelle oder ein Index aus irgendeinem Grund erheblich größer geworden ist, wird durch regelmäßige Bereinigung Speicherplatz auf vorhandenen Seiten frei: Sie haben Löcher, die dann zum Einfügen neuer Versionen von Zeilen verwendet werden.  Die Anzahl der Seiten ändert sich jedoch nicht. Aus Sicht des Betriebssystems belegen die Dateien daher genau so viel Speicherplatz wie vor dem Bereinigen.  Und das ist schlecht, weil: <br><br><ul><li>  Das vollständige Scannen einer Tabelle (oder eines Index) wird verlangsamt. </li><li>  Möglicherweise ist ein größerer Puffercache erforderlich (da Seiten gespeichert werden und die Dichte nützlicher Informationen abnimmt). </li><li>  Im Indexbaum wird möglicherweise eine zusätzliche Ebene angezeigt, die den Indexzugriff verlangsamt. </li><li>  Dateien belegen zusätzlichen Speicherplatz und Backups. </li></ul><br>  (Die einzige Ausnahme sind die vollständig bereinigten Seiten am Ende der Datei. Diese Seiten „beißen“ die Datei ab und kehren zum Betriebssystem zurück.) <br><br>  Wenn der Anteil nützlicher Informationen in den Dateien einen angemessenen Grenzwert unterschreitet, kann der Administrator eine vollständige Tabellenbereinigung durchführen.  Gleichzeitig werden die Tabelle und alle ihre Indizes vollständig von Grund auf neu erstellt, und die Daten werden so kompakt wie möglich gepackt (natürlich unter Berücksichtigung des Füllfaktorparameters).  Bei der Neuerstellung erstellt PostgreSQL zuerst die Tabelle und dann jeden ihrer Indizes nacheinander neu.  Für jedes Objekt werden neue Dateien erstellt, und am Ende der Neuerstellung werden alte Dateien gelöscht.  Bitte beachten Sie, dass während der Arbeit an der Festplatte zusätzlicher Speicherplatz benötigt wird. <br><br>  Fügen Sie zur Veranschaulichung erneut eine Reihe von Zeilen in die Tabelle ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Wie bewertet man die Informationsdichte?  Verwenden Sie dazu bequem die spezielle Erweiterung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Die Funktion liest die gesamte Tabelle und zeigt Statistiken darüber an, wie viel Speicherplatz welche Daten in den Dateien belegen.  Die Hauptinformation, die uns jetzt interessiert, ist das Feld tuple_percent: der Prozentsatz, der von nützlichen Daten belegt wird.  Es ist weniger als 100 aufgrund des unvermeidlichen Overheads an Serviceinformationen auf der Seite, aber dennoch ziemlich hoch. <br><br>  Für den Index werden andere Informationen angezeigt, aber das Feld avg_leaf_density hat dieselbe Bedeutung: den Prozentsatz nützlicher Informationen (auf Blattseiten). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Und hier ist die Größe der Tabelle und des Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Löschen Sie jetzt 90% aller Zeilen.  Wir wählen die zu löschenden Zeilen zufällig aus, so dass auf jeder Seite mit hoher Wahrscheinlichkeit mindestens eine Zeile übrig bleibt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Welche Größe haben Objekte nach der normalen Reinigung? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Wir sehen, dass sich die Größe nicht geändert hat: Durch regelmäßige Reinigung kann die Größe der Dateien in keiner Weise verringert werden.  Obwohl die Informationsdichte offensichtlich um das Zehnfache abgenommen hat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Überprüfen Sie nun, was nach einer vollständigen Bereinigung passiert.  Hier sind die Dateien, die jetzt von der Tabelle und den Indizes verwendet werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Jetzt werden die Dateien durch neue ersetzt.  Die Größe der Tabelle und des Index hat erheblich abgenommen, und die Informationsdichte hat entsprechend zugenommen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Bitte beachten Sie, dass die Informationsdichte im Index im Vergleich zum Original sogar gestiegen ist.  Das erneute Erstellen eines Index (B-Baum) aus den verfügbaren Daten ist rentabler als das zeilenweise Einfügen von Daten in einen vorhandenen Index. <br><br>  Die von uns verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgstattuple-</a> Erweiterungsfunktionen lesen die gesamte Tabelle.  Wenn die Tabelle groß ist, ist dies unpraktisch, und daher gibt es dort eine Funktion pgstattuple_approx, die die in der Sichtbarkeitskarte markierten Seiten überspringt und ungefähre Zahlen anzeigt. <br><br>  Eine noch schnellere, aber noch weniger genaue Methode besteht darin, das Verhältnis von Datenvolumen zu Dateigröße im Systemverzeichnis zu schätzen.  Optionen für solche Abfragen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Wiki</a> . <br><br>  Eine vollständige Bereinigung erfordert keine regelmäßige Verwendung, da alle Arbeiten mit der Tabelle (einschließlich der Abfrage) für die gesamte Dauer ihrer Arbeit vollständig blockiert werden.  Es ist klar, dass dies auf einem aktiv genutzten System möglicherweise nicht akzeptabel ist.  Sperren werden separat betrachtet, aber wir beschränken uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorerst darauf</a> , die Erweiterung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_repack</a> zu erwähnen, die die Tabelle am Ende der Arbeit nur für kurze Zeit sperrt. <br><br><h2>  Ähnliche Teams </h2><br>  Es gibt mehrere Befehle, mit denen Tabellen und Indizes ebenfalls vollständig neu erstellt werden. Dies ähnelt einer vollständigen Bereinigung.  Alle blockieren die Arbeit mit der Tabelle vollständig, alle löschen die alten Datendateien und erstellen neue. <br><br>  Der Befehl CLUSTER ähnelt in allen Punkten VACUUM FULL, ordnet jedoch zusätzlich die Version der Zeichenfolgen physisch nach einem der verfügbaren Indizes an.  Dies gibt dem Scheduler in einigen Fällen die Möglichkeit, den Indexzugriff effektiver zu nutzen.  Es versteht sich jedoch, dass Clustering nicht unterstützt wird: Bei nachfolgenden Änderungen an der Tabelle wird die physische Reihenfolge der Zeilenversionen verletzt. <br><br>  Der Befehl REINDEX erstellt einen einzelnen Index für eine Tabelle neu.  Tatsächlich verwenden VACUUM FULL und CLUSTER diesen Befehl, um Indizes neu zu erstellen. <br><br>  Der Befehl TRUNCATE funktioniert logischerweise genauso wie DELETE - er löscht alle Tabellenzeilen.  Wie bereits erwähnt, markiert DELETE jedoch nur die Version der Zeilen als gelöscht, was eine weitere Reinigung erfordert.  TRUNCATE erstellt nur eine neue, saubere Datei.  Dies funktioniert in der Regel schneller. Beachten Sie jedoch, dass TRUNCATE die Arbeit mit der Tabelle für die gesamte Zeit bis zum Ende der Transaktion vollständig blockiert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452320/">https://habr.com/ru/post/de452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452310/index.html">Einrichten von Netzwerkvertriebskanälen für DO-RA-Geräte</a></li>
<li><a href="../de452312/index.html">Die britische Telekommunikation zahlt den Abonnenten eine Entschädigung für Verbindungsabbrüche</a></li>
<li><a href="../de452314/index.html">Das Design von Levels und Gameplay ist am Beispiel von Cogmind roguelartig</a></li>
<li><a href="../de452316/index.html">Die Chang'e-4-Mission - die Ergebnisse des fünften Mondtages: Probleme mit dem Yutu-2-Rover und eine neue wissenschaftliche Entdeckung</a></li>
<li><a href="../de452318/index.html">Verwenden von Firebase als Bildspeicher für eine Android-Anwendung</a></li>
<li><a href="../de452322/index.html">Aus dem Epizentrum von Google Cloud Next '19: Feldnotizen des CEO</a></li>
<li><a href="../de452328/index.html">Matroschka C. Schichtprogramm-Sprachsystem</a></li>
<li><a href="../de452330/index.html">Wie kann man eine verteilte papierlose vierteljährliche Planung durchführen und nicht vermasseln?</a></li>
<li><a href="../de452332/index.html">Es ist schwer, ein Open Source-Projektbetreuer zu sein</a></li>
<li><a href="../de452334/index.html">So verkleiden Sie sich im Internet: Vergleichen Sie Server- und residente Proxys</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>