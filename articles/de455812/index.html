<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèª üöµüèª üå°Ô∏è Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 2 (Docker) üôáüèø üîö üò©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist Zeit, die Container in Angriff zu nehmen 
 Zun√§chst verwenden wir das neueste Linux Alpine-Image. Linux Alpine ist eine leichtgewichtige Linux-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 2 (Docker)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  Es ist Zeit, die Container in Angriff zu nehmen </h3><br>  Zun√§chst verwenden wir das neueste Linux Alpine-Image.  Linux Alpine ist eine leichtgewichtige Linux-Distribution, die f√ºr die Ausf√ºhrung von Webanwendungen in Docker entwickelt und optimiert wurde.  Mit anderen Worten, Linux Alpine verf√ºgt √ºber gen√ºgend Abh√§ngigkeiten und Funktionen, um die meisten Anwendungen auszuf√ºhren.  Dies bedeutet, dass die Bildgr√∂√üe ca. 8 MB betr√§gt! <br><br>  Im Vergleich zu beispielsweise einer virtuellen Ubuntu-Maschine mit einer Kapazit√§t von etwa 1 GB sind Docker-Images f√ºr Microservices und Cloud Computing nat√ºrlicher geworden. <br><br>  Nun hoffe ich, dass Sie Wert in der Containerisierung sehen und wir mit dem ‚ÄûDockerisieren‚Äú unseres ersten Dienstes beginnen k√∂nnen.  Erstellen wir einen Dockerfile <b>$ touch-Sendungsdienst / Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originales EwanValentine-Repository</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> <br><br>  F√ºgen Sie in der Docker-Datei Folgendes hinzu: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Dann erstellen wir ein neues Verzeichnis, um unsere Anwendung zu hosten.  Dann f√ºgen wir unsere kompilierte Bin√§rdatei zu unserem Docker-Container hinzu und f√ºhren sie aus. <br><br>  Aktualisieren wir nun den Build-Datensatz unseres Makefiles, um ein Docker-Image zu erstellen. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Wir haben zwei weitere Schritte hinzugef√ºgt, und ich m√∂chte sie n√§her erl√§utern.  Zun√§chst erstellen wir unsere Go-Bin√§rdatei.  Sie werden jedoch zwei Umgebungsvariablen bemerken, bevor wir $ go build ausf√ºhren.  Mit GOOS und GOARCH k√∂nnen Sie Ihre Bin√§rdatei f√ºr ein anderes Betriebssystem √ºberkompilieren.  Da ich f√ºr ein Macbook entwickle, kann ich die ausf√ºhrbare Datei go nicht kompilieren und dann in einem Docker-Container ausf√ºhren, der Linux verwendet.  Die Bin√§rdatei ist in Ihrem Docker-Container v√∂llig bedeutungslos und es wird ein Fehler ausgegeben. <br><br>  Der zweite Schritt, den ich hinzugef√ºgt habe, ist der Docker-Erstellungsprozess.  Docker liest Ihre Docker-Datei und erstellt ein Bild mit dem Namen "Konsignationsdienst". Der Punkt gibt den Verzeichnispfad an. Hier soll der Erstellungsprozess nur das aktuelle Verzeichnis anzeigen. <br><br>  Ich werde unserem Makefile einen neuen Eintrag hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Hier starten wir unser Docker-Image durch √ñffnen von Port 50051. Da Docker auf einer separaten Netzwerkebene ausgef√ºhrt wird, m√ºssen Sie den Port umleiten.  Wenn Sie diesen Dienst beispielsweise an Port 8080 starten m√∂chten, m√ºssen Sie das Argument -p in 8080: 50051 √§ndern.  Sie k√∂nnen den Container auch im Hintergrund ausf√ºhren, indem Sie das Flag -d einf√ºgen.  Zum Beispiel f√ºhrt <b>Docker -d -p 50051: 50051 aus</b> . <br><br>  F√ºhren Sie <b>$ make run aus</b> , und f√ºhren Sie dann in einem separaten Terminalfenster erneut <b>go go main.go aus</b> und √ºberpr√ºfen Sie, ob es noch funktioniert. <br><br>  Wenn Sie $ docker build ausf√ºhren, binden Sie Ihren Code und Ihre Laufzeit in das Image ein.  Docker-Images sind portable Images Ihrer Umgebung und ihrer Abh√§ngigkeiten.  Sie k√∂nnen Docker-Bilder freigeben, indem Sie sie im Docker Hub ver√∂ffentlichen.  Dies √§hnelt npm oder dem yum-Repository f√ºr Docker-Images.  Wenn Sie FROM in Ihrer Docker-Datei definieren, weisen Sie Docker an, dieses Image aus dem Docker-Repository zur Verwendung als Basis abzurufen.  Sie k√∂nnen dann Teile dieser Basisdatei erweitern und neu definieren und sie nach Ihren W√ºnschen neu definieren.  Wir werden unsere Docker-Images nicht ver√∂ffentlichen, k√∂nnen jedoch das Docker-Repository durchsuchen und feststellen, dass fast jede Software bereits in Containern verpackt wurde.  Einige wirklich wundervolle Dinge wurden angedockt. <br><br>  Jede Anzeige in Dockerfile wird beim ersten Erstellen zwischengespeichert.  Dadurch entf√§llt die Notwendigkeit, die gesamte Laufzeit bei jeder √Ñnderung neu zu erstellen.  Der Docker ist intelligent genug, um herauszufinden, welche Details sich ge√§ndert haben und welche neu erstellt werden m√ºssen.  Dies macht den Erstellungsprozess unglaublich schnell. <br><br>  Genug von den Containern!  Kehren wir zu unserem Code zur√ºck. <br><br>  Beim Erstellen des gRPC-Dienstes gibt es viele Standardcodes zum Erstellen von Verbindungen, und Sie m√ºssen den Speicherort der Dienstadresse im Client oder einem anderen Dienst fest codieren, damit er eine Verbindung zu ihm herstellen kann.  Dies ist schwierig, da beim Starten von Diensten in der Cloud m√∂glicherweise nicht derselbe Host verwendet wird oder sich die Adresse oder IP-Adresse nach der erneuten Bereitstellung des Dienstes √§ndert. <br><br>  Hier kommt der Discovery-Service ins Spiel.  Der Erkennungsdienst aktualisiert das Verzeichnis aller Ihrer Dienste und deren Speicherorte.  Jeder Dienst wird zur Laufzeit registriert und beim Schlie√üen abgemeldet.  Jedem Dienst wird dann ein Name oder eine Kennung zugewiesen.  Selbst wenn es eine neue IP-Adresse oder eine neue Hostadresse hat, m√ºssen Sie daher keine Anrufe von anderen Diensten auf diesen Dienst aktualisieren, sofern der Dienstname gleich bleibt. <br><br>  In der Regel gibt es viele Ans√§tze f√ºr dieses Problem, aber wie die meisten Dinge in der Programmierung macht es keinen Sinn, das Rad neu zu erfinden, wenn sich jemand bereits mit diesem Problem befasst hat.  @Chuhnk (Asim Aslam), der Erfinder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-micro</a> , l√∂st diese Probleme mit fantastischer Klarheit und Benutzerfreundlichkeit.  Er produziert im Alleingang fantastische Software.  Bitte helfen Sie ihm, wenn Ihnen das gef√§llt, was Sie sehen! <br><br><h3>  Gehen Sie Mikro </h3><br>  Go-micro ist ein leistungsstarkes Microservice-Framework, das in Go geschrieben wurde und gr√∂√ütenteils mit Go verwendet werden kann.  Sie k√∂nnen Sidecar jedoch verwenden, um mit anderen Sprachen zu interagieren. <br><br>  Go-micro bietet n√ºtzliche Funktionen zum Erstellen von Microservices in Go.  Aber wir werden mit dem vielleicht h√§ufigsten Problem beginnen, das er l√∂st, und dies ist die Entdeckung eines Dienstes. <br><br>  Wir m√ºssen einige Aktualisierungen an unserem Service vornehmen, um mit go-micro arbeiten zu k√∂nnen.  Go-micro wird als Protoc-Plugin integriert und ersetzt in diesem Fall das derzeit verwendete Standard-gRPC-Plugin.  Beginnen wir also damit, dies in unserem Makefile zu ersetzen. <br><br>  Stellen Sie sicher, dass Sie die go-micro-Abh√§ngigkeiten installieren: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Aktualisieren Sie unser Makefile, um das Go-Micro-Plugin anstelle des gRPC-Plugins zu verwenden: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Jetzt m√ºssen wir unsere Shippy-Service-Sendung / main.go aktualisieren, um go-micro verwenden zu k√∂nnen.  Dies abstrahiert den gr√∂√üten Teil unseres vorherigen gRPC-Codes.  Es verarbeitet problemlos die Registrierung und beschleunigt das Schreiben eines Dienstes. <br><br><div class="spoiler">  <b class="spoiler_title">Shippy-Service-Sendung / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Die wichtigste √Ñnderung hierbei ist die Art und Weise, wie wir unseren gRPC-Server erstellen, der sauber von mico.NewService () abstrahiert wurde, der die Registrierung unseres Dienstes √ºbernimmt.  Und schlie√ülich die Funktion service.Run (), die die Verbindung selbst verarbeitet.  Nach wie vor registrieren wir unsere Implementierung, diesmal jedoch mit einer etwas anderen Methode. <br><br>  Die zweitgr√∂√üte √Ñnderung betrifft die Dienstmethoden selbst: Die Argumente und Antworttypen werden geringf√ºgig ge√§ndert, um sowohl die Anforderungs- als auch die Antwortstruktur als Argumente zu akzeptieren, und geben jetzt nur noch einen Fehler zur√ºck.  In unseren Methoden legen wir die Antwort fest, die Go-Micro-Prozesse verarbeiten. <br><br>  Schlie√ülich programmieren wir den Port nicht mehr.  Go-micro muss mithilfe von Umgebungsvariablen oder Befehlszeilenargumenten konfiguriert werden.  Verwenden Sie zum Festlegen der Adresse MICRO_SERVER_ADDRESS =: 50051.  Standardm√§√üig verwendet Micro MDNS (Multicast-DNS) als Service Discovery Broker f√ºr die lokale Verwendung.  Normalerweise verwenden Sie mdns nicht, um Services in einer Produktionsumgebung zu ermitteln. Wir m√∂chten jedoch vermeiden, dass Sie zum Testen etwas wie Consul oder etcd lokal ausf√ºhren m√ºssen.  Dazu sp√§ter mehr. <br><br>  Lassen Sie uns unser Makefile aktualisieren, um dies widerzuspiegeln. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e ist das Flag der Umgebungsvariablen. Sie k√∂nnen Umgebungsvariablen an Ihren Docker-Container √ºbergeben.  Sie m√ºssen f√ºr jede Variable ein Flag haben, z. B. -e ENV = Staging -e DB_HOST = localhost usw. <br><br>  Wenn Sie jetzt $ make run ausf√ºhren, verf√ºgen Sie √ºber einen Dockerised-Dienst mit Diensterkennung.  Aktualisieren wir also unser Cli-Tool, um dies zu verwenden. <br><br><div class="spoiler">  <b class="spoiler_title">Sendung-Cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Hier haben wir die Go-Micro-Bibliotheken zum Erstellen von Clients importiert und den vorhandenen Verbindungscode durch den Go-Micro-Client-Code ersetzt, der die Berechtigung des Dienstes verwendet, anstatt eine direkte Verbindung zur Adresse herzustellen. <br><br>  Wenn Sie dies jedoch ausf√ºhren, funktioniert es nicht.  Dies liegt daran, dass wir unseren Dienst jetzt im Docker-Container starten, der √ºber eigene MDNS verf√ºgt, die von dem derzeit verwendeten MDNS-Host getrennt sind.  Der einfachste Weg, dies zu beheben, besteht darin, sicherzustellen, dass sowohl der Dienst als auch der Client im Dockerland ausgef√ºhrt werden, sodass beide auf demselben Host arbeiten und dieselbe Netzwerkschicht verwenden.  Erstellen wir also make consignment-cli / Makefile und erstellen einige Eintr√§ge. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Nach wie vor wollen wir unsere Bin√§rdatei f√ºr Linux erstellen.  Wenn wir unser Docker-Image starten, m√∂chten wir eine Umgebungsvariable √ºbergeben, um dem Befehl go-micro die Verwendung von mdns zu erteilen. <br><br>  Jetzt erstellen wir eine Docker-Datei f√ºr unser CLI-Tool: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Dies ist unserem Service Dockerfile sehr √§hnlich, au√üer dass es auch unsere JSON-Datendatei extrahiert. <br><br>  Wenn Sie jetzt $ make run in Ihrer Shippy-Cli-Sendung ausf√ºhren, sollten Sie Created: true wie zuvor sehen. <br><br>  Jetzt scheint es an der Zeit, einen Blick auf die neue Docker-Funktion zu werfen: mehrstufige Builds.  Dadurch k√∂nnen wir mehrere Docker-Images in einer Docker-Datei verwenden. <br><br>  Dies ist in unserem Fall besonders n√ºtzlich, da wir ein Bild verwenden k√∂nnen, um unsere Bin√§rdatei mit allen korrekten Abh√§ngigkeiten zu erstellen.  Verwenden Sie dann das zweite Image, um es zu starten.  Versuchen wir dies, ich werde detaillierte Kommentare zusammen mit dem Code hinterlassen: <br><div class="spoiler">  <b class="spoiler_title">Sendungsservice / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Jetzt werde ich zu anderen Docker-Dateien √ºbergehen und diesen neuen Ansatz w√§hlen.  Oh, und vergiss nicht, $ go build von deinen Makefiles zu entfernen! <br><br><h3>  Schiffsservice </h3><br>  Lassen Sie uns einen zweiten Dienst erstellen.  Wir haben einen Service (Shippy-Service-Sendung), der sich mit der Koordination der Containercharge mit dem Schiff befasst, das f√ºr diese Charge am besten geeignet ist.  Um unserer Charge zu entsprechen, m√ºssen wir das Gewicht und die Anzahl der Container an unseren neuen Schiffsservice senden, der dann ein Schiff findet, das diese Charge verarbeiten kann. <br><br>  Erstellen Sie ein neues Verzeichnis in Ihrem <b>$ mkdir-Schiffsdienst-</b> Stammverzeichnis. Erstellen Sie jetzt ein Unterverzeichnis f√ºr unsere neue Protobuf-Dienstdefinition, <b>$ mkdir -p shippy-service-Schiff / Proto / Schiff</b> .  Jetzt erstellen wir eine neue Protobuf-Datei, <b>$ touch shippy-service-ship / proto / ship / ship.proto</b> . <br><br>  Da die Definition von Protobuf in der Tat der Kern unseres Software-Designs ist, beginnen wir damit. <br><br><div class="spoiler">  <b class="spoiler_title">Schiff / Schiff.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Wie Sie sehen k√∂nnen, ist dies unserem ersten Service sehr √§hnlich.  Wir erstellen einen Service mit einer RPC-Methode namens FindAvailable.  Dies nimmt eine Art von Spezifikation an und gibt eine Art von Antwort zur√ºck.  Der Antworttyp gibt entweder den Schiffstyp oder mehrere Schiffe √ºber ein sich wiederholendes Feld zur√ºck. <br><br>  Jetzt m√ºssen wir ein Makefile erstellen, um unsere Build-Logik und unser Startskript zu verarbeiten.  <b>$ touch Shippy-Service-Schiff / Makefile</b> .  √ñffnen Sie diese Datei und f√ºgen Sie Folgendes hinzu: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Dies ist fast identisch mit dem ersten Makefile, das wir f√ºr unseren Sendungsservice erstellt haben. Beachten Sie jedoch, dass sich die Namen der Services und Ports etwas ge√§ndert haben.  Wir k√∂nnen nicht zwei Dock-Container am selben Port starten, daher verwenden wir die Docker-Portweiterleitung, damit dieser Dienst im Host-Netzwerk von 50051 auf 50052 umleitet. <br><br>  Jetzt brauchen wir eine Docker-Datei mit unserem neuen mehrstufigen Format: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Schlie√ülich k√∂nnen wir unsere Implementierung schreiben: <br><br><div class="spoiler">  <b class="spoiler_title">Schiffsservice / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Kommen wir nun zum interessanten Teil.  Wenn wir eine Sendung erstellen, m√ºssen wir unseren Frachtumschlagdienst √§ndern, um den Schiffssuchdienst zu kontaktieren, das Schiff zu finden und den Parameter ship_id in der erstellten Sendung zu aktualisieren: <br><br><div class="spoiler">  <b class="spoiler_title">Versand / Sendungsservice / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Hier haben wir eine Client-Instanz f√ºr unseren Schiffsservice erstellt, mit der wir den Servicenamen verwenden k√∂nnen, d. H.  shipy.service.vessel, um den Schiffsservice als Client aufzurufen und mit seinen Methoden zu interagieren.       ( FindAvailable ).        ,    ,      .       . <br><br>   consignment-cli / consignment.json,    ship_id,    ,      .          .  Zum Beispiel: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br>   <b>$ make build &amp;&amp; make run</b>  consignment-cli.        .      ,    vessel_id. <br><br> ,          ! <br>               MongoDB.        docker-compose       . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  EwanValentine</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455812/">https://habr.com/ru/post/de455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455796/index.html">Objektorientierte Programmierung in Java und Python: √Ñhnlichkeiten und Unterschiede</a></li>
<li><a href="../de455800/index.html">Matrix 1.0 - Freigabe des dezentralen Messaging-Protokolls</a></li>
<li><a href="../de455802/index.html">Wie man die Olympischen Spiele per E-Mail zusammenstellt. Fall Black Star</a></li>
<li><a href="../de455806/index.html">Geburt und Tod eines Albums: Wir verstehen, wie sich die Musikformate in den letzten 100 Jahren ver√§ndert haben</a></li>
<li><a href="../de455808/index.html">Holen Sie sich mit Python Ausz√ºge aus dem Register auf der FTS-Website</a></li>
<li><a href="../de455816/index.html">So erstellen Sie coole Aktionen f√ºr Google Assistant. Lifehacks von Just AI</a></li>
<li><a href="../de455820/index.html">VM-Leistungsanalyse in VMware vSphere. Teil 2: Erinnerung</a></li>
<li><a href="../de455826/index.html">Ferngesteuerte automatische Bew√§sserung</a></li>
<li><a href="../de455828/index.html">Wissenschaftler haben neue exotische Formen der Synchronisation entdeckt</a></li>
<li><a href="../de455830/index.html">Ein Blick auf Go durch die Augen eines .NET-Entwicklers. Woche # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>