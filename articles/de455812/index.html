<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏻 🚵🏻 🌡️ Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 2 (Docker) 🙇🏿 🔚 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist Zeit, die Container in Angriff zu nehmen 
 Zunächst verwenden wir das neueste Linux Alpine-Image. Linux Alpine ist eine leichtgewichtige Linux-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau einer Microservice-Architektur auf Golang und gRPC, Teil 2 (Docker)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  Es ist Zeit, die Container in Angriff zu nehmen </h3><br>  Zunächst verwenden wir das neueste Linux Alpine-Image.  Linux Alpine ist eine leichtgewichtige Linux-Distribution, die für die Ausführung von Webanwendungen in Docker entwickelt und optimiert wurde.  Mit anderen Worten, Linux Alpine verfügt über genügend Abhängigkeiten und Funktionen, um die meisten Anwendungen auszuführen.  Dies bedeutet, dass die Bildgröße ca. 8 MB beträgt! <br><br>  Im Vergleich zu beispielsweise einer virtuellen Ubuntu-Maschine mit einer Kapazität von etwa 1 GB sind Docker-Images für Microservices und Cloud Computing natürlicher geworden. <br><br>  Nun hoffe ich, dass Sie Wert in der Containerisierung sehen und wir mit dem „Dockerisieren“ unseres ersten Dienstes beginnen können.  Erstellen wir einen Dockerfile <b>$ touch-Sendungsdienst / Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originales EwanValentine-Repository</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> <br><br>  Fügen Sie in der Docker-Datei Folgendes hinzu: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Dann erstellen wir ein neues Verzeichnis, um unsere Anwendung zu hosten.  Dann fügen wir unsere kompilierte Binärdatei zu unserem Docker-Container hinzu und führen sie aus. <br><br>  Aktualisieren wir nun den Build-Datensatz unseres Makefiles, um ein Docker-Image zu erstellen. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Wir haben zwei weitere Schritte hinzugefügt, und ich möchte sie näher erläutern.  Zunächst erstellen wir unsere Go-Binärdatei.  Sie werden jedoch zwei Umgebungsvariablen bemerken, bevor wir $ go build ausführen.  Mit GOOS und GOARCH können Sie Ihre Binärdatei für ein anderes Betriebssystem überkompilieren.  Da ich für ein Macbook entwickle, kann ich die ausführbare Datei go nicht kompilieren und dann in einem Docker-Container ausführen, der Linux verwendet.  Die Binärdatei ist in Ihrem Docker-Container völlig bedeutungslos und es wird ein Fehler ausgegeben. <br><br>  Der zweite Schritt, den ich hinzugefügt habe, ist der Docker-Erstellungsprozess.  Docker liest Ihre Docker-Datei und erstellt ein Bild mit dem Namen "Konsignationsdienst". Der Punkt gibt den Verzeichnispfad an. Hier soll der Erstellungsprozess nur das aktuelle Verzeichnis anzeigen. <br><br>  Ich werde unserem Makefile einen neuen Eintrag hinzufügen: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Hier starten wir unser Docker-Image durch Öffnen von Port 50051. Da Docker auf einer separaten Netzwerkebene ausgeführt wird, müssen Sie den Port umleiten.  Wenn Sie diesen Dienst beispielsweise an Port 8080 starten möchten, müssen Sie das Argument -p in 8080: 50051 ändern.  Sie können den Container auch im Hintergrund ausführen, indem Sie das Flag -d einfügen.  Zum Beispiel führt <b>Docker -d -p 50051: 50051 aus</b> . <br><br>  Führen Sie <b>$ make run aus</b> , und führen Sie dann in einem separaten Terminalfenster erneut <b>go go main.go aus</b> und überprüfen Sie, ob es noch funktioniert. <br><br>  Wenn Sie $ docker build ausführen, binden Sie Ihren Code und Ihre Laufzeit in das Image ein.  Docker-Images sind portable Images Ihrer Umgebung und ihrer Abhängigkeiten.  Sie können Docker-Bilder freigeben, indem Sie sie im Docker Hub veröffentlichen.  Dies ähnelt npm oder dem yum-Repository für Docker-Images.  Wenn Sie FROM in Ihrer Docker-Datei definieren, weisen Sie Docker an, dieses Image aus dem Docker-Repository zur Verwendung als Basis abzurufen.  Sie können dann Teile dieser Basisdatei erweitern und neu definieren und sie nach Ihren Wünschen neu definieren.  Wir werden unsere Docker-Images nicht veröffentlichen, können jedoch das Docker-Repository durchsuchen und feststellen, dass fast jede Software bereits in Containern verpackt wurde.  Einige wirklich wundervolle Dinge wurden angedockt. <br><br>  Jede Anzeige in Dockerfile wird beim ersten Erstellen zwischengespeichert.  Dadurch entfällt die Notwendigkeit, die gesamte Laufzeit bei jeder Änderung neu zu erstellen.  Der Docker ist intelligent genug, um herauszufinden, welche Details sich geändert haben und welche neu erstellt werden müssen.  Dies macht den Erstellungsprozess unglaublich schnell. <br><br>  Genug von den Containern!  Kehren wir zu unserem Code zurück. <br><br>  Beim Erstellen des gRPC-Dienstes gibt es viele Standardcodes zum Erstellen von Verbindungen, und Sie müssen den Speicherort der Dienstadresse im Client oder einem anderen Dienst fest codieren, damit er eine Verbindung zu ihm herstellen kann.  Dies ist schwierig, da beim Starten von Diensten in der Cloud möglicherweise nicht derselbe Host verwendet wird oder sich die Adresse oder IP-Adresse nach der erneuten Bereitstellung des Dienstes ändert. <br><br>  Hier kommt der Discovery-Service ins Spiel.  Der Erkennungsdienst aktualisiert das Verzeichnis aller Ihrer Dienste und deren Speicherorte.  Jeder Dienst wird zur Laufzeit registriert und beim Schließen abgemeldet.  Jedem Dienst wird dann ein Name oder eine Kennung zugewiesen.  Selbst wenn es eine neue IP-Adresse oder eine neue Hostadresse hat, müssen Sie daher keine Anrufe von anderen Diensten auf diesen Dienst aktualisieren, sofern der Dienstname gleich bleibt. <br><br>  In der Regel gibt es viele Ansätze für dieses Problem, aber wie die meisten Dinge in der Programmierung macht es keinen Sinn, das Rad neu zu erfinden, wenn sich jemand bereits mit diesem Problem befasst hat.  @Chuhnk (Asim Aslam), der Erfinder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-micro</a> , löst diese Probleme mit fantastischer Klarheit und Benutzerfreundlichkeit.  Er produziert im Alleingang fantastische Software.  Bitte helfen Sie ihm, wenn Ihnen das gefällt, was Sie sehen! <br><br><h3>  Gehen Sie Mikro </h3><br>  Go-micro ist ein leistungsstarkes Microservice-Framework, das in Go geschrieben wurde und größtenteils mit Go verwendet werden kann.  Sie können Sidecar jedoch verwenden, um mit anderen Sprachen zu interagieren. <br><br>  Go-micro bietet nützliche Funktionen zum Erstellen von Microservices in Go.  Aber wir werden mit dem vielleicht häufigsten Problem beginnen, das er löst, und dies ist die Entdeckung eines Dienstes. <br><br>  Wir müssen einige Aktualisierungen an unserem Service vornehmen, um mit go-micro arbeiten zu können.  Go-micro wird als Protoc-Plugin integriert und ersetzt in diesem Fall das derzeit verwendete Standard-gRPC-Plugin.  Beginnen wir also damit, dies in unserem Makefile zu ersetzen. <br><br>  Stellen Sie sicher, dass Sie die go-micro-Abhängigkeiten installieren: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Aktualisieren Sie unser Makefile, um das Go-Micro-Plugin anstelle des gRPC-Plugins zu verwenden: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Jetzt müssen wir unsere Shippy-Service-Sendung / main.go aktualisieren, um go-micro verwenden zu können.  Dies abstrahiert den größten Teil unseres vorherigen gRPC-Codes.  Es verarbeitet problemlos die Registrierung und beschleunigt das Schreiben eines Dienstes. <br><br><div class="spoiler">  <b class="spoiler_title">Shippy-Service-Sendung / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Die wichtigste Änderung hierbei ist die Art und Weise, wie wir unseren gRPC-Server erstellen, der sauber von mico.NewService () abstrahiert wurde, der die Registrierung unseres Dienstes übernimmt.  Und schließlich die Funktion service.Run (), die die Verbindung selbst verarbeitet.  Nach wie vor registrieren wir unsere Implementierung, diesmal jedoch mit einer etwas anderen Methode. <br><br>  Die zweitgrößte Änderung betrifft die Dienstmethoden selbst: Die Argumente und Antworttypen werden geringfügig geändert, um sowohl die Anforderungs- als auch die Antwortstruktur als Argumente zu akzeptieren, und geben jetzt nur noch einen Fehler zurück.  In unseren Methoden legen wir die Antwort fest, die Go-Micro-Prozesse verarbeiten. <br><br>  Schließlich programmieren wir den Port nicht mehr.  Go-micro muss mithilfe von Umgebungsvariablen oder Befehlszeilenargumenten konfiguriert werden.  Verwenden Sie zum Festlegen der Adresse MICRO_SERVER_ADDRESS =: 50051.  Standardmäßig verwendet Micro MDNS (Multicast-DNS) als Service Discovery Broker für die lokale Verwendung.  Normalerweise verwenden Sie mdns nicht, um Services in einer Produktionsumgebung zu ermitteln. Wir möchten jedoch vermeiden, dass Sie zum Testen etwas wie Consul oder etcd lokal ausführen müssen.  Dazu später mehr. <br><br>  Lassen Sie uns unser Makefile aktualisieren, um dies widerzuspiegeln. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e ist das Flag der Umgebungsvariablen. Sie können Umgebungsvariablen an Ihren Docker-Container übergeben.  Sie müssen für jede Variable ein Flag haben, z. B. -e ENV = Staging -e DB_HOST = localhost usw. <br><br>  Wenn Sie jetzt $ make run ausführen, verfügen Sie über einen Dockerised-Dienst mit Diensterkennung.  Aktualisieren wir also unser Cli-Tool, um dies zu verwenden. <br><br><div class="spoiler">  <b class="spoiler_title">Sendung-Cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Hier haben wir die Go-Micro-Bibliotheken zum Erstellen von Clients importiert und den vorhandenen Verbindungscode durch den Go-Micro-Client-Code ersetzt, der die Berechtigung des Dienstes verwendet, anstatt eine direkte Verbindung zur Adresse herzustellen. <br><br>  Wenn Sie dies jedoch ausführen, funktioniert es nicht.  Dies liegt daran, dass wir unseren Dienst jetzt im Docker-Container starten, der über eigene MDNS verfügt, die von dem derzeit verwendeten MDNS-Host getrennt sind.  Der einfachste Weg, dies zu beheben, besteht darin, sicherzustellen, dass sowohl der Dienst als auch der Client im Dockerland ausgeführt werden, sodass beide auf demselben Host arbeiten und dieselbe Netzwerkschicht verwenden.  Erstellen wir also make consignment-cli / Makefile und erstellen einige Einträge. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Nach wie vor wollen wir unsere Binärdatei für Linux erstellen.  Wenn wir unser Docker-Image starten, möchten wir eine Umgebungsvariable übergeben, um dem Befehl go-micro die Verwendung von mdns zu erteilen. <br><br>  Jetzt erstellen wir eine Docker-Datei für unser CLI-Tool: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Dies ist unserem Service Dockerfile sehr ähnlich, außer dass es auch unsere JSON-Datendatei extrahiert. <br><br>  Wenn Sie jetzt $ make run in Ihrer Shippy-Cli-Sendung ausführen, sollten Sie Created: true wie zuvor sehen. <br><br>  Jetzt scheint es an der Zeit, einen Blick auf die neue Docker-Funktion zu werfen: mehrstufige Builds.  Dadurch können wir mehrere Docker-Images in einer Docker-Datei verwenden. <br><br>  Dies ist in unserem Fall besonders nützlich, da wir ein Bild verwenden können, um unsere Binärdatei mit allen korrekten Abhängigkeiten zu erstellen.  Verwenden Sie dann das zweite Image, um es zu starten.  Versuchen wir dies, ich werde detaillierte Kommentare zusammen mit dem Code hinterlassen: <br><div class="spoiler">  <b class="spoiler_title">Sendungsservice / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Jetzt werde ich zu anderen Docker-Dateien übergehen und diesen neuen Ansatz wählen.  Oh, und vergiss nicht, $ go build von deinen Makefiles zu entfernen! <br><br><h3>  Schiffsservice </h3><br>  Lassen Sie uns einen zweiten Dienst erstellen.  Wir haben einen Service (Shippy-Service-Sendung), der sich mit der Koordination der Containercharge mit dem Schiff befasst, das für diese Charge am besten geeignet ist.  Um unserer Charge zu entsprechen, müssen wir das Gewicht und die Anzahl der Container an unseren neuen Schiffsservice senden, der dann ein Schiff findet, das diese Charge verarbeiten kann. <br><br>  Erstellen Sie ein neues Verzeichnis in Ihrem <b>$ mkdir-Schiffsdienst-</b> Stammverzeichnis. Erstellen Sie jetzt ein Unterverzeichnis für unsere neue Protobuf-Dienstdefinition, <b>$ mkdir -p shippy-service-Schiff / Proto / Schiff</b> .  Jetzt erstellen wir eine neue Protobuf-Datei, <b>$ touch shippy-service-ship / proto / ship / ship.proto</b> . <br><br>  Da die Definition von Protobuf in der Tat der Kern unseres Software-Designs ist, beginnen wir damit. <br><br><div class="spoiler">  <b class="spoiler_title">Schiff / Schiff.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Wie Sie sehen können, ist dies unserem ersten Service sehr ähnlich.  Wir erstellen einen Service mit einer RPC-Methode namens FindAvailable.  Dies nimmt eine Art von Spezifikation an und gibt eine Art von Antwort zurück.  Der Antworttyp gibt entweder den Schiffstyp oder mehrere Schiffe über ein sich wiederholendes Feld zurück. <br><br>  Jetzt müssen wir ein Makefile erstellen, um unsere Build-Logik und unser Startskript zu verarbeiten.  <b>$ touch Shippy-Service-Schiff / Makefile</b> .  Öffnen Sie diese Datei und fügen Sie Folgendes hinzu: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Dies ist fast identisch mit dem ersten Makefile, das wir für unseren Sendungsservice erstellt haben. Beachten Sie jedoch, dass sich die Namen der Services und Ports etwas geändert haben.  Wir können nicht zwei Dock-Container am selben Port starten, daher verwenden wir die Docker-Portweiterleitung, damit dieser Dienst im Host-Netzwerk von 50051 auf 50052 umleitet. <br><br>  Jetzt brauchen wir eine Docker-Datei mit unserem neuen mehrstufigen Format: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Schließlich können wir unsere Implementierung schreiben: <br><br><div class="spoiler">  <b class="spoiler_title">Schiffsservice / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Kommen wir nun zum interessanten Teil.  Wenn wir eine Sendung erstellen, müssen wir unseren Frachtumschlagdienst ändern, um den Schiffssuchdienst zu kontaktieren, das Schiff zu finden und den Parameter ship_id in der erstellten Sendung zu aktualisieren: <br><br><div class="spoiler">  <b class="spoiler_title">Versand / Sendungsservice / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Hier haben wir eine Client-Instanz für unseren Schiffsservice erstellt, mit der wir den Servicenamen verwenden können, d. H.  shipy.service.vessel, um den Schiffsservice als Client aufzurufen und mit seinen Methoden zu interagieren.       ( FindAvailable ).        ,    ,      .       . <br><br>   consignment-cli / consignment.json,    ship_id,    ,      .          .  Zum Beispiel: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br>   <b>$ make build &amp;&amp; make run</b>  consignment-cli.        .      ,    vessel_id. <br><br> ,          ! <br>               MongoDB.        docker-compose       . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  EwanValentine</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455812/">https://habr.com/ru/post/de455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455796/index.html">Objektorientierte Programmierung in Java und Python: Ähnlichkeiten und Unterschiede</a></li>
<li><a href="../de455800/index.html">Matrix 1.0 - Freigabe des dezentralen Messaging-Protokolls</a></li>
<li><a href="../de455802/index.html">Wie man die Olympischen Spiele per E-Mail zusammenstellt. Fall Black Star</a></li>
<li><a href="../de455806/index.html">Geburt und Tod eines Albums: Wir verstehen, wie sich die Musikformate in den letzten 100 Jahren verändert haben</a></li>
<li><a href="../de455808/index.html">Holen Sie sich mit Python Auszüge aus dem Register auf der FTS-Website</a></li>
<li><a href="../de455816/index.html">So erstellen Sie coole Aktionen für Google Assistant. Lifehacks von Just AI</a></li>
<li><a href="../de455820/index.html">VM-Leistungsanalyse in VMware vSphere. Teil 2: Erinnerung</a></li>
<li><a href="../de455826/index.html">Ferngesteuerte automatische Bewässerung</a></li>
<li><a href="../de455828/index.html">Wissenschaftler haben neue exotische Formen der Synchronisation entdeckt</a></li>
<li><a href="../de455830/index.html">Ein Blick auf Go durch die Augen eines .NET-Entwicklers. Woche # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>