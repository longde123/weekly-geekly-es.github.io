<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üì• üóûÔ∏è Apakah Anda membaca Scaladoc untuk metode pengumpulan yang "jelas"? Atau mengapa kemalasan tidak selalu baik ‚û°Ô∏è üí≥ üö∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda tidak tahu bagaimana mereka berbeda 


someMap.map{ case (k, v) => k -> foo(v)}  


 dan 


 someMap.mapValues(foo)  


 kecuali untuk sinta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah Anda membaca Scaladoc untuk metode pengumpulan yang "jelas"? Atau mengapa kemalasan tidak selalu baik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/430538/"><p>  Jika Anda tidak tahu bagaimana mereka berbeda </p><br><pre><code class="scala hljs">someMap.map{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k, v) =&gt; k -&gt; foo(v)}</code> </pre> <br><p>  dan </p><br><pre> <code class="scala hljs">someMap.mapValues(foo)</code> </pre> <br><p>  kecuali untuk sintaks, atau Anda ragu / tidak tahu apa konsekuensi buruk perbedaan ini dapat menyebabkan, dan di mana <code>identity</code> , maka artikel ini adalah untuk Anda. </p><br><p>  Kalau tidak, ambil bagian dalam survei yang terletak di akhir artikel. </p><a name="habracut"></a><br><h2 id="nachnem-s-prostogo">  Mari kita mulai dengan yang sederhana </h2><br><p>  Mari kita coba dengan bodoh untuk mengambil contoh yang terletak sebelum kat dan melihat apa yang terjadi: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = value + <span class="hljs-string"><span class="hljs-string">"_changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap = someMap.map{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; k -&gt; foo(v)} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues = someMap.mapValues(foo) println(<span class="hljs-string"><span class="hljs-string">s"resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"equality: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap == resultMapValues}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Kode ini diharapkan untuk dicetak </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; value1_changed, key2 -&gt; value2_changed) resultMapValues: Map(key1 -&gt; value1_changed, key2 -&gt; value2_changed) equality: true</code> </pre> <br><p>  Dan pada tingkat ini, pemahaman tentang metode <code>mapValues</code> pada tahap awal pembelajaran Scala: baik, ya, ada metode seperti itu, akan lebih mudah untuk mengubah nilai-nilai di <code>Map</code> ketika kunci tidak berubah.  Dan sungguh, apa lagi yang ada untuk dipikirkan?  Dengan nama metode, semuanya jelas, perilakunya jelas. </p><br><h2 id="primery-poslozhnee">  Contoh yang lebih rumit </h2><br><p>  Mari kita sedikit memodifikasi contoh kami (saya akan secara eksplisit menulis jenis sehingga Anda tidak berpikir bahwa ada semacam muggle dengan implisit): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">someMap</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span> = <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>(value) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.map{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; k -&gt; foo(v)} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.mapValues(foo) println(<span class="hljs-string"><span class="hljs-string">s"resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"equality: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap == resultMapValues}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Dan kode tersebut akan menghasilkan setelah peluncuran </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; ValueHolder(value1), key2 -&gt; ValueHolder(value2)) resultMapValues: Map(key1 -&gt; ValueHolder(value1), key2 -&gt; ValueHolder(value2)) equality: true</code> </pre> <br><p>  Cukup logis dan jelas.  "Sobat, saatnya untuk sampai ke bagian bawah artikel!"  - Pembaca akan berkata.  Mari kita buat penciptaan kelas kita tergantung pada kondisi eksternal dan menambahkan beberapa pemeriksaan sederhana untuk kebodohan: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, seed: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span> = <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>(value, <span class="hljs-type"><span class="hljs-type">Random</span></span>.nextInt()) ... println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap.head == resultMap.head}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMapValues.head == resultMapValues.head}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Pada output yang kita dapatkan: </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; ValueHolder(value1,1189482436), key2 -&gt; ValueHolder(value2,-702760039)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,-1354493526), key2 -&gt; ValueHolder(value2,-379389312)) equality: false simple assert for resultMap: true simple assert for resultMapValues: false</code> </pre> <br><p>  Adalah logis bahwa hasilnya sekarang tidak sama, tetapi acak.  Tapi tunggu, mengapa pernyataan kedua itu <code>false</code> ?  Sungguh nilai dalam <code>resultMapValues</code> telah berubah, tetapi kami tidak melakukan apa pun dengan mereka?  Mari kita periksa apakah semua yang ada di dalamnya sama dengan sebelumnya: </p><br><pre> <code class="scala hljs">println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Dan pada output kita dapatkan: </p><br><pre> <code class="plaintext hljs">resultMapValues: Map(key1 -&gt; ValueHolder(value1,1771067356), key2 -&gt; ValueHolder(value2,2034115276)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,-625731649), key2 -&gt; ValueHolder(value2,-1815306407))</code> </pre> <br><p><img src="https://habrastorage.org/webt/q8/mu/fq/q8mufqtncnwg0ttpmvrcl6p4zxo.jpeg" alt="gambar"></p><br><h2 id="pochemu-eto-proizoshlo">  Mengapa ini terjadi? </h2><br><p>  Mengapa <code>println</code> mengubah nilai <code>Map</code> ? <br>  Saatnya masuk ke dokumentasi untuk metode <code>mapValues</code> : </p><br><pre> <code class="scala hljs"> <span class="hljs-comment"><span class="hljs-comment">/** Transforms this map by applying a function to every retrieved value. * @param f the function used to transform values of this map. * @return a map view which maps every key of this map * to `f(this(key))`. The resulting map wraps the original map without copying any elements. */</span></span></code> </pre> <br><p>  Baris pertama memberi tahu kita apa yang kita pikirkan - ia mengubah <code>Map</code> , menerapkan fungsi yang diteruskan dalam argumen ke setiap nilai.  Tetapi jika Anda membacanya dengan sangat hati-hati dan sampai akhir, ternyata bukan <code>Map</code> yang dikembalikan, melainkan "tampilan peta" (tampilan).  Dan ini bukan tampilan normal ( <code>View</code> ), yang bisa Anda dapatkan menggunakan metode <code>view</code> dan yang memiliki metode <code>force</code> untuk perhitungan eksplisit.  Kelas khusus (kodenya dari Scala versi 2.12.7, tetapi untuk 2.11 ada hal yang hampir sama): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MappedValues</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">f: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">V</span></span></span></span><span class="hljs-class"><span class="hljs-params"> =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">W</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMap</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultMap</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">U</span></span>](g: ((<span class="hljs-type"><span class="hljs-type">K</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)) =&gt; <span class="hljs-type"><span class="hljs-type">U</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((k, v) &lt;- self) g((k, f(v))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((k, v) &lt;- self.iterator) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (k, f(v)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function"> </span></span>= self.size <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>) = self.contains(key) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>) = self.get(key).map(f) }</code> </pre> <br><p>  Jika Anda membaca kode ini, Anda akan melihat bahwa tidak ada yang di-cache, dan setiap kali Anda mengakses nilainya, mereka akan dihitung ulang.  Apa yang kita amati dalam contoh kita. </p><br><p>  Jika Anda bekerja dengan fungsi murni dan semuanya tidak berubah, maka Anda tidak akan melihat perbedaan apa pun.  Yah, mungkin kinerja akan menguras.  Tetapi, sayangnya, tidak semua yang ada di dunia kita bersih dan sempurna, dan dengan menggunakan metode ini, Anda dapat menginjak rake (yang terjadi di salah satu proyek kami, kalau tidak, artikel ini tidak akan). </p><br><p>  Tentu saja, kami bukan yang pertama kali menemukan ini.  Sudah pada tahun 2011, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug utama</a> dibuka pada kesempatan ini (dan pada saat penulisan, ini ditandai sebagai terbuka).  Itu juga menyebutkan metode <code>filterKeys</code> , yang memiliki masalah yang persis sama, karena diterapkan pada prinsip yang sama. </p><br><p>  Selain itu, sejak 2015, sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket telah</a> digantung untuk menambahkan inspeksi ke IntelliJ Idea. </p><br><h2 id="chto-delat">  Apa yang harus dilakukan </h2><br><p>  Solusi paling sederhana adalah dengan bodohnya tidak menggunakan metode ini, karena  menurut nama, perilaku mereka, menurut saya, sangat tidak jelas. </p><br><p>  Pilihan yang sedikit lebih baik adalah memanggil <code>map(identity)</code> . <br>  <code>identity</code> , jika ada yang tidak tahu, ini adalah fungsi dari perpustakaan standar yang hanya mengembalikan argumen inputnya.  Dalam hal ini, pekerjaan utama dilakukan dengan metode <code>map</code> , yang secara eksplisit membuat <code>Map</code> normal.  Mari kita periksa untuk berjaga-jaga: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.mapValues(foo).map(identity) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMapValues.head == resultMapValues.head}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Pada output yang kita dapatkan </p><br><pre> <code class="plaintext hljs">resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608)) simple assert for resultMapValues: true resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608))</code> </pre> <br><p>  Semua baik-baik saja :) </p><br><p>  Jika Anda masih ingin meninggalkan kemalasan, lebih baik mengubah kode sehingga jelas.  Anda bisa membuat kelas implisit dengan metode wrapper untuk <code>mapValues</code> dan <code>filterKeys</code> , yang memberikan nama baru yang bisa dimengerti oleh mereka.  Atau gunakan secara eksplisit <code>.view</code> dan bekerja dengan iterator berpasangan. </p><br><p>  Selain itu, ada baiknya menambahkan inspeksi ke lingkungan pengembangan / aturan dalam penganalisa statis / di tempat lain, yang memperingatkan tentang penggunaan metode ini.  Karena lebih baik menghabiskan sedikit waktu sekarang daripada menginjak menyapu dan menyapu konsekuensinya untuk waktu yang lama kemudian. </p><br><h2 id="kak-vy-esche-mozhete-nastupit-na-grabli-i-kak-nastupili-na-nih-my">  Bagaimana lagi Anda bisa menginjak menyapu dan bagaimana kita menginjaknya </h2><br><p>  Selain kasus dengan ketergantungan pada kondisi eksternal, yang kami amati dalam contoh di atas, ada opsi lain. </p><br><p>  Misalnya, nilai yang dapat berubah (perhatikan, di sini jika dilihat sekilas semuanya "tidak berubah"): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap1 = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap2 = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = value.incrementAndGet() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>] = someMap1.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k, v) =&gt; k -&gt; increment(v) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>] = someMap2.mapValues(increment) println(<span class="hljs-string"><span class="hljs-string">s"resultMap (1): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues (1): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMap (2): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues (2): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Kode ini akan menghasilkan hasil ini: </p><br><pre> <code class="plaintext hljs">resultMap (1): Map(key1 -&gt; 1, key2 -&gt; 1) resultMapValues (1): Map(key1 -&gt; 1, key2 -&gt; 1) resultMap (2): Map(key1 -&gt; 1, key2 -&gt; 1) resultMapValues (2): Map(key1 -&gt; 2, key2 -&gt; 2)</code> </pre> <br><p>  Ketika saya mengakses <code>someMap2</code> lagi, <code>someMap2</code> mendapat hasil yang lucu. </p><br><p>  Masalah-masalah yang mungkin timbul ketika nilai-nilai <code>mapValues</code> dan <code>filterKeys</code> digunakan secara <code>mapValues</code> - <code>mapValues</code> dapat ditambahkan ke degradasi kinerja, peningkatan konsumsi memori dan / atau peningkatan beban pada GC, tetapi ini lebih tergantung pada kasus-kasus tertentu dan mungkin tidak begitu kritis. </p><br><p>  Anda juga harus menambahkan metode <code>toSeq</code> dari iterator ke celengan rake yang serupa, yang mengembalikan <code>Stream</code> malas. </p><br><p>  Kami <code>mapValues</code> tidak sengaja.  Itu digunakan dalam metode yang, menggunakan refleksi, menciptakan satu set penangan dari konfigurasi: kunci adalah pengidentifikasi penangan, dan nilai adalah pengaturan mereka, yang kemudian dikonversi ke penangan sendiri (contoh kelas dibuat).  Karena handler hanya terdiri dari fungsi murni, semuanya bekerja tanpa masalah, bahkan terasa tidak mempengaruhi kinerja (setelah mengambil penggaruk, kami melakukan pengukuran). </p><br><p>  Tetapi begitu saya harus membuat semafor di salah satu penangan agar hanya satu penangan yang melakukan fungsi berat, yang hasilnya disimpan dalam cache dan digunakan oleh penangan lain.  Dan kemudian masalah dimulai pada lingkungan pengujian - kode yang valid yang berfungsi dengan baik secara lokal mulai macet karena masalah dengan semaphore.  Tentu saja, pemikiran pertama dengan ketidakmampuan fungsi baru adalah bahwa masalahnya terkait dengan itu sendiri.  Kami memutar-mutar dengan ini untuk waktu yang lama sampai kami sampai pada kesimpulan "beberapa permainan, mengapa contoh berbeda dari penangan digunakan?"  dan itu hanya pada jejak tumpukan yang mereka temukan kami untuk muncul <code>mapValues</code> . </p><br><p>  Jika Anda bekerja dengan Apache Spark, maka Anda dapat menemukan masalah yang sama ketika Anda tiba-tiba menemukan bahwa untuk beberapa bagian dasar kode dengan <code>.mapValues</code> Anda dapat menangkap </p><br><pre> <code class="plaintext hljs">java.io.NotSerializableException: scala.collection.immutable.MapLike$$anon$2</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/32900862/map-can-not-be-serializable-in-scala</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://issues.scala-lang.org/browse/SI-7005</a> <br>  Namun <code>map(identity)</code> memecahkan masalah, dan biasanya tidak ada motivasi / waktu untuk menggali lebih dalam. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Kesalahan dapat mengintai di tempat-tempat yang paling tidak terduga - bahkan dalam metode yang tampaknya 100% jelas.  Secara khusus, masalah ini, menurut pendapat saya, terkait dengan nama metode yang buruk dan tipe pengembalian yang tidak cukup ketat. </p><br><p>  Tentu saja, penting untuk mempelajari dokumentasi untuk semua metode yang digunakan di perpustakaan standar, tetapi tidak selalu jelas dan, terus terang, tidak selalu ada motivasi yang cukup untuk membaca tentang "hal-hal yang jelas". </p><br><p>  Komputasi malas saja adalah lelucon keren, dan artikel itu sama sekali tidak mendorong mereka untuk meninggalkannya.  Namun, ketika kemalasan tidak jelas - ini dapat menyebabkan masalah. </p><br><p>  Dalam keadilan, masalah dengan nilai <code>mapValues</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah muncul di Habr√©</a> dalam terjemahan, tetapi secara pribadi, artikel yang sangat buruk saya masukkan ke dalam kepala saya, karena  ada banyak hal yang sudah diketahui / mendasar dan tidak sepenuhnya jelas apa bahayanya menggunakan fungsi-fungsi ini: </p><br><blockquote>  Metode filterKeys membungkus tabel sumber tanpa menyalin elemen apa pun.  Tidak ada yang salah dengan itu, tetapi Anda hampir tidak mengharapkan perilaku ini dari filterKeys </blockquote><p>  Artinya, ada komentar tentang perilaku tak terduga, dan bahwa pada saat yang sama Anda juga bisa menginjak menyapu sedikit, tampaknya, itu dianggap tidak mungkin. </p><br><p>  ‚Üí Semua kode dari artikel ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intisari</a> ini </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430538/">https://habr.com/ru/post/id430538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430528/index.html">Pemrograman dengan PyUSB 1.0</a></li>
<li><a href="../id430530/index.html">Server tiruan untuk otomatisasi pengujian seluler</a></li>
<li><a href="../id430532/index.html">Keamanan di aplikasi iOS</a></li>
<li><a href="../id430534/index.html">Membuat templat untuk Zabbix menggunakan DVR Trassir SDK sebagai contoh</a></li>
<li><a href="../id430536/index.html">Merancang fungsi jendela diringkas menjadi satu unit dengan tingkat tumpang tindih yang diberikan</a></li>
<li><a href="../id430542/index.html">Buka webinar "Infrastruktur sebagai kode"</a></li>
<li><a href="../id430546/index.html">"Diyakini bahwa kode tersebut akan diganti oleh diagram UML, tetapi tidak perlu diuji": sebuah wawancara dengan Alexei Barantsev</a></li>
<li><a href="../id430548/index.html">Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 1. Evolusi pengendali interupsi</a></li>
<li><a href="../id430550/index.html">Membangun sistem komponen reaktif dengan Kotlin</a></li>
<li><a href="../id430552/index.html">Startup of the day (September-Oktober 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>