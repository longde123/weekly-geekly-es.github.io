<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôå üöµüèø üìü Alto rendimiento y particionamiento nativo: Zabbix con soporte TimescaleDB ü§üüèæ üïí üññüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zabbix es un sistema de monitoreo. Al igual que cualquier otro sistema, se enfrenta a tres problemas principales de todos los sistemas de monitoreo: r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alto rendimiento y particionamiento nativo: Zabbix con soporte TimescaleDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/470902/">  Zabbix es un sistema de monitoreo.  Al igual que cualquier otro sistema, se enfrenta a tres problemas principales de todos los sistemas de monitoreo: recopilaci√≥n y procesamiento de datos, almacenamiento del historial y su limpieza. <br><br>  Los pasos para adquirir, procesar y registrar datos llevan tiempo.  No mucho, pero para un sistema grande esto puede ocasionar grandes retrasos.  El problema de almacenamiento es un problema de acceso a datos.  Se utilizan para informes, comprobaciones y disparadores.  Los retrasos en el acceso a los datos tambi√©n afectan el rendimiento.  Cuando la base de datos crece, se deben eliminar los datos irrelevantes.  La eliminaci√≥n es una operaci√≥n dif√≠cil que tambi√©n consume algunos de los recursos. <br><br><img src="https://habrastorage.org/webt/jb/yy/zo/jbyyzopzw6gtfio8uhqbgushzo8.jpeg"><br><br>  Los problemas de demoras durante la recolecci√≥n y el almacenamiento en Zabbix se resuelven mediante el almacenamiento en cach√©: varios tipos de cach√©s, almacenamiento en cach√© en la base de datos.  Para resolver el tercer problema, el almacenamiento en cach√© no es adecuado, por lo tanto, Zabbix us√≥ TimescaleDB.  <strong>Andrey Gushchin</strong> , ingeniero de soporte t√©cnico en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zabbix SIA,</a> hablar√° sobre esto.  Andrey ha estado apoyando a Zabbix durante m√°s de 6 a√±os y se enfrenta directamente al rendimiento. <br><br>  ¬øC√≥mo funciona TimescaleDB, qu√© rendimiento puede ofrecer en comparaci√≥n con PostgreSQL normal?  ¬øQu√© papel juega Zabbix en TimescaleDB?  ¬øC√≥mo ejecutar desde cero y c√≥mo migrar con PostgreSQL y qu√© rendimiento es mejor?  Sobre todo esto bajo el corte. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/umRk94j5M8o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Retos de rendimiento </h2><br>  Cada sistema de monitoreo enfrenta desaf√≠os de desempe√±o espec√≠ficos.  Hablar√© de tres de ellos: recopilar y procesar datos, almacenar, limpiar el historial. <br><br>  <strong>R√°pida recopilaci√≥n y procesamiento de datos.</strong>  Un buen sistema de monitoreo deber√≠a recibir r√°pidamente todos los datos y procesarlos de acuerdo con las expresiones de activaci√≥n, de acuerdo con sus propios criterios.  Despu√©s del procesamiento, el sistema tambi√©n debe guardar r√°pidamente estos datos en la base de datos para usarlos m√°s tarde. <br><br>  <strong>Manteniendo una historia.</strong>  Un buen sistema de monitoreo debe almacenar el historial en la base de datos y proporcionar un acceso conveniente a las m√©tricas.  Se necesita una historia para usarla en informes, gr√°ficos, disparadores, umbrales y elementos de datos calculados para alertas. <br><br>  <strong>Claro historial.</strong>  A veces llega un d√≠a en que no necesita almacenar m√©tricas.  ¬øPor qu√© necesita los datos que se recopilaron hace 5 a√±os, un mes o dos: algunos nodos se eliminan, algunos hosts o m√©tricas ya no son necesarios, porque est√°n desactualizados y dejaron de recopilarse.  Un buen sistema de monitoreo debe almacenar datos hist√≥ricos y eliminarlos de vez en cuando para que la base de datos no crezca. <br><br><blockquote>  La eliminaci√≥n de datos obsoletos es un tema candente que tiene un gran impacto en el rendimiento de la base de datos. </blockquote><br><h2>  Almacenamiento en cach√© de Zabbix </h2><br>  En Zabbix, la primera y la segunda llamada se resuelven mediante el almacenamiento en cach√©.  RAM se utiliza para la recopilaci√≥n y el procesamiento de datos.  Para almacenamiento: historias en disparadores, gr√°ficos y elementos de datos calculados.  En el lado de la base de datos, hay un cierto almacenamiento en cach√© para las muestras principales, por ejemplo, gr√°ficos. <br><br>  El almacenamiento en cach√© en el lado del servidor Zabbix es: <br><br><ul><li>  ConfigurationCache; </li><li>  ValueCache; </li><li>  HistoryCache; </li><li>  TrendsCache. </li></ul><br>  Consideremos con m√°s detalle. <br><br><h3>  Cach√© de configuraci√≥n </h3><br>  Este es el cach√© principal en el que almacenamos m√©tricas, hosts, elementos de datos, disparadores: todo lo que se necesita para el preprocesamiento y la recopilaci√≥n de datos. <br><br><img src="https://habrastorage.org/webt/g0/zd/er/g0zderqgjgddgeq0frjdyvgj-q0.png"><br><br>  Todo esto se almacena en ConfigurationCache para no crear consultas innecesarias en la base de datos.  Despu√©s de que se inicia el servidor, actualizamos este cach√©, creamos y actualizamos peri√≥dicamente las configuraciones. <br><br><h3>  Recogida de datos </h3><br>  El esquema es bastante grande, pero lo principal son los <strong>ensambladores</strong> .  Estos son los diversos "sondeadores" - procesos de ensamblaje.  Son responsables de los diferentes tipos de ensamblaje: recopilan datos a trav√©s de SNMP, IPMI y los transfieren a Preprocesamiento. <br><br><img src="https://habrastorage.org/webt/z2/2r/jq/z22rjqgzyoam-61aadugsmowsbe.jpeg">  <em>Los coleccionistas est√°n rodeados en naranja.</em> <br><br>  Zabbix ha calculado elementos de datos de agregaci√≥n que son necesarios para agregar validaciones.  Si los tenemos, tomamos los datos directamente de ValueCache. <br><br><h3>  Historial de preprocesamiento </h3><br>  Todos los recopiladores usan ConfigurationCache para recibir trabajos.  Luego los pasan a Preprocesamiento. <br><br><img src="https://habrastorage.org/webt/f9/f-/yc/f9f-ycupjcyofnnz20injlmynty.png"><br><br>  El procesamiento previo utiliza ConfigurationCache para recibir los pasos de procesamiento previo.  Procesa estos datos de varias maneras. <br><br>  Despu√©s de procesar los datos usando PreProcessing, los guardamos en HistoryCache para procesarlos.  Esto finaliza la recopilaci√≥n de datos y pasamos al proceso principal en Zabbix: <strong>sincerizador de historia</strong> , ya que es una arquitectura monol√≠tica. <br><br>  <em>Nota: El preprocesamiento es una operaci√≥n bastante dif√≠cil.</em>  <em>Desde v 4.2, se ha enviado a proxy.</em>  <em>Si tiene un Zabbix muy grande con una gran cantidad de elementos de datos y una frecuencia de recopilaci√≥n, esto facilita enormemente el trabajo.</em> <br><br><h3>  Cach√© de ValueCache, historial y tendencias </h3><br><blockquote>  El sincerizador de historia es el proceso principal que procesa at√≥micamente cada elemento de datos, es decir, cada valor. </blockquote><br>  El sincronizador de historial toma valores de HistoryCache y verifica en Configuraci√≥n los activadores para los c√°lculos.  Si lo son, se calcula. <br><br>  El sincronizador de historial crea un evento, escalada para crear alertas, si la configuraci√≥n lo requiere, y registros.  Si hay desencadenantes para el procesamiento posterior, entonces recuerda este valor en ValueCache para no acceder a la tabla del historial.  Entonces ValueCache est√° lleno de datos que son necesarios para calcular los desencadenantes, los elementos calculados. <br><br>  History Syncer escribe todos los datos en la base de datos, y se escribe en el disco.  El proceso de procesamiento termina aqu√≠. <br><br><img src="https://habrastorage.org/webt/u7/v0/08/u7v0080wzx7v_fh8ej-fas7b1wg.jpeg"><br><br><h3>  Almacenamiento en cach√© de DB </h3><br>  En el lado de la base de datos, hay varios cach√©s cuando desea ver gr√°ficos o informes de eventos: <br><br><ul><li> <code>Innodb_buffer_pool</code> en el lado de MySQL; </li><li>  <code>shared_buffers</code> en el lado de PostgreSQL; </li><li>  <code>effective_cache_size</code> en el lado de Oracle; </li><li>  <code>shared_pool</code> en el lado de DB2. </li></ul><br>  Hay muchos otros cach√©s, pero estos son los principales para todas las bases de datos.  Le permiten mantener en la memoria los datos que a menudo se necesitan para las consultas.  Tienen sus propias tecnolog√≠as para esto. <br><br><h3>  El rendimiento de la base de datos es cr√≠tico </h3><br>  El servidor Zabbix recopila constantemente datos y los escribe.  Al reiniciar, tambi√©n lee del historial para completar ValueCache.  Los scripts y los informes utilizan la <strong>API de Zabbix</strong> , que se basa en la interfaz web.  La API de Zabbix se pone en contacto con la base de datos y recibe los datos necesarios para gr√°ficos, informes, listas de eventos y problemas recientes. <br><br><img src="https://habrastorage.org/webt/b5/48/rc/b548rcjuhprytj6zcpi_buqdr2c.png"><br><br>  Para visualizaci√≥n - <strong>Grafana</strong> .  Entre nuestros usuarios, esta es una soluci√≥n popular.  Puede enviar solicitudes directamente a trav√©s de la API de Zabbix y a la base de datos, y crea una cierta competitividad para recibir datos.  Por lo tanto, necesitamos un ajuste m√°s fino y mejor de la base de datos para que se corresponda con la salida r√°pida de resultados y pruebas. <br><br><h2>  Ama de llaves </h2><br>  El tercer desaf√≠o de rendimiento en Zabbix es limpiar la historia con Housekeeper.  Sigue todos los ajustes: los elementos de datos indican cu√°nto mantener la din√°mica de los cambios (tendencias) en d√≠as. <br><br>  Calculamos TrendsCache sobre la marcha.  Cuando llegan los datos, los agregamos en una hora y los escribimos en tablas para la din√°mica de los cambios de tendencia. <br><br>  Housekeeper inicia y elimina la informaci√≥n de la base de datos con las "selecciones" habituales.  Esto no siempre es efectivo, lo que puede entenderse a partir de los gr√°ficos de rendimiento de los procesos internos. <br><br><img src="https://habrastorage.org/webt/m0/3q/x_/m03qx_0sgbs_2bpjc_toewzmsbo.png"><br><br>  Un gr√°fico rojo indica que el sincronizador de Historial est√° constantemente ocupado.  El cuadro naranja anterior es Housekeeper, que se ejecuta constantemente.  Espera que la base de datos elimine todas las filas que especific√≥. <br><br>  ¬øCu√°ndo apagar Housekeeper?  Por ejemplo, hay un "ID de art√≠culo" y debe eliminar las √∫ltimas 5 mil l√≠neas en un momento determinado.  Por supuesto, esto sucede por √≠ndice.  Pero, por lo general, el conjunto de datos es muy grande y la base de datos a√∫n lee del disco y lo eleva al cach√©.  Esta es siempre una operaci√≥n muy costosa para la base de datos y, dependiendo del tama√±o de la base de datos, puede generar problemas de rendimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/c4/y7/w4c4y7m_lwigpvwzq4bfsftktw8.png" width="500"></div><br><br>  El ama de llaves es solo una desconexi√≥n.  En la interfaz web hay una configuraci√≥n en "Administraci√≥n general" para Housekeeper.  Deshabilite la limpieza interna para el historial de tendencias interno y ya no lo gestiona. <br><br>  El ama de llaves se apag√≥, los gr√°ficos se nivelaron: ¬øcu√°l podr√≠a ser el problema en este caso y qu√© puede ayudar a resolver el tercer desaf√≠o de rendimiento? <br><br><h2>  Particionamiento - particionamiento o particionamiento </h2><br>  Por lo general, la partici√≥n se configura de manera diferente en cada base de datos relacional que he enumerado.  Cada uno tiene su propia tecnolog√≠a, pero son similares, en general.  Crear una nueva partici√≥n a menudo conduce a ciertos problemas. <br><br>  Las particiones generalmente se configuran en funci√≥n de la "configuraci√≥n": la cantidad de datos que se crean en un d√≠a.  Como regla general, la partici√≥n se expone en un d√≠a, esto es un m√≠nimo.  Para conocer las tendencias de la nueva partici√≥n, durante 1 mes. <br><br>  Los valores pueden cambiar en el caso de una "configuraci√≥n" muy grande.  Si la "configuraci√≥n" peque√±a es de hasta 5,000 nvps (nuevos valores por segundo), el promedio es de 5,000 a 25,000, entonces el grande es superior a 25,000 nvps.  Estas son instalaciones grandes y muy grandes que requieren una configuraci√≥n cuidadosa de la base de datos. <br><br>  En instalaciones muy grandes, una ejecuci√≥n de un d√≠a puede no ser √≥ptima.  Vi en particiones MySQL de 40 GB o m√°s por d√≠a.  Esta es una cantidad muy grande de datos que puede generar problemas y debe reducirse. <br><br><h3>  ¬øQu√© da el particionamiento? </h3><br>  <strong>Tablas de partici√≥n</strong> .  A menudo, estos son archivos separados en el disco.  El plan de consulta selecciona de manera m√°s √≥ptima una partici√≥n.  La partici√≥n generalmente se usa en un rango; para Zabbix esto tambi√©n es cierto.  Usamos all√≠ "marca de tiempo" - tiempo desde el comienzo de la era.  Tenemos numeros ordinarios.  Establece el comienzo y el final del d√≠a: esta es una partici√≥n. <br><br>  <strong>Eliminaci√≥n r√°pida</strong> : <code>DELETE</code> .  Se selecciona un √∫nico archivo / subtabla, no una selecci√≥n de filas para eliminar. <br><br>  <strong>Acelera visiblemente la recuperaci√≥n de datos</strong> <code>SELECT</code> : utiliza una o m√°s particiones, no toda la tabla.  Si solicita datos hace dos d√≠as, se seleccionan de la base de datos m√°s r√°pido porque necesita cargarlos en la memoria cach√© y emitir solo un archivo, no una tabla grande. <br><br>  A menudo, muchas bases de datos tambi√©n aceleran las inserciones <code>INSERT</code> en la tabla secundaria. <br><br><h2>  Timescaledb </h2><br>  Para la versi√≥n 4.2, dirigimos nuestra atenci√≥n a TimescaleDB.  Esta es una extensi√≥n para PostgreSQL con una interfaz nativa.  La extensi√≥n funciona eficazmente con datos de series temporales, sin perder los beneficios de las bases de datos relacionales.  TimescaleDB tambi√©n se particiona autom√°ticamente. <br><br>  TimescaleDB tiene el concepto de <strong>hipertensi√≥n</strong> que creas.  Contiene <strong>trozos</strong> - particiones.  Los fragmentos son fragmentos controlados autom√°ticamente de un hipertable que no afectan a otros fragmentos.  Cada fragmento tiene su propio rango de tiempo. <br><br><img src="https://habrastorage.org/webt/0p/0g/mh/0p0gmhmshsg_htxuboh2w1xdmeo.jpeg"><br><br><h3>  TimescaleDB vs PostgreSQL </h3><br>  TimescaleDB funciona de manera realmente eficiente.  Los fabricantes de extensiones afirman que utilizan un algoritmo de procesamiento de solicitudes m√°s correcto, en particular, &lt;code&gt; insertos &lt;/code&gt;.  Cuando las dimensiones de la inserci√≥n del conjunto de datos crecen, el algoritmo mantiene un rendimiento constante. <br><br><img src="https://habrastorage.org/webt/_n/1v/vo/_n1vvoqc1hghllux5r_u7i_23q4.png"><br><br>  Despu√©s de 200 millones de filas, PostgreSQL generalmente comienza a caer mucho y pierde rendimiento hasta 0. TimescaleDB le permite insertar eficientemente "inserciones" para cualquier cantidad de datos. <br><br><h3>  Instalaci√≥n </h3><br>  Instalar TimescaleDB es bastante f√°cil para cualquier paquete.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> describe todo en detalle: depende de los paquetes oficiales de PostgreSQL.  TimescaleDB tambi√©n se puede compilar y compilar manualmente. <br><br>  Para la base de datos Zabbix, simplemente activamos la extensi√≥n: <br><br><pre> <code class="sql hljs">echo "<span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> timescaledb <span class="hljs-keyword"><span class="hljs-keyword">CASCADE</span></span>;" | sudo -u postgres psql zabbix</code> </pre> <br>  Activa la <code>extension</code> y la crea para la base de datos Zabbix.  El √∫ltimo paso es crear un hipertable. <br><br><h3>  Migraci√≥n de tablas de historial a TimescaleDB </h3><br>  Hay una funci√≥n especial <code>create_hypertable</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_unit'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_log'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_text'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_str'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'trends'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'trends_unit'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> db_extension=<span class="hljs-string"><span class="hljs-string">'timescaledb'</span></span>, hk_history_global=<span class="hljs-number"><span class="hljs-number">1</span></span>, hk_trends_global=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  La funci√≥n tiene tres par√°metros.  La primera es una <strong>tabla en la base</strong> de <strong>datos</strong> para la que necesita crear una hipertable.  El segundo es el <strong>campo</strong> mediante el cual se crea <code>chunk_time_interval</code> , el intervalo de los fragmentos de particiones que desea usar.  En mi caso, el intervalo es de un d√≠a: 86.400. <br><br>  El tercer par√°metro es <code><strong>migrate_data</strong></code> .  Si se establece en <code>true</code> , todos los datos actuales se transfieren a fragmentos previamente creados.  Yo mismo us√© <code>migrate_data</code> .  Ten√≠a alrededor de 1 TB, que tard√≥ m√°s de una hora.  Incluso en algunos casos, durante las pruebas, elimin√© los datos hist√≥ricos de los tipos de caracteres que eran opcionales para el almacenamiento, a fin de no transferirlos. <br><br>  El √∫ltimo paso es <code><strong>UPDATE</strong></code> : configuramos <code>db_extension</code> en <code>db_extension</code> para que la base de datos comprenda que existe esta extensi√≥n.  Zabbix lo activa y usa correctamente la sintaxis y las consultas que ya se encuentran en la base de datos, esas caracter√≠sticas que son necesarias para TimescaleDB. <br><br><h2>  Configuraci√≥n de hierro </h2><br>  Us√© dos servidores.  El primero es una <strong>m√°quina VMware</strong> .  Es lo suficientemente peque√±o: 20 procesadores Intel¬Æ Xeon¬Æ E5-2630 v 4 @ 2.20GHz, 16 GB de RAM y un SSD de 200 GB. <br><br>  Instal√© PostgreSQL 10.8 con Debian 10.8-1.pgdg90 + 1 y el sistema de archivos xfs.  Configur√© todo m√≠nimamente para usar esta base de datos en particular, menos lo que Zabbix usar√°. <br><br>  En la misma m√°quina hab√≠a un servidor Zabbix, PostgreSQL y <strong>agentes de carga</strong> .  Ten√≠a 50 agentes activos que usaban <code>LoadableModule</code> para generar r√°pidamente varios resultados: n√∫meros, cadenas.  Atasqu√© la base de datos con muchos datos. <br><br>  Inicialmente, la configuraci√≥n conten√≠a <strong>5.000 elementos de</strong> datos por host.  Casi todos los elementos conten√≠an un disparador, por lo que era similar a las instalaciones reales.  En algunos casos, hubo m√°s de un desencadenante.  Hubo <strong>3,000-7,000 disparadores por</strong> nodo de red. <br><br>  El intervalo para actualizar los elementos de datos es de <strong>4 a 7 segundos</strong> .  Regul√© la carga en s√≠ usando no solo 50 agentes, sino tambi√©n agregando m√°s.  Adem√°s, con la ayuda de elementos de datos, ajust√© din√°micamente la carga y reduje el intervalo de actualizaci√≥n a 4 s. <br><br><h3>  PostgreSQL  35,000 nvps </h3><br>  La primera ejecuci√≥n en este hardware la tuve en PostgreSQL puro: 35 mil valores por segundo.  Como puede ver, la inserci√≥n de datos toma fracciones de segundo: todo est√° bien y es r√°pido.  Lo √∫nico que un SSD de 200 GB se est√° llenando r√°pidamente. <br><br><img src="https://habrastorage.org/webt/wp/pk/vq/wppkvqe33kjs-udv8qc75jynloq.jpeg"><br><br>  Este es el panel de rendimiento est√°ndar del servidor Zabbix. <br><br><img src="https://habrastorage.org/webt/nu/h1/jl/nuh1jlhlz3cyoxyrc94cybshjos.png"><br><br>  El primer gr√°fico azul es el n√∫mero de valores por segundo.  El segundo gr√°fico de la derecha es la carga de los procesos de ensamblaje.  El tercero es cargar los procesos internos de ensamblaje: sincerizadores de historia y Housekeeper, que ha estado funcionando durante bastante tiempo aqu√≠. <br><br>  El cuarto gr√°fico muestra el uso de HistoryCache.  Este es un b√∫fer antes de insertarlo en la base de datos.  El quinto gr√°fico verde muestra el uso de ValueCache, es decir, cu√°ntos hits de ValueCache para los desencadenantes son varios miles de valores por segundo. <br><br><h3>  PostgreSQL  50,000 nvps </h3><br>  Luego aument√© la carga a 50 mil valores por segundo en el mismo hardware. <br><br><img src="https://habrastorage.org/webt/wj/47/u6/wj47u6j2fycdpnx55-mrrqrwcp4.jpeg"><br><br>  Al cargar desde Housekeeper, se registr√≥ una inserci√≥n de 10 mil valores durante 2-3 s. <br><br><img src="https://habrastorage.org/webt/fn/qo/go/fnqogopttou4hwlygqckfoieht0.png"><br>  <em>El ama de llaves ya est√° comenzando a interferir.</em> <br><br>  El tercer gr√°fico muestra que, en general, la carga de tramperos y sincronizadores de historia todav√≠a est√° en 60%.  En el cuarto gr√°fico, HistoryCache ya comienza a llenarse de manera bastante activa durante el trabajo de Housekeeper.  Est√° lleno al 20%, es de aproximadamente 0,5 GB. <br><br><h3>  PostgreSQL  80,000 nvps </h3><br>  Luego aument√© la carga a 80 mil valores por segundo.  Estos son aproximadamente 400 mil elementos de datos y 280 mil disparadores. <br><br><img src="https://habrastorage.org/webt/8q/zh/5z/8qzh5zsbwvouradg7j-qxeksqfi.jpeg"><br>  <em>La inserci√≥n para cargar treinta sincronizadores de historia ya es bastante alta.</em> <br><br>  Tambi√©n aument√© varios par√°metros: sincerizadores de historia, cach√©s. <br><br><img src="https://habrastorage.org/webt/xs/3m/ia/xs3miafccbymaddfyzzj2l4e494.png"><br><br>  En mi hardware, la carga de sincronizadores de historia aument√≥ al m√°ximo.  HistoryCache se llen√≥ r√°pidamente de datos: los datos para el procesamiento acumulados en el b√∫fer. <br><br>  Todo este tiempo observ√© c√≥mo se usaban el procesador, la RAM y otros par√°metros del sistema, y ‚Äã‚Äãdescubr√≠ que la utilizaci√≥n del disco estaba maximizada. <br><br><img src="https://habrastorage.org/webt/zy/el/im/zyelimg6_immdsthjxburb1gjmw.jpeg"><br><br>  Saqu√© el <strong>m√°ximo provecho del disco</strong> en este hardware y en esta m√°quina virtual.  A esta intensidad, PostgreSQL comenz√≥ a volcar datos de manera bastante activa, y el disco ya no tuvo tiempo de trabajar en escritura y lectura. <br><br><h3>  Segundo servidor </h3><br>  Tom√© otro servidor que ya ten√≠a 48 procesadores y 128 GB de RAM.  Aj√∫stelo: configure 60 sincronizadores de historia y logre un rendimiento aceptable. <br><br><img src="https://habrastorage.org/webt/hl/ae/ig/hlaeigh1dtxphardj6hkwmtas8w.png"><br><br>  De hecho, esto ya es un l√≠mite de rendimiento en el que hay que hacer algo. <br><br><h3>  TimescaleDB.  80,000 nvps </h3><br>  Mi tarea principal es probar las capacidades de TimescaleDB desde la carga de Zabbix.  80 mil valores por segundo es mucho, la frecuencia de recopilaci√≥n de m√©tricas (a excepci√≥n de Yandex, por supuesto) y una "configuraci√≥n" bastante grande. <br><br><img src="https://habrastorage.org/webt/c-/45/yc/c-45yc-ctmrtj7o5td-ajwrtpdm.png"><br><br>  Hay un error en cada gr√°fico; esto es solo la migraci√≥n de datos.  Despu√©s de fallas en el servidor Zabbix, el perfil de inicio del sincronizador de historia ha cambiado mucho, ha ca√≠do tres veces. <br><br><blockquote>  TimescaleDB le permite insertar datos casi 3 veces m√°s r√°pido y usar menos HistoryCache. </blockquote><br>  En consecuencia, los datos se le entregar√°n de manera oportuna. <br><br><h3>  TimescaleDB.  120,000 nvps </h3><br>  Luego aument√© el n√∫mero de elementos de datos a 500 mil. La tarea principal era verificar las capacidades de TimescaleDB: obtuve el valor calculado de 125 mil valores por segundo. <br><br><img src="https://habrastorage.org/webt/hi/hd/ce/hihdcemwxqcqfxnv3n5-4ypmvic.png"><br><br>  Esta es una "configuraci√≥n" funcional que puede funcionar durante mucho tiempo.  Pero como mi disco ten√≠a solo 1,5 TB, lo llen√© en un par de d√≠as. <br><br><img src="https://habrastorage.org/webt/vk/51/wz/vk51wzryy45k4sycilxbcj-pjcq.png"><br><br>  Lo m√°s importante, al mismo tiempo, se crearon nuevas particiones TimescaleDB. <br><br>  Para el rendimiento, esto es completamente invisible.  Cuando se crean particiones en MySQL, por ejemplo, todo es diferente.  Por lo general, esto sucede de noche, porque bloquea la inserci√≥n general, trabaja con tablas y puede crear degradaci√≥n del servicio.  En el caso de TimescaleDB esto no es. <br><br>  Por ejemplo, mostrar√© un gr√°fico del conjunto en la comunidad.  TimescaleDB se incluye en la imagen, debido a esto, la carga sobre el uso de io.weight en el procesador ha disminuido.  El uso de elementos de procesos internos tambi√©n ha disminuido.  Y esta es una m√°quina virtual normal en discos de panqueque ordinarios, no una SSD. <br><br><img src="https://habrastorage.org/webt/e6/bm/a-/e6bma-otl8o5mcrt9z8wkrsq5du.jpeg"><br><br><h2>  Conclusiones </h2><br>  <strong>TimescaleDB es una buena soluci√≥n para peque√±as "configuraciones"</strong> que dependen del rendimiento del disco.  Le permitir√° continuar trabajando bien hasta que la base de datos se migre a planchar m√°s r√°pido. <br><br>  TimescaleDB es f√°cil de configurar, proporciona un aumento de rendimiento, funciona bien con Zabbix y <strong>tiene ventajas sobre PostgreSQL</strong> . <br><br>  Si usa PostgreSQL y no planea cambiarlo, le recomiendo <strong>usar PostgreSQL con la extensi√≥n TimescaleDB junto con Zabbix</strong> .  Esta soluci√≥n funciona de manera efectiva para la "configuraci√≥n" media. <br><br><blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Decimos</a> "alto rendimiento", nos referimos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> .  A la espera de familiarizarse con las tecnolog√≠as y pr√°cticas que permiten que los servicios sirvan a millones de usuarios, muy brevemente.  Ya hemos compilado una lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes</a> para el 7 y 8 de noviembre, pero todav√≠a se pueden ofrecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mitaps</a> . <br><br>  Suscr√≠base a nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">telegrama</a> , en el que revelaremos los chips de la pr√≥xima conferencia, y aprenda c√≥mo aprovecharla al m√°ximo. </p></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470902/">https://habr.com/ru/post/470902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470882/index.html">¬øPor qu√© atrapaste mi mouse o un juego de mesa como modelo de interacci√≥n social?</a></li>
<li><a href="../470884/index.html">Escribir y leer datos en la cadena de bloques de Bitcoin</a></li>
<li><a href="../470888/index.html">La legislaci√≥n rusa e internacional en el √°mbito de la protecci√≥n de datos personales.</a></li>
<li><a href="../470892/index.html">Implementaci√≥n simple de CAM peque√±o en FPGA</a></li>
<li><a href="../470894/index.html">Bala</a></li>
<li><a href="../470904/index.html">El camino m√°s suave y peludo en aprendizaje autom√°tico y redes neuronales profundas</a></li>
<li><a href="../470908/index.html">Por primera vez en el mundo con la ayuda de tecnolog√≠as aditivas, se obtuvo un conjunto de motor de avi√≥n de gran tama√±o</a></li>
<li><a href="../470910/index.html">¬øQu√© se puede hacer con anotaciones de contratos de microservicios?</a></li>
<li><a href="../470916/index.html">El punto de control electr√≥nico "m√°s barato" en Rusia controlado desde un tel√©fono inteligente</a></li>
<li><a href="../470918/index.html">F # 9: Opci√≥n de tipo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>