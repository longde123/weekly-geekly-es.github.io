<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏽 👩🏼‍🔧 👩‍👦 BTRFS最小 ✊🏼 🤜 🧝🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="美好的一天，Khabravchane。 我在Veeam Software工作，并且是我们Linux备份解决方案的开发人员之一。 就职业而言，我碰巧遇到了BTRFS。 最近，它已从“不适合”状态转变为“稳定”状态。 当网络上的第一个用户讨论问题区域和稳定性问题时，Veeam的我们用一根魔杖戳了一下，并...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS最小</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/">美好的一天，Khabravchane。 我在Veeam Software工作，并且是我们Linux备份解决方案的开发人员之一。 就职业而言，我碰巧遇到了BTRFS。 最近，它已从“不适合”状态转变为“稳定”状态。 当网络上的第一个用户讨论问题区域和稳定性问题时，Veeam的我们用一根魔杖戳了一下，并试图对其进行备份。 坦率地说，结果不是很多-它太不一样了，不像传统文件系统那样。 在学习如何使用它之前，我必须研究许多方面并收集大量耙。 在学习过程中，BTRFS很好地打动了我，并没有给我留下什么深刻的印象。 我敢肯定，她不会离开Linux世界的任何IT专家：有些人会吐口水，有些人会赞扬。 <br><br> 如果您听说过此文件系统，但不知道为什么使用它，对详细信息感兴趣，或者正在寻找从哪里开始了解它，我邀请您来关注。 <br><a name="habracut"></a><br><h1> 引言 </h1><br>  BTRFS（B树文件系统）-基于写时复制（CoW）技术的类Unix操作系统的文件系统，旨在提供易于扩展的文件系统，高度的数据可靠性和安全性，配置灵活性以及易于管理的同时维护同时高速。 至少那是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wiki主页面</a>所说的。 <br><br> 为了遵守这些手续，我们列出了btrfs的主要功能： <br><br><ul><li> 最大文件大小2 ^ 64字节 <br></li><li> 动态索引表 <br></li><li> 重复数据删除 <br></li><li> 有效的文件存储，无论大小，都非常大 <br></li><li> 创建子画面和快照 <br></li><li> 子卷配额 <br></li><li> 数据和元数据的校验和 <br></li><li> 能够将多个驱动器组合到一个文件系统中 <br></li><li> 在文件系统级别创建RAID配置 <br></li><li> 资料压缩 <br></li><li> 动态碎片整理数据 <br></li></ul><br> 我想立即警告您BTRFS正在积极开发中，某些观点可能因版本而异。 链接-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//btrfs.wiki.kernel.org/index.php/Changelog，</a>您可以了解何时添加，更改或修复了哪些功能。 <br><br> 是的，BTRFS是一个年轻而现代的文件系统，它可以解决各种各样的任务，但并非没有缺点： <br><br><ul><li> 它的积极发展导致第三方实用程序在使用它时可以依靠的所有关键点发生了变化。 <br></li><li> 尽管开发人员保证了BTRFS的稳定性，但用户经常会遇到可能导致数据丢失的问题。 通常，它们本质上是“漂浮的”，因此尚未对其进行研究和纠正。 <br></li><li> 易碎。 <br></li><li> 很少甚至有时过时的文档。 <br></li></ul><br> 整个页面专门讨论不同版本内核上的文件系统问题-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//btrfs.wiki.kernel.org/index.php/Gotchas</a> 。 我强烈建议您去那里看看-事实证明，这很有趣且不明显。 <br><br><h1>  BTRFS结构 </h1><br> 简化的BTRFS设备可以分为以下级别： <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br> 块设备位于最低级别，代表一个或多个单独的物理地址空间（与块设备本身相同的“物理”空间，但这些已经是详细信息）。 通过特殊的结构，分配的物理内存块被组合到单个虚拟地址空间中。 <br><br> 具有用户数据（范围）的元数据结构和块已经在逻辑级别上解决了。 结果，顺序位于逻辑级别的数据可以物理地驻留在不同的块设备上。 <br><br> 元数据结构可以分为多个级别。 当然，我不会对它们进行分类-它们很多，而这样的低级详细信息是另一篇文章的主题。 在这里重要的是，层次结构中的某些结构将比其他结构更高级，并且在最顶层将有一个子卷结构。 <br><br> 子卷是一种入口点，或者说是文件系统的根元素。 它们形成了一个单独的数据表示层，封装了较低层的工作，以通常的形式显示用户数据：目录和文件。 此外，亚狼是BTRFS上CoW机制的关键要素。 两个子卷中的相同文件在较低级别上可能是相同的数据集。 <br><br> 最后一层是数据层。 如用户所见。 这些是位于子卷中的文件和目录。 <br><br> 但是足够的理论。 现在该继续练习了！ <br><br><h1>  Btrfs-编 </h1><br> 这是用于管理BTRFS的标准实用程序集。 根据分发程序包的不同，存储库中的这些实用程序可能具有不同的名称： <b>btrfsprogs</b> ， <b>btrfs-progs</b> ， <b>btrfs-tools</b>等。 如果您的存储库没有类似的内容，则可以随时手动对其进行编译，而源代码也就不远了-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/kdave/btrfs-progs</a> 。 <br> 此软件包中最重要的实用程序是<b>btrfs</b>和<b>mkfs.btrfs</b> 。 从第二个开始，我认为一切都非常清楚-必须在块设备上创建BTRFS。 首先， <b>btrfs</b>是允许您执行其余操作的主要实用程序。 一种“瑞士刀”。 <br><br> 在本文中，我使用的是v4.15.1版本。 该实用程序的开发非常活跃，各个版本之间存在明显的差异。 因此，如果您没有必要的命令，请检查<b>btrfs</b>实用程序的版本，它可能已经过时。 <br><br> 同样，很可能在软件包中找到了<b>btrfsck</b>和<b>btrfstune</b>实用程序。 <br><br><ul><li> 它们中的第一个用于检查文件系统中的错误和后续更正，但是，我不建议使用它-它处于<i>已弃用</i>状态，其功能已移至<b>btrfs check</b>命令。 </li><li> 第二个允许您对btrfs执行一些有用的操作，例如，更改文件系统的唯一标识符（FS UUID），或启用文件系统的某些功能。 </li></ul><br> 除了上面列出的实用程序外，程序包中还有其他几个实用程序，但是它们主要是调试btrfs所必需的，对本文没有帮助。 <br><br><h1> 在BTRFS中格式化磁盘 </h1><br> 实际上，一切都比较简单。 让我们从一个驱动器开始。 <br> 在btrfs中格式化单个磁盘的操作与通常的命令相同： <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br> 作为响应，该实用程序会将已创建文件系统的参数输出到控制台： <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br> 让我们看一下呈现的参数。 <br><br><ul><li>  <b>标签</b> -标签或文件系统名称。 它由<code>-L</code>开关指定，并且是可选参数。 </li><li>  <b>UUID</b>是使btrfs内核彼此区分实例的唯一标识符。 </li><li>  <b>节点大小</b> -存储元数据的B树元素的大小。 可以使用<code>-n | --nodesize</code>设置<code>-n | --nodesize</code>  <code>-n | --nodesize</code> ，并且必须是<b>Sector size</b>的大小的倍数。 节点的小尺寸导致B树的高度增加（节点数量增加），结果，导致阻塞单个节点的竞争减少。 另一方面，节点的小尺寸使文件系统实例更易于碎片化。 另一方面，大型节点有助于更好地在磁盘上打包元数据，从而减少了碎片。 <br> 缺点是增加了用于通过多个线程更新同一节点的数据访问时间。 在低于3.11的内核上，默认情况下，节点的大小为16384字节或OS内存页的大小（这两个值中的较大者）。 </li><li>  <b>扇区大小</b> -在物理级别分配和释放的空间的倍数的空间量。 除非使用<code>-s</code>另行指定，否则它等于操作系统虚拟内存的页面大小。 </li><li>  <b>文件系统大小</b> -文件系统的总容量（数据加元数据）。 用<code>-b</code>开关手动设置。 默认情况下，将占用块设备的整个卷。 </li><li>  <b>不兼容的功能</b> -创建的btrfs中包含的功能列表，这些功能破坏了与较早内核版本的向后兼容性。 如果需要向后兼容，则可以禁用： <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br> 顺便说一句，您可以通过以下调用检查当前内核支持的功能： <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>设备数和设备数</b> -创建的btrfs实例中涉及多少个块设备，以及所有设备的列表。 </li><li> 我们还应该讨论“ <b>块组配置文件”</b>参数。 它指示三种数据类型（数据，元数据和系统）中每种数据的适用记录配置文件。 回到btrfs的广义结构，我们可以说： <br><br><ul><li> 数据是用户数据； </li><li> 元数据是子卷层以及元数据和范围层的组合； </li><li> 系统是用于将物理内存的地址空间映射到逻辑地址的连续空间的结构。 </li></ul><br> 记录配置文件是在物理级别存储数据的一种方式： <br><br><ul><li> 单-数据存储在一个副本中； </li><li>  DUP-在一种介质上复制数据； </li><li>  RAIDX是RAID0，RAID1，RAID10，RAID5和RAID6的配置之一。 </li></ul><br></li></ul><br> 标记一个块设备时，默认情况下，btrfs将对元数据和系统数据应用复制，并且用户数据将以单个副本形式保留在介质上。 一次在多个磁盘上创建btrfs，默认情况下会将“ RAID0”配置文件应用于用户数据，并将“ RAID1”应用于元数据。 <br> 使用两个键控制该组参数： <code>-d</code>表示数据， <code>-m</code>表示元数据和系统数据。 <br><br> 但是有一点细微差别……SSD的情况有所不同。 事实是，如果我们要标记SSD驱动器（或闪存驱动器），则默认情况下文件系统不会复制元数据。  SSD可以扩展重复数据删除功能以延长存储元件的寿命。 即 具有两个逻辑副本的数据，实际上只有一个副本会记录在介质上。 结果，当一个内存段出现故障时，数据的“两个副本”将被损坏。 此外，通过两次写入数据，可以更快地消耗SSD资源。 <br><br> 为了确定媒体的类型，btrfs检查文件<i>/ sys / block / DEV / queue / rotation的内容</i> ，其中“ DEV”是要检查的块设备的名称。 <br> 当然，即使在使用SSD的情况下，也可以强制使用存储配置文件。 <br><br> 要在多个设备上创建btrfs实例，只需用空格指定它们： <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br> 或带有配置文件： <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br> 应该注意的是，即使使用完全镜像，媒体也不必具有相同的大小。 但是，只要最小的驱动器上没有足够的空间来分配内存，文件系统将显示一条消息，指示没有可用空间，尽管实际上其他介质上可能仍有一些可用空间。 <br><br><h1> 安装方式 </h1><br> 新创建的btrfs的第一次安装与其他文件系统没有什么不同： <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br> 如果文件系统位于多个磁盘上，则只需指定其中的任何一个即可安装。 <br><br> 通常，安装btrfs总是涉及安装其一个或多个子卷。 如果未指定mount命令，则应该安装哪个子卷，然后btrfs将从特殊记录中读取该子卷的ID，默认情况下必须安装该子卷的ID。 以后可以使用<code>btrfs set-default</code>命令更改该条目，但是当您首次将其安装在btrfs上时，只有一个子卷-根卷。 默认情况下已指定他进行安装。 <br><br>  btrfs上的根子世界始终存在。 它与文件系统一起出现，以后将不会进行任何更改。 <br><br> 除了默认卷，有两种方法可以挂载任何子卷： <br> 从根子卷btrfs指定路径： <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br> 要么指定子卷ID： <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br> 如前所述，默认情况下将btrfs子卷之一指定为已安装。 通过执行以下操作找出可能的方法： <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br> 要安装默认的子底座，可以使用以下命令： <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br> 在这种情况下，子卷的路径仅用于指示该命令适用的特定btrfs实例。 顺便说一句，这不必是一个子世界；任何目录的路径也都适用。 <br><br>  <code>mount</code>命令接受大量选项来控制btrfs的功能：碎片整理，缓存刷新，压缩，cow，日志记录，平衡，ssd支持以及btrfs的许多其他功能。 我不会在本文的框架中考虑它们，因为 它们是微调文件系统所必需的，在大多数情况下，没有它们就可以做到。 <br><br><h1> 子体积为 </h1><br> 子卷是btrfs的关键元素，它执行各种功能： <br><br><ul><li> 存储用户数据和其他子卷， <br></li><li> 提供对数据的访问（安装）， <br></li><li>  CoW机制 <br></li><li> 创建快照。 <br></li></ul><br> 初步看，子卷是普通目录。 您可以重命名/移动它们，查看其内容，在其中放置和修改文件。 不需要特殊的实用程序。 <br><br> 使用已安装的btrfs使用特殊命令执行创建和删除子卷的操作： <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br> 我注意到，如果尝试使用文件管理器或<b>rm</b>实用程序删除子卷，则该操作将以<i>操作不允许</i>错误（操作不允许）结束。 <br><br>  <b>UPD：</b>从内核版本4.18.0开始，可以使用<b>rm</b>实用程序或文件管理器工具删除子齐射。 显然，这是一个错误，而不是功能。 感谢Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">habravchanin</a>的澄清。 <br><br> 创建子卷后，您可以看到其属性： <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br> 让我们看一下子狼的主要属性： <br><br><ul><li>  <b>名称</b> -子卷的名称 <br></li><li>  <b>UUID</b>是通用的唯一标识符，主要用于确定低音炮与快照的关系， <br></li><li>  <b>父</b> UUID-从其导出当前子卷的子卷祖先的标识符， <br></li><li>  <b>接收</b>到的UUID-通过<i>btrfs send发送</i>的子卷祖先的标识符， <br></li><li>  <b>子卷ID-</b>放置在B树中的唯一标识符， <br></li><li>  <b>生成</b> -子卷元数据最后一次更新时的交易号， <br></li><li>  <b>创建时生成</b> - <b>生成</b>子卷时的交易号， <br></li><li>  <b>父级ID-</b>嵌入当前卷的子卷的标识符， <br></li><li>  <b>顶级ID</b>与父ID完全相同， <br></li><li>  <b>标志</b> -标志（实际上只有1个标志是<i>readonly</i> ）， <br></li><li>  <b>快照</b> -从此子卷中获取的快照列表。 <br></li></ul><br> 子卷还有一个参数-这是它从根元素btrfs开始的路径。 列出子卷时显示路径： <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br> 但是这里的一切都很简单明了-带来命令的输出甚至都没有意义。 <br> 与<code>get-default</code>和<code>set-default</code>命令一样，您可以在此处指定任何子卷的路径，其结果不会改变。 此路径用于找到根子对象btrfs。 之后，将读取整个地下树。 <br><br> 例如，如果尝试使用<b>cp</b>实用程序复制子卷，则复制操作将成功，但是结果不是将创建子卷，而是创建常规目录。 但是，btrfs提供了一种更灵活的工具来创建此类副本-快照。 <br><br><h1> 快照为 </h1><br> 快照也是一个子世界，仅具有高级属性。 <br><br> 它们的主要区别在于快照具有记录是从哪个子窝产生的。 这些是<b>父UUID</b>和已<b>接收UUID</b>字段。 在低音炮中，也存在这些字段，但它们始终为空。 因此，实际上，快照和子卷是相同的。 <br> 创建时，可以使用<code>-r</code>开关阻止快照进行更改。 <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br> 在这种情况下，保证文件保持在创建快照时的状态。 <br><br> 只读标志也可以手动控制，这适用于任何子卷： <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br> 现在，如果我们查看快照的属性，将看到已填充的“ <b>父UUID”</b>字段： <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br> 快照操作的一个重要特征是它是非递归的。 将在快照中创建空目录，而不是嵌套子卷。 <br><br> 让我们转到下面的示例。 <br><br> 在文件系统上，有一个低音炮“ sub0”，其中有一个低音炮<i>subA</i>和一个目录<i>dirB</i> 。 在每个文件的内部分别是<i>fileA</i>和<i>fileB</i> 。 <br><br> 删除快照： <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  <i>创建</i>的<i>snap0</i>快照将继承其父级的所有文件和目录，但是subA <i>低音炮</i>将不会出现在快照中。 相反，快照中只会出现一个空目录，即  subA <i>子卷</i>的内容将不会被继承。 <br><br> 一方面，这很好-我们从特定的子卷中删除了快照，而所有嵌套的卷都不是我们感兴趣的。 另一方面，如果需要递归快照，则btrfs不能解决此问题。 我们将不得不寻找工作机会。 <br><br> 第一种解决方法是基于以下事实：删除快照时没有只读标志，这使您可以非常简单地解决这种情况： <br><br><ul><li> 从快照中删除多余的目录 <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li> 从嵌套子卷中删除快照 <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br> 如果使用只读标志删除了快照，则上述选项将不起作用，因为 在<i>snap0中，</i>您既不能删除目录也不能放置快照。 只有一种选择-将快照放置在snap0 <i>重低音扬声器</i>附近： <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br> 然后在<i>snap0</i>快照中挂载<i>snapA</i> ，该目录已经存在： <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br> 无论如何，重要的是要了解递归快照都将在不同的时间，不同的操作中拍摄。 不能说从几个子卷中原子删除快照。 <br><br><h1> 写时复制 </h1><br> 关于子卷和CoW方法的一些知识。 想象一下，文件系统上存在一个子卷，并且其中有一个文件（采用理想情况-该文件没有碎片）。 接下来，从超人那里删除快照。 <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br> 一个新的子卷（快照）将出现在文件系统上，其内容与原始子卷完全相同。 创建快照的过程几乎是瞬时的-文件本身的数据不会被复制。 而是创建了其他元数据，快照和父子卷一起成为文件的所有者。 实际上，磁盘上只有一个文件，但是现在它既属于子卷又属于快照。 <br> 如果现在更改子卷中的文件，则更改将不会影响快照中的文件。 如果在创建快照时未设置只读标志，则也可以修改快照中的文件。 <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br> 从技术上讲，更改文件时，仅记录这些更改。 因此，源文件将存储在磁盘上，再加上一些可区别原始文件和修改后文件的增量。 如果删除其中一个子卷（第二个我指的是快照），则将从磁盘上删除不再被任何人使用的多余数据，并且仅文件的当前版本将保留在磁盘上（从其余子卷的角度来看）。 <br><br>  <i>简短说明</i> ：卸下后，低音炮将立即从用户的眼中消失，实用程序将控制权返回给终端，但是，磁盘上的数据将被后台进程清理一段时间。 也就是说，与删除常规目录不同，无需等待删除操作的实际完成。 如果需要与此过程同步并等待它完成，则可以在调用<b>delete</b>时指定<code>--commit-after</code>开关。 用<code>-d</code>开关<b>调用</b>的<b>btrfs子卷列表</b>命令显示用户已删除的子卷列表，这些子卷当前正在从磁盘中删除。 <br><br> 此外，btrfs允许您在不使用快照的情况下在文件系统上克隆文件。 这是通过使用<code>--reflink</code>进行常规复制来完成的： <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  <code>reflink=always</code>键告诉文件系统我们要在复制时使用CoW机制。 复制后，可以相互独立地更改文件，因此我们得到的行为与创建快照后相同。 那么，为什么我们需要子集呢？ <br><br>  btrfs上的子类别对整个数据集起着高级控制工具的作用：首先，它是从子卷的所有数据中删除原子快照（对于--reflink原子性仅在文件级别）；其次，可以查看其继承者，或快速将数据集“回滚”到早期版本，等等。 <br> 因此，btrfs提供了使用子卷作为管理这些状态的高级手段，在所需时间点捕获文件状态的能力。 <br><br><h1> 子卷恢复 </h1><br> 在广阔的领域中，经常会出现一个问题：“我有一个低音炮，我有一个快照，如何进行反转？” 此方法不适用于btrfs，因为 没有机会“退缩”。 取而代之的是，btrfs提供了一种用快照替换潜伏者的策略。 确实，为什么要还原某些内容，如果快照本身就是我们想要通过还原获得的对象。 <br><br> 想象一下这种情况：在btrfs上有一个子卷，数据库文件位于其中（很好，或其他重要数据）。 会定期从此子卷中删除快照，并且有时需要回滚数据。 在这种情况下，我们只是摆脱了子狼，而是开始使用从其中获取的快照，或者-如果我们也不想破坏该数据，则从快照中删除另一个快照。 如果未安装原始子世界并将其用作普通目录，则必须将其删除或移动/重命名，并应在其中放置快照。 <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br> 在控制台中，它可能看起来像这样： <br><br><ul><li> 重命名潜行者 <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li> 将他的快照代替子卷 <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br> 如果通过安装点安装并使用了子卷，则足以卸载子卷并在其位置安装快照。 <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li> 卸下低音炮 <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li> 您可以创建快照的快照，以免破坏最后幸存的数据： <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li> 挂载快照： <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br> 为了完整起见，我将再试一次。 发生更改的子卷是<i>主</i>分支。 <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br> 创建快照时，磁盘上文件的状态是固定的。 从现在开始，快照是<i>主</i>分支的早午餐。 对<i>main的</i>所有进一步更改都不会以任何方式影响快照。 回滚到快照意味着停止使用<i>主</i>分支并完全切换到早午餐。  <i>主</i>分支可以根据需要删除。 因此，btrfs实际上是一个版本控制系统，但是没有合并分支的能力。 <br><br><h1> 文件系统树 </h1><br> 与使用btrfs相关的明显点之一是如何将系统数据拆分为子卷。 当然，没有解决此问题的“正确”方法。 但是有3种方法来组织子体积的结构：嵌套和混合的平面结构。 <br><br> 平面结构表示将子卷放置在根子卷的平面列表中。 例如，您可以选择文件系统的根目录（我们称其为<i>root</i> ），用户目录<i>home</i> ，站点为<i>/ var / www</i>的目录以及例如位于<i>/ var / database中的数据库</i>作为单独的子目录。 <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br> 为了方便起见，可以将某些子卷放在目录中，例如，在<i>var / www</i>子卷的情况下。 <br><br> 使用这种方法，必须安装所有子卷。  <i>根</i>子目录必须具有挂载点/，并且其中包含目录<i>home</i>和<i>var</i> 。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装后</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的根</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/家庭</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须安装sabvolyum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在/ var / WWW</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电子- sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无功/网络</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分别。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，btrfs-subvolume树可以在OS的虚拟文件系统中任意显示，并且已经足够了。</font></font><br><br> 优点： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户只能看到已安装的子卷， </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更换低音炮很容易（卸下一个，再安装另一个）， </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 易于卸下低音炮。 </font></font><br></li></ul><br> 缺点： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 容易混淆安装位置， </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对于每个子卷，fstab中都应该有一个条目，如果快照有“回滚”，则fstab中的相应条目也必须更新。 </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子卷的嵌套结构建议使用子卷而不是某些目录的简单用法。</font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，除了根子卷外，不需要安装其他任何东西。</font></font><br><br> 优点： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 所有子体积都是可见的，结构易于感知， </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您无需再次挂载任何东西，一切就像使用“常规”文件系统一样。 </font></font><br></li></ul><br> 缺点： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 所有子体积都是可见的，也许有些想向用户隐藏， </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 很难移除/替换亚狼（其原因是嵌套的亚狼）。 </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，第三种方法是混合方法。</font><font style="vertical-align: inherit;">它涉及前两者的组合，以最大限度地发挥两者的优势。</font><font style="vertical-align: inherit;">但是，这种特殊方法可能会导致复杂，难以更改的，混乱的结构以及fstab中的大量条目。</font><font style="vertical-align: inherit;">这完全取决于</font><font style="vertical-align: inherit;">系统管理员</font><font style="vertical-align: inherit;">的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清醒</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程度。</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加/删除磁盘，余额 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btrfs具有出色的功能-能够在文件系统运行期间直接“添加”热块设备： </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 或删除： </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，在一个添加/删除调用中，您可以指定多个磁盘。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，指定的路径是将对该命令应用到的btrfs的任何子卷的路径。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们检查一下受btrfs控制的块设备以及哪些块设备：</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段中的</font><i><font style="vertical-align: inherit;">0.00B</font></i><font style="vertical-align: inherit;">告诉我们添加的磁盘为空。</font><font style="vertical-align: inherit;">要根据记录配置文件填充数据，您必须平衡：</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">根据所选的记录配置文件在磁盘上重新分配数据。例如，在RAID1的情况下，余额将导致从原始设备克隆数据，在RAID0的情况下，这将导致数据在两个磁盘之间的分配更加均匀。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为平衡的结果，如果在此之前磁盘上有空隙，那么磁盘上的数据将以更密集的方式写入，即进行碎片整理。但是，重要的是要了解这并非完全是碎片整理。在这种情况下，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">不查看逻辑内容，而仅对数据块进行操作。她没有注意任何文件都散布在磁盘上的事实。相反，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天平</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数据块从一个地方转移到另一个地方。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零碎的文件将保持零碎。但是！数据块级别的碎片仍然会减少，可以使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为避免混淆，我们这样说：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">减少了数据块级别的碎片，但不影响文件碎片。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">还提供了更改录音配置文件的功能。例如，在磁盘上使用了DUP配置文件，添加磁盘后，他们决定制作完整的RAID1。为此，请使用过滤器</font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">选项</font><font style="vertical-align: inherit;">，</font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分别为数据和元数据设置新的记录配置文件。</font><font style="vertical-align: inherit;">还有-sconvert选项，该选项旨在更改系统数据写入配置文件，但是，您还必须添加-f（--force）开关以强制执行操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，过滤器的主要目的是为平衡操作设置规则：要处理的块和不涉及的块。</font><font style="vertical-align: inherit;">因此，例如，您可以只影响以特定记录配置文件记录的块（过滤器配置文件），或者以一定百分比占用的块（使用过滤器），或者仅影响与特定磁盘相关的块组（分配过滤器）等。</font><font style="vertical-align: inherit;">顺便说一句，它们仍然可以合并。</font><font style="vertical-align: inherit;">通常，过滤器的功能非常广泛，并且对于进行数据的选择性平衡而言是主要必需的。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 碎片化 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，由于btrfs的体系结构，它极易受到碎片等现象的影响。</font><font style="vertical-align: inherit;">事实是，数据总是被写入磁盘上的新位置。</font><font style="vertical-align: inherit;">即使您读取文件，也不对数据进行任何处理并将其写回到同一文件中，数据也将到达磁盘上的新区域。</font><font style="vertical-align: inherit;">如果仅部分更新文件中的数据，则会发生相同的情况-更改将被写入磁盘上的新区域。</font><font style="vertical-align: inherit;">因此，频繁地频繁更改片段文件，通常会增加片段在多个磁盘上的“分散”。</font><font style="vertical-align: inherit;">这导致CPU负载增加和不必要的内存消耗。</font><font style="vertical-align: inherit;">最零散的是数据库和虚拟机映像。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用</font><b><font style="vertical-align: inherit;">filefrag</font></b><font style="vertical-align: inherit;">实用程序评估文件碎片</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （不包含在btrfs-progs中）。 </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它显示了用于存储文件的盘区数。</font><font style="vertical-align: inherit;">简而言之-涉及的范围越少，文件的碎片就越少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法可以防止btrfs上出现碎片：碎片整理和flag </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">碎片整理可以应用于单个文件或子卷/目录（包括递归）。</font><font style="vertical-align: inherit;">命令如下：</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我必须说，这个团队并不总是能带来预期的结果。</font><font style="vertical-align: inherit;">碎片整理后的较小碎片文件（10-20个范围）可以分成更多部分。</font><font style="vertical-align: inherit;">此外，在某些版本的内核上对btrfs进行碎片整理会破坏文件的重复数据删除，使其成为真实的物理副本。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理级别的快照将成为完整副本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决碎片的第二种方法是使用file属性</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该属性</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能设置为新文件或空文件。</font><font style="vertical-align: inherit;">它禁用了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写时复制</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制</font><font style="vertical-align: inherit;">，因此btrfs在更新文件内容时将始终在固定磁盘区域上工作，并在现有文件上（物理级别）写入数据。</font><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的缺点中</font><font style="vertical-align: inherit;">-它还禁用了对此文件的校验和检查。</font><font style="vertical-align: inherit;">换句话说，没有牛-没有校验和。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，手动设置属性</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个文件都是一项艰巨的任务。如果设置了目录/子卷的此标志，则其中创建的所有新文件将自动继承该标志。创建的嵌套目录也是如此。如果在打开属性的那一刻目录中已经有任何数据，那么这将不会以任何方式影响它们-该属性</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能设置为新文件或空文件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动设置标志的另一种方法</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是使用选项挂载文件系统</font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此选项将导致该选项自动连接</font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此对于新创建的文件，将不计算校验和。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像往常一样，有一个细微差别：您不能仅安装一个带option的低音炮</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。所有子卷都有一个option </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，或者没有。一切都由第一个安装的子卷决定：如果指定了选项</font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则所有后续安装将自动与此选项一起使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在文件上放置标志</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并从该文件所在的子卷中删除快照，则会出现明显的情况。在这种情况下，</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果多个子卷引用了更新的数据块</font><font style="vertical-align: inherit;">，则btrfs将忽略该标志</font><font style="vertical-align: inherit;">。因此，尽管有国旗</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（顺便说一下，该文件还将在快照中继承它），对任何文件的更改将进入磁盘上的新区域，并且文件将再次变得碎片化。</font><font style="vertical-align: inherit;">如果文件中的数据块被更新了几次，那么它第一次将落入磁盘上的新区域中，并且随后的条目将在该新区域中“就地”更新。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 技巧和失败 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用btrfs-progs时，可以省略命令的全名： </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅需首字符的巧合就足够了，它们唯一地确定了命令： </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为原则很明确。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b，btrfs无法创建目录的快照，但是有一种解决方法：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个子卷 </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将文件从目录复制到子卷： </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥</font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用CoW机制，即 </font><font style="vertical-align: inherit;">数据将不会被复制，但是将在较低级别的btrfs上创建指向该数据的链接。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，子世界包含目录中的所有文件，您可以从其中删除快照。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能将</font><font style="vertical-align: inherit;">属性设置为</font><font style="vertical-align: inherit;">现有数据文件。</font><font style="vertical-align: inherit;">但是，您可以采用以下方式：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建空文件 </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 给他设置一个标志 </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为新文件分配磁盘空间 </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将现有文件的内容复制到 </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果btrfs空间不足，即使删除文件也可能会导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“设备上没有剩余空间”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于该解决方案，建议将大小至少为1GB的临时驱动器连接到btrfs。</font><font style="vertical-align: inherit;">然后清除数据。</font><font style="vertical-align: inherit;">然后卸下临时驱动器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">未指定写配置文件的情况下调用</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">会将其从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐式更改</font><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">偶然地写在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面上的内容</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将磁盘添加到使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写配置文件的btrfs后，会发生这种情况</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">回想一下，在btrfs中格式化单个驱动器会对</font><font style="vertical-align: inherit;">元数据和系统数据</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">默认的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置文件</font><font style="vertical-align: inherit;">。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也许最重要 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免使用btrfs创建块设备的低级克隆。作为一个“智能”文件系统，对于某些操作（通常是在安装时），btrfs会重新读取块设备上的系统数据以查找文件系统的所有部分。如果在搜索过程中找到两个具有相同UUID的块设备，则btrfs将接受它们作为同一实例的一部分。如果同时发现这两个设备是原始设备及其克隆，那么仅安装驱动程序后，便知道文件系统将如何工作，但是很显然，这样做不会以任何好的结果而告终。在最坏的情况下，它将导致不可逆的数据损坏。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您确实想以低级方式使用btrfs克隆磁盘，则必须格外小心。</font><font style="vertical-align: inherit;">通常，当原始副本存在于系统中时，克隆不应作为块设备对OS内核可见，反之亦然。</font><font style="vertical-align: inherit;">提供此条件后，您可以更改克隆的UUID（很好，也可以是原始的UUID，这里是可选的）。</font><b><font style="vertical-align: inherit;">btrfs-progs</font></b><font style="vertical-align: inherit;">软件包随附</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用</font><font style="vertical-align: inherit;">程序</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将帮助您</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再说一遍：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个“智能”实用程序，它不仅会更改磁盘上的UUID，还会更改整个文件系统上的UUID。</font><font style="vertical-align: inherit;">这意味着当被调用时，她将读取所有块设备，以替换与文件系统相关的所有设备上的UUID。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 而不是结论 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这时您什么都不懂-这很正常。 Btrfs是不平凡的，可能不会立即屈服。在我看来，每当我了解她时，她都会大吃一惊，并重新思考现有的事物。我不能说我现在已经了解了一切-在写作过程中，我发现了一些新东西，尽管我已经根据自己的经验写作了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将比较掌握btrfs的过程与从过程编程样式到面向对象的转变。最初的印象是“哇，太棒了”，但随后您将继续编写包裹在类中的过程代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这篇文章中，我试图不倒水-写有关案件的一切。</font><font style="vertical-align: inherit;">尽管如此，结果却非常庞大。</font><font style="vertical-align: inherit;">但是，一切都不可能告诉您-您仍然可以撰写和撰写有关btrfs的文章。</font><font style="vertical-align: inherit;">本文只是冰山一角。</font><font style="vertical-align: inherit;">最开始就是了解它的哲学并开始使用它。</font><font style="vertical-align: inherit;">现在该结束了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢您阅读到最后。</font><font style="vertical-align: inherit;">希望不要累。</font><font style="vertical-align: inherit;">在评论中写下您还想知道的其他内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做备份，先生们。</font><font style="vertical-align: inherit;">并且让他们永远不会派上用场。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458250/">https://habr.com/ru/post/zh-CN458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458240/index.html">人工智能，无人机和摄像头如何确保道路和桥梁的安全</a></li>
<li><a href="../zh-CN458242/index.html">C ++ 20中的新太空飞船运算符</a></li>
<li><a href="../zh-CN458244/index.html">为了安全使用公共Wi-Fi网络，您需要了解的内容无穷无尽的清单</a></li>
<li><a href="../zh-CN458246/index.html">生活中的偶然巧合，或结果证明您在拖拉机工厂被送上蛋糕</a></li>
<li><a href="../zh-CN458248/index.html">用火箭科学简化您的代码：C ++ 20的太空船操作员</a></li>
<li><a href="../zh-CN458252/index.html">超长射电望远镜的数学模型</a></li>
<li><a href="../zh-CN458256/index.html">是不是该洗脑了？</a></li>
<li><a href="../zh-CN458260/index.html">为Java应用程序优化Docker映像的另一种方法</a></li>
<li><a href="../zh-CN458262/index.html">会议室的在线设计师-选择视频会议的最佳解决方案</a></li>
<li><a href="../zh-CN458264/index.html">自我记录代码的10条原则</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>