<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🍳 🔊 ‼️ PVS-Studio for Java 💪🏾 🙃 👎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在PVS-Studio静态分析器的第七版中，我们添加了对Java语言的支持。 现在该讨论一下我们如何开始为Java语言提供支持，我们做了什么以及未来计划如何。 而且，当然，本文将显示分析仪在开放项目上的首次测试。 

 PVS工作室 
 对于以前从未听说过PVS-Studio工具的Java开发人员，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio for Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio for Java"></div><br> 在PVS-Studio静态分析器的第七版中，我们添加了对Java语言的支持。 现在该讨论一下我们如何开始为Java语言提供支持，我们做了什么以及未来计划如何。 而且，当然，本文将显示分析仪在开放项目上的首次测试。 <br><a name="habracut"></a><br><h2>  PVS工作室 </h2><br> 对于以前从未听说过PVS-Studio工具的Java开发人员，我将对其进行简要说明。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>是用于检测用C，C ++，C＃和Java编写的程序的源代码中的错误和潜在漏洞的工具。 它可以在Windows，Linux和macOS上运行。 <br><br>  PVS-Studio执行静态代码分析并生成报告，以帮助程序员发现和修复缺陷。 对于那些对PVS-Studio到底如何查找错误感兴趣的人，建议您阅读文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio代码分析器中用于查找错误和潜在漏洞的技术</a> ”。 <br><br><h2> 开始 </h2><br> 我想出一个聪明的故事，因为我们已经思考两年了，PVS-Studio支持哪种语言。 基于该语言的高度流行等事实，Java是一个合理的选择。 <br><br> 但是，在生活中发生的一切，并不是通过深入的分析来决定的，而是通过实验来决定的:)。 是的，我们正在考虑应朝哪个方向进一步开发PVS-Studio分析仪。 考虑使用以下编程语言：Java，PHP，Python，JavaScript，IBM RPG。 我们倾向于使用Java语言，但最终选择尚未做出。 那些对陌生的IBM RPG视而不见的人，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>参考此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> ，从中可以清楚地看到所有内容。 <br><br>  2017年底，同事Egor Bredikhin考察了哪些现成的用于解析代码的库（即解析器）可用于我们感兴趣的新方向。 我遇到了几个项目来解析Java代码。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spoon的帮助下</a> ，他很快设法制造出带有几个诊断程序的原型分析仪。 而且，很明显，借助Java分析器中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SWIG</a> ，我们可以使用C ++分析器的某些机制。 我们查看发生了什么，并意识到我们的下一个解析器将用于Java。 <br><br> 感谢Egor在Java分析器上所做的努力和积极的工作。 他在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发新的静态分析器：PVS-Studio Java</a> ”中描述了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发的进行方式</a> 。 <br><br><h2> 竞争对手？ </h2><br> 世界上有许多免费的和商用的Java静态代码分析器。 在文章中将它们全部列出是没有意义的，我只留下了“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">静态代码分析工具列表</a> ”的链接（请参阅Java和多语言部分）。 <br><br> 但是，我知道首先我们将被问到有关IntelliJ IDEA，FindBugs和SonarQube（SonarJava）的问题。 <br><br>  <b>IntelliJ IDEA</b> <br><br>  IntelliJ IDEA内置了功能非常强大的静态代码分析器。 此外，分析仪正在开发中，其作者正在密切<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">监视</a>我们的活动。 有了IntelliJ IDEA，我们将变得最困难。 至少到目前为止，我们将无法在诊断功能上超过IntelliJ IDEA。 因此，我们将尝试着重于其他优势。 <br><br> 首先，IntelliJ IDEA中的静态分析是开发环境的芯片之一，这对其施加了一定的限制。 我们可以免费使用分析仪。 例如，我们可以使分析仪快速适应客户的特定需求。 快速而深入的支持是我们的竞争优势。 我们的客户与开发PVS-Studio特定部分的程序员直接沟通。 <br><br>  PVS-Studio具有将其集成到大型旧项目的开发周期中的多种可能性。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与SonarQube集成的</a> 。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对</a>分析器消息的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">极大抑制</a> ，它使您可以立即在大型项目中使用分析器来仅跟踪新代码或更改的代码中的错误。  PVS-Studio已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集成</a>到持续集成过程中。 我认为这些功能和其他功能将帮助我们的分析仪在Java世界中找到阳光下的地方。 <br><br>  <b>虫子</b> <br><br>  FindBugs项目被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">放弃</a> 。 但是应该记住这一点，因为它可能是最著名的Java代码免费静态分析器。 <br><br>  FindBugs的后继者是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpotBugs</a>项目。 但是，他的受欢迎程度较弱，对他的影响也尚不完全清楚。 <br><br> 总的来说，我们认为尽管FindBugs曾经并且仍然非常流行，并且还是一个免费的分析器，但是我们不应该考虑它。 这个项目只是悄无声息地成为过去。 <br><br>  PS：顺便说一下，现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a>开放项目时，PVS-Studio也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费使用</a> 。 <br><br>  <b>SonarQube（SonarJava）</b> <br><br> 我们相信我们不会与SonarQube竞争，而是会对其进行补充。  PVS-Studio与SonarQube集成，开发人员可以在他们的项目中发现更多的错误和潜在的漏洞。 如何将PVS-Studio工具和其他分析器集成到SonarQube中，我们定期在各种会议上举办的大师班上进行演讲（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> ）。 <br><br><h2> 如何启动PVS-Studio for Java </h2><br> 我们向用户提供了将分析仪集成到装配系统中的最流行方法： <br><br><ul><li>  Maven插件； </li><li>  Gradle插件； </li><li>  IntelliJ IDEA的插件 </li></ul><br> 在测试阶段，我们遇到了许多拥有自行编写的装配系统的用户，尤其是在移动开发中。 他们喜欢直接运行分析器，列出源和类路径的功能。 <br><br> 您可以在文档页面“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何启动PVS-Studio Java</a> ”中找到有关启动分析仪的所有方法的详细信息。 <br><br> 我们不能忽略在Java开发人员中非常流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube</a>代码质量控制平台，因此我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube插件中</a>添加了Java语言支持。 <br><br><h2> 进一步的计划 </h2><br> 我们有很多想法需要进一步研究，但是一些针对我们分析仪的特定计划如下所示： <br><br><ul><li> 创建新的诊断并完善现有的诊断； </li><li> 开发数据流分析； </li><li> 提高可靠性和可用性。 </li></ul><br> 我们可能会抽出时间将IntelliJ IDEA插件用于CLion。 向使用Java分析器的开发人员介绍C ++ :-) <br><br><h2> 开源项目中发现的错误示例 </h2><br> 如果我没有显示本文中使用新分析仪发现的任何错误，我将不是我。 我们可以像往常一样进行一些大型的开放源Java项目，并撰写带有错误分析的经典文章。 <br><br> 但是，我立即预见到是否可以在IntelliJ IDEA，FindBugs等项目中找到某些问题。 因此，我根本没有出路，而我将从这些项目开始。 因此，我决定快速检查并写出以下项目中一些有趣的错误示例： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IntelliJ IDEA社区版</a> 。 我认为无需解释为什么选择此项目:)。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpotBugs</a> 如我先前所写，FindBugs项目没有开发。 因此，请看一下SpotBugs项目，它是FindBugs的后继项目。  SpotBugs是经典的静态Java代码分析器。 </li><li>  SonarSource的某些项目，该项目开发了用于连续代码质量控制的软件。 看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarJava项目</a> 。 </li></ul><br> 在这些项目中编写错误是一项艰巨的任务。 事实是这些项目的质量很高。 实际上，这并不奇怪。 正如我们的观察结果所示，静态分析器的代码始终使用其他工具进行了良好的测试和验证。 <br><br> 尽管如此，我还是必须从这些项目开始。 我将没有第二次机会写一些关于他们的东西。 我确信，PVS-Studio for Java发行后，这些项目的开发人员将使PVS-Studio投入使用，并将开始将其用于定期或至少定期检查其代码。 例如，我知道从事撰写IntelliJ IDEA静态代码分析器的JetBrains的开发人员之一Tagir Valeyev（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">lany</a> ）在撰写本文时已经在使用Beta版的PVS-Studio。 他已经给我们写了15封有关错误报告和建议的信。 谢谢塔吉尔！ <br><br> 幸运的是，我不需要在一个特定项目中发现尽可能多的错误。 现在，我的任务是证明Java的PVS-Studio分析器似乎没有白费，并且将能够补充其他旨在提高代码质量的工具。 我只是浏览了分析仪的报告，并写出了一些对我来说似乎很有趣的错误。 只要有可能，我都会尝试写出各种类型的错误。 让我们看看发生了什么。 <br><br><h3>  IntelliJ IDEA整数部分 </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  PVS-Studio警告：V6011 [CWE-682]将'double'类型的'0.2'文字与'int'类型的值进行比较。  TitleCapitalizationInspection.java 169 <br><br> 按照预期，如果少于20％的单词以大写字母开头，则函数应返回true。 实际上，该检查不起作用，因为发生了整数除法。 作为除法的结果，只能获得两个值：0或1。 <br><br> 仅当所有单词均以大写字母开头时，该函数才会返回假值。 在所有其他情况下，除法将产生0，并且该函数将返回真实值。 <br><br><h3>  IntelliJ IDEA可疑周期 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'index&gt; = 0'始终为true。  Updater.java 184 <br><br> 首先，查看条件<i>（0 &lt;= current &amp;&amp; current &lt;count）</i> 。 仅当<i>count</i>变量的值大于0时才执行。 <br><br> 现在看一下循环： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br> 变量<i>索引</i>由表达式<i>count-1</i>初始化。 由于<i>计数</i>变量大于0，因此<i>索引</i>变量的初始值始终大于或等于0。事实证明，循环将执行直到<i>索引</i>变量溢出为止。 <br><br> 最有可能的是，这只是一个错字，不得执行增量，而应执行以下操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA，复制粘贴 </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  PVS-Studio警告：V6001 [CWE-570]在“ ||”的左侧和右侧有相同的子表达式“ LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase（str）”。 操作员。 检查行：127，128。ExtensionOrderConverter.java 127 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一行效果</a>不错。 程序员匆匆忙忙，在增加了一行代码之后，却忘了对其进行修复。 结果，两次将字符串<i>str</i>与<i>BEFORE_STR_OLD</i>进行比较。 比较可能是与<i>AFTER_STR_OLD</i>比较。 <br><br><h3>  IntelliJ IDEA错字 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告：V6001 [CWE-571]在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'！StringUtil.endsWithChar（name，'“'）'。JsonNamesValidator.java 27 <br><br> 这段代码验证该名称是单引号还是双引号。 如果不是这种情况，则会自动添加双引号。 <br><br> 由于输入错误，只会检查名称的结尾是否包含双引号。 结果，单引号中的名称将无法正确处理。 <br><br> 名 <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br> 由于增加了双引号，它将变为： <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA，错误的阵列溢出保护 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'i &lt;endOffset'始终为true。  EnterAfterJavadocTagHandler.java 183 <br><br> 在<i>if语句</i>的条件下，子表达式<i>i &lt;endOffset</i>没有意义。 从执行循环的条件<i>来看</i> ，变量<i>i</i>始终小于<i>endOffset</i> 。 <br><br> 程序员最有可能希望在调用函数时保护自己免于脱节： <br><br><ul><li>  text.charAt（i + 1） </li><li>  CharArrayUtil.regionMatches（文本，i + 2，endOffset，startTag） </li></ul><br> 在这种情况下，用于检查索引的子表达式应如下所示： <i>i &lt;endOffset-2</i> 。 <br><br><h3>  IntelliJ IDEA重复检查 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'buffer.length（）&gt; 0'始终为true。  DeleteUtil.java 62 <br><br> 这可能是无害的冗余代码，也可能是严重的错误。 <br><br> 例如，如果在重构过程中偶然出现了重复检查，则没有任何问题。 第二张支票可以简单地删除。 <br><br> 但是另一种情况是可能的。 第二次检查应该完全不同，并且代码的行为不符合预期。 这是一个真正的错误。 <br><br>  <b>注意事项</b> 顺便说一下，有很多不同的冗余检查。 而且，经常看到这不是错误。 但是，分析器消息也不能称为误报。 为了澄清，这是一个示例，也取自IntelliJ IDEA： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br> 分析器说<i>text.contains（“ \ r \ n”）</i>函数始终返回false。 确实，如果找不到符号“ \ n”和“ \ r”，则寻找“ \ r \ n”毫无意义。 这不是一个错误，并且代码很糟糕，只是因为它的工作速度慢一点，对子字符串执行了无意义的搜索。 <br><br> 在每种情况下，如何处理此类代码都由程序员决定。 通常，在撰写文章时，我根本不注意此类代码。 <br><br><h3>  IntelliJ IDEA，出了点问题 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-570]表达式'“ 0” .equals（text）'始终为false。  ConvertIntegerToDecimalPredicate.java 46 <br><br> 此代码肯定包含逻辑错误。 但是我发现很难说程序员想要检查什么，以及如何纠正缺陷。 因此，这里我仅指出毫无意义的检查。 <br><br> 首先，检查该字符串必须至少包含两个字符。 如果不是，则该函数返回<i>false</i> 。 <br><br> 以下是<i>“ 0” .equals（文本）</i>检查。 这是没有意义的，因为字符串不能仅包含一个字符。 <br><br> 通常，这里出了点问题，代码应该固定。 <br><br><h3>  SpotBugs（FindBugs的前身），迭代限制错误 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'count &lt;4'始终为true。 实用程序394 <br><br> 按照计划，仅在文件的前四行中搜索xml标记。 但是由于他们忘记增加变量<i>计数</i> ，因此将读取整个文件。 <br><br> 首先，这可能是非常缓慢的操作，其次，可以在文件中间的某处找到某些内容，将其解释为xml标记，但事实并非如此。 <br><br><h3>  SpotBugs（FindBugs的前身），覆盖值 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  PVS-Studio警告：V6021 [CWE-563]该值已分配给'priority'变量，但未使用。  FindNonShortCircuit.java 197 <br><br> 根据变量<i>sawNullTestVeryOld</i>的值设置<i>优先级</i>变量的值。 但是，这没有任何作用。 此外，在任何情况下都将为<i>优先级</i>变量分配一个不同的值。 函数逻辑中明显的错误。 <br><br><h3>  SonarQube，复制粘贴 </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio：V6032奇怪的是，方法“ setUpdatedAtFromDefinition”的主体完全等效于另一种方法“ setUpdatedAtFromMetadata”的主体。 检查行：396，405。RuleDto.java 396 <br><br>  <i>setUpdatedAtFromMetadata</i>方法使用<i>定义</i>字段。 最有可能应使用<i>元数据</i>字段。 这与复制粘贴失败的后果非常相似。 <br><br><h3>  SonarJava，重复地图初始化 </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  PVS-Studio警告：V6033 [CWE-462]已添加带有相同键“ JavaPunctuator.PLUSEQU”的项目。 检查行：104、100。KindMaps.java 104 <br><br> 相同的键值对在卡中放置了两次。 事实证明，这很可能是专心的，实际上没有真正的错误。 但是，无论如何，都需要检查此代码，因为您可能忘记添加其他对。 <br><br><h2> 结论 </h2><br> 但是会有什么结论呢？ 我邀请所有人立即下载PVS-Studio并尝试用Java测试您的工作项目！  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载PVS-Studio</a> 。 <br><br> 谢谢大家的关注。 我希望不久以后，我们将为读者提供一系列致力于检查各种开放Java项目的文章，以使读者满意。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio for Java</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436434/">https://habr.com/ru/post/zh-CN436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436424/index.html">小动物，大事：切叶机在新热带植物温室效应中的作用</a></li>
<li><a href="../zh-CN436426/index.html">如果网络连接丢失，则暂停应用程序</a></li>
<li><a href="../zh-CN436428/index.html">为什么我们为体育节目节目加油</a></li>
<li><a href="../zh-CN436430/index.html">自白</a></li>
<li><a href="../zh-CN436432/index.html">SAP：开始学习SAPUI5需要什么？</a></li>
<li><a href="../zh-CN436436/index.html">欧洲核子研究中心计划建造新的加速器，其隧道长度为100公里</a></li>
<li><a href="../zh-CN436438/index.html">Roscosmos称与Spektr-R轨道天文台失去通讯的可能原因</a></li>
<li><a href="../zh-CN436440/index.html">Gotta Go Fast：在iOS中构建速度。 第二部分</a></li>
<li><a href="../zh-CN436442/index.html">一个脑袋好，两个脑袋好，或者配对编程有效</a></li>
<li><a href="../zh-CN436444/index.html">在AWS上的生产中无形部署整体应用程序。 个人经历</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>