<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüî¨ ‚öõÔ∏è üêª Estimamos o rendimento do canal MIMO (o algoritmo de vazamento de √°gua est√° inclu√≠do) ‚õîÔ∏è üå∫ üòú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio 


 No ver√£o de 2016, a partir de um evento bem conhecido, seu humilde servidor, entre um grupo de outros estudantes, p√¥de assistir a palestr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estimamos o rendimento do canal MIMO (o algoritmo de vazamento de √°gua est√° inclu√≠do)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448570/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/672/437/0d067243758eedce24dc51cb947b5581.jpg"></p><br><h1 id="predislovie">  Pref√°cio </h1><br><p>  No ver√£o de 2016, a partir de um evento bem conhecido, seu humilde servidor, entre um grupo de outros estudantes, p√¥de assistir a palestras do professor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Martin Haardt</a> sobre t√≥picos do <strong>MIMO</strong> , realizadas por ele no √¢mbito do programa de mestrado internacional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">"Comunica√ß√£o e processamento de sinais"</a> .  Mas, infelizmente, uma semana e meia em duas fiquei muito doente - e, portanto, v√°rios t√≥picos ficaram fora do meu escopo de compreens√£o ... No entanto, depois de algum tempo, analisar o b√°sico do MIMO se tornou meu hobby - para n√£o deixar o caso inacabado. </p><br><p>  Pouco a pouco, tudo isso se transformou em uma s√©rie de pequenos <em>semin√°rios abstratos</em> , que, provavelmente, seria errado n√£o compartilhar.  E hoje, em homenagem <strong>ao Dia da Comunica√ß√£o</strong> , eu gostaria de discutir com voc√™ o t√≥pico da largura de banda do canal MIMO - o t√≥pico √© simples, mas ainda est√° causando algumas dificuldades para os alunos (e n√£o apenas para os alunos). </p><br><p>  Pode parecer que as pessoas n√£o est√£o envolvidas que um aumento no n√∫mero de antenas de recep√ß√£o e transmiss√£o dentro da estrutura da tecnologia mencionada aumenta a largura de banda do sistema na mesma quantidade: por exemplo, se voc√™ colocar <strong>2</strong> antenas no lado de recebimento e <strong>2</strong> antenas no lado de transmiss√£o (MIMO 2x2), o rendimento definitivamente aumentar√° <strong>2</strong> vezes.  Mas isso √© verdade em teoria?  Vamos tentar descobrir! </p><a name="habracut"></a><br><blockquote>  Uma vers√£o mais formal em ingl√™s pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">no link</a> e no meu <a href="" rel="nofollow">reposit√≥rio GitHub</a> . <br>  Neste artigo, n√£o consideraremos os problemas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">correla√ß√£o</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">antena</a> e outros problemas de implementa√ß√£o.  Nos limitamos a uma teoria destilada - para iniciantes. </blockquote><br><h1 id="model-prinyatogo-signala">  Modelo de Sinal Recebido </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/308/f3d/94b/308f3d94b67d28b58f43b6c934fdefd7.png"></p><br><p>  Antes de come√ßarmos a falar sobre largura de banda, trataremos primeiro da descri√ß√£o matem√°tica do sinal recebido.  Esta parte deve ser tomada com muito cuidado, pois muito vir√° dessa f√≥rmula.  Portanto, o sinal recebido pode ser representado como: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/4ec/2f2/a114ec2f2cdbad23ee05bedbe4ca698f.svg" alt="\ mathbf {y} = \ sqrt {\ frac {P} {M_T}} \ mathbf {H} \ mathbf {s} + \ mathbf {n} \ qquad (1)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P">  - pot√™ncia do transmissor, <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  - n√∫mero de antenas de transmiss√£o, <img src="https://habrastorage.org/getpro/habr/post_images/704/f4d/c83/704f4dc83e43715dbca37e74095e21fd.svg" alt="\ mathbf {s}">  - caracteres transmitidos <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  - ru√≠do aditivo, e <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  - matriz de coeficientes de transmiss√£o do canal (de fato, o processo de desbotamento). </p><br><p>  O sinal transmitido tamb√©m pode ser pintado com mais detalhes: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/0f5/eb0/3990f5eb08f290f19a1288c2c5772792.svg" alt="s_i = \ gamma_i d_i \ quad i = 1,2, .. M_T \ qquad (2)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/1bb/7b2/fbc/1bb7b2fbccba41b76c9d4173d75920a6.svg" alt="di">  - um dos sinais de informa√ß√£o ( <img src="https://habrastorage.org/getpro/habr/post_images/3da/909/c1e/3da909c1e9bfc42a2d72c4cb9eaf46cd.svg" alt="E \ {\ mathbf {d} \ mathbf {d} ^ H \} = M_T">  ) e <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  - amplifica√ß√£o de um certo caminho de propaga√ß√£o de uma onda EM (ganho de caminho). </p><br><p>  <u>Vamos declarar qual √© o refor√ßo do caminho:</u> <br>  Refor√ßar o caminho de propaga√ß√£o (ou o peso da antena) significa a distribui√ß√£o da pot√™ncia de sa√≠da proporcional √† "for√ßa" de um caminho espec√≠fico.  Em outras palavras, queremos alocar mais energia para bons canais (caminhos de propaga√ß√£o) e menos energia para canais ruins. </p><br><p>  Os pesos das antenas s√£o limitados pelo n√∫mero de antenas de transmiss√£o: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/3c5/de0/cbb3c5de0a1de4ab81447d7e251f85a4.svg" alt="\ sum ^ r_ {i = 1} \ gamma_i = M_T \ qquad (3)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  √â a <strong>classifica√ß√£o da</strong> matriz <strong>do</strong> canal. </p><br><p>  Falando nisso. </p><br><p>  Dimens√£o da matriz <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  comp√µe <img src="https://habrastorage.org/getpro/habr/post_images/043/a05/2ed/043a052edaf7736764222d480a9bdf44.svg" alt="M_R \ vezes M_T">  onde <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  - n√∫mero de antenas receptoras. <br>  Para v√°rias medi√ß√µes de tempo, o canal ficar√° assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fb/9e2/0c2/6fb9e20c2a79856e2d952dd1897813ec.png"></p><br><blockquote>  <strong>Para refer√™ncia:</strong> <br>  Talvez para c√°lculos e modelos mais complexos, voc√™ queira usar uma das ferramentas mais populares para isso - o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">MatLab</a> .  Nesse caso, vale a pena considerar que uma estrutura de dados ligeiramente diferente √© usada l√°: as linhas s√£o medidas de tempo (instant√¢neos), o n√∫mero de colunas corresponde ao n√∫mero de antenas de transmiss√£o <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  , a dimens√£o lateral corresponde a <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  . </blockquote><p>  A f√≥rmula (1) pode ser facilmente adaptada para casos especiais de MIMO. </p><br><p>  <strong>MISO</strong> (sa√≠da m√∫ltipla de entrada √∫nica - v√°rias antenas de transmiss√£o e uma receptora): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/faa/99b/800/faa99b80083c385e9efcec4c39e135b9.svg" alt="y = \ sqrt {\ frac {P} {M_T}} \ mathbf {h} \ mathbf {s} + n \ qquad (4)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  √â um vetor <img src="https://habrastorage.org/getpro/habr/post_images/198/8ce/bbb/1988cebbb6865548743db331b96b8691.svg" alt="1 \ vezes M_T">  . </p><br><p>  <strong>SIMO</strong> (√önica <strong>sa√≠da de</strong> m√∫ltiplos dispositivos - v√°rias antenas receptoras e uma antena transmissora): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/4ce/713/1d44ce713b6479b18db31b6eea465139.svg" alt="y = \ sqrt {P} \ mathbf {h} s + \ mathbf {n} \ qquad (5)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  √â um vetor <img src="https://habrastorage.org/getpro/habr/post_images/255/44a/e75/25544ae75110da1c6751c23ef7057e7d.svg" alt="M_R \ times 1"></p><br><p>  <strong>SISO</strong> (√önica <strong>sa√≠da</strong> monof√°sica - uma antena nos lados receptor e transmissor): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dff/17e/6a9/dff17e6a9569811683f776e4e9b87b9a.svg" alt="y = \ sqrt {P} hs + n \ qquad (6)"></div><br><p>  Parece ser simples. </p><br><p>  Todas as considera√ß√µes adicionais podem ser divididas em <strong>dois</strong> casos grandes: as informa√ß√µes do estado do canal (CSI - informa√ß√µes do estado do canal) s√£o <em>desconhecidas para o</em> transmissor ( <strong>CU</strong> - Canal desconhecido) e as informa√ß√µes do status do canal s√£o <em>conhecidas pelo</em> transmissor ( <strong>CK</strong> - Canal conhecido). </p><br><p>  Acima, examinamos o caso em que o canal √© <strong>desconhecido</strong> para o transmissor ( <strong>caso de loop aberto</strong> , transmiss√£o sem realimenta√ß√£o).  Em outras palavras, devido √† falta de informa√ß√µes necess√°rias, n√£o podemos escolher nenhuma dire√ß√£o efetiva e, portanto, seguimos o caminho mais simples: transmitimos pot√™ncia igual por todas as antenas (caminhos, caminhos de propaga√ß√£o).  Portanto, o ganho de cada ganho de caminho √© <strong>1</strong> : </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/f6d/75b/39ef6d75b2d7666174e1f1570c433b07.svg" alt="\ gamma_i = 1, \ quad i = 1,2, .. M_T \ qquad (7)"></div><br><p>  No entanto, repetimos: queremos alocar <strong>mais</strong> energia para <strong>bons</strong> canais (caminhos de propaga√ß√£o) e <strong>menos</strong> energia para canais <strong>ruins</strong> . </p><br><p>  Surge a quest√£o: <u>como distribuir efetivamente o poder?</u> </p><br><p>  Se o canal <strong>for conhecido</strong> ( <strong>caso de malha fechada</strong> - com feedback), podemos usar cen√°rios avan√ßados de transmiss√£o com alguns algoritmos de processamento de sinal adicionais.  Por exemplo, com abordagens lineares, como <em>pr√©-codifica√ß√£o</em> e <strong>p√≥s-processamento</strong> . </p><br><p>  Vamos entender o que os dois √∫ltimos termos significam. </p><br><p>  Se tivermos <strong>CSI</strong> no lado da transmiss√£o, ou seja,  matriz <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , podemos processar matematicamente essa mesma matriz.  Por exemplo, aplicando o algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">SVD</a> (Decomposi√ß√£o de Valor Singular). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6bb/95a/fd3/6bb95afd35a66bb0b6421818b985d561.png"></p><br><p>  Observe que a matriz <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  √â uma matriz diagonal, e os elementos de sua diagonal (valores singulares) s√£o, em ess√™ncia, coeficientes de transmiss√£o de caminhos de propaga√ß√£o √∫nicos.  Em outras palavras, se conseguirmos a multiplica√ß√£o do nosso sinal por uma matriz de valores singulares <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  em vez de canal completo <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , o canal <strong>MIMO</strong> se decomp√µe em uma matriz de canais <strong>SISO</strong> paralelos. </p><br><p>  Portanto, a matriz de pr√©-codifica√ß√£o linear (filtro) deve ser <img src="https://habrastorage.org/getpro/habr/post_images/0dc/438/f04/0dc438f04dcae00f8f6be6e90cc305d7.svg" alt="\ mathbf {F} = \ mathbf {V} _s">  e a matriz de p√≥s-processamento linear (desmodulador) <img src="https://habrastorage.org/getpro/habr/post_images/7d4/715/f1a/7d4715f1a45bb371053c241af4f13904.svg" alt="\ mathbf {D} = \ mathbf {U} ^ H_s">  ( <em>H</em> significa conjuga√ß√£o hermitiana). </p><br><blockquote>  Obviamente, para o caso com um canal desconhecido <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  e <img src="https://habrastorage.org/getpro/habr/post_images/21b/7c1/06d/21b7c106daa35c36f96c5ae499233ec0.svg" alt="\ mathbf {D}">  matrizes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">identidade</a> iguais. </blockquote><p>  Agora, sabendo todas as op√ß√µes acima, redefinimos o modelo do sinal recebido: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/56d/23d/38b56d23d403a6a8910ad66923db4118.svg" alt="\ mathbf {Dy} = \ mathbf {D} \ left (\ sqrt {\ frac {P} {M_t}} \ mathbf {H} \ mathbf {F} \ mathbf {s} + \ mathbf {n} \ right) = \ mathbf {U} ^ H_s \ mathbf {y} = \ sqrt {\ frac {P} {M_t}} \ mathbf {U} ^ H_s \ mathbf {H} \ mathbf {V} _s \ mathbf {s} + \ mathbf {U} ^ H_s \ mathbf {n} = \ sqrt {\ frac {P} {M_t}} \ mathbf {\ Sigma} _s \ mathbf {s} + \ mathbf {\ hat {n}} = \ mathbf {\ hat {y}} \ qquad (8)"></div><br><p>  Note que: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/feb/dae/d36/febdaed369cb465bf821b996e5e5cb61.svg" alt="\ mathbf {\ hat {n}}">  tem as mesmas propriedades estat√≠sticas que <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  ; </li><li>  Valores pr√≥prios <img src="https://habrastorage.org/getpro/habr/post_images/bff/f9f/d6d/bfff9fd6d698c1d0e8011e5f9a9c6585.svg" alt="\ mathbf {HH} ^ H">  s√£o os quadrados dos valores singulares da matriz do canal <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  ( <img src="https://habrastorage.org/getpro/habr/post_images/5d9/204/19e/5d920419e86666fa5a5de6669e965466.svg" alt="\ sigma_i = \ sqrt {\ lambda_i}">  ) </li></ul><br><p>  Esquematicamente, isso pode ser representado como: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/ce5/f41/e66ce5f41bd4d57670aad51ad5409adc.png" alt="sch" width="500" height="600"><br><p>  <em>Fig.</em>  <em>1. O esquema de pr√©-codifica√ß√£o e p√≥s-processamento [1, p.67].</em> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/072/138/b29/072138b29e56f44939c260426c564153.png" alt="paralelo" width="500" height="600"><br><p>  <em>Fig.</em>  <em>2. Esquema de decomposi√ß√£o modal</em> <em><img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}"></em>  <em>quando o canal √© conhecido pelo transmissor e receptor [1, p.67].</em> </p><br><p>  O b√°sico √© desmontado - podemos prosseguir diretamente para a <strong>largura de banda</strong> ! </p><br><h1 id="propusknaya-sposobnost-capacity">  Capacidade </h1><br><p>  Acho que todo mundo que estudou a <strong>teoria da informa√ß√£o</strong> lembra que o termo largura de banda chegou at√© n√≥s nessa disciplina espec√≠fica.  Normalmente (na minha idade de estudante), a considera√ß√£o era focada no caso cl√°ssico do canal AWGN, mas a f√≥rmula pode ser relativamente facilmente derivada para o caso de um canal MIMO com desbotamento. </p><br><blockquote>  Para n√£o redigitar os c√°lculos dos livros mais uma vez, tentei organizar tudo de forma mais ou menos colorida e √† m√£o - a fim de fornecer f√≥rmulas para a vida, por assim dizer.  Espero que este formato seja menos tedioso. </blockquote><p>  Ent√£o, mais uma vez, escrevemos o modelo de sinal: </p><br><img src="https://habrastorage.org/webt/rh/x_/gc/rhx_gc1lr_rmqj6eaeewoewhvce.png"><br><p>  Agora, vamos determinar a taxa de transfer√™ncia atrav√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">de informa√ß√µes m√∫tuas</a> . </p><br><img src="https://habrastorage.org/webt/40/rb/cf/40rbcfuupxwyyx0ztm58nhubpqc.png"><br><p>  Escrevemos a matriz de autocovari√¢ncia do sinal recebido e seus componentes: </p><br><img src="https://habrastorage.org/webt/hd/ke/nz/hdkenzy3rhhgoysafzwopgnij7u.png"><br><p>  E n√≥s os usamos na determina√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">entropia diferencial</a> : </p><br><img src="https://habrastorage.org/webt/ev/cj/mm/evcjmmt0qlyjudk_7xqn2ldimec.png"><br><p>  Substitua (4) e (5) em (2): </p><br><img src="https://habrastorage.org/webt/ww/ud/gd/wwudgdbvqd6orus-tfnp3azhly0.png"><br><p>  E agora substitu√≠mos (6) em (1): </p><br><img src="https://habrastorage.org/webt/2i/3c/p4/2i3cp4tj0nf_4s-rnistbmcw0rm.png"><br><p>  Continuamos a raciocinar.  Veja o primeiro caso: o canal √© desconhecido (canal desconhecido).  Isso significa para n√≥s que √© imposs√≠vel escolher a dire√ß√£o de transmiss√£o ideal e, portanto, os sinais transmitidos ser√£o independentes e ter√£o a mesma pot√™ncia (com alimenta√ß√£o equi).  Com base na condi√ß√£o m√°xima ( <img src="https://habrastorage.org/getpro/habr/post_images/b55/710/37c/b5571037cdb68260d690fba1e74c122b.svg" alt="Tr \ {\ mathbf {R} _ {ss} \} = M_T">  ), podemos pegar a matriz de autocovari√¢ncia dos caracteres transmitidos igual √† matriz de identidade.  Ent√£o n√≥s temos: </p><br><img src="https://habrastorage.org/webt/nn/bd/_p/nnbd_pjhgqezwomw944_71x0vw4.png"><br><p>  Usamos a seguinte propriedade dos determinantes: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/866/f57/fbb866f57bd5076cb0d56869fe5ecde0.svg" alt="det \ left (\ mathbf {I} _m + \ mathbf {AB} \ right) = det \ left (\ mathbf {I} _n + \ mathbf {BA} \ right)"></div><br><p>  Este √© o nosso caso, e podemos trocar as matrizes para que <img src="https://habrastorage.org/getpro/habr/post_images/698/669/b9e/698669b9ea8fc3b7983608348382cc36.svg" alt="\ mathbf {Q} \ mathbf {Q} ^ H = \ mathbf {I}">  (das propriedades EVD).  Permanecer√°: </p><br><img src="https://habrastorage.org/webt/pk/no/dq/pknodqpt0rpcbvfp0z9eisl7imq.png"><br><p>  Passando de matrizes para somas, temos: </p><br><img src="https://habrastorage.org/webt/u_/gm/k9/u_gmk95fp05y8obm7odpf-wo2lq.png" width="600"><br><p>  Esta f√≥rmula ilustra mais uma vez a abordagem de considerar o MIMO como canais SISO paralelos. <br>  Para o caso do canal conhecido (canal <strong>K</strong> conhecido), os pesos da antena ser√£o adicionados √† f√≥rmula: </p><br><img src="https://habrastorage.org/webt/vr/ht/bl/vrhtblex4vq8soaxqoa1tokmmre.png"><br><p>  Tamb√©m escrevemos f√≥rmulas para casos especiais: </p><br><img src="https://habrastorage.org/webt/y-/f5/7y/y-f57yb-4yc4-yeegeblpmr6-hy.png"><br><blockquote>  <strong>Nota</strong> : <br>  Para os casos <strong>SIMO</strong> e <strong>MISO, n√£o √©</strong> em v√£o que os quadrados da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">norma Frobenius</a> aparecem no registro <img src="https://habrastorage.org/getpro/habr/post_images/c16/a79/bd1/c16a79bd16d4f7febf57f4dc4cefd303.svg" alt="|| \ mathbf {h} || _F ^ 2">  - do ponto de vista matem√°tico, s√£o equivalentes a valores pr√≥prios <img src="https://habrastorage.org/getpro/habr/post_images/f99/9f8/c65/f999f8c65e413f78334f6f3db0a438a6.svg" alt="\ mathbf {h} \ mathbf {h} ^ H">  .  Portanto, se voc√™ precisar calcular rapidamente algo √† m√£o - aqui est√° uma maneira. </blockquote><p>  Bem, espero que minha caligrafia e meu ingl√™s n√£o interfiram muito na percep√ß√£o da informa√ß√£o, mas, ainda assim, vamos falar sobre o <strong>ponto principal</strong> : </p><br><ul><li>  Sim, a largura de banda do canal <strong>MIMO</strong> pode ser considerada como a <strong>soma da</strong> largura de banda dos canais <strong>SISO</strong> . </li><li>  No entanto, esse valor √© limitado pela <strong>classifica√ß√£o do</strong> canal! </li></ul><br><h2 id="algoritm-water-pouring">  Algoritmo de vazamento de √°gua </h2><br><p>  Como pode ser visto na f√≥rmula de largura de banda conhecida no lado transmissor do canal (CK - Channel Known), a distribui√ß√£o de energia nas antenas pode ser otimizada.  Para isso, usamos o algoritmo Derramamento de √°gua ( <em>enchimento com √°gua</em> ) [1, p. 68-69]: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> linalg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LA <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waterpouring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mt, SNR_dB, H_chan)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) r = LA.matrix_rank(H_chan) H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] p = <span class="hljs-number"><span class="hljs-number">1</span></span>; gammas = np.zeros((r,<span class="hljs-number"><span class="hljs-number">1</span></span>)) flag = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> flag == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: lambdas_r_p_1 = lambdas[<span class="hljs-number"><span class="hljs-number">0</span></span>:(r-p+<span class="hljs-number"><span class="hljs-number">1</span></span>)] inv_lambdas_sum = np.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>/lambdas_r_p_1) mu = ( Mt / (r - p + <span class="hljs-number"><span class="hljs-number">1</span></span>) ) * ( <span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span>/SNR) * inv_lambdas_sum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas_r_p_1): gammas[idx] = mu - (Mt/(SNR*item)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gammas[rp] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#due to Python starts from 0 gammas[rp] = 0 #due to Python starts from 0 p = p + 1 else: flag = False res = [] for gamma in gammas: res.append(float(gamma)) return np.array(res)</span></span></code> </pre> <br><p>  Teste: </p><br><pre> <code class="python hljs">Mt = <span class="hljs-number"><span class="hljs-number">3</span></span> SNR_db = <span class="hljs-number"><span class="hljs-number">10</span></span> H_chan = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]], dtype = float) gammas = waterpouring(Mt, SNR_db, H_chan) print(<span class="hljs-string"><span class="hljs-string">'Rank of the matrix: '</span></span>+str(LA.matrix_rank(H_chan))) print(<span class="hljs-string"><span class="hljs-string">'Gammas:\n'</span></span>+str(gammas)) &gt;&gt;&gt; Rank of the matrix: <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; Gammas: &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.545</span></span> <span class="hljs-number"><span class="hljs-number">1.455</span></span>]</code> </pre> <br><p>  Bem, parece razo√°vel: <br>  1) o n√∫mero de antenas de transmiss√£o envolvidas √© igual √† <strong>classifica√ß√£o do</strong> canal; <br>  2) a soma dos <strong>pesos das</strong> antenas √© igual ao n√∫mero de antenas transmissoras. </p><br><h2 id="dva-predelnyh-sluchaya">  Dois casos limitantes </h2><br><p>  E agora vamos nos distrair um pouco e resolver os problemas de compreens√£o. </p><br><p>  Vamos encontrar, por exemplo, quais ser√£o os coeficientes iguais a <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  com o SNR tendendo a <img src="https://habrastorage.org/getpro/habr/post_images/279/496/46c/27949646c03ab2b1b12c79632ddc20bf.svg" alt="+ \ infty">  e <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  (em escala logar√≠tmica, √© claro, porque n√£o existem poderes negativos). </p><br><p>  Recordamos a f√≥rmula da correspond√™ncia entre decib√©is e tempos: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/109/e43/006/109e430066ec30bab3ea15fc12b24b5a.svg" alt="SNR_ {dB} = 10log_ {10} \ left (\ frac {S} {N} \ right)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S">  - pot√™ncia do sinal transmitido (para nossas tarefas, √© equivalente √† energia do s√≠mbolo <img src="https://habrastorage.org/getpro/habr/post_images/072/074/880/072074880bc38a00e1970f944ed4cf99.svg" alt="E_s">  ) e <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">  - pot√™ncia do ru√≠do (no nosso problema √© igual √† densidade espectral do ru√≠do <img src="https://habrastorage.org/getpro/habr/post_images/69a/ad3/04d/69aad304d9c25b25096b8e1cc83127e0.svg" alt="N_0">  ) </p><br><p>  Ent√£o, em uma escala linear ser√°: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60d/387/38e/60d38738e895ea76af6cc9fcfb1dd0b6.svg" alt="\ frac {E_s} {N_0} \ equiv \ frac {S} {N} = 10 ^ {SNR_ {dB} / 10}"></div><br><p>  Examinamos as f√≥rmulas b√°sicas do algoritmo: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/6ee/46c/62a6ee46c3a82d81a5b1bddd0f625ea8.svg" alt="\ mu = \ frac {M_T} {(r-p + 1)} \ left [1 + \ frac {N_0} {E_s} \ sum_ {i = 1} ^ {r-p + 1} \ frac {1} {\ lambda_i} \ right]"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/d76/c4d/c2b/d76c4dc2b17f00a09c864bf2d24ab365.svg" alt="p">  √â um iterador come√ßando com 1, <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  √â a classifica√ß√£o da matriz do canal, <img src="https://habrastorage.org/getpro/habr/post_images/4a1/9e2/b6a/4a19e2b6a9b67e2a8e0682126d49684a.svg" alt="\ lambda_i">  - i-√©simo autovalor do "quadrado" da matriz do canal.  Os gammas s√£o calculados de acordo com a seguinte f√≥rmula: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/2eb/aff/4f52ebaffbebeba87ac646dadd57d2cd.svg" alt="\ gamma_i = \ left (\ mu - \ frac {M_TN_0} {E_s \ lambda_i} \ right) \ quad i = 1,2, ..., r-p + 1"></div><br><p>  Come√ßamos a raciocinar: </p><br><p>  Se <img src="https://habrastorage.org/getpro/habr/post_images/734/618/09c/73461809c5cedcf8d9c19312c41a4d7a.svg" alt="SNR_ {dB} \ para + \ infty">  ent√£o <img src="https://habrastorage.org/getpro/habr/post_images/4ae/0cd/4f4/4ae0cd4f42acfe2e7b83ea1781a19667.svg" alt="\ frac {E_s} {N_0} \ para + \ infty">  .  Portanto, <img src="https://habrastorage.org/getpro/habr/post_images/c58/ff3/050/c58ff30508740ab8078825a703e9e651.svg" alt="\ frac {N_0} {E_s} \ a 0">  .  Para a primeira itera√ß√£o, ele permanece: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/3a2/84f/05a3a284fd68bd18f8bbcb5608edf314.svg" alt="\ mu = \ frac {M_T} {r}"></div><br><p>  Substitua por gama: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/e82/af3/47ee82af3923910da61acce90e57ccc3.svg" alt="\ gamma_i = \ mu = \ frac {M_T} {r} \ quad i = 1,2, ..., r"></div><br><p>  Resumimos: </p><br><p>  Com energia de transmiss√£o infinitamente grande ou ru√≠do infinitesimal, nada de especial precisa ser inventado, digamos assim - distribu√≠mos uniformemente a pot√™ncia entre as antenas de transmiss√£o (levando em considera√ß√£o a classifica√ß√£o da matriz do canal). </p><br><p>  N√≥s raciocinamos ainda mais: </p><br><p>  E o que o caso do SNR tendendo a <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  ?  Aqui nem vamos entrar em matem√°tica, raciocinaremos logicamente: esse caso corresponde a um ru√≠do infinitamente grande ou a uma pot√™ncia de transmiss√£o zero.  Portanto, desta maneira e daquela, nosso sistema, considere, n√£o funciona.  Portanto, a quest√£o com gama desaparece automaticamente ... </p><br><p>  √Äs vezes, essas s√£o perguntas que surgem em um exame com um professor. </p><br><h1 id="schitaem-propusknuyu-sposobnost-nakonec-to">  Contando a taxa de transfer√™ncia (finalmente!) </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">siso_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) c = np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*(np.abs(H_chan)**<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eig <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lambdas: c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*eig/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closedloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.real(np.sort(lambdas))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> gammas = waterpouring(Mt, SNR_dB, H_chan) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas): c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*item*gammas[idx]/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> H_chan = (np.random.randn(Mr,Mt) \ + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">#Rayleigh flat fading c = openloop_capacity(H_chan, 10) print(c) c = closedloop_capacity(H_chan, 10) print(c) c = siso_capacity(H_chan[0,0], 10) print(c) &gt;&gt;&gt; 11.978909197556913 &gt;&gt;&gt; 12.342571770086721 &gt;&gt;&gt; 3.9058582578551193</span></span></code> </pre> <br><p>  Parece funcionar.  Passamos a avalia√ß√µes mais substantivas. </p><br><h2 id="ergodic-capacity">  Capacidade erg√≥dica </h2><br><p>  Como pode ser visto nos exemplos acima, trabalhamos com processos aleat√≥rios.  E, francamente, √© um erro tirar conclus√µes sobre processos aleat√≥rios em uma implementa√ß√£o.  Mesmo que o canal seja <em>constante</em> no sentido estat√≠stico, √© necess√°ria uma m√©dia de um conjunto suficientemente grande. </p><br><p>  Aqui o conceito de <strong>capacidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">erg√≥dica</a> √©</strong> √∫til para n√≥s: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/664/e69/cc3664e69c54efa0d98127e7f65bf6ea.svg" alt="\ hat {C} = E \ left \ {C \ right \} \ qquad (9)"></div><br><p>  onde <img src="https://habrastorage.org/getpro/habr/post_images/a73/317/bad/a73317bad2bf7d6419c448e2051efdc9.svg" alt="E \ {* \}">  denota tapete.  expectativa (valor esperado). </p><br><p>  Estamos modelando. </p><br><pre> <code class="python hljs">Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> counter = <span class="hljs-number"><span class="hljs-number">1000</span></span> SNR_dBs = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)] C_MIMO_CU = np.empty((len(SNR_dBs), counter)) C_MIMO_CK = np.empty((len(SNR_dBs), counter)) C_SISO = np.empty((len(SNR_dBs), counter)) C_SIMO = np.empty((len(SNR_dBs), counter)) C_MISO_CU = np.empty((len(SNR_dBs), counter)) C_MISO_CK = np.empty((len(SNR_dBs), counter)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(counter): H_MIMO = (np.random.randn(Mr,Mt) + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) H_SISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] H_SIMO = H_MIMO[:,<span class="hljs-number"><span class="hljs-number">0</span></span>].reshape(Mr,<span class="hljs-number"><span class="hljs-number">1</span></span>) H_MISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,:].reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,Mt) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, SNR_dB <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(SNR_dBs): C_MIMO_CU[idx, c] = openloop_capacity(H_MIMO, SNR_dB) C_MIMO_CK[idx, c] = closedloop_capacity(H_MIMO, SNR_dB) C_SISO[idx, c] = siso_capacity(H_SISO, SNR_dB) C_SIMO[idx, c] = openloop_capacity(H_SIMO, SNR_dB) C_MISO_CU[idx, c] = openloop_capacity(H_MISO, SNR_dB) C_MISO_CK[idx, c] = closedloop_capacity(H_MISO, SNR_dB) C_MIMO_CU_erg = np.mean(C_MIMO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MIMO_CK_erg = np.mean(C_MIMO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SISO_erg = np.mean(C_SISO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SIMO_erg = np.mean(C_SIMO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CU_erg = np.mean(C_MISO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CK_erg = np.mean(C_MISO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">600</span></span>) plt.plot(SNR_dBs, C_MIMO_CU_erg,<span class="hljs-string"><span class="hljs-string">'g-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MIMO_CK_erg,<span class="hljs-string"><span class="hljs-string">'g-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_MISO_CU_erg, <span class="hljs-string"><span class="hljs-string">'m-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MISO_CK_erg, <span class="hljs-string"><span class="hljs-string">'m-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_SISO_erg, <span class="hljs-string"><span class="hljs-string">'k-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=1$'</span></span>) plt.plot(SNR_dBs, C_SIMO_erg, <span class="hljs-string"><span class="hljs-string">'c-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=1$'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">"Ergodic Capacity"</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'SNR (dB)'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Capacity (bps/Hz)'</span></span>) plt.legend() plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/5z/il/br/5zilbr1ijigrduhc3pqpzn7qsuc.png"><br>  <em>Fig. 3.</em>  <em>Curvas de largura de banda para diferentes esquemas de transmiss√£o.</em>  <em>Compare com [1, p.</em>  <em>74]</em> </p><br><p>  Ent√£o n√≥s vemos isso </p><br><ul><li>  espera-se que o caso <strong>MIMO</strong> seja superior aos demais e, com o aumento do <strong>SNR, a</strong> necessidade de conhecimento da matriz do canal diminui (veja o exemplo com infinitos). </li><li>  <strong>O SIMO √©</strong> superior ao <strong>MISO</strong> se o transmissor n√£o <em>conhece</em> o canal (a energia no MISO √© compartilhada em todas as antenas, mas n√£o de maneira ideal) e coincide com o <strong>MISO</strong> no caso de um canal <em>conhecido</em> . </li><li>  <strong>SISO √©</strong> esperado para chicotear na cauda. </li></ul><br><p>  E Sua Majestade reina sobre a <strong>classifica√ß√£o da matriz de canais</strong> , o que n√£o nos permite comparar inequivocamente o aumento no n√∫mero de antenas com o aumento na velocidade de transmiss√£o. </p><br><p>  Essas coisas. </p><br><h2 id="literatura">  Literatura </h2><br><p>  (embora haja um livro, mas que livro!) </p><br><ol><li>  Paulraj, Arogyaswami, Rohit Nabar e Dhananjay Gore. <br>  Introdu√ß√£o √†s comunica√ß√µes sem fio no espa√ßo-tempo.  Cambridge University Press, 2003. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448570/">https://habr.com/ru/post/pt448570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448558/index.html">√â poss√≠vel renderizar imagens realistas sem n√∫meros de ponto flutuante?</a></li>
<li><a href="../pt448560/index.html">Plano de transforma√ß√£o da IA: como gerenciar uma empresa na era da IA?</a></li>
<li><a href="../pt448562/index.html">Google ajuda a pol√≠cia a localizar dispositivos perto de cenas de crime usando dados de localiza√ß√£o</a></li>
<li><a href="../pt448564/index.html">O primeiro do grupo - o primeiro a cair: avalia√ß√£o dos riscos de lideran√ßa em grupos de animais auto-organizados</a></li>
<li><a href="../pt448568/index.html">Como implementar a ISO 27001: instru√ß√µes de uso</a></li>
<li><a href="../pt448572/index.html">A comunica√ß√£o humana est√° se tornando um item de luxo</a></li>
<li><a href="../pt448574/index.html">Uma tarefa da rotina de SEO: solu√ß√£o em tr√™s etapas</a></li>
<li><a href="../pt448576/index.html">Hist√≥ria do Transistor Parte 2: Do Crisol da Guerra</a></li>
<li><a href="../pt448580/index.html">CQ CQ CQ Boas Festas, R√°dio Amador! #WorldAmateurRadioDay</a></li>
<li><a href="../pt448582/index.html">Criando uma calculadora de dicas no Kotlin: como funciona?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>