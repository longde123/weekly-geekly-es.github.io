<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’· ğŸ³ ğŸ‘ Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 1 ğŸ’» ğŸ˜· ğŸ–ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/414505/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  <b>James Mickens:</b> Dari kuliah sebelumnya, kami mempelajari semua tentang serangan buffer overflow, dan hari ini kami akan terus mendiskusikan beberapa metode untuk meluncurkan serangan ini.  Ide dasar di balik serangan buffer overflow adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/ii/9r/h5/ii9rh5-e9oyrvipsizqgmnoln10.jpeg"><br><br>  Pertama-tama, saya perhatikan bahwa serangan ini mempengaruhi beberapa keadaan yang berbeda.  Keadaan pertama yang mereka gunakan adalah bahwa perangkat lunak sistem sering ditulis dalam C. <br><br>  Dengan perangkat lunak sistem, maksud saya database, kompiler, server jaringan, dan sejenisnya.  Anda dapat mengingat hal itu sebagai shell perintah favorit Anda.  Semua "perangkat lunak" ini biasanya ditulis dalam C. Mengapa dalam C?  Karena, pertama, lebih cepat, dan kedua, C dianggap sebagai perakit tingkat tinggi yang paling sesuai dengan kebutuhan berbagai platform perangkat keras.  Oleh karena itu, semua sistem kritis ditulis dalam bahasa pemrograman tingkat rendah ini.  Masalah dengan perangkat lunak yang ditulis dalam C adalah bahwa ia benar-benar menggunakan alamat memori mentah dan tidak memiliki alat atau modul perangkat lunak untuk memeriksanya.  Dalam beberapa kasus, ini dapat menyebabkan konsekuensi bencana. <br><br>  Mengapa tidak ada pemeriksaan indeks array di C, yaitu, tidak ada pemeriksaan perbatasan?  Salah satu alasannya adalah perangkat kerasnya tidak.  Dan orang-orang yang menulis dalam C biasanya menginginkan kecepatan eksekusi program secepat mungkin.  Alasan lain adalah bahwa dalam C, seperti yang akan kita bahas nanti, sebenarnya sangat sulit untuk mendefinisikan semantik dari apa itu pointer dan sejauh mana ia harus bertindak.  Oleh karena itu, dalam beberapa kasus akan sangat sulit untuk mengotomatisasi proses perangkat lunak dalam C. <br>  Mari kita bahas beberapa teknologi yang sebenarnya mencoba membuat beberapa jenis manajemen memori otomatis.  Tetapi, seperti yang akan kita lihat, tidak satu pun dari metode ini yang sepenuhnya "anti peluru". <br><br>  Selain itu, serangan buffer overflow menggunakan pengetahuan arsitektur x86, misalnya, ke arah mana stack tumbuh.  Apa yang dimaksud dengan konvensi pemanggilan fungsi?  Saat Anda mengakses fungsi C, seperti apa tumpukan itu?  Dan ketika Anda memilih objek pada heap, seperti apa struktur utama yang dipilih ini? <br><br>  Mari kita lihat contoh sederhana.  Ini sangat mirip dengan apa yang Anda lihat di kuliah terakhir.  Jadi, di sini kita memiliki permintaan baca standar, dan kemudian kita mendapatkan buffer, di sini, kemudian muncul <b>int</b> kanonik, diikuti oleh perintah <b>mendapat</b> perintah yang terkenal.  Dan di bawah ini kami memiliki hal-hal lain yang diperlukan. <br><br><img src="https://habrastorage.org/webt/ay/gn/u0/aygnu0xbps6qt4pqoarpqe_jjgq.jpeg"><br><br>  Jadi, seperti yang kita diskusikan di kuliah minggu lalu, ini bermasalah, kan?  Karena ini <b>mendapat</b> operasi tidak memeriksa batas buffer.  Jika pengguna mengisi buffer dengan data dan kami menggunakan fungsi tidak aman ini di sini, maka kami sebenarnya bisa meluap buffer.  Kami dapat menulis ulang seluruh isi tumpukan.  Biarkan saya mengingatkan Anda bagaimana tampilannya. <br><br>  Di bagian paling bawah adalah array "i".  Buffer terletak di atasnya, ia memiliki alamat pertama di bagian bawah, dan yang terakhir di bagian atas.  Dalam kasus apa pun, di atas buffer, kami memiliki nilai simpanan indikator gap - nilai simpanan EBP.  Di atasnya adalah alamat pengirim untuk fungsi, dan bahkan lebih tinggi beberapa hal dari bingkai sebelumnya. <br><br>  Dan jangan lupa bahwa di sini di bagian bawah, di sebelah kiri "i", kami memiliki penunjuk tumpukan ESP yang ada di sana, dan penunjuk break baru datang di bagian EBP yang disimpan.  Alamat kembali termasuk ESP, dan sisa dari frame sebelumnya termasuk titik istirahat. <br><br><img src="https://habrastorage.org/webt/xq/y8/7h/xqy87haonu0ryqknxcmuxvessrk.jpeg"><br><br>  Biarkan saya mengingatkan Anda bahwa stack overflows adalah data terakumulasi ke atas, ke arah panah ini ke kanan.  Ketika operasi mendapat dimulai, kita mulai menulis byte ke buffer, pada akhirnya, itu akan mulai menimpa semua yang terletak di hulu.  Pada dasarnya, semuanya akan terlihat akrab bagi Anda. <br><br>  Apa yang dilakukan penyerang untuk memanfaatkan ini?  Pada dasarnya, ia memasuki urutan data yang panjang.  Oleh karena itu, ide kuncinya adalah teknik seperti itu dapat digunakan untuk menyerang. <br><br>  Dan jika alamat pengirim ditangkap oleh penyerang, ia dapat menentukan di mana fungsi akan melompat setelah meluap.  Artinya, satu-satunya hal yang dapat dilakukan seorang peretas adalah mencegat alamat pengirim dan melompat ke mana pun ia mau.  Kebanyakan penyerang menjalankan kode dengan hak istimewa untuk mengontrol proses intersepsi. <br><br>  Jadi, jika proses ini adalah prioritas tinggi, misalnya, dijalankan sebagai root atau admin, tidak peduli apa yang kita sebut superuser dari sistem operasi favorit Anda, sekarang program ini, yang dikendalikan oleh penyerang, dapat melakukan apa pun yang diinginkan menggunakan hak istimewa dari prioritas ini.  Dengan demikian, seorang hacker dapat membaca file atau mengirim spam jika ia merusak server email.  Bahkan dapat mengalahkan firewall, karena ide firewall adalah bahwa ada mesin "baik" di belakangnya, dan yang "buruk" di luarnya.  Biasanya, komputer di dalam firewall â€œsaling percayaâ€ satu sama lain, dan jika Anda berhasil meretas setidaknya satu komputer di dalam jaringan yang dilindungi oleh firewall, itu akan bagus.  Karena sekarang Anda dapat dengan mudah melewati banyak pemeriksaan yang biasanya dilakukan komputer ini mengenai mesin "alien", karena mereka akan menganggap Anda orang yang tepercaya. <br><br>  Ada hal yang harus Anda pikirkan dan saya anggap sebagai mahasiswa: <br><br>  â€œHebat, mereka menunjukkan kepada kita bagaimana meluap buffer, tetapi mengapa sistem operasi tidak bisa menghentikan ini?  Bukankah dia bertindak sebagai seseorang seperti Penjaga Galaxy, yang melindungi hal-hal baik dari kejahatan terjadi di sekitar? " <br><br>  Penting untuk dicatat bahwa OS tidak terus-menerus memonitor Anda.  Dan perangkat keras mengamati, itu mengekstraksi instruksi dan mendekripsi mereka dan melakukan banyak hal seperti itu.  Namun dalam perkiraan pertama, apa yang dilakukan OS?  Pada dasarnya ia mengatur tabel halaman yang memungkinkan aplikasi untuk bekerja, dan jika Anda meminta sistem operasi, misalnya, untuk mengirim paket jaringan, atau Anda ingin membuat semacam permintaan IPC, atau hal serupa, Anda akan beralih ke OS untuk meminta bantuan.  Tetapi sistem operasi tidak mengikuti setiap instruksi yang dijalankan aplikasi Anda.  Dengan kata lain, ketika buffer ini penuh, OS tidak memantau sama sekali bagaimana memori tumpukan ini digunakan.  Semua ruang alamat ini milik Anda, sebagai pemrakarsa proses, dan ini tidak berlaku untuk OS.  Anda dapat melakukan apa pun yang Anda inginkan dengan ini, dan sistem operasi tidak dapat membantu Anda dengan masalah. <br><br>  Nanti kita akan membahas beberapa hal yang dapat dilakukan OS mengenai perangkat keras untuk mempertahankan diri terhadap serangan jenis ini.  Biarkan saya mengingatkan Anda lagi - pada kenyataannya, hanya perangkat keras yang memantau apa yang Anda lakukan dan bereaksi terhadapnya.  Dengan demikian, Anda dapat memanfaatkan beberapa jenis perlindungan khusus, kami akan membahas ini lebih lanjut. <br><br>  Ini adalah bagaimana buffer overflow terlihat.  Bagaimana kita akan memperbaiki semua hal ini? <br><br>  Salah satu cara untuk mencegah buffer overflows adalah dengan hanya menghindari kesalahan dalam kode C. Ini adalah pendekatan yang konstruktif, karena jika program Anda tidak memiliki kesalahan, maka penyerang tidak dapat menggunakannya.  Namun, ini lebih mudah diucapkan daripada dilakukan.  Ada beberapa hal yang sangat sederhana yang dapat dilakukan oleh programmer untuk memberikan "kebersihan" keamanan.  Sebagai contoh, fitur seperti get, yang sekarang kita tahu dapat disebut "masuk," atau "menangkap sistem operasi," yang merupakan pelanggaran keamanan. <br><br>  Jadi, ketika Anda mengkompilasi kode Anda menggunakan kompiler modern seperti GCC atau Visual Studio, mereka akan menunjukkan kelemahan dari fungsi-fungsi tersebut.  Mereka akan berkata: "Hei, Anda menggunakan hal yang berbahaya, lebih baik pertimbangkan untuk menggunakan fungsi app atau fungsi lain yang benar-benar dapat melacak kepatuhan perbatasan."  Ini adalah salah satu hal sederhana yang dapat dilakukan programmer. <br><br>  Tetapi perhatikan bahwa banyak aplikasi sebenarnya memanipulasi buffer tanpa menggunakan semua fungsi ini.  Ini sangat umum di server jaringan yang menetapkan prosedur parsing mereka sendiri dan kemudian memastikan bahwa data diambil dari buffer seperti yang mereka inginkan.  Dengan demikian, cukup membatasi diri pada pemilihan fungsi perintah yang benar, tidak akan mungkin untuk sepenuhnya menyelesaikan masalah. <br><br>  Keadaan lain yang membuat pendekatan ini untuk masalah lebih sulit adalah bahwa tidak selalu jelas bahwa masalah disebabkan oleh kesalahan dalam program yang ditulis dalam C. Jika Anda pernah bekerja pada program skala besar yang ditulis dalam C, Anda tahu , seperti yang terjadi dengan pengidentifikasi fungsi yang memiliki 18 bintang di atas penunjuk void *.  Saya pikir hanya Zeus yang tahu apa artinya ini, bukan?  Dengan bahasa seperti C, bahkan seorang programmer bisa merasa sangat sulit untuk memahami apakah kesalahan telah terjadi atau tidak. <br><br>  Secara umum, salah satu topik utama dari kuliah kami adalah bahwa bahasa C adalah produk setan.  Dan kami menggunakannya hanya karena kami selalu ingin menjadi lebih cepat daripada orang lain, bukan?  Tetapi karena perangkat keras menjadi lebih cepat dan lebih cepat, kami menggunakan bahasa yang lebih maju untuk menulis kode sistem yang banyak.  Namun, tidak selalu masuk akal untuk menulis kode C Anda, bahkan jika Anda pikir itu akan lebih cepat.  Kami akan membahas masalah ini nanti. <br><br><img src="https://habrastorage.org/webt/hy/ki/da/hykidavsdlgsuaiitifmgkyff40.jpeg"><br><br>  Jadi, pendekatan pertama untuk memecahkan masalah adalah untuk menghindari kesalahan dalam kode program C, dan yang kedua adalah membuat alat yang membantu programmer menemukan kesalahan seperti itu.  Contoh alat tersebut adalah analisis kode statis.  Nanti kita akan membicarakannya secara rinci, dan sekarang saya akan mengatakan bahwa analisis statis adalah cara menganalisis kode sumber program Anda bahkan sebelum dimulai, dan membantu mendeteksi potensi masalah. <br><br>  Bayangkan Anda memiliki fungsi seperti itu, sebut saja <b>void foo (int, * p)</b> , ini berisi data integer dan pointer.  Katakanlah itu menyatakan nilai offset integer <b>int off</b> .  Fungsi ini mendeklarasikan pointer lain dan menambahkan offset ke dalamnya: <b>int * z = p + off</b> .  Bahkan sekarang, ketika menulis suatu fungsi, analisis kode statis dapat memberi tahu kita bahwa variabel offset ini tidak diinisialisasi. <br><br><img src="https://habrastorage.org/webt/h3/z3/kj/h3z3kjqa65p3l1bwlzvbf1wu040.jpeg"><br><br>  Dengan demikian, dengan menganalisis program, dimungkinkan untuk menjawab pertanyaan apakah fungsi kita akan berfungsi dengan baik.  Dan dalam contoh ini, sangat sederhana untuk melihat jawaban "tidak, tidak akan" karena tidak ada inisialisasi offset.  Analisis statis adalah perangkat lunak, dan ketika Anda menggunakan kompiler populer untuk membangun kode Anda, itu akan memberi tahu Anda: "Hai, sobat, hal ini tidak diinisialisasi.  Apakah Anda yakin ingin melakukan hal itu? â€  Ini adalah salah satu contoh paling sederhana menggunakan analisis statis. <br><br>  Contoh lain mempertimbangkan kasus ketika kita memiliki cabang fungsi, yaitu pelaksanaannya dalam kondisi tertentu. <br><br><img src="https://habrastorage.org/webt/zk/fy/av/zkfyavkq4pcc2tywksll-hiecfy.jpeg"><br><br>  Jadi, jika offset lebih besar dari 8, <b>jika (off&gt; 8)</b> , maka ini mengarah pada panggilan ke beberapa function <b>bar (off)</b> .  Jadi, kondisi ini memberi tahu kita apa nilai offsetnya.  Bahkan mengabaikan fakta bahwa offset tidak diinisialisasi, saat menganalisis cabang fungsi ini, kami masih menemukan bahwa itu bisa lebih besar dari 8. Oleh karena itu, ketika kami mulai melakukan analisis statis bar, kami menemukan bahwa offset hanya dapat mengambil nilai tertentu.  Saya perhatikan sekali lagi bahwa ini adalah pengantar yang sangat dangkal untuk analisis statis, nanti kita akan mempertimbangkan alat ini secara lebih rinci.  Tetapi contoh ini menunjukkan bagaimana Anda dapat mendeteksi beberapa jenis kesalahan bahkan tanpa mengeksekusi kode. <br><br>  Jadi, satu hal lagi yang mungkin Anda pikirkan adalah melakukan hal yang sama dengan analisis statis.  Ini adalah fuzzing perangkat lunak.  Idenya adalah bahwa Anda mengambil semua fungsi dalam kode program Anda dan kemudian memasukkan nilai acak ke dalamnya.  Dengan demikian, semua opsi untuk nilai dan format kode Anda tumpang tindih.  Artinya, Fuzzing adalah alat untuk mencari kerentanan secara otomatis dengan mengirimkan data yang tidak valid atau data dalam format yang salah ke input program.  Misalnya, Anda memasukkan nilai 2, 4, 8, dan 15 dalam pengujian unit dan Anda mendapatkan pesan bahwa angka 15 mungkin salah, karena semua angka genap, tetapi ganjil. <br><br>  Bahkan, Anda perlu melihat berapa banyak cabang program secara keseluruhan yang memengaruhi kode pengujian Anda, karena ini biasanya merupakan tempat di mana "bug" disembunyikan.  Pemrogram tidak berpikir tentang "celah dan celah" seperti itu dan sebagai hasilnya mereka lulus beberapa tes unit, Anda dapat mengatakan sebagian besar dari tes ini.  Namun, mereka tidak memeriksa semua "celah dan celah" dari program ini, dan di sinilah analisis statis dapat membantu.  Sekali lagi, menggunakan hal-hal seperti konsep pembatasan.  Misalnya, di bagian program kami, ini adalah kondisi untuk bercabang fungsi yang mendefinisikan offset lebih dari delapan.  Dengan demikian, kita dapat mengetahui bahwa perpindahan ini statis.  Dan jika kita menggunakan generasi input data Fuzzing otomatis berdasarkan pembatasan ini, maka kita dapat memastikan bahwa salah satu nilai input untuk offset akan kurang dari 8, satu akan menjadi 8 dan satu akan lebih dari 8. Apakah itu jelas? <br><br><img src="https://habrastorage.org/webt/mc/tn/ty/mctntyvh1aqv58xvu6p1zjvqxo8.jpeg"><br><br>  Jadi ini adalah ide utama di balik konsep menciptakan alat untuk membantu programmer menemukan kesalahan.  Bahkan analisis kode parsial dapat sangat berguna ketika bekerja dengan bahasa C. Banyak alat yang akan kita lihat berfungsi untuk mencegah buffer overflows atau memeriksa inisialisasi variabel yang tidak dapat mendeteksi semua masalah kode program.  Tetapi mereka dapat bermanfaat praktis dalam meningkatkan keamanan program-program ini.  Kerugian dari alat-alat ini adalah bahwa mereka tidak lengkap.  Kemajuan prospektif bukanlah kemajuan yang lengkap.  Oleh karena itu, Anda perlu secara aktif mengeksplorasi masalah perlindungan terhadap eksploitasi baik dalam program yang ditulis dalam C dan dalam program lain.  Kami memeriksa 2 pendekatan untuk memecahkan masalah perlindungan buffer overflow, tetapi ada beberapa pendekatan lain. <br><br>  Jadi, pendekatan ketiga adalah penggunaan bahasa memori-aman, atau bahasa yang menjamin keamanan memori.  Bahasa-bahasa ini termasuk Python, Java, c #.  Saya tidak ingin menempatkan Perl setara dengan mereka, karena digunakan oleh "orang jahat."  Dengan cara ini Anda dapat menggunakan bahasa memori yang aman, dan sepertinya ini adalah hal yang paling jelas yang dapat Anda lakukan.  Saya baru saja menjelaskan kepada Anda bahwa pada dasarnya C adalah encoder perakitan tingkat tinggi, tetapi memberikan pointer mentah dan hal-hal lain yang tidak diinginkan, jadi mengapa tidak hanya menggunakan salah satu dari bahasa pemrograman tingkat tinggi ini? <br><br>  Ada beberapa alasan untuk ini.  Pertama, dalam bahasa ini ada banyak elemen kode yang diwarisi dari C. Semuanya baik-baik saja jika Anda memulai proyek baru dan menggunakan salah satu bahasa tingkat tinggi yang menjamin keamanan memori untuknya.  Tetapi bagaimana jika Anda diberi file biner besar atau distribusi sumber besar yang ditulis dalam C dan dipelihara selama 10-15 tahun, ini adalah proyek generasi, maksud saya bahkan anak-anak kita akan terus mengerjakannya ?  Dalam hal ini, Anda tidak akan bisa mengatakan: "Saya hanya menulis ulang semuanya dalam C # dan mengubah dunia!". <br><br>  Dan masalahnya bukan hanya dalam bahasa C, ada sistem yang Anda harus takut bahkan lebih, karena mereka menggunakan kode Fortran dan COBOL, hal-hal dari Perang Saudara.  Mengapa ini terjadi?  Karena, sebagai insinyur, kami ingin berpikir bahwa kami dapat membangun semuanya sendiri, dan itu akan luar biasa, akan seperti yang saya inginkan, dan saya akan memanggil variabel saya seperti yang saya inginkan. <br><br>  Tetapi di dunia nyata ini tidak terjadi.  Anda muncul di tempat kerja, dan Anda memiliki sistem ini yang sudah ada, dan Anda melihat dasar kode dan berpikir mengapa tidak melakukan apa yang dibutuhkan?  Dan kemudian mereka berkata kepada Anda, "Dengar, kami akan melakukan semua yang Anda inginkan, tetapi hanya dalam versi kedua dari program ini, dan sekarang Anda harus membuat apa yang harus kami kerjakan, karena kalau tidak pelanggan akan mengambil uang mereka kembali." <br><br>  Jadi, bagaimana kita menangani masalah besar penggunaan paksa kode warisan?  Seperti yang Anda ketahui, salah satu kelebihan sistem dengan definisi batas yang salah adalah bahwa mereka bekerja dengan sempurna dengan kode yang ketinggalan zaman ini.  Ini adalah salah satu alasan mengapa Anda tidak bisa menghilangkan masalah buffer overflow dengan hanya beralih ke bahasa yang menyediakan penggunaan memori yang aman. <br><br><img src="https://habrastorage.org/webt/z5/hp/1b/z5hp1bdiuxbyazad1amzu-_iezm.jpeg"><br><br>  Bagaimana jika kita membutuhkan akses tingkat rendah ke perangkat keras?  Misalnya, memperbarui driver dan hal-hal lain. <br><br>  Jadi, masalah lain muncul jika Anda memerlukan akses tingkat rendah ke peralatan, yang terjadi saat menulis driver untuk beberapa perangkat.  Dalam hal ini, Anda benar-benar membutuhkan kelebihan yang diberikan C, misalnya, kemampuan untuk melihat register dan elemen fungsi serupa. <br><br>  Lebih lanjut, kebutuhan untuk menggunakan C muncul ketika Anda khawatir tentang kinerja sistem.  ,     ,   ,      . ,       ,          .  ,  ,         memory-safe .    ,   JIT. ,     Java,  Java Script.     ,  ,      Â«Â».     ,    .      ,         Â«Â»  x86. <br><br>          ,           ,  -. ,     ,  JVM, -   Java.      ,    -        . ,  - JVM   ,       .      ,    ,       .      .        ,    ,   . <br><br>           ,  ,     86.   JIT-     ,        .  JIT-       ,   . <br><br>       ,       JavaScript     ,     , Â«Â» 32-  ,       .       JIT-,         Â«Â»  . ,    ,  JIT-, ,      ,    . <br><br><img src="https://habrastorage.org/webt/yx/zv/9l/yxzv9lj9b57b09rpogi_ojgabs8.jpeg"><br><br>     Â«Â» ,   asm.js â€“  JavaScript, ,   ,   .   ,    , ,    JavaScript     ,    .            JavaScript,       JavaScript,     C  ++. <br><br>   ,       -,   IO.      .  ,           ,   ,    ,   .      Â«Â»  ,               . <br><br>         . ,   -            .     ,      C  C++,    ,       .        Python, ,  ,    .          .         . <br><br> ,     ,   ,    . <br><br>   ,        .         ,    .      ,          .   ,          Â«Â»  ,       .   ,        C  C++,        . <br><br> ,           ?        , , ?       ? <br><br>       . ,     â€“      .  ,  -       ,         .   ,     .  , -,    ,        .        IP , ,            .  ,     -          .           ,   ,        .      ,      ,           Â«Â» . <br><br> ,  ,  ,     ,   ,   ,         .     ,    -  ,   .    ,        ,             ,      . ,   ,    ,        ,  ,       ,      . <br><br><img src="https://habrastorage.org/webt/gk/41/p2/gk41p2phaguhv4easepocrejn4q.jpeg"><br><br> ,      .   stack canaries, Â« Â»,         ,         .   Â« Â»   ,           ,           ,     .  ,       ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita menggambar diagram tumpukan kita. </font><font style="vertical-align: inherit;">Kita perlu memastikan bahwa penyerang pertama "masuk ke kenari" sebelum dia sampai ke alamat pengirim. </font><font style="vertical-align: inherit;">Dan jika kita dapat mendeteksi ini sebelum kembali dari fungsi, maka kita dapat mendeteksi "kejahatan." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28:30 menit </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lanjutan:</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus MIT "Keamanan Sistem Komputer".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuliah 2: "Kontrol serangan hacker", bagian 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi lengkap dari kursus ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414505/">https://habr.com/ru/post/id414505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414495/index.html">toString: Hebat dan Mengerikan</a></li>
<li><a href="../id414497/index.html">API UI Consulo dari ide ke prototipe</a></li>
<li><a href="../id414499/index.html">Laporan Club of Rome 2018, Bab 1.1.3: â€œDunia yang Kosong versus Perdamaian Penuhâ€</a></li>
<li><a href="../id414501/index.html">Laporan Club of Rome 2018, Bab 3.11: â€œReformasi Sektor Keuanganâ€</a></li>
<li><a href="../id414503/index.html">Intel NUC Hades Canyon dengan AMD Vega Graphics - VR or Not VR?</a></li>
<li><a href="../id414507/index.html">Bagaimana keyboard terprogram paling populer untuk perdagangan telah berubah: kisah keyboard Bloomberg</a></li>
<li><a href="../id414509/index.html">Kami menghubungkan setiap (hampir) pelacak GPS (menggunakan Sinotrack ST-901 sebagai contoh) ke rumah pintar HomeAssistant</a></li>
<li><a href="../id414513/index.html">27 alat pengembangan web open source yang bagus</a></li>
<li><a href="../id414515/index.html">Pelajaran Optimasi Server Aplikasi Web</a></li>
<li><a href="../id414517/index.html">Ilmuwan Oxford: probabilitas bahwa kita sendirian di bagian alam semesta yang dapat diperkirakan jauh lebih tinggi daripada nol</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>