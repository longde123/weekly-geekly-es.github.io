<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ»â€ğŸ« ğŸ¤˜ğŸ» ğŸ—¾ Interaksi klien-server dalam perangkat PvP shooter dan server game baru: masalah dan solusi ğŸ•‹ ğŸ¡ ğŸ¤˜ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel seri sebelumnya (semua tautan di akhir artikel) tentang pengembangan penembak cepat baru, kami memeriksa mekanisme arsitektur utama logi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interaksi klien-server dalam perangkat PvP shooter dan server game baru: masalah dan solusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/420019/">  Dalam artikel seri sebelumnya (semua tautan di akhir artikel) tentang pengembangan penembak cepat baru, kami memeriksa mekanisme arsitektur utama logika game berdasarkan ECS, dan fitur-fitur bekerja dengan penembak pada klien, khususnya, implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem untuk memprediksi tindakan pemain lokal</a> untuk meningkatkan respons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemain</a> terhadap permainan. .  Kali ini kita akan membahas lebih rinci tentang masalah interaksi klien-server dalam kondisi koneksi jaringan seluler yang buruk dan cara-cara untuk meningkatkan kualitas permainan bagi pengguna akhir.  Saya juga akan menjelaskan secara singkat arsitektur server game. <br><br><img src="https://habrastorage.org/webt/py/lp/8q/pylp8q_ki2el3odmsmd_h5ppqh0.jpeg"><br><a name="habracut"></a><br><br>  Selama pengembangan PvP sinkron baru untuk perangkat seluler, kami mengalami masalah khas genre: <br><br><ol><li>  Kualitas koneksi klien seluler buruk.  Ini adalah ping rata-rata yang relatif tinggi di wilayah 200-250 ms, dan distribusi waktu ping yang tidak stabil dengan mempertimbangkan perubahan titik akses (walaupun, bertentangan dengan kepercayaan umum, persentase kehilangan paket di jaringan seluler 3G + cukup rendah - sekitar 1%). </li><li>  Solusi teknis yang ada adalah kerangka kerja mengerikan yang mendorong pengembang ke kerangka kerja ketat. </li></ol><br>  Kami membuat prototipe pertama di UNet, meskipun memberlakukan pembatasan skalabilitas, kontrol atas komponen jaringan dan menambahkan ketergantungan pada koneksi yang berubah-ubah dari klien master.  Kemudian kami beralih ke netcode yang ditulis sendiri di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server Photon</a> , tetapi lebih lanjut tentang itu nanti. <br><br>  Pertimbangkan mekanisme untuk mengatur interaksi antara klien dalam game PvP sinkron.  Yang paling populer di antaranya: <br><br><ul><li>  <b>P2P atau peer-to-peer</b> .  Semua logika pertandingan di-host di salah satu klien dan hampir tidak memerlukan biaya lalu lintas dari kami.  Tetapi ruang lingkup untuk curang dan persyaratan tinggi untuk klien yang menjadi tuan rumah pertandingan, serta keterbatasan NAT tidak memungkinkan kami untuk mengambil solusi ini untuk permainan seluler. </li><li>  <b>Server klien</b> .  Sebaliknya, dedicated server memungkinkan Anda untuk sepenuhnya mengendalikan segala sesuatu yang terjadi dalam pertandingan (selamat tinggal, curang), dan kinerjanya memungkinkan Anda untuk menghitung beberapa hal khusus untuk proyek kami.  Juga, banyak penyedia hosting besar memiliki struktur subnet mereka sendiri, yang memberikan penundaan minimal bagi pengguna akhir. </li></ul><br>  Diputuskan untuk menulis server otoriter. <br><br><img src="https://habrastorage.org/webt/x4/a4/ku/x4a4kunfi3lnbjqeghpddh-hsz8.jpeg"><br>  <i>Jaringan dengan peer-to-peer (kiri) dan client-server (kanan)</i> <br><br><h3>  Transfer data antara klien dan server </h3><br>  Kami menggunakan <b>Server Photon</b> - ini memungkinkan kami untuk dengan cepat menyebarkan infrastruktur yang diperlukan untuk proyek berdasarkan skema yang sudah berjalan selama bertahun-tahun (dalam Robot Perang kami menggunakannya). <br><br>  Server Photon secara eksklusif merupakan solusi transportasi bagi kami, tanpa desain tingkat tinggi yang sangat terkait dengan mesin permainan tertentu.  Yang memberikan beberapa keuntungan, karena perpustakaan transfer data dapat diganti kapan saja. <br><br>  Server game adalah aplikasi multi-utas dalam wadah Foton.  Aliran terpisah dibuat untuk setiap kecocokan, yang merangkum seluruh logika kerja dan mencegah pengaruh satu kecocokan pada kecocokan lainnya.  Semua koneksi server dikendalikan oleh Photon, dan data yang datang dari klien ditambahkan ke antrian, yang kemudian diurai menjadi ECS. <br><br><img src="https://habrastorage.org/webt/j-/ws/wm/j-wswmt08qutnwc1jha0dgazkfo.jpeg"><br>  <i>Skema umum aliran pertandingan dalam wadah Server Photon</i> <br><br>  Setiap pertandingan terdiri dari beberapa tahap: <br><br><ol><li>  Antrean klien game dalam layanan yang disebut pencocokan.  Segera setelah jumlah pemain yang memenuhi persyaratan tertentu dikumpulkan di dalamnya, ia melaporkan hal ini ke server permainan menggunakan gRPC.  Pada saat yang sama, semua data yang diperlukan untuk membuat game dikirimkan. <br><br><img src="https://habrastorage.org/webt/e_/rq/qp/e_rqqp5kiwrz-mxwbtkeuqptfpy.jpeg"><br>  <i>Skema umum untuk membuat kecocokan</i> </li><li>  Di server permainan, inisialisasi pertandingan dimulai.  Semua parameter kecocokan diproses dan disiapkan, termasuk data peta, serta semua data pelanggan yang diterima dari layanan pembuatan kecocokan.  Memproses dan menyiapkan data menyiratkan bahwa kami mem-parsing semua data yang diperlukan dan menulisnya ke subset entitas khusus yang kami sebut RuleBook.  Ini menyimpan statistik pertandingan (yang tidak berubah selama kursus) dan akan dikirimkan ke semua klien selama koneksi dan otorisasi pada server game sekali atau ketika menghubungkan kembali setelah kehilangan koneksi.  Data pertandingan statis termasuk konfigurasi peta (penyajian peta oleh komponen ECS yang menghubungkannya dengan mesin fisik), data pelanggan (nama panggilan, seperangkat senjata yang mereka miliki dan tidak berubah selama pertempuran, dll.). </li><li>  Menjalankan pertandingan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem ECS</a> yang membentuk gim di server mulai bekerja.  Semua sistem berdetak 30 frame per detik. </li><li>  Setiap frame membaca dan membongkar input atau salinan pemain jika pemain tidak mengirim input mereka dalam interval tertentu. </li><li>  Kemudian, dalam bingkai yang sama, input diproses dalam sistem ECS, yaitu: perubahan status pemain;  dunia yang dia pengaruhi dengan masukannya;  dan status pemain lain. </li><li>  Pada akhir frame, negara dunia yang dihasilkan dikemas untuk pemain dan dikirim melalui jaringan. </li><li>  Pada akhir pertandingan, hasilnya dikirim ke klien dan ke layanan mikro, yang memproses hadiah untuk pertempuran menggunakan gRPC, serta analis untuk pertandingan. </li><li>  Setelah itu, aliran korek terjepit dan aliran menutup. </li></ol><br><img src="https://habrastorage.org/webt/02/8i/jl/028ijlnhor-evm6llkmfbiguf3s.jpeg"><br>  <i>Urutan tindakan di server dalam satu bingkai</i> <br><br>  Di sisi klien, proses menghubungkan ke pertandingan adalah sebagai berikut: <br><br><ol><li>  Pertama, permintaan dibuat untuk antri dalam layanan untuk membuat pertandingan melalui websocket dengan serialisasi melalui protobuf. </li><li>  Saat membuat pertandingan, layanan ini memberi tahu klien tentang alamat server game dan mentransfer payload tambahan yang diperlukan oleh klien sebelum pertandingan.  Sekarang klien siap untuk memulai proses otorisasi di server game. </li><li>  Klien membuat soket UDP dan mulai mengirim permintaan ke server game untuk terhubung ke pertandingan bersama dengan beberapa kredensial.  Server sudah menunggu klien ini.  Saat terhubung, ia memberinya semua data yang diperlukan untuk memulai permainan dan menampilkan dunia untuk pertama kalinya.  Ini termasuk: RuleBook (daftar data statis untuk pertandingan), serta StringIntMap, yang kami sebut sebagai data tentang garis yang digunakan dalam gameplay yang akan diidentifikasi oleh bilangan bulat selama pertandingan).  Ini diperlukan untuk menghemat lalu lintas, karena  garis yang lewat setiap frame menciptakan beban signifikan pada jaringan.  Misalnya, semua nama pemain, nama kelas, pengidentifikasi senjata, akun, dan sejenisnya, semua informasi ditulis ke StringIntMap, di mana ia dikodekan menggunakan data integer sederhana. </li></ol><br>  Ketika seorang pemain secara langsung mempengaruhi pengguna lain (menyebabkan kerusakan, memaksakan efek, dll.), Sejarah negara dicari di server untuk membandingkan dunia game yang benar-benar dilihat oleh klien dalam centang simulasi spesifik dengan apa yang terjadi di server dengan yang lain pada saat itu entitas game. <br><br>  Misalnya, Anda menembak klien Anda.  Bagi Anda, ini terjadi secara instan, tetapi klien telah "melarikan diri" untuk beberapa waktu ke depan dibandingkan dengan dunia sekitarnya, yang ia tampilkan.  Oleh karena itu, karena prediksi lokal mengenai perilaku pemain, server perlu memahami di mana dan dalam kondisi apa lawan berada pada saat tembakan (mungkin mereka sudah mati atau, sebaliknya, kebal).  Server memeriksa semua faktor dan memberikan putusannya atas kerusakan yang terjadi. <br><br><img src="https://habrastorage.org/webt/os/fb/hh/osfbhh4iwrw6gk2hvtpqp8co2sw.jpeg"><br>  <i>Permintaan untuk membuat pertandingan, menghubungkan ke server game dan otorisasi</i> <br><br><h3>  Serialisasi dan deserialisasi, pengemasan, dan pembongkaran byte pertama pertandingan </h3><br>  Kami memiliki serialisasi data biner yang dipatenkan, dan untuk transfer data kami menggunakan UDP. <br><br>  UDP adalah opsi yang paling jelas untuk mengirim pesan dengan cepat antara klien dan server, di mana biasanya jauh lebih penting untuk menampilkan data sesegera mungkin daripada menampilkannya secara prinsip.  Paket yang hilang membuat penyesuaian, tetapi masalah diselesaikan untuk setiap kasus secara individual, seperti  Karena data terus-menerus berasal dari klien ke server dan kembali, Anda dapat memasukkan konsep koneksi antara klien dan server. <br><br>  Untuk membuat kode yang optimal dan nyaman berdasarkan deskripsi deklaratif dari struktur ECS kami, kami menggunakan pembuatan kode.  Saat membuat komponen, aturan serialisasi dan deserialisasi juga dibuat untuknya.  Serialisasi didasarkan pada paket biner khusus yang memungkinkan Anda mengemas data dengan cara yang paling ekonomis.  Kumpulan byte yang diperoleh selama operasinya bukan yang paling optimal, tetapi memungkinkan Anda untuk membuat aliran dari mana Anda dapat membaca beberapa paket data tanpa perlu deserialisasi lengkap. <br><br>  Batas transfer data sebesar 1500 byte (alias MTU), pada kenyataannya, adalah ukuran paket maksimum yang dapat ditransfer melalui Ethernet.  Properti ini dapat dikonfigurasi pada setiap hop jaringan dan seringkali bahkan di bawah 1500 byte.  Apa yang terjadi jika saya mengirim paket yang lebih besar dari 1500 byte?  Fragmentasi paket dimulai.  Yaitu  setiap paket akan secara paksa dibagi menjadi beberapa bagian, yang akan dikirim secara terpisah dari satu antarmuka ke antarmuka lainnya.  Mereka dapat dikirim dengan rute yang sangat berbeda, dan waktu untuk menerima paket tersebut dapat meningkat secara signifikan sebelum lapisan jaringan mengeluarkan paket terpaku ke aplikasi Anda. <br><br>  Dalam hal Photon, perpustakaan secara paksa mulai mengirim paket-paket seperti itu dalam mode UDP yang andal.  Yaitu  Foton akan menunggu setiap fragmen paket, serta meneruskan fragmen yang hilang jika hilang selama penerusan.  Tetapi pekerjaan seperti itu dari bagian jaringan tidak dapat diterima dalam permainan di mana penundaan jaringan minimum diperlukan.  Oleh karena itu, disarankan untuk mengurangi ukuran paket yang diteruskan ke minimum dan tidak melebihi 1500 byte yang direkomendasikan (dalam permainan kami, ukuran satu negara penuh dunia tidak melebihi 1000 byte; ukuran paket dengan kompresi delta adalah 200 byte). <br><br>  Setiap paket dari server memiliki header pendek yang berisi beberapa byte yang menggambarkan jenis paket.  Klien pertama-tama membongkar set byte ini dan menentukan paket mana yang kita hadapi.  Kami sangat bergantung pada properti ini dari mekanisme deserialisasi kami selama otorisasi: agar tidak melebihi ukuran paket yang disarankan 1500 byte, kami memecah paket RuleBook dan StringIntMap ke dalam beberapa tahap;  dan untuk memahami apa yang sebenarnya kita dapatkan dari server - aturan main atau status itu sendiri - kita menggunakan header paket. <br><br>  Ketika mengembangkan fitur-fitur baru proyek, ukuran paket terus berkembang.  Ketika kami mengalami masalah ini, diputuskan untuk menulis sistem kompresi delta kami sendiri, serta kliping data kontekstual yang tidak dibutuhkan klien. <br><br><h3>  Optimasi lalu lintas jaringan yang sensitif terhadap konteks.  Kompresi Delta </h3><br>  Kliping data kontekstual ditulis secara manual berdasarkan data apa yang dibutuhkan klien untuk menampilkan dunia dan prediksi lokal dari data mereka sendiri agar berfungsi dengan benar.  Kemudian, kompresi delta diterapkan pada data yang tersisa. <br><br>  Permainan kami setiap kutu menghasilkan keadaan dunia baru, yang harus dikemas dan diteruskan ke pelanggan.  Biasanya, kompresi delta adalah untuk pertama mengirim keadaan penuh dengan semua data yang diperlukan kepada klien, dan kemudian hanya mengirim perubahan pada data ini.  Ini dapat direpresentasikan sebagai berikut: <br><br>  <i>deltaGameState = newGameState - prevGameState</i> <br><br>  Tetapi untuk setiap klien, data yang berbeda dikirim dan hilangnya hanya satu paket dapat mengarah pada kenyataan bahwa Anda harus meneruskan keadaan penuh dunia. <br><br>  Meneruskan status penuh dunia adalah tugas yang agak mahal untuk jaringan.  Oleh karena itu, kami memodifikasi pendekatan dan mengirimkan perbedaan antara kondisi dunia saat ini yang diproses dan yang diterima secara tepat oleh klien.  Untuk melakukan ini, klien dalam paketnya dengan input juga mengirimkan nomor kutu, yang merupakan pengidentifikasi unik dari status permainan yang telah ia terima dengan tepat.  Sekarang server tahu berdasarkan kondisi apa yang diperlukan untuk membangun kompresi delta.  Klien biasanya tidak punya waktu untuk mengirimi server nomor kutu yang dimilikinya sebelum server menyiapkan bingkai berikutnya dengan data.  Oleh karena itu, pada klien ada sejarah negara server di dunia, yang diterapkan patch deltaGameState oleh server. <br><br><img src="https://habrastorage.org/webt/ji/uo/ka/jiuokasgdo-wgmgmzbmchlb1gvm.jpeg"><br>  <i>Ilustrasi frekuensi interaksi klien-server dalam proyek</i> <br><br>  Mari kita membahas lebih detail tentang apa yang dikirim klien.  Dalam penembak klasik, paket seperti itu disebut ClientCmd dan berisi informasi tentang tombol yang ditekan pemain dan waktu tim dibuat.  Di dalam paket input, kami mengirim lebih banyak data: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputSample</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,        public uint WorldTick; // ,      ,     public uint PlayerSimulationTick; //   .  (idle, , ) public MovementMagnitude MovementMagnitude; //  ,   public float MovementAngle; //    public AimMagnitude AimMagnitude; //    public float AimAngle; //   ,       public uint ShotTarget; //    ,        public float AimMagnitudeCompressed; }</span></span></code> </pre> <br><br>  Ada beberapa poin menarik.  Pertama, klien memberi tahu server tempat centang melihat semua objek dari dunia game di sekitarnya yang tidak dapat diprediksi (WorldTick).  Tampaknya klien mampu "menghentikan" waktu untuk dunia, dan berlari serta menembak semua orang sendiri karena prediksi lokal.  Ini tidak benar.  Kami hanya mempercayai seperangkat nilai terbatas dari klien dan jangan biarkan dia menembak ke masa lalu selama lebih dari 1 detik.  Bidang WorldTick juga digunakan sebagai paket pengakuan, atas dasar mana kompresi delta dibangun. <br><br>  Anda dapat menemukan nomor floating point dalam suatu paket.  Biasanya, nilai-nilai tersebut sering digunakan untuk mengambil bacaan dari joystick pemain, tetapi nilai-nilai tersebut tidak ditransmisikan dengan baik melalui jaringan, karena memiliki "bouncing" besar dan biasanya terlalu akurat.  Kami menghitung angka-angka tersebut dan mengemasnya menggunakan biner packer sehingga tidak melebihi nilai integer yang dapat ditampung dalam beberapa bit, tergantung pada ukurannya.  Dengan demikian, pengemasan input dari joystick pengarah rusak: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(s.AimMagnitudeCompressed) &lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Epsilon) { packer.PackByte(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { packer.PackByte(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step = <span class="hljs-number"><span class="hljs-number">0.001f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000    , //          //     packer.PackUInt32((uint)((s.AimMagnitudeCompressed - min)/step), CalcFloatRangeBits(min, max, step)); }</span></span></code> </pre> <br><br>  Fitur menarik lainnya saat mengirim input adalah beberapa perintah dapat dikirim beberapa kali.  Sangat sering kita ditanya apa yang harus dilakukan jika seseorang telah menekan kemampuan tertinggi, dan paket dengan inputnya telah hilang?  Kami hanya mengirim input ini beberapa kali.  Ini terlihat seperti pengiriman yang dijamin, tetapi lebih fleksibel dan lebih cepat.  Karena  ukuran paket input sangat kecil, kita dapat mengemas beberapa input pemain yang berdekatan ke dalam paket yang dihasilkan.  Saat ini, ukuran jendela yang menentukan jumlahnya adalah lima. <br><br><img src="https://habrastorage.org/webt/gi/08/0g/gi080gxlym3kf7n801ah19gjeq8.jpeg"><br>  <i>Paket input yang dihasilkan pada klien di setiap centang dan dikirim ke server</i> <br><br>  Transmisi data jenis ini adalah yang tercepat dan paling andal untuk menyelesaikan masalah kita tanpa menggunakan UDP yang andal.  Kami melanjutkan dari fakta bahwa kemungkinan kehilangan sejumlah paket dalam satu baris sangat rendah dan merupakan indikator penurunan kualitas jaringan secara keseluruhan.  Jika ini terjadi, server cukup menyalin input yang terakhir diterima dari pemain dan menerapkannya, berharap itu tidak berubah. <br><br>  Jika klien menyadari bahwa ia tidak menerima paket melalui jaringan untuk waktu yang sangat lama, proses menghubungkan kembali ke server dimulai.  Server, untuk bagiannya, memantau bahwa antrian input dari pemain selesai. <br><br><h3>  Alih-alih kesimpulan dan referensi </h3><br>  Ada banyak sistem lain di server game yang bertanggung jawab untuk mendeteksi, men-debug, dan mengedit pertandingan "by the gain", desainer game memperbarui konfigurasi tanpa memulai ulang, masuk, dan memantau status server.  Kami juga ingin menulis tentang ini secara lebih rinci, tetapi secara terpisah. <br><br>  Pertama-tama, ketika mengembangkan permainan jaringan pada platform seluler, Anda harus memperhatikan operasi yang benar dari klien Anda dengan ping tinggi (sekitar 200 ms), kehilangan data yang sedikit lebih sering, serta ukuran data yang dikirim.  Dan Anda harus secara jelas masuk ke dalam batas paket 1500 byte untuk menghindari fragmentasi dan penundaan lalu lintas. <br><br>  Tautan yang bermanfaat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://gafferongames.com/post/udp_vs_tcp/</a> adalah artikel yang bagus untuk memilih antara TCP dan UDP untuk game jaringan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://api.unrealengine.com/udk/Three/NetworkingOverview.html</a> - deskripsi model server di Unreal Engine. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://ieeexplore.ieee.org/document/5360721</a> - studi tentang kualitas jaringan koneksi seluler. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://ithare.com/mmog-rtt-input-lag-and-how-to-mitigate-them/</a> - interaksi jaringan dalam game yang bergerak cepat. </li></ul><br>  Artikel sebelumnya tentang proyek: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana Kami Mengayun di Mobile Fast Paced Shooter: Teknologi dan Pendekatan</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana dan mengapa kami menulis ECS kami</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Ketika kami menulis kode jaringan penembak PvP seluler: sinkronisasi pemain pada klien</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420019/">https://habr.com/ru/post/id420019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420009/index.html">Seluk-beluk desain produk</a></li>
<li><a href="../id420011/index.html">Cara Memilih Printer 3D: Panduan Pemula</a></li>
<li><a href="../id420013/index.html">Pencarian Alamat MAC pada Switch Juniper</a></li>
<li><a href="../id420015/index.html">Cara mengukur kecepatan saluran Internet dengan benar dan berhenti terlihat seperti orang bodoh di mata penyedia Anda</a></li>
<li><a href="../id420017/index.html">Seni mengambil kata sandi</a></li>
<li><a href="../id420021/index.html">Mengapa Anda perlu Splunk? Internet Benda dan Data Industri</a></li>
<li><a href="../id420023/index.html">Menyimpan status di aplikasi android</a></li>
<li><a href="../id420025/index.html">Pertanian cerdas. Akan seperti apa dia?</a></li>
<li><a href="../id420029/index.html">Bagaimana kita di 1C: Perusahaan memecahkan sistem persamaan aljabar</a></li>
<li><a href="../id420031/index.html">Menggambar dengan Target Render di Mesin Unreal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>