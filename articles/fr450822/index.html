<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💶 🚴🏾 🚜 Cadres en voie de disparition 💭 ⚪️ ☣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi utilisons-nous des cadres? Angular, React et Vue nous aident à créer des applications Web complexes: structurer le code, gérer l'état et déve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cadres en voie de disparition</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450822/">  Pourquoi utilisons-nous des cadres?  Angular, React et Vue nous aident à créer des applications Web complexes: structurer le code, gérer l'état et développer des interfaces complexes.  Au cours de la dernière décennie, les cadres sont devenus la norme.  Un standard cher.  Depuis que les frameworks sont entrés en service, JS a été très gonflé.  Il y a plus de pages pesant plusieurs mégaoctets, et une partie importante de ce volume est le cadre lui-même.  Cela semble un peu, mais pour l'utilisateur, c'est critique - au téléphone ou sur Internet faible, la page peut même ne pas se charger.  C'est un problème. <br><br><img src="https://habrastorage.org/webt/l4/wd/k7/l4wdk7s_mctdg-p6ctwusbwiq7m.png"><br><br>  En plus d'être en surpoids, les cadres classiques présentent de nombreux autres inconvénients et ne conviennent pas à tous les projets.  Ces problèmes sont résolus dans des «cadres menacés».  Quelle est cette nouvelle tendance, pourquoi n'est-elle pas «un autre framework JS», mais une bonne idée et comment des frameworks mystérieux peuvent améliorer nos applications, dira Pavel Malyshev. <br><a name="habracut"></a><br>  <b>À propos de l'orateur: Pavel Malyshev</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">PaulMaly</a> ) - fullstack avec plus de 10 ans d'expérience.  Il travaille chez Mustlab, qui sous-traite le Web, la Smart TV et les appareils mobiles, ainsi que l'IoT.  Un évangéliste du cadre Svelte JS en Russie, dirige un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe Telegram</a> sur ce sujet. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NvNe4nKmZT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Ce qui ne devrait pas figurer dans le rapport </h2><br>  Quand j'ai considéré cette histoire, j'ai décidé qu'elle devrait être non standard.  Par conséquent, j'ai écrit ce qui ne devrait pas être ici.  On ne mettra pas l'accent sur un cadre spécifique, des comparaisons avec d'autres cadres - ils sont fatigués de tout le monde et, bien sûr, je ne veux pas être le capitaine Obvious.  Tout cela n'aurait pas dû être dans mon histoire, mais, malheureusement, ce sera ... <br><br>  Lorsque vous avez lu le nom, vous avez probablement pensé qu'il y avait un autre cadre et qu'il y avait déjà tout un zoo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/324/d9c/b9e324d9cd7205923e0805c009b820e5.png"><br><br>  Il me semble que si un nouveau cadre apparaît, alors les anciens ne satisfont pas certains de nos besoins.  Peut-être que les besoins eux-mêmes changent avec le temps, et c'est pourquoi nous avons besoin de nouvelles solutions - plus efficaces et plus intéressantes.  Par conséquent, je vous demande d'aborder ce qui précède de ce point de vue avec un esprit ouvert et de considérer les cadres disparaissants comme un nouvel outil qui peut vous aider dans votre travail. <br><br>  Pour commencer, découvrons qui est qui. <br><br><h2>  Qui est qui </h2><br>  J'ai pris les trois grands et Svelte.  Il est intéressant de noter que chaque outil se caractérise différemment.  <b>Angular se</b> positionne comme un cadre pour toutes les occasions, «tout dans une boîte».  <b>React</b> imite une bibliothèque: «Je suis aussi petite qu'une bibliothèque», mais avec toute l'infrastructure, c'est aussi un cadre à part entière.  <b>Vue</b> est censé être un framework progressif.  Vous pouvez y basculer avec jQuery en transférant séquentiellement le code, en commençant presque par la balise de <code>script</code> habituelle sans collecteurs.  <b>Svelte</b> est un cadre qui disparaît comme par magie.  Wat? <br><br>  Voyons de quoi je parle. <br><br><h2>  Pourquoi les cadres ont-ils commencé à disparaître? </h2><br><blockquote>  Nous envoyons trop de code à nos utilisateurs. </blockquote><br>  Nos clients deviennent de plus en plus mobiles, mais la technologie Internet n'est pas bonne partout - même la 3G n'est pas partout, sans parler du LTE.  Nous devons réduire la taille du code. <br><br>  Il y a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étude intéressante</a> de 2017 sur ce sujet, qui montre que si votre application a beaucoup de JS, vous ne pouvez mettre que <b>130 Ko pour faire plaisir à l'utilisateur</b> .  Si JS est petit, alors jusqu'à 170 Ko.  Cette différence est due au fait que l'étude a tenu compte du fait que JS est différent des autres types de ressources, il doit être analysé, interprété, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/032/ec3/8b5032ec37fd48a2f95998759f41c5f9.png"><br><br>  Dans l'étude, 130 Ko n'est pas seulement JS, mais en général tout, y compris CSS, HTML, bien sûr, sans images.  Dans le même temps, un Angular pèse 143 Ko, et nous n'avons même pas écrit une seule ligne de code.  Voyons quelles solutions actuelles nous offrent. <br><br><h3>  Performances </h3><br>  En principe, tout framework classique est une abstraction sur une plateforme qui nous permet d'écrire à des niveaux plus pratiques.  C'est mauvais car toute abstraction a des coûts, y compris les performances. <br><br><blockquote>  Nous encourons des coûts supplémentaires en raison d'abstractions inutiles entre notre code et le navigateur. </blockquote><br>  La caractéristique de la disparition des frameworks est qu'ils <b>suppriment les abstractions et les calculs inutiles du moteur d'exécution du navigateur</b> , effectuant des analyses et des calculs au moment de la compilation.  C’est pourquoi ils disparaissent.  Nous en parlerons plus en détail ci-dessous. <br><br><h3>  La compatibilité </h3><br><blockquote>  Les solutions écrites pour le framework classique ne peuvent être appliquées nulle part. </blockquote><br>  Ils ne fonctionnent que dans le cadre de ce cadre.  Par exemple, vous effectuez 2-3 projets sur votre React préféré, écrivez un tas de solutions intéressantes pour celui-ci, puis décidez de passer à Angular.  Vous n'avez plus besoin de ces solutions, vous pouvez les jeter.  Bien que l'idée centrale soit la mise en correspondance des composants, les frameworks classiques nous empêchent de réutiliser le code. <br><br>  La chose à propos de la disparition des frameworks est qu'ils <b>n'ont pas d'abstractions</b> , et dans ce cas il n'y a pas de framework en runtime.  Votre code est absolument vanilla JS, qui peut être utilisé n'importe où - dans n'importe quel projet, même sur un framework différent.  Par exemple, vous pouvez prendre le code sur un framework qui disparaît et le transférer vers React. <br><br><h3>  Fractionnement de code et tremblement d'arbre </h3><br><blockquote>  Les anciennes technologies rendent difficile l'application de nouvelles technologies. </blockquote><br>  La plupart des cadres ont été créés lorsque ces technologies n'ont pas été développées de la sorte.  Nous avons un noyau assez monolithique et tout composant, même le plus petit morceau de votre code, est lié à l'ensemble du framework.  Par conséquent, il n'est pas possible de diviser le code efficacement et même de secouer les arbres. <br><br>  Désormais, tous les frameworks évoluent vers une plus grande modularité afin de mieux "secouer".  Dans les frameworks qui disparaissent, cela est résolu dès le départ, car ils sont faits de telle manière que <b>seul le code dont vous avez besoin au départ est ajouté au bundle</b> , et cela résout votre tâche exclusivement.  C'est un cas très spécifique - comme si vous avez écrit le code avec vos mains exactement pour votre tâche et que vous l'avez mis dans le bundle, seul le framework le fait pour vous. <br><br><h3>  Coût de la fonctionnalité </h3><br><blockquote>  Tout cadre a un prix pour une nouvelle fonctionnalité. </blockquote><br>  La communauté a besoin de nouvelles fonctionnalités différentes et chaque membre a besoin de quelque chose qui lui est propre, et toute fonctionnalité a un prix.  Dans les frameworks en voie de disparition, ce problème est résolu au niveau du concept, car toute fonctionnalité que vous n'utilisez pas n'entrera jamais dans votre bundle. <br>  Donc, la question principale: les frameworks en voie de disparition, et spécifiquement Svelte, peuvent-ils résoudre tous ces problèmes?  Faisons les choses correctement. <br><br><h2>  Bez avec runtime </h2><br>  Rantime est un sujet plutôt éphémère.  Ce n’est pas clair, et différentes personnes le comprennent différemment.  Dans ce contexte, je parlerai du runtime du point de vue de deux aspects: l' <b>environnement dans lequel le code est exécuté</b> et <b>le code lui-même</b> . <br><br><h3>  Le runtime comme environnement </h3><br>  Regardons un exemple.  Si le code est écrit en Vanilla, alors le seul runtime nécessaire est le DOM.  Si le code est écrit dans React, vous avez besoin d'un autre runtime: DOM, React et React DOM. <br><br><blockquote>  Dans tous les cas, le plus petit composant de votre code dans React dépend de l'environnement dans lequel votre framework fonctionne, c'est-à-dire lors de l'exécution. </blockquote><br><br><h3>  Runtime comme exécution de code </h3><br>  Le deuxième point est l'exécution en termes d'exécution de code lors de l'exécution.  Examinons le cas d'exécution de base d'aujourd'hui pour le frontend - le DOM virtuel - un gros morceau d'exécution, par exemple, dans les applications React - en utilisant un exemple simple: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Il y a une variable dynamique dans ce morceau de HTML.  Du point de vue du DOM virtuel, le code fonctionne ainsi. <br><br><ul><li>  Cette variable est en cours de modification. <br></li><li>  L'arborescence DOM virtuelle en mémoire est en cours de construction. <br></li><li>  Par rapport à la version précédente. <br></li><li>  Les manipulations DOM sont effectuées directement, ce qui en fin de compte est assez efficace, car nous avons obtenu une sorte de différence et nous savons exactement quoi changer dans le vrai DOM. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/12e/082/a7e/12e082a7e3f5e596d6251c22b4016046.png"><br><br><blockquote>  Un DOM virtuel est un surcoût absolu, car il sera toujours plus rapide comme ceci: dès que des changements sont survenus, ils ont immédiatement apporté des modifications au DOM. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5f8/18a/d83/5f818ad83b71a697f3af30a4b747bdaf.png"><br><br>  Question: comment comprendre ce qui a changé et ce qui doit être changé?  Le DOM virtuel résout le problème de ce qui a changé, pas la vitesse de ces changements.  La vitesse est atteinte grâce au fait que nous savons autant que possible ce qui a changé et que nous pouvons manipuler efficacement le DOM. <br><br><h2>  Compilez-le </h2><br>  Pour résoudre ce problème, les frameworks qui disparaissent déterminent simplement les changements au stade de la compilation: vous avez écrit le code, lors de la compilation, le framework qui disparaît crée toutes les dépendances, calcule quelles manipulations dans le DOM sont nécessaires.  En fait, tout ce qu'un DOM virtuel fait en runtime, un framework de fuite le fait en temps de construction: il génère des manipulations directes avec le DOM, qui sont simplement appelées pendant le runtime.  Le résultat est un diagramme: lorsque nous apportons des modifications, la manipulation dans le DOM va tout de suite. <br><br><blockquote>  Vous ne pouvez pas écrire d'applications sérieuses en JavaScript vanille sans heurter un mur de complexité.  Mais un compilateur peut le faire pour vous. <br>  <b>Rich Harris, créateur de Svelte</b> </blockquote><br>  Je vais vous raconter comment j'ai rencontré Svelte.  Nous avions un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet intéressant</a> - un widget à insérer sur un nombre illimité de sites, alors que nous ne savons pas de quels sites il s'agit, sur quels appareils l'utilisateur les ouvrira.  Le widget doit être de très petite taille et très rapide.  Naturellement, lorsque nous avons entrepris cette tâche, nous avons immédiatement compris que faire sur React ou même sur Vue n'est pas une option, car il se révèle beaucoup de frais supplémentaires. <br><br>  Nous étions presque enclins à écrire en Vanilla, mais c'est difficile et pas toujours pratique à entretenir.  Mais nous avons eu de la chance - nous sommes tombés sur Svelte.  L'idée principale de ce cadre est donnée dans une citation: vous ne pouvez pas écrire une application sérieuse sur Vanilla, car vous rencontrerez rapidement un mur de complexité - il sera difficile pour l'équipe de travailler, il n'y a pas d'approches communes et le compilateur peut le faire pour vous. <br><br><h3>  Comment ça marche </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/822/0c9/463/8220c9463072b5a7aedd40185dfa8a70.png"><br><br>  <b>Le code source est un code basé</b> sur le framework - un code qui dépend du framework.  Tout est comme d'habitude: il y a de la documentation, vous écrivez le code comme si vous utilisiez un autre framework qui a une sorte d'API, des principes et des approches.  Tout est comme d'habitude. <br><br>  Au moment de la construction, ce code se compile.  En conséquence, vanilla JS se trouve dans le bundle, et, comme je l'ai dit, le code nécessaire à l'exécution de votre application y arrive précisément.  Si, dans deux minutes, vous y ajoutez une nouvelle fonction ou utilisez une nouvelle fonctionnalité du framework, Svelte l'ajoutera là, et elle entrera également dans le bundle.  Sinon, cela ne se produira pas. <br><br>  Examinons les étapes plus en détail.  La première étape est le <b>composant</b> .  Considérez le même composant. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dans la deuxième étape - <b>AST</b> - le code est produit dans un arbre de syntaxe abstraite. <br><br><pre> <code class="xml hljs">{"type": "Element", "name": "h1", "children": [{ "type": "Text", "data": "Hello",....}]}</code> </pre><br>  La troisième étape est l' <b>API DOM</b> .  Sur la base de l'arborescence, le code est généré directement, ce qui est nécessaire pour que ce composant fonctionne.  Le code est très simple, il n'y a pas d'exécutions et d'abstractions compliquées ici en principe. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changed, ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed.name) { text_1.data = ctx.name; } }</code> </pre><br>  A la fin de l'article, indiquez dans l'enquête si vous aimez l'idée d'une compilation AOT du framework Svelte?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La dernière fois, la</a> majorité s'est exprimée positivement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/be9/d8e/5aabe9d8e0bd77fef1a1ed0e1844ac91.png"><br><br>  Voyons maintenant ce qu'est Svelte. <br><br><h2>  Svelte </h2><br>  Le mot anglais svelte ou svelt signifie «mince, flexible».  Svelte JS l'est! <br><br>  Je prétends que ce n'est pas «encore un autre framework JS» car c'est un <b>framework d'interface utilisateur au moment de la construction</b> .  Les frameworks réguliers fonctionnent en runtime, et Svelte n'existe qu'avant que nous ne le compilions. <br><br>  Il s'agit d'un <b>analyseur statique au moment de la compilation</b> ou d'un analyseur de code statique qui passe à travers le code pendant la compilation, l'analyse statiquement et, sur cette base, génère le bundle final correspondant. <br><br>  Il s'agit d'un <b>compilateur à l'avance</b> - un compilateur AOT qui fait tout. <br><br>  Le créateur du framework Rich Harris, que vous pouvez connaître à partir d'outils tels que Rollup, Ractive, Buble - un analogue de Babel - est un mec cool.  À mon avis, le même Rollup est toujours la meilleure implémentation d'arborescence.  Il y est apparu beaucoup plus tôt que dans Webpack et fonctionne toujours mieux.  Harris a initialement construit le framework Svelte avec des arborescences, le fractionnement de code et d'autres approches modernes. <br><br><blockquote>  Svelte est un outil pour écrire JS vanille sans avoir à écrire JS vanille. </blockquote><br>  Regardons ce cadre de l'intérieur. <br><br><h3>  Composant de fichier unique </h3><br>  <b>Svelte est un composant à fichier unique</b> .  Si vous avez travaillé avec Vue, cela vous rappellera beaucoup ce framework, mais ce n'est pas un hasard.  La syntaxe que Vue utilise principalement est dérivée du cadre Ractive, que Harris a également créé en 2012.  Ce framework, malheureusement, n'est pas devenu populaire, il me semble, car il est sorti trop tard en 1.0.  Ils étaient tellement en désordre avec les versions que Ractive était en versions mineures depuis 6 ans. <br><br>  Vue a emprunté de nombreuses interfaces à partir de là, et Svelte est le successeur de Ractive.  Par conséquent, il vous semblera que tout est similaire, mais des composants à fichier unique sont apparus dans Ractive en 2013.  Ils ont l'air un peu différents, mais dans l'ensemble - ça a l'air.  Tout composant que vous écrivez dans Svelte ressemblera à ceci. <br><br><pre> <code class="plaintext hljs">&lt;h1 &gt;Hello {world}!&lt;/h1 &gt; &lt;script&gt; export default { /* component behaviour */ }; &lt;/script&gt; &lt;style&gt;    /* scoped styles */ &lt;/style&gt;</code> </pre> <br>  Ci-dessus est un certain modèle HTML - HTML simple sans aucune exception.  La seule chose en plus est un certain langage de modèle appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTMLx</a> .  Je vous en dirai plus sur lui plus tard. <br><br>  Vient ensuite le script dans lequel nous écrivons le comportement de notre composant.  Comment l'écrire est décrit dans le guide.  Là, vous pouvez importer, créer diverses fonctions et méthodes - tout comme dans Vue. <br><br>  Vous pouvez utiliser un style limité pour obtenir des styles de composants isolés dans la boîte.  Cela fonctionne comme ceci: dans la compilation principale, un hachage est généré, par conséquent, c'est comme émuler un DOM Shadow. <br><br>  Aucune des sections n'est requise, donc un composant ne peut être composé que d'un seul HTML. <br><br><h3>  Syntaxe HTMLx </h3><br>  Comme pour tout HTML, les données sont écrites entre parenthèses. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  C'est ainsi que les instructions conditionnelles sont écrites. <br><br><pre> <code class="xml hljs">{#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br>  Énumérations et boucles: <br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Vous pouvez utiliser des directives pour intercepter des événements, pour une double liaison de données. <br><br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name)"</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Il y a très peu de directives dans HTMLx - seulement 4-5 types, et il n'y a pas de directives personnalisées, comme dans Angular. <br><br>  Vous pouvez insérer n'importe quelle donnée dynamique dans n'importe quel attribut, cela ne pose aucun problème. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Styles isolés et suppression des éléments inutilisés </h3><br>  Si vous utilisez des styles isolés, en plus d'être isolés, les styles inutilisés sont également coupés automatiquement. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> .used {...} .unused {...} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Si le style est <code>used</code> , alors il est utilisé, et si le style n'est <code>unused</code> , il ne sera pas dans le bundle.  Le cadre coupera tout, mais proprement.  Par conséquent, cette fonctionnalité peut être facilement interrompue si vous utilisez beaucoup de dynamique.  Svelte pensera: «Je ferais mieux de ne pas toucher» - et partir.  Il faut être prudent, mais c'est très pratique.  Étant donné que Svelte possède un analyseur statique, il affiche dans la console au démarrage les styles qui ne sont pas utilisés.  Si vous n'en avez vraiment pas besoin, vous pouvez les retirer immédiatement. <br><br><h3>  Composition des composants </h3><br>  Tout est comme d'habitude ici: nous importons le fichier, l'enregistrons dans les composants, nous l'utilisons comme tag. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Nested</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">foo</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"static"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{dynamic}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:baz</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">baz</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Nested </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'Nested.html'</span></span></span><span class="javascript">;</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">' export default {   components: {Nested} }; </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Vous pouvez transférer toutes les données via les attributs, utilisez la double liaison.  Ou ne pas utiliser - la double liaison est facultative, elle peut même être désactivée au niveau du compilateur, et elle ne sera nulle part ailleurs.  C'est pour ceux qui n'aiment pas les fixations.  Les liaisons sont obtenues à l'aide de la directive <code>bind:</code> :. <br><br><h3>  Fonctionnalités supplémentaires de Svelte </h3><br>  Les deux premières possibilités sont les suivantes: <b>SSR &amp; Hydration</b> - rendu et hydratation du serveur, et <b>gestion d'état</b> intégrée - gestion d'état globale intégrée basée sur notre propre solution, la soi-disant magasin. <br><br>  En principe, vous pouvez utiliser Redux, ce que beaucoup font: ceux qui ont l'habitude de Redux l'utilisent avec Svelte.  Mais il existe une solution interne plus simple qui est profondément intégrée de sorte que si vous l'enregistrez dans le magasin, elle est immédiatement disponible dans toutes les hiérarchies de composants - aucune manipulation du tout.  La seule chose à utiliser est d'utiliser le préfixe <code>$</code> , c'est-à-dire que toutes les méthodes ou les données de stockage sont écrites avec ce préfixe.  <code>$</code> peut être utilisé dans n'importe quel modèle. <br><br>  Le magasin a une fonctionnalité intéressante que je n'ai vu nulle part ailleurs - il s'étend globalement à une hiérarchie de composants.  Si vous avez, par exemple, un composant racine, il est utilisé dans toute cette hiérarchie.  Si vous avez un autre magasin quelque part dans cette hiérarchie, ce magasin s'étend à toute la hiérarchie inférieure. <br><br>  Ceci est pratique lorsque vous souhaitez créer un grand composant complexe avec de nombreux sous-composants, puis l'utiliser dans différents projets, dont certains sont Redux et d'autres non.  Si vous utilisez des magasins réguliers avec Redux, vous devez vous assurer que le projet où vous l'ajoutez a Redux.  Cela n'a pas besoin d'être fait ici - Svelte implémente son propre magasin pour cette hiérarchie.  Il peut être facilement transféré même vers les projets où il n'y a pas de magasin mondial du tout.  Vous l'avez apporté, et Svelte fait déjà tout à l'intérieur. <br><br>  <b>Les éléments personnalisés sont pris en charge prêts à l'emploi</b> .  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site spécial</a> sur lequel le support est testé par des frameworks de la norme Web Components.  Selon les tests, Svelte prend en charge à 100% les éléments personnalisés.  Cela fonctionne comme ceci: le nom de la balise est spécifié, l'indicateur «customElement: true» est défini dans le compilateur et un élément personnalisé prêt à l'emploi est généré qui prend en charge toutes les fonctionnalités Svelte existantes. <br><br>  <b>Sapeur - Créateur d'applications Svelte</b> .  Il s'agit d'un analogue de Next.js et Nuxt.js pour Vue.  En principe, tout est identique: isomorphisme, prise en charge du fractionnement de code, de la prélecture et hors ligne, ainsi que d'autres fonctionnalités.  À mon avis, récemment, même certaines des idées de routage sont venues de Sapeur à Next.js. <br><br>  Mais aucun Svelte ne le fait.  Nous sommes pour une concurrence loyale! <br><br><h2>  Qui d'autre? </h2><br>  <b>Stencil</b> est un framework des développeurs Ionic.  Ils travaillent également sur un cadre compilé, mais avec un accent particulier sur les composants Web et les éléments personnalisés.  Svelte en diffère par le fait que ses composants sont généralement compilés en classes JS régulières et qu'il n'y a pas de biais dans les composants Web. <br><br>  <b>Glimmer</b> - Je pense que tout le monde connaît ce projet.  Il n'est présenté ici que parce qu'il compile aussi: il a son propre bytecode, sa propre machine virtuelle, ce qui donne évidemment des optimisations supplémentaires pour le code final. <br><br>  <b>Marko d'eBay</b> .  Je ne l'ai pas étudié en détail, mais ils compilent également, pas sûr de ce qui est aussi profond que Svelte.  Certes, je n'ai pas compris en détail et je peux me tromper. <br><br>  <b>Angulaire</b>  Il y a un compilateur AOT ici, et il sera bien promu, mais ce n'est qu'une recompilation de modèles de chaînes sous une forme triée prête à l'emploi à l'avance.  Pour autant que je sache, il n'y a pas encore de compilation AoT complète. <br><br><h2>  Bonjour les films </h2><br>  J'ai écrit une petite application - une liste de films avec des filtres basés sur l'API TMDb.  Il a des catégories: populaires, les mieux notées, à venir.  Vous pouvez parcourir les pages, sélectionner un pays, lui appliquer des filtres, changer la langue.  Cette application primitive ne prend que 6,4 Ko. <br><br>  Au total, HELLO MOVIES ne compte que 172 lignes de code avec HTML, dont 36 lignes de code JS, avec toutes sortes de citations.  C'est tout le code que j'ai écrit personnellement.  Naturellement, tout cela se compile pour un volume beaucoup plus important, mais pour moi, en tant que développeur, cela n'a pas d'importance. <br><br>  Encore quelques indicateurs.  "TodoList MVC" sur Svelte prend 3,6 Ko - cela dépend de qui il dit, mais même sur Vanilla, il prend 11 Ko, et sur Vue et React encore plus - 80 et 300 Ko, respectivement.  Le projet "RealWorld", un clone de Medium, avec inscription, comptes, likes, partages, amis - 40 Ko, sur React et Angular - 211 et 575 Ko.  Le clone de "HackerNews" sur Svelte est de 30 Ko, sur React et Vue - plusieurs fois de plus. <br><br><h2>  Repères </h2><br>  Nous aimons tous hollichivat sur le thème des repères.  J'ai utilisé le célèbre benchmark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Krausest</a> .  Vous pensez probablement que je vais maintenant montrer les résultats où Svelte déchire tout le monde en lambeaux et Inferno pleure juste de côté.  Mais cela n'arrivera pas. <br><br><img src="https://habrastorage.org/webt/3r/xz/4_/3rxz4_c2qbhoczgeo8yzr_kbg8s.jpeg"><br><br>  J'ai pris une comparaison de Svelte avec les Big Three - Angular, React et Vue dans les versions récentes.  En conséquence, il a identifié les deux premières positions concernant la vanille.  Et ici, les chiffres ne sont pas aussi importants que l'idée principale, à savoir que <b>Svelte est très équilibré</b> . <br><br>  Svelte s'efforce d'être équilibré - <b>il est bon à tous égards dans toutes les références</b> .  À certains égards, Svelte dépasse même Vanilla, dans certains cas, il prend le premier, mais quelque part il dépasse Vue et Angular.  Cependant, dans tous les tests, Angular et Vue consomment beaucoup de mémoire, mais Svelte ne le fait pas.        ,    ,       .   — . <br><br>  Svelte     —    .  ,    . <br><br><h2> - —   ! </h2><br>  Svelte   New York Times.    . ,      Svelte, ,   legacy-  CMS,       .     ,     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/080/9a3/6c8/0809a36c8b7f7d9d4eb9e18fe3d3bfa2.png"><br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> -</a>   « » —  ,  Drag&amp;Drop.       Svelte,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Soft-Gear</a>    ,     ,  Svelte.   ,         -     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">airca.st</a>    Svelte.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dabble</a>   Svelte.    -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">i-want-to-ride-an-electric-citi</a>        Svelte. <br><br>      . ,   RuTube.       Smart TV   Tizen,    Samsung.     Tizen  Smart TV     Svelte.      ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/154/f5d/46c154f5d392f46698fb5a03e4234adc.png"><br><br><h2>   </h2><br><br> <b>  standalone vanilla JavaScript  </b> .     ,      ,  overhead . <br><br> <b>    </b> .  Svelte       DOM.    . <br><br> <b>  </b> .  ,     Vue,   Svelte  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">REPL</a> ,         ,     . <br><br> <b>      </b> .   ,      —    ,         .       ,   . <br><br> <b>Code-splitting &amp; tree-shaking</b> .         code-splitting  tree-shaking.         .     ,          . <br><br> <b>Micro-frontends ready</b> .     -.      ,    ,        PHP,    Svelte-. ,      .      ,          .        code-splitting  tree-shaking. <br><br><h2>   </h2><br><br> <b>Svelte  ,   </b> .      2016 .          . <br><br> <b> </b> .  ,              .         . ,  ,   ,    ,     ,     Vue. <br><br> <b>  </b> .  React  Facebook, Angular — Google, Vue    ,      Rich Harris   ,            . <br><br><blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a>   ++      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,  ,    .   33       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>              ++ 27  28 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450822/">https://habr.com/ru/post/fr450822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450812/index.html">PSR-14 - l'événement principal en PHP</a></li>
<li><a href="../fr450814/index.html">Comment BGP fonctionne</a></li>
<li><a href="../fr450816/index.html">En-têtes HTTP pour le développeur responsable</a></li>
<li><a href="../fr450818/index.html">De la latence Ceph élevée au patch du noyau avec eBPF / BCC</a></li>
<li><a href="../fr450820/index.html">Comité du programme FrontendConf: cadres, horizons, expérience mondiale et mission de la conférence</a></li>
<li><a href="../fr450824/index.html">L'état du CSS</a></li>
<li><a href="../fr450826/index.html">Comment parler avec le microcontrôleur de JS</a></li>
<li><a href="../fr450828/index.html">Quand la ville s'endort ...</a></li>
<li><a href="../fr450830/index.html">Nikita Dubko sur les conférences, le syndrome des imposteurs et les reportages</a></li>
<li><a href="../fr450832/index.html">L'histoire d'une animation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>