<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèø üöú üë©‚Äçüë©‚Äçüë¶ EHCI menschlich auf Russisch üï∫ üëäüèª ü§üüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Ich begr√º√üe alle. Heute m√∂chte ich meine Erfahrungen teilen und meiner Meinung nach auf den ersten Blick einen einfachen Standard f√ºr USB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI menschlich auf Russisch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="Bild"><br><br><h3>  <b>Einf√ºhrung</b> </h3><br>  Ich begr√º√üe alle.  Heute m√∂chte ich meine Erfahrungen teilen und meiner Meinung nach auf den ersten Blick einen einfachen Standard f√ºr USB 2.0-Host-Controller klar erl√§utern. <br><br>  Zun√§chst k√∂nnen Sie sich vorstellen, dass ein USB 2.0-Anschluss nur aus 4 Pins besteht, von denen zwei einfach Daten √ºbertragen (z. B. ein COM-Anschluss), aber tats√§chlich ist nicht alles so, und sogar das Gegenteil.  Der USB-Controller erlaubt es uns grunds√§tzlich nicht, Daten wie √ºber einen normalen COM-Port zu √ºbertragen.  EHCI ist ein ziemlich komplizierter Standard, der eine zuverl√§ssige und schnelle Daten√ºbertragung von der Software zum Ger√§t selbst und in die entgegengesetzte Richtung erm√∂glicht. <br><br>  Sie k√∂nnen diesen Artikel n√ºtzlich finden, wenn Sie beispielsweise nicht √ºber ausreichende Schreibf√§higkeiten f√ºr Treiber und das Lesen von Dokumentation f√ºr eine Hardware verf√ºgen.  Ein einfaches Beispiel: Sie m√∂chten Ihr Betriebssystem f√ºr einen Mini-PC schreiben, damit einige Windows- oder andere Linux-Distributionen kein Eisen herunterladen, und Sie nutzen die gesamte Leistung ausschlie√ülich f√ºr Ihre eigenen Zwecke. <br><a name="habracut"></a><br><h3>  <b>Was ist EHCI?</b> </h3><br>  Nun, fangen wir an.  EHCI - Enhanced Host Controller Interface (Enhanced Host Controller Interface) dient zur √úbertragung von Daten und Steuerungsanforderungen an USB-Ger√§te und in die andere Richtung. In 99% der F√§lle handelt es sich um eine Verbindung zwischen einer Software und einem physischen Ger√§t.  EHCI arbeitet als PCI-Ger√§t und verwendet dementsprechend MMIO (Memory-Mapped-IO) zur Steuerung des Controllers (ja, ich wei√ü, dass einige PCI-Ger√§te Ports verwenden, aber hier habe ich alles verallgemeinert).  Die Dokumentation von Intel beschreibt nur das Funktionsprinzip, und es gibt keine Hinweise auf alle Algorithmen, die zumindest in Pseudocode geschrieben sind.  EHCI verf√ºgt √ºber zwei Arten von MMIO-Registern: Capability und Operational.  Die ersteren dienen dazu, die Eigenschaften der Steuerung zu erhalten, w√§hrend die letzteren dazu dienen, diese zu steuern.  Eigentlich werde ich das Wesentliche der Verbindung zwischen Software und dem EHCI-Controller anh√§ngen: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="Bild"><br><br>  Jeder EHCI-Controller verf√ºgt √ºber mehrere Anschl√ºsse, von denen jeder an ein beliebiges USB-Ger√§t angeschlossen werden kann.  Bitte beachten Sie auch, dass EHCI eine verbesserte Version von UHCI ist, die einige Jahre zuvor ebenfalls von Intel entwickelt wurde.  Aus Gr√ºnden der Abw√§rtskompatibilit√§t ist jeder UHCI / OHCI-Controller mit einer niedrigeren Version als EHCI ein Begleiter von EHCI.  Sie haben beispielsweise eine USB-Tastatur (und die meisten Tastaturen des Jahres waren bisher genau so), die mit USB 1.1 funktioniert (beachten Sie, dass die maximale Geschwindigkeit von USB 1.1 12 Megabit pro Sekunde betr√§gt und FullSpeed ‚Äã‚ÄãUSB 2.0 √ºber Bandbreite verf√ºgt bis zu 480 Mbit / s) und Sie haben einen Computer mit einem USB 2.0-Anschluss. Wenn Sie die Tastatur an den Computer anschlie√üen, funktioniert der EHCI-Host-Controller in keiner Weise mit USB 1.1.  Dieses Modell ist in der folgenden Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="Bild"><br><br>  Au√üerdem m√∂chte ich Sie f√ºr die Zukunft sofort warnen, dass Ihr Treiber aufgrund einer solch absurden Situation m√∂glicherweise nicht richtig funktioniert: Sie haben UHCI initialisiert und dann EHCI, w√§hrend Sie zwei identische Ger√§te hinzugef√ºgt haben, das Port Owner Control-Bit auf das Portregister gesetzt und dann UHCI funktioniert nicht mehr, da EHCI den Port automatisch auf sich selbst zieht und der Port auf UHCI nicht mehr reagiert. Diese Situation muss √ºberwacht werden. <br><br>  Schauen wir uns auch ein Diagramm an, das die EHCI-Architektur selbst zeigt: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="Bild"><br><br>  Rechts steht √ºber die Warteschlange - etwas sp√§ter dar√ºber. <br><br><h2>  EHCI-Controller-Register </h2><br>  Zun√§chst m√∂chte ich noch einmal klarstellen, dass Sie √ºber diese Register Ihr Ger√§t steuern, daher sind sie sehr wichtig - und ohne sie ist eine EHCI-Programmierung nicht m√∂glich. <br><br>  Zuerst m√ºssen Sie die MMIO-Adresse erhalten, die diesem Controller zugewiesen wurde. Bei Offset + 0x10 ist dies die Adresse unserer lang erwarteten Register.  Es gibt eine Sache: Erstens gehen Capability-Register und erst danach - Operational, also bei Offset 0 (von der vorherigen Adresse, die wir bei Offset 0x10 relativ zum Beginn des MMIO unseres EHCI erhalten haben), gibt es ein Byte - die L√§nge der Capability-Register. <br><br><h3>  <b>F√§higkeitsregister</b> </h3><br>  Bei Offset 2 befindet sich das <b>HCIVERSION-</b> Register - die Revisionsnummer dieses HC, die 2 Bytes ben√∂tigt und die BCD-Version der Revision enth√§lt (welche BCD auf Wikipedia zu finden ist). <br>  Bei Offset +4 befindet sich das <b>HCSPARAMS-</b> Register, seine Gr√∂√üe betr√§gt 2 W√∂rter, es enth√§lt die Strukturparameter des Ger√§ts und seine Bits zeigen Folgendes: <br><br><ul><li>  Bit 16 - Portanzeigen - Verf√ºgbare LEDs f√ºr angeschlossene USB-Ger√§te. </li><li>  Bits 15:12 - Die Nummer des Companion-Controllers, der diesem Controller zugewiesen ist </li><li>  Bits 11: 8 - Die Anzahl der Ports auf dem Companion-Controller </li><li>  Bit 7 - Port-Routing-Regeln - zeigt, wie diese Ports Begleit-Ports zugeordnet werden </li><li>  Bit 4 - Port Power Control - zeigt an, ob die Stromversorgung f√ºr jeden Port eingeschaltet werden muss. 0 - Die Stromversorgung erfolgt automatisch </li><li>  Bits 3: 0 - Die Anzahl der Ports f√ºr diesen Controller. </li><li>  Bei Offset +8 liegt das HCCPARAMS-Register - es zeigt Kompatibilit√§tsparameter, seine Bits bedeuten Folgendes: </li><li>  Bit 2 - Verf√ºgbarkeit der asynchronen Warteschlange, </li><li>  Bit 1 - Periodische (sequentielle) Verf√ºgbarkeit der Warteschlange </li><li>  Bit 0 - 64 Bit Kompatibilit√§t </li></ul><br><h3>  <b>Betriebsregister</b> </h3><br>  Bei Offset 0 ist das <b>USBCMD-</b> Register das Befehlsregister der Steuerung, seine Bits bedeuten Folgendes: <br><br><ul><li>  Bits 23:16 - Interrupt Threshold Control - zeigt an, wie viele Micro-Frames f√ºr einen regul√§ren Frame verwendet werden.  Je gr√∂√üer, desto schneller, aber wenn mehr als 8, werden die Micro-Frames mit der gleichen Geschwindigkeit wie f√ºr 8 verarbeitet. </li><li>  Bit 6 - Interrupt nach jeder Transaktion in der asynchronen Warteschlange, </li><li>  Bit 5 - ist die verwendete asynchrone Warteschlange </li><li>  Bit 4 - Verwendung der sequentiellen Warteschlange, </li><li>  Bits 3: 2 - die Gr√∂√üe von FrameList'a (dazu sp√§ter mehr).  0 bedeutet 1024 Elemente, 1 - 512, 2 - 256, 3 - reserviert </li><li>  Bit 1 - Zum Zur√ºcksetzen des Host-Controllers setzen. </li><li>  Bit 0 - Ausf√ºhren / Stoppen </li></ul>  . <br>  Als n√§chstes gibt es bei Offset +4 das <b>USBSTS-</b> Register - den Status des Host-Controllers, <br><br><ul><li>  Bit 15 gibt an, ob eine asynchrone Warteschlange verwendet wird. </li><li>  Bit 14 zeigt an, ob eine sequentielle Warteschlange verwendet wird. </li><li>  Bit 13 - zeigt an, dass eine leere asynchrone Warteschlange erkannt wurde. </li><li>  Bit 12 wird auf 1 gesetzt. Wenn w√§hrend der Verarbeitung der Transaktion ein Fehler aufgetreten ist, stoppt der Host-Controller alle Warteschlangen. </li><li>  Bit 4 wird auf 1 gesetzt. Wenn ein schwerwiegender Fehler auftritt, stoppt der Host-Controller alle Warteschlangen. </li><li>  Bit 3 FrameList (Register) Rollover - wird auf 1 gesetzt, wenn der Host-Controller die gesamte FrameList verarbeitet hat. </li><li>  Bit 1 - USB-Fehlerunterbrechung - Generiere ich eine Fehlerunterbrechung? </li><li>  Bit 0 - USB-Interrupt - wird nach erfolgreicher Transaktionsverarbeitung gesetzt, wenn IOC in TD installiert wurde </li></ul><br>  Nicht m√ºde?  Sie k√∂nnen sich eine starke M√∂we einschenken und die Leber bringen, wir stehen ganz am Anfang! <br><br>  Bei Offset +8 gibt es ein <b>USBINTR-</b> Register - das Interrupt-Aktivierungsregister <br>  Um nicht lange zu schreiben und noch mehr, um nicht lange zu lesen, finden Sie die Werte der Bits dieses Registers in der Spezifikation. Ein Link dazu bleibt unten.  Hier schreibe ich einfach 0, weil  Ich habe absolut keine Lust, Handler, Map-Interrupts usw. zu schreiben, daher halte ich das f√ºr fast v√∂llig sinnlos. <br><br>  Bei Offset +12 (0x0C) befindet sich das <b>FRINDEX-</b> Register, in dem die aktuelle Frame-Nummer einfach liegt, und ich m√∂chte darauf hinweisen, dass die letzten 4 Bits die Micro-Frame-Nummer und in den oberen 28 Bits die Frame-Nummer anzeigen (der Wert ist auch nicht unbedingt kleiner als die FrameList-Gr√∂√üe Wenn Sie jedoch einen Index ben√∂tigen, ist es besser, ihn mit einer Maske von 0x3FF (oder 0x1FF usw.) zu verwenden. <br><br>  Das <b>CTRLDSSEGMENT-</b> Register hat den Offset + 0x10 und zeigt dem Host-Controller die h√∂chstwertigen 32 Bits der Adresse des Rahmenblatts an. <br><br>  Das <b>PERIODICLISTBASE-</b> Register hat einen Versatz von + 0x14. Sie k√∂nnen die unteren 32 Bits des Rahmenblatts darin einf√ºgen. Beachten Sie, dass die Adresse an der Gr√∂√üe der Speicherseite (4096) ausgerichtet sein sollte. <br><br>  Das <b>ASYNCLISTADDR-</b> Register hat einen Offset von + 0x18. Sie k√∂nnen die Adresse der asynchronen Warteschlange darin einf√ºgen. Beachten Sie, dass sie an der Grenze von 32 Byte ausgerichtet sein muss, w√§hrend sie sich in den ersten vier Gigabyte des physischen Speichers befinden muss. <br><br>  Das <b>CONFIGFLAG-</b> Register zeigt an, ob das Ger√§t konfiguriert ist.  Sie m√ºssen Bit 0 setzen, nachdem Sie das Ger√§te-Setup abgeschlossen haben. Es hat einen Offset von + 0x40. <br><br>  Gehen wir weiter zu den Portregistern.  Jeder Port hat ein eigenes Befehlsstatusregister, jedes <b>Portregister</b> ist versetzt <b>+ 0x44 + (Portnummer - 1) * 4</b> , seine Bits bedeuten Folgendes: <br><br><ul><li>  Bit 12 - Portstromversorgung, 1 - Stromversorgung, 0 - Nr. </li><li>  Bit 8 - Port Rest - wird gesetzt, um das Ger√§t zur√ºckzusetzen. </li><li>  Bit 3 - Port Enable / Disable Change - wird gesetzt, wenn der Status der "Einbeziehung" des Ports ge√§ndert wird. </li><li>  Bit 2 - Port ein / aus. </li><li>  Bit 1 - √Ñndern Sie den Verbindungsstatus. Wird beispielsweise auf 1 gesetzt, wenn Sie ein USB-Ger√§t angeschlossen oder getrennt haben. </li><li>  Bit 0 - Verbindungsstatus, 1 - verbunden, 0 - Nr. </li></ul><br>  Kommen wir nun zum Saft selbst. <br><br><h2>  Daten√ºbertragungs- und Abfragestrukturen </h2><br>  Das Organisieren einer Struktur zum Verarbeiten von Anforderungen umfasst Warteschlangen und √úbertragungsdeskriptoren (TDs). <br><br>  Im Moment werden wir nur 3 Strukturen betrachten. <br><br><h3>  Sequenzielle Liste </h3><br>  Die sequentielle Liste (periodisch, Pereodisch) ist wie folgt organisiert: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="Bild"><br><br>  Wie Sie im Diagramm sehen k√∂nnen, beginnt die Verarbeitung mit dem Erhalten des gew√ºnschten Rahmens aus dem Blattrahmen. Jedes seiner Elemente belegt 4 Bytes und hat die folgende Struktur: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="Bild"><br><br>  Wie Sie in der Abbildung sehen k√∂nnen, ist die √úbertragung von Warteschlangenadresse / Deskriptor an der Grenze von 32 Bytes ausgerichtet. Bit 0 bedeutet, dass der Host-Controller dieses Element nicht verarbeitet. Bits 3: 1 geben den Typ an, den der Host-Controller verarbeitet: 0 - isosynchrones TD (iTD), 1 - Runde, 2 und 3 in diesem Artikel werde ich nicht ber√ºcksichtigen. <br><br><h3>  Asynchrone Warteschlange </h3><br>  Der Host-Controller verarbeitet diese Warteschlange nur, wenn der sequentielle Frame leer ist oder der Host-Controller die gesamte serielle Liste verarbeitet hat. <br><br>  Eine asynchrone Warteschlange ist ein Zeiger auf eine Warteschlange, die andere Warteschlangen enth√§lt, die verarbeitet werden m√ºssen.  Schema: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="Bild"><br><br><h3>  qTD (Queue Element Transfer Descriptor) </h3><br>  Dieser TD hat die folgende Struktur: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="Bild"><br><br>  <b>N√§chster qTD-Zeiger</b> - Ein Zeiger auf die Fortsetzung der Warteschlange zur Verarbeitung (f√ºr die horizontale Ausf√ºhrung), Bit 0. N√§chster qTD-Zeiger zeigt an, dass keine weitere Warteschlange vorhanden ist. <br>  <b>qTD-Token</b> - TD-Token, zeigt Daten√ºbertragungsparameter an: <br><br><ul><li>  Bit 31 - Data Toggle (dazu sp√§ter mehr) </li><li>  Bits 30:16 - Die zu √ºbertragende Datenmenge verringert sich nach Abschluss der Transaktion um die √ºbertragene Datenmenge. </li><li>  Bit 15 - IOC - Interrupt On Complete - Unterbrechung verursachen, nachdem die Deskriptorverarbeitung abgeschlossen ist. </li><li>  Die Bits 14:12 zeigen die Nummer des aktuellen Puffers, zu dem / von dem Daten ausgetauscht werden, dazu sp√§ter mehr. </li><li>  Bits 11:10 - die Anzahl der zul√§ssigen Fehler.  Diese Tabelle zeigt, wann die Fehlerzahl abnimmt: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="Bild"><br><br>  Fu√ünote 1 - Wenn Sie entweder Babble oder Stall erkennen, wird die Ausf√ºhrung des Warteschlangenkopfs automatisch gestoppt.  Fu√ünote 3 - Datenpufferfehler sind Probleme mit dem Host.  Sie ber√ºcksichtigen keine Ger√§tewiederholungen. </li><li>  9: 8 - PID-Code - Token-Typ: 0 - Token zum Eingang (vom Host zum Ger√§t), 1 - Token zum Ausgang (vom Ger√§t zum Host), 2 - Token ‚ÄûSETUP‚Äú </li><li>  Die Bits 7: 0 zeigen den TD-Status an: <br>  Bit 7 zeigt an, dass sich der TD in einem aktiven Zustand befindet (d. H. Der Host-Controller verarbeitet diesen TD). <br>  Bit 6 - Angehalten - zeigt an, dass ein Fehler aufgetreten ist und die TD-Ausf√ºhrung gestoppt wurde. <br>  Bit 4 - Babble Detected - Die Datenmenge, die wir an das Ger√§t oder pro Umdrehung gesendet haben, ist geringer als die von uns √ºbertragene, d. H. Das Ger√§t hat uns beispielsweise 100 Datenbytes gesendet, und wir lesen nur 50 Byte und dann weitere 50 Byte Das angehaltene Bit wird auch gesetzt, wenn dieses Bit auf 1 gesetzt ist. <br>  Bit 3 - Transaktionsfehler - W√§hrend der Transaktion ist ein Fehler aufgetreten. </li></ul><br>  <b>qTD Buffer Page Pointer List</b> - einer von 5 Puffern.  Es enth√§lt einen Link zu dem Ort, an dem die Transaktion im Speicher durchgef√ºhrt werden soll (Daten an das Ger√§t senden / Daten vom Ger√§t empfangen). Alle Adressen in den Puffern mit Ausnahme der ersten sollten an der Gr√∂√üe der Seite ausgerichtet sein (4096 Byte). <br><br><h3>  Leiter der Leitung </h3><br>  Der Warteschlangenkopf hat die folgende Struktur: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="Bild"><br><br>  <b>Horizontaler Verbindungszeiger</b> f√ºr Warteschlangenkopf - Zeiger auf die n√§chste Warteschlange, Bits 2: 1 haben je nach Warteschlangentyp die folgenden Werte: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="Bild"><br><br>  <b>Endpunktfunktionen / -merkmale</b> - Warteschlangenmerkmale: <br><br><ul><li>  Die Bits 26:16 enthalten die maximale Paketgr√∂√üe f√ºr die √úbertragung </li><li>  Bit 14: Data Toggle Control - Zeigt an, wo der Host-Controller den anf√§nglichen Data Toggle-Wert 0 annehmen soll. Ignoriert das DT-Bit in qTD und speichert das DT-Bit f√ºr den Warteschlangenkopf. </li><li>  Bit 13:12 - √úbertragungsrateneigenschaften: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="Bild"></li><li>  Bits 11: 8 - Die Nummer des Endpunkts, an den die Anforderung gesendet wird </li><li>  Bits 6: 0 - Ger√§teadresse </li></ul><br>  <b>Endpunktfunktionen: Queue Head DWord 2</b> - Fortsetzung des vorherigen Doppelworts: <br><br><ul><li>  Bits 29:23 - Hub-Nummer </li><li>  Bits 22:16 - Hub-Adresse </li></ul><br>  <b>Aktueller qTD-Link-Zeiger</b> - Zeiger auf den aktuellen qTD. <br><br>  Wir gehen zu den interessantesten √ºber. <br><br><h2>  EHCI-Treiber </h2><br>  Beginnen wir mit den Fragen, die der EHCI erf√ºllen kann.  Es gibt zwei Arten von Anforderungen: Steuerung - a la Befehl und Bulk - an Endpunkte, f√ºr den Datenaustausch. Beispielsweise verwendet die √ºberwiegende Mehrheit der USB-Flash-Laufwerke (USB MassStorage) den Daten√ºbertragungstyp Bulk / Bulk / Bulk.  Maus und Tastatur verwenden auch Massenanforderungen f√ºr die Daten√ºbertragung. <br><br>  Initialisieren Sie EHCI und konfigurieren Sie asynchrone und sequentielle Warteschlangen: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br>  Eigentlich der Code zum Zur√ºcksetzen des Ports auf seinen urspr√ºnglichen Zustand: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Steueranforderung an das Ger√§t: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  Code f√ºr die Warteschlangenverarbeitung: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  Und jetzt die Endpunktanforderung (Massenanforderung) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  Ich finde das Thema sehr interessant, im Internet auf Russisch gibt es fast keine Dokumente, Beschreibungen und Artikel zu diesem Thema, und wenn ja, ist es sehr verschwommen.  Wenn das Thema der Arbeit mit Hardware- und Betriebssystementwicklung interessant ist, gibt es viel zu erz√§hlen. <br><br>  Docks: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426421/">https://habr.com/ru/post/de426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426411/index.html">Entwickeln von C ++ / CLI-Deskriptorklassen</a></li>
<li><a href="../de426413/index.html">FESTE Prinzipien, √ºber die jeder Entwickler Bescheid wissen sollte</a></li>
<li><a href="../de426415/index.html">Fintech-Digest: Digitalisierungskontrolle durch die Zentralbank, Gehalt in Kryptow√§hrung, Mir-Karte in Form von Armb√§ndern und Schl√ºsselringen</a></li>
<li><a href="../de426417/index.html">Pavel 2.0: Reptilienberater auf JS, node.js mit Sockets und Telefonie</a></li>
<li><a href="../de426419/index.html">Verbotene √úberlastungs- oder Bridge-Methoden in Java</a></li>
<li><a href="../de426423/index.html">mmWave auf Smartphones: Wie Qualcomm das Unm√∂gliche m√∂glich gemacht hat</a></li>
<li><a href="../de426425/index.html">Die ganze Wahrheit √ºber RTOS. Artikel # 14. Speicherbereiche: Einf√ºhrung und Grundversorgung</a></li>
<li><a href="../de426427/index.html">N√ºtzliches Zeug zum "Zeug": eine kleine Auswahl mit niedrigen Preisen</a></li>
<li><a href="../de426429/index.html">Installation von FreeSWITCH 1.8 unter Debian 9 (Raspbian Stretch, das Grundimage des Smart Home-Systems von MajorDoMo auf Rasbperri Pi)</a></li>
<li><a href="../de426431/index.html">Demontage der Qlie Visual Novel Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>