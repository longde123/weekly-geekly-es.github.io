<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôæ ‚å®Ô∏è ü§∞üèæ .NET: outils pour travailler avec le multithreading et l'asynchronie. 2e partie üò´ ü§ì üíÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je publie l'article original sur Habr, dont la traduction est publi√©e sur le blog Codingsight . 

 Je continue de cr√©er une version texte de mon expos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: outils pour travailler avec le multithreading et l'asynchronie. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Je publie l'article original sur Habr, dont la traduction est publi√©e sur le blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codingsight</a> .</i> <br><br>  Je continue de cr√©er une version texte de mon expos√© lors de la r√©union multithreading.  La premi√®re partie peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , l√†, il s'agissait plus de l'ensemble d'outils de base pour d√©marrer un thread ou une t√¢che, des fa√ßons de voir leur statut et quelques petites choses comme PLinq.  Dans cet article, je souhaite me concentrer davantage sur les probl√®mes pouvant survenir dans un environnement multithread et sur les moyens de les r√©soudre. <br><br><h2>  Table des mati√®res </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä propos des ressources partag√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Probl√®mes possibles lorsque vous travaillez dans un environnement multi-thread</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Condition de course</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Attente occup√©e</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fil de famine</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Outils de synchronisation</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interlocked</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monitor.Enter, Monitor.Exit, lock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monitor.Wait, Monitor.Pulse [Tout]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Famille ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusions</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  √Ä propos des ressources partag√©es </h2><br>  Il est impossible d'√©crire un programme qui fonctionnerait dans plusieurs threads, mais n'aurait pas une seule ressource partag√©e:  m√™me si cela fonctionne √† votre niveau d'abstraction, puis en descendant d'un ou plusieurs niveaux en dessous, il s'av√®re qu'il existe toujours une ressource commune.  Je vais donner quelques exemples: <br><br>  <b>Exemple # 1:</b> <br><br>  Craignant d'√©ventuels probl√®mes, vous avez fait fonctionner les threads avec diff√©rents fichiers.  Par fichier √† diffuser.  Il vous semble que le programme ne poss√®de pas une seule ressource commune. <br><br>  Apr√®s avoir descendu plusieurs niveaux plus bas, nous comprenons qu'il n'y a qu'un seul disque dur et que le pilote ou le syst√®me d'exploitation devront r√©soudre les probl√®mes d'acc√®s √† celui-ci. <br><br>  <b>Exemple # 2:</b> <br><br>  Apr√®s avoir lu l' <i>exemple #</i> 1, vous avez d√©cid√© de placer les fichiers sur deux machines distantes diff√©rentes avec deux morceaux de fer et des syst√®mes d'exploitation physiquement diff√©rents.  Nous gardons 2 connexions diff√©rentes via FTP ou NFS. <br><br>  Apr√®s avoir descendu plusieurs niveaux plus bas, nous comprenons que rien n'a chang√© et que le pilote de la carte r√©seau ou le syst√®me d'exploitation de la machine sur laquelle le programme s'ex√©cute devra r√©soudre le probl√®me de l'acc√®s concurrentiel. <br><br>  <b>Exemple # 3:</b> <br><br>  Ayant perdu une partie consid√©rable de vos cheveux pour tenter de prouver la possibilit√© d'√©crire un programme multi-thread, vous refusez compl√®tement les fichiers et d√©composez les calculs en deux objets diff√©rents, les liens vers chacun d'eux ne sont disponibles que pour un seul flux. <br><br>  Je cloue les douze derniers clous dans le cercueil de cette id√©e: un runtime et un garbage collector, un planificateur de threads, physiquement une RAM et de la m√©moire, un processeur sont toujours des ressources partag√©es. <br><br>  Nous avons donc d√©couvert qu'il est impossible d'√©crire un programme multithread sans une seule ressource partag√©e √† tous les niveaux d'abstraction sur toute la largeur de la pile technologique.  Heureusement, chacun des niveaux d'abstraction, en r√®gle g√©n√©rale, r√©sout partiellement ou compl√®tement les probl√®mes d'acc√®s concurrentiel ou l'interdit simplement (exemple: tout cadre d'interface utilisateur interdit de travailler avec des √©l√©ments de diff√©rents threads), par cons√©quent, les probl√®mes surviennent le plus souvent avec des ressources partag√©es sur votre niveau d'abstraction.  Pour les r√©soudre, introduisez le concept de synchronisation. <br><a name="Problems"></a><br><h2>  Probl√®mes possibles lorsque vous travaillez dans un environnement multi-thread </h2><br>  Les erreurs dans le logiciel peuvent √™tre divis√©es en plusieurs groupes: <br><br><ol><li>  Le programme ne produit aucun r√©sultat.  Se bloque ou se fige. </li><li>  Le programme renvoie un r√©sultat incorrect. </li><li>  Le programme produit le r√©sultat correct, mais ne satisfait pas √† l'une ou l'autre des exigences non fonctionnelles.  Fonctionne trop longtemps ou consomme trop de ressources. </li></ol><br>  Dans un environnement multithread, les deux principaux probl√®mes √† l'origine des erreurs 1 et 2 sont le <b>blocage</b> et la <b>condition de concurrence critique</b> . <br><a name="Deadlock"></a><br><h3>  Impasse </h3><br>  Deadlock - deadlock.  Il existe de nombreuses variantes diff√©rentes.  Les plus courants sont les suivants: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Pendant que le <b>thread # 1</b> faisait quelque chose, le <b>thread # 2 a</b> bloqu√© la ressource <b>B</b> , un peu plus tard le <b>thread # 1 a</b> bloqu√© la ressource <b>A</b> et essaie de verrouiller la ressource <b>B</b> , malheureusement cela ne se produira jamais, car  <b>Le thread # 2 ne</b> lib√©rera la ressource <b>B</b> qu'apr√®s avoir verrouill√© la ressource <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condition de course </h3><br>  Race-Condition - condition de course.  La situation dans laquelle le comportement et le r√©sultat des calculs effectu√©s par le programme d√©pendent du travail du planificateur de threads d'ex√©cution. <br>  Le d√©sagr√©ment de cette situation r√©side pr√©cis√©ment dans le fait que votre programme peut ne pas fonctionner qu'une seule fois sur cent voire sur un million. <br><br>  La situation est aggrav√©e par le fait que les probl√®mes peuvent aller de pair, par exemple: avec un certain comportement du planificateur de threads, un blocage se produit. <br><br>  En plus de ces deux probl√®mes conduisant √† des erreurs √©videntes dans le programme, il y a aussi ceux qui peuvent ne pas conduire √† un r√©sultat de calcul incorrect, mais plus de temps ou de puissance de traitement sera d√©pens√© pour l'obtenir.  Deux de ces probl√®mes sont: <b>attente occup√©e</b> et <b>famine de thread</b> . <br><a name="BusyWait"></a><br><h3>  Attente occup√©e </h3><br>  Busy-Wait est un probl√®me dans lequel le programme consomme des ressources processeur non pas pour les calculs, mais pour l'attente. <br><br>  Souvent, un tel probl√®me dans le code ressemble √† ceci: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Ceci est un exemple de code extr√™mement mauvais car  Un tel code occupe compl√®tement un c≈ìur de votre processeur sans rien faire d'utile.  Cela peut √™tre justifi√© si et seulement s'il est extr√™mement important de traiter une modification d'une valeur dans un autre thread.  Et en parlant rapidement, je parle du cas o√π vous ne pouvez pas attendre m√™me quelques nanosecondes.  Dans d'autres cas, c'est-√†-dire dans tout ce qui peut produire un cerveau sain, il est plus raisonnable d'utiliser les vari√©t√©s ResetEvent et leurs versions Slim.  √Ä leur sujet ci-dessous. <br><br>  Peut-√™tre que l'un des lecteurs proposera de r√©soudre le probl√®me du chargement complet d'un c≈ìur avec une attente inutile en ajoutant des constructions comme Thread.Sleep (1) √† la boucle.  Cela r√©soudra vraiment le probl√®me, mais en cr√©era un autre: le temps de r√©ponse au changement sera en moyenne d'une demi-milliseconde, ce qui peut ne pas √™tre beaucoup, mais catastrophiquement plus que vous ne pourriez utiliser les primitives de synchronisation de la famille ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Fil de famine </h3><br>  Thread-Starvation est un probl√®me o√π le programme a trop de threads fonctionnant simultan√©ment.  Qu'est-ce que cela signifie exactement ces flux qui sont occup√©s par des calculs, et pas seulement en attente d'une r√©ponse de la part de n'importe quel E / S.  Avec ce probl√®me, tout le gain de performances possible de l'utilisation de threads est perdu, car  Le processeur passe beaucoup de temps √† changer de contexte. <br>  Il est pratique de rechercher de tels probl√®mes √† l'aide de divers profileurs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> un exemple de capture d'√©cran du profileur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotTrace</a> lanc√© en mode Timeline. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(L'image est cliquable)</i> <br><br>  Dans le programme qui ne souffre pas de la faim en streaming, il n'y aura pas de couleur rose sur les graphiques refl√©tant les flux.  De plus, dans la cat√©gorie Sous-syst√®mes, il est clair que 30,6% du programme attendait le CPU. <br><br>  Lorsqu'un tel probl√®me est diagnostiqu√©, il est r√©solu tout simplement: vous avez d√©marr√© trop de threads √† la fois, d√©marrez moins ou pas tous √† la fois. <br><a name="SyncPrimitives"></a><br><h2>  Outils de synchronisation </h2><br><a name="Interlocked"></a><br><h3>  Interlocked </h3><br>  C'est peut-√™tre le moyen le plus l√©ger de synchroniser.  Interlocked est une collection d'op√©rations atomiques simples.  Une op√©ration atomique est appel√©e une op√©ration au moment o√π rien ne peut se produire.  Dans .NET, Interlocked est repr√©sent√© par la classe statique du m√™me nom avec un certain nombre de m√©thodes, chacune impl√©mentant une op√©ration atomique. <br><br>  Pour r√©aliser l'horreur des op√©rations non atomiques, essayez d'√©crire un programme qui d√©marre 10 threads, chacun faisant un million d'incr√©ments de la m√™me variable, et √† la fin de leur travail imprimez la valeur de cette variable - malheureusement, elle sera tr√®s diff√©rente de 10 millions, de plus Chaque fois que le programme d√©marre, ce sera diff√©rent.  Cela se produit parce que m√™me une op√©ration aussi simple qu'un incr√©ment n'est pas atomique, mais implique d'extraire une valeur de la m√©moire, d'en calculer une nouvelle et de l'√©crire.  Ainsi, deux threads peuvent effectuer simultan√©ment chacune de ces op√©rations, auquel cas l'incr√©ment sera perdu. <br><br>  La classe Interlocked fournit des m√©thodes Increment / Decrement; il est facile de deviner ce qu'elles font.  Ils sont pratiques √† utiliser si vous traitez des donn√©es dans plusieurs threads et envisagez quelque chose.  Un tel code fonctionnera beaucoup plus rapidement que le verrou classique.  Si Interlocked est utilis√© pour la situation d√©crite dans le dernier paragraphe, le programme distribuera de mani√®re stable 10 millions dans n'importe quelle situation. <br><br>  La m√©thode CompareExchange remplit, √† premi√®re vue, une fonction assez peu √©vidente, mais toute sa pr√©sence vous permet de mettre en ≈ìuvre de nombreux algorithmes int√©ressants, en particulier la famille sans verrouillage. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  La m√©thode prend trois valeurs: la premi√®re est transmise par r√©f√©rence et il s'agit de la valeur qui sera remplac√©e par la seconde, si au moment de la comparaison, location1 correspond √† comparand, la valeur d'origine de location1 sera retourn√©e.  Cela semble assez d√©routant, car il est plus facile d'√©crire du code qui effectue les m√™mes op√©rations que CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Seule une impl√©mentation dans la classe Interlocked sera atomique.  Autrement dit, si nous √©crivions ce code nous-m√™mes, une situation aurait pu se produire lorsque la condition location1 == comparand avait d√©j√† √©t√© remplie, mais au moment o√π l'expression location1 = value a √©t√© ex√©cut√©e, un autre thread avait chang√© la valeur de location1 et il serait perdu. <br><br>  Nous pouvons trouver un bon exemple d'utilisation de cette m√©thode dans le code que le compilateur g√©n√®re pour tout √©v√©nement C #. <br><br>  √âcrivons une classe simple avec un √©v√©nement MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©rons</a> le projet dans la configuration Release et ouvrons l'assembly √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotPeek</a> avec l'option Show Compiler Generated Code activ√©e: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Ici, vous pouvez voir que dans les coulisses, le compilateur a g√©n√©r√© un algorithme plut√¥t sophistiqu√©.  Cet algorithme prot√®ge contre la situation de perte d'un abonnement √† un √©v√©nement lorsque plusieurs threads s'abonnent √† cet √©v√©nement simultan√©ment.  √âcrivons la m√©thode add plus en d√©tail, en nous rappelant ce que fait la m√©thode CompareExchange en arri√®re-plan <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  C'est d√©j√† un peu plus clair, bien qu'il ait probablement encore besoin d'une explication.  En mots, je d√©crirais cet algorithme comme suit: <br><br>  <i>Si MyEvent est toujours le m√™me qu'au moment o√π nous avons commenc√© √† ex√©cuter Delegate.Combine, puis √©crivez-y ce que Delegate.Combine renvoie, et sinon, cela n'a pas d'importance, essayons √† nouveau et r√©p√©tons jusqu'√† ce qu'il sorte.</i> <i><br></i> <br><br>  Aucun abonnement √† l'√©v√©nement ne sera donc perdu.  Vous devrez r√©soudre un probl√®me similaire si vous souhaitez soudainement impl√©menter un tableau dynamique sans verrou thread-safe.  Si plusieurs flux se pr√©cipitent pour y ajouter des √©l√©ments, il est important qu'ils soient tous ajout√©s √† la fin. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, lock </h3><br>  Ce sont les conceptions les plus couramment utilis√©es pour la synchronisation des threads.  Ils impl√©mentent l'id√©e d'une section critique: c'est-√†-dire que le code √©crit entre les appels √† Monitor.Enter, Monitor.Exit sur une ressource peut √™tre ex√©cut√© √† la fois dans un seul thread.  L'instruction de verrouillage est du sucre syntaxique autour des appels Entr√©e / Sortie envelopp√©s dans try-finally.  Une fonctionnalit√© int√©ressante de l'impl√©mentation d'une section critique dans .NET est la possibilit√© de la ressaisir pour le m√™me flux.  Cela signifie qu'un tel code s'ex√©cutera sans probl√®me: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Il est peu probable, bien s√ªr, que quelqu'un √©crive de cette fa√ßon, mais si vous √©talez ce code dans plusieurs m√©thodes en profondeur, cette fonction peut vous faire √©conomiser des ifs.  Afin de rendre une telle astuce possible, les d√©veloppeurs .NET ont d√ª ajouter une restriction - seule une instance d'un type de r√©f√©rence peut √™tre utilis√©e comme objet de synchronisation, et plusieurs octets sont implicitement ajout√©s √† chaque objet o√π l'identifiant de flux sera √©crit. <br><br>  Cette fonctionnalit√© de la section critique en c # impose une limitation int√©ressante au fonctionnement de l'instruction lock: vous ne pouvez pas utiliser l'instruction d'attente √† l'int√©rieur de l'instruction lock.  Au d√©but, cela m'a surpris, car une construction similaire Monitor -Enter / Exit similaire se compile.  Quelle est la question?  Ici, il est n√©cessaire de relire attentivement le dernier paragraphe √† nouveau, puis d'y ajouter quelques connaissances sur le principe asynchrone / attendent: le code apr√®s attendre ne sera pas n√©cessairement ex√©cut√© sur le m√™me thread que le code avant attendre, cela d√©pend du contexte de synchronisation et de la pr√©sence ou aucun appel √† ConfigureAwait.  Il s'ensuit que Monitor.Exit peut s'ex√©cuter sur un thread autre que Monitor.Enter, qui l√®vera une <b>SynchronizationLockException</b> .  Si vous ne le croyez pas, vous pouvez ex√©cuter le code suivant dans une application console: il l√®vera une SynchronizationLockException. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Il est √† noter que dans WinForms ou une application WPF, ce code fonctionnera correctement s'il est appel√© √† partir du thread principal.  il y aura un contexte de synchronisation qui impl√©mente un retour au thread d'interface utilisateur apr√®s l'attente.  Dans tous les cas, vous ne devez pas jouer avec la section critique dans le contexte du code contenant l'op√©rateur d'attente.  Dans ces cas, il est pr√©f√©rable d'utiliser des primitives de synchronisation, qui seront discut√©es plus loin. <br><br>  En parlant du travail de la section critique dans .NET, il convient de mentionner une autre caract√©ristique de sa mise en ≈ìuvre.  La section critique de .NET fonctionne en deux modes: le mode d'attente d'attente et le mode noyau.  L'algorithme spin-wait est commod√©ment repr√©sent√© comme le pseudo-code suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Cette optimisation vise la capture la plus rapide de la section critique en peu de temps, en partant du principe que si la ressource est occup√©e maintenant, elle est sur le point de se lib√©rer.  Si cela ne se produit pas dans un court laps de temps, alors le thread va attendre en mode noyau, ce qui, comme pour en revenir, prend du temps.  Les d√©veloppeurs .NET ont optimis√© le sc√©nario de verrouillage court autant que possible, malheureusement, si de nombreux threads commencent √† d√©chirer la section critique, cela peut entra√Æner une charge CPU √©lev√©e et soudaine. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Puisque j'ai mentionn√© l'algorithme de rotation d'attente, il convient de mentionner les structures BCL SpinLock et SpinWait.  Ils doivent √™tre utilis√©s s'il y a lieu de croire qu'il sera toujours possible de verrouiller tr√®s rapidement.  D'un autre c√¥t√©, cela ne vaut gu√®re la peine de s'en souvenir avant que les r√©sultats du profilage montrent que c'est l'utilisation d'autres primitives de synchronisation qui est le goulot d'√©tranglement de votre programme. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Tout] </h3><br>  Cette paire de m√©thodes doit √™tre consid√©r√©e ensemble.  Avec leur aide, diff√©rents sc√©narios Producteur-Consommateur peuvent √™tre mis en ≈ìuvre. <br><br>  <i>Producteur-consommateur - un mod√®le de conception multi-processus / multi-threads supposant la pr√©sence d'un ou plusieurs threads / processus qui produisent des donn√©es et un ou plusieurs processus / threads qui traitent ces donn√©es.</i>  <i>Utilise g√©n√©ralement une collection partag√©e.</i> <br><br>  Ces deux m√©thodes ne peuvent √™tre appel√©es que si le thread qui les provoque a un verrou pour le moment.  La m√©thode Wait lib√®re le verrou et se bloque jusqu'√† ce qu'un autre thread appelle Pulse. <br><br>  Pour d√©montrer le travail, j'ai √©crit un petit exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(J'ai utilis√© l'image, pas le texte, pour montrer visuellement l'ordre d'ex√©cution des instructions)</i> <br><br>  <u>Analyser:</u> d√©finissez un d√©lai de 100 ms au d√©but du deuxi√®me flux, en particulier pour garantir que son ex√©cution d√©marre plus tard. <br>  - T1: le flux de la ligne n ¬∞ 2 d√©marre <br>  - T1: le flux de la ligne # 3 entre dans la section critique <br>  - T1: Ligne # 6 le ruisseau s'endort <br>  - T2: le flux de la ligne 3 d√©marre <br>  - T2: la ligne # 4 se fige en attendant une section critique <br>  - T1: la ligne # 7 lib√®re la section critique et se fige en attendant la sortie de Pulse <br>  - T2: la ligne # 8 entre dans la section critique <br>  - T2: la ligne # 11 informe T1 en utilisant la m√©thode Pulse <br>  - T2: la ligne # 14 quitte la section critique.  Jusque-l√†, T1 ne peut pas continuer l'ex√©cution. <br>  - T1: la ligne # 15 se r√©veille <br>  - T1: la ligne # 16 quitte la section critique <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSDN</a> a une remarque importante concernant l'utilisation des m√©thodes Pulse / Wait, √† savoir: Monitor ne stocke pas les informations d'√©tat, ce qui signifie que si la m√©thode Pulse est appel√©e avant l'appel de la m√©thode Wait, cela peut entra√Æner un blocage.</i>  <i>Si cette situation est possible, il est pr√©f√©rable d'utiliser l'une des classes de la famille ResetEvent.</i> <br><br>  L'exemple pr√©c√©dent montre clairement comment fonctionnent les m√©thodes Wait / Pulse de la classe Monitor, mais laisse toujours des questions sur le moment o√π il doit √™tre utilis√©.  Un bon exemple serait une telle impl√©mentation de BlockingQueue &lt;T&gt;, d'autre part, l'impl√©mentation de BlockingCollection &lt;T&gt; de System.Collections.Concurrent utilise SemaphoreSlim pour la synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Il s'agit de ma primitive de synchronisation bien-aim√©e, repr√©sent√©e par la classe d'espace de noms System.Threading du m√™me nom.  Il me semble que de nombreux programmes fonctionneraient mieux si leurs d√©veloppeurs utilisaient cette classe au lieu du verrou habituel. <br><br>  <i>Id√©e: plusieurs threads peuvent lire, une seule √©criture.</i>  <i>D√®s que le flux d√©clare son d√©sir d'√©crire, de nouvelles lectures ne peuvent pas √™tre d√©marr√©es, mais attendent la fin de l'enregistrement.</i>  <i>Il y a aussi le concept de verrou de lecture √©volutif, qui peut √™tre utilis√© si vous comprenez pendant le processus de lecture que vous avez besoin d'√©crire quelque chose, un tel verrou sera converti en verrou d'√©criture en une seule op√©ration atomique.</i> <br><br>  <i>Il existe √©galement une classe ReadWriteLock dans l'espace de noms System.Threading, mais elle est fortement recommand√©e pour les nouveaux d√©veloppements.</i>  <i>La version mince permettra d'√©viter un certain nombre de cas conduisant √† des blocages, en plus elle vous permet de capturer rapidement le verrou, car</i>  <i>prend en charge la synchronisation en mode d'attente d'attente avant de quitter pour le mode noyau.</i> <br><br>  Si au moment de la lecture de cet article, vous ne connaissiez pas encore cette classe, je pense que vous avez maintenant rappel√© quelques exemples du code √©crit r√©cemment, o√π une telle approche des verrous permettrait au programme de fonctionner efficacement. <br><br>  L'interface de la classe ReaderWriterLockSlim est simple et directe, mais son utilisation peut difficilement √™tre qualifi√©e de pratique: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  J'aime envelopper son utilisation dans une classe, ce qui rend son utilisation beaucoup plus pratique. <br>  Id√©e: pour cr√©er des m√©thodes Read / WriteLock qui retournent un objet avec la m√©thode Dispose, alors cela leur permettra d'√™tre utilis√© dans l'utilisation et par le nombre de lignes, il ne diff√©rera gu√®re du verrou habituel. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Une telle astuce vous permet d'√©crire simplement plus loin: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  Famille ResetEvent </h3><br>  J'inclus les classes ManualResetEvent, ManualResetEventSlim, AutoResetEvent dans cette famille. <br>  Les classes ManualResetEvent, sa version Slim et la classe AutoResetEvent peuvent √™tre dans deux √©tats: <br>  - Un arm√© (non signal√©), dans cet √©tat, tous les threads qui ont appel√© WaitOne se figent jusqu'√† ce que l'√©v√©nement passe √† un √©tat signal√©. <br>  - L'√©tat abaiss√© (signal√©), dans cet √©tat, tous les flux suspendus sur l'appel WaitOne sont lib√©r√©s.  Tous les nouveaux appels WaitOne sur un √©v√©nement en panne passent conditionnellement instantan√©ment. <br><br>  La classe AutoResetEvent diff√®re de la classe ManualResetEvent en ce qu'elle entre automatiquement dans un √©tat arm√© apr√®s avoir lib√©r√© exactement un thread.  Si plusieurs threads se bloquent en attendant AutoResetEvent, l'appel Set ne lib√©rera qu'un arbitraire, contrairement √† ManualResetEvent.  ManualResetEvent lib√©rera tous les threads. <br><br>  Regardons un exemple du fonctionnement d'AutoResetEvent: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  L'exemple montre que l'√©v√©nement entre automatiquement dans un √©tat arm√© (non signal√©) uniquement en l√¢chant le fil suspendu √† l'appel WaitOne. <br><br>  Contrairement √† ReaderWriterLock, la classe ManualResetEvent n'est pas marqu√©e comme obsol√®te et n'est pas recommand√©e pour une utilisation apr√®s l'apparition de sa version Slim.  La version mince de cette classe est utilis√©e efficacement pour de courtes attentes, comme  Cela se passe en mode Spin-Wait, la version r√©guli√®re convient aux longues. <br><br>  Outre les classes ManualResetEvent et AutoResetEvent, la classe CountdownEvent existe √©galement.  Cette classe est pratique pour l'impl√©mentation d'algorithmes, o√π la partie qui a r√©ussi √† √™tre parall√©lis√©e est suivie par la partie de rassemblement des r√©sultats.  Cette approche est connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fork-join</a> .  Un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article est</a> consacr√© au travail de cette classe, je ne vais donc pas l'analyser en d√©tail ici. <br><a name="Conclusions"></a><br><h2>  Conclusions </h2><br><ul><li>  Lorsque vous travaillez avec des threads, deux probl√®mes entra√Ænant des r√©sultats incorrects ou manquants sont la condition de concurrence critique et le blocage. </li><li>  Les probl√®mes qui font que le programme passe plus de temps ou de ressources - famine de threads et attente occup√©e </li><li>  .NET est riche en synchronisation de threads </li><li>  Il existe 2 modes d'attente de verrouillage - Spin Wait, Core Wait.  Certaines primitives de synchronisation des threads .NET utilisent les deux </li><li>  Interlocked est un ensemble d'op√©rations atomiques, utilis√© dans les algorithmes sans verrouillage, est la primitive de synchronisation la plus rapide </li><li>  L'op√©rateur de verrouillage et Monitor.Enter / Exit impl√©mentent l'id√©e d'une section critique - un morceau de code qui ne peut √™tre ex√©cut√© que par un thread √† la fois </li><li>  Les m√©thodes Monitor.Pulse / Wait sont pratiques pour l'impl√©mentation de scripts Producer-Consumer </li><li>  ReaderWriterLockSlim peut √™tre plus efficace qu'un verrouillage normal dans des scripts o√π la lecture parall√®le est acceptable </li><li>  La famille de classes ResetEvent peut √™tre utile pour la synchronisation des threads. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459514/">https://habr.com/ru/post/fr459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459500/index.html">HTML est le web</a></li>
<li><a href="../fr459502/index.html">Nous continuons √† d√©velopper une plate-forme d'aventure pour les Russes: fonctionnalit√©s d'interface et pr√©f√©rences estivales</a></li>
<li><a href="../fr459504/index.html">Cours pour jeunes concepteurs de jeux: comment compter l'√©quilibre des caract√®res et de l'√©quipement sans math√©matiques</a></li>
<li><a href="../fr459506/index.html">Les aventures des Malvari insaisissables, Partie III: Scripts VBA complexes pour le rire et le profit</a></li>
<li><a href="../fr459508/index.html">5 diapositives que les pr√©sentateurs exp√©riment√©s ignorent</a></li>
<li><a href="../fr459518/index.html">Explication des t√¢ches Python avec entretiens d'embauche</a></li>
<li><a href="../fr459520/index.html">Un mod√®le d'une s√©rie naturelle de nombres et de ses √©l√©ments. Losanges</a></li>
<li><a href="../fr459528/index.html">Comment enseigner l'√©cologie fran√ßaise et collecter les bouteilles</a></li>
<li><a href="../fr459530/index.html">Microbiota. Histoire des m√©thodes d'√©tude et de recherche</a></li>
<li><a href="../fr459532/index.html">Comment choisir un nombre al√©atoire de 1 √† 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>