<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥔 😚 👨‍👧‍👧 Hibernate - tutorial apa yang dibungkam 🔲 🐊 👮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini tidak akan membahas dasar-dasar hibernate (cara mendefinisikan entitas atau menulis kueri kriteria). Di sini saya akan mencoba untuk berbi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hibernate - tutorial apa yang dibungkam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Artikel ini tidak akan membahas dasar-dasar hibernate (cara mendefinisikan entitas atau menulis kueri kriteria).  Di sini saya akan mencoba untuk berbicara tentang hal-hal menarik yang sangat berguna dalam pekerjaan.  Informasi tentang yang belum saya temui di satu tempat. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="gambar"><br><a name="habracut"></a><br>  Saya akan melakukan reservasi segera.  Semua hal berikut ini berlaku untuk Hibernate 5.2.  Kesalahan juga dimungkinkan karena fakta bahwa saya salah memahami sesuatu.  Jika Anda menemukan - tulis. <br><br><h2>  Masalah memetakan model objek menjadi relasional </h2><br>  Tapi mari kita mulai dengan dasar-dasar ORM.  ORM - pemetaan objek-relasional - sehingga kami memiliki model relasional dan objek.  Dan ketika menampilkan satu sama lain, ada masalah yang harus kita selesaikan sendiri.  Mari kita pisahkan mereka. <br><br>  Sebagai ilustrasi, mari kita ambil contoh berikut: kita memiliki entitas "Pengguna", yang bisa berupa Jedi atau pesawat serang.  Jedi harus memiliki kekuatan, dan spesialisasi serangan pesawat.  Di bawah ini adalah diagram kelas. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="gambar"><br><br><h3>  Masalah 1. Warisan dan pertanyaan polimorfik. </h3><br>  Ada pewarisan dalam model objek, tetapi tidak dalam model relasional.  Karenanya, ini adalah masalah pertama - bagaimana memetakan warisan dengan benar ke model relasional. <br><br>  Hibernate menawarkan 3 opsi untuk menampilkan model objek seperti itu: <br><br><ol><li>  Semua ahli waris berada di tabel yang sama: <br>  <b>@Inheritance (strategi = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="gambar"><br><br>  Dalam hal ini, bidang umum dan bidang ahli waris terletak di satu meja.  Menggunakan strategi ini, kami menghindari bergabung ketika memilih entitas.  Dari minus, perlu dicatat bahwa, pertama, kita tidak dapat mengatur batasan “NOT NULL” untuk kolom “force” dalam model relasional, dan kedua, kita kehilangan bentuk normal ketiga.  (ketergantungan transitif dari atribut non-kunci muncul: force and disc). <br><br>  Omong-omong, termasuk untuk alasan ini ada 2 cara untuk menentukan batasan bidang bukan nol - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">NotNull</a> bertanggung jawab untuk validasi;  @ Kolom (nullable = true) - bertanggung jawab atas kendala bukan nol dalam database. <br><br>  Menurut pendapat saya, ini adalah cara terbaik untuk memetakan model objek ke model relasional. <br></li><li>  Bidang khusus entitas berada di tabel terpisah. <br><br>  <b>@Inheritance (strategi = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="gambar"><br><br>  Dalam kasus ini, bidang umum disimpan dalam tabel bersama, dan khusus untuk entitas anak disimpan dalam yang terpisah.  Dengan menggunakan strategi ini, kami mendapatkan GABUNGAN saat memilih entitas, tetapi sekarang kami menyimpan bentuk normal ketiga, dan kami juga dapat menentukan batasan NOT NULL dalam database. </li><li>  Setiap entitas memiliki tabel sendiri. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="gambar"><br><br>  Dalam hal ini, kami tidak memiliki tabel bersama.  Menggunakan strategi ini, kami menggunakan UNION untuk kueri polimorfik.  Kami mengalami masalah dengan generator kunci utama dan kendala integritas lainnya.  Jenis pemetaan warisan sangat tidak dianjurkan. </li></ol><br>  Untuk jaga-jaga, saya akan menyebutkan anotasi - @MappedSuperclass.  Ini digunakan ketika Anda ingin "menyembunyikan" bidang umum untuk beberapa entitas model objek.  Selain itu, kelas yang dijelaskan itu sendiri tidak dianggap sebagai entitas yang terpisah. <br><br><h3>  Masalah 2. Rasio komposisi dalam OOP </h3><br>  Kembali ke contoh kita, kita perhatikan bahwa dalam model objek kita mengambil profil pengguna ke entitas yang terpisah - Profil.  Tetapi dalam model relasional, kami tidak memilih tabel terpisah untuk itu. <br><br>  Sikap OneToOne sering merupakan praktik buruk karena  di pilih, kami memiliki GABUNGAN yang tidak dibenarkan (bahkan menentukan fetchType = LAZY dalam kebanyakan kasus kami akan GABUNG - kami akan membahas masalah ini nanti). <br><br>  Ada penjelasan @Embedable dan @Embeded untuk menampilkan komposisi dalam tabel bersama.  Yang pertama ditempatkan di atas bidang, dan yang kedua di atas kelas.  Mereka dipertukarkan. <br><br><h2>  Manajer Entitas </h2><br>  Setiap instance dari EntityManager (EM) mendefinisikan sesi interaksi dengan database.  Dalam instance EM, ada cache level pertama.  Di sini saya akan menyoroti poin-poin penting berikut: <br><br><ol><li>  <b>Menangkap koneksi basis data</b> <br><br>  Ini hanya poin yang menarik.  Hibernate tidak menangkap Connection pada saat menerima EM, tetapi pada akses pertama ke database atau membuka transaksi (meskipun masalah ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat diselesaikan</a> ).  Ini dilakukan untuk mengurangi waktu koneksi yang sibuk.  Selama menerima EM-a, keberadaan transaksi JTA diperiksa. </li><li>  <b>Entitas gigih selalu memiliki id</b> </li><li>  <b>Entitas yang menjelaskan satu baris dalam database setara dengan referensi</b> <br>  Seperti disebutkan di atas, EM memiliki cache tingkat pertama, objek di dalamnya dibandingkan dengan referensi.  Oleh karena itu, muncul pertanyaan - bidang mana yang harus digunakan untuk mengganti persamaan dan kode hash?  Pertimbangkan opsi berikut: <br><br><ul><li>  Gunakan semua bidang.  Ide yang buruk  sama dengan dapat mempengaruhi bidang LAZY.  Omong-omong, ini juga berlaku untuk metode toString. </li><li>  Gunakan id saja.  Ide yang normal, tetapi ada nuansa juga.  Karena paling sering untuk entitas baru id menempatkan generator pada saat bertahan.  Situasi berikut mungkin terjadi: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Gunakan kunci bisnis (secara kasar, bidang yang unik dan BUKAN NULL).  Tetapi opsi ini tidak selalu nyaman. <br><br>  Ngomong-ngomong, karena kita berbicara tentang NOT NULL dan UNIK, kadang-kadang nyaman untuk membuat konstruktor publik dengan argumen NOT NULL, dan konstruktor tanpa argumen dilindungi. </li><li>  Jangan menimpa sama dengan dan kode hash sama sekali. </li></ul></li><li>  <b>Cara kerja flush</b> <br>  Flush - mengeksekusi akumulasi insert, update, dan delete pada database.  Secara default, flush dijalankan dalam kasus: <br><br><ul><li>  Sebelum menjalankan kueri (dengan pengecualian em.get), ini perlu untuk mematuhi prinsip ACID.  Misalnya: kami mengubah tanggal lahir pesawat serang, dan kemudian kami ingin mendapatkan jumlah pesawat serang orang dewasa. <br><br>  Jika kita berbicara tentang CriteriaQuery atau JPQL, maka flush akan dieksekusi jika kueri memengaruhi tabel yang entitasnya ada dalam cache dari level pertama. </li><li>  Saat melakukan transaksi; </li><li>  Kadang-kadang ketika mempertahankan entitas baru - dalam kasus ketika kita bisa mendapatkan id hanya melalui sisipan. </li></ul><br>  Dan sekarang tes kecil.  Berapa banyak operasi UPDATE yang akan dilakukan dalam kasus ini? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Fitur hibernasi yang menarik disembunyikan di bawah operasi flush - ia berusaha mengurangi waktu yang diperlukan untuk mengunci baris dalam database. <br><br>  Perhatikan juga bahwa ada beberapa strategi berbeda untuk operasi flush.  Misalnya, Anda dapat melarang "penggabungan" perubahan ke database - ini disebut MANUAL (ini juga menonaktifkan mekanisme pemeriksaan kotor). <br></li><li>  <b>Pemeriksaan kotor</b> <br><br>  Pengecekan Kotor adalah mekanisme yang dilakukan selama operasi flush.  Tujuannya adalah untuk menemukan entitas yang telah berubah dan memperbaruinya.  Untuk menerapkan mekanisme seperti itu, hibernate harus menyimpan salinan asli objek (dengan objek apa yang sebenarnya akan dibandingkan).  Untuk lebih tepatnya, hibernate menyimpan salinan bidang objek, bukan objek itu sendiri. <br><br>  Perlu dicatat bahwa jika grafik entitas besar, maka operasi pemeriksaan kotor bisa mahal.  Jangan lupa bahwa hibernate menyimpan 2 salinan entitas (secara kasar). <br>  Untuk "mengurangi biaya" dari proses ini, gunakan fitur berikut: <br><br><ul><li>  em.detach / em.clear - lepaskan entitas dari EntityManager </li><li>  FlushMode = MANUAL - berguna dalam operasi baca </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Abadi</a> - juga menghindari operasi pengecekan kotor </li></ul><br></li><li>  <b>Transaksi</b> <br><br>  Seperti yang Anda ketahui, hibernasi memungkinkan Anda memperbarui entitas hanya dalam transaksi.  Operasi baca menawarkan lebih banyak kebebasan - kita dapat menjalankannya tanpa secara eksplisit membuka transaksi.  Tetapi justru ini pertanyaannya: apakah layak untuk membuka transaksi secara eksplisit untuk operasi baca? <br><br>  Saya akan mengutip beberapa fakta: <br><br><ul><li>  Pernyataan apa pun dijalankan di basis data di dalam transaksi.  Bahkan jika kita jelas tidak membukanya.  (mode komit otomatis). </li><li>  Sebagai aturan, kami tidak terbatas pada satu permintaan ke database.  Misalnya: untuk mendapatkan 10 catatan pertama, Anda mungkin ingin mengembalikan jumlah total catatan.  Dan ini hampir selalu 2 permintaan. </li><li>  Jika kita berbicara tentang data pegas, maka metode repositori adalah transaksional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara default</a> , sedangkan metode baca hanya baca. </li><li>  Anotasi pegas @Transaksional (readOnly = true) juga memengaruhi FlushMode, lebih tepatnya, Pegas meletakkannya dalam status MANUAL, sehingga hibernate tidak akan melakukan pemeriksaan kotor. </li><li>  Pengujian sintetis dengan satu atau dua permintaan basis data akan menunjukkan bahwa komit otomatis lebih cepat.  Tetapi dalam mode tempur, ini mungkin tidak begitu.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel bagus tentang hal ini</a> , + lihat komentar) </li></ul><br>  Singkatnya: adalah praktik yang baik untuk melakukan komunikasi apa pun dengan database dalam suatu transaksi. <br></li></ol><br><h2>  Generator </h2><br>  Generator diperlukan untuk menggambarkan bagaimana kunci utama entitas kita akan menerima nilai.  Mari kita cepat membahas opsi: <br><br><ul><li>  <b>GenerationType.AUTO</b> - pemilihan generator didasarkan pada dialek.  Bukan pilihan terbaik, karena aturan "eksplisit lebih baik daripada implisit" hanya berlaku di sini. </li><li>  <b>GenerationType.IDENTITY</b> adalah cara termudah untuk mengonfigurasi generator.  Itu bergantung pada kolom kenaikan otomatis di tabel.  Karena itu, untuk mendapatkan id dengan persisten kita perlu melakukan insert.  Itulah sebabnya mengapa menghilangkan kemungkinan ditangguhkan bertahan dan karena itu batching. </li><li>  <b>GenerationType.SEQUENCE</b> adalah kasus paling nyaman ketika kita mendapatkan id dari urutan. </li><li>  <b>GenerationType.TABLE</b> - dalam hal ini hibernate mengemulasi urutan melalui tabel tambahan.  Bukan pilihan terbaik, karena  dalam solusi semacam itu, hibernate harus menggunakan transaksi terpisah dan mengunci per baris. </li></ul><br>  Mari kita bicara sedikit lebih banyak tentang urutan.  Untuk meningkatkan kecepatan operasi, hibernate menggunakan algoritma optimasi yang berbeda.  Semuanya ditujukan untuk mengurangi jumlah percakapan dengan database (jumlah perjalanan pulang pergi).  Mari kita lihat lebih detail: <br><br><ul><li>  <b>tidak ada</b> - tidak ada optimasi.  untuk setiap id kita tarik urutan. </li><li>  <b>pooled dan pooled-lo</b> - dalam hal ini, sekuens kami harus meningkat dengan interval tertentu - N dalam database (SequenceGenerator.allocationSize).  Dan dalam aplikasi, kami memiliki kumpulan tertentu, nilai-nilai dari mana kami dapat menetapkan untuk entitas baru tanpa mengakses database .. </li><li>  <b>hilo</b> - untuk menghasilkan ID, algoritma hilo menggunakan 2 angka: hi (disimpan dalam database - nilai yang diperoleh dari panggilan urutan) dan lo (disimpan hanya dalam aplikasi - SequenceGenerator.allocationSize).  Berdasarkan angka-angka ini, interval untuk menghasilkan id dihitung sebagai berikut: [(hi - 1) * lo + 1, hi * lo + 1).  Untuk alasan yang jelas, algoritma ini dianggap ketinggalan jaman dan tidak disarankan untuk menggunakannya. </li></ul><br>  Sekarang mari kita lihat bagaimana pengoptimal dipilih.  Hibernate memiliki beberapa generator urutan.  Kami akan tertarik pada 2 dari mereka: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> adalah generator lama yang menggunakan pengoptimal hilo.  Dipilih secara default jika kita memiliki hibernate.id.new_generator_mappings == properti palsu. </li><li>  <b>SequenceStyleGenerator</b> - digunakan secara default (jika hibernate.id.new_generator_mappings == true property).  Generator ini mendukung beberapa pengoptimal, tetapi standarnya dikumpulkan. </li></ul><br>  Anda juga dapat mengkonfigurasi anotasi generator @GenericGenerator. <br><br><h2>  Jalan buntu </h2><br>  Mari kita lihat contoh situasi kode semu yang dapat menyebabkan kebuntuan: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Untuk mencegah masalah seperti itu, hibernate memiliki mekanisme yang menghindari kebuntuan jenis ini - parameter hibernate.order_updates.  Dalam hal ini, semua pembaruan akan dipesan oleh id dan dieksekusi.  Saya juga akan menyebutkan sekali lagi bahwa hibernate sedang mencoba untuk "menunda" penangkapan koneksi dan eksekusi insert dan pembaruan. <br><br><h2>  Set, Tas, Daftar </h2><br>  Hibernate memiliki 3 cara utama untuk menyajikan koleksi komunikasi OneToMany. <br><br><ul><li>  Set - set entitas yang tidak terurut tanpa pengulangan; </li><li>  Bag - seperangkat entitas yang tidak teratur; </li><li>  Daftar adalah seperangkat entitas yang dipesan. </li></ul><br>  Tidak ada kelas untuk Bag di inti java yang akan menggambarkan struktur seperti itu.  Karena itu, semua Daftar dan Koleksi adalah tas kecuali Anda menentukan kolom di mana koleksi kami akan diurutkan (anotasi OrderColumn. Jangan bingung dengan SortBy).  Saya sangat merekomendasikan untuk tidak menggunakan anotasi OrderColumn karena implementasi fitur yang buruk (menurut saya) - tidak kueri sql yang optimal, kemungkinan NULL dalam lembar. <br><br>  Muncul pertanyaan, tetapi apa yang lebih baik menggunakan tas atau set?  Untuk mulai dengan, saat menggunakan tas, masalah berikut mungkin terjadi: <br><br><ul><li>  Jika versi hibernate Anda lebih rendah dari 5.0.8, maka ada bug yang agak serius - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HHH-5855</a> - saat memasukkan entitas anak, duplikasinya dimungkinkan (dalam kasus cascadType = MERGE dan PERSIST); </li><li>  Jika Anda menggunakan tas untuk hubungan ManyToMany, maka hibernate menghasilkan kueri yang sangat tidak pantas saat menghapus entitas dari koleksi - pertama-tama menghapus semua baris dari tabel bergabung, dan kemudian melakukan memasukkan; </li><li>  Hibernate tidak dapat mengambil beberapa tas untuk entitas yang sama secara bersamaan. </li></ul><br>  Jika Anda ingin menambahkan entitas lain ke koneksi @OneToMany, akan lebih menguntungkan jika menggunakan Bag, karena  tidak memerlukan pemuatan semua entitas terkait untuk operasi ini.  Mari kita lihat sebuah contoh: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Referensi Kekuatan </h2><br>  Referensi adalah referensi ke objek, yang kami putuskan untuk menunda pemuatan.  Dalam kasus hubungan ManyToOne dengan fetchType = LAZY, kami mendapatkan referensi seperti itu.  Inisialisasi objek terjadi pada saat mengakses bidang entitas, dengan pengecualian id (karena kita tahu nilai bidang ini). <br><br>  Perlu dicatat bahwa dalam kasus Lazy Loading, referensi selalu merujuk ke baris yang ada dalam database.  Untuk alasan ini, sebagian besar kasus Pemuatan Malas tidak berfungsi dalam hubungan OneToOne - hibernate perlu dibuat BERGABUNG untuk memeriksa apakah koneksi sudah ada dan sudah GABUNG, lalu hibernasi memuatnya ke dalam model objek.  Jika kami mengindikasikan nullable = true di OneToOne, maka LazyLoad harus berfungsi. <br><br>  Kita dapat membuat referensi kita sendiri menggunakan metode em.getReference.  Benar, dalam hal ini tidak ada jaminan bahwa referensi merujuk ke baris yang ada dalam database. <br><br>  Mari kita beri contoh menggunakan tautan seperti itu: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Untuk berjaga-jaga, saya mengingatkan Anda bahwa kami akan mendapatkan LazyInitializationException jika terjadi EM atau tautan terpisah. <br><br><h2>  Tanggal dan waktu </h2><br>  Terlepas dari kenyataan bahwa java 8 memiliki API yang sangat baik untuk bekerja dengan tanggal dan waktu, JDBC API masih memungkinkan Anda untuk bekerja hanya dengan API tanggal yang lama.  Karena itu, kami akan menganalisis beberapa poin menarik. <br><br>  Pertama, Anda perlu memahami dengan jelas perbedaan antara LocalDateTime dan Instan dan ZonedDateTime.  (Saya tidak akan melakukan peregangan, tapi saya akan memberikan artikel bagus tentang topik ini: yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Jika singkat</b> <div class="spoiler_text">  LocalDateTime dan LocalDate mewakili tuple angka reguler.  Mereka tidak terikat pada waktu tertentu.  Yaitu  waktu pendaratan pesawat tidak dapat disimpan di LocalDateTime.  Dan tanggal lahir melalui LocalDate cukup normal.  Instan mewakili suatu titik waktu, relatif yang dengannya kita dapat memperoleh waktu setempat di titik mana pun di planet ini. <br></div></div><br>  Poin yang lebih menarik dan penting adalah bagaimana tanggal disimpan dalam database.  Jika kita memiliki TIMESTAMP DENGAN tipe TIMEZONE ditempelkan, maka seharusnya tidak ada masalah, tetapi jika TIMESTAMP (TANPA TIMEZONE) berdiri, maka ada kemungkinan bahwa tanggal akan ditulis / dibaca salah.  (tidak termasuk LocalDate dan LocalDateTime) <br><br>  Mari kita lihat mengapa: <br><br>  Saat kami menyimpan tanggal, metode dengan tanda tangan berikut digunakan: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Seperti yang Anda lihat, API lama digunakan di sini.  Argumen Kalender opsional diperlukan untuk mengonversi cap waktu ke representasi string.  Yaitu menyimpan zona waktu dengan sendirinya.  Jika Kalender tidak dikirim, maka Kalender digunakan secara default dengan zona waktu JVM. <br><br>  Ada 3 cara untuk mengatasi masalah ini: <br><br><ul><li>  Tetapkan JVM zona waktu yang diinginkan </li><li>  Gunakan parameter hibernate - hibernate.jdbc.time_zone (ditambahkan pada 5.2) - hanya akan memperbaiki ZonedDateTime dan OffsetDateTime </li><li>  Gunakan jenis TIMESTAMP DENGAN TIMEZONE </li></ul><br>  Pertanyaan yang menarik, mengapa LocalDate dan LocalDateTime tidak termasuk dalam masalah seperti itu? <br><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Untuk menjawab pertanyaan ini, Anda perlu memahami struktur kelas java.util.Date (java.sql.Date dan java.sql.Timestamp, ahli warisnya dan perbedaannya dalam hal ini tidak mengganggu kami).  Date menyimpan tanggal dalam milidetik sejak 1970, secara kasar berbicara dalam UTC, tetapi metode toString mengubah tanggal menurut zona waktu sistem. <br><br>  Dengan demikian, ketika kita mendapatkan tanggal tanpa zona waktu dari database, itu dipetakan ke objek Timestamp sehingga metode toString menampilkan nilai yang diinginkan.  Pada saat yang sama, jumlah milidetik sejak tahun 1970 dapat berbeda (tergantung pada zona waktu).  Itu sebabnya hanya waktu lokal yang selalu ditampilkan dengan benar. <br><br>  Saya juga memberikan contoh kode yang bertanggung jawab untuk mengubah Timesamp ke LocalDateTime dan Instan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Batching </h2><br>  Secara default, kueri dikirim ke database satu per satu.  Ketika batching diaktifkan, hibernate akan dapat mengirim beberapa pernyataan dalam satu permintaan ke database.  (mis. batching mengurangi jumlah perjalanan pulang-pergi ke basis data) <br><br>  Untuk melakukan ini, Anda harus: <br><br><ul><li>  Aktifkan batching dan atur jumlah pernyataan maksimum: <br>  hibernate.jdbc.batch_size (disarankan 5 hingga 30) </li><li>  Aktifkan penyortiran sisipan dan perbarui: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Jika kita menggunakan versi, maka kita juga harus mengaktifkannya <br>  hibernate.jdbc.batch_versioned_data - hati-hati di sini, Anda memerlukan driver jdbc untuk dapat memberikan jumlah baris yang terpengaruh selama pembaruan. </li></ul><br>  Saya juga akan mengingatkan Anda tentang efektivitas operasi em.clear () - ini melepaskan ikatan entitas dari mereka, sehingga membebaskan memori dan mengurangi waktu operasi pengecekan kotor. <br>  Jika kita menggunakan postgres, maka kita juga bisa mengatakan hibernate untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">insert multi-mentah</a> . <br><br><h2>  Masalah N +1 </h2><br>  Ini adalah topik yang cukup umum, jadi cepatlah membahasnya. <br><br>  Masalah N +1 adalah situasi di mana, alih-alih satu permintaan untuk memilih buku N, setidaknya terjadi permintaan N +1. <br><br>  Cara termudah untuk menyelesaikan masalah N +1 adalah dengan mengambil tabel terkait.  Dalam hal ini, kami mungkin mengalami beberapa masalah lain: <br><br><ul><li>  <b>Pagination.</b>  dalam kasus hubungan OneToMany, hibernasi tidak akan dapat menentukan offset dan batas.  Oleh karena itu, pagination akan muncul di memori. </li><li>  <b>Masalah produk Cartesian</b> adalah situasi ketika database mengembalikan baris N * M * K untuk memilih buku N dengan bab M dan penulis K. </li></ul><br>  Ada cara lain untuk menyelesaikan masalah N +1. <br><br><ul><li>  <b>FetchMode</b> - memungkinkan Anda untuk mengubah algoritma pemuatan entitas anak.  Dalam kasus kami, kami tertarik pada yang berikut: <ul><li>  <b>FetchType.SUBSELECT</b> - Memuat catatan anak dalam permintaan terpisah.  Kelemahannya adalah bahwa semua kompleksitas permintaan utama diulangi dalam subselect. </li><li>  <b>BATCH (FetchType.SELECT + anotasi BatchSize)</b> - juga memuat catatan sebagai permintaan terpisah, tetapi bersama dengan subquery membuat kondisi seperti WHERE parent_id IN (?,?,?, ..., N) </li></ul>  Perlu dicatat bahwa saat menggunakan fetch di API Kriteria, FetchType diabaikan - GABUNG selalu digunakan </li><li>  <b>JPA EntityGraph dan Hibernate FetchProfile</b> - memungkinkan Anda untuk membuat aturan pemuatan entitas menjadi abstraksi terpisah - menurut pendapat saya kedua implementasi tidak nyaman. </li></ul><br><h2>  Pengujian </h2><br>  Idealnya, lingkungan pengembangan harus memberikan informasi yang berguna sebanyak mungkin tentang operasi hibernate dan tentang interaksi dengan database.  Yaitu: <br><br><ul><li>  Penebangan <ul><li>  org.hibernate.SQL: debug </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Statistik <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Dari utilitas yang bermanfaat, berikut ini dapat dibedakan: <br><ul><li>  <b>DBUnit</b> - memungkinkan Anda untuk menggambarkan keadaan basis data dalam format XML.  Terkadang itu nyaman.  Tetapi lebih baik pikirkan lagi apakah Anda membutuhkannya. </li><li>  DataSource-proxy <ul><li>  <b>p6spy</b> adalah salah satu solusi tertua.  menawarkan logging, runtime, dll. permintaan </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> adalah utilitas praktis untuk menemukan masalah N +1.  Ini juga memungkinkan Anda untuk mencatat kueri.  Komposisi tersebut mencakup anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Coba Lagi yang</a> menarik, yang mencoba kembali transaksi dalam kasus OptimisticLockException. </li><li>  <b>Sniffy</b> - memungkinkan Anda untuk menegaskan jumlah permintaan melalui anotasi.  Dalam beberapa hal, lebih elegan daripada keputusan dari Vlad. </li></ul></li></ul><br>  Tetapi sekali lagi saya ulangi bahwa ini hanya untuk pengembangan, ini tidak boleh dimasukkan dalam produksi. <br><br><h2>  Sastra </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan oleh Nikolai Alimenkov - Mari kita cepatkan Hibernate</a> - laporan inilah yang menginspirasi saya untuk belajar hibernasi lebih dalam.  Di bawah ini adalah sumber daya yang saya gunakan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku "Java Persistence API and Hibernate"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vlad M. Blog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Weakly Digest</a> - Daily Digest (tidak langsung terkait dengan topik) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416851/">https://habr.com/ru/post/id416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416841/index.html">Cara menguji hipotesis dan menghasilkan uang di Swift menggunakan tes terpisah</a></li>
<li><a href="../id416843/index.html">Mesin roket nuklir dan sistem propulsi listrik roket nuklir</a></li>
<li><a href="../id416845/index.html">10 alasan untuk menggunakan itracking atau meninggalkannya selamanya</a></li>
<li><a href="../id416847/index.html">Situs Admin Ammyy kembali diganggu</a></li>
<li><a href="../id416849/index.html">Oh, kode saya. Bagaimana menjadi administrator sistem</a></li>
<li><a href="../id416855/index.html">Sarjana dari Universitas Negeri St. Petersburg</a></li>
<li><a href="../id416857/index.html">Kami membangun kuil - dalam kode dan dalam kehidupan. Pengalaman saya mengembangkan aplikasi Android kedua saya</a></li>
<li><a href="../id416859/index.html">Temui Semua Seketika Bereaksi Boilerplate oleh Maximilian Stoiber v3.6.0</a></li>
<li><a href="../id416863/index.html">Cara baru untuk memperkenalkan peserta pameran</a></li>
<li><a href="../id416865/index.html">Desain retro untuk konsol portabel pertama dari tahun 1979 yang jauh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>