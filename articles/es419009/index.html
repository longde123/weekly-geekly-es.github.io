<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° üí± üà≥ Clang e IDE: una historia sobre la amistad y la amistad üçï üëû ‚è¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para m√≠, comenz√≥ hace seis a√±os y medio, cuando, por voluntad del destino, me atrajeron a un proyecto cerrado. Cuyo proyecto - no preguntes, no lo dir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clang e IDE: una historia sobre la amistad y la amistad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419009/"><p><img src="https://habrastorage.org/webt/yi/u_/xb/yiu_xbaeyduzvwqklgpu5xujgvo.png" align="left">  Para m√≠, comenz√≥ hace seis a√±os y medio, cuando, por voluntad del destino, me atrajeron a un proyecto cerrado.  Cuyo proyecto - no preguntes, no lo dir√©.  Solo puedo decir que su idea fue simple como un rastrillo: incrustar el front-end clang en el IDE.  Bueno, como se hizo recientemente en QtCreator, en CLion (en cierto sentido), etc. Clang era entonces una estrella en ascenso, muchos estaban tratando de evitar la posibilidad de utilizar finalmente el analizador de C ++ completo de forma casi gratuita.  Y la idea, por as√≠ decirlo, literalmente estaba en el aire (y el autocompletado del c√≥digo integrado en la API de clang fue insinuado por Be), solo ten√≠a que tomarlo y hacerlo.  Pero, como dijo Boromir, "No puedes tomarlo y ...".  Entonces sucedi√≥ en este caso.  Para m√°s detalles - Bienvenido bajo cat. </p><a name="habracut"></a><br><h2 id="snachala-o-horoshem">  Primero sobre el bien </h2><br><p>  Los beneficios de usar clang como un analizador incorporado en el IDE C ++, por supuesto, son.  Al final, las funciones IDE no se limitan √∫nicamente a la edici√≥n de archivos.  Esta es una base de datos de caracteres, tareas de navegaci√≥n, dependencias y mucho m√°s.  Y aqu√≠, un compilador completo se dirige a su altura m√°xima, porque dominar todo el poder del preprocesador y las plantillas en un analizador autoescrito relativamente simple no es una tarea trivial.  Debido a que generalmente tiene que hacer muchos compromisos, lo que obviamente afecta la calidad del an√°lisis de c√≥digo.  A qui√©n le importa: puede ver, por ejemplo, el analizador incorporado de QtCeator aqu√≠: analizador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qt Creator C ++</a> </p><br><p>  En el mismo lugar, en el c√≥digo fuente de QtCreator, puede ver que lo anterior no es todo lo que el IDE requiere del analizador.  Adem√°s, necesita al menos: </p><br><ul><li>  resaltado de sintaxis (l√©xico y sem√°ntico) </li><li>  todo tipo de sugerencias "sobre la marcha" con la visualizaci√≥n de informaci√≥n en el s√≠mbolo </li><li>  Consejos sobre lo que est√° mal con el c√≥digo y c√≥mo solucionarlo / complementarlo </li><li>  Completar c√≥digo en una amplia variedad de contextos </li><li>  la refactorizaci√≥n m√°s diversa </li></ul><br><p>  Por lo tanto, en los beneficios enumerados anteriormente (¬°realmente serio!), Las ventajas terminan y comienza el dolor.  Para comprender mejor este dolor, primero puede ver el informe de Anastasia Kazakova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">anastasiak2512</a> ) sobre lo que realmente se requiere del analizador de c√≥digo integrado en el IDE: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4giOynD7Emg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="sut-problemy">  La esencia del problema </h2><br><p>  Pero es simple, aunque puede no ser obvio a primera vista.  En pocas palabras, entonces: clang es un <em>compilador</em> .  Y se refiere al c√≥digo como un <em>compilador</em> .  Y agudizado por el hecho de que el c√≥digo se le ha entregado ya completado, y no el trozo del archivo que ahora est√° abierto en el editor IDE.  A los compiladores no les gustan los bits de archivos, como construcciones incompletas, identificadores escritos incorrectamente, <strong>retrun en</strong> lugar de <strong>return</strong> y otras delicias que pueden surgir aqu√≠ y ahora en el editor.  Por supuesto, antes de la compilaci√≥n, todo esto se limpiar√°, arreglar√° y pondr√° en l√≠nea.  Pero aqu√≠ y ahora, en el editor, es lo que es.  Y es de esta forma que el analizador integrado en el IDE llega a la tabla cada 5-10 segundos.  Y si la versi√≥n autoescrita del mismo "comprende" perfectamente que se trata de un producto semiacabado, entonces el sonido met√°lico no.  Y muy sorprendido.  Lo que sucede como resultado de tal sorpresa depende "de", como dicen. </p><br><p>  Afortunadamente, clang es bastante tolerante con los errores de c√≥digo.  Sin embargo, puede haber sorpresas: luz de fondo que desaparece repentinamente, curva de autocompletar, diagn√≥sticos extra√±os.  Necesitas estar preparado para todo esto.  Adem√°s, el sonido met√°lico no es omn√≠voro.  Tiene derecho a no aceptar nada en los encabezados del compilador, que aqu√≠ y ahora se usa para construir el proyecto.  Las intr√≠nsecas complicadas, las extensiones no est√°ndar y otras, um ..., caracter√≠sticas, todo esto puede conducir a errores de an√°lisis en los lugares m√°s inesperados.  Y, por supuesto, el rendimiento.  Editar un archivo de gram√°tica en Boost.Spirit o trabajar en un proyecto basado en llvm ser√° un placer.  Pero, sobre todo con m√°s detalle. </p><br><h2 id="kod-polufabrikat">  C√≥digo prefabricado </h2><br><p>  Entonces, digamos que comenz√≥ un nuevo proyecto.  Su entorno gener√≥ un espacio en blanco predeterminado para main.cpp, y en √©l escribi√≥: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { foo(10) }</span></span></span></span></code> </pre> <br><p>  El c√≥digo, desde el punto de vista de C ++, francamente, no es v√°lido.  No hay una definici√≥n de la funci√≥n foo (...) en el archivo, la l√≠nea no est√° completa, etc. Pero ... usted acaba de comenzar.  Este c√≥digo tiene derecho a este tipo.  ¬øC√≥mo percibe este c√≥digo un IDE con un analizador auto-escrito (en este caso, CLion)? </p><br><p><img src="https://habrastorage.org/webt/us/8y/ni/us8yni2bzf5zpm6epgx_uh7m4bs.png"></p><br><p>  Y si hace clic en la bombilla, puede ver esto: </p><br><p><img src="https://habrastorage.org/webt/p2/ej/h4/p2ejh4woiuojsq19oq90rmozhrm.png"></p><br><p>  Tal IDE, sabiendo algo, um, m√°s sobre lo que est√° sucediendo, ofrece la opci√≥n muy esperada: crear una funci√≥n desde el contexto de uso.  Gran oferta, creo.  ¬øC√≥mo se comporta el IDE basado en clang (en este caso, Qt Creator 4.7)? </p><br><p><img src="https://habrastorage.org/webt/ql/pa/hj/qlpahj0vu5of_my6s1ymrelsa3o.png"></p><br><p>  ¬øY qu√© se propone para rectificar la situaci√≥n?  Pero nada!  ¬°Solo cambio de nombre est√°ndar! </p><br><p><img src="https://habrastorage.org/webt/kk/0m/pt/kk0mptuuwnufqjugzumnoisnyms.png"></p><br><p>  La raz√≥n de este comportamiento es muy simple: para el sonido met√°lico, este texto est√° completo (y no puede ser otra cosa).  Y √©l construye el AST basado en esta suposici√≥n.  Y luego todo es simple: clang ve un identificador previamente indefinido.  Este es texto en C ++ (no en C).  No se hacen suposiciones sobre la naturaleza del identificador: no est√° definido, por lo que un fragmento de c√≥digo no es v√°lido.  Y en AST para esta l√≠nea no aparece nada.  Ella simplemente no est√° all√≠.  Y lo que no est√° en AST es imposible de analizar.  Es una pena, molesto, est√° bien. </p><br><p>  El analizador incorporado en el IDE proviene de algunas otras suposiciones.  √âl <em>sabe</em> que el c√≥digo no est√° terminado.  Que el programador est√° ahora apresurando el pensamiento y los dedos detr√°s de ella no tienen tiempo.  Por lo tanto, no todos los identificadores se pueden definir.  Dicho c√≥digo, por supuesto, es incorrecto desde el punto de vista de los altos est√°ndares de calidad del compilador, pero el analizador sabe qu√© se puede hacer con dicho c√≥digo y ofrece opciones.  Opciones bastante razonables. </p><br><p>  Al menos hasta la versi√≥n 3.7 (inclusive), se produjeron problemas similares en este c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Temp { public: int i; }; template&lt;typename T&gt; class Foo { public: int Bar(Temp tmp) { Tpl(tmp); } private: template&lt;typename U&gt; void Tpl(U val) { Foo&lt;U&gt; tmp(val); tmp. } int member; }; int main() { return 0; }</span></span></span></span></code> </pre> <br><p>  Dentro de los m√©todos de clase de plantilla, el autocompletado basado en clang no funcion√≥.  Por lo que pude averiguar, la raz√≥n estaba en el an√°lisis de plantillas de dos pasos.  El autocompletado en clang se activa en la primera pasada, cuando la informaci√≥n sobre los tipos realmente utilizados puede no ser suficiente.  En clang 5.0 (a juzgar por las notas de la versi√≥n), esto se solucion√≥. </p><br><p>  De una forma u otra, las situaciones en las que el compilador no puede construir el AST correcto (o sacar las conclusiones correctas del contexto) en el c√≥digo editado pueden serlo.  Y en este caso, el IDE simplemente no "ver√°" las secciones de texto correspondientes y no podr√° ayudar al programador de ninguna manera.  Lo cual, por supuesto, no es genial.  La capacidad de trabajar eficazmente con c√≥digo incorrecto es lo que necesita el analizador en el IDE y lo que el compilador normal no necesita en absoluto.  Por lo tanto, el analizador en el IDE puede usar muchas heur√≠sticas, que para el compilador pueden ser no solo in√∫tiles, sino tambi√©n da√±inas.  Y para implementar dos modos de funcionamiento en √©l, bueno, a√∫n necesita convencer a los desarrolladores. </p><br><h2 id="eta-rol---rugatelnaya">  "¬°Este papel es abusivo!" </h2><br><p>  El IDE del programador suele ser uno (bueno, dos), pero hay muchos proyectos y cadenas de herramientas.  Y, por supuesto, no quiero hacer ning√∫n gesto adicional para cambiar de cadena de herramientas a cadena de herramientas, de proyecto a proyecto.  Uno o dos clics, y la configuraci√≥n de compilaci√≥n cambia de Debug a Release, y el compilador de MSVC a MinGW.  Pero el analizador de c√≥digo en el IDE sigue siendo el mismo.  Y debe, junto con el sistema de construcci√≥n, cambiar de una configuraci√≥n a otra, de una cadena de herramientas a otra.  Una cadena de herramientas puede ser ex√≥tica o cruzada.  Y la tarea del analizador aqu√≠ es continuar analizando correctamente el c√≥digo.  Si es posible con un m√≠nimo de errores. </p><br><p>  el sonido met√°lico es lo suficientemente omn√≠voro.  Se puede obligar a aceptar extensiones del compilador de Microsoft, el compilador gcc.  Se pueden pasar opciones en el formato de estos compiladores, y el sonido met√°lico incluso las entender√°.  Pero todo esto no garantiza que el sonido met√°lico acepte cualquier partida de los menudillos recogidos del tanque de gcc.  Cualquier __builtin_intrinsic_xxx puede convertirse en un obst√°culo para √©l.  O el lenguaje construye que la versi√≥n actual de clang en el IDE simplemente no es compatible.  Lo m√°s probable es que esto no afecte la calidad de la construcci√≥n AST para el archivo editado actualmente.  Pero construir una base de caracteres global o guardar encabezados precompilados puede romperse.  Y esto puede ser un problema grave.  Un problema similar podr√≠a ser un c√≥digo similar, no en los encabezados de las cadenas de herramientas o de terceros, sino en los encabezados o c√≥digos fuente del proyecto.  Por cierto, todo esto es una raz√≥n suficientemente significativa para decirle expl√≠citamente al sistema de compilaci√≥n (e IDE) sobre qu√© archivos de encabezado para su proyecto son "extra√±os".  Puede hacerte la vida m√°s f√°cil. </p><br><p>  Nuevamente, el IDE se dise√±√≥ originalmente para usarse con diferentes compiladores, configuraciones, cadenas de herramientas y m√°s.  Dise√±ado para tener que lidiar con el c√≥digo, algunos de cuyos elementos no son compatibles.  El ciclo de lanzamiento del IDE (no todos :)) es m√°s corto que el de los compiladores, por lo tanto, existe el potencial de obtener m√°s r√°pidamente nuevas funciones y responder a los problemas encontrados.  En el mundo de los compiladores, todo es un poco diferente: el ciclo de lanzamiento es de al menos un a√±o, los problemas de compatibilidad entre compiladores se resuelven mediante compilaci√≥n condicional y se pasan a los hombros del desarrollador.  El compilador no tiene que ser universal y omn√≠voro: su complejidad ya es alta.  Clang no es una excepci√≥n. </p><br><h2 id="borba-za-skorost">  La lucha por la velocidad </h2><br><p>  Esa parte del tiempo que pas√≥ en el IDE, cuando el programador no est√° sentado en el depurador, edita el texto.  Y su deseo natural aqu√≠ es hacerlo c√≥modo (de lo contrario, ¬øpor qu√© un IDE? ¬°Puedo pasarlo con un bloc de notas!) La comodidad, en particular, implica la alta velocidad de reacci√≥n del editor a los cambios de texto y presionar teclas de acceso r√°pido.  Como Anastasia se√±al√≥ correctamente en su informe, si cinco segundos despu√©s de presionar Ctrl + Espacio el entorno no respond√≠a con la aparici√≥n de un men√∫ o una lista del autocompletado, esto es terrible (en serio, pru√©belo usted mismo).  En n√∫meros, esto significa que el analizador incorporado en el IDE tiene aproximadamente un segundo para evaluar los cambios en el archivo y reconstruir el AST, y otro uno y medio o dos para ofrecer al desarrollador una opci√≥n sensible al contexto.  Segundo.  Bueno, tal vez dos.  Adem√°s, el comportamiento esperado es que si el desarrollador cambi√≥ el apodo .h y luego cambi√≥ a .cpp-shnik, los cambios realizados ser√°n "visibles".  Los archivos, aqu√≠ est√°n, se abrieron en las ventanas vecinas.  Y ahora un simple c√°lculo.  Si clang, lanzado desde la l√≠nea de comando, puede hacer frente al c√≥digo fuente en unos diez o veinte segundos, entonces ¬ød√≥nde est√° la raz√≥n para creer que cuando se inicia desde el IDE har√° frente al c√≥digo fuente mucho m√°s r√°pido y encajar√° en ese segundo o dos?  Es decir, ¬øfuncionar√° un orden de magnitud m√°s r√°pido?  En general, esto podr√≠a estar terminado, pero no lo har√©. </p><br><p>  Unos diez o veinte segundos para la fuente, por supuesto, exagero.  Aunque, si se incluye alguna API pesada o, por ejemplo, boost.spirit con Hana lista, y luego todo esto se usa activamente en el texto, 10-20 segundos siguen siendo buenos valores.  Pero incluso si el AST est√° listo segundos despu√©s de tres o cuatro despu√©s del lanzamiento del analizador incorporado, ya es mucho tiempo.  Siempre que dichos lanzamientos sean tan regulares (para mantener el modelo de c√≥digo y el √≠ndice en un estado coherente, resaltado, r√°pido, etc.), as√≠ como a pedido: la finalizaci√≥n del c√≥digo tambi√©n es el lanzamiento del compilador.  ¬øEs posible de alguna manera reducir este tiempo?  Desafortunadamente, en el caso de usar clang como analizador sint√°ctico, no hay muchas posibilidades.  Motivo: esta es una herramienta de terceros en la que ( <em>idealmente</em> ) no se pueden realizar cambios.  Es decir, profundizar en el c√≥digo clang con perftool, optimizar y simplificar algunas ramas: estas caracter√≠sticas no est√°n disponibles y tiene que ver con lo que proporciona la API externa (en el caso de usar libclang, tambi√©n es bastante limitado). </p><br><p>  La primera, obvia y, de hecho, la √∫nica soluci√≥n es usar encabezados precompilados generados din√°micamente.  Con una implementaci√≥n adecuada, la soluci√≥n es asesina.  Aumenta la velocidad de compilaci√≥n al menos algunas veces.  Su esencia es simple: el entorno recopila todos los encabezados de terceros (o encabezados fuera de la ra√≠z del proyecto) en un solo archivo .h, crea pch a partir de este archivo y luego incluye impl√≠citamente este pch en cada fuente.  Por supuesto, aparece un efecto secundario obvio: en el c√≥digo fuente ( <em>en la etapa de edici√≥n</em> ), se pueden ver s√≠mbolos que no est√°n incluidos en √©l.  Pero esto es un cargo por la velocidad.  Tengo que elegir  Y todo estar√≠a bien, si no fuera por un peque√±o problema: clang sigue siendo un compilador.  Y, al ser un compilador, no le gustan los errores en el c√≥digo.  Y si de repente (¬°de repente! - vea la secci√≥n anterior) hay errores en los encabezados, entonces el archivo .pch no se crea.  Al menos fue hasta la versi√≥n 3.7.  ¬øHa cambiado algo a este respecto desde entonces?  No s√©, hay una sospecha de que no.  Por desgracia, ya no hay ninguna oportunidad de verificar. </p><br><p>  Las opciones alternativas, por desgracia, no est√°n disponibles por la misma raz√≥n: clang es un compilador y una cosa "en s√≠ misma".  Intervenir activamente en el proceso de generaci√≥n de AST, de alguna manera hacer que combine AST de diferentes piezas, mantener bases de s√≠mbolos externas y te te y te - por desgracia, todas estas caracter√≠sticas no est√°n disponibles.  Solo API externa, solo hardcore y configuraciones disponibles a trav√©s de opciones de compilaci√≥n.  Y luego el an√°lisis de la AST resultante.  Si se sienta en la versi√≥n C ++ de la API, entonces hay un poco m√°s de oportunidades disponibles.  Por ejemplo, puede jugar con FrontendActions personalizadas, hacer ajustes m√°s finos para las opciones de compilaci√≥n, etc. Pero en este caso, el punto principal no cambiar√°: el texto editado (o indexado) se compilar√° independientemente de los dem√°s y completamente.  Eso es todo.  El punto </p><br><p>  Tal vez (¬°tal vez!) Alg√∫n d√≠a habr√° una bifurcaci√≥n del sonido met√°lico aguas arriba especialmente dise√±ado para su uso como parte del IDE.  Posiblemente  Pero por ahora, todo est√° como est√°.  Digamos que la integraci√≥n del equipo de Qt Creator (a la etapa "final") con libclang tom√≥ siete a√±os.  Prob√© QtC 4.7 con un motor basado en libclang; lo admito, personalmente me gusta la versi√≥n anterior (en la autoescrita) m√°s simplemente porque funciona mejor en mis casos: muestra y resalta, y todo lo dem√°s.  No me comprometer√© a estimar cu√°ntas horas humanas pasaron en esta integraci√≥n, pero me aventuro a sugerir que durante este tiempo ser√≠a posible terminar mi propio analizador.  Por lo que puedo decir (por indicaciones indirectas), el equipo que trabaja en CLion mira con cautela hacia la integraci√≥n con libclang / clang ++.  Pero estos son supuestos puramente personales.  La integraci√≥n en el nivel del Protocolo de servidor de idiomas es una opci√≥n interesante, pero espec√≠ficamente para el caso de C ++, tiendo a considerar esto m√°s como un paliativo por las razones mencionadas anteriormente.  Simplemente transfiere problemas de un nivel de abstracci√≥n a otro.  Pero tal vez me confunden con el LSP: el futuro.  A ver  Pero de todos modos, la vida de los desarrolladores de IDEs modernos para C ++ est√° llena de aventuras, con el sonido met√°lico como backend o sin √©l. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419009/">https://habr.com/ru/post/es419009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418999/index.html">[Anuncio, Peter] Reuni√≥n de JUG.ru con Andrei Belyaev y Alexei Stukalov - Troll oprime a CUBA: Preguntas frecuentes</a></li>
<li><a href="../es419001/index.html">5 "super habilidades" necesarias para el trabajo del futuro</a></li>
<li><a href="../es419003/index.html">Resumen de noticias de blockchain</a></li>
<li><a href="../es419005/index.html">Excursi√≥n a la subestaci√≥n 220/110/20</a></li>
<li><a href="../es419007/index.html">Texturas para la introducci√≥n de 64k: c√≥mo se hace hoy</a></li>
<li><a href="../es419011/index.html">Jinja2 en el mundo C ++, segunda parte. Renderizado</a></li>
<li><a href="../es419013/index.html">Atribuci√≥n basada en embudos para empresas B2B SaaS, ya que consideramos el valor de todos los esfuerzos de marketing</a></li>
<li><a href="../es419017/index.html">Novedades de RestraintLayout 1.1</a></li>
<li><a href="../es419019/index.html">AlterEgo: un dispositivo que puede leer (algunos) pensamientos</a></li>
<li><a href="../es419021/index.html">Los principales tipos de impresi√≥n y sus caracter√≠sticas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>