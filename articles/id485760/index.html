<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’„ â›²ï¸ âœˆï¸ Ekstensi di Kotlin. Atavisme berbahaya atau alat yang berguna? ğŸ¤º ğŸ§—ğŸ» ğŸ‘ŠğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin masih merupakan bahasa yang masih muda, tetapi telah memasuki kehidupan kita. Karena itu, tidak selalu jelas bagaimana menerapkan dengan benar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ekstensi di Kotlin. Atavisme berbahaya atau alat yang berguna?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/485760/"><img src="https://habrastorage.org/webt/kz/wk/5d/kzwk5d50usqqdehsvqpkpzmkogg.jpeg"><br><br>  Kotlin masih merupakan bahasa yang masih muda, tetapi telah memasuki kehidupan kita.  Karena itu, tidak selalu jelas bagaimana menerapkan dengan benar ini atau itu fungsional dan praktik terbaik mana yang diterapkan. <br><br>  Yang paling sulit adalah kasus dengan fitur-fitur bahasa yang tidak ada di Jawa.  Salah satu batu sandungan ini adalah <a href="https://kotlinlang.org/docs/reference/extensions.html">ekspansi</a> . <br><br>  Ini adalah alat yang nyaman yang membuat kode lebih mudah dibaca, hampir tidak memerlukan imbalan apa pun.  Tetapi pada saat yang sama, saya tahu setidaknya satu orang yang, jika dia tidak menganggap ekspansi sebagai kejahatan, pasti skeptis terhadap mereka.  Di bawah ini saya ingin membahas fitur-fitur mekanisme ini, yang dapat menyebabkan kontroversi dan kesalahpahaman. <br><a name="habracut"></a><br><h3>  Ekstensi ke DTO - pelanggaran templat Obyek Transfer Data </h3><br>  Misalnya, ada Pengguna kelas <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String)</code> </pre> <br>  Cukup DTO!  Lebih lanjut, dalam kode di beberapa tempat, diperlukan pemeriksaan untuk menentukan apakah pengguna tersebut orang dewasa.  Pilihan termudah adalah membuat kondisi di semua tempat <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) { ... }</code> </pre><br>  Tetapi, karena ada banyak tempat yang sewenang-wenang seperti itu, masuk akal untuk memasukkan cek ini ke dalam metode. <br>  Ada tiga opsi di sini: <br><br><ol><li>  Function fun isAdult (pengguna: Pengguna) - kelas utilitas biasanya terdiri dari fungsi-fungsi tersebut. <br></li><li>  Masukkan fungsi isAdult ke dalam kelas Pengguna <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> }</code> </pre><br></li><li>  Tulis pembungkus untuk Pengguna yang akan berisi fungsi serupa. <br></li></ol><br>  Ketiga opsi secara teknis berhak untuk hidup.  Tetapi yang pertama menambah ketidaknyamanan dalam bentuk kebutuhan untuk mengetahui semua fungsi utilitas, meskipun ini, tentu saja, bukan masalah besar. <br>  Opsi kedua tampaknya melanggar pola Objek Transfer Data, karena kelas tidak hanya getter dan setter.  Namun, merusak pola itu buruk. <br><br>  Opsi ketiga tidak melanggar prinsip-prinsip OOP atau templat, tetapi setiap kali Anda harus membuat pembungkus jika Anda ingin menggunakan fungsi yang sama.  Opsi ini juga tidak terlalu suka.  Pada akhirnya, ternyata Anda masih harus berkorban. <br><br>  Menurut pendapat saya, lebih mudah untuk mengorbankan template DTO.  Pertama, saya tidak menemukan penjelasan tunggal tentang mengapa fungsi (kecuali getter dan setter) tidak dapat dibuat di DTO.  Dan kedua, hanya dari segi makna, kode seperti itu nyaman untuk dimiliki di sebelah data yang kami operasikan. <br><br>  Tetapi tidak selalu memungkinkan untuk memasukkan kode seperti itu di dalam DTO shek, karena pengembang tidak selalu memiliki kemampuan untuk mengedit kelas yang digunakannya.  Sebagai contoh, ini mungkin kelas yang dihasilkan dari xsd.  Selain itu, bagi seseorang mungkin tidak biasa dan tidak nyaman untuk menulis kode seperti itu di kelas Data.  Kotlin menawarkan solusi untuk situasi seperti itu dalam bentuk fungsi dan bidang ekstensi: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Kode ini dapat digunakan seolah-olah dinyatakan di dalam kelas Pengguna: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user.isAdult()) {...}</code> </pre><br>  Hasilnya adalah solusi yang cukup akurat yang, dengan sedikit kompromi, memuaskan kebutuhan kita.  Jika kita berbicara tentang fakta bahwa template DTO dilanggar, maka kita ingin mengingat bahwa di Jawa itu akan menjadi metode statis biasa dari form: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull User receiver)</span></span></span></span></code> </pre><br>  Seperti yang Anda lihat, secara formal, bahkan templat tidak dilanggar.  Menggunakan fungsi ini tampak seolah-olah dideklarasikan di User dan Idea akan menawarkannya secara otomatis.  Sangat nyaman. <br><br><h3>  Ekstensi spesifik.  Anda tidak bisa tahu tentang keberadaan mereka dan membingungkan metode dan bidang entitas dengan ekstensi </h3><br>  Idenya adalah bahwa pengembang datang ke proyek, dan sekitar kode yang diterapkan dalam ekstensi, tidak jelas metode mana yang asli dan mana yang merupakan metode ekstensi. <br><br>  Ini bukan masalah, karena Ide membantu pengembang dalam masalah ini dan menyoroti fungsi-fungsi tersebut.  Meskipun secara adil harus dikatakan bahwa perbedaannya lebih terlihat dalam tema Darcula.  Jika Anda mengubahnya menjadi Cahaya, semuanya menjadi kurang jelas dan ekstensi hanya berbeda dalam font miring. <br><br>  Di bawah ini kita melihat contoh memanggil dua metode: isAdult adalah metode ekstensi, isMale adalah metode biasa di dalam kelas Pengguna.  Tangkapan layar di sebelah kiri adalah tema Darcula, di sebelah kanan adalah tema Cahaya yang biasa. <br><br><img src="https://habrastorage.org/webt/qr/yx/j2/qryxj2ld3i7pyphvqsqd05njozi.png"><img src="https://habrastorage.org/webt/ik/ro/ed/ikroeddsainpwwaevfjjounzeva.png"><br><br>  Agak lebih buruk dengan ladang.  Jika, misalnya, kami memutuskan untuk mengimplementasikan isAdult sebagai bidang ekstensi, maka kami hanya dapat membedakannya dari bidang biasa dengan jenis font.  Dalam contoh ini, nama adalah bidang biasa.  Bidang ekstensi hanya menghasilkan font miring. <br><br><img src="https://habrastorage.org/webt/bt/w1/ej/btw1ejdtlclzohkqlucw8pfpihq.png"><img src="https://habrastorage.org/webt/bz/ok/ux/bzokuxqd_-bykhju0gylzq-g2wq.png"><br><br>  Lingkungan pengembangan Ide membantu Anda menentukan metode mana yang merupakan ekstensi dan mana yang asli saat pelengkapan otomatis.  Ini nyaman. <br><br><img src="https://habrastorage.org/webt/7v/be/oe/7vbeoe1s9093-wjgwv5piavux1w.png"><br><br>  Situasinya mirip dengan bidang. <br><br><img src="https://habrastorage.org/webt/za/0q/jk/za0qjkyxmk94k8khz0atanwusgo.png"><br><br>  "Untuk Pengguna di &lt;root&gt;" berarti ekstensi. <br><br>  Plus, fakta bahwa Ide â€œmengikatâ€ ekstensi ke entitas yang dapat diperluas sangat membantu dalam pengembangan, karena metode dan bidang ekstensi diusulkan untuk pelengkapan otomatis. <br><br><h3>  Ekstensi tersebar di seluruh proyek, membentuk tong sampah </h3><br>  Kami tidak memiliki masalah seperti itu pada proyek, karena kami tidak secara sewenang-wenang menempatkan ekstensi dan mengeluarkan kode dengan ekstensi publik di file atau paket terpisah. <br><br>  Misalnya, fungsi isAdult dari contoh di atas dapat muncul di file Pengguna paket ekstensi.  Jika paket tidak cukup dan Anda hanya ingin tidak bingung di mana kelasnya dan di mana file fungsinya, Anda dapat menamainya, misalnya, _User.kt.  Begitu pula para pengembang di JetBrains untuk koleksi.  Atau, jika hati nurani melarang memulai file dengan garis bawah, Anda dapat menghubungi user.kt.  Faktanya, tidak ada perbedaan cara penggunaan, yang utama adalah bahwa ada keseragaman yang dipatuhi oleh seluruh tim. <br><br>  Pembuat bahasa, ketika mengembangkan metode ekstensi untuk koleksi, menempatkannya dalam file <a href="">_Collections.kt</a> . <br><br>  Ini umumnya masalah mengatur kode, bukan masalah ekstensi.  Fungsi statis di Java, dan tidak hanya yang statis, dapat tersebar tidak kurang dari ekstensi secara acak. <br><br><h3>  Jangan mengabaikan fungsi ekstensi selama pengujian unit </h3><br>  Menurut pendapat saya, tidak perlu membasahi fungsi ekstensi, sama seperti tidak perlu membasahi metode statis.  Dalam fungsi ekspansi, Anda harus meletakkan logika bekerja dengan data yang ada.  Sebagai contoh, dalam kasus fungsi isAdult untuk kelas Pengguna, semua yang Anda butuhkan ada di isAdult.  Anda tidak perlu basah. <br><br>  Pertimbangkan contoh yang sedikit lebih rumit.  Ada komponen tertentu yang berfungsi untuk mendapatkan pengguna dari sistem eksternal - UserComponent.  Metode untuk mendapatkan pengguna disebut getUsers.  Misalkan ada kebutuhan untuk mendapatkan semua pengguna aktif dan memutuskan untuk menambahkan logika penyaringan dalam bentuk fungsi - ekstensi.  Akibatnya, kami mendapat fungsi: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> UserComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActiveUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Users&gt; = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().filter{it.status == â€œActiveâ€}</code> </pre><br>  Sepertinya ini dia - situasi ketika Anda membutuhkan tiruan untuk ekspansi.  Tetapi jika Anda ingat bahwa getActiveUsers hanyalah metode statis, ternyata tiruan itu tidak diperlukan.  Dip haruslah metode dan fungsi yang disebut dalam ekstensi, dan tidak lebih. <br><br><h3>  Ada kemungkinan bahwa fungsi ekstensi tumpang tindih dengan fungsi dari nama yang sama yang terletak di dalam kelas extended </h3><br>  Kami akan mempertimbangkan kasus ini menggunakan contoh dari paragraf pertama.  Misalkan ada ekstensi fungsi adalah Dewasa, yang memeriksa apakah pengguna dewasa: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> User.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br>  Setelah itu, kami mengimplementasikan fungsi dengan nama yang sama di dalam Pengguna: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sex: String){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = age &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> }</code> </pre><br>  Ketika user.isAdult () dipanggil, fungsi dari kelas akan dipanggil, meskipun ada ekstensi dengan nama yang sama dan fungsi yang sesuai.  Kasus seperti itu dapat membingungkan, karena pengguna yang tidak mengetahui fungsi yang dideklarasikan di dalam kelas akan menunggu untuk fungsi ekstensi selesai.  Ini adalah situasi yang tidak menyenangkan yang dapat memiliki konsekuensi yang sangat serius.  Dalam hal ini, kami tidak berbicara tentang kemungkinan ketidaknyamanan ulasan atau pelanggaran templat, tetapi tentang perilaku kode yang berpotensi salah. <br><br>  Situasi yang dijelaskan di atas menunjukkan bahwa ketika menggunakan fungsi ekstensi, masalah nyata dapat muncul. <br><br>  Untuk menghindarinya, Anda jangan lupa untuk menutupi fungsi ekspansi dengan unit test sebanyak mungkin.  Dalam kasus terburuk, jika tes gagal, akan ada dua fungsi yang bekerja dengan cara yang sama.  Satu adalah perpanjangan, dan yang lainnya adalah di dalam kelas itu sendiri.  Jika tes gagal, itu akan menarik perhatian pada fakta bahwa satu fungsi tumpang tindih lainnya. <br><br><h3>  Ekstensi terikat ke kelas, bukan objek, dan ini dapat menyebabkan kebingungan </h3><br>  Misalnya, pertimbangkan kelas Pengguna dari paragraf pertama.  Mari kita buka dan ciptakan Siswa penggantinya: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span></span>(name: String, age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sex: String): User(name, age, sex)</code> </pre><br>  Kami mendefinisikan fungsi ekstensi untuk Siswa, yang juga akan menentukan apakah siswa tersebut orang dewasa atau tidak.  Hanya untuk siswa kami mengubah kondisi: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Student.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age &gt;= <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  Dan sekarang kita menulis kode berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user: User = Student(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-string"><span class="hljs-string">"M"</span></span>)</code> </pre><br>  Apa yang akan mengembalikan user.isAdult ())? <br>  Tampaknya objek bertipe Student dan fungsinya harus mengembalikan true.  Tapi itu tidak sesederhana itu.  Ekstensi dilampirkan ke kelas, bukan ke objek, dan hasilnya akan salah. <br><br>  Tidak ada yang aneh dalam hal ini, jika kita ingat bahwa ekstensi adalah metode statis, dan entitas yang dapat dikembangkan adalah parameter pertama dalam metode ini.  Ini adalah hal lain yang perlu diingat ketika menggunakan mekanisme ini.  Jika tidak, Anda bisa mendapatkan efek yang tidak menyenangkan dan tidak terduga. <br><br><h3>  Alih-alih output </h3><br>  Poin-poin kontroversial ini tampaknya tidak berbahaya, jika Anda ingat bahwa kami mengatakan ekstensi - yang kami maksud adalah metode statis.  Plus, mencakup fungsi tersebut dengan unit test akan membantu meminimalkan kemungkinan kebingungan yang terkait dengan sifat statis ekstensi. <br><br>  Menurut pendapat saya, ekstensi adalah alat yang ampuh dan nyaman yang dapat meningkatkan kualitas dan keterbacaan kode, hampir tidak memerlukan imbalan apa pun.  Itu sebabnya saya mencintai mereka: <br><br><ul><li>  Ekstensi memungkinkan Anda untuk menulis logika khusus untuk konteks kelas yang dapat diperluas.  Berkat ini, bidang dan metode ekstensi dibaca seolah-olah mereka selalu hadir dalam entitas yang diperluas, yang, pada gilirannya, meningkatkan pemahaman tingkat atas kode.  Di Jawa, sayangnya, ini tidak bisa dilakukan.  Selain itu, ekstensi memiliki pengubah akses yang sama dengan fungsi biasa.  Ini memungkinkan Anda untuk menulis kode serupa dengan ruang lingkup yang benar-benar diperlukan untuk fungsi tertentu. <br></li><li>  Lebih mudah menggunakan fungsi ekstensi untuk pemetaan, yang harus Anda lihat cukup banyak saat menyelesaikan tugas sehari-hari.  Sebagai contoh, dalam proyek ada kelas UserFromExternalSystem, yang digunakan saat memanggil sistem eksternal, dan akan lebih bagus untuk menempatkan pemetaan dalam fungsi ekstensi, lupakan dan gunakan seolah-olah itu aslinya di Pengguna. <br><br><pre> <code class="kotlin hljs">callExternalSystem(user.getUserFromExternalSystem())</code> </pre><br>  Tentu saja, hal yang sama dapat dilakukan dengan metode biasa, tetapi opsi ini kurang dapat dibaca: <br><br><pre> <code class="kotlin hljs">callExternalSystem(getUserFromExternalSystem(user))</code> </pre><br>  atau opsi semacam itu: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> externalUser = getUserFromExternalSystem(user) callExternalSystem(externalUser)</code> </pre><br>  Sebenarnya, tidak ada keajaiban yang terjadi, tetapi berkat hal sepele seperti itu, lebih menyenangkan bekerja dengan kode. <br></li><li>  Dukungan gagasan dan pelengkapan otomatis.  Tidak seperti metode dari kelas utilitas, ekstensi didukung dengan baik oleh lingkungan pengembangan.  Dengan pelengkapan otomatis, ekstensi ditawarkan oleh lingkungan sebagai fungsi dan bidang "asli".  Ini memungkinkan peningkatan produktivitas pengembang yang baik. <br></li><li>  Yang mendukung ekstensi adalah kenyataan bahwa sebagian besar perpustakaan Kotlin ditulis sebagai ekstensi.  Banyak metode yang mudah dan favorit untuk bekerja dengan koleksi adalah ekstensi (Filter, Peta, dan sebagainya).  Anda dapat memverifikasi ini dengan memeriksa file <a href="">_Collections.kt</a> . <br></li></ul><br>  Keuntungan ekstensi mencakup kemungkinan kerugian.  Tentu saja, ada risiko besar penyalahgunaan mekanisme ini dan godaan untuk menjejalkan semua kode ke ekstensi.  Namun di sini pertanyaannya lebih lanjut tentang pengorganisasian kode dan penggunaan alat yang kompeten.  Ketika digunakan dengan benar, ekstensi akan menjadi teman sejati dan penolong dalam penulisan kode yang dibaca dan dikelola dengan baik. <br><br>  Di bawah ini adalah tautan ke bahan-bahan yang digunakan untuk mempersiapkan artikel ini: <br><br><ol><li>  <a href="https://proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff">proandroiddev.com/kotlin-extension-functions-more-than-sugar-1f04ca7189ff</a> - dari sini diambil pemikiran menarik tentang fakta bahwa, menggunakan ekstensi, kami bekerja lebih dekat dengan konteksnya. <br></li><li>  <a href="https://www.nikialeksey.com/2017/11/14/kotlin-is-bad.html">www.nikialeksey.com/2017/11/14/kotlin-is-bad.html</a> - di sini penulis menentang ekstensi dan memberikan contoh yang menarik, yang dibahas dalam salah satu poin di atas. <br></li><li>  <a href="https://medium.com/%40elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a">medium.com/@elizarov/i-do-not-see-much-reason-to-mock-extension-func-7-7f24d88a188a</a> - <a href="https://medium.com/%40elizarov/i-do-not-see-much-reason-to-mock-extension-functions-7f24d88a188a">Pendapat</a> Roman Elizarov tentang pembasahan metode ekstensi. <br></li></ol><br>  Saya juga ingin mengucapkan terima kasih kepada kolega yang membantu dengan kasus dan pemikiran menarik tentang materi ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485760/">https://habr.com/ru/post/id485760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485744/index.html">Inteligensi - kemampuan suatu objek untuk menyesuaikan perilakunya dengan lingkungan untuk melestarikan (bertahan hidup)</a></li>
<li><a href="../id485746/index.html">Platform ke-4 berangkat dari server yang digunakan</a></li>
<li><a href="../id485748/index.html">Rantai opsional, penyatuan dengan nol, dan bagaimana mereka mengubah pendekatan kami dalam menulis kode</a></li>
<li><a href="../id485750/index.html">API yang akhirnya layak ditingkatkan dari Java 8. Bagian 1</a></li>
<li><a href="../id485758/index.html">Raksasa modular dengan kontrol online, serta tekstil dan keyboard rajutan Joe Paradiso</a></li>
<li><a href="../id485764/index.html">Bereaksi Token Auth</a></li>
<li><a href="../id485766/index.html">Aturan makan</a></li>
<li><a href="../id485768/index.html">Tren Web 2020 Layak Dicoba</a></li>
<li><a href="../id485770/index.html">Polemik salah</a></li>
<li><a href="../id485772/index.html">Dari desktop ke pusat data virtual - bagaimana kami menuju virtualisasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>