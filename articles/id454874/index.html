<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ³ ğŸŸ â›¹ğŸ¾ Sedikit tentang multitasking dalam mikrokontroler ğŸ˜¸ ğŸ“³ ğŸ‘©ğŸ¾â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sedikit tentang multitasking 


 Setiap orang yang hari demi hari, atau dari kasus ke kasus, terlibat dalam pemrograman mikrokontroler, cepat atau lam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang multitasking dalam mikrokontroler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454874/"><p>  <strong>Sedikit tentang multitasking</strong> </p><br><p>  Setiap orang yang hari demi hari, atau dari kasus ke kasus, terlibat dalam pemrograman mikrokontroler, cepat atau lambat akan dihadapkan dengan pertanyaan: apakah saya harus menggunakan sistem operasi multi-tasking?  Ada cukup banyak dari mereka di jaringan, dan banyak dari mereka gratis (atau hampir gratis).  Pilih saja. </p><br><p>  Keraguan serupa muncul ketika Anda menemukan sebuah proyek di mana mikrokontroler harus secara bersamaan melakukan beberapa tindakan berbeda.  Beberapa dari mereka tidak terhubung dengan yang lain, sementara sisanya, sebaliknya, tidak bisa tanpa satu sama lain.  Selain itu, mungkin terlalu banyak dari keduanya.  Apa yang â€œterlalu banyakâ€ tergantung pada siapa yang akan mengevaluasi atau siapa yang akan melaksanakan pengembangan.  Nah, apakah itu orang yang sama. </p><br><p>  Sebaliknya, ini bukan masalah kuantitas, tetapi pertanyaan tentang perbedaan kualitatif dalam tugas dalam kaitannya dengan kecepatan eksekusi, atau persyaratan lainnya.  Pikiran seperti itu mungkin muncul, misalnya, ketika proyek perlu secara teratur memonitor tegangan suplai (apakah itu hilang?), Cukup sering membaca dan menyimpan nilai-nilai dari jumlah input (mereka tidak memberikan istirahat), sesekali memantau suhu dan mengontrol kipas (tidak ada yang bernapas), periksa menonton dengan seseorang yang Anda percaya (baik bagi Anda untuk memerintahkannya), tetap berhubungan dengan operator (cobalah untuk tidak membuatnya kesal), periksa checksum dari memori permanen program untuk demensia (ketika dihidupkan, atau seminggu sekali, atau di pagi hari). <a name="habracut"></a></p><br><p>  Tugas heterogen seperti itu dapat diprogram dengan sangat bermakna dan berhasil, bergantung pada tugas latar belakang tunggal dan pengatur waktu.  Dalam penangan interupsi ini, setiap kali salah satu dari "potongan" tugas berikutnya dieksekusi.  Tergantung pada pentingnya, urgensi, atau pertimbangan serupa, tantangan ini sering diulang untuk beberapa tugas, tetapi jarang untuk yang lain.  Namun, kita harus memastikan bahwa setiap tugas melakukan bagian waktu yang singkat dari pekerjaan, kemudian bersiap untuk bagian kecil berikutnya dari pekerjaan, dan seterusnya.  Pendekatan ini, jika Anda terbiasa, sepertinya tidak terlalu rumit.  Ketidaknyamanan terjadi ketika Anda ingin membangun proyek.  Atau, misalnya, tiba-tiba dipindahkan ke yang lain.  Perlu dicatat bahwa yang kedua sering lebih sulit dan tanpa banyak tugas semu. </p><br><p>  Tetapi bagaimana jika Anda menggunakan sistem operasi yang sudah jadi untuk mikrokontroler?  Tentu, banyak yang melakukannya.  Ini pilihan yang bagus.  Tetapi penulis kalimat-kalimat ini, sampai sekarang, telah dan terus dihentikan oleh gagasan bahwa perlu memahami ini, setelah menghabiskan banyak waktu, memilih dari apa yang berhasil kami peroleh dan hanya menggunakan apa yang benar-benar diperlukan dari ini.  Dan lakukan semua ini, ingatlah, menyelidiki kode orang lain!  Dan tidak ada kepastian bahwa dalam enam bulan ini tidak perlu diulang, karena itu akan dilupakan. </p><br><p>  Dengan kata lain, mengapa Anda perlu garasi penuh peralatan dan perlengkapan jika sepeda disimpan dan digunakan di sana? </p><br><p>  Oleh karena itu, ada keinginan untuk membuat tugas "switch" sederhana hanya untuk Cortex-M4 (well, mungkin bahkan untuk M3 dan M7).  Tapi yang lama, keinginan yang baik untuk tidak terlalu banyak tidak hilang. </p><br><p>  Jadi, kami melakukan yang paling sederhana.  Sejumlah kecil tugas berbagi waktu eksekusi secara merata.  Seperti pada Gambar 1 di bawah ini, empat tugas melakukan ini.  Biarkan yang utama menjadi nol, karena sulit membayangkan yang lain. </p><br><p><img src="https://habrastorage.org/webt/hz/er/47/hzer47qstbq61q9nj41xkqnquoo.jpeg"></p><br><p>  Dengan bekerja dengan cara ini, mereka dijamin mendapatkan slot atau rentang waktu mereka (tick) dan tidak perlu tahu tentang keberadaan tugas lain.  Setiap tugas tepat setelah 3 kutu lagi akan mendapatkan kesempatan untuk melakukan sesuatu. </p><br><p>  Tetapi, di sisi lain, jika ada tugas yang diperlukan untuk menunggu acara eksternal, misalnya, menekan tombol, maka itu akan dengan bodohnya menghabiskan waktu berharga dari mikrokontroler kita.  Kami tidak bisa setuju dengan ini.  Dan katak kita (hati nurani) - juga.  Sesuatu harus dilakukan. </p><br><p>  Dan biarkan tugas itu, jika tidak ada hubungannya sejauh ini, berikan waktu yang tersisa dari kutu ke rekan-rekannya, yang, kemungkinan besar, membajak dengan sekuat tenaga. </p><br><p>  Dengan kata lain, berbagi itu perlu.  Biarkan tugas 2 melakukan hal itu, seperti pada Gambar 2. </p><br><p><img src="https://habrastorage.org/webt/5j/dm/sv/5jdmsvttcr9cfs5ygk_giclmc5w.jpeg"></p><br><p>  Dan mengapa tugas latar belakang utama kita tidak diizinkan untuk memberikan sisa waktu, jika Anda masih harus menunggu?  Mari kita ijinkan.  Seperti yang ditunjukkan pada Gambar 3. </p><br><p><img src="https://habrastorage.org/webt/jg/mh/q4/jgmhq4bmtd26vzif444qypg3c18.jpeg"></p><br><p>  Dan jika Anda tahu bahwa beberapa tugas tidak akan segera mengharuskan Anda untuk memeriksa sesuatu lagi atau hanya bekerja?  Dan dia bisa membiarkan dirinya sedikit tidur, dan sebagai gantinya akan membuang waktu dan mendapatkan di bawah kakinya.  Bukan pesanan, itu harus diperbaiki.  Biarkan tugas 3 melewatkan satu bagian waktunya (atau seribu).  Seperti yang ditunjukkan pada gambar 4. </p><br><p><img src="https://habrastorage.org/webt/50/no/ma/50nomamrfalo_crb2hmf1nkalli.jpeg"></p><br><p>  Seperti yang kita lihat, kita telah menggariskan koeksistensi yang adil dari tugas atau sesuatu seperti itu.  Kita sekarang harus membuat tugas individu kita berperilaku seperti yang ditentukan.  Dan jika kita mencoba menilai waktu, maka ada baiknya mengingat bahasa tingkat rendah (saya tidak takut pada kata assembler) dan tidak sepenuhnya mempercayai kompiler dari bahasa apa pun, level tinggi atau sangat tinggi.  Memang, jauh di lubuk hati kita, kita dengan tegas menentang semua ketergantungan.  Selain itu, fakta bahwa kita tidak memerlukan assembler apa pun, tetapi hanya dari Cortex-M4, menyederhanakan hidup kita. </p><br><p>  Untuk stack, kami memilih satu area umum RAM yang akan terisi, yaitu, dengan tujuan mengurangi alamat memori.  Mengapa  Hanya karena itu tidak bekerja secara berbeda.  Kami akan secara mental membagi area penting ini menjadi bagian yang sama sesuai dengan jumlah tugas maksimum yang dinyatakan.  Gambar 5 menunjukkan ini untuk empat tugas. </p><br><p><img src="https://habrastorage.org/webt/tp/tz/wo/tptzwopr7htrcuhwgb6y6ydfdae.jpeg"></p><br><p>  Selanjutnya, kami memilih tempat di mana kami akan menyimpan salinan penunjuk tumpukan untuk setiap tugas.  Sekarang, dengan menyela dari timer, yang kita ambil sebagai system timer, kita menyimpan semua register tugas saat ini di area stack-nya (register SP sekarang menunjuk ke sana), kemudian kita menyimpan stack pointer-nya di tempat khusus (kita menyimpan nilainya), kita mendapatkan stack pointer dari tugas selanjutnya ( tulis nilai baru ke register SP) dari tempat khusus kami dan pulihkan semua registernya.  Salinan mereka sekarang ditunjukkan oleh register SP dari tugas kita selanjutnya.  Yah, kita keluar dari gangguan, tentu saja.  Selain itu, seluruh konteks tugas selanjutnya dalam daftar muncul di register. </p><br><p>  Mungkin, akan berlebihan untuk mengatakan bahwa task3 setelah berikutnya dalam antrian akan menjadi utama.  Dan tentu saja, tidak berlebihan untuk mengingat bahwa Cortex-M4 sudah memiliki timer SysTick dan interupsi khusus darinya, dan banyak produsen mikrokontroler mengetahuinya.  Kami akan menggunakannya dan gangguan ini sebagaimana dimaksud. </p><br><p>  Untuk memulai penghitung waktu sistem ini, serta melakukan semua persiapan dan pemeriksaan yang diperlukan, Anda harus menggunakan prosedur yang dimaksudkan untuk ini. </p><br><pre><code class="plaintext hljs">U8 main_start_task_switcher(void);</code> </pre> <br><p>  Rutin ini mengembalikan 0 jika semua pemeriksaan telah lulus, atau kode kesalahan jika terjadi kesalahan.  Diperiksa, pada dasarnya, apakah tumpukan disejajarkan dengan benar dan apakah ada cukup ruang untuknya, dan juga semua tempat khusus kami diisi dengan nilai awal.  Singkatnya, kebosanan. </p><br><p>  Jika seseorang ingin melihat teks program, maka pada akhir narasi ia akan dapat dengan mudah melakukan ini, misalnya, melalui surat pribadi. </p><br><p>  Ya, saya benar-benar lupa ketika kita mengambil register dari tugas berikutnya dari penyimpanan untuk pertama kali dalam hidupnya, perlu bahwa mereka mendapatkan nilai asli yang bermakna.  Dan karena, dia akan mengambilnya dari bagian tumpukannya, Anda harus meletakkannya terlebih dahulu dan menggerakkan penunjuk tumpukannya sehingga nyaman untuk diambil.  Untuk ini kita perlu prosedur </p><br><pre> <code class="plaintext hljs"> U8 task_run_and_return_task_number(U32 taskAddress);</code> </pre> <br><p>  Untuk subrutin ini, kami melaporkan alamat 32-bit dari awal tugas kami yang ingin kami jalankan.  Dan dia (subrutin) memberi tahu kami jumlah tugas, yang ternyata dalam tabel umum khusus, atau 0 jika tidak ada ruang di dalam tabel.  Lalu kita bisa menjalankan tugas lain, lalu yang lain dan seterusnya, meskipun ketiganya merupakan tambahan dari tugas utama kita yang tidak pernah berakhir.  Dia tidak akan pernah memberikan nomor nolnya kepada siapa pun. </p><br><p>  Beberapa kata tentang prioritas.  Prioritas utama adalah dan tetap tidak membebani pembaca dengan detail yang tidak perlu. </p><br><p>  Tapi serius, kita harus ingat bahwa ada gangguan dari port serial, dari beberapa koneksi SPI, dari konverter analog-ke-digital, dari timer lain, setelah semua.  Dan apa yang akan terjadi jika kita akan beralih ke tugas lain (beralih konteks) ketika kita berada di handler dari beberapa jenis interupsi.  Lagi pula, ini bukan tugas yang sah, tetapi pengaburan sementara dari program.  Dan kita akan menjaga konteks yang aneh ini sebagai semacam tugas.  Akan ada kebingungan: kerah tidak kencang, tutupnya tidak pas.  Hentikan, tidak, ini dari cerita yang berbeda. </p><br><p>  Dalam kasus kami, ini tidak bisa dibiarkan.  Kita tidak boleh mengizinkan kita untuk mengubah konteks selama pemrosesan interupsi yang tidak direncanakan.  Inilah prioritas untuk ini.  Kita hanya harus menunggu sedikit, dan hanya kemudian, ketika keberanian yang belum pernah terjadi ini berakhir, dengan tenang beralih ke tugas lain.  Singkatnya, prioritas interupsi dari pengalihan tugas kami harus lebih lemah daripada prioritas interupsi lainnya yang digunakan.  Omong-omong, ini juga dilakukan dalam prosedur start-up kami, dan di sanalah ia diinstal, yang paling tidak prioritas dari semua kemungkinan. </p><br><p>  Saya tidak ingin berbicara, tetapi saya harus.  Prosesor kami memiliki dua mode operasi: istimewa dan tidak istimewa.  Dan juga dua register untuk stack pointer: <br>  proses SP dan SP utama.  Jadi, kami tidak akan menukar dengan hal-hal sepele, kami hanya akan menggunakan mode istimewa dan hanya pointer tumpukan utama.  Selain itu, semua ini sudah diberikan pada awal controller.  Jadi, kita tidak akan mempersulit hidup kita. </p><br><p>  Masih perlu diingat bahwa setiap tugas, pasti, ingin dapat membuang segalanya ke neraka dan bagaimana untuk bersantai.  Dan ini bisa terjadi kapan saja selama hari kerja, yaitu selama kutu kami.  Cortex-M4 menyediakan untuk kasus seperti itu perintah assembler khusus SVC, yang akan kami adaptasi dengan situasi kami.  Ini mengarah pada gangguan yang akan membawa kita ke tujuan.  Dan kami akan membiarkan tugas tidak hanya meninggalkan tempat kerja setelah makan siang, tetapi tidak akan datang besok.  Kenapa, biarkan saja setelah liburan.  Dan jika perlu, maka biarkan sampai ketika selesai perbaikan atau tidak datang sama sekali.  Untuk melakukan ini, ada prosedur yang bisa disebabkan oleh tugas itu sendiri. </p><br><pre> <code class="plaintext hljs"> void release_me_and_set_sleep_period(U32 ticks);</code> </pre> <br><p>  Rutin ini hanya perlu menunjukkan berapa banyak kutu yang direncanakan untuk beristirahat.  Jika 0, maka Anda hanya dapat mengistirahatkan sisa dari centang saat ini.  Jika 0xFFFFFFFF, maka tugas itu akan "tidur" sampai seseorang bangun.  Semua angka lain menunjukkan jumlah kutu di mana tugas akan berada dalam kondisi tidur. </p><br><p>  Agar orang lain dapat bangun dari samping atau membuatnya tidur, saya harus menambahkan prosedur seperti itu. </p><br><pre> <code class="plaintext hljs"> void task_wake_up_action(U8 taskNumber); void set_task_sleep_period(U8 taskNumber, U32 ticks);</code> </pre> <br><p>  Dan, untuk jaga-jaga, bahkan subrutin seperti itu. </p><br><pre> <code class="plaintext hljs"> void task_remove_action(U8 taskNumber);</code> </pre> <br><p>  Secara kasar, dia mencoret tugas dari daftar karyawan.  Jujur, saya belum tahu mengapa saya menulisnya.  Tiba-tiba berguna? </p><br><p>  Sudah waktunya untuk menunjukkan bagaimana tempat di mana satu tugas digantikan oleh yang lain, yaitu, saklar itu sendiri, terlihat seperti. </p><br><p>  Untuk jaga-jaga, mari kita ingat bahwa beberapa register, ketika memasuki interupsi, disimpan di stack tanpa partisipasi kita, secara otomatis (seperti kebiasaan di Cortex-M4).  Karena itu, kita hanya perlu menyimpan sisanya.  Ini bisa dilihat di bawah.  Jangan khawatir dengan apa yang Anda lihat, ini adalah instruksi assembler Cortex-M4 (M3, M7), sebagaimana diuraikan oleh IAR Embedded Workbench. </p><br><p>  Mereka yang belum menemukan instruksi perakitan, percayalah padaku, mereka benar-benar terlihat seperti itu.  Ini adalah molekul yang membentuk program apa pun di bawah ARM Cortex-M4. </p><br><pre> <code class="plaintext hljs">SysTick_Handler STMDB SP!,{R4-R11} ;   LDR R0,=timersTable ;    LDR R1,=stacksTable ;    LDR R2,[R0] ;R2   ()  STR SP,[R1,R2,LSL #2] ;   SP (R2 * 4) __st_next_check ADD R2,R2,#1 ;   CMP R2,#TASKS_LIMIT ;R2-TASKS_LIMIT  BLO __st_no_border_yet ;   MOV R2,#0 ;    (main) LDR R3,[R1] ; main SP MOV SP,R3 B __st_timer_ok __st_no_border_yet ;; LDR SP,[R1,R2,LSL #2] ;    (errata Cortex M4) ;; CMP SP,#0 ; LDR R3,[R1,R2,LSL #2] ;  SP      CMP R3,#0 ; =0     BEQ __st_next_check MOV SP,R3 LDR R3,[R0,R2,LSL #2] ;  suspend timer CBZ R3,__st_timer_ok ; 0    ,   ; CMP R3,#0xFFFFFFFF ; ,   BEQ __st_next_check SUB R3,R3,#1 ;  1 STR R3,[R0,R2,LSL #2] ;  suspend timer B __st_next_check __st_timer_ok STR R2,[R0] ;     LDMIA SP!,{R4-R11} ;  R4-R11 BX LR</code> </pre> <br><p>  Menangani interupsi yang diperintahkan oleh tugas itu sendiri ketika mengembalikan sisa centang tampak serupa.  Satu-satunya perbedaan adalah Anda masih harus repot-repot tidur sebentar (atau tertidur lelap).  Ada satu kehalusan.  Dua tindakan harus dilakukan, tulis nomor yang diinginkan di sleep timer dan menyebabkan SVC terputus.  Fakta bahwa kedua tindakan ini tidak terjadi secara atom (yaitu, tidak keduanya sekaligus) membuat saya sedikit khawatir.  Bayangkan selama satu milidetik bahwa kita baru saja menyalakan pengatur waktu dan pada saat itu sudah waktunya untuk mengerjakan tugas lain.  Yang lain mulai menghabiskan kutu nya, sementara tugas kita akan tidur kutu berikutnya, seperti yang diharapkan (karena timer-nya tidak nol).  Kemudian, ketika saatnya tiba, tugas kita akan menerima centangnya dan segera memberikannya untuk mengganggu SVC, karena dua tindakan ini masih harus dilakukan.  Tidak ada yang mengerikan, menurut saya, akan terjadi, tetapi endapan akan tetap ada.  Karena itu, kami akan melakukannya.  Penghitung waktu tidur yang akan datang diletakkan di tempat pendahuluan.  Ini diambil dari sana oleh rutinitas interupsi itu sendiri dari SVC.  Atomicity, seolah-olah, tercapai.  Ini ditunjukkan di bawah ini. </p><br><pre> <code class="plaintext hljs">SVC_Handler LDR R0,__sysTickAddr ; SysTick  MOV R1,#6 ;   CSR ,   STR R1,[R0] ;Stop SysTimer MOV R1,#7 ; ,   STR R1,[R0] ;Start SysTimer ; STMDB SP!,{R4-R11} ;   LDR R0,=timersTable ;    LDR R1,=stacksTable ;    LDR R2,[R0] ;R2   ()  STR SP,[R1,R2,LSL #2] ;   SP (R2 * 4) LDR R3,=tmpTimersTable ;   tmpTimers LDR R3,[R3,R2,LSL #2] ;tmpTimer    STR R3,[R0,R2,LSL #2] ; timer  __svc_next_check ADD R2,R2,#1 ;   CMP R2,#TASKS_LIMIT ;R2-TASKS_LIMIT  BLO __svc_no_border_yet ;   MOV R2,#0 ;    (main) LDR R3,[R1] ; main SP MOV SP,R3 B __svc_timer_ok __svc_no_border_yet ;; LDR SP,[R1,R2,LSL #2] ;Restore SP does not work (errata Cortex M4) ;; CMP SP,#0 ; LDR R3,[R1,R2,LSL #2] ;  SP      CMP R3,#0 ; =0     BEQ __svc_next_check MOV SP,R3 LDR R3,[R0,R2,LSL #2] ;  suspend timer CBZ R3,__svc_timer_ok ; 0    ,   B __svc_next_check __svc_timer_ok STR R2,[R0] ;     LDMIA SP!,{R4-R11} ; R4-R11 BX LR</code> </pre> <br><p>  Harus diingat bahwa semua subrutin dan penangan interupsi ini mengacu pada area data tertentu, yang terlihat dilakukan oleh penulis seperti yang ditunjukkan pada Gambar 7. </p><br><pre> <code class="plaintext hljs"> DATA SECTION .taskSwitcher:CODE:ROOT(2) __topStack DCD sfe(CSTACK) __botStack DCD sfb(CSTACK) __dimStack DCD sizeof(CSTACK) __sysAIRCRaddr DCD 0xE000ED0C __sysTickAddr DCD 0xE000E010 __sysSHPRaddr DCD 0xE000ED18 __sysTickReload DCD RELOAD ;******************************************************************************* ; Task table for concurrent tasks (main is number 0). ;******************************************************************************* SECTION TABLE:DATA:ROOT(2) DS32 1 ;stack shift due to FPU mainCopyCONTROL DS32 1 ;Needed to determine if FPU is used mainPSRvalue DS32 1 ;Copy from main ;*******************************************************************************</code> </pre> <br><p>  Untuk memastikan bahwa semua hal di atas masuk akal, penulis harus menulis proyek kecil di bawah IAR Embedded Workbench, di mana ia berhasil memeriksa dan menyentuh semuanya secara detail.  Semuanya diuji pada pengontrol STM32F303VCT6 (ARM Cortex-M4).  Atau lebih tepatnya, menggunakan papan STM32F3DISCOVERY.  Ada cukup LED untuk memberi setiap tugas banyak flashing dengan LED sendiri secara terpisah. </p><br><p>  Ada beberapa fitur yang menurut saya berguna.  Misalnya, subrutin yang menghitung dalam setiap area tumpukan jumlah kata yang tidak terpengaruh, yaitu, tetap sama dengan nol.  Ini dapat berguna saat debugging, ketika Anda perlu memeriksa apakah mengisi tumpukan dengan satu tugas atau yang lain terlalu dekat dengan level batas. </p><br><pre> <code class="plaintext hljs"> U32 get_task_stack_empty_space(U8 taskNum);</code> </pre> <br><p>  Saya ingin menyebutkan satu fungsi lagi.  Ini adalah peluang bagi tugas itu sendiri untuk mengetahui nomor Anda dalam daftar.  Anda bisa memberi tahu seseorang nanti. </p><br><pre> <code class="plaintext hljs">;******************************************************************************* ; Example: U8 get_my_number(void); ;     (). ..    . ;******************************************************************************* get_my_number LDR R0,=timersTable ;    (currentTaskNumber) LDR R0,[R0] ;  BX LR ;==============================================================</code> </pre> <br><p>  Mungkin itu saja untuk saat ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454874/">https://habr.com/ru/post/id454874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454856/index.html">Kami menganalisis kerentanan validasi sertifikat SSL / TLS dalam perangkat lunak non-browser</a></li>
<li><a href="../id454860/index.html">Mari kita bantu QueryProvider menangani string yang diinterpolasi</a></li>
<li><a href="../id454864/index.html">Bagaimana proses pengembangan di berbagai perusahaan</a></li>
<li><a href="../id454868/index.html">Kompilasi C di WebAssembly tanpa Emscripten</a></li>
<li><a href="../id454872/index.html">Space Invaders: sekarang dalam 512 byte (Assembler x86)</a></li>
<li><a href="../id454876/index.html">Tentang merancang sistem kemampuan karakter yang fleksibel dalam game</a></li>
<li><a href="../id454878/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 3</a></li>
<li><a href="../id454880/index.html">â€œOff-seasonâ€ dalam kehidupan freelancer: bagaimana cara bertahan dan bertahan?</a></li>
<li><a href="../id454882/index.html">Arsitektur situasi yang luar biasa: halaman 2 dari 4</a></li>
<li><a href="../id454884/index.html">Penamaan Tes yang Dapat Dibaca dalam JS dan Pola Perilaku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>