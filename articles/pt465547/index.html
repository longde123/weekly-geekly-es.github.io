<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏼 📙 🙍 Guia SQL: Como escrever consultas melhor (parte 1) 🚁 💪 💪🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aprenda sobre antipadrões, planos de execução, complexidade de tempo, ajuste de consulta e otimização de SQL 
 O SQL (Structured Query Language) é uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia SQL: Como escrever consultas melhor (parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Aprenda sobre antipadrões, planos de execução, complexidade de tempo, ajuste de consulta e otimização de SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  O SQL (Structured Query Language) é uma habilidade indispensável no setor de ciência da computação e, de um modo geral, o aprendizado dessa habilidade é relativamente simples.  No entanto, a maioria das pessoas esquece que o SQL não é apenas escrever consultas, é apenas o primeiro passo adiante.  Garantir o desempenho da consulta ou corresponder ao contexto em que você trabalha é algo completamente diferente. <br><br>  É por isso que este guia SQL fornece uma pequena visão geral de algumas das etapas que você pode seguir para avaliar sua consulta: <br><br><ul><li>  Primeiro, você começará com uma breve visão geral da importância do aprendizado de SQL para trabalhar no campo da ciência de dados; </li><li>  A seguir, você primeiro aprenderá como processar e executar consultas SQL para entender a importância da criação de consultas de qualidade.  Mais especificamente, você verá que a solicitação é analisada, reescrita, otimizada e finalmente avaliada. </li><li>  Com isso em mente, você não apenas passará para alguns dos antipadrões de consultas que os iniciantes fazem ao escrever consultas, mas também aprenderá mais sobre alternativas e soluções para esses possíveis erros;  Além disso, você aprenderá mais sobre a abordagem de consulta baseada em conjunto. </li><li>  Você também verá que esses antipadrões se originam de problemas de desempenho e que, além da abordagem "manual" para melhorar as consultas SQL, é possível analisar suas consultas de maneira mais estruturada e aprofundada, usando algumas outras ferramentas que ajudam a visualizar o plano de consultas;  E </li><li>  Você aprenderá brevemente sobre a complexidade do tempo e a grande notação O, para ter uma idéia da complexidade do plano de execução a tempo antes de executar a solicitação; </li><li>  Você aprenderá brevemente como otimizar sua consulta. </li></ul><a name="habracut"></a><br><h2>  Por que você deve aprender SQL a trabalhar com dados? </h2><br>  O SQL está longe de morrer: essa é uma das habilidades mais procuradas que você encontra nas descrições de cargos do setor de processamento e análise de dados, independentemente de você solicitar análise de dados, engenheiro de dados, especialista em dados ou qualquer outra função.  Isso é confirmado por 70% dos participantes da pesquisa de salários da O 'Reilly Data Science para 2016, que indicam que usam SQL em seu contexto profissional.  Além disso, nesta pesquisa, o SQL se destaca acima das linguagens de programação R (57%) e Python (54%). <br><br>  Você entende: SQL é uma habilidade necessária quando você está trabalhando para conseguir um emprego no setor de TI. <br><br>  Nada mal para uma linguagem que foi desenvolvida no início dos anos 1970, certo? <br><br>  Mas por que é tão frequentemente usado?  E por que ele não morreu, apesar de existir há tanto tempo? <br><br>  Há vários motivos: um dos primeiros motivos pode ser que as empresas armazenem dados principalmente em sistemas de gerenciamento de banco de dados relacional (RDBMS) ou em sistemas de gerenciamento de fluxo de dados relacionais (RDSMS), e o SQL seja necessário para acessar esses dados.  O SQL é a <i>língua franca dos</i> dados: torna possível interagir com quase qualquer banco de dados ou até mesmo criar o seu próprio local! <br><br>  Se isso ainda não for suficiente, lembre-se de que existem algumas implementações SQL incompatíveis entre os fornecedores e que não estão necessariamente em conformidade com os padrões.  Portanto, o conhecimento do SQL padrão é um requisito para você encontrar seu caminho na indústria (ciência da computação). <br><br>  Além disso, é seguro dizer que as novas tecnologias também aderiram ao SQL, como o Hive, uma interface de linguagem de consulta semelhante ao SQL para consultar e gerenciar grandes conjuntos de dados, ou Spark SQL, que pode ser usado para executar consultas SQL.  Novamente, o SQL que você encontrar lá será diferente do padrão que você pode aprender, mas a curva de aprendizado será muito mais simples. <br><br>  Se você quiser fazer uma comparação, considere isso como aprender álgebra linear: depois de colocar todo esse esforço nesse assunto, você sabe que também pode usá-lo para dominar o aprendizado de máquina! <br><br>  Em resumo, é por isso que você deve aprender esta linguagem de consulta: <br><br><ul><li>  É muito fácil aprender, mesmo para iniciantes.  A curva de aprendizado é bastante simples e gradual, portanto você escreverá as perguntas o mais rápido possível. </li><li>  Segue o princípio de “aprenda uma vez, use em qualquer lugar”, portanto, este é um grande investimento do seu tempo! </li><li>  Este é um ótimo complemento para linguagens de programação;  Em alguns casos, escrever uma consulta é ainda preferível a escrever um código, porque é mais eficiente! </li><li>  ... </li></ul><br>  O que você ainda está esperando?  :) <br><br><h2>  Processamento SQL e execução de consultas </h2><br>  Para melhorar o desempenho da sua consulta SQL, primeiro você precisa saber o que acontece dentro quando clica em um atalho para executar a consulta. <br><br>  Primeiro, a solicitação é analisada em uma árvore de análise;  A solicitação é analisada quanto à conformidade com requisitos sintáticos e semânticos.  O analisador cria uma representação interna da solicitação de entrada.  Essa saída é então transferida para o mecanismo de reescrita. <br><br>  Em seguida, o otimizador deve encontrar a execução ideal ou o plano de consulta para a consulta especificada.  O plano de execução determina com precisão qual algoritmo é usado para cada operação e como as operações são coordenadas. <br><br>  Para encontrar o plano de execução ideal, o otimizador lista todos os planos de implementação possíveis, determina a qualidade ou o custo de cada plano, recebe informações sobre o estado atual do banco de dados e seleciona o melhor deles como plano de implementação final.  Como os otimizadores de consulta podem ser imperfeitos, os usuários e administradores de banco de dados às vezes precisam examinar e ajustar manualmente os planos criados pelo otimizador para melhorar o desempenho. <br><br>  Agora você provavelmente está se perguntando o que é considerado um "bom plano de consulta". <br><br>  Como você já leu, a qualidade do custo de um plano desempenha um papel importante.  Mais especificamente, coisas como o número de E / Ss de disco necessárias para avaliar o plano, o custo da CPU do plano e o tempo total de resposta que o cliente do banco de dados pode observar e o tempo total de execução são importantes.  É aqui que surge o conceito de complexidade do tempo.  Você aprenderá mais sobre isso mais tarde. <br><br>  Em seguida, o plano de consulta selecionado é executado, avaliado pelo mecanismo de execução do sistema e os resultados da consulta são retornados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Escrevendo consultas SQL </h2><br>  Pode não ter ficado claro na seção anterior que o princípio Garbage In, Garbage Out (GIGO) se manifesta naturalmente no processo de processamento e execução de uma consulta: quem formula a consulta também possui chaves para o desempenho de suas consultas SQL.  Se o otimizador receber uma solicitação mal formulada, ele poderá fazer o mesmo ... <br><br>  Isso significa que há algumas coisas que você pode fazer ao escrever uma solicitação.  Como você já viu na introdução, a responsabilidade aqui é dupla: não se trata apenas de escrever consultas que atendem a um determinado padrão, mas também de coletar idéias sobre onde os problemas de desempenho podem estar ocultos na sua consulta. <br><br>  Um ponto de partida ideal é pensar em "lugares" em suas consultas onde possam surgir problemas.  E, em geral, existem quatro palavras-chave nas quais os recém-chegados podem esperar que ocorram problemas de desempenho: <br><br><ul><li> Condição <code>WHERE</code> ; </li><li>  Qualquer <code>INNER JOIN</code> chave <code>INNER JOIN</code> ou <code>LEFT JOIN</code> ;  E também </li><li>  <code>HAVING</code> condição; </li></ul><br>  Obviamente, essa abordagem é simples e ingênua, mas, para um iniciante, esses pontos são excelentes indicadores, e é seguro dizer que, quando você inicia, ocorrem erros nesses locais e, curiosamente, onde também é difícil notá-los. <br><br>  No entanto, você também deve entender que desempenho é algo que deve se tornar significativo.  No entanto, apenas dizer que essas frases e palavras-chave são ruins não é o que você precisa quando pensa em desempenho do SQL.  Ter uma <code>HAVING</code> <code>WHERE</code> ou <code>HAVING</code> em uma solicitação não significa necessariamente que é uma solicitação incorreta ... <br><br>  Confira a próxima seção para saber mais sobre antipadrões e abordagens alternativas para criar sua consulta.  Essas dicas e truques servem como guia.  Como e se você realmente precisa reescrever sua solicitação depende, entre outras coisas, da quantidade de dados, do banco de dados e do número de vezes que você precisa concluir a solicitação.  Depende completamente da finalidade da sua solicitação e é crucial ter algum conhecimento prévio sobre o banco de dados com o qual você trabalhará! <br><br><h3>  1. Recupere apenas os dados necessários </h3><br>  A conclusão “quanto mais dados, melhor” - não precisa ser seguida ao escrever SQL: você corre o risco de não apenas ficar confuso ao obter mais dados do que realmente precisa, mas também de desempenho, porque a sua consulta recebe muitos dados. <br><br>  É por isso que, como regra, você deve prestar atenção à <code>SELECT</code> , à <code>SELECT</code> <code>DISTINCT</code> e à instrução <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  A primeira coisa que você já pode verificar ao escrever uma consulta é se a <code>SELECT</code> mais compacta possível.  O objetivo aqui deve ser remover colunas desnecessárias do <code>SELECT</code> .  Dessa forma, você se força a recuperar apenas os dados que atendem ao seu objetivo de consulta. <br><br>  Se você correlacionou subconsultas com <code>EXISTS</code> , tente usar uma constante na <code>SELECT</code> desta subconsulta em vez de escolher o valor da coluna real.  Isso é especialmente conveniente quando você verifica apenas a existência. <br><br>  <b>Lembre-se de</b> que uma subconsulta correlacionada é uma subconsulta que usa valores de uma consulta externa.  E observe que, embora o <code>NULL</code> possa funcionar como uma "constante" nesse contexto, isso é muito confuso! <br><br>  Considere o exemplo a seguir para entender o que significa usar uma constante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Dica: é</b> útil saber que ter uma subconsulta correlata nem sempre é uma boa ideia.  Você sempre pode se livrar deles, por exemplo, reescrevendo-os usando <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Operação <code>DISTINCT</code> </h4><br>  A <code>SELECT DISTINCT</code> usada para retornar apenas valores diferentes.  <code>DISTINCT</code> é um ponto que certamente deve ser evitado, se possível.  Como em outros exemplos, o tempo de execução aumenta apenas quando essa frase é adicionada à solicitação.  Portanto, é sempre útil considerar se você realmente precisa desta operação <code>DISTINCT</code> para obter os resultados que deseja alcançar. <br><br><h4>  <code>LIKE</code> </h4><br>  Ao usar o operador <code>LIKE</code> em uma consulta, o índice não será usado se o padrão iniciar com <code>%</code> ou <code>_</code> .  Isso impedirá que o banco de dados use o índice (se houver).  Obviamente, de outro ponto de vista, também pode ser argumentado que esse tipo de solicitação potencialmente permite obter muitos registros que não necessariamente atendem ao objetivo da solicitação. <br><br>  Novamente, conhecer os dados armazenados no banco de dados pode ajudá-lo a formular um modelo que filtre todos os dados corretamente para encontrar apenas as linhas que são realmente importantes para sua consulta. <br><br><h3>  2. Limite seus resultados </h3><br>  Se você não conseguir evitar filtrar sua <code>SELECT</code> , poderá limitar seus resultados de outras maneiras.  É aqui que entram abordagens como a <code>LIMIT</code> e as conversões de tipo de dados. <br><br><h4>  <code>ROWNUM</code> <code>TOP</code> , <code>LIMIT</code> e <code>ROWNUM</code> </h4><br>  Você pode adicionar instruções <code>LIMIT</code> ou <code>TOP</code> às consultas para especificar o número máximo de linhas para o conjunto de resultados.  Aqui estão alguns exemplos: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Observe que você pode opcionalmente especificar <code>PERCENT</code> , por exemplo, se alterar a primeira linha de consulta com <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Como alternativa, você pode adicionar a <code>ROWNUM</code> equivalente ao uso de <code>LIMIT</code> na consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Conversões de tipo de dados </h4><br>  Os mais eficazes devem sempre ser usados, ou seja,  menor, tipos de dados.  Sempre existe um risco quando você fornece um grande tipo de dados, enquanto um menor é mais suficiente. <br><br>  No entanto, ao adicionar uma conversão de tipo de dados à consulta, apenas o tempo de execução aumenta. <br><br>  Uma alternativa é evitar a conversão do tipo de dados, tanto quanto possível.  Observe também que nem sempre é possível remover ou ignorar a conversão de tipo de dados das consultas, mas você deve sempre se esforçar para incluí-las e deve verificar o efeito da adição antes de executar a consulta. <br><br><h3>  3. Não torne as consultas mais complicadas do que deveriam </h3><br>  As conversões de tipo de dados levam você ao seguinte ponto: você não deve criar excessivamente suas consultas.  Tente torná-los simples e eficazes.  Isso pode parecer simples ou estúpido demais para ser uma dica, principalmente porque os pedidos podem ser complexos. <br><br>  No entanto, nos exemplos mencionados nas seções a seguir, você verá que é fácil começar a tornar as consultas simples mais complexas do que deveriam. <br><br><h4>  Operador <code>OR</code> </h4><br>  Quando você usa o operador <code>OR</code> na sua consulta, provavelmente você não está usando um índice. <br><br>  Lembre-se de que um índice é uma estrutura de dados que melhora a velocidade de pesquisa de dados em uma tabela de banco de dados, mas é caro: registros adicionais serão necessários e espaço de armazenamento adicional será necessário para manter a estrutura de dados do índice.  Os índices são usados ​​para pesquisar ou procurar dados rapidamente, sem ter que pesquisar todas as linhas do banco de dados sempre que a tabela do banco de dados for acessada.  Os índices podem ser criados usando uma ou mais colunas em uma tabela de banco de dados. <br><br>  Se você não usar índices incluídos no banco de dados, a execução da sua consulta inevitavelmente levará mais tempo.  É por isso que é melhor procurar alternativas para usar o operador <code>OR</code> na sua consulta; <br><br>  Considere a seguinte consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  O operador pode ser substituído por: <br><br>  Condição com <code>IN</code> ;  ou <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Duas <code>SELECT</code> com <code>UNION</code> . <br><br>  <b>Dica:</b> aqui você deve ter cuidado para não usar a operação <code>UNION</code> desnecessária, porque está visualizando a mesma tabela várias vezes.  Ao mesmo tempo, você deve entender que, quando você usa <code>UNION</code> em sua consulta, o tempo de execução aumenta.  Alternativas à operação <code>UNION</code> : reformule a consulta para que todas as condições sejam colocadas em uma única <code>SELECT</code> ou use <code>OUTER JOIN</code> vez de <code>UNION</code> . <br><br>  <b>Dica:</b> Lembre-se de que, embora <code>OR</code> - e os outros operadores mencionados nas seções a seguir - provavelmente não usem um índice, a pesquisa de índice nem sempre é preferível! <br><br><h4>  Operador <code>NOT</code> </h4><br>  Quando sua consulta contém um operador <code>NOT</code> , é provável que o índice não seja usado, como no operador <code>OR</code> .  Isso inevitavelmente desacelerará sua solicitação.  Se você não souber o que significa aqui, considere a seguinte consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Essa consulta certamente será mais lenta do que você poderia esperar, principalmente porque é formulada muito mais complicada do que pode ser: em casos como esse, é melhor procurar uma alternativa.  Considere substituir <code>NOT</code> operadores de comparação, como <code>&gt;</code> , <code>&lt;&gt;</code> ou <code>!&gt;</code> ;  O exemplo acima pode realmente ser reescrito e mais ou menos assim: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Já parece melhor, certo? <br><br><h4>  Operador <code>AND</code> </h4><br>  O operador <code>AND</code> é outro operador que não usa um índice e pode desacelerar uma consulta se for usada de uma maneira excessivamente complexa e ineficiente, como no exemplo a seguir: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  É melhor reescrever esta consulta usando a instrução <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> e <code>ALL</code> operadores </h4><br>  Além disso, você deve ter cuidado com os operadores <code>ANY</code> e <code>ALL</code> , pois se você incluí-los em suas consultas, o índice não será usado.  Funções de agregação alternativas, como <code>MIN</code> ou <code>MAX</code> são úteis aqui. <br><br>  Dica: nos casos em que você usa as alternativas propostas, lembre-se de que todas as funções de agregação, como <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> em muitas linhas, podem levar a uma consulta longa.  Nesses casos, você pode tentar minimizar o número de linhas para processar ou pré-calcular esses valores.  Mais uma vez, você percebe que é importante conhecer seu ambiente, seu objetivo da solicitação ... Quando você decide qual solicitação usar! <br><br><h4>  Isolar colunas em condições </h4><br>  Além disso, nos casos em que uma coluna é usada em um cálculo ou em uma função escalar, o índice não é usado.  Uma solução possível seria simplesmente selecionar uma coluna específica para que não faça mais parte do cálculo ou da função.  Considere o seguinte exemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Parece engraçado, né?  Em vez disso, tente revisar o cálculo e reescrever a consulta da seguinte maneira: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Falta de força bruta </h3><br>  Esta última dica significa que você não deve tentar limitar demais a solicitação, pois isso pode afetar seu desempenho.  Isto é especialmente verdade para junções e para a cláusula HAVING. <br><br><h4>  Ordem da tabela nas junções </h4><br>  Ao ingressar em duas tabelas, pode ser importante considerar a ordem das tabelas na associação.  Se você perceber que uma tabela é significativamente maior que a outra, talvez seja necessário reescrever a consulta para que a maior tabela seja colocada por último na associação. <br><br><h4>  Condições de conexão excessivas </h4><br>  Se você adicionar muitas condições às conexões SQL, deverá escolher um caminho específico.  No entanto, pode ser que esse caminho nem sempre seja mais eficiente. <br><br><h4>  <code>HAVING</code> Condição </h4><br>  A <code>HAVING</code> foi originalmente adicionada ao SQL porque a palavra-chave <code>WHERE</code> não pôde ser usada com funções agregadas.  <code>HAVING</code> geralmente <code>HAVING</code> usado com a <code>GROUP BY</code> para restringir grupos de linhas retornadas apenas àquelas que satisfazem determinadas condições.  No entanto, se essa condição for usada na consulta, o índice não será usado, o que, como você já sabe, pode levar ao fato de que a consulta realmente não funciona tão bem. <br><br>  Se você está procurando uma alternativa, tente usar a <code>WHERE</code> . <br><br>  Considere as seguintes consultas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  A primeira consulta usa a <code>WHERE</code> para limitar o número de linhas que precisam ser resumidas, enquanto a segunda consulta soma todas as linhas da tabela e, em seguida, usa <code>HAVING</code> para descartar os valores calculados.  Nesses casos, a opção da <code>WHERE</code> é claramente melhor, pois você não está desperdiçando recursos. <br><br>  Pode-se observar que não se trata de limitar o conjunto de resultados, mas de limitar o número intermediário de registros na consulta. <br><br>  Deve-se notar que a diferença entre as duas condições é que a <code>WHERE</code> introduz uma condição para linhas individuais, enquanto a <code>HAVING</code> introduz uma condição para agregações ou resultados de seleção, onde um resultado, como <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... foi criado a partir de várias linhas. <br><br>  Veja bem, solicitações de avaliação de qualidade, gravação e reescrita não são uma tarefa fácil, uma vez que devem ser o mais produtivas possível;  A prevenção de antipadrões e a consideração de opções alternativas também farão parte da responsabilidade ao escrever consultas que precisam ser executadas em bancos de dados em um ambiente profissional. <br><br>  Esta lista foi apenas uma pequena visão geral de alguns antipadrões e dicas que, espero, ajudem os iniciantes;  Se você quiser ter uma idéia do que os desenvolvedores mais antigos consideram os antipadrões mais comuns, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta discussão</a> . <br><br><h2>  Abordagens baseadas em conjuntos versus procedimentos para escrever consultas </h2><br>  Os antipatterns mencionados acima implicam que eles realmente se resumem a uma diferença nas abordagens processual e baseada em conjuntos para construir suas consultas. <br><br>  A abordagem processual das consultas é muito semelhante à programação: você diz ao sistema o que fazer e como fazê-lo. <br><br>  Um exemplo disso são condições excessivas em conexões ou casos em que você abusa das condições <code>HAVING</code> , como nos exemplos acima, nos quais você consulta um banco de dados executando uma função e depois chamando outra função, ou usa uma lógica que contém condições, loops, funções definidas pelo usuário ( UDF), cursores, ... para obter o resultado final.  Com essa abordagem, você geralmente solicita um subconjunto dos dados, solicita outro subconjunto dos dados e assim por diante. <br><br>  Sem surpresa, essa abordagem é frequentemente chamada de consulta "passo a passo" ou "linha por linha". <br><br>  Outra abordagem é uma abordagem baseada em conjuntos, onde você simplesmente indica o que fazer.  Sua função é especificar as condições ou requisitos para o conjunto de resultados que você deseja receber da consulta.  Você deixa a maneira como seus dados são recuperados para os mecanismos internos que determinam a implementação da consulta: permite que o mecanismo de banco de dados determine os melhores algoritmos ou lógica de processamento para executar sua consulta. <br><br>  Como o SQL é baseado em conjunto, não é de surpreender que essa abordagem seja mais eficiente do que processual e também explica por que, em alguns casos, o SQL pode executar mais rápido que o código. <br><br>  <b>O aconselhamento é uma</b> abordagem baseada em <b>conjuntos</b> para a consulta também é a que os empregadores mais importantes do setor de tecnologia da informação solicitarão que você domine!  Muitas vezes é necessário alternar entre esses dois tipos de abordagens. <br><br>  <b>Observe</b> que, se você precisar de uma solicitação de procedimento, considere reescrevê-la ou refatorá-la. <br><br>  A próxima parte abordará o plano e a otimização de consultas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465547/">https://habr.com/ru/post/pt465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465535/index.html">Quem implementa o IPv6 e o ​​que dificulta o seu desenvolvimento</a></li>
<li><a href="../pt465537/index.html">Yandex: uma casa inteligente para adultos</a></li>
<li><a href="../pt465539/index.html">766 km - um novo recorde de alcance para o LoRaWAN</a></li>
<li><a href="../pt465541/index.html">Das empresas às pequenas e médias empresas: compartilhamos nossa experiência na adaptação de soluções corporativas para pequenas e médias empresas com monetização usando o modelo SaaS</a></li>
<li><a href="../pt465545/index.html">Em diferentes lados do estado: como o Facebook foi frito no Congresso dos EUA, enquanto o Telegram lutou com o FSB</a></li>
<li><a href="../pt465551/index.html">Resumo dos eventos de TI de setembro (parte um)</a></li>
<li><a href="../pt465553/index.html">Linguagem de programação Ü. Introdução, motivação para criar, objetivos</a></li>
<li><a href="../pt465555/index.html">12 Soft Skills que tornam os gerentes de projeto de TI imparáveis</a></li>
<li><a href="../pt465557/index.html">Prazos de Desenvolvimento de Produto</a></li>
<li><a href="../pt465561/index.html">O que aprendi com um programador líder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>