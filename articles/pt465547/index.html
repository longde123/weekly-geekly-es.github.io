<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèº üìô üôç Guia SQL: Como escrever consultas melhor (parte 1) üöÅ üí™ üí™üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aprenda sobre antipadr√µes, planos de execu√ß√£o, complexidade de tempo, ajuste de consulta e otimiza√ß√£o de SQL 
 O SQL (Structured Query Language) √© uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia SQL: Como escrever consultas melhor (parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Aprenda sobre antipadr√µes, planos de execu√ß√£o, complexidade de tempo, ajuste de consulta e otimiza√ß√£o de SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  O SQL (Structured Query Language) √© uma habilidade indispens√°vel no setor de ci√™ncia da computa√ß√£o e, de um modo geral, o aprendizado dessa habilidade √© relativamente simples.  No entanto, a maioria das pessoas esquece que o SQL n√£o √© apenas escrever consultas, √© apenas o primeiro passo adiante.  Garantir o desempenho da consulta ou corresponder ao contexto em que voc√™ trabalha √© algo completamente diferente. <br><br>  √â por isso que este guia SQL fornece uma pequena vis√£o geral de algumas das etapas que voc√™ pode seguir para avaliar sua consulta: <br><br><ul><li>  Primeiro, voc√™ come√ßar√° com uma breve vis√£o geral da import√¢ncia do aprendizado de SQL para trabalhar no campo da ci√™ncia de dados; </li><li>  A seguir, voc√™ primeiro aprender√° como processar e executar consultas SQL para entender a import√¢ncia da cria√ß√£o de consultas de qualidade.  Mais especificamente, voc√™ ver√° que a solicita√ß√£o √© analisada, reescrita, otimizada e finalmente avaliada. </li><li>  Com isso em mente, voc√™ n√£o apenas passar√° para alguns dos antipadr√µes de consultas que os iniciantes fazem ao escrever consultas, mas tamb√©m aprender√° mais sobre alternativas e solu√ß√µes para esses poss√≠veis erros;  Al√©m disso, voc√™ aprender√° mais sobre a abordagem de consulta baseada em conjunto. </li><li>  Voc√™ tamb√©m ver√° que esses antipadr√µes se originam de problemas de desempenho e que, al√©m da abordagem "manual" para melhorar as consultas SQL, √© poss√≠vel analisar suas consultas de maneira mais estruturada e aprofundada, usando algumas outras ferramentas que ajudam a visualizar o plano de consultas;  E </li><li>  Voc√™ aprender√° brevemente sobre a complexidade do tempo e a grande nota√ß√£o O, para ter uma id√©ia da complexidade do plano de execu√ß√£o a tempo antes de executar a solicita√ß√£o; </li><li>  Voc√™ aprender√° brevemente como otimizar sua consulta. </li></ul><a name="habracut"></a><br><h2>  Por que voc√™ deve aprender SQL a trabalhar com dados? </h2><br>  O SQL est√° longe de morrer: essa √© uma das habilidades mais procuradas que voc√™ encontra nas descri√ß√µes de cargos do setor de processamento e an√°lise de dados, independentemente de voc√™ solicitar an√°lise de dados, engenheiro de dados, especialista em dados ou qualquer outra fun√ß√£o.  Isso √© confirmado por 70% dos participantes da pesquisa de sal√°rios da O 'Reilly Data Science para 2016, que indicam que usam SQL em seu contexto profissional.  Al√©m disso, nesta pesquisa, o SQL se destaca acima das linguagens de programa√ß√£o R (57%) e Python (54%). <br><br>  Voc√™ entende: SQL √© uma habilidade necess√°ria quando voc√™ est√° trabalhando para conseguir um emprego no setor de TI. <br><br>  Nada mal para uma linguagem que foi desenvolvida no in√≠cio dos anos 1970, certo? <br><br>  Mas por que √© t√£o frequentemente usado?  E por que ele n√£o morreu, apesar de existir h√° tanto tempo? <br><br>  H√° v√°rios motivos: um dos primeiros motivos pode ser que as empresas armazenem dados principalmente em sistemas de gerenciamento de banco de dados relacional (RDBMS) ou em sistemas de gerenciamento de fluxo de dados relacionais (RDSMS), e o SQL seja necess√°rio para acessar esses dados.  O SQL √© a <i>l√≠ngua franca dos</i> dados: torna poss√≠vel interagir com quase qualquer banco de dados ou at√© mesmo criar o seu pr√≥prio local! <br><br>  Se isso ainda n√£o for suficiente, lembre-se de que existem algumas implementa√ß√µes SQL incompat√≠veis entre os fornecedores e que n√£o est√£o necessariamente em conformidade com os padr√µes.  Portanto, o conhecimento do SQL padr√£o √© um requisito para voc√™ encontrar seu caminho na ind√∫stria (ci√™ncia da computa√ß√£o). <br><br>  Al√©m disso, √© seguro dizer que as novas tecnologias tamb√©m aderiram ao SQL, como o Hive, uma interface de linguagem de consulta semelhante ao SQL para consultar e gerenciar grandes conjuntos de dados, ou Spark SQL, que pode ser usado para executar consultas SQL.  Novamente, o SQL que voc√™ encontrar l√° ser√° diferente do padr√£o que voc√™ pode aprender, mas a curva de aprendizado ser√° muito mais simples. <br><br>  Se voc√™ quiser fazer uma compara√ß√£o, considere isso como aprender √°lgebra linear: depois de colocar todo esse esfor√ßo nesse assunto, voc√™ sabe que tamb√©m pode us√°-lo para dominar o aprendizado de m√°quina! <br><br>  Em resumo, √© por isso que voc√™ deve aprender esta linguagem de consulta: <br><br><ul><li>  √â muito f√°cil aprender, mesmo para iniciantes.  A curva de aprendizado √© bastante simples e gradual, portanto voc√™ escrever√° as perguntas o mais r√°pido poss√≠vel. </li><li>  Segue o princ√≠pio de ‚Äúaprenda uma vez, use em qualquer lugar‚Äù, portanto, este √© um grande investimento do seu tempo! </li><li>  Este √© um √≥timo complemento para linguagens de programa√ß√£o;  Em alguns casos, escrever uma consulta √© ainda prefer√≠vel a escrever um c√≥digo, porque √© mais eficiente! </li><li>  ... </li></ul><br>  O que voc√™ ainda est√° esperando?  :) <br><br><h2>  Processamento SQL e execu√ß√£o de consultas </h2><br>  Para melhorar o desempenho da sua consulta SQL, primeiro voc√™ precisa saber o que acontece dentro quando clica em um atalho para executar a consulta. <br><br>  Primeiro, a solicita√ß√£o √© analisada em uma √°rvore de an√°lise;  A solicita√ß√£o √© analisada quanto √† conformidade com requisitos sint√°ticos e sem√¢nticos.  O analisador cria uma representa√ß√£o interna da solicita√ß√£o de entrada.  Essa sa√≠da √© ent√£o transferida para o mecanismo de reescrita. <br><br>  Em seguida, o otimizador deve encontrar a execu√ß√£o ideal ou o plano de consulta para a consulta especificada.  O plano de execu√ß√£o determina com precis√£o qual algoritmo √© usado para cada opera√ß√£o e como as opera√ß√µes s√£o coordenadas. <br><br>  Para encontrar o plano de execu√ß√£o ideal, o otimizador lista todos os planos de implementa√ß√£o poss√≠veis, determina a qualidade ou o custo de cada plano, recebe informa√ß√µes sobre o estado atual do banco de dados e seleciona o melhor deles como plano de implementa√ß√£o final.  Como os otimizadores de consulta podem ser imperfeitos, os usu√°rios e administradores de banco de dados √†s vezes precisam examinar e ajustar manualmente os planos criados pelo otimizador para melhorar o desempenho. <br><br>  Agora voc√™ provavelmente est√° se perguntando o que √© considerado um "bom plano de consulta". <br><br>  Como voc√™ j√° leu, a qualidade do custo de um plano desempenha um papel importante.  Mais especificamente, coisas como o n√∫mero de E / Ss de disco necess√°rias para avaliar o plano, o custo da CPU do plano e o tempo total de resposta que o cliente do banco de dados pode observar e o tempo total de execu√ß√£o s√£o importantes.  √â aqui que surge o conceito de complexidade do tempo.  Voc√™ aprender√° mais sobre isso mais tarde. <br><br>  Em seguida, o plano de consulta selecionado √© executado, avaliado pelo mecanismo de execu√ß√£o do sistema e os resultados da consulta s√£o retornados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Escrevendo consultas SQL </h2><br>  Pode n√£o ter ficado claro na se√ß√£o anterior que o princ√≠pio Garbage In, Garbage Out (GIGO) se manifesta naturalmente no processo de processamento e execu√ß√£o de uma consulta: quem formula a consulta tamb√©m possui chaves para o desempenho de suas consultas SQL.  Se o otimizador receber uma solicita√ß√£o mal formulada, ele poder√° fazer o mesmo ... <br><br>  Isso significa que h√° algumas coisas que voc√™ pode fazer ao escrever uma solicita√ß√£o.  Como voc√™ j√° viu na introdu√ß√£o, a responsabilidade aqui √© dupla: n√£o se trata apenas de escrever consultas que atendem a um determinado padr√£o, mas tamb√©m de coletar id√©ias sobre onde os problemas de desempenho podem estar ocultos na sua consulta. <br><br>  Um ponto de partida ideal √© pensar em "lugares" em suas consultas onde possam surgir problemas.  E, em geral, existem quatro palavras-chave nas quais os rec√©m-chegados podem esperar que ocorram problemas de desempenho: <br><br><ul><li> Condi√ß√£o <code>WHERE</code> ; </li><li>  Qualquer <code>INNER JOIN</code> chave <code>INNER JOIN</code> ou <code>LEFT JOIN</code> ;  E tamb√©m </li><li>  <code>HAVING</code> condi√ß√£o; </li></ul><br>  Obviamente, essa abordagem √© simples e ing√™nua, mas, para um iniciante, esses pontos s√£o excelentes indicadores, e √© seguro dizer que, quando voc√™ inicia, ocorrem erros nesses locais e, curiosamente, onde tamb√©m √© dif√≠cil not√°-los. <br><br>  No entanto, voc√™ tamb√©m deve entender que desempenho √© algo que deve se tornar significativo.  No entanto, apenas dizer que essas frases e palavras-chave s√£o ruins n√£o √© o que voc√™ precisa quando pensa em desempenho do SQL.  Ter uma <code>HAVING</code> <code>WHERE</code> ou <code>HAVING</code> em uma solicita√ß√£o n√£o significa necessariamente que √© uma solicita√ß√£o incorreta ... <br><br>  Confira a pr√≥xima se√ß√£o para saber mais sobre antipadr√µes e abordagens alternativas para criar sua consulta.  Essas dicas e truques servem como guia.  Como e se voc√™ realmente precisa reescrever sua solicita√ß√£o depende, entre outras coisas, da quantidade de dados, do banco de dados e do n√∫mero de vezes que voc√™ precisa concluir a solicita√ß√£o.  Depende completamente da finalidade da sua solicita√ß√£o e √© crucial ter algum conhecimento pr√©vio sobre o banco de dados com o qual voc√™ trabalhar√°! <br><br><h3>  1. Recupere apenas os dados necess√°rios </h3><br>  A conclus√£o ‚Äúquanto mais dados, melhor‚Äù - n√£o precisa ser seguida ao escrever SQL: voc√™ corre o risco de n√£o apenas ficar confuso ao obter mais dados do que realmente precisa, mas tamb√©m de desempenho, porque a sua consulta recebe muitos dados. <br><br>  √â por isso que, como regra, voc√™ deve prestar aten√ß√£o √† <code>SELECT</code> , √† <code>SELECT</code> <code>DISTINCT</code> e √† instru√ß√£o <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  A primeira coisa que voc√™ j√° pode verificar ao escrever uma consulta √© se a <code>SELECT</code> mais compacta poss√≠vel.  O objetivo aqui deve ser remover colunas desnecess√°rias do <code>SELECT</code> .  Dessa forma, voc√™ se for√ßa a recuperar apenas os dados que atendem ao seu objetivo de consulta. <br><br>  Se voc√™ correlacionou subconsultas com <code>EXISTS</code> , tente usar uma constante na <code>SELECT</code> desta subconsulta em vez de escolher o valor da coluna real.  Isso √© especialmente conveniente quando voc√™ verifica apenas a exist√™ncia. <br><br>  <b>Lembre-se de</b> que uma subconsulta correlacionada √© uma subconsulta que usa valores de uma consulta externa.  E observe que, embora o <code>NULL</code> possa funcionar como uma "constante" nesse contexto, isso √© muito confuso! <br><br>  Considere o exemplo a seguir para entender o que significa usar uma constante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Dica: √©</b> √∫til saber que ter uma subconsulta correlata nem sempre √© uma boa ideia.  Voc√™ sempre pode se livrar deles, por exemplo, reescrevendo-os usando <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Opera√ß√£o <code>DISTINCT</code> </h4><br>  A <code>SELECT DISTINCT</code> usada para retornar apenas valores diferentes.  <code>DISTINCT</code> √© um ponto que certamente deve ser evitado, se poss√≠vel.  Como em outros exemplos, o tempo de execu√ß√£o aumenta apenas quando essa frase √© adicionada √† solicita√ß√£o.  Portanto, √© sempre √∫til considerar se voc√™ realmente precisa desta opera√ß√£o <code>DISTINCT</code> para obter os resultados que deseja alcan√ßar. <br><br><h4>  <code>LIKE</code> </h4><br>  Ao usar o operador <code>LIKE</code> em uma consulta, o √≠ndice n√£o ser√° usado se o padr√£o iniciar com <code>%</code> ou <code>_</code> .  Isso impedir√° que o banco de dados use o √≠ndice (se houver).  Obviamente, de outro ponto de vista, tamb√©m pode ser argumentado que esse tipo de solicita√ß√£o potencialmente permite obter muitos registros que n√£o necessariamente atendem ao objetivo da solicita√ß√£o. <br><br>  Novamente, conhecer os dados armazenados no banco de dados pode ajud√°-lo a formular um modelo que filtre todos os dados corretamente para encontrar apenas as linhas que s√£o realmente importantes para sua consulta. <br><br><h3>  2. Limite seus resultados </h3><br>  Se voc√™ n√£o conseguir evitar filtrar sua <code>SELECT</code> , poder√° limitar seus resultados de outras maneiras.  √â aqui que entram abordagens como a <code>LIMIT</code> e as convers√µes de tipo de dados. <br><br><h4>  <code>ROWNUM</code> <code>TOP</code> , <code>LIMIT</code> e <code>ROWNUM</code> </h4><br>  Voc√™ pode adicionar instru√ß√µes <code>LIMIT</code> ou <code>TOP</code> √†s consultas para especificar o n√∫mero m√°ximo de linhas para o conjunto de resultados.  Aqui est√£o alguns exemplos: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Observe que voc√™ pode opcionalmente especificar <code>PERCENT</code> , por exemplo, se alterar a primeira linha de consulta com <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Como alternativa, voc√™ pode adicionar a <code>ROWNUM</code> equivalente ao uso de <code>LIMIT</code> na consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Convers√µes de tipo de dados </h4><br>  Os mais eficazes devem sempre ser usados, ou seja,  menor, tipos de dados.  Sempre existe um risco quando voc√™ fornece um grande tipo de dados, enquanto um menor √© mais suficiente. <br><br>  No entanto, ao adicionar uma convers√£o de tipo de dados √† consulta, apenas o tempo de execu√ß√£o aumenta. <br><br>  Uma alternativa √© evitar a convers√£o do tipo de dados, tanto quanto poss√≠vel.  Observe tamb√©m que nem sempre √© poss√≠vel remover ou ignorar a convers√£o de tipo de dados das consultas, mas voc√™ deve sempre se esfor√ßar para inclu√≠-las e deve verificar o efeito da adi√ß√£o antes de executar a consulta. <br><br><h3>  3. N√£o torne as consultas mais complicadas do que deveriam </h3><br>  As convers√µes de tipo de dados levam voc√™ ao seguinte ponto: voc√™ n√£o deve criar excessivamente suas consultas.  Tente torn√°-los simples e eficazes.  Isso pode parecer simples ou est√∫pido demais para ser uma dica, principalmente porque os pedidos podem ser complexos. <br><br>  No entanto, nos exemplos mencionados nas se√ß√µes a seguir, voc√™ ver√° que √© f√°cil come√ßar a tornar as consultas simples mais complexas do que deveriam. <br><br><h4>  Operador <code>OR</code> </h4><br>  Quando voc√™ usa o operador <code>OR</code> na sua consulta, provavelmente voc√™ n√£o est√° usando um √≠ndice. <br><br>  Lembre-se de que um √≠ndice √© uma estrutura de dados que melhora a velocidade de pesquisa de dados em uma tabela de banco de dados, mas √© caro: registros adicionais ser√£o necess√°rios e espa√ßo de armazenamento adicional ser√° necess√°rio para manter a estrutura de dados do √≠ndice.  Os √≠ndices s√£o usados ‚Äã‚Äãpara pesquisar ou procurar dados rapidamente, sem ter que pesquisar todas as linhas do banco de dados sempre que a tabela do banco de dados for acessada.  Os √≠ndices podem ser criados usando uma ou mais colunas em uma tabela de banco de dados. <br><br>  Se voc√™ n√£o usar √≠ndices inclu√≠dos no banco de dados, a execu√ß√£o da sua consulta inevitavelmente levar√° mais tempo.  √â por isso que √© melhor procurar alternativas para usar o operador <code>OR</code> na sua consulta; <br><br>  Considere a seguinte consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  O operador pode ser substitu√≠do por: <br><br>  Condi√ß√£o com <code>IN</code> ;  ou <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Duas <code>SELECT</code> com <code>UNION</code> . <br><br>  <b>Dica:</b> aqui voc√™ deve ter cuidado para n√£o usar a opera√ß√£o <code>UNION</code> desnecess√°ria, porque est√° visualizando a mesma tabela v√°rias vezes.  Ao mesmo tempo, voc√™ deve entender que, quando voc√™ usa <code>UNION</code> em sua consulta, o tempo de execu√ß√£o aumenta.  Alternativas √† opera√ß√£o <code>UNION</code> : reformule a consulta para que todas as condi√ß√µes sejam colocadas em uma √∫nica <code>SELECT</code> ou use <code>OUTER JOIN</code> vez de <code>UNION</code> . <br><br>  <b>Dica:</b> Lembre-se de que, embora <code>OR</code> - e os outros operadores mencionados nas se√ß√µes a seguir - provavelmente n√£o usem um √≠ndice, a pesquisa de √≠ndice nem sempre √© prefer√≠vel! <br><br><h4>  Operador <code>NOT</code> </h4><br>  Quando sua consulta cont√©m um operador <code>NOT</code> , √© prov√°vel que o √≠ndice n√£o seja usado, como no operador <code>OR</code> .  Isso inevitavelmente desacelerar√° sua solicita√ß√£o.  Se voc√™ n√£o souber o que significa aqui, considere a seguinte consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Essa consulta certamente ser√° mais lenta do que voc√™ poderia esperar, principalmente porque √© formulada muito mais complicada do que pode ser: em casos como esse, √© melhor procurar uma alternativa.  Considere substituir <code>NOT</code> operadores de compara√ß√£o, como <code>&gt;</code> , <code>&lt;&gt;</code> ou <code>!&gt;</code> ;  O exemplo acima pode realmente ser reescrito e mais ou menos assim: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  J√° parece melhor, certo? <br><br><h4>  Operador <code>AND</code> </h4><br>  O operador <code>AND</code> √© outro operador que n√£o usa um √≠ndice e pode desacelerar uma consulta se for usada de uma maneira excessivamente complexa e ineficiente, como no exemplo a seguir: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  √â melhor reescrever esta consulta usando a instru√ß√£o <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> e <code>ALL</code> operadores </h4><br>  Al√©m disso, voc√™ deve ter cuidado com os operadores <code>ANY</code> e <code>ALL</code> , pois se voc√™ inclu√≠-los em suas consultas, o √≠ndice n√£o ser√° usado.  Fun√ß√µes de agrega√ß√£o alternativas, como <code>MIN</code> ou <code>MAX</code> s√£o √∫teis aqui. <br><br>  Dica: nos casos em que voc√™ usa as alternativas propostas, lembre-se de que todas as fun√ß√µes de agrega√ß√£o, como <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> em muitas linhas, podem levar a uma consulta longa.  Nesses casos, voc√™ pode tentar minimizar o n√∫mero de linhas para processar ou pr√©-calcular esses valores.  Mais uma vez, voc√™ percebe que √© importante conhecer seu ambiente, seu objetivo da solicita√ß√£o ... Quando voc√™ decide qual solicita√ß√£o usar! <br><br><h4>  Isolar colunas em condi√ß√µes </h4><br>  Al√©m disso, nos casos em que uma coluna √© usada em um c√°lculo ou em uma fun√ß√£o escalar, o √≠ndice n√£o √© usado.  Uma solu√ß√£o poss√≠vel seria simplesmente selecionar uma coluna espec√≠fica para que n√£o fa√ßa mais parte do c√°lculo ou da fun√ß√£o.  Considere o seguinte exemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Parece engra√ßado, n√©?  Em vez disso, tente revisar o c√°lculo e reescrever a consulta da seguinte maneira: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Falta de for√ßa bruta </h3><br>  Esta √∫ltima dica significa que voc√™ n√£o deve tentar limitar demais a solicita√ß√£o, pois isso pode afetar seu desempenho.  Isto √© especialmente verdade para jun√ß√µes e para a cl√°usula HAVING. <br><br><h4>  Ordem da tabela nas jun√ß√µes </h4><br>  Ao ingressar em duas tabelas, pode ser importante considerar a ordem das tabelas na associa√ß√£o.  Se voc√™ perceber que uma tabela √© significativamente maior que a outra, talvez seja necess√°rio reescrever a consulta para que a maior tabela seja colocada por √∫ltimo na associa√ß√£o. <br><br><h4>  Condi√ß√µes de conex√£o excessivas </h4><br>  Se voc√™ adicionar muitas condi√ß√µes √†s conex√µes SQL, dever√° escolher um caminho espec√≠fico.  No entanto, pode ser que esse caminho nem sempre seja mais eficiente. <br><br><h4>  <code>HAVING</code> Condi√ß√£o </h4><br>  A <code>HAVING</code> foi originalmente adicionada ao SQL porque a palavra-chave <code>WHERE</code> n√£o p√¥de ser usada com fun√ß√µes agregadas.  <code>HAVING</code> geralmente <code>HAVING</code> usado com a <code>GROUP BY</code> para restringir grupos de linhas retornadas apenas √†quelas que satisfazem determinadas condi√ß√µes.  No entanto, se essa condi√ß√£o for usada na consulta, o √≠ndice n√£o ser√° usado, o que, como voc√™ j√° sabe, pode levar ao fato de que a consulta realmente n√£o funciona t√£o bem. <br><br>  Se voc√™ est√° procurando uma alternativa, tente usar a <code>WHERE</code> . <br><br>  Considere as seguintes consultas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  A primeira consulta usa a <code>WHERE</code> para limitar o n√∫mero de linhas que precisam ser resumidas, enquanto a segunda consulta soma todas as linhas da tabela e, em seguida, usa <code>HAVING</code> para descartar os valores calculados.  Nesses casos, a op√ß√£o da <code>WHERE</code> √© claramente melhor, pois voc√™ n√£o est√° desperdi√ßando recursos. <br><br>  Pode-se observar que n√£o se trata de limitar o conjunto de resultados, mas de limitar o n√∫mero intermedi√°rio de registros na consulta. <br><br>  Deve-se notar que a diferen√ßa entre as duas condi√ß√µes √© que a <code>WHERE</code> introduz uma condi√ß√£o para linhas individuais, enquanto a <code>HAVING</code> introduz uma condi√ß√£o para agrega√ß√µes ou resultados de sele√ß√£o, onde um resultado, como <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... foi criado a partir de v√°rias linhas. <br><br>  Veja bem, solicita√ß√µes de avalia√ß√£o de qualidade, grava√ß√£o e reescrita n√£o s√£o uma tarefa f√°cil, uma vez que devem ser o mais produtivas poss√≠vel;  A preven√ß√£o de antipadr√µes e a considera√ß√£o de op√ß√µes alternativas tamb√©m far√£o parte da responsabilidade ao escrever consultas que precisam ser executadas em bancos de dados em um ambiente profissional. <br><br>  Esta lista foi apenas uma pequena vis√£o geral de alguns antipadr√µes e dicas que, espero, ajudem os iniciantes;  Se voc√™ quiser ter uma id√©ia do que os desenvolvedores mais antigos consideram os antipadr√µes mais comuns, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta discuss√£o</a> . <br><br><h2>  Abordagens baseadas em conjuntos versus procedimentos para escrever consultas </h2><br>  Os antipatterns mencionados acima implicam que eles realmente se resumem a uma diferen√ßa nas abordagens processual e baseada em conjuntos para construir suas consultas. <br><br>  A abordagem processual das consultas √© muito semelhante √† programa√ß√£o: voc√™ diz ao sistema o que fazer e como faz√™-lo. <br><br>  Um exemplo disso s√£o condi√ß√µes excessivas em conex√µes ou casos em que voc√™ abusa das condi√ß√µes <code>HAVING</code> , como nos exemplos acima, nos quais voc√™ consulta um banco de dados executando uma fun√ß√£o e depois chamando outra fun√ß√£o, ou usa uma l√≥gica que cont√©m condi√ß√µes, loops, fun√ß√µes definidas pelo usu√°rio ( UDF), cursores, ... para obter o resultado final.  Com essa abordagem, voc√™ geralmente solicita um subconjunto dos dados, solicita outro subconjunto dos dados e assim por diante. <br><br>  Sem surpresa, essa abordagem √© frequentemente chamada de consulta "passo a passo" ou "linha por linha". <br><br>  Outra abordagem √© uma abordagem baseada em conjuntos, onde voc√™ simplesmente indica o que fazer.  Sua fun√ß√£o √© especificar as condi√ß√µes ou requisitos para o conjunto de resultados que voc√™ deseja receber da consulta.  Voc√™ deixa a maneira como seus dados s√£o recuperados para os mecanismos internos que determinam a implementa√ß√£o da consulta: permite que o mecanismo de banco de dados determine os melhores algoritmos ou l√≥gica de processamento para executar sua consulta. <br><br>  Como o SQL √© baseado em conjunto, n√£o √© de surpreender que essa abordagem seja mais eficiente do que processual e tamb√©m explica por que, em alguns casos, o SQL pode executar mais r√°pido que o c√≥digo. <br><br>  <b>O aconselhamento √© uma</b> abordagem baseada em <b>conjuntos</b> para a consulta tamb√©m √© a que os empregadores mais importantes do setor de tecnologia da informa√ß√£o solicitar√£o que voc√™ domine!  Muitas vezes √© necess√°rio alternar entre esses dois tipos de abordagens. <br><br>  <b>Observe</b> que, se voc√™ precisar de uma solicita√ß√£o de procedimento, considere reescrev√™-la ou refator√°-la. <br><br>  A pr√≥xima parte abordar√° o plano e a otimiza√ß√£o de consultas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465547/">https://habr.com/ru/post/pt465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465535/index.html">Quem implementa o IPv6 e o ‚Äã‚Äãque dificulta o seu desenvolvimento</a></li>
<li><a href="../pt465537/index.html">Yandex: uma casa inteligente para adultos</a></li>
<li><a href="../pt465539/index.html">766 km - um novo recorde de alcance para o LoRaWAN</a></li>
<li><a href="../pt465541/index.html">Das empresas √†s pequenas e m√©dias empresas: compartilhamos nossa experi√™ncia na adapta√ß√£o de solu√ß√µes corporativas para pequenas e m√©dias empresas com monetiza√ß√£o usando o modelo SaaS</a></li>
<li><a href="../pt465545/index.html">Em diferentes lados do estado: como o Facebook foi frito no Congresso dos EUA, enquanto o Telegram lutou com o FSB</a></li>
<li><a href="../pt465551/index.html">Resumo dos eventos de TI de setembro (parte um)</a></li>
<li><a href="../pt465553/index.html">Linguagem de programa√ß√£o √ú. Introdu√ß√£o, motiva√ß√£o para criar, objetivos</a></li>
<li><a href="../pt465555/index.html">12 Soft Skills que tornam os gerentes de projeto de TI impar√°veis</a></li>
<li><a href="../pt465557/index.html">Prazos de Desenvolvimento de Produto</a></li>
<li><a href="../pt465561/index.html">O que aprendi com um programador l√≠der</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>