<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ üèáüèº ‚ò∏Ô∏è Index dans PostgreSQL - 10 (Bloom) üßìüèº üôå üêä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles pr√©c√©dents, nous avons discut√© du moteur d'indexation PostgreSQL et de l'interface des m√©thodes d'acc√®s, ainsi que des index de hach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 10 (Bloom)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452968/">  Dans les articles pr√©c√©dents, nous avons discut√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL et de l'interface des m√©thodes d'acc√®s, ainsi que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des index de hachage</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RUM</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BRIN</a> .  Mais nous devons encore examiner les indices Bloom. <br><br><h1>  Bloom </h1><br><h2>  Concept g√©n√©ral </h2><br>  Un filtre Bloom classique est une structure de donn√©es qui nous permet de v√©rifier rapidement l'appartenance d'un √©l√©ment √† un ensemble.  Le filtre est tr√®s compact, mais autorise les faux positifs: il peut √† tort consid√©rer un √©l√©ment comme membre d'un ensemble (faux positif), mais il n'est pas autoris√© de consid√©rer un √©l√©ment d'un ensemble comme n'√©tant pas membre (faux n√©gatif) . <br><br>  Le filtre est un tableau de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> m </script>  bits (√©galement appel√©s <em>signature</em> ) qui sont initialement remplis de z√©ros. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> k </script>  diff√©rentes fonctions de hachage sont choisies pour mapper n'importe quel √©l√©ment de l'ensemble sur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  morceaux de la signature.  Pour ajouter un √©l√©ment √† l'ensemble, nous devons d√©finir chacun de ces bits dans la signature.  Par cons√©quent, si tous les bits correspondant √† un √©l√©ment sont mis √† un, l'√©l√©ment peut √™tre membre de l'ensemble, mais si au moins un bit est √©gal √† z√©ro, l'√©l√©ment n'est pas dans l'ensemble √† coup s√ªr. <br><br>  Dans le cas d'un SGBD, nous avons en fait <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> N </script>  filtres s√©par√©s construits pour chaque ligne d'index.  En r√®gle g√©n√©rale, plusieurs champs sont inclus dans l'index, et ce sont les valeurs de ces champs qui composent l'ensemble d'√©l√©ments pour chaque ligne. <br><br>  En choisissant la longueur de la signature <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> m </script>  , nous pouvons trouver un compromis entre la taille de l'indice et la probabilit√© de faux positifs.  Le domaine d'application de l'index Bloom est de grandes tables significativement "larges" √† interroger √† l'aide de filtres sur chacun des champs.  Cette m√©thode d'acc√®s, comme BRIN, peut √™tre consid√©r√©e comme un acc√©l√©rateur de balayage s√©quentiel: toutes les correspondances trouv√©es par l'index doivent √™tre rev√©rifi√©es avec la table, mais il est possible d'√©viter de consid√©rer la plupart des lignes du tout. <br><a name="habracut"></a><br><h2>  La structure </h2><br>  Nous avons d√©j√† discut√© des arbres de signature dans le contexte de la m√©thode d'acc√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> .  Contrairement √† ces arbres, l'indice Bloom est une structure plate.  Il consiste en une m√©tapage suivie de pages r√©guli√®res avec des lignes d'index.  Chaque ligne d'index contient une signature et une r√©f√©rence √† une ligne de table (TID), comme illustr√© sch√©matiquement sur la figure. <br><br><img src="https://habrastorage.org/webt/tl/v3/xp/tlv3xpdlc4iw25iuma6yurx8wto.png"><br><br><h3>  Cr√©ation et choix des valeurs des param√®tres </h3><br>  Lors de la cr√©ation d'un index Bloom, une taille totale de la signature ("longueur") est sp√©cifi√©e, ainsi que le nombre de bits √† d√©finir <em>pour chaque champ individuel</em> inclus dans l'index ("col1" - "col32"): <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(...) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=..., col1=..., col2=..., ...);</code> </pre> <br>  La fa√ßon de sp√©cifier le nombre de bits semble √©trange: ces nombres doivent √™tre les param√®tres d'une classe d'op√©rateurs plut√¥t que l'index.  Le fait est que les classes d'op√©rateurs ne peuvent pas √™tre param√©tr√©es √† l'heure actuelle, bien que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail sur ce point</a> soit en cours. <br><br><blockquote>  Malheureusement, il n'y a plus de progr√®s √† ce sujet. <br></blockquote><br>  Comment choisir des valeurs adapt√©es?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La th√©orie</a> stipule que compte tenu de la probabilit√© <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> p </script>  d'un filtre pour retourner un faux positif, le nombre optimal de bits de signature peut √™tre estim√© comme <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">m</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">n</span><span class="MJXp-mtext" id="MJXp-Span-18">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">o</span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">p</span><span class="MJXp-mrow" id="MJXp-Span-25"><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mtext" id="MJXp-Span-27">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span><span class="MJXp-mn" id="MJXp-Span-30">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> m = ‚àín \ log_2 p / \ ln 2 </script>  , o√π <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> n </script>  est le nombre de champs dans l'index et le nombre de bits √† d√©finir est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">k</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mtext" id="MJXp-Span-37">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">o</span><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = - \ log_2 p </script>  . <br><br>  La signature est stock√©e √† l'int√©rieur de l'index sous la forme d'un tableau de nombres entiers √† deux octets, donc la valeur de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> m </script>  peut √™tre arrondi en toute s√©curit√© √† <math></math><img src="https://habrastorage.org/getpro/habr/formulas/ede/b88/0f9/edeb880f9f7b63330852174a59d9f35f.svg" alt="16 $" data-tex="inline">  . <br><br>  Lors du choix de la probabilit√© <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> p </script>  , nous devons tenir compte de la taille de l'indice, qui sera approximativement √©gale √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">m</span><span class="MJXp-mrow" id="MJXp-Span-51"><span class="MJXp-mo" id="MJXp-Span-52" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-53">8</span><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-55">6</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> (m / 8 + 6) N </script>  , o√π <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> N </script>  est le nombre de lignes du tableau et <math></math><img src="https://habrastorage.org/getpro/habr/formulas/a98/05b/342/a9805b3422e51c726fc4b1931f2d51aa.svg" alt="6 $" data-tex="inline">  est la taille du pointeur TID en octets. <br><br>  Quelques points √† noter: <br><br><ul><li>  La probabilit√© <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> p </script>  d'un faux positif se rapporte √† un filtre, par cons√©quent, nous nous attendons √† obtenir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> Np </script>  faux positifs lors de l'analyse de la table (bien s√ªr, pour une requ√™te qui renvoie peu de lignes).  Par exemple, pour une table avec un million de lignes et la probabilit√© 0,01, dans le plan de requ√™te, en moyenne, nous pouvons nous attendre √† "Lignes supprim√©es par recontr√¥le d'index: 10000". </li><li>  Le filtre Bloom est une structure probabiliste.  Il est logique de parler de nombres sp√©cifiques uniquement lorsque la moyenne d'un grand nombre de valeurs, alors que dans chaque cas particulier, nous pouvons obtenir tout ce que nous pouvons penser. </li><li>  Les estimations ci-dessus sont bas√©es sur un mod√®le math√©matique id√©alis√© et quelques hypoth√®ses.  En pratique, le r√©sultat risque d'√™tre pire.  Alors, ne surestimez pas les formules: elles ne sont qu'un moyen de choisir des valeurs initiales pour de futures exp√©riences. </li><li>  Pour chaque champ individuellement, la m√©thode d'acc√®s nous permet de choisir le nombre de bits √† r√©gler.  Il existe une hypoth√®se raisonnable selon laquelle le nombre optimal d√©pend en fait de la distribution des valeurs dans la colonne.  Pour approfondir la plong√©e, vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> (les r√©f√©rences √† d'autres recherches sont les bienvenues).  Mais relisez d'abord l'article pr√©c√©dent. </li></ul><br><h3>  Mise √† jour </h3><br>  Lorsqu'une nouvelle ligne est ins√©r√©e dans une table, une signature est cr√©√©e: pour les valeurs de tous les champs index√©s, tous leurs bits correspondants sont mis √† un.  En th√©orie, nous devons avoir k fonctions de hachage diff√©rentes, tandis qu'en pratique, le g√©n√©rateur de nombres pseudo-al√©atoires suffit, dont la graine est choisie √† chaque fois √† l'aide de la seule fonction de hachage. <br><br>  Un filtre Bloom standard ne prend pas en charge la suppression d'√©l√©ments, mais cela n'est pas requis pour l'index Bloom: lorsqu'une ligne de tableau est supprim√©e, la signature enti√®re est supprim√©e, ainsi que la ligne d'index. <br><br>  Comme d'habitude, une mise √† jour consiste √† supprimer la version de ligne obsol√®te et √† ins√©rer la nouvelle (la signature √©tant calcul√©e √† partir de z√©ro). <br><br><h3>  Num√©risation </h3><br>  √âtant donn√© que la seule chose que le filtre Bloom peut faire est de v√©rifier l'appartenance d'un √©l√©ment dans un ensemble, la seule op√©ration prise en charge par l'index Bloom est une v√©rification d'√©galit√© (comme dans l'index de hachage). <br><br>  Comme nous l'avons d√©j√† mentionn√©, l'indice Bloom est plat, donc au cours de l'acc√®s √† l'index, il est toujours lu successivement et enti√®rement.  Au cours de la lecture, un bitmap est construit, qui est ensuite utilis√© pour acc√©der √† la table. <br><br>  Dans un acc√®s √† un index normal, il est suppos√© que peu de lignes d'index devront √™tre lues et, en outre, elles peuvent √™tre bient√¥t √† nouveau n√©cessaires, par cons√©quent, elles sont stock√©es dans un cache tampon.  La lecture de l'index Bloom, cependant, est en r√©alit√© un balayage s√©quentiel.  Pour √©viter d'expulser des informations utiles hors du cache, la lecture se fait via un petit anneau tampon, exactement de la m√™me mani√®re que pour le scan s√©quentiel des tables. <br><br>  Il faut tenir compte du fait que plus la taille de l'indice Bloom est importante, moins il semblera attrayant pour le planificateur.  Cette d√©pendance est lin√©aire, contrairement aux index arborescents. <br><br><h2>  Exemple </h2><br><h3>  Table </h3><br>  Regardons l'indice Bloom par exemple d'une grande table "vols_bi" de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article pr√©c√©dent</a> .  Pour rappel, la taille de ce tableau est de 4 Go avec environ 30 millions de lignes.  D√©finition du tableau: <br><br><pre> <code class="pgsql hljs">demo=# \d flights_bi</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.flights_bi" Column | Type | Collation | Nullable | Default --------------------+--------------------------+-----------+----------+--------- airport_code | character(3) | | | airport_coord | point | | | airport_utc_offset | interval | | | flight_no | character(6) | | | flight_type | text | | | scheduled_time | timestamp with time zone | | | actual_time | timestamp with time zone | | | aircraft_code | character(3) | | | seat_no | character varying(4) | | | fare_conditions | character varying(10) | | | passenger_id | character varying(20) | | | passenger_name | text | | |</code> </pre><br>  Cr√©ons d'abord l'extension: bien que l'index Bloom soit inclus dans une livraison standard √† partir de la version 9.6, il n'est pas disponible par d√©faut. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> bloom;</code> </pre><br>  La derni√®re fois, nous avons pu indexer trois champs √† l'aide de BRIN ("horaire_programm√©", "heure_actuelle", "d√©calage_a√©roport").  √âtant donn√© que les index Bloom ne d√©pendent pas de l'ordre physique des donn√©es, essayons d'inclure presque tous les champs de la table dans l'index.  Excluons cependant les champs de temps ("horaire_programm√©" et "heure_r√©elle"): la m√©thode ne prend en charge que la comparaison pour l'√©galit√©, mais une requ√™te pour l'heure exacte n'est gu√®re int√©ressante pour personne (nous pourrions cependant construire l'index sur une expression, en arrondissant le √† un jour, mais nous ne le ferons pas).  Nous devrons √©galement exclure les coordonn√©es g√©ographiques des a√©roports ("airport_coord"): pour l'avenir, le type "point" n'est pas support√©. <br><br>  Pour choisir les valeurs des param√®tres, d√©finissons la probabilit√© d'un faux positif √† 0,01 (en gardant √† l'esprit que nous en obtiendrons plus).  Les formules ci-dessus pour <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">n</span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-68">9</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> n = 9 </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">N</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-72">30</span><span class="MJXp-mspace" id="MJXp-Span-73" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-74">000</span><span class="MJXp-mspace" id="MJXp-Span-75" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-76">000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N = 30 \, 000 \, 000 </script>  donner la taille de signature de 96 bits et sugg√©rer de d√©finir 7 bits par √©l√©ment.  La taille estim√©e de l'indice est de 515 Mo (environ un huiti√®me du tableau). <br><br>  (Avec une taille de signature minimale de 16 bits, les formules promettent une taille d'index deux fois plus petite, mais permettent de s'appuyer uniquement sur la probabilit√© de 0,5, ce qui est tr√®s faible.) <br><br><h3>  Classes d'op√©rateur </h3><br>  Essayons donc de cr√©er l'index. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type character has no default operator class for access method "bloom" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Malheureusement, l'extension ne nous fournit que deux classes d'op√©rateurs: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opcmethod = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'bloom'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcname | opcintype ----------+----------- int4_ops | integer text_ops | text (2 rows)</code> </pre><br>  Mais heureusement, il est assez facile de cr√©er des classes similaires pour d'autres types de donn√©es √©galement.  Une classe d'op√©rateur pour la m√©thode d'acc√®s Bloom doit contenir exactement un op√©rateur - √©galit√© - et exactement une fonction auxiliaire - hachage.  Le moyen le plus simple de trouver les op√©rateurs et les fonctions n√©cessaires pour un type arbitraire est de consulter le catalogue syst√®me pour les classes d'op√©rateurs de la m√©thode "hash": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, ampr.amproc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opclass opc, pg_amop amop, pg_amproc ampr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoprighttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amprocfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amproclefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcintype | amopopr | amproc -----------+----------------------+-------------- abstime | =(abstime,abstime) | hashint4 aclitem | =(aclitem,aclitem) | hash_aclitem anyarray | =(anyarray,anyarray) | hash_array anyenum | =(anyenum,anyenum) | hashenum anyrange | =(anyrange,anyrange) | hash_range ...</code> </pre><br>  Nous allons cr√©er deux classes manquantes √† l'aide de ces informations: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> character_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">character</span></span>,<span class="hljs-type"><span class="hljs-type">character</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> hashbpchar; demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> interval_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">interval</span></span>,<span class="hljs-type"><span class="hljs-type">interval</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> interval_hash;</code> </pre><br>  Une fonction de hachage n'est pas d√©finie pour les points (type "point"), et c'est pour cette raison que nous ne pouvons pas construire d'index Bloom sur un tel champ (tout comme nous ne pouvons pas effectuer de jointure de hachage sur des champs de ce type). <br><br>  R√©essayer: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">CREATE INDEX</code> </pre><br>  La taille de l'indice est de 526 Mo, ce qui est un peu plus grand que pr√©vu.  En effet, la formule ne prend pas en compte la surcharge de page. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_bloom'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 526 MB (1 row)</code> </pre><br><h3>  Requ√™tes </h3><br>  Nous pouvons maintenant effectuer une recherche en utilisant divers crit√®res, et l'index le supportera. <br><br>  Comme nous l'avons d√©j√† mentionn√©, le filtre Bloom est une structure probabiliste, par cons√©quent, l'efficacit√© d√©pend fortement de chaque cas particulier.  Par exemple, regardons les rang√©es relatives √† deux passagers, Miroslav Sidorov: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=2639.010..3010.692 rows=2 loops=1) Recheck Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Rows Removed by Index Recheck: 38562 Heap Blocks: exact=21726 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1065.191..1065.191 rows=38564 loops=1) Index Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Planning time: 0.109 ms Execution time: 3010.736 ms</code> </pre><br>  et Marfa Soloveva: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MARFA SOLOVEVA'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=9980.884..10142.684 rows=2 loops=1) Recheck Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Rows Removed by Index Recheck: 3950168 Heap Blocks: exact=45757 lossy=67332 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1037.588..1037.588 rows=212972 loops=1) Index Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Planning time: 0.157 ms Execution time: 10142.730 ms</code> </pre><br>  Dans un cas, le filtre n'a permis que 40 000 faux positifs et jusqu'√† 4 millions dans l'autre ("Rows Removed by Index Recheck").  Les temps d'ex√©cution des requ√™tes diff√®rent en cons√©quence. <br><br>  Et voici les r√©sultats de la recherche des m√™mes lignes par l'ID du passager plut√¥t que par son nom.  Miroslav: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) demo-# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=13747.305..16907.387 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '5864 006033'::text) Rows Removed by Index Recheck: 9620258 Heap Blocks: exact=50510 lossy=165722 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=937.202..937.202 rows=426474 loops=1) Index Cond: ((passenger_id)::text = '5864 006033'::text) Planning time: 0.110 ms Execution time: 16907.423 ms</code> </pre><br>  Et marfa: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'2461 559238'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=3881.615..3934.481 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '2461 559238'::text) Rows Removed by Index Recheck: 30669 Heap Blocks: exact=27513 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1084.391..1084.391 rows=30671 loops=1) Index Cond: ((passenger_id)::text = '2461 559238'::text) Planning time: 0.120 ms Execution time: 3934.517 ms</code> </pre><br>  Les rendements diff√®rent encore beaucoup, et cette fois Marfa a eu plus de chance. <br><br>  Notez que la recherche simultan√©e sur deux champs se fera beaucoup plus efficacement car la probabilit√© d'un faux positif <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-77"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> p </script>  se transforme en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-79"><span class="MJXp-msubsup" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-82" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> p ^ 2 </script>  : <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=872.593..877.915 rows=2 loops=1) Recheck Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Rows Removed by Index Recheck: 357 Heap Blocks: exact=356 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=832.041..832.041 rows=359 loops=1) Index Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Planning time: 0.524 ms Execution time: 877.967 ms</code> </pre><br>  Cependant, la recherche avec un bool√©en "ou" n'est pas du tout prise en charge;  il s'agit d'une limitation d'un planificateur plut√¥t que de la m√©thode d'acc√®s.  Bien s√ªr, il reste une option pour lire l'index deux fois, cr√©er deux bitmaps et les joindre, mais cela est probablement trop co√ªteux pour que ce plan soit choisi. <br><br><h2>  Comparaison avec BRIN et Hash </h2><br>  Les domaines d'application des indices Bloom et BRIN se croisent √©videmment.  Ce sont de grandes tables pour lesquelles il est souhaitable d'assurer la recherche par diff√©rents champs, la pr√©cision de recherche √©tant sacrifi√©e √† la compacit√©. <br><br>  Les index BRIN sont plus compacts (par exemple, jusqu'√† des dizaines de m√©gaoctets dans notre exemple) et peuvent prendre en charge la recherche par plage, mais ont une forte limitation li√©e √† l'ordre physique des donn√©es dans un fichier.  Les index Bloom sont plus grands (des centaines de m√©gaoctets), mais n'ont pas de limites, sauf la disponibilit√© d'une fonction de hachage appropri√©e. <br><br>  Comme les index Bloom, les index de hachage prennent en charge la seule op√©ration de v√©rification d'√©galit√©.  L'index de hachage garantit une pr√©cision de recherche inaccessible pour Bloom, mais la taille de l'index est beaucoup plus grande (dans notre exemple, un gigaoctet pour un seul champ et un index de hachage ne peut pas √™tre cr√©√© sur plusieurs champs). <br><br><h2>  Propri√©t√©s </h2><br>  Comme d'habitude, regardons les propri√©t√©s de Bloom (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont d√©j√† √©t√© fournies</a> ). <br><br>  Voici les propri√©t√©s de la m√©thode d'acc√®s: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- bloom | can_order | f bloom | can_unique | f bloom | can_multi_col | t bloom | can_exclude | f</code> </pre><br>  Evidemment, la m√©thode d'acc√®s nous permet de construire un index sur plusieurs colonnes.  Cela n'a gu√®re de sens de cr√©er un indice Bloom sur une colonne. <br><br>  Les propri√©t√©s de couche d'index suivantes sont disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  La seule technique de scan disponible est le scan bitmap.  √âtant donn√© que l'index est toujours enti√®rement analys√©, il n'est pas logique d'impl√©menter un acc√®s d'index r√©gulier qui renvoie les lignes TID par TID. <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Seuls les tirets sont ici;  la m√©thode ne peut m√™me pas manipuler les valeurs NULL. <br><br><h2>  Et enfin: </h2><br>  Il n'est pas impossible que cette s√©rie d'articles se poursuive √† l'avenir, lorsque de nouveaux types d'indices d'int√©r√™t apparaissent, mais il est temps de s'arr√™ter maintenant. <br><br>  Je voudrais exprimer ma gratitude √† mes coll√®gues de Postgres Professional (certains d'entre eux sont les auteurs de nombreuses m√©thodes d'acc√®s discut√©es) pour avoir lu les √©bauches et fourni leurs commentaires.  Et je vous suis certainement reconnaissant de votre patience et de vos pr√©cieux commentaires.  Votre attention m'a encourag√© √† en arriver l√†.  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452968/">https://habr.com/ru/post/fr452968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452958/index.html">JMAP - un protocole ouvert remplace IMAP lors de l'√©change de courriels</a></li>
<li><a href="../fr452960/index.html">Vous r√©pondrez de tout! Contrats ax√©s sur le consommateur √† travers les yeux du d√©veloppeur</a></li>
<li><a href="../fr452962/index.html">La principale cause d'accidents dans les centres de donn√©es est la pose entre l'ordinateur et le fauteuil</a></li>
<li><a href="../fr452964/index.html">Une explication abordable de l'hypoth√®se de Riemann</a></li>
<li><a href="../fr452966/index.html">Le mythe de la pleine conscience: une vision ¬´neurocentrique¬ª de la m√©ditation</a></li>
<li><a href="../fr452974/index.html">Programmation asynchrone (cours complet)</a></li>
<li><a href="../fr452978/index.html">ok.tech: Explication des donn√©es</a></li>
<li><a href="../fr452980/index.html">AWP KBR-N - Le jour X arrivera bient√¥t, qui ne s'est pas pr√©par√© √† bl√¢mer</a></li>
<li><a href="../fr452982/index.html">Int√©gration simple de MS Project et Redmine</a></li>
<li><a href="../fr452984/index.html">Arduino et framboise interdits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>