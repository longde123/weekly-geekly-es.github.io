<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 👩🏽‍🚒 🙇🏾 阿波罗：9个月-正常飞行 🛋️ 🧚🏽 📶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，我叫Semyon Levenson，我是Rambler Group的Stream项目的团队负责人，我想谈谈我们在Apollo的经历。 


 我将解释什么是“流”。 这是一项针对企业家的自动化服务，可让您在不参与广告的情况下将客户从Internet吸引到您的企业，并快速创建简单的网站而无需成...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>阿波罗：9个月-正常飞行</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rambler-co/blog/418417/"><p><img src="https://habrastorage.org/webt/ww/0p/je/ww0pjeoegdfxhlx-zfh54jbxvyw.png" alt="图片"></p><br><p> 大家好，我叫Semyon Levenson，我是Rambler Group的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stream</a>项目的团队负责人，我想谈谈我们在Apollo的经历。 </p><br><p> 我将解释什么是“流”。 这是一项针对企业家的自动化服务，可让您在不参与广告的情况下将客户从Internet吸引到您的企业，并快速创建简单的网站而无需成为布局专家。 </p><a name="habracut"></a><br><p> 屏幕截图显示了创建登录页面的步骤之一。 </p><br><p><img src="https://habrastorage.org/webt/rf/vg/dj/rfvgdjmcvzpwydgz9qcdu8_3eay.png"></p><br><h3 id="chto-bylo-vnachale"> 是什么开始的？ </h3><br><p>最初有MVP，很多Twig，jQuery和非常紧迫的截止日期。 但是我们采用了非标准的方式，并决定进行重新设计。 重新设计不是“修补样式”的意思，而是决定完全审查该系统。 对于组装完美的前端，这对我们来说是一个很好的阶段。 毕竟，我们的开发团队应继续为此提供支持，并在此基础上执行其他任务，以实现产品团队设定的新目标。 </p><br><p> 我们的部门已经在使用React方面积累了足够的专业知识。 我不想花两个星期来设置webpack，所以我决定使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRA</a> （创建React应用）。 对于样式，使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样式化的组件</a> ，而在没有键入的地方使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flow</a> 。 他们选择<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux</a>进行状态管理，但结果证明我们根本不需要它，但稍后再介绍。 </p><br><p> 我们汇集了完美的前端，并意识到我们忘记了一些东西。 事实证明，我们忘记了后端，或者忘记了与后端的交互。 当您考虑到我们可以用来组织这种互动的内容时，首先想到的是-Rest。 不，我们没有休息（微笑），而是开始谈论RESTful API。 从原则上讲，这个故事很熟悉，可以延续很长时间，但是我们也知道它存在的问题。 我们将讨论它们。 </p><br><p> 第一个问题是文档。  RESTful当然没有说明如何组织文档。 这里可以选择使用相同的选项，但实际上这是引入了一个额外的实体，并使过程变得复杂。 </p><br><p> 第二个问题是如何组织对API版本的支持。 </p><br><p> 第三个重要问题是我们可以奖励的大量查询或自定义端点。 假设我们需要为这些帖子请求帖子-评论以及这些评论的更多作者。 在经典的Rest中，我们必须至少进行3个查询。 是的，我们可以奖励自定义端点，并且所有这些都可以减少到1个请求，但这已经很复杂了。 </p><br><p><img src="https://habrastorage.org/webt/mo/os/uv/moosuvdayfwhr7r2dqswlg9nuuk.png"><br>  <em>谢谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sashko Stubailo</a>的插图<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a></em> </p><br><h3 id="reshenie"> 解决方案 </h3><br><p> 目前，Facebook通过GraphQL帮助我们。 什么是GraphQL？ 这是一个平台，但是今天我们将看一下其中的一部分-这是用于您的API的查询语言，只是一种语言，并且是一种非常原始的语言。 它的工作尽可能简单-当我们请求某种实体时，我们也会得到它。 </p><br><p> 要求： </p><br><pre><code class="hljs objectivec">{ me { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> isAcceptedFreeOffer balance } }</code> </pre> <br><p> 答案是： </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"me"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"balance"</span></span>: <span class="hljs-number"><span class="hljs-number">100000</span></span> } }</code> </pre> <br><p> 但是GraphQL不仅与读取有关，还与更改数据有关。 为此，GraphQL中存在突变。 突变是值得注意的，因为我们可以通过成功的更改从后端声明所需的响应。 但是，有一些细微差别。 例如，如果我们的突变影响了图范围之外的数据。 </p><br><p> 我们使用免费优惠的一个变异示例： </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">mutation</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">acceptOffer</span></span> (_type: FREE) { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> isAcceptedFreeOffer } }</code> </pre> <br><p> 作为回应，我们得到了与请求相同的结构 </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"acceptOffer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p> 可以使用常规提取与GraphQL后端进行交互。 </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, body: <span class="hljs-type"><span class="hljs-type">JSON</span></span>.stringify({ query: <span class="hljs-string"><span class="hljs-string">'{me { id balance } }'</span></span> }) });</code> </pre> <br><h3 id="kakie-zhe-plyusy-u-graphql">  GraphQL有哪些优势？ </h3><br><p> 当您开始使用它时，首先要意识到的一点就是它是强类型化的并且具有自记录功能。 通过在服务器上设计GraphQL模式，我们可以直接在代码中立即描述类型和属性。 </p><br><p><img src="https://habrastorage.org/webt/7l/oh/ze/7lohze1ioujv7qchctics80_qd8.png"></p><br><p> 如上所述，RESTful存在版本控制问题。  GraphQL为此实现了一个非常优雅的解决方案-已弃用。 </p><br><p><img src="https://habrastorage.org/webt/zr/la/rr/zrlarrevkaenkyjdx7yzm6wbm5a.png"></p><br><p> 假设我们有一部电影，我们扩大了它，所以我们有一个导演。 在某些时候，我们只是将导演设为单独的类型。 问题是，如何处理最后一个导演字段？ 对此有两个答案：要么删除此字段，要么将其标记为已弃用，然后它自动从文档中消失。 </p><br><p> 我们独立决定需要什么。 </p><br><p> 我们回想起上一张图片，其中所有内容都与REST一起使用，但是在这里，所有内容都组合到一个请求中，不需要后端开发进行任何自定义。 一旦他们都描述了它，我们就扭曲，扭曲，变戏法。 </p><br><p><img src="https://habrastorage.org/webt/k2/rs/rp/k2rsrp234e3xoe6gs8jmwpy1rse.png"></p><br><p> 但不是没有美中不足的地方。 原则上，GraphQL在前端没有太多缺点，因为它最初是为解决前端问题而开发的。 但是后端运行得不太顺利...它们有类似N + 1的问题。 以查询为例： </p><br><pre> <code class="hljs objectivec">{ landings(_page: <span class="hljs-number"><span class="hljs-number">0</span></span>, limit: <span class="hljs-number"><span class="hljs-number">20</span></span>) { nodes { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> title } totalCount } }</code> </pre> <br><p> 一个简单的请求，我们请求20个站点以及我们拥有的站点数。 在后端，这可以变成21个数据库查询。 这个问题是已知的，已经解决。 对于Node JS，有来自Facebook的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dataloader</a>软件包。 对于其他语言，您可以找到自己的解决方案。 </p><br><p> 还存在深度嵌套的问题。 例如，我们有专辑，这些专辑有歌曲，通过歌曲我们也可以获取专辑。 为此，请进行以下查询： </p><br><pre> <code class="hljs objectivec">{ album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { title artists } } }</code> </pre> <br><pre> <code class="hljs dos">{ song(id: <span class="hljs-number"><span class="hljs-number">1337</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> album { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br><p> 因此，我们得到了一个递归查询，这也为我们奠定了基础。 </p><br><pre> <code class="hljs objectivec">query evil { album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { album { songs { album {</code> </pre> <br><p> 这个问题也是众所周知的，Node JS的解决方案是GraphQL深度限制，对于其他语言也有解决方案。 </p><br><p> 因此，我们决定使用GraphQL。 现在是时候选择适用于GraphQL API的库了。 上面显示的几行带有访存的示例只是一个传输。 但是，由于该方案和声明性，我们还可以在前端缓存查询，并通过GraphQL后端以更高的性能工作。 </p><br><p> 因此，我们有两个主要参与者-Relay和Apollo。 </p><br><h3 id="relay"> 接力赛 </h3><br><p>  Relay是Facebook开发的，他们自己使用。 像Oculus，Circle CI，Arsti和Friday。 </p><br><h4 id="kakie-plyusy-est-u-relay">  Relay的优点是什么？ </h4><br><p> 直接的好处是开发人员是Facebook。  React，Flow和GraphQL是Facebook的发展，所有这些都是彼此量身定制的拼图游戏。 我们在Github上没有星星的地方，Relay有将近11,000，Apollo有7600可以比较。 。 我们可以假设这仅适用于GraphQL： </p><br><pre> <code class="hljs scala">#  <span class="hljs-type"><span class="hljs-type">Relay</span></span>-compiler foo { # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span></span>{ # matches the parent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extraneous</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">#</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span></span>{ id }</code> </pre> <br><h4 id="kakie-minusy-u-relay"> 中继的缺点是什么？ </h4><br><p> 首先要减去的*是缺少SSR。  Github尚有一个未<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解决的问题</a> 。 为什么在星号下-因为已经有解决方案，但是它们是第三方的，而且还很模棱两可。 </p><br><p><img src="https://habrastorage.org/webt/ee/1b/rc/ee1brchbmmgdpqka4kpf3ogo2my.png"></p><br><p> 同样，中继是一个规范。 事实是GraphQL已经是一个规范，而Relay是一个规范之上的规范。 </p><br><p><img src="https://habrastorage.org/webt/f6/ds/nl/f6dsnlwzog77hrwpboaru95u7_y.png"></p><br><p> 例如，中继分页的实现方式有所不同，光标出现在此处。 </p><br><pre> <code class="hljs pgsql">{ friends(first: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">after</span></span>: "opaqueCursor") { edges { <span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> node { id <span class="hljs-type"><span class="hljs-type">name</span></span> } } pageInfo { hasNextPage } } }</code> </pre> <br><p> 我们不再使用通常的偏移量和限制。 对于提要中的提要，这是一个很棒的话题，但是当我们开始做各种网格时，就会感到痛苦。 </p><br><p>  Facebook通过为React编写一个库解决了这个问题。 还有针对vue.js的其他库的解决方案，例如-vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-relay</a> 。 但是，如果我们注意恒星和commit-s的数量，那么在这里也不是所有事物都那么平滑且不稳定。 例如，在CRA框外创建Create React App会阻止您使用中继编译器。 但是您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-app-rewired</a>来解决此限制。 </p><br><p><img src="https://habrastorage.org/webt/dj/wb/i2/djwbi2it6brz4qxdipg0wcdyhpa.png"></p><br><h2 id="apollo"> 阿波罗 </h2><br><p> 我们的第二个候选人是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阿波罗</a> 。 由他的团队<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Meteor</a>开发。  Apollo使用诸如AirBnB，ticketmaster，Opentable等著名命令。 </p><br><h3 id="kakie-est-plyusy-u-apollo"> 阿波罗有什么优势？ </h3><br><p> 第一个重要的优点是Apollo被开发为框架不可知的库。 例如，如果我们现在想在Angular上重写所有内容，那么这将不是问题，Apollo可以解决此问题。 您甚至可以用Vanilla编写所有内容。 </p><br><p> 阿波罗（Apollo）有很不错的文档，有针对常见问题的现成解决方案。 </p><br><p><img src="https://habrastorage.org/webt/tq/wu/ko/tqwukoydh-b7fem6dwusyuwklgw.png"></p><br><p> 另一个优点是Apollo-功能强大的API。 原则上，与Redux一起工作的人会在这里找到常用的方法：有ApolloProvider（例如Provux for Redux），而不是Apollo的商店，它称为客户端： </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloProvider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ApolloClient'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">client</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{ApolloClient}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><p> 在组件本身的级别，我们提供了graphql HOC作为连接。 并且我们已经在其中编写了GraphQL查询，例如Redux中的MapStateToProps。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { graphql } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gql <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Landing } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Landing'</span></span>; graphql(gql<span class="hljs-string"><span class="hljs-string">` { landing(id: 1) { id title } } `</span></span>)(Landing);</code> </pre> <br><p> 但是，当我们在Redux中执行MapStateToProps时，我们会拾取本地数据。 如果没有本地数据，则Apollo本身会向服务器发送数据。 非常方便道具属于组件本身。 </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ data, loading, error, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 这是： <br>  •数据； <br>  •下载状态； <br>  •错误（如果发生）； <br> 辅助功能，例如refetch重新加载数据或fetchMore进行分页。  Apollo和Relay都有一个巨大的优势，那就是Optimistic UI。 它允许您在请求级别提交撤消/重做： </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.setNotificationStatusMutation({ variables: { … }, optimisticResponse: { … } });</code> </pre> <br><p> 例如，用户单击“喜欢”按钮，“喜欢”立即计数。 在这种情况下，对服务器的请求将在后台发送。 如果在发送过程中发生一些错误，则可变数据将自行返回其原始状态。 </p><br><p> 服务器端渲染实现良好，我们在客户端上设置了一个标志，一切就绪。 </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ApolloClient</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">ssrMode</span></span>: true, ... });</code> </pre> <br><p> 但是在这里我想谈谈初始状态。 当阿波罗自己烹饪时，一切都很好。 </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = client.extract(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p> 但是我们没有服务器端渲染，后端将特定的GraphQL查询推送到全局变量中。 在这里，您需要一个小拐杖，您需要编写一个Transform函数，后端的GraphQL响应已经变成了Apollo所需的格式。 </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = transform({…}); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Apollo的另一个优点是可以很好地自定义。 我们都记得Redux的中间件，这里的一切都是一样的，仅此称为链接。 </p><br><p><img src="https://habrastorage.org/webt/va/gw/-z/vagw-zeeg2j0t7pjuawtw4tllq8.png"></p><br><p> 我想分别说明两个链接： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apollo-link-state</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apollo-link-rest</a> ，如果我们想将GraphQL查询写入Rest API，则需要在不存在Redux的情况下存储本地状态。 但是，对于后者，您需要非常小心，因为 可能会出现某些问题。 </p><br><h4 id="minusy-u-apollo-tozhe-est"> 阿波罗也有缺点 </h4><br><p> 让我们来看一个例子。 出现了意外的性能问题：在前端（这是一个目录）上请求了2,000个项目，并且开始出现性能问题。 在调试器中查看它之后，原来是Apollo在读取时吞噬了很多资源，该问题基本上已经解决，现在一切都很好，但是有这样的缺点。 </p><br><p> 而且，结果却非常明显。 </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ loading, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 此外，似乎在执行数据重新请求时，如果先前的请求以错误结束，则加载应该变为true。 但是不！ </p><br><p> 为此，您需要在graphql HOC中指定notifyOnNetworkStatusChange：true，或在本地存储重新获取状态。 </p><br><h3 id="apollo-vs-relay"> 阿波罗vs. 接力赛 </h3><br><p> 因此，我们得到了这样一张桌子，我们都进行了称重，计数，并且落后阿波罗76％。 </p><br><p><img src="https://habrastorage.org/webt/ry/if/wx/ryifwxtkdmb4yvc2xczme5xoqkc.png"></p><br><p> 因此，我们选择了图书馆并开始工作。 </p><br><p> 但是我想对工具链说更多。 </p><br><p> 这里的一切都非常好，有一些供编辑者使用的插件，无论是更好的地方还是坏的地方。 还有一个apollo-codegen，它生成有用的文件，例如流类型，并基本上从GraphQL API中提取模式。 </p><br><h3 id="rubrika-ochumelye-ruchki-ili-chto-my-sdelali-u-sebya"> 标题为“疯狂的手”或我们在家做的事情 </h3><br><p> 我们遇到的第一件事是，我们基本上需要以某种方式请求数据。 </p><br><pre> <code class="hljs lisp">graphql(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>)(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p> 我们有共同的条件：加载，错误处理。 我们编写了自己的鹰（asyncCard），该鹰通过graqhql和asyncCard组成。 </p><br><pre> <code class="hljs lisp">compose( <span class="hljs-name"><span class="hljs-name">graphql</span></span>(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>), AsyncCard )(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p> 我也想谈谈片段。 有一个LandingItem组件，它从GraphQL API知道需要什么数据。 我们设置fragment属性，在该属性中，我们指定了Landing实体的字段。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); LandingItem.fragment = gql<span class="hljs-string"><span class="hljs-string">` fragment LandingItem on Landing { ... } `</span></span>;</code> </pre> <br><p> 现在，在组件使用级别，我们在最终请求中使用其片段。 </p><br><pre> <code class="hljs bash">query LandingsDashboard { landings(...) { nodes { ...LandingItem } totalCount } <span class="hljs-variable"><span class="hljs-variable">${LandingItem.Fragment}</span></span> }</code> </pre> <br><p> 假设有一项任务可以完成，以向此目标网页添加状态-这不是问题。 我们向渲染器和片段添加一个属性。 一切准备就绪。 单一责任原则的所有荣耀。 </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStatus</span></span></span></span><span class="xml"><span class="hljs-tag"> … /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); LandingItem.fragment = gql` fragment LandingItem on Landing { ... status } `;</span></span></code> </pre> <br><h4 id="kakaya-u-nas-esche-byla-problema"> 我们还有什么其他问题？ </h4><br><p> 我们网站上有许多小部件，它们发出了各自的请求。 </p><br><p><img src="https://habrastorage.org/webt/ab/li/-x/abli-xjzcmoq9_p2rtnorl-y3qu.png"></p><br><p> 在测试过程中，事实证明所有这些都会变慢。 我们的安全检查时间很长，每个请求的费用都很高。 原来也没问题，有Apollo-link-batch-http </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BatchHttpLink</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">batchMax</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, batchInterval: <span class="hljs-number"><span class="hljs-number">10</span></span> });</code> </pre> <br><p> 它的配置如下：我们传递可以合并的请求数，以及第一个请求出现后此链接将等待多长时间。 <br> 结果是这样的：同时加载所有内容，同时同时加载所有内容。 值得注意的是，如果在此合并过程中任何子查询返回错误，则该错误将仅与他有关，而不与整个请求有关。 </p><br><h4 id="hochetsya-otdelno-rasskazat-chto-proshloy-osenyu-proizoshlo-obnovlenie-s-pervogo-apollo-na-vtoroy"> 我想分别告诉大家，去年秋天，从第一个阿波罗到第二个 </h4><br><p> 一开始是阿波罗和雷德克斯 </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span></code> </pre> <br><p> 然后，Apollo变得更加模块化和可扩展，这些模块可以独立开发。 相同的阿波罗缓存内存。 </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-client'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-link-batch-http'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-cache-inmemory'</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span></code> </pre> <br><p> 值得注意的是，不需要Redux，事实证明，原则上不需要Redux。 </p><br><h2 id="vyvody"> 结论： </h2><br><ol><li> 功能交付时间减少了，我们不会浪费时间描述操作，减少了Redux，并减少了后端的接触 </li><li> 出现抗脆弱性是因为 通过API的静态分析，您可以在前端需要一件事而后端返回完全不同的问题时消除问题。 </li><li> 如果您开始使用GraphQL-试试Apollo，请不要失望。 </li></ol><br><p> 附注：您也可以在Rambler Front＆Meet up＃4上观看我的演讲中的视频 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rCEoy-V3x8k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418417/">https://habr.com/ru/post/zh-CN418417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418403/index.html">FPGA加速器编程示例</a></li>
<li><a href="../zh-CN418405/index.html">分析中倒金字塔的原理。 我们建立一个易于理解的仪表板</a></li>
<li><a href="../zh-CN418407/index.html">Hashflare云采矿已关闭。 钱不回来</a></li>
<li><a href="../zh-CN418411/index.html">Node.js上的浏览器网络射击</a></li>
<li><a href="../zh-CN418415/index.html">Telegram推出了自己的Passport服务，用于用户验证和授权</a></li>
<li><a href="../zh-CN418419/index.html">渡渡鸟披萨如何使用机器学习解决业务问题</a></li>
<li><a href="../zh-CN418423/index.html">智能家居：舒适和追求卓越的新维度。 第一部分</a></li>
<li><a href="../zh-CN418427/index.html">移动优先索引。 链接图如何以及为什么会改变？</a></li>
<li><a href="../zh-CN418429/index.html">我在欧洲从事敏捷教练的工作经验，第二部分</a></li>
<li><a href="../zh-CN418431/index.html">想象中的问题-不良软件的根源</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>