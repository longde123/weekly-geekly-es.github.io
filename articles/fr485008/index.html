<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏾 👩🏼‍🤝‍👨🏽 🧝🏾 Encapsuleurs de propriétés Swift 👐🏻 👩🏿‍🤝‍👨🏼 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous avez utilisé SwiftUI, vous avez probablement fait attention aux mots clés tels que @ObservedObject, @EnvironmentObject, @FetchRequest et ainsi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsuleurs de propriétés Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/485008/"><p>  Si vous avez utilisé SwiftUI, vous avez probablement fait attention aux mots clés tels que @ObservedObject, @EnvironmentObject, @FetchRequest et ainsi de suite.  Les wrappers de propriété (ci-après dénommés «wrappers de propriété») est une nouvelle fonctionnalité de Swift 5.1.  Cet article vous aidera à comprendre d'où viennent toutes les constructions de @, comment les utiliser dans SwiftUI et dans vos projets. </p><br><img src="https://habrastorage.org/webt/vp/5r/4c/vp5r4ct4rymlk9mzxdlvkb73uqe.jpeg"><br><p>  <em>Traduit par: Evgeny Zavozhansky, développeur de FunCorp.</em> </p><br><p>  <em>Remarque:</em> Au moment où la traduction a été préparée, une partie du code source de l'article d'origine avait perdu sa pertinence en raison de changements dans la langue, donc certains exemples de code ont été intentionnellement remplacés. <a name="habracut"></a></p><br><p> Les wrappers de propriétés ont été introduits pour la première fois sur les forums <a href="https://forums.swift.org/t/pitch-property-delegates/21895" title="Rapide">Swift</a> en mars 2019, quelques mois avant l'annonce de SwiftUI.  Dans sa proposition originale, Douglas Gregor, membre de l'équipe Swift Core, décrivait cette construction (alors appelée délégués de propriété) comme «une généralisation accessible aux utilisateurs des fonctionnalités actuellement fournies par une construction de langage telle que <code>lazy</code> , par exemple». </p><br><p>  Si une propriété est déclarée avec le mot-clé <code>lazy</code> , cela signifie qu'elle sera initialisée lors du premier accès.  Par exemple, l'initialisation différée d'une propriété peut être implémentée à l'aide d'une propriété privée, accessible via une propriété calculée.  Mais l'utilisation du mot-clé <code>lazy</code> rend cela beaucoup plus facile. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Structure</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//      lazy    lazy var deferred = …    //            private var _deferred: Type?    var deferred: Type {        get {            if let value = _deferred { return value }            let initialValue = …            _deferred = initialValue            return initialValue        }        set {            _deferred = newValue        }    } }</span></span></code> </pre> <br><p>  <a href="" title="SE-0258: Enveloppeurs de propriétés">SE-0258: Property Wrapper</a> explique parfaitement la conception et la mise en œuvre des wrappers de propriété.  Par conséquent, au lieu d'essayer d'améliorer la description dans la documentation officielle, considérez quelques exemples qui peuvent être implémentés à l'aide de wrappers de propriétés: </p><br><ul><li>  restriction de la valeur des propriétés; <br></li><li>  conversion de valeurs lors du changement de propriétés; <br></li><li>  changer la sémantique de l'égalité et comparer les propriétés; <br></li><li>  enregistrement de l'accès à la propriété. <br></li></ul><br><h2>  Limiter les valeurs de propriété </h2><br><p>  <a href="" title="SE-0258">SE-0258: Property Wrapper</a> fournit plusieurs exemples pratiques, notamment <code>@Clamping</code> , <code>@Copying</code> , <code>@Atomic</code> , <code>@ThreadSpecific</code> , <code>@Box</code> , <code>@UserDefault</code> .  Considérez le wrapper <code>@Clamping</code> , qui vous permet de limiter la valeur maximale ou minimale d'une propriété. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clamping</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&gt; </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> range: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt;) {        <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(range.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(value))        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.range = range    }    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(range.lowerBound, newValue), range.upperBound) }    } }</code> </pre> <br><p>  <code>@Clamping</code> peut être utilisé, par exemple, pour modéliser l'acidité d'une solution, dont la valeur peut prendre une valeur de 0 à 14. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Solution</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pH: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">7.0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carbonicAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: <span class="hljs-number"><span class="hljs-number">4.68</span></span>)</code> </pre> <br><p>  Si vous tentez de définir la valeur du pH au-delà de la plage de <code>(0...14)</code> , la propriété prendra la valeur la plus proche de l'intervalle minimum ou maximum. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> superDuperAcid = <span class="hljs-type"><span class="hljs-type">Solution</span></span>(pH: -<span class="hljs-number"><span class="hljs-number">1</span></span>) superDuperAcid.pH <span class="hljs-comment"><span class="hljs-comment">// 0</span></span></code> </pre> <br><p>  Les wrappers de propriété peuvent être utilisés pour implémenter d'autres wrappers de propriété.  Par exemple, le wrapper <code>@UnitInterval</code> limite la valeur d'une propriété à l'intervalle <code>(0...1)</code> aide de <code>@Clamping(0...1)</code> : </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitInterval</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FloatingPoint</span></span></span><span class="hljs-class">&gt; </span></span>{    @<span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">Value</span></span> = .zero    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = value    } }</code> </pre> <br><h3>  Idées similaires </h3><br><ul><li>  <code>@Positive</code> / <code>@NonNegative</code> indique que la valeur peut être un nombre positif ou négatif. </li><li>  <code>@NonZero</code> indique que la valeur de la propriété ne peut pas être 0. </li><li>  <code>@Validated</code> ou <code>@Whitelisted</code> / <code>@Blacklisted</code> restreint la valeur d'une propriété à certaines valeurs. </li></ul><br><h2>  Conversion de valeurs lors de la modification des propriétés </h2><br><p>  La validation des valeurs des champs de texte est un casse-tête constant pour les développeurs d'applications.  Il y a tellement de choses à garder à l'esprit: des platitudes telles que l'encodage aux tentatives malveillantes d'entrer un code via un champ de texte.  Envisagez d'utiliser un wrapper de propriété pour supprimer les espaces qu'un utilisateur a saisis au début et à la fin d'une ligne. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation let url = URL(string: " https:<span class="hljs-comment"><span class="hljs-comment">//habrahabr.ru") // nil let date = ISO8601DateFormatter().date(from: " 2019-06-24") // nil let words = " Hello, world!".components(separatedBy: .whitespaces) words.count // 3</span></span></code> </pre> <br><p>  <code>Foundation</code> propose la méthode <code>trimmingCharacters(in:)</code> , avec laquelle vous pouvez supprimer des espaces au début et à la fin d'une ligne.  Vous pouvez appeler cette méthode chaque fois que vous avez besoin de garantir l'exactitude de l'entrée, mais ce n'est pas très pratique.  Vous pouvez utiliser le wrapper de propriété pour cela. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Trimmed {    private(set) var value: String = ""    var wrappedValue: String {        get { return value }        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }    }    init(initialValue: String) {        self.wrappedValue = initialValue    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span>    @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quine = <span class="hljs-type"><span class="hljs-type">Post</span></span>(title: <span class="hljs-string"><span class="hljs-string">" Swift Property Wrappers "</span></span>, body: <span class="hljs-string"><span class="hljs-string">"…"</span></span>) quine.title <span class="hljs-comment"><span class="hljs-comment">// "Swift Property Wrappers" —        quine.title = "   @propertyWrapper " // "@propertyWrapper"</span></span></code> </pre> <br><h3>  Idées similaires </h3><br><ul><li>  <code>@Transformed</code> applique la <a href="https://developer.apple.com/documentation/foundation/nsstring/1407787-applyingtransform" title="Conversion ICU">conversion ICU</a> à la chaîne d' <code>@Transformed</code> . </li><li>  <code>@Rounded</code> / <code>@Truncated</code> arrondit ou tronque une valeur de chaîne. </li></ul><br><h2>  Changer la sémantique de l'égalité et la comparaison des propriétés </h2><br><p>  Dans Swift, deux chaînes sont égales si elles sont <a href="https://unicode.org/reports/tr15/" title="canoniquement équivalent">canoniquement équivalentes</a> , c'est-à-dire  contiennent les mêmes caractères.  Mais supposons que nous voulons que les propriétés de chaîne soient égales, et non sensibles à la casse, qu'elles contiennent. </p><br><p>  <code>@CaseInsensitive</code> implémente un wrapper pour les propriétés de type <code>String</code> ou <code>SubString</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct CaseInsensitive&lt;Value: StringProtocol&gt; {    var wrappedValue: Value } extension CaseInsensitive: Comparable {    private func compare(_ other: CaseInsensitive) -&gt; ComparisonResult {        wrappedValue.caseInsensitiveCompare(other.wrappedValue)    }    static func == (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedSame    }    static func &lt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedAscending    }    static func &gt; (lhs: CaseInsensitive, rhs: CaseInsensitive) -&gt; Bool {        lhs.compare(rhs) == .orderedDescending    } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hello: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">HELLO</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"HELLO"</span></span> hello == <span class="hljs-type"><span class="hljs-type">HELLO</span></span> <span class="hljs-comment"><span class="hljs-comment">// false CaseInsensitive(wrappedValue: hello) == CaseInsensitive(wrappedValue: HELLO) // true</span></span></code> </pre> <br><h3>  Idées similaires </h3><br><ul><li>  <code>@Approximate</code> pour une comparaison grossière des propriétés de type Double ou Float. </li><li>  <code>@Ranked</code> pour les propriétés dont les valeurs sont en ordre (par exemple, le rang des cartes à jouer). </li></ul><br><h2>  Journalisation de l'accès aux propriétés </h2><br><p>  <code>@Versioned</code> vous permettra d'intercepter les valeurs attribuées et de vous rappeler quand elles ont été définies. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation @propertyWrapper struct Versioned&lt;Value&gt; {    private var value: Value    private(set) var timestampedValues: [(Date, Value)] = []    var wrappedValue: Value {        get { value }        set {            defer { timestampedValues.append((Date(), value)) }            value = newValue        }    }    init(initialValue value: Value) {        self.wrappedValue = value    } }</code> </pre> <br><p>  La classe <code>ExpenseReport</code> permet d'enregistrer les horodatages des états de traitement du rapport de dépenses. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> submitted, received, approved, denied }    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted }</code> </pre> <br><p>  Mais l'exemple ci-dessus montre une sérieuse limitation dans l'implémentation actuelle des wrappers de propriétés, qui découle de la restriction Swift: les propriétés ne peuvent pas lever d'exceptions.  Si nous voulions ajouter une restriction à <code>@Versioned</code> pour empêcher la valeur de <code>.approved</code> après avoir pris la valeur <code>.denied</code> , alors la meilleure option est <code>fatalError()</code> , qui ne convient pas aux applications réelles. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpenseReport</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Versioned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span> = .submitted {        <span class="hljs-keyword"><span class="hljs-keyword">willSet</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newValue == .approved,                $state.timestampedValues.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0.1</span></span> }.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(.denied)            {                <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)            }        }    } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tripExpenses = <span class="hljs-type"><span class="hljs-type">ExpenseReport</span></span>() tripExpenses.state = .denied tripExpenses.state = .approved <span class="hljs-comment"><span class="hljs-comment">// Fatal error: «»   .</span></span></code> </pre> <br><h3>  Idées similaires </h3><br><ul><li>  <code>@Audited</code> pour <code>@Audited</code> accès à la propriété. </li><li>  <code>@UserDefault</code> pour encapsuler le mécanisme de lecture et d'enregistrement des données dans <code>UserDefaults</code> . </li></ul><br><h2>  Limitations </h2><br><h3>  Les propriétés ne peuvent pas lever d'exceptions </h3><br><p>  Comme déjà mentionné, les wrappers de propriété ne peuvent utiliser que quelques méthodes pour traiter les valeurs non valides: </p><br><ul><li>  les ignorer; <br></li><li>  terminer l'application à l'aide de fatalError (). <br></li></ul><br><h3>  Les propriétés encapsulées ne peuvent pas être marquées avec l'attribut `typealias` </h3><br><p>  L'exemple <code>@UnitInterval</code> ci-dessus, dont la propriété est limitée par l'intervalle <code>(0...1)</code> , ne peut pas être déclaré comme </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">UnitInterval</span></span> = <span class="hljs-type"><span class="hljs-type">Clamping</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h3>  Restriction à l'utilisation d'une composition de plusieurs wrappers de propriété </h3><br><p>  Composer des wrappers de propriétés n'est pas une opération commutative: l'ordre de la déclaration affectera le comportement.  Prenons un exemple dans lequel la propriété slug, qui est l'url d'un article de blog, est normalisée.  Dans ce cas, le résultat de la normalisation variera selon le moment où les espaces seront remplacés par des tirets, avant ou après la suppression des espaces.  Par conséquent, pour le moment, une composition de plusieurs wrappers de propriété n'est pas prise en charge. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dasherized</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.replacingOccurrences(of: <span class="hljs-string"><span class="hljs-string">" "</span></span>, with: <span class="hljs-string"><span class="hljs-string">"-"</span></span>) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span> @<span class="hljs-type"><span class="hljs-type">Trimmed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-comment"><span class="hljs-comment">// error: multiple property wrappers are not supported }</span></span></code> </pre> <br><p>  Cependant, cette limitation peut être contournée en utilisant des wrappers de propriété imbriqués. </p><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrimmedAndDasherized</span></span></span><span class="hljs-class"> </span></span>{    @<span class="hljs-type"><span class="hljs-type">Dasherized</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">String</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { value }        <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { value = newValue.trimmingCharacters(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .whitespacesAndNewlines) }    }    <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(initialValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrappedValue = initialValue    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{    …    @<span class="hljs-type"><span class="hljs-type">TrimmedAndDasherized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slug: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre> <br><h3>  Autres restrictions de wrapper de propriété </h3><br><ul><li>  Ne peut pas être utilisé à l'intérieur du protocole. </li><li>  Une instance de propriété wrapper ne peut pas être déclarée dans <code>enum</code> . </li><li>  Une propriété encapsulée déclarée à l'intérieur d'une classe ne peut pas être remplacée par une autre propriété. </li><li>  Une propriété <code>@NSCopying</code> ne peut pas être <code>lazy</code> , <code>@NSCopying</code> , <code>@NSManaged</code> , <code>weak</code> ou sans <code>unowned</code> . </li><li>  Une propriété <code>@Lazy var (x, y) = /* ... */</code> doit être la seule dans sa définition (c'est-à-dire que <code>@Lazy var (x, y) = /* ... */</code> ). </li><li>  Une propriété encapsulée ne peut pas avoir de <code>getter</code> et de <code>setter</code> définis. </li><li>  Les types de la propriété <code>wrappedValue</code> et de la variable <code>wrappedValue</code> dans <code>init(wrappedValue:)</code> doivent avoir le même niveau d'accès que le type d'encapsuleur de la propriété. </li><li>  La propriété type de <code>projectedValue</code> doit avoir le même niveau d'accès que le type wrapper de la propriété. </li><li>  <code>init()</code> doit avoir le même niveau d'accès que le type d'encapsuleur de propriété. </li></ul><br><p>  Résumons.  Les wrappers de propriétés dans Swift permettent aux auteurs de bibliothèques d'accéder au comportement de haut niveau précédemment réservé aux fonctions de langage.  Leur potentiel pour améliorer la lisibilité et réduire la complexité du code est énorme, et nous n'avons examiné que superficiellement les capacités de cet outil. </p><br><p>  Utilisez-vous des wrappers de propriétés dans vos projets?  Écrivez dans les commentaires! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485008/">https://habr.com/ru/post/fr485008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484992/index.html">Plus joli dans les grands projets: passez 20 minutes sur la configuration, oubliez le formatage pour toujours</a></li>
<li><a href="../fr484996/index.html">PBX virtuel Beeline. Ce que le manager ne vous dira pas</a></li>
<li><a href="../fr485000/index.html">Le trafic américain est-il cher ou non?</a></li>
<li><a href="../fr485002/index.html">Flutter BloC pattern + Provider + tests + souvenez-vous de l'état</a></li>
<li><a href="../fr485006/index.html">Livre (d'être?). Réflexions sur la nature de l'esprit. Partie II</a></li>
<li><a href="../fr485010/index.html">Ne pleure pas, ma fille! Réponse à l'auteur avec vc.ru sur la lettre concernant Habré</a></li>
<li><a href="../fr485012/index.html">Comment utiliser Control Inversion en JavaScript et Reactjs pour simplifier la gestion du code</a></li>
<li><a href="../fr485014/index.html">Dois-je me plaindre des entretiens?</a></li>
<li><a href="../fr485016/index.html">Bases de données gérées chez Selectel: Bienvenue dans la version bêta</a></li>
<li><a href="../fr485018/index.html">Écriture de shaders avec du code dans Unity LWRP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>