<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🍳 👨🏿‍🚒 🧚🏾 RESTinio ist ein asynchroner HTTP-Server. Asynchron 🍽️ 📍 👩🏿‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren haben wir RESTinio veröffentlicht , unser kleines OpenSource C ++ - Framework zum Einbetten eines HTTP-Servers in C ++ - Anwendunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio ist ein asynchroner HTTP-Server. Asynchron</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Vor einigen Jahren haben wir <a href="">RESTinio veröffentlicht</a> , unser kleines OpenSource C ++ - Framework zum Einbetten eines HTTP-Servers in C ++ - Anwendungen.  RESTinio wurde in dieser Zeit nicht besonders beliebt, ging aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht verloren</a> .  Jemand wählt es für die "native" Unterstützung für Windows, jemand für einige einzelne Funktionen (wie Sendfile-Unterstützung), jemand für das Verhältnis von Funktionen, Benutzerfreundlichkeit und Anpassung.  Aber ich denke, anfangs sind viele RESTinio von diesem lakonischen "Hallo Welt" angezogen: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  Dies ist wirklich alles, was benötigt wird, um den HTTP-Server in einer C ++ - Anwendung auszuführen. </p><br><p>  Und obwohl wir immer versuchen zu sagen, dass die Hauptfunktion, für die wir RESTinio im Allgemeinen übernommen haben, die asynchrone Verarbeitung eingehender Anforderungen war, stoßen wir gelegentlich auf Fragen, was zu tun ist, wenn Sie in request_handler längere Vorgänge ausführen müssen. </p><br><p>  Und da eine solche Frage relevant ist, können Sie noch einmal darüber sprechen und ein paar kleine Beispiele nennen. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Ein kleiner Hinweis auf die Ursprünge </h1><br><p>  Wir haben uns entschlossen, unseren einbettbaren HTTP-Server nach mehreren aufeinanderfolgenden Aufgaben sehr ähnlich zu gestalten: Es war erforderlich, eine HTTP-Eingabe für eine vorhandene C ++ - Anwendung zu organisieren, oder es musste ein Mikrodienst geschrieben werden, in dem das bereits vorhandene "schwere" C ++ wiederverwendet werden musste ny Code.  Ein gemeinsames Merkmal dieser Aufgaben war, dass sich die Anwendungsverarbeitung der Anforderung über mehrere zehn Sekunden erstrecken konnte. </p><br><p>  Grob gesagt sortierte der HTTP-Server eine Millisekunde lang eine neue HTTP-Anforderung aus, aber um eine HTTP-Antwort auszugeben, musste er sich an einige andere Dienste wenden oder einige langwierige Berechnungen durchführen.  Wenn Sie HTTP-Anforderungen im synchronen Modus verarbeiten, benötigt der HTTP-Server einen Pool von Tausenden von Arbeitsthreads, was selbst unter modernen Bedingungen kaum als gute Idee angesehen werden kann. </p><br><p>  Es ist viel praktischer, wenn der HTTP-Server nur mit einem Arbeitsthread arbeiten kann, für den E / A ausgeführt wird und Anforderungshandler aufgerufen werden.  Der Anforderungshandler delegiert einfach die eigentliche Verarbeitung eines anderen Arbeitsthreads und gibt die Steuerung an den HTTP-Server zurück.  Wenn viel später irgendwo in einem anderen Arbeitsthread Informationen bereit sind, auf die Anforderung zu antworten, wird einfach eine HTTP-Antwort generiert, die den HTTP-Server automatisch aufnimmt und diese Antwort an den entsprechenden Client sendet. </p><br><p>  Da wir nie eine vorgefertigte Version gefunden haben, die einfach und bequem zu verwenden ist, war sie plattformübergreifend und unterstützte Windows als „native“ Plattform, bot mehr oder weniger anständige Leistung und wurde vor allem speziell für asynchrone Anwendungen geschärft Arbeit, dann haben wir Anfang 2017 begonnen, RESTinio zu entwickeln. </p><br><p>  Wir wollten einen asynchronen eingebetteten HTTP-Server erstellen, der einfach zu bedienen ist, den Benutzer von einigen Routineproblemen befreit, mehr oder weniger produktiv ist, plattformübergreifend und eine flexible Konfiguration für verschiedene Bedingungen ermöglicht.  Es scheint zu funktionieren, aber überlassen wir es den Benutzern, zu beurteilen ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Es gibt also eine eingehende Anfrage, die viel Verarbeitungszeit erfordert.  Was zu tun ist? </h1><br><h2 id="rabochie-niti-restinioasio">  Arbeitsthreads RESTinio / Asio </h2><br><p>  Manchmal denken RESTinio-Benutzer nicht darüber nach, welche Arbeitsthreads und wie genau RESTinio verwendet wird.  Beispielsweise könnte jemand in Betracht ziehen, dass RESTinio beim Starten von RESTinio in einem Arbeitsthread (unter Verwendung von <code>run(on_this_thread(...))</code> wie im obigen Beispiel) in diesem Arbeitsthread nur Anforderungshandler aufruft.  Während für E / A RESTinio einen separaten Faden unter der Haube erzeugt.  Und dieser separate Thread bedient weiterhin neue Verbindungen, wenn der Hauptarbeitsthread von request_handler belegt ist. </p><br><p>  Tatsächlich werden alle Threads, die der Benutzer RESTinio zuweist, sowohl zum Ausführen von E / A-Operationen als auch zum Aufrufen von request_handlers verwendet.  Wenn Sie den RESTinio-Server über <code>run(on_this_thread(...))</code> und dann über <code>run()</code> im aktuellen Thread gestartet haben, werden sowohl E / A- als auch Anforderungshandler ausgeführt. </p><br><p>  Grob gesagt startet RESTinio eine Asio-Ereignisschleife, in der neue Verbindungen verarbeitet, Daten von vorhandenen Verbindungen gelesen und analysiert, sendfertige Daten geschrieben, Verbindungen geschlossen usw. werden.  Nachdem die eingehende Anforderung gelesen und von der nächsten Verbindung vollständig analysiert wurde, wird unter anderem der vom Benutzer angegebene request_handler aufgerufen, um diese Anforderung zu verarbeiten. </p><br><p>  Wenn request_handler den Betrieb des aktuellen Threads blockiert, wird dementsprechend auch die Asio-Action-Ereignisschleife blockiert, die an demselben Thread arbeitet.  Alles ist einfach. </p><br><p>  Wenn RESTinio für einen Pool von Arbeitsthreads gestartet wird (d. H. Durch <code>run(on_thread_pool(...))</code> wie <a href="">in diesem Beispiel</a> ), geschieht fast dasselbe: Für jeden Thread aus dem Pool wird eine Asio-Ereignisereignisschleife gestartet.  Wenn ein request_handler beginnt, große Matrizen zu multiplizieren, blockiert dies den Arbeitsthread im Pool und E / A-Operationen werden nicht mehr für diesen Thread bereitgestellt. </p><br><p>  Daher besteht die Aufgabe des Entwicklers bei der Verwendung von RESTinio darin, seine request_handlers in angemessener und vorzugsweise nicht sehr langer Zeit abzuschließen. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  Benötigen Sie einen Workflow-Pool für RESTinio / Asio? </h2><br><p>  Wenn der vom Benutzer angegebene request_handler den Arbeitsthread, für den er aufgerufen wird, für längere Zeit blockiert, verliert dieser Thread die Fähigkeit, E / A-Operationen zu verarbeiten.  Was aber, wenn request_handler viel Zeit benötigt, um eine Antwort zu erstellen?  Angenommen, er führt eine schwere Rechenoperation aus, deren Zeit im Prinzip nicht auf einige Millisekunden verkürzt werden kann? </p><br><p>  Einer der Benutzer könnte denken, da RESTinio an einem Pool von Arbeitsthreads arbeiten kann, geben Sie einfach die größere Poolgröße an und fertig. </p><br><p>  Leider funktioniert dies nur in einfachen Fällen, wenn Sie nur wenige parallele Verbindungen haben.  Und die Abfrageintensität ist gering.  Wenn die Anzahl der parallelen Abfragen Tausende (mindestens nur einige Hundert) beträgt, kann es leicht zu einer Situation kommen, in der alle Arbeitsthreads des Pools damit beschäftigt sind, bereits akzeptierte Anforderungen zu verarbeiten.  Und es werden keine Threads mehr zum Ausführen von E / A-Operationen übrig sein.  Infolgedessen verliert der Server seine Reaktionsfähigkeit.  Durch das Einbeziehen von RESTinio wird die Fähigkeit verloren, Zeitüberschreitungen zu verarbeiten, die RESTinio automatisch zählt, wenn neue Verbindungen empfangen und Anforderungen verarbeitet werden. </p><br><p>  Wenn Sie längere Blockierungsvorgänge ausführen müssen, um eingehende Anforderungen zu bearbeiten, ist es daher besser, nur einen Arbeitsthread für RESTinio zuzuweisen, aber einen großen Pool von Arbeitsabläufen zuzuweisen, um dieselben Vorgänge auszuführen.  Der Anforderungshandler stellt die nächste Anforderung nur in eine Warteschlange, von der aus die Anforderung abgerufen und zur Verarbeitung gesendet wird. </p><br><p>  Wir haben uns ein Beispiel für dieses Schema im Detail angesehen, als wir in diesem Artikel über unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp-Demo-Projekt</a> sprachen: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp: Skalieren und Freigeben von HTTP-Bildern in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio</a> ." </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Beispiele für das Delegieren der Anforderungsverarbeitung an einzelne Arbeitsthreads </h2><br><p>  Oben habe ich versucht zu erklären, warum es nicht notwendig ist, eine lange Verarbeitung direkt im request_handler durchzuführen.  Woher kommt das offensichtliche Ergebnis: Eine lange Anforderungsverarbeitung muss an einen anderen Arbeitsthread delegiert werden.  Schauen wir uns an, wie das aussehen könnte. </p><br><p>  In den beiden folgenden Beispielen benötigen wir einen einzelnen Arbeitsthread, um RESTinio auszuführen, und einen anderen Arbeitsthread, um eine lange Anforderungsverarbeitung zu simulieren.  Außerdem benötigen wir eine Art Nachrichtenwarteschlange, um Anforderungen vom RESTinio-Thread an einen separaten Arbeitsthread zu übertragen. </p><br><p>  Für diese beiden Beispiele konnte ich keine neue Implementierung der thread-sicheren Nachrichtenwarteschlange auf dem Knie durchführen. Daher habe ich meinen nativen SObjectizer und seine Ketten verwendet, bei denen es sich um CSP-Kanäle handelt.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> mchain finden Sie hier: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationsaustausch zwischen Arbeitsthreads ohne Schmerzen? CSP-Kanäle, die uns helfen</a> ." </p><br><h3 id="sohranenie-obekta-request_handle">  Anforderungshandle-Objekt speichern </h3><br><p>  Die grundlegende Technik, auf der die Delegierung der Anforderungsverarbeitung basiert, ist die Übertragung des Objekts <code>request_handle_t</code> irgendwo. </p><br><p>  Wenn RESTinio den vom Benutzer angegebenen request_handler aufruft, um eine eingehende Anforderung zu verarbeiten, wird ein Objekt vom Typ <code>request_handle_t</code> an diesen <code>request_handle_t</code> .  Dieser Typ ist nichts anderes als ein intelligenter Zeiger auf die Parameter der empfangenen Anforderung.  Wenn es für jemanden <code>request_handle_t</code> ist zu glauben, dass <code>request_handle_t</code> <code>shared_ptr</code> , können Sie dies sicher glauben.  Dieser <code>shared_ptr</code> ist. </p><br><p>  Und da <code>request_handle_t</code> <code>shared_ptr</code> , können wir diesen intelligenten Zeiger sicher irgendwo übergeben.  Was wir in den folgenden Beispielen tun werden. </p><br><p>  Wir brauchen also einen separaten Arbeitsthread und Kanal, um mit ihm zu kommunizieren.  Lassen Sie uns alles erstellen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  Der Hauptteil des Arbeitsthreads selbst befindet sich in der Funktion <code>processing_thread_func()</code> , auf die wir später noch eingehen werden. </p><br><p>  Jetzt haben wir bereits einen separaten Arbeitsthread und einen Kanal für die Kommunikation damit.  Sie können den RESTinio-Server starten: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  Die Logik für diesen Server ist sehr einfach.  Wenn eine GET-Anfrage für '/' eingetroffen ist, delegieren wir die Anforderungsverarbeitung eines einzelnen Threads.  Dazu führen wir zwei wichtige Operationen durch: </p><br><ul><li>  Senden Sie das Objekt <code>request_handle_t</code> an den CSP-Kanal.  Während dieses Objekt im CSP-Kanal oder anderswo gespeichert ist, weiß RESTinio, dass die Anforderung noch aktiv ist. </li><li>  Wir geben den Wert <code>restinio::request_accepted()</code> vom Request-Handler zurück.  Dadurch wird RESTinio klar, dass die Anforderung zur Verarbeitung angenommen wurde und die Verbindung zum Client nicht geschlossen werden kann. </li></ul><br><p>  Die Tatsache, dass request_handler nicht sofort eine RESTinio-Antwort generiert hat, stört nicht.  Sobald <code>restinio::request_accepted()</code> zurückgegeben wurde, übernahm der Benutzer die Verantwortung für die Verarbeitung der Anfrage und eines Tages wird die Antwort auf die Anfrage generiert. </p><br><p>  Wenn der Anforderungshandler <code>restinio::request_rejected()</code> , versteht RESTinio, dass die Anforderung nicht verarbeitet wird, und gibt einen 501-Fehler an den Client zurück. </p><br><p>  Also <code>request_handle_t</code> wir das vorläufige Ergebnis: Die <code>request_handle_t</code> Instanz kann irgendwo übergeben werden, da es sich tatsächlich um <code>std::shared_ptr</code> .  Während diese Instanz aktiv ist, geht RESTinio davon aus, dass die Anforderung verarbeitet wird.  Wenn der Anforderungshandler <code>restinio::request_accepted()</code> , macht sich RESTinio keine Sorgen darüber, dass die Antwort auf die Anforderung gerade nicht generiert wurde. </p><br><p>  Jetzt können wir uns die Implementierung dieses sehr separaten Threads ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  Die Logik hier ist sehr einfach: Wir erhalten die erste Anforderung in Form einer <code>handle_request</code> Nachricht und leiten sie in Form einer <code>timeout_elapsed</code> Nachricht, die um eine zufällige Zeit verzögert ist, an uns weiter.  Die eigentliche Bearbeitung der Anfrage erfolgt erst nach Erhalt von <code>timeout_elapsed</code> . </p><br><p>  <strong>Upd.</strong>  Wenn die Methode <code>done()</code> in einem separaten Arbeitsthread aufgerufen wird, wird RESTinio benachrichtigt, dass eine vorgefertigte Antwort angezeigt wurde, die in die TCP-Verbindung geschrieben werden muss.  RESTinio initiiert die Schreiboperation, aber die E / A-Operation selbst wird nicht ausgeführt, wenn <code>done()</code> aufgerufen wird, sondern wenn RESTinio die E / A ausführt und request_handlers aufruft.  Das heißt,  In diesem Beispiel wird <code>done()</code> für einen separaten Arbeitsthread aufgerufen, und die Schreiboperation wird für den Hauptthread ausgeführt, in dem <code>restinio::run()</code> funktioniert. </p><br><p>  Die Nachrichten selbst lauten wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  Das heißt,  Ein separater Arbeitsthread nimmt <code>request_handle_t</code> und speichert es, bis sich die Gelegenheit ergibt, eine vollständige Antwort zu bilden.  Wenn sich diese Gelegenheit ergibt, wird <code>create_response()</code> für das gespeicherte Anforderungsobjekt aufgerufen und die Antwort an RESTinio zurückgegeben.  Dann schreibt RESTinio bereits in seinem Arbeitskontext die Antwort in Verbindung mit dem entsprechenden Client. </p><br><p>  Hier wird die <code>request_handle_t</code> Instanz in einer verzögerten <code>timeout_elapsed</code> Nachricht gespeichert, da in diesem primitiven Beispiel keine echte Verarbeitung erfolgt.  In einer realen Anwendung kann <code>request_handle_t</code> in einer Warteschlange oder in einem Objekt gespeichert werden, das zur Verarbeitung der Anforderung erstellt wurde. </p><br><p>  Der vollständige Code für dieses Beispiel befindet sich <a href="">unter den regulären RESTinio-Beispielen</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Einige kleine Code-Notizen </h4><br><p>  Diese Konstruktion legt die RESTinio-Eigenschaften fest, die ein RESTinio-Server haben sollte: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  In diesem Beispiel benötige ich RESTinio, um die Anforderungsverarbeitungsaktionen zu protokollieren.  Daher habe ich <code>logger_t</code> dass es sich vom Standardwert <code>null_logger_t</code> .  Aber seitdem  RESTinio funktioniert tatsächlich mit mehreren Threads (RESTinio verarbeitet eingehende Anforderungen im Hauptthread, die Antworten stammen jedoch von einem separaten Arbeitsthread). Dann benötigen Sie einen threadsicheren Logger, <code>shared_ostream_logger_t</code> . </p><br><p>  In process_thread_func <code>processing_thread_func()</code> wird die SObjectizer-Funktion <code>select()</code> , die dem Go select-Konstrukt etwas ähnelt: Sie können Nachrichten von mehreren Kanälen gleichzeitig lesen und verarbeiten.  Die Funktion <code>select()</code> funktioniert so lange, bis alle an sie übergebenen Kanäle geschlossen sind.  Oder bis ihr gewaltsam gesagt wird, dass es Zeit ist zu enden. </p><br><p>  Wenn der Kanal für die Kommunikation mit dem RESTinio-Server geschlossen ist, macht es keinen Sinn, die Arbeit fortzusetzen.  Daher wird in <code>select()</code> die Reaktion auf das Schließen eines der Kanäle bestimmt: Sobald ein Kanal geschlossen wird, wird das Stoppflag gehisst.  Dies führt zum Abschluss von <code>select()</code> und zum Beenden von <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Speichern des response_builder-Objekts </h3><br><p>  Im vorherigen Beispiel haben wir einen einfachen Fall betrachtet, in dem es möglich ist, <code>request_handle_t</code> zu speichern, bis wir sofort die gesamte Antwort auf die Anforderung geben können. </p><br><p>  Es kann jedoch komplexere Szenarien geben, in denen Sie beispielsweise teilweise eine Antwort geben müssen.  Das heißt, wir erhalten eine Anfrage, wir können sofort nur den ersten Teil der Antwort bilden.  Wir bilden es.  Nach einiger Zeit haben wir dann die Möglichkeit, den zweiten Teil der Antwort zu bilden.  Dann, nach einiger Zeit, können wir den nächsten Teil usw. bilden. </p><br><p>  Darüber hinaus kann es für uns wünschenswert sein, dass alle diese Teile verschwinden, wenn wir sie bilden.  Das heißt,  Zuerst der erste Teil der Antwort, damit der Client sie subtrahieren kann, dann der zweite, dann der dritte usw. </p><br><p>  Mit RESTinio können Sie dies aufgrund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedener Arten von responce_builders tun</a> .  Insbesondere Typen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">user_controlled_output</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chunked_output</a> . </p><br><p>  In diesem Fall reicht es nicht aus, <code>request_handle_t</code> zu speichern, da <code>request_handle_t</code> nur bis zum ersten Aufruf von <code>create_reponse()</code> nützlich ist.  Als nächstes müssen wir mit response_builder arbeiten.  Na und... </p><br><p>  Nun, das ist okay.  Response_builder ist ein beweglicher Typ, der unique_ptr ähnelt.  So können wir es auch so lange behalten, wie wir es brauchen.  Und um zu zeigen, wie es aussieht, wiederholen wir das obige Beispiel leicht.  Lassen Sie die Funktion <code>processing_thread_func()</code> die Antwort in Teilen bilden. </p><br><p>  Das ist überhaupt nicht schwierig. </p><br><p>  Zuerst müssen wir uns für die Typen entscheiden, die new <code>processing_thread_func()</code> benötigt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  Die Nachricht <code>handle_request</code> bleibt unverändert.  In der Nachricht <code>timeout_elapsed</code> speichern wir jetzt nicht <code>request_handle_t</code> , sondern response_builder des Typs, den wir benötigen.  Plus einen Zähler der restlichen Teile.  Sobald dieser Zähler zurückgesetzt wird, endet der Anforderungsdienst. </p><br><p>  Jetzt können wir uns eine neue Version der Funktion <code>processing_thread_func()</code> ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  Das heißt,     ,        .       .         . </p><br><p>  <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  Das heißt,    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p> ,   ,      RESTinio —   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451728/">https://habr.com/ru/post/de451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451718/index.html">Sprachassistenten erstellen</a></li>
<li><a href="../de451720/index.html">FIAS wird durch improvisierte (SQLXMLBULKLOAD) Mittel in die Datenbank von MSSQLSERVER geladen. Wie es (wahrscheinlich) nicht gemacht werden muss</a></li>
<li><a href="../de451722/index.html">Qt-asynchrone asynchrone Widget-Bibliothek</a></li>
<li><a href="../de451724/index.html">Skyrmion zu Skyrmion Zwietracht: dreidimensionale polare Skyrmionen in Ferroelastik</a></li>
<li><a href="../de451726/index.html">Arbeitssuche im Ausland: 7 einfache Tipps für IT-Profis</a></li>
<li><a href="../de451738/index.html">Kurzer Rückblick auf den Artikel "DeViSE: Ein tiefes visuell-semantisches Einbettungsmodell"</a></li>
<li><a href="../de451742/index.html">Einen Tag vor DotNext 2019 Piter. Kostenlose Broadcast-Ankündigung</a></li>
<li><a href="../de451746/index.html">MegaSlerm für Ingenieure und Architekten Kubernetes</a></li>
<li><a href="../de451748/index.html">Überwachen des SSD-Status in Qsan-Arrays</a></li>
<li><a href="../de451750/index.html">Buch "Elasticsearch, Kibana, Logstash und Suchmaschinen der nächsten Generation"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>