<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüç≥ üë®üèø‚Äçüöí üßöüèæ RESTinio ist ein asynchroner HTTP-Server. Asynchron üçΩÔ∏è üìç üë©üèø‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren haben wir RESTinio ver√∂ffentlicht , unser kleines OpenSource C ++ - Framework zum Einbetten eines HTTP-Servers in C ++ - Anwendunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio ist ein asynchroner HTTP-Server. Asynchron</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Vor einigen Jahren haben wir <a href="">RESTinio ver√∂ffentlicht</a> , unser kleines OpenSource C ++ - Framework zum Einbetten eines HTTP-Servers in C ++ - Anwendungen.  RESTinio wurde in dieser Zeit nicht besonders beliebt, ging aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht verloren</a> .  Jemand w√§hlt es f√ºr die "native" Unterst√ºtzung f√ºr Windows, jemand f√ºr einige einzelne Funktionen (wie Sendfile-Unterst√ºtzung), jemand f√ºr das Verh√§ltnis von Funktionen, Benutzerfreundlichkeit und Anpassung.  Aber ich denke, anfangs sind viele RESTinio von diesem lakonischen "Hallo Welt" angezogen: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  Dies ist wirklich alles, was ben√∂tigt wird, um den HTTP-Server in einer C ++ - Anwendung auszuf√ºhren. </p><br><p>  Und obwohl wir immer versuchen zu sagen, dass die Hauptfunktion, f√ºr die wir RESTinio im Allgemeinen √ºbernommen haben, die asynchrone Verarbeitung eingehender Anforderungen war, sto√üen wir gelegentlich auf Fragen, was zu tun ist, wenn Sie in request_handler l√§ngere Vorg√§nge ausf√ºhren m√ºssen. </p><br><p>  Und da eine solche Frage relevant ist, k√∂nnen Sie noch einmal dar√ºber sprechen und ein paar kleine Beispiele nennen. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Ein kleiner Hinweis auf die Urspr√ºnge </h1><br><p>  Wir haben uns entschlossen, unseren einbettbaren HTTP-Server nach mehreren aufeinanderfolgenden Aufgaben sehr √§hnlich zu gestalten: Es war erforderlich, eine HTTP-Eingabe f√ºr eine vorhandene C ++ - Anwendung zu organisieren, oder es musste ein Mikrodienst geschrieben werden, in dem das bereits vorhandene "schwere" C ++ wiederverwendet werden musste ny Code.  Ein gemeinsames Merkmal dieser Aufgaben war, dass sich die Anwendungsverarbeitung der Anforderung √ºber mehrere zehn Sekunden erstrecken konnte. </p><br><p>  Grob gesagt sortierte der HTTP-Server eine Millisekunde lang eine neue HTTP-Anforderung aus, aber um eine HTTP-Antwort auszugeben, musste er sich an einige andere Dienste wenden oder einige langwierige Berechnungen durchf√ºhren.  Wenn Sie HTTP-Anforderungen im synchronen Modus verarbeiten, ben√∂tigt der HTTP-Server einen Pool von Tausenden von Arbeitsthreads, was selbst unter modernen Bedingungen kaum als gute Idee angesehen werden kann. </p><br><p>  Es ist viel praktischer, wenn der HTTP-Server nur mit einem Arbeitsthread arbeiten kann, f√ºr den E / A ausgef√ºhrt wird und Anforderungshandler aufgerufen werden.  Der Anforderungshandler delegiert einfach die eigentliche Verarbeitung eines anderen Arbeitsthreads und gibt die Steuerung an den HTTP-Server zur√ºck.  Wenn viel sp√§ter irgendwo in einem anderen Arbeitsthread Informationen bereit sind, auf die Anforderung zu antworten, wird einfach eine HTTP-Antwort generiert, die den HTTP-Server automatisch aufnimmt und diese Antwort an den entsprechenden Client sendet. </p><br><p>  Da wir nie eine vorgefertigte Version gefunden haben, die einfach und bequem zu verwenden ist, war sie plattform√ºbergreifend und unterst√ºtzte Windows als ‚Äûnative‚Äú Plattform, bot mehr oder weniger anst√§ndige Leistung und wurde vor allem speziell f√ºr asynchrone Anwendungen gesch√§rft Arbeit, dann haben wir Anfang 2017 begonnen, RESTinio zu entwickeln. </p><br><p>  Wir wollten einen asynchronen eingebetteten HTTP-Server erstellen, der einfach zu bedienen ist, den Benutzer von einigen Routineproblemen befreit, mehr oder weniger produktiv ist, plattform√ºbergreifend und eine flexible Konfiguration f√ºr verschiedene Bedingungen erm√∂glicht.  Es scheint zu funktionieren, aber √ºberlassen wir es den Benutzern, zu beurteilen ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Es gibt also eine eingehende Anfrage, die viel Verarbeitungszeit erfordert.  Was zu tun ist? </h1><br><h2 id="rabochie-niti-restinioasio">  Arbeitsthreads RESTinio / Asio </h2><br><p>  Manchmal denken RESTinio-Benutzer nicht dar√ºber nach, welche Arbeitsthreads und wie genau RESTinio verwendet wird.  Beispielsweise k√∂nnte jemand in Betracht ziehen, dass RESTinio beim Starten von RESTinio in einem Arbeitsthread (unter Verwendung von <code>run(on_this_thread(...))</code> wie im obigen Beispiel) in diesem Arbeitsthread nur Anforderungshandler aufruft.  W√§hrend f√ºr E / A RESTinio einen separaten Faden unter der Haube erzeugt.  Und dieser separate Thread bedient weiterhin neue Verbindungen, wenn der Hauptarbeitsthread von request_handler belegt ist. </p><br><p>  Tats√§chlich werden alle Threads, die der Benutzer RESTinio zuweist, sowohl zum Ausf√ºhren von E / A-Operationen als auch zum Aufrufen von request_handlers verwendet.  Wenn Sie den RESTinio-Server √ºber <code>run(on_this_thread(...))</code> und dann √ºber <code>run()</code> im aktuellen Thread gestartet haben, werden sowohl E / A- als auch Anforderungshandler ausgef√ºhrt. </p><br><p>  Grob gesagt startet RESTinio eine Asio-Ereignisschleife, in der neue Verbindungen verarbeitet, Daten von vorhandenen Verbindungen gelesen und analysiert, sendfertige Daten geschrieben, Verbindungen geschlossen usw. werden.  Nachdem die eingehende Anforderung gelesen und von der n√§chsten Verbindung vollst√§ndig analysiert wurde, wird unter anderem der vom Benutzer angegebene request_handler aufgerufen, um diese Anforderung zu verarbeiten. </p><br><p>  Wenn request_handler den Betrieb des aktuellen Threads blockiert, wird dementsprechend auch die Asio-Action-Ereignisschleife blockiert, die an demselben Thread arbeitet.  Alles ist einfach. </p><br><p>  Wenn RESTinio f√ºr einen Pool von Arbeitsthreads gestartet wird (d. H. Durch <code>run(on_thread_pool(...))</code> wie <a href="">in diesem Beispiel</a> ), geschieht fast dasselbe: F√ºr jeden Thread aus dem Pool wird eine Asio-Ereignisereignisschleife gestartet.  Wenn ein request_handler beginnt, gro√üe Matrizen zu multiplizieren, blockiert dies den Arbeitsthread im Pool und E / A-Operationen werden nicht mehr f√ºr diesen Thread bereitgestellt. </p><br><p>  Daher besteht die Aufgabe des Entwicklers bei der Verwendung von RESTinio darin, seine request_handlers in angemessener und vorzugsweise nicht sehr langer Zeit abzuschlie√üen. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  Ben√∂tigen Sie einen Workflow-Pool f√ºr RESTinio / Asio? </h2><br><p>  Wenn der vom Benutzer angegebene request_handler den Arbeitsthread, f√ºr den er aufgerufen wird, f√ºr l√§ngere Zeit blockiert, verliert dieser Thread die F√§higkeit, E / A-Operationen zu verarbeiten.  Was aber, wenn request_handler viel Zeit ben√∂tigt, um eine Antwort zu erstellen?  Angenommen, er f√ºhrt eine schwere Rechenoperation aus, deren Zeit im Prinzip nicht auf einige Millisekunden verk√ºrzt werden kann? </p><br><p>  Einer der Benutzer k√∂nnte denken, da RESTinio an einem Pool von Arbeitsthreads arbeiten kann, geben Sie einfach die gr√∂√üere Poolgr√∂√üe an und fertig. </p><br><p>  Leider funktioniert dies nur in einfachen F√§llen, wenn Sie nur wenige parallele Verbindungen haben.  Und die Abfrageintensit√§t ist gering.  Wenn die Anzahl der parallelen Abfragen Tausende (mindestens nur einige Hundert) betr√§gt, kann es leicht zu einer Situation kommen, in der alle Arbeitsthreads des Pools damit besch√§ftigt sind, bereits akzeptierte Anforderungen zu verarbeiten.  Und es werden keine Threads mehr zum Ausf√ºhren von E / A-Operationen √ºbrig sein.  Infolgedessen verliert der Server seine Reaktionsf√§higkeit.  Durch das Einbeziehen von RESTinio wird die F√§higkeit verloren, Zeit√ºberschreitungen zu verarbeiten, die RESTinio automatisch z√§hlt, wenn neue Verbindungen empfangen und Anforderungen verarbeitet werden. </p><br><p>  Wenn Sie l√§ngere Blockierungsvorg√§nge ausf√ºhren m√ºssen, um eingehende Anforderungen zu bearbeiten, ist es daher besser, nur einen Arbeitsthread f√ºr RESTinio zuzuweisen, aber einen gro√üen Pool von Arbeitsabl√§ufen zuzuweisen, um dieselben Vorg√§nge auszuf√ºhren.  Der Anforderungshandler stellt die n√§chste Anforderung nur in eine Warteschlange, von der aus die Anforderung abgerufen und zur Verarbeitung gesendet wird. </p><br><p>  Wir haben uns ein Beispiel f√ºr dieses Schema im Detail angesehen, als wir in diesem Artikel √ºber unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp-Demo-Projekt</a> sprachen: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp: Skalieren und Freigeben von HTTP-Bildern in modernem C ++ mit ImageMagic ++, SObjectizer und RESTinio</a> ." </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Beispiele f√ºr das Delegieren der Anforderungsverarbeitung an einzelne Arbeitsthreads </h2><br><p>  Oben habe ich versucht zu erkl√§ren, warum es nicht notwendig ist, eine lange Verarbeitung direkt im request_handler durchzuf√ºhren.  Woher kommt das offensichtliche Ergebnis: Eine lange Anforderungsverarbeitung muss an einen anderen Arbeitsthread delegiert werden.  Schauen wir uns an, wie das aussehen k√∂nnte. </p><br><p>  In den beiden folgenden Beispielen ben√∂tigen wir einen einzelnen Arbeitsthread, um RESTinio auszuf√ºhren, und einen anderen Arbeitsthread, um eine lange Anforderungsverarbeitung zu simulieren.  Au√üerdem ben√∂tigen wir eine Art Nachrichtenwarteschlange, um Anforderungen vom RESTinio-Thread an einen separaten Arbeitsthread zu √ºbertragen. </p><br><p>  F√ºr diese beiden Beispiele konnte ich keine neue Implementierung der thread-sicheren Nachrichtenwarteschlange auf dem Knie durchf√ºhren. Daher habe ich meinen nativen SObjectizer und seine Ketten verwendet, bei denen es sich um CSP-Kan√§le handelt.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> mchain finden Sie hier: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationsaustausch zwischen Arbeitsthreads ohne Schmerzen? CSP-Kan√§le, die uns helfen</a> ." </p><br><h3 id="sohranenie-obekta-request_handle">  Anforderungshandle-Objekt speichern </h3><br><p>  Die grundlegende Technik, auf der die Delegierung der Anforderungsverarbeitung basiert, ist die √úbertragung des Objekts <code>request_handle_t</code> irgendwo. </p><br><p>  Wenn RESTinio den vom Benutzer angegebenen request_handler aufruft, um eine eingehende Anforderung zu verarbeiten, wird ein Objekt vom Typ <code>request_handle_t</code> an diesen <code>request_handle_t</code> .  Dieser Typ ist nichts anderes als ein intelligenter Zeiger auf die Parameter der empfangenen Anforderung.  Wenn es f√ºr jemanden <code>request_handle_t</code> ist zu glauben, dass <code>request_handle_t</code> <code>shared_ptr</code> , k√∂nnen Sie dies sicher glauben.  Dieser <code>shared_ptr</code> ist. </p><br><p>  Und da <code>request_handle_t</code> <code>shared_ptr</code> , k√∂nnen wir diesen intelligenten Zeiger sicher irgendwo √ºbergeben.  Was wir in den folgenden Beispielen tun werden. </p><br><p>  Wir brauchen also einen separaten Arbeitsthread und Kanal, um mit ihm zu kommunizieren.  Lassen Sie uns alles erstellen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  Der Hauptteil des Arbeitsthreads selbst befindet sich in der Funktion <code>processing_thread_func()</code> , auf die wir sp√§ter noch eingehen werden. </p><br><p>  Jetzt haben wir bereits einen separaten Arbeitsthread und einen Kanal f√ºr die Kommunikation damit.  Sie k√∂nnen den RESTinio-Server starten: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  Die Logik f√ºr diesen Server ist sehr einfach.  Wenn eine GET-Anfrage f√ºr '/' eingetroffen ist, delegieren wir die Anforderungsverarbeitung eines einzelnen Threads.  Dazu f√ºhren wir zwei wichtige Operationen durch: </p><br><ul><li>  Senden Sie das Objekt <code>request_handle_t</code> an den CSP-Kanal.  W√§hrend dieses Objekt im CSP-Kanal oder anderswo gespeichert ist, wei√ü RESTinio, dass die Anforderung noch aktiv ist. </li><li>  Wir geben den Wert <code>restinio::request_accepted()</code> vom Request-Handler zur√ºck.  Dadurch wird RESTinio klar, dass die Anforderung zur Verarbeitung angenommen wurde und die Verbindung zum Client nicht geschlossen werden kann. </li></ul><br><p>  Die Tatsache, dass request_handler nicht sofort eine RESTinio-Antwort generiert hat, st√∂rt nicht.  Sobald <code>restinio::request_accepted()</code> zur√ºckgegeben wurde, √ºbernahm der Benutzer die Verantwortung f√ºr die Verarbeitung der Anfrage und eines Tages wird die Antwort auf die Anfrage generiert. </p><br><p>  Wenn der Anforderungshandler <code>restinio::request_rejected()</code> , versteht RESTinio, dass die Anforderung nicht verarbeitet wird, und gibt einen 501-Fehler an den Client zur√ºck. </p><br><p>  Also <code>request_handle_t</code> wir das vorl√§ufige Ergebnis: Die <code>request_handle_t</code> Instanz kann irgendwo √ºbergeben werden, da es sich tats√§chlich um <code>std::shared_ptr</code> .  W√§hrend diese Instanz aktiv ist, geht RESTinio davon aus, dass die Anforderung verarbeitet wird.  Wenn der Anforderungshandler <code>restinio::request_accepted()</code> , macht sich RESTinio keine Sorgen dar√ºber, dass die Antwort auf die Anforderung gerade nicht generiert wurde. </p><br><p>  Jetzt k√∂nnen wir uns die Implementierung dieses sehr separaten Threads ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  Die Logik hier ist sehr einfach: Wir erhalten die erste Anforderung in Form einer <code>handle_request</code> Nachricht und leiten sie in Form einer <code>timeout_elapsed</code> Nachricht, die um eine zuf√§llige Zeit verz√∂gert ist, an uns weiter.  Die eigentliche Bearbeitung der Anfrage erfolgt erst nach Erhalt von <code>timeout_elapsed</code> . </p><br><p>  <strong>Upd.</strong>  Wenn die Methode <code>done()</code> in einem separaten Arbeitsthread aufgerufen wird, wird RESTinio benachrichtigt, dass eine vorgefertigte Antwort angezeigt wurde, die in die TCP-Verbindung geschrieben werden muss.  RESTinio initiiert die Schreiboperation, aber die E / A-Operation selbst wird nicht ausgef√ºhrt, wenn <code>done()</code> aufgerufen wird, sondern wenn RESTinio die E / A ausf√ºhrt und request_handlers aufruft.  Das hei√üt,  In diesem Beispiel wird <code>done()</code> f√ºr einen separaten Arbeitsthread aufgerufen, und die Schreiboperation wird f√ºr den Hauptthread ausgef√ºhrt, in dem <code>restinio::run()</code> funktioniert. </p><br><p>  Die Nachrichten selbst lauten wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  Das hei√üt,  Ein separater Arbeitsthread nimmt <code>request_handle_t</code> und speichert es, bis sich die Gelegenheit ergibt, eine vollst√§ndige Antwort zu bilden.  Wenn sich diese Gelegenheit ergibt, wird <code>create_response()</code> f√ºr das gespeicherte Anforderungsobjekt aufgerufen und die Antwort an RESTinio zur√ºckgegeben.  Dann schreibt RESTinio bereits in seinem Arbeitskontext die Antwort in Verbindung mit dem entsprechenden Client. </p><br><p>  Hier wird die <code>request_handle_t</code> Instanz in einer verz√∂gerten <code>timeout_elapsed</code> Nachricht gespeichert, da in diesem primitiven Beispiel keine echte Verarbeitung erfolgt.  In einer realen Anwendung kann <code>request_handle_t</code> in einer Warteschlange oder in einem Objekt gespeichert werden, das zur Verarbeitung der Anforderung erstellt wurde. </p><br><p>  Der vollst√§ndige Code f√ºr dieses Beispiel befindet sich <a href="">unter den regul√§ren RESTinio-Beispielen</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Einige kleine Code-Notizen </h4><br><p>  Diese Konstruktion legt die RESTinio-Eigenschaften fest, die ein RESTinio-Server haben sollte: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  In diesem Beispiel ben√∂tige ich RESTinio, um die Anforderungsverarbeitungsaktionen zu protokollieren.  Daher habe ich <code>logger_t</code> dass es sich vom Standardwert <code>null_logger_t</code> .  Aber seitdem  RESTinio funktioniert tats√§chlich mit mehreren Threads (RESTinio verarbeitet eingehende Anforderungen im Hauptthread, die Antworten stammen jedoch von einem separaten Arbeitsthread). Dann ben√∂tigen Sie einen threadsicheren Logger, <code>shared_ostream_logger_t</code> . </p><br><p>  In process_thread_func <code>processing_thread_func()</code> wird die SObjectizer-Funktion <code>select()</code> , die dem Go select-Konstrukt etwas √§hnelt: Sie k√∂nnen Nachrichten von mehreren Kan√§len gleichzeitig lesen und verarbeiten.  Die Funktion <code>select()</code> funktioniert so lange, bis alle an sie √ºbergebenen Kan√§le geschlossen sind.  Oder bis ihr gewaltsam gesagt wird, dass es Zeit ist zu enden. </p><br><p>  Wenn der Kanal f√ºr die Kommunikation mit dem RESTinio-Server geschlossen ist, macht es keinen Sinn, die Arbeit fortzusetzen.  Daher wird in <code>select()</code> die Reaktion auf das Schlie√üen eines der Kan√§le bestimmt: Sobald ein Kanal geschlossen wird, wird das Stoppflag gehisst.  Dies f√ºhrt zum Abschluss von <code>select()</code> und zum Beenden von <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Speichern des response_builder-Objekts </h3><br><p>  Im vorherigen Beispiel haben wir einen einfachen Fall betrachtet, in dem es m√∂glich ist, <code>request_handle_t</code> zu speichern, bis wir sofort die gesamte Antwort auf die Anforderung geben k√∂nnen. </p><br><p>  Es kann jedoch komplexere Szenarien geben, in denen Sie beispielsweise teilweise eine Antwort geben m√ºssen.  Das hei√üt, wir erhalten eine Anfrage, wir k√∂nnen sofort nur den ersten Teil der Antwort bilden.  Wir bilden es.  Nach einiger Zeit haben wir dann die M√∂glichkeit, den zweiten Teil der Antwort zu bilden.  Dann, nach einiger Zeit, k√∂nnen wir den n√§chsten Teil usw. bilden. </p><br><p>  Dar√ºber hinaus kann es f√ºr uns w√ºnschenswert sein, dass alle diese Teile verschwinden, wenn wir sie bilden.  Das hei√üt,  Zuerst der erste Teil der Antwort, damit der Client sie subtrahieren kann, dann der zweite, dann der dritte usw. </p><br><p>  Mit RESTinio k√∂nnen Sie dies aufgrund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedener Arten von responce_builders tun</a> .  Insbesondere Typen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">user_controlled_output</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chunked_output</a> . </p><br><p>  In diesem Fall reicht es nicht aus, <code>request_handle_t</code> zu speichern, da <code>request_handle_t</code> nur bis zum ersten Aufruf von <code>create_reponse()</code> n√ºtzlich ist.  Als n√§chstes m√ºssen wir mit response_builder arbeiten.  Na und... </p><br><p>  Nun, das ist okay.  Response_builder ist ein beweglicher Typ, der unique_ptr √§hnelt.  So k√∂nnen wir es auch so lange behalten, wie wir es brauchen.  Und um zu zeigen, wie es aussieht, wiederholen wir das obige Beispiel leicht.  Lassen Sie die Funktion <code>processing_thread_func()</code> die Antwort in Teilen bilden. </p><br><p>  Das ist √ºberhaupt nicht schwierig. </p><br><p>  Zuerst m√ºssen wir uns f√ºr die Typen entscheiden, die new <code>processing_thread_func()</code> ben√∂tigt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  Die Nachricht <code>handle_request</code> bleibt unver√§ndert.  In der Nachricht <code>timeout_elapsed</code> speichern wir jetzt nicht <code>request_handle_t</code> , sondern response_builder des Typs, den wir ben√∂tigen.  Plus einen Z√§hler der restlichen Teile.  Sobald dieser Z√§hler zur√ºckgesetzt wird, endet der Anforderungsdienst. </p><br><p>  Jetzt k√∂nnen wir uns eine neue Version der Funktion <code>processing_thread_func()</code> ansehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  Das hei√üt,     ,        .       .         . </p><br><p>  <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  Das hei√üt,    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p> ,   ,      RESTinio ‚Äî   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451728/">https://habr.com/ru/post/de451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451718/index.html">Sprachassistenten erstellen</a></li>
<li><a href="../de451720/index.html">FIAS wird durch improvisierte (SQLXMLBULKLOAD) Mittel in die Datenbank von MSSQLSERVER geladen. Wie es (wahrscheinlich) nicht gemacht werden muss</a></li>
<li><a href="../de451722/index.html">Qt-asynchrone asynchrone Widget-Bibliothek</a></li>
<li><a href="../de451724/index.html">Skyrmion zu Skyrmion Zwietracht: dreidimensionale polare Skyrmionen in Ferroelastik</a></li>
<li><a href="../de451726/index.html">Arbeitssuche im Ausland: 7 einfache Tipps f√ºr IT-Profis</a></li>
<li><a href="../de451738/index.html">Kurzer R√ºckblick auf den Artikel "DeViSE: Ein tiefes visuell-semantisches Einbettungsmodell"</a></li>
<li><a href="../de451742/index.html">Einen Tag vor DotNext 2019 Piter. Kostenlose Broadcast-Ank√ºndigung</a></li>
<li><a href="../de451746/index.html">MegaSlerm f√ºr Ingenieure und Architekten Kubernetes</a></li>
<li><a href="../de451748/index.html">√úberwachen des SSD-Status in Qsan-Arrays</a></li>
<li><a href="../de451750/index.html">Buch "Elasticsearch, Kibana, Logstash und Suchmaschinen der n√§chsten Generation"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>