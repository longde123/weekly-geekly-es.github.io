<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚ÄçüöÄ üòï üë† Como os processadores s√£o projetados e fabricados: o b√°sico da arquitetura de computadores üõÄüèΩ üàµ üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Percebemos o processador central como o "c√©rebro" de um computador, mas o que isso realmente significa? O que exatamente acontece dentro dos bilh√µes d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os processadores s√£o projetados e fabricados: o b√°sico da arquitetura de computadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="imagem"></div><br>  Percebemos o processador central como o "c√©rebro" de um computador, mas o que isso realmente significa?  O que exatamente acontece dentro dos bilh√µes de transistores que fazem um computador funcionar?  Em nossa nova miniss√©rie de quatro artigos, consideraremos o processo de cria√ß√£o da arquitetura de equipamentos de computador e discutiremos os princ√≠pios de sua opera√ß√£o. <br><br>  Nesta s√©rie, falaremos sobre arquitetura de computadores, design de placas de processador, VLSI (integra√ß√£o em grande escala), fabrica√ß√£o de chips e tend√™ncias futuras no campo da tecnologia de computadores.  Se voc√™ estava interessado em entender os detalhes dos processadores, √© melhor come√ßar o estudo com esta s√©rie de artigos. <br><br>  Come√ßaremos com uma explica√ß√£o de alto n√≠vel sobre o que o processador faz e como os blocos de constru√ß√£o se conectam a uma estrutura funcional.  Em particular, consideraremos n√∫cleos de processador, hierarquia de mem√≥ria, previs√£o de ramifica√ß√£o e muito mais.  Primeiro, precisamos dar uma defini√ß√£o simples do que a CPU faz.  A explica√ß√£o mais simples: o processador segue um conjunto de instru√ß√µes para executar uma certa opera√ß√£o em muitos dados recebidos.  Por exemplo, ele pode ler um valor da mem√≥ria, adicion√°-lo a outro valor e, finalmente, salvar o resultado na mem√≥ria em um endere√ßo diferente.  Pode ser algo mais complicado, por exemplo, a divis√£o de dois n√∫meros, se o resultado do c√°lculo anterior for maior que zero. <br><br>  Programas, como um sistema operacional ou um jogo, s√£o seq√º√™ncias de instru√ß√µes que a CPU deve executar.  Essas instru√ß√µes s√£o carregadas da mem√≥ria e executadas em um processador simples, uma ap√≥s a outra, at√© o programa terminar.  Os desenvolvedores de software escrevem programas em linguagens de alto n√≠vel, como C ++ ou Python, mas o processador n√£o pode entend√™-los.  Ele entende apenas zeros e zeros, portanto, precisamos representar de alguma forma o c√≥digo nesse formato. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br>  Os programas s√£o compilados em um conjunto de instru√ß√µes de baixo n√≠vel chamado <em>linguagem assembly</em> , que faz parte da arquitetura do conjunto de instru√ß√µes (ISA).  Este √© um conjunto de instru√ß√µes que a CPU deve entender e executar.  Alguns dos ISAs mais comuns s√£o x86, MIPS, ARM, RISC-V e PowerPC.  Da mesma maneira que a sintaxe para escrever uma fun√ß√£o em C ++ difere da fun√ß√£o que executa a mesma a√ß√£o em Python, cada ISA possui sua pr√≥pria sintaxe diferente. <br><br>  Esses ISAs podem ser divididos em duas categorias principais: comprimento fixo e vari√°vel.  O ISA RISC-V usa instru√ß√µes de comprimento fixo, o que significa que um n√∫mero predeterminado de bits em cada instru√ß√£o determina que tipo de instru√ß√£o √©.  No x86, tudo √© diferente, ele usa instru√ß√µes de comprimento vari√°vel.  No x86, as instru√ß√µes podem ser codificadas de diferentes maneiras, com diferentes n√∫meros de bits para diferentes partes.  Devido a essa complexidade, o decodificador de instru√ß√µes no processador x86 geralmente √© a parte mais complexa de todo o dispositivo. <br><br>  As instru√ß√µes de comprimento fixo fornecem decodifica√ß√£o simples devido a uma estrutura constante, mas limitam o n√∫mero total de instru√ß√µes que podem ser suportadas pelo ISA.  Embora as vers√µes populares da arquitetura RISC-V possuam aproximadamente 100 instru√ß√µes e todas sejam de c√≥digo aberto, a arquitetura x86 √© propriet√°ria e ningu√©m sabe quantas instru√ß√µes existem nela.  Geralmente, acredita-se que existem v√°rios milhares de instru√ß√µes x86, mas ningu√©m publica o n√∫mero exato.  Apesar das diferen√ßas entre os ISAs, todos eles t√™m a mesma funcionalidade b√°sica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>  <i>Um exemplo de algumas instru√ß√µes do RISC-V.</i>  <i>O c√≥digo de opera√ß√£o √† direita tem 7 bits e determina o tipo de instru√ß√£o.</i>  <i>Al√©m disso, cada instru√ß√£o cont√©m bits que definem os registradores utilizados e as fun√ß√µes executadas.</i>  <i>Portanto, as instru√ß√µes do assembler s√£o divididas em c√≥digo bin√°rio para que o processador o entenda.</i> <br><br>  Agora estamos prontos para ligar o computador e come√ßar a executar programas.  A execu√ß√£o da instru√ß√£o possui v√°rias partes b√°sicas, que s√£o divididas em v√°rios est√°gios do processador. <br><br>  O primeiro est√°gio √© a transfer√™ncia de instru√ß√µes da mem√≥ria para o processador para iniciar a execu√ß√£o.  Na segunda etapa, a instru√ß√£o √© decodificada para que a CPU possa entender que tipo de instru√ß√£o √©.  Existem muitos tipos, incluindo instru√ß√µes aritm√©ticas, instru√ß√µes de ramifica√ß√£o e instru√ß√µes de mem√≥ria.  Depois que a CPU descobre que tipo de instru√ß√£o est√° executando, os operandos da instru√ß√£o s√£o retirados da mem√≥ria ou dos registros internos da CPU.  Se voc√™ deseja adicionar o n√∫mero A e o n√∫mero B, n√£o poder√° adicion√°-lo at√© conhecer os valores de A e B. A maioria dos processadores modernos s√£o de 64 bits, ou seja, o tamanho de cada valor de dados √© de 64 bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>  <i>64 bits √© a largura do registro do processador, canal de dados e / ou endere√ßo de mem√≥ria.</i>  <i>Para usu√°rios comuns, isso significa quanta informa√ß√£o um computador pode processar por vez, e isso √© melhor compreendido em compara√ß√£o com um parente de arquitetura mais jovem - um processador de 32 bits.</i>  <i>A arquitetura de 64 bits pode processar o dobro de bits de informa√ß√£o por vez (64 bits versus 32).</i> <br><br>  Depois de receber os operandos para a instru√ß√£o, o processador os transfere para o est√°gio de execu√ß√£o, onde a opera√ß√£o √© executada nos dados recebidos.  Isso pode incluir n√∫meros, executar manipula√ß√µes l√≥gicas com n√∫meros ou simplesmente passar n√∫meros sem alter√°-los.  Ap√≥s calcular o resultado, pode ser necess√°rio acessar a mem√≥ria para armazen√°-lo ou o processador pode simplesmente armazenar o valor em um de seus registros internos.  Depois de salvar o resultado, a CPU atualiza o estado dos v√°rios elementos e prossegue para a pr√≥xima instru√ß√£o. <br><br>  Essa explica√ß√£o, √© claro, √© bastante simplificada, e a maioria dos processadores modernos divide esses v√°rios est√°gios em 20 ou at√© mais pequenos est√°gios para aumentar a efici√™ncia.  Isso significa que, embora o processador inicie e termine com v√°rias instru√ß√µes em cada ciclo, pode levar 20 ou mais ciclos para executar uma instru√ß√£o do in√≠cio ao fim.  Esse modelo geralmente √© chamado de gasoduto ("gasoduto", geralmente traduzido para o russo como "transportador"), porque leva tempo para encher o gasoduto com l√≠quido e conclu√≠-lo, mas ap√≥s o preenchimento do fluxo (sa√≠da de dados) ser√° constante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>  <i>Um exemplo de transportador de 4 est√°gios.</i>  <i>Ret√¢ngulos multicoloridos indicam instru√ß√µes independentes entre si.</i> <br><br>  Todo o ciclo pelo qual a instru√ß√£o passa √© um processo coordenado com muito cuidado, mas nem todas as instru√ß√µes podem ser conclu√≠das ao mesmo tempo.  Por exemplo, a adi√ß√£o √© muito r√°pida e a divis√£o ou carregamento da mem√≥ria pode levar milhares de ciclos.  Em vez de parar o processador inteiro at√© a conclus√£o de uma instru√ß√£o lenta, a maioria dos processadores modernos os executa com uma mudan√ßa de ordem.  Ou seja, eles determinam qual das instru√ß√µes √© mais vantajosa para executar no momento e armazenam em buffer outras instru√ß√µes que ainda n√£o est√£o prontas.  Se a instru√ß√£o atual ainda n√£o estiver pronta, o processador poder√° avan√ßar no c√≥digo para ver se alguma outra coisa est√° pronta. <br><br>  Al√©m de executar com uma sequ√™ncia de altera√ß√µes, os processadores modernos usam uma tecnologia chamada <em>arquitetura superescalar</em> .  Isso significa que a qualquer momento, o processador executa simultaneamente v√°rias instru√ß√µes em cada est√°gio do pipeline.  Ele tamb√©m pode esperar que outras centenas iniciem sua execu√ß√£o e, para poder executar v√°rias instru√ß√µes simultaneamente dentro dos processadores, existem v√°rias c√≥pias de cada est√°gio do pipeline.  Se o processador vir que duas instru√ß√µes est√£o prontas para execu√ß√£o e n√£o houver depend√™ncia entre elas, n√£o esperar√° at√© que sejam conclu√≠das separadamente, mas as executar√° simultaneamente.  Uma implementa√ß√£o popular dessa arquitetura √© chamada SMT (Multithreading Simult√¢neo) e tamb√©m √© conhecida como Hyper-Threading.  Os processadores Intel e AMD agora suportam SMT de dupla face, enquanto a IBM desenvolveu chips que suportam at√© oito SMTs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br>  Para concluir esta execu√ß√£o cuidadosamente coordenada, o processador, al√©m do n√∫cleo b√°sico, possui muitos elementos adicionais.  O processador possui centenas de m√≥dulos separados, cada um com uma fun√ß√£o espec√≠fica, mas consideraremos apenas o b√°sico.  Os mais importantes e lucrativos s√£o os caches e o preditor de transi√ß√µes.  Existem outras estruturas adicionais que n√£o consideraremos: reordenar buffers, registrar tabelas de renomea√ß√£o e esta√ß√µes de backup. <br><br>  √Äs vezes, a necessidade de caches pode ser confusa, porque eles armazenam dados, como RAM ou SSD.  Mas os caches diferem em lat√™ncia e velocidade de acesso.  Embora a mem√≥ria RAM seja extremamente r√°pida, √© uma ordem de magnitude mais lenta do que a CPU precisa.  Podem ser necess√°rias centenas de ciclos para responder com a transfer√™ncia de dados de RAM e o processador n√£o ter√° nada a fazer no momento.  E se n√£o houver dados na RAM, pode levar dezenas de milhares de ciclos para obter acesso a eles a partir do SSD.  Sem caches, os processadores paravam constantemente. <br><br>  Os processadores normalmente t√™m tr√™s n√≠veis de cache que comp√µem a chamada <em>hierarquia de mem√≥ria</em> .  O cache L1 √© o menor e mais r√°pido, o L2 est√° no meio e o L3 √© o maior e mais lento de todos os caches.  Acima dos caches na hierarquia existem pequenos registros que armazenam o √∫nico valor de dados durante os c√°lculos.  Em ordem de magnitude, esses registros s√£o os dispositivos de armazenamento mais r√°pidos do sistema.  Quando o compilador converte um programa de alto n√≠vel em linguagem assembly, ele determina a melhor maneira de usar esses registros. <br><br>  Quando a CPU solicita dados da mem√≥ria, primeiro verifica se esses dados j√° est√£o armazenados no cache L1.  Nesse caso, voc√™ pode acess√°-los em apenas alguns ciclos.  Se eles n√£o estiverem l√°, o processador verificar√° L2 e, em seguida, o cache L3.  Os caches s√£o implementados de maneira que, em geral, sejam transparentes ao kernel.  O kernel simplesmente solicita dados no endere√ßo de mem√≥ria especificado e o n√≠vel na hierarquia em que existe responde.  Ao passar para n√≠veis subseq√ºentes na hierarquia de mem√≥ria, o tamanho e os atrasos geralmente aumentam em ordens de magnitude.  No final, se a CPU n√£o encontrar dados em nenhum dos caches, ela acessa a mem√≥ria principal (RAM). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br>  Em um processador comum, cada n√∫cleo possui dois caches L1: um para dados e outro para instru√ß√µes.  Os caches L1 geralmente t√™m uma capacidade total de cerca de 100 kilobytes e o tamanho varia muito, dependendo da gera√ß√£o do chip e do processador.  Al√©m disso, geralmente cada n√∫cleo possui seu pr√≥prio cache L2, embora em algumas arquiteturas seja comum a dois n√∫cleos.  Os caches L2 geralmente t√™m v√°rias centenas de kilobytes de tamanho.  Por fim, existe um √∫nico cache L3 comum a todos os n√∫cleos, com um tamanho da ordem de dezenas de megabytes. <br><br>  Quando o processador executa o c√≥digo, as instru√ß√µes e valores de dados usados ‚Äã‚Äãcom mais freq√º√™ncia s√£o armazenados em cache.  Isso acelera significativamente a execu√ß√£o, porque o processador n√£o precisa acessar constantemente a mem√≥ria principal para obter os dados necess√°rios.  Na segunda e terceira partes da s√©rie, falaremos mais sobre como esses sistemas de mem√≥ria s√£o implementados. <br><br>  Al√©m dos caches, um dos componentes mais importantes de um processador moderno √© um <em>preditor de transi√ß√£o</em> preciso.  As instru√ß√µes de transi√ß√£o (ramifica√ß√£o) s√£o semelhantes √†s constru√ß√µes if do processador.  Um conjunto de instru√ß√µes √© executado se a condi√ß√£o for verdadeira e o outro se for falso.  Por exemplo, precisamos comparar dois n√∫meros e, se forem iguais, execute uma fun√ß√£o e, se n√£o forem iguais, execute outra.  Essas instru√ß√µes de ramifica√ß√£o s√£o extremamente comuns e podem representar cerca de 20% de todas as instru√ß√µes em um programa. <br><br>  √Ä primeira vista, parece que essas instru√ß√µes de ramifica√ß√£o n√£o devem causar problemas, mas sua execu√ß√£o adequada pode ser muito dif√≠cil para o processador.  A qualquer momento, o processador pode estar executando simultaneamente dez ou vinte instru√ß√µes; portanto, √© muito importante saber <em>quais</em> instru√ß√µes executar.  Pode levar 5 ciclos para determinar que a instru√ß√£o atual √© uma transi√ß√£o e outros 10 para determinar se a condi√ß√£o √© verdadeira.  No momento, o processador j√° pode come√ßar a executar dezenas de instru√ß√µes adicionais, sem nem mesmo saber se essas instru√ß√µes s√£o realmente adequadas para execu√ß√£o. <br><br>  Para contornar esse problema, todos os processadores modernos de alto desempenho usam uma t√©cnica chamada especula√ß√£o.  Isso significa que o processador controla as instru√ß√µes da ramifica√ß√£o e se pergunta se a ramifica√ß√£o condicional ser√° executada ou n√£o.  Se a previs√£o estiver correta, o processador j√° come√ßou a executar as seguintes instru√ß√µes, e isso fornece um aumento de desempenho.  Se a previs√£o estiver incorreta, o processador interromper√° a execu√ß√£o, excluir√° todas as instru√ß√µes incorretas que come√ßaram a executar e iniciar√° novamente a partir do ponto correto. <br><br>  Esses preditores de ramifica√ß√£o s√£o alguns dos tipos mais simples de aprendizado de m√°quina, porque o preditor estuda o comportamento das ramifica√ß√µes durante a execu√ß√£o.  Se ele predizer incorretamente com muita frequ√™ncia, ele come√ßa a aprender o comportamento correto.  D√©cadas de pesquisas sobre t√©cnicas de previs√£o de transi√ß√£o resultaram em mais de 90% de precis√£o de previs√£o nos processadores modernos. <br><br>  Embora a antecipa√ß√£o ofere√ßa um enorme aumento no desempenho, porque o processador pode executar instru√ß√µes que j√° est√£o prontas, em vez de esperar na fila pela conclus√£o da execu√ß√£o, tamb√©m cria vulnerabilidades de seguran√ßa.  O famoso ataque Spectre explora bugs na previs√£o e antecipa√ß√£o de transi√ß√µes.  O invasor usa c√≥digo especialmente selecionado para for√ßar o processador a executar proativamente o c√≥digo, o que resulta em um vazamento de valores da mem√≥ria.  Para evitar vazamento de dados, foi necess√°rio refazer o design de certos aspectos da antecipa√ß√£o, o que levou a uma leve queda no desempenho. <br><br>  Nas √∫ltimas d√©cadas, a arquitetura usada nos processadores modernos percorreu um longo caminho.  A inova√ß√£o e o desenvolvimento de uma estrutura bem pensada levaram ao aumento da produtividade e ao uso mais otimizado do hardware.  No entanto, os desenvolvedores dos processadores centrais mant√™m cuidadosamente os segredos de suas tecnologias, para que n√£o possamos descobrir exatamente o que est√° acontecendo dentro deles.  No entanto, os princ√≠pios fundamentais dos processadores s√£o padronizados para todas as arquiteturas e modelos.  A Intel pode adicionar seus ingredientes secretos para aumentar o compartilhamento de hits do cache, e a AMD pode adicionar um preditor de transi√ß√£o aprimorado, mas os processadores de ambas as empresas executam a mesma tarefa. <br><br>  Neste primeiro olhar e revis√£o, abordamos o b√°sico de como os processadores funcionam.  Na pr√≥xima parte, mostraremos como desenvolver os componentes que comp√µem os processadores, falar sobre elementos l√≥gicos, frequ√™ncias de clock, gerenciamento de energia, circuitos e muito mais. <br><br><h5>  Leitura Recomendada </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A hist√≥ria do microprocessador e do computador pessoal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologia de exibi√ß√£o comparada: TN vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VA vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Batalha na CPU de 4GHz: AMD 2nd-Gen Ryzen vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel de 8a gera√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© limita√ß√£o t√©rmica e como evit√°-la</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456922/">https://habr.com/ru/post/pt456922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456904/index.html">Carregar teste de um projeto da web - sem dinheiro</a></li>
<li><a href="../pt456908/index.html">Como o Telegram funde voc√™ com a Rostelecom</a></li>
<li><a href="../pt456910/index.html">Projeto de Internet security.txt - conhecendo outro arquivo .well conhecido</a></li>
<li><a href="../pt456912/index.html">Como criar sites em 2019</a></li>
<li><a href="../pt456920/index.html">Sony Xperia 1 na R√∫ssia - pre√ßo e b√¥nus de pr√©-venda</a></li>
<li><a href="../pt456926/index.html">Como fazemos Sportmaster</a></li>
<li><a href="../pt456928/index.html">JMeter - Faca de Testador Su√≠√ßo (Parte 1)</a></li>
<li><a href="../pt456930/index.html">Trazendo a IoT para as massas: resultados da primeira IoT-hackathon da GeekBrains e Rostelecom</a></li>
<li><a href="../pt456932/index.html">OpenGL ultramoderno. Parte 1</a></li>
<li><a href="../pt456936/index.html">Cart√µes animados no SwiftUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>