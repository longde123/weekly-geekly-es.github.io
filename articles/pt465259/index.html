<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ üì£ üÜñ ValueTask <TResult> - por que, por que e como? üö¶ üåá üêå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio da tradu√ß√£o 


 Ao contr√°rio dos artigos cient√≠ficos, √© dif√≠cil traduzir artigos desse tipo "perto do texto", e uma adapta√ß√£o bastante forte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult> - por que, por que e como?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>Pref√°cio da tradu√ß√£o</em> </h3><br><p>  <em>Ao contr√°rio dos artigos cient√≠ficos, √© dif√≠cil traduzir artigos desse tipo "perto do texto", e uma adapta√ß√£o bastante forte deve ser feita.</em>  <em>Por esse motivo, pe√ßo desculpas por algumas liberdades, da minha parte, ao lidar com o texto do artigo original.</em>  <em>Sou guiado por apenas um objetivo - tornar a tradu√ß√£o compreens√≠vel, mesmo que em alguns lugares ela se desvie fortemente do artigo original.</em>  <em>Eu ficaria grato por cr√≠ticas construtivas e corre√ß√µes / acr√©scimos √† tradu√ß√£o.</em> </p><br><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p> O namespace <code>System.Threading.Tasks</code> e a classe <code>Task</code> foram introduzidos pela primeira vez no .NET Framework 4. Desde ent√£o, esse tipo e sua classe derivada <code>Task&lt;TResult&gt;</code> entraram firmemente na pr√°tica de programa√ß√£o no .NET e tornaram-se aspectos-chave do modelo ass√≠ncrono. implementado em C # 5, com seu <code>async/await</code> .  Neste artigo, falarei sobre novos tipos de <code>ValueTask/ValueTask&lt;TResult&gt;</code> que foram introduzidos com o objetivo de aumentar o desempenho do c√≥digo ass√≠ncrono, nos casos em que a sobrecarga ao trabalhar com mem√≥ria desempenha um papel fundamental. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task">  Tarefa </h2><br><p>  <code>Task</code> serve a v√°rios prop√≥sitos, mas o principal √© a "promessa" - um objeto que representa a capacidade de aguardar a conclus√£o de uma opera√ß√£o.  Voc√™ inicia a opera√ß√£o e obt√©m a <code>Task</code> .  Esta <code>Task</code> ser√° conclu√≠da quando a opera√ß√£o em si for conclu√≠da.  Nesse caso, existem tr√™s op√ß√µes: </p><br><ol><li>  A opera√ß√£o √© conclu√≠da de forma s√≠ncrona no encadeamento do iniciador.  <em>Por exemplo, ao acessar alguns dados que j√° est√£o no buffer</em> . </li><li>  A opera√ß√£o √© executada de forma ass√≠ncrona, mas consegue concluir <em>quando o</em> iniciador recebe a <code>Task</code> .  <em>Por exemplo, ao executar acesso r√°pido a dados que ainda n√£o foram armazenados em buffer</em> </li><li>  A opera√ß√£o √© executada de forma ass√≠ncrona e termina <em>ap√≥s o</em> iniciador receber a <code>Task</code> <em>exemplo √© o recebimento de dados em uma rede</em> . </li></ol><br><p>  Para obter o resultado de uma chamada ass√≠ncrona, o cliente pode bloquear o segmento de chamada enquanto aguarda a conclus√£o, o que geralmente contradiz a id√©ia de assincronia, ou fornecer um m√©todo de retorno de chamada que ser√° executado ap√≥s a conclus√£o da opera√ß√£o ass√≠ncrona.  O modelo de retorno de chamada no .NET 4 foi apresentado explicitamente, usando o m√©todo <code>ContinueWith</code> de um objeto da classe <code>Task</code> , que recebeu um delegado chamado ap√≥s a conclus√£o da opera√ß√£o ass√≠ncrona. </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Com o .NET Frmaework 4.5 e C # 5, o resultado de uma opera√ß√£o ass√≠ncrona foi simplificado com a introdu√ß√£o das palavras-chave <code>async/await</code> e o mecanismo por tr√°s delas.  Esse mecanismo, o c√≥digo gerado, √© capaz de otimizar todos os casos mencionados acima, manipulando corretamente a conclus√£o, apesar do caminho em que foi atingido. </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  A classe <code>Task</code> √© bastante flex√≠vel e possui v√°rias vantagens.  Por exemplo, voc√™ pode "esperar" um objeto dessa classe v√°rias vezes, o resultado de forma competitiva, por qualquer n√∫mero de consumidores.  Inst√¢ncias de uma classe podem ser armazenadas em um dicion√°rio para qualquer n√∫mero de chamadas subsequentes, com o objetivo de "aguardar" no futuro.  Os cen√°rios descritos permitem considerar objetos de <code>Task</code> como um tipo de cache de resultados obtidos de forma ass√≠ncrona.  Al√©m disso, o <code>Task</code> fornece a capacidade de bloquear o thread em espera at√© que a opera√ß√£o seja conclu√≠da, se o script exigir.  H√° tamb√©m o chamado.  combinadores para v√°rias estrat√©gias para aguardar a conclus√£o de conjuntos de tarefas, por exemplo, "Task.WhenAny" - aguardando assincronamente a conclus√£o da primeira de muitas tarefas. </p><br><p>  Por√©m, o caso de uso mais comum √© simplesmente iniciar uma opera√ß√£o ass√≠ncrona e aguardar o resultado de sua execu√ß√£o.  Um caso t√£o simples, bastante comum, n√£o requer a flexibilidade acima: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Isso √© muito semelhante √† forma como escrevemos c√≥digo s√≠ncrono (por exemplo, <code>TResult result = SomeOperation();</code> ).  Esta op√ß√£o √© naturalmente traduzida em <code>async/await</code> . </p><br><p>  Al√©m disso, por todos os seus m√©ritos, o tipo de <code>Task</code> tem uma falha em potencial.  <code>Task</code> √© uma classe, o que significa que toda opera√ß√£o que cria uma inst√¢ncia de uma tarefa aloca um objeto no heap.  Quanto mais objetos criamos, mais trabalho √© exigido do GC e mais recursos s√£o gastos no trabalho do coletor de lixo, recursos que podem ser usados ‚Äã‚Äãpara outros fins.  Isso se torna um problema claro para o c√≥digo, no qual, por um lado, as inst√¢ncias de <code>Task</code> s√£o criadas com freq√º√™ncia e, por outro lado, o que aumenta os requisitos de taxa de transfer√™ncia e desempenho. </p><br><p>  O tempo de execu√ß√£o e as principais bibliotecas, em muitas situa√ß√µes, conseguem mitigar esse efeito.  Por exemplo, se voc√™ escrever um m√©todo como o abaixo: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  e, na maioria das vezes, haver√° espa√ßo suficiente no buffer, a opera√ß√£o ser√° finalizada de forma s√≠ncrona.  Nesse caso, n√£o h√° nada de especial na tarefa retornada, n√£o h√° valor de retorno e a opera√ß√£o j√° est√° conclu√≠da.  Em outras palavras, estamos lidando com a <code>Task</code> , o equivalente a uma opera√ß√£o <code>void</code> s√≠ncrona.  Nessas situa√ß√µes, o tempo de execu√ß√£o simplesmente armazena em cache o objeto <code>Task</code> e o usa sempre como resultado para qualquer <code>async Task</code> - um m√©todo que termina de forma s√≠ncrona ( <code>Task.ComletedTask</code> ).  Outro exemplo, digamos que voc√™ escreva: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Suponha, da mesma maneira, que na maioria dos casos, haja alguns dados no buffer.  O m√©todo verifica <code>_bufferedCount</code> , v√™ que a vari√°vel √© maior que zero e retorna <code>true</code> .  Somente se no momento da verifica√ß√£o os dados n√£o foram armazenados em buffer, uma opera√ß√£o ass√≠ncrona √© necess√°ria.  Seja como for, existem apenas dois resultados l√≥gicos poss√≠veis ( <code>true</code> e <code>false</code> ) e apenas dois estados de retorno poss√≠veis por meio da <code>Task&lt;bool&gt;</code> .  Com base na conclus√£o s√≠ncrona, ou ass√≠ncrona, mas antes de sair do m√©todo, o tempo de execu√ß√£o armazena em cache duas inst√¢ncias da <code>Task&lt;bool&gt;</code> (uma para <code>true</code> e outra para <code>false</code> ) e retorna a desejada, evitando aloca√ß√µes adicionais.  A √∫nica op√ß√£o quando voc√™ precisa criar um novo objeto <code>Task&lt;bool&gt;</code> √© um caso de execu√ß√£o ass√≠ncrona, que termina ap√≥s o "retorno".  Nesse caso, o m√©todo precisa criar um novo objeto <code>Task&lt;bool&gt;</code> , porque  no momento da sa√≠da do m√©todo, o resultado da conclus√£o da opera√ß√£o ainda n√£o √© conhecido.  O objeto retornado deve ser exclusivo, porque  ele armazenar√° o resultado da opera√ß√£o ass√≠ncrona. </p><br><p>  Existem outros exemplos de armazenamento em cache semelhante no tempo de execu√ß√£o.  Mas essa estrat√©gia n√£o √© aplic√°vel em todos os lugares.  Por exemplo, o m√©todo: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  tamb√©m frequentemente termina de forma s√≠ncrona.  Mas, diferentemente do exemplo anterior, esse m√©todo retorna um resultado inteiro que possui aproximadamente quatro bilh√µes de valores poss√≠veis.  Para armazenar em cache a <code>Task&lt;int&gt;</code> , nessa situa√ß√£o, seriam necess√°rias centenas de gigabytes de mem√≥ria.  O ambiente aqui tamb√©m suporta um pequeno cache para a <code>Task&lt;int&gt;</code> , para v√°rios valores pequenos.  Portanto, por exemplo, se a opera√ß√£o for conclu√≠da de forma s√≠ncrona (os dados est√£o presentes no buffer), com um resultado de 4, o cache ser√° usado.  Por√©m, se o resultado, embora s√≠ncrono, for 42, um novo objeto <code>Task&lt;int&gt;</code> ser√° criado, semelhante √† chamada <code>Task.FromResult(42)</code> . </p><br><p>  Muitas implementa√ß√µes de bibliotecas tentam atenuar essas situa√ß√µes, suportando seus pr√≥prios caches.  Um exemplo √© a sobrecarga do <code>MemoryStream.ReadAsync</code> .  Esta opera√ß√£o, introduzida no .NET Framework 4.5, sempre termina de forma s√≠ncrona, porque  √© apenas uma leitura da mem√≥ria.  <code>ReadAsync</code> retorna uma <code>Task&lt;int&gt;</code> onde o resultado inteiro representa o n√∫mero de bytes lidos.  Muitas vezes, no c√≥digo, ocorre uma situa√ß√£o quando o <code>ReadAsync</code> usado em um loop.  Al√©m disso, se houver os seguintes sintomas: </p><br><ul><li>  O n√∫mero de bytes solicitados n√£o muda para a maioria das itera√ß√µes do loop; </li><li>  Na maioria das itera√ß√µes, o <code>ReadAsync</code> pode ler o n√∫mero solicitado de bytes. </li></ul><br><p>  Ou seja, para chamadas repetidas, o <code>ReadAsync</code> √© executado de forma s√≠ncrona e retorna um objeto <code>Task&lt;int&gt;</code> , com o mesmo resultado de itera√ß√£o para itera√ß√£o.  √â l√≥gico que o <code>MemoryStream</code> cache a √∫ltima tarefa conclu√≠da com √™xito e, para todas as chamadas subseq√ºentes, se o novo resultado corresponder ao anterior, ele retornar√° uma inst√¢ncia do cache.  Se o resultado n√£o corresponder, o <code>Task.FromResult</code> usado para criar uma nova inst√¢ncia, que, por sua vez, tamb√©m ser√° armazenada em cache antes de retornar. </p><br><p>  Por√©m, h√° muitos casos em que uma opera√ß√£o √© for√ßada a criar novos objetos <code>Task&lt;TResult&gt;</code> , mesmo quando conclu√≠dos de forma s√≠ncrona. </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; e conclus√£o s√≠ncrona </h2><br><p>  Tudo isso serviu de motiva√ß√£o para a introdu√ß√£o de um novo tipo de <code>ValueTask&lt;TResult&gt;</code> no .NET Core 2.0.  Al√©m disso, por meio do pacote nuget <code>System.Threading.Tasks.Extensions</code> , esse tipo foi disponibilizado em outras vers√µes do .NET. </p><br><p>  <code>ValueTask&lt;TResult&gt;</code> foi introduzido no .NET Core 2.0 como uma estrutura capaz de agrupar <code>TResult</code> ou <code>Task&lt;TResult&gt;</code> .  Isso significa que objetos desse tipo podem ser retornados do m√©todo <code>async</code> .  A primeira vantagem da introdu√ß√£o desse tipo √© imediatamente vis√≠vel: se o m√©todo for conclu√≠do com √™xito e de forma s√≠ncrona, n√£o ser√° necess√°rio criar nada no heap, apenas o suficiente para criar uma inst√¢ncia do <code>ValueTask&lt;TResult&gt;</code> com o valor resultante.  Somente se o m√©todo sair assincronamente, precisamos criar uma <code>Task&lt;TResult&gt;</code> .  Nesse caso, <code>ValueTask&lt;TResult&gt;</code> usado como um inv√≥lucro na <code>Task&lt;TResult&gt;</code> .  A decis√£o de tornar o <code>ValueTask&lt;TResult&gt;</code> capaz de agregar a <code>Task&lt;TResult&gt;</code> foi tomada com o objetivo de otimiza√ß√£o: em caso de sucesso e em caso de falha, o m√©todo ass√≠ncrono cria a <code>Task&lt;TResult&gt;</code> , do ponto de vista da otimiza√ß√£o da mem√≥ria, √© melhor agregar a <code>Task&lt;TResult&gt;</code> pr√≥prio objeto <code>Task&lt;TResult&gt;</code> que para manter campos adicionais no <code>ValueTask&lt;TResult&gt;</code> para v√°rios casos de conclus√£o (por exemplo, para armazenar uma exce√ß√£o). </p><br><p>  Dado o exposto, n√£o √© mais necess√°rio armazenar em cache m√©todos como o <code>MemoryStream.ReadAsync</code> acima, mas pode ser implementado da seguinte maneira: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt; e finaliza√ß√£o ass√≠ncrona </h2><br><p>  Ter a capacidade de escrever m√©todos ass√≠ncronos que n√£o exigem aloca√ß√µes de mem√≥ria adicionais para o resultado, com conclus√£o s√≠ncrona, √© realmente uma grande vantagem.  Conforme mencionado acima, esse era o principal objetivo da introdu√ß√£o do novo tipo <code>ValueTask&lt;TResult&gt;</code> no .NET Core 2.0.  Todos os novos m√©todos que devem ser usados ‚Äã‚Äãnas "estradas quentes" agora usam <code>ValueTask&lt;TResult&gt;</code> vez de <code>Task&lt;TResult&gt;</code> como o tipo de retorno.  Por exemplo, uma nova sobrecarga do m√©todo <code>ReadAsync</code> para <code>Stream</code> , no .NET Core 2.1 (que usa a <code>Memory&lt;byte&gt;</code> vez de <code>byte[]</code> como par√¢metro), retorna uma inst√¢ncia de <code>ValueTask&lt;int&gt;</code> .  Isso permitiu reduzir significativamente o n√∫mero de aloca√ß√µes ao trabalhar com fluxos (muitas vezes o m√©todo <code>ReadAsync</code> termina de forma s√≠ncrona, como no exemplo com <code>MemoryStream</code> ). </p><br><p>  No entanto, ao desenvolver servi√ßos com alta largura de banda, em que a termina√ß√£o ass√≠ncrona n√£o √© incomum, precisamos fazer o poss√≠vel para evitar aloca√ß√µes adicionais. </p><br><p>  Como mencionado anteriormente, no modelo <code>async/await</code> , qualquer opera√ß√£o que seja conclu√≠da de forma ass√≠ncrona deve retornar um objeto exclusivo para aguardar a conclus√£o.  √önico porque  servir√° como um canal para realizar retornos de chamada.  Observe, no entanto, que essa constru√ß√£o n√£o diz nada sobre se o objeto de espera retornado pode ser <em>reutilizado</em> ap√≥s a conclus√£o da opera√ß√£o ass√≠ncrona.  Se um objeto puder ser reutilizado, a API poder√° manter um pool para esses tipos de objetos.  Mas, nesse caso, esse pool n√£o pode suportar acesso simult√¢neo - um objeto do pool passar√° do estado "conclu√≠do" para o estado "n√£o conclu√≠do" e vice-versa. </p><br><p>  Para oferecer suporte √† possibilidade de trabalhar com esses pools, a interface <code>IValueTaskSource&lt;TResult&gt;</code> foi adicionada ao .NET Core 2.1 e a estrutura <code>ValueTask&lt;TResult&gt;</code> foi expandida: agora os objetos desse tipo podem envolver n√£o apenas os objetos do tipo <code>TResult</code> ou <code>Task&lt;TResult&gt;</code> , mas tamb√©m inst√¢ncias de <code>IValueTaskSource&lt;TResult&gt;</code> .  A nova interface fornece funcionalidade b√°sica que permite que objetos <code>ValueTask&lt;TResult&gt;</code> trabalhem com <code>IValueTaskSource&lt;TResult&gt;</code> da mesma maneira que com a <code>Task&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code> destinado ao uso na propriedade <code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> - permite descobrir se a opera√ß√£o foi conclu√≠da ou n√£o (com √™xito ou n√£o).  <code>OnCompleted</code> usado no <code>ValueTask&lt;TResult&gt;</code> para acionar um retorno de chamada.  <code>GetResult</code> usado para obter o resultado ou lan√ßar uma exce√ß√£o. </p><br><p>  √â improv√°vel que a maioria dos desenvolvedores precise lidar com a interface <code>IValueTaskSource&lt;TResult&gt;</code> , porque  m√©todos ass√≠ncronos, quando retornados, ocultam-no atr√°s da <code>ValueTask&lt;TResult&gt;</code> .  A interface em si √© direcionada principalmente para aqueles que desenvolvem APIs de alto desempenho e procura evitar trabalho desnecess√°rio com muitos. </p><br><p>  No .NET Core 2.1, existem v√°rios exemplos desse tipo de API.  O mais famoso deles s√£o as novas sobrecargas dos m√©todos <code>Socket.ReceiveAsync</code> e <code>Socket.SendAsync</code> .  Por exemplo: </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Objetos do tipo <code>ValueTask&lt;int&gt;</code> s√£o usados ‚Äã‚Äãcomo o valor de retorno. <br>  Se o m√©todo sair de forma s√≠ncrona, ele retornar√° uma <code>ValueTask&lt;int&gt;</code> com o valor correspondente: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Se a opera√ß√£o for conclu√≠da de forma ass√≠ncrona, ser√° usado um objeto em cache que implementa a interface <code>IValueTaskSource&lt;TResult&gt;</code> : </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  A implementa√ß√£o do <code>Socket</code> suporta um objeto em cache para recebimento e outro para envio de dados, desde que cada um deles seja usado sem concorr√™ncia (n√£o, por exemplo, envio de dados competitivos).  Essa estrat√©gia reduz a quantidade de mem√≥ria adicional alocada, mesmo no caso de execu√ß√£o ass√≠ncrona. <br>  A otimiza√ß√£o descrita do <code>Socket</code> no .NET Core 2.1 teve um impacto positivo no desempenho do <code>NetworkStream</code> .  Sua sobrecarga √© o m√©todo <code>ReadAsync</code> da classe <code>Stream</code> : </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  apenas delega o trabalho para o m√©todo <code>Socket.ReceiveAsync</code> .  Aumentar a efici√™ncia do m√©todo soquete, em termos de trabalho com mem√≥ria, aumenta a efici√™ncia do m√©todo <code>NetworkStream</code> . </p><br><h2 id="non-generic-valuetask">  ValueTask n√£o gen√©rico </h2><br><p>  Anteriormente, observei v√°rias vezes que o objetivo original do <code>ValueTask&lt;T&gt;</code> , no .NET Core 2.0, era otimizar casos de conclus√£o s√≠ncrona de m√©todos com um resultado "n√£o vazio".  Isso significa que n√£o havia necessidade de uma <code>ValueTask</code> n√£o digitada: nos casos de conclus√£o s√≠ncrona, os m√©todos usam um singleton por meio da propriedade <code>Task.CompletedTask</code> , e o tempo de execu√ß√£o dos m√©todos de <code>async Task</code> tamb√©m √© recebido implicitamente. </p><br><p>  Mas, com o advento da capacidade de evitar aloca√ß√µes desnecess√°rias e com execu√ß√£o ass√≠ncrona, a necessidade de um <code>ValueTask</code> n√£o digitado novamente se tornou relevante.  Por esse motivo, no .NET Core 2.1, introduzimos <code>ValueTask</code> n√£o <code>ValueTask</code> e <code>IValueTaskSource</code> .  Eles s√£o an√°logos dos tipos gen√©ricos correspondentes e s√£o usados ‚Äã‚Äãda mesma maneira, mas para m√©todos com um retorno vazio ( <code>void</code> ). </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt">  Implementar IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p>  A maioria dos desenvolvedores n√£o precisar√° implementar essas interfaces.  E sua implementa√ß√£o n√£o √© uma tarefa f√°cil.  Se voc√™ decidir implement√°-los, ent√£o, dentro do .NET Core 2.1, h√° v√°rias implementa√ß√µes que podem servir como exemplos: </p><br><ul><li>  <a href="">AwaitableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;TResult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p>  Para simplificar essas tarefas (implementa√ß√µes de <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ), planejamos introduzir o tipo <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> no .NET Core 3.0.  Essa estrutura encapsular√° toda a l√≥gica necess√°ria.  A <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> pode ser usada em outro objeto que implementa <code>IValueTaskSource&lt;TResult&gt;</code> e / ou <code>IValueTaskSource</code> e delegar a maior parte do trabalho.  Voc√™ pode aprender mais sobre isso em ttps: //github.com/dotnet/corefx/issues/32664. </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks">  O modelo correto para usar ValueTasks </h2><br><p>  Mesmo um exame superficial <code>ValueTask</code> que <code>ValueTask</code> e <code>ValueTask&lt;TResult&gt;</code> mais limitados que <code>Task</code> e <code>Task&lt;TResult&gt;</code> .  E isso √© normal, at√© desej√°vel, porque o objetivo principal √© aguardar a conclus√£o da execu√ß√£o ass√≠ncrona. </p><br><p>  Em particular, surgem limita√ß√µes significativas devido ao fato de que <code>ValueTask</code> e <code>ValueTask&lt;TResult&gt;</code> podem agregar objetos reutiliz√°veis.  Em geral, as seguintes opera√ß√µes * <em>NUNCA devem ser executadas ao usar</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * <em>(</em> deixe-me reformular atrav√©s de "Never" *): </p><br><ul><li>  <strong>Nunca use o mesmo <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> repetidamente</strong> </li></ul><br><p>  <em>Motiva√ß√£o: As</em> inst√¢ncias <code>Task</code> e <code>Task&lt;TResult&gt;</code> nunca passam do estado "conclu√≠do" para o estado "incompleto", podemos us√°-las para aguardar o resultado quantas vezes quisermos - ap√≥s a conclus√£o, sempre obteremos o mesmo resultado.  Pelo contr√°rio, desde <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> , eles podem atuar como inv√≥lucros sobre objetos reutilizados, o que significa que seu estado pode mudar, porque  o estado dos objetos reutilizados muda por defini√ß√£o - para passar de "conclu√≠do" para "incompleto" e vice-versa. </p><br><ul><li>  <strong>Nunca <code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>no modo competitivo.</strong> </li></ul><br><p>  <em>Motiva√ß√£o: um</em> objeto empacotado espera trabalhar com apenas um retorno de chamada, de um √∫nico consumidor de cada vez, e tentar competir antecipadamente pode facilmente levar a condi√ß√µes de corrida e sutis erros de programa√ß√£o.  Expectativas competitivas, esta √© uma das op√ß√µes descritas acima, <strong>m√∫ltiplas expectativas</strong> .  Observe que a <code>Task</code> / <code>Task&lt;TResult&gt;</code> permite qualquer n√∫mero de expectativas competitivas. </p><br><ul><li>  <strong>Nunca use <code>.GetAwaiter().GetResult()</code> at√© que a opera√ß√£o seja conclu√≠da</strong> . </li></ul><br><p>  <em>Motiva√ß√£o: As</em> implementa√ß√µes de <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code> n√£o devem suportar o bloqueio at√© que a opera√ß√£o seja conclu√≠da.  De fato, o bloqueio leva a uma condi√ß√£o de corrida; √© improv√°vel que esse seja o comportamento esperado por parte do consumidor.  Enquanto <code>Task</code> / <code>Task&lt;TResult&gt;</code> permite fazer isso, bloqueando o encadeamento de chamada at√© que a opera√ß√£o seja conclu√≠da. </p><br><p>  Mas e se, no entanto, voc√™ precisar <code>ValueTask</code> uma das opera√ß√µes descritas acima e o m√©todo chamado retornar inst√¢ncias de <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ?  Para esses casos, o <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> fornece o m√©todo <code>.AsTask()</code> .  Ao chamar esse m√©todo, voc√™ obter√° uma inst√¢ncia de <code>Task</code> / <code>Task&lt;TResult&gt;</code> e j√° poder√° executar a opera√ß√£o necess√°ria.  Reutilizar o objeto original ap√≥s chamar <code>.AsTask()</code> <em>n√£o</em> √© <em>permitido</em> . </p><br><p> <strong>  </strong> : <em>    <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,   ( <code>await</code> )   (,    <code>.ConfigureAwait(false)</code> ),   <code>.AsTask()</code> ,        <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> .</em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method‚Ä¶ public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); ‚Ä¶ // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>    , "",  ,       (    ,      ). </p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    ‚Äî <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   .  Porque    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe">  O que vem a seguir? </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   ‚Äî <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465259/">https://habr.com/ru/post/pt465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465247/index.html">Angular No√ß√µes b√°sicas sobre @Input, @Output e EventEmitter</a></li>
<li><a href="../pt465249/index.html">Palestra de Richard Stallman no Polit√©cnico de Moscou. Agosto 2019</a></li>
<li><a href="../pt465251/index.html">O ver√£o est√° quase no fim. Quase nenhum dado vazou</a></li>
<li><a href="../pt465255/index.html">Implementa√ß√£o do conjunto de conex√µes WCF para .Net Core usando HttpClientFactory</a></li>
<li><a href="../pt465257/index.html">‚ÄúCuidado, FAS!‚Äù: Truques do McDonald's, shawarma divino, Clooney falso e um pouco de magia das ruas</a></li>
<li><a href="../pt465261/index.html">O poder m√°gico das macros ou como facilitar a vida de um programador de assembler AVR</a></li>
<li><a href="../pt465263/index.html">Bloqueios no PostgreSQL: 3. Bloqueia outros objetos</a></li>
<li><a href="../pt465267/index.html">TypeScript Express√£o M√°gica</a></li>
<li><a href="../pt465269/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 26. DNS e DHCP</a></li>
<li><a href="../pt465271/index.html">Os hackers roubam e lavam dinheiro atrav√©s de servi√ßos de entrega de comida e reserva de hotel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>