<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≥ üìå üóØÔ∏è WebSockets en Angular: cree un servicio angular para trabajar con sockets web ‚ÜòÔ∏è ‚öîÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, tratar√© de cubrir en detalle el alcance limitado de la tecnolog√≠a dentro del marco del marco angular y su asistente ya integral: RxJ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets en Angular: cree un servicio angular para trabajar con sockets web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="imagen"><br>  En este art√≠culo, tratar√© de cubrir en detalle el alcance limitado de la tecnolog√≠a dentro del marco del marco angular y su asistente ya integral: RxJs, mientras que no tocaremos deliberadamente las implementaciones del servidor, como  Este es un tema completo para un art√≠culo separado. <br><br>  Este texto ser√° √∫til para aquellos que ya est√°n familiarizados con Angular, pero desean profundizar sus conocimientos directamente sobre el tema. <br><a name="habracut"></a><br>  Primero, alguna informaci√≥n b√°sica. <br><br><h2>  ¬øQu√© es WebSocket y por qu√© lo necesita? </h2><br><blockquote>  Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> , WebSocket es un "protocolo de comunicaci√≥n d√∫plex (puede transmitir y recibir al mismo tiempo) a trav√©s de una conexi√≥n TCP, dise√±ado para la mensajer√≠a en tiempo real entre un navegador y un servidor web. <br>  WebSocket est√° dise√±ado para implementarse en navegadores web y servidores web, pero se puede usar para cualquier aplicaci√≥n cliente o servidor.  El protocolo WebSocket es un protocolo independiente basado en el protocolo TCP.  Permite una interacci√≥n m√°s estrecha entre el navegador y el sitio web, facilitando la distribuci√≥n de contenido interactivo y la creaci√≥n de aplicaciones en tiempo real ". <br></blockquote><br>  En otras palabras, WebSocket permite que el servidor reciba solicitudes del cliente y env√≠e solicitudes al cliente en cualquier momento deseado, por lo tanto, el navegador (cliente) y el servidor reciben los mismos derechos y la capacidad de intercambiar mensajes cuando se conecta.  Una solicitud AJAX regular requiere la transmisi√≥n de encabezados HTTP completos, lo que significa un mayor tr√°fico en ambas direcciones, mientras que la sobrecarga de los sockets web despu√©s de establecer una conexi√≥n es de solo dos bytes.  El socket web reduce la cantidad de informaci√≥n transmitida en los encabezados HTTP cientos y miles de veces y reduce significativamente el tiempo de espera.  Las conexiones de socket web admiten dominios cruzados como CORS. <br><br>  En el lado del servidor, hay paquetes para admitir el socket web, en el cliente es la API HTML5 WebSocket, que tiene una interfaz de tres m√©todos: <br><br>  <b><i>WebSocket</i></b> : la interfaz principal para conectarse a un servidor WebSocket y luego enviar y recibir datos a trav√©s de la conexi√≥n; <br>  <b><i>CloseEvent</i></b> : un evento enviado por el objeto WebSocket cuando se cerr√≥ la conexi√≥n; <br>  <b><i>MessageEvent</i></b> : un evento enviado por un WebSocket cuando se recibe un mensaje del servidor. <br><br>  As√≠ es como se ve en el nivel de implementaci√≥n de JavaSript: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - escucha mensajes del servidor <br>  <b><i>enviar</i></b> : env√≠a tus mensajes al servidor <br><br>  Es decir, en su forma b√°sica, todo es extremadamente simple, pero si desea profundizar en el tema, puede recurrir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDN Web Docs</a> y al mismo tiempo estudiar bibliotecas que implementan sus propias capas en la parte superior de esta API. <br><br><h2>  ¬øPor qu√© no tener miedo de usar WebSocket? </h2><br>  El primer punto que puede asustar es el <b>soporte del navegador</b> .  Hoy en d√≠a no existe tal problema: WebSocket es compatible casi por completo tanto en la web como en el segmento m√≥vil. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="imagen"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  El segundo punto es la <b>facilidad de implementaci√≥n</b> .  S√≠, al principio esto es desalentador. <br><br>  La API es tan simple que a primera vista puede ser dif√≠cil entender c√≥mo trabajar con un n√∫mero tan modesto de m√©todos, porque todos, excepto uno, informan errores o conexiones, y solo uno de ellos, <b><i>onmessage</i></b> , lleva para qu√© sockets web se utilizan, es decir  para recibir datos del servidor. <br><br>  Al mismo tiempo, el problema es que el servidor generalmente env√≠a datos diferentes, por lo tanto, ¬ønecesitamos varios mensajes diferentes?  ¬øO necesita crear su propia conexi√≥n para cada modelo de datos? <br><br>  Entonces, la tarea: debe aceptar el modelo de usuario y el √∫ltimo modelo de noticias del servidor, y tal vez incluso algo m√°s. <br><br>  Me he encontrado con una implementaci√≥n tan "elegante": <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  A primera vista, todo es l√≥gico.  Pero ahora imagine c√≥mo se ver√° si hay docenas o cientos de ellos.  En uno de los proyectos en los que trabaj√©, hubo unos trescientos eventos. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="imagen"><br><br>  Solucionamos el problema. <br><br>  Todas las bibliotecas de terceros para trabajar con sockets web le permiten suscribirse a mensajes del tipo addEventListener.  Se ve as√≠: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Como sabemos, podemos operar con un solo m√©todo: un <b><i>mensaje</i></b> , que recibe todos los datos como parte de su conexi√≥n, por lo que este c√≥digo parece algo inusual.  Esto se implementa de la siguiente manera: <b><i>onmessage</i></b> devuelve un <b><i>mensaje de evento</i></b> que contiene el campo de <b><i>datos</i></b> .  Son los <b><i>datos que</i></b> contienen la informaci√≥n que el servidor nos env√≠a.  Este objeto se ve as√≠: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  donde <b><i>evento</i></b> es la clave por la cual es posible determinar qu√© informaci√≥n envi√≥ el servidor.  A continuaci√≥n, en el lado frontal, se crea un bus que filtra la informaci√≥n por evento y la env√≠a a la direcci√≥n deseada: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Esto permite recibir datos diferentes dentro de la misma conexi√≥n y suscribirse a ellos a trav√©s de una sintaxis similar a la habitual para los eventos JS. <br><br><h2>  WebSockets en Angular </h2><br>  Finalmente, llegamos a lo m√°s importante: usar WebSockets directamente en Angular. <br><br>  A pesar de la simplicidad de trabajar con la API nativa de WebSocket, en este art√≠culo usaremos RxJs, lo cual, por supuesto, porque estamos hablando de Angular. <br><br>  La API nativa de WebSocket se puede usar en aplicaciones en Angular, crear una interfaz f√°cil de usar sobre la base, RxJs Observable, suscribirse a los mensajes necesarios, etc., pero RxJs ya ha hecho el trabajo principal para usted: WebSocketSubject es un envoltorio reactivo sobre el WebSocket est√°ndar API  No crea un bus de eventos ni vuelve a conectar el procesamiento.  Este es un tema normal, con el que puede trabajar con sockets web de estilo reactivo. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Por lo tanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocketSubject</a> espera <a href="">WebSocketSubjectConfig</a> y un destino opcional, en el que puede pasar un enlace a su Asunto observado, crea un Observable a trav√©s del cual puede escuchar y enviar mensajes para enchufes web. <br><br>  En pocas palabras, pase la url de conexi√≥n como argumento a WebSocketSubject y suscr√≠base a toda la actividad del socket web de la manera habitual para RxJs.  Y si necesita enviar un mensaje al servidor, utilice el mismo m√©todo habitual webSocketSubject.next (data). <br><br><h2>  Hacemos un servicio para trabajar con WebSocket Angular </h2><br>  Describa brevemente lo que esperamos del servicio: <br><br><ul><li>  Interfaz unificada y concisa; </li><li>  Posibilidad de configuraci√≥n a nivel de conexi√≥n de dependencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DI</a> ; </li><li>  La posibilidad de reutilizaci√≥n; </li><li>  Mecanograf√≠a; </li><li>  La capacidad de suscribirse para recibir informaci√≥n por clave; </li><li>  Posibilidad de rescindir una suscripci√≥n; </li><li>  Enviar mensajes al servidor; </li><li>  Reconectar </li></ul><br>  Vale la pena prestar especial atenci√≥n al √∫ltimo punto.  La reconexi√≥n, o la organizaci√≥n de reconectarse al servidor, es un factor primordial cuando se trabaja con sockets web, como  interrupciones de la red, fallas del servidor u otros errores que causan una interrupci√≥n de la conexi√≥n pueden hacer que la aplicaci√≥n se bloquee <br><br>  Es importante tener en cuenta que los intentos de reconexi√≥n <b>no deber√≠an ser demasiado frecuentes</b> y no deber√≠an continuar indefinidamente, ya que  Este comportamiento puede suspender al cliente. <br><br>  Empecemos <br><br>  En primer lugar, crearemos una interfaz de configuraci√≥n de servicio y un m√≥dulo que proporcionar√° la capacidad de configurar cuando est√© conectado. <br><br>  Si es posible, acortar√© el c√≥digo, la versi√≥n completa que puedes ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la comunidad angular de habla rusa en GitHub</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  A continuaci√≥n, debemos describir la interfaz del mensaje del sitio web: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  donde <b><i>evento</i></b> es la clave, y los <b><i>datos</i></b> obtenidos por la clave es un modelo escrito. <br><br>  La interfaz p√∫blica del servicio se ve as√≠: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  El servicio tiene campos: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  En el constructor de la clase de servicio, obtenemos el objeto WebSocketConfig especificado cuando se conect√≥ el m√≥dulo: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  El m√©todo de conexi√≥n en s√≠ es simple: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  Reconectarse es un poco m√°s complicado: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  El m√©todo <b><i>on</i></b> , tambi√©n es extremadamente simple, no hay nada que comentar. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  El m√©todo de <b><i>env√≠o</i></b> es a√∫n m√°s simple: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  Ese es todo el servicio.  Como puede ver, la mayor parte del c√≥digo recay√≥ en la organizaci√≥n de la reconexi√≥n. <br><br>  Veamos ahora c√≥mo usarlo.  Conecte el m√≥dulo WebsocketModule: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  En el constructor de componentes, inyectamos el servicio y nos suscribimos a los mensajes de ' <b><i>mensajes</i></b> ', enviamos el texto de vuelta al servidor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  El nombre de los eventos es m√°s conveniente para poner en constantes o enumeraciones.  Creamos en alg√∫n lugar el archivo websocket.events.ts y lo escribimos en √©l: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  Reescribe las suscripciones usando el objeto WS creado: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="imagen"><br><br><h2>  En conclusi√≥n </h2><br>  Eso, de hecho, es todo.  Este es un m√≠nimo necesario que un desarrollador Angular necesita saber sobre WebSockets.  Espero haber cubierto este tema con bastante claridad.  La versi√≥n completa del servicio se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  Para todas las preguntas puede contactarme en los comentarios, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a m√≠</a> en Telegram o en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el canal Angular</a> en el mismo lugar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416155/">https://habr.com/ru/post/es416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416143/index.html">El libro "¬°Se mostrar√° una autopsia!" An√°lisis pr√°ctico de malware ¬ª</a></li>
<li><a href="../es416147/index.html">Organizaci√≥n de la navegaci√≥n en aplicaciones iOS usando el Root Controller</a></li>
<li><a href="../es416149/index.html">Preguntas y respuestas sobre energ√≠as renovables, parte 1</a></li>
<li><a href="../es416151/index.html">Globo adimensional. An√°lisis utilitario de la dimensi√≥n m√°gica</a></li>
<li><a href="../es416153/index.html">¬øLos aviones se volver√°n m√°s confiables? Los fabricantes de aviones presentan robots a las empresas</a></li>
<li><a href="../es416157/index.html">En los brazos de Python (solo mujeres)</a></li>
<li><a href="../es416159/index.html">C√≥mo nos encargaron comparar un erizo con una serpiente</a></li>
<li><a href="../es416161/index.html">10 razones [para no] usar k8s</a></li>
<li><a href="../es416163/index.html">Aprende OpenGL. Lecci√≥n 5.6 - Mapeo de paralaje</a></li>
<li><a href="../es416167/index.html">Peter Norwig: Aprenda programaci√≥n en ... 10 a√±os</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>