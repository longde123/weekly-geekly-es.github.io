<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•î üêó ü§π Verwenden von Intel Processor Trace zur Verfolgung des Systemverwaltungsmoduscodes üèÅ ‚ú® ü§µüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit dem Testen der M√∂glichkeit, mithilfe der Intel Processor Trace-Technologie (Intel PT) Tracks im SMM-Modus (System Mana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Intel Processor Trace zur Verfolgung des Systemverwaltungsmoduscodes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/481692/"><p><img src="https://habrastorage.org/webt/ek/w6/yn/ekw6ynxfsk4gnib6pbdy0glmkxy.png"></p><br><p>  Dieser Artikel befasst sich mit dem Testen der M√∂glichkeit, mithilfe der Intel Processor Trace-Technologie (Intel PT) Tracks im SMM-Modus (System Management Mode) aufzuzeichnen.  Diese Arbeit wurde im Rahmen von Summer Of Hack 2019 <a href="https://twitter.com/sysenter_eip">durchgef√ºhrt</a> . <a href="https://twitter.com/sysenter_eip">Gepostet</a> von <a href="https://twitter.com/sysenter_eip">@sysenter_eip</a> . </p><br><p>  Die meisten verwendeten Tools wurden von anderen Personen geschrieben (insbesondere <a href="https://twitter.com/d_olex">@d_olex</a> , <a href="https://twitter.com/aionescu">@aionescu</a> ).  Das Ergebnis ist nur eine Kombination der verf√ºgbaren Tools, um den Codeausf√ºhrungspfad im SMM-Modus f√ºr <strong>ein bestimmtes</strong> Motherboard abzurufen.  Das Material kann jedoch f√ºr diejenigen interessant sein, die dies f√ºr ihre Plattform wiederholen m√∂chten oder einfach nur an der Arbeit von SMM interessiert sind. </p><a name="habracut"></a><br><h2 id="system-management-mode">  Systemverwaltungsmodus </h2><br><p> SMM ist ein spezieller privilegierter Modus des x86-Architekturprozessors, der verf√ºgbar ist, w√§hrend das Betriebssystem ausgef√ºhrt wird, aber f√ºr diesen vollst√§ndig unsichtbar ist.  Es wurde f√ºr die Interaktion mit Eisen auf niedriger Ebene, f√ºr die Energieverwaltung, die Emulation √§lterer Ger√§te, den √úbergang in den Ruhemodus (S3), den Zugriff auf TPM und mehr entwickelt.  Es funktioniert v√∂llig isoliert vom Betriebssystem.  W√§hrend der Ausf√ºhrung von SMM stoppt das Betriebssystem vollst√§ndig.  Der in diesem Modus ausgef√ºhrte Programmcode wird im SPI-Flash-Speicher des Motherboards gespeichert und ist Teil der UEFI-BIOS-Firmware. </p><br><p>  Das Umschalten in den SMM-Modus erfolgt √ºber spezielle SMI-Unterbrechungen (System Management Interrupt).  Eine der Optionen f√ºr diesen Interrupt ist f√ºr die Verwendung im Nullring (d. H. Vom Betriebssystemkern) verf√ºgbar - SMI-Interrupt auf Anwendungsebene (Software-SMI).  Weiter werden wir uns auf diese Unterbrechungen konzentrieren. </p><br><p>  Aufgrund seines hohen Privilegs ist SMM f√ºr die Sicherheitsforschung von besonderem Interesse.  Die Kompromittierung von SMM f√ºhrt zu schwerwiegenden Verst√∂√üen gegen die Integrit√§t und Vertraulichkeit des gesamten Systems. In den meisten F√§llen k√∂nnen Sie b√∂sartigen Code, der nicht gel√∂scht werden kann und vom Betriebssystem nicht erkannt wird, in die UEFI-BIOS-Firmware einf√ºgen. </p><br><h2 id="intel-processor-trace">  Intel-Prozessor-Trace </h2><br><p>  Eine der T√ºcken des Debugging-Prozesses f√ºr verschiedene stark ausgelastete Anwendungen ist der Overhead - die Kosten f√ºr das Debuggen von Tools.  Sie k√∂nnen mit einer hardwarebasierten L√∂sung reduziert werden. </p><br><p>  Die f√ºnfte Generation von Prozessoren von Intel (Broadwell) hat der Welt Technologien wie Intel Processor Trace vorgestellt.  Wie ist es n√ºtzlich?  Mit Intel PT k√∂nnen Sie den gesamten Ausf√ºhrungsfluss (Kontrollfluss) der debuggten Anwendung mit minimalem Overhead (&lt;5%) abrufen.  Gleichzeitig unterst√ºtzt es Multithreading und kann bei der Behebung von Fehlern wie "Race Condition" aufgrund der Zeitstempel beim Aufzeichnen des Application Trace helfen.  Zweifellos bietet die Intel PT-Technologie gro√üartige M√∂glichkeiten zum Schreiben von Schwachstellensuchwerkzeugen in Anwendungen. </p><br><p>  Heutzutage wird diese Technologie in verschiedenen Tools zum Nachverfolgen, Debuggen und Auswerten der Codeabdeckung verwendet - sowohl in Anwendungen auf Benutzer- als auch auf Kernelebene.  Beispiele f√ºr Tools finden Sie auf der <a href="https://software.intel.com/en-us/node/721535">Intel-</a> Website.  Eine AFL-Fuzzer-Option, die Intel PT nutzt, ist im <a href="https://github.com/hunter-ht-2018/ptfuzzer">PTfuzzer-</a> Repository verf√ºgbar.  <a href="https://github.com/ohjeongwook/iptanalyzer">Achten Sie bei</a> aktuellen Projekten auf <a href="https://github.com/ohjeongwook/iptanalyzer">iptanalyzer</a> . </p><br><p>  Wir haben jedoch noch keine Arbeit √ºber die Verwendung von Intel PT im SMM-Modus gesehen.  Da uns in diesem Zusammenhang nichts daran hindert, Intel PT zu verwenden, haben wir uns entschlossen, herauszufinden, ob es m√∂glich ist, Code aus dem Systemverwaltungsmodus damit zu verfolgen. </p><br><h2 id="podgotovka-k-rabote">  Vorbereitung auf die Arbeit </h2><br><p>  Aus dem <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">Intel Developer Manual geht hervor,</a> dass es unm√∂glich ist, die Intel PT-Ablaufverfolgung in SMM mit normalen Mitteln von au√üen zu aktivieren.  Wenn es zum Zeitpunkt der Ausl√∂sung des SMI aktiv war, deaktiviert der Prozessor es, bevor die Steuerung an den SMI-Handler-Einstiegspunkt √ºbertragen wird.  Die einzige Aktivierungsmethode ist die freiwillige Einbeziehung des SMI-Handlers durch den Code selbst. </p><br><p>  Auch wenn der Prozessor eine solche Gelegenheit zun√§chst nicht bietet, k√∂nnen wir sie abfangen und Intel PT manuell aktivieren.  Sie m√ºssen jedoch irgendwie feststellen, dass das System bereit ist, die Ablaufverfolgung aufzuzeichnen (die Adresse des Ausgabepuffers ist festgelegt), und die Ablaufverfolgung am Ende der Prozessorausf√ºhrung deaktivieren (Ausf√ºhrung der RSM-Anweisung).  Andernfalls f√§hrt der Prozessor das gesamte System herunter. </p><br><p>  Zun√§chst m√ºssen Sie auf SMRAM zugreifen (den RAM-Bereich, in dem sich der im SMM-Modus ausgef√ºhrte Code befindet).  Da dieser RAM-Bereich gesch√ºtzt ist, k√∂nnen wir vom Betriebssystem aus nicht darauf zugreifen (auch dies ist mit DMA nicht m√∂glich).  Es gibt verschiedene Szenarien: </p><br><ol><li>  eine bekannte Sicherheitsl√ºcke in SMM ausnutzen und das R / W-Grundelement daraus holen.  Dies kann entweder ein Softwarefehler sein (eine Sicherheitsanf√§lligkeit im SMI-Prozessor selbst; in der Regel ist in SMM gen√ºgend Code vorhanden, der vom OEM hinzugef√ºgt wurde, sodass Sicherheitsanf√§lligkeiten keine Seltenheit sind), oder eine anf√§llige Plattformkonfiguration (Entsperren / Verschieben von SMRAM). </li><li>  das UEFI-Image so zu patchen, dass wir eine Schnittstelle zum Lesen und Schreiben an beliebige Adressen haben - eine Hintert√ºr.  Um diese Option zu implementieren, m√ºssen Sie ein Motherboard finden, auf dem Intel Boot Guard deaktiviert ist, oder es gibt Schwachstellen, die dies umgehen k√∂nnen. </li></ol><br><h2 id="vnedrenie-svoego-koda-v-proshivku">  Betten Sie Ihren Code in die Firmware ein </h2><br><p>  Trotz der Tatsache, dass von <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">Zeit</a> zu <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">Zeit</a> SMM-Schwachstellen im Code verschiedener Hersteller gefunden <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">werden</a> , ist es besser, wenn wir uns nicht auf sie verlassen.  F√ºr uns ist es interessanter, den Code f√ºr neue Firmware zu verfolgen und dementsprechend zu versuchen, Schwachstellen darin zu finden.  Wir hatten bereits das GIGABYTE GA-Q270M-D3H-Motherboard mit deaktiviertem Intel Boot Guard. Alles, was wir tun mussten, war, SMM eine Hintert√ºr hinzuzuf√ºgen. </p><br><p><img src="https://habrastorage.org/webt/cj/gs/ub/cjgsubzj6xwovbitbn7dob_tsz4.jpeg"><br>  Abbildung 1. Pr√ºfstand </p><br><p>  Es gibt bereits ein <a href="https://github.com/Cr4sh/SmmBackdoor">Framework, um SMM zu "infizieren" und mit einer Hintert√ºr zu arbeiten</a> .  Es besteht aus drei Komponenten: dem UEFI-Treiber in C, dem "Infector" und dem Client-Skript in Python.  F√ºr den Betrieb m√ºssen Sie einen beliebigen DXE-Treiber extrahieren (dies k√∂nnen Sie mit <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> tun) und ihn mit einem <a href="https://github.com/LongSoft/UEFITool">Infector</a> verarbeiten.  Das urspr√ºngliche Modul wurde durch "Verbessert" ersetzt und die Firmware in den SPI-Speicher hochgeladen (um das Flashen zu vereinfachen, wurde das SPI-Flash-Laufwerk von der Platine entfernt). </p><br><p><img src="https://habrastorage.org/webt/bv/2a/ih/bv2aihyunbskeqjvp6ppqvqhzmi.jpeg"><br>  Abbildung 2. SPI-Flash-Speicherchip </p><br><p>  Das System wurde erfolgreich gestartet, und jetzt haben wir vollen Zugriff auf SMRAM von Python aus (ein Anwendungsbeispiel wird mit der Hintert√ºr bereitgestellt).  Da das Client-Skript f√ºr die Backdoor auf <a href="https://github.com/chipsec/chipsec">CHIPSEC</a> basiert, m√ºssen Sie ihm Zugriff auf den Kernel-Modus gew√§hren (wir haben den RWEverything-Treiber verwendet; es ist praktisch, wenn jemand seinen eigenen CHIPSEC-Treiber mit deaktivierter Signatur√ºberpr√ºfung im System verwendet). </p><br><p>  Sie k√∂nnen die Backdoor √ºberpr√ºfen, indem Sie einen SMRAM-Dump anfordern. </p><br><p><code>$ python SmmBackdoor.py -d</code> </p> <br><p>  Nach dem Ausf√ºhren dieses Befehls wird die Datei SMRAM_dump_cb000000_cb7fffff.bin erstellt, die den aktuellen SMRAM-Status enth√§lt.  Die Werte cb000000 und cb7fffff sind die physikalischen Adressen am Anfang und am Ende des SMRAM. </p><br><h2 id="rabota-s-dampom-smram">  Arbeiten Sie mit Dump-SMRAM </h2><br><p>  Der SMRAM-Speicherauszug kann in einen Disassembler geladen oder zur Analyse an das Skript <a href="https://github.com/Cr4sh/smram_parse">smram_parse.py √ºbergeben werden</a> , das viele n√ºtzliche Informationen f√ºr uns extrahiert.  Am wichtigsten sind f√ºr uns die Adressen der SMI-Einstiegspunkte.  Dies sind die Adressen der Funktionen, an die die Steuerung √ºbertragen wird, wenn SMI ausgel√∂st wird.  Jede CPU hat einen eigenen Einstiegspunkt. </p><br><p><img src="https://habrastorage.org/webt/8a/20/jq/8a20jq29bgn7rhqeim16vqhfxam.png"><br>  Abbildung 3. Die Ausgabe des Skripts smram_parse </p><br><p>  Schauen wir uns ihren Code an.  Da SMM seine Ausf√ºhrung im 16-Bit-Real-Modus startet (die ersten 4 GB RAM spiegeln sich im virtuellen Raum wider), wechselt der Code zun√§chst in den 64-Bit-Modus.  Gleichzeitig ist der gesamte SMRAM mit Schreib- und Ausf√ºhrungsrechten verf√ºgbar, da nur ein Segment erstellt wurde (gibt es Anbieter, die dies anders machen?). </p><br><p>  Wir m√∂chten keinen 16-Bit-Code schreiben oder alles Notwendige vorbereiten, um in den 64-Bit-Modus zu wechseln. Deshalb platzieren wir unseren Interceptor direkt vor dem Aufruf der SMI-Manager-Funktion (diese Funktion legt fest, von welchem ‚Äã‚ÄãSMM-Modul die Ausf√ºhrung √ºbertragen werden soll) welcher Dienst wurde angerufen oder welches Ereignis geschah). </p><br><p><img src="https://habrastorage.org/webt/_u/b0/4k/_ub04kwpncdmptrknltqyl0i3jg.png"><br>  Abbildung 4. Platzierung zum Einh√§ngen </p><br><p>  Die einfachste M√∂glichkeit, die Kontrolle zu √ºbernehmen, besteht darin, die Absenderadresse durch unsere zu ersetzen.  Alle Einstiegspunkte haben den gleichen Code, daher muss der Patch f√ºr jeden wiederholt werden. </p><br><p>  <strong>Hinweis:</strong> Bez√ºglich der Position des Interceptor-Codes.  Da uns die Struktur des SMRAM nicht vollst√§ndig bekannt ist, haben wir einen zuf√§lligen Teil des Nullspeichers in der N√§he eines der Eintrittspunkte ausgew√§hlt, an dem wir den Interceptor-Code platziert haben.  Die beste Option w√§re, Ihr SMM-Modul der Firmware hinzuzuf√ºgen, die UEFI legal in SMRAM ablegen w√ºrde, um nicht zu bef√ºrchten, dass etwas Wichtiges mit unserem Code √ºberschrieben wird. </p><br><h2 id="realizaciya-perehvatchika-dispetchera-smi">  Implementierung eines SMI Manager Interceptors </h2><br><p>  Lassen Sie uns bestimmen, was genau wir in unserem Abfangj√§ger tun werden.  Zuerst m√ºssen wir feststellen, ob Intel PT eingeschaltet war, bevor wir zu SMM wechseln.  Aus der Intel-Dokumentation ist bekannt, dass jeder Prozessor zum Zeitpunkt des √úbergangs zu SMM √ºber eine eigene SMBASE-Basis (MSR 0x9E) und einen eigenen Speicherbereich f√ºr den Prozessorstatus (SMM-Speicherstatusbereich) verf√ºgt. </p><br><p><img src="https://habrastorage.org/webt/bz/ti/i2/bztii2soe7myxor_zprtytfr09q.png"><br>  Abbildung 5. SMBASE-Layout </p><br><h3 id="opredelyaem-sostoyanie-intel-pt">  Wir ermitteln den Status von Intel PT </h3><br><p>  Im SMM Save State muss der Wert des MSR-Registers IA32_RTIT_CTL gespeichert werden, das f√ºr die Verwaltung der Intel PT-Ablaufverfolgung zust√§ndig ist.  Leider gibt Intel Manual nicht an, wo der Prozessor den Status des IA32_RTIT_CTL.TraceEn-Bits zum Zeitpunkt des √úbergangs zu SMM speichert (ob die Ablaufverfolgung aktiviert ist, Null-Bit).  Sie k√∂nnen dies jedoch selbst feststellen, indem Sie den SMM-Speicherstatus zweimal sichern: mit und ohne aktivierter Ablaufverfolgung. </p><br><p>  Wir haben das <a href="https://ionescu007.github.io/winipt/">WinIPT-</a> Tool verwendet, um die Ablaufverfolgung f√ºr den Python-Interpreterprozess zu aktivieren (pid <strong>1337</strong> ), dem Ablaufverfolgungspuffer 2 ^ <strong>12</strong> (4096) Bytes zuzuweisen und dann das Skript SmmBackdoor.py im Interpreter auszuf√ºhren (Argument <strong>0</strong> ist ein Flag, f√ºr uns ist dies nicht der Fall) wichtig, weil Sie in SMM noch Ihre Trace-Einstellungen erzwingen m√ºssen). </p><br><p> <code>$ ipttool.exe --start 1337 12 0</code> </p> <br><p>  Durch Vergleichen der SMRAM-Snapshots haben wir die Position des IA32_RTIT_CTL-Registers in der SMM-Sicherungsstatusstruktur ermittelt.  Es wird am Offset SMBASE + 0xFE3C gespeichert.  Der Status des IA32_RTIT_CTL.TraceEn-Bits ist die Hauptbedingung f√ºr die Intel PT-Reaktivierung in SMM.  Das Feld mit diesem Versatz ist im Intel Developer Manual als Reserviert markiert. </p><br><p><img src="https://habrastorage.org/webt/tf/uy/hx/tfuyhxbfmhemoyy8gh003uo37s8.png"><br>  Abbildung 6. Markieren, dass Felder reserviert sind </p><br><h3 id="pishem-shellcode">  Shellcode schreiben </h3><br><p>  Wir wollten Intel PT nicht in SMM selbst konfigurieren, da dies unseren Shellcode komplizieren w√ºrde (zum Beispiel w√§re es in SMM schwierig, einen gro√üen Teil des Arbeitsspeichers zuzuweisen, damit er nicht vom Betriebssystem selbst verwendet wird).  Aus diesem Grund haben wir uns entschlossen, den bereits konfigurierten Tracer zu verwenden und ihn einfach in SMM zu "√ºberspringen", zumal er bereits die Funktion hat, den Trace in einer Datei zu speichern. </p><br><p>  Da wir zu diesem Zweck WinIPT verwendeten, das zu diesem Zeitpunkt das Tracen des Kernel-Codes (CPL == 0) nicht unterst√ºtzte, war es offensichtlich, dass selbst wenn der Trace in SMM enthalten war, nichts im Protokoll angezeigt wurde, da der SMM-Code mit CPL = 0 ausgef√ºhrt wurde .  Wir m√ºssen einige Filter modifizieren, damit der Tracer w√§hrend der gesamten in SMM verbrachten Zeit arbeiten kann.  Wir listen alles auf, was √ºberpr√ºft und installiert werden muss: </p><br><ol><li>  Das Tracing mit CPL = 0 muss aktiviert sein. </li><li>  Die Ablaufverfolgung f√ºr CPL&gt; 0 muss aktiviert sein (optional). </li><li>  Die g√ºltigen IP-Bereiche f√ºr die Aufzeichnung von Ereignissen m√ºssen deaktiviert sein. </li><li>  IA32_RTIT_STATUS.PacketByteCnt muss zur√ºckgesetzt werden. </li><li>  Die CR3-Filterung muss deaktiviert sein. </li></ol><br><p>  Ein paar Worte sollten √ºber PacketByteCnt gesagt werden.  Dieser Z√§hler bestimmt, an welchem ‚Äã‚ÄãPunkt Sie Synchronisationspakete (eine Folge von mehreren PSB-Befehlen) in den Trace einf√ºgen m√ºssen.  Wir m√ºssen diesen Z√§hler zur√ºcksetzen, da sonst w√§hrend der Verarbeitung der Ablaufverfolgung der Moment des Eintritts in den SMM verpasst wird und die Ablaufverfolgung an einer zuf√§lligen Stelle beginnt, wenn der PSB auf nat√ºrliche Weise generiert wird. </p><br><p>  Unten ist der von uns verwendete Shellcode: </p><br><pre> <code class="plaintext hljs"> sub rsp, 0x18 ; this will align stack at 16 byte boundary (in case SMM ; code uses align dependent instructions) mov qword ptr ss:[rsp+0x10], rcx ; need to save rcx for SMI_Dispatcher mov ecx, 0x9E ; MSR_IA32_SMBASE rdmsr test byte ptr ds:[rax+0xFE3C], 0x1 ; Save State area contains saved ; IA32_RTIT_CTL.TraceEn je short @NoTrace call @Trace_Enable mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall ; (first argument in rcx) mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax call @Trace_Disable add rsp, 0x18 ret @NoTrace: mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax add rsp, 0x18 ret @Trace_Disable: mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov rax, qword ptr ss:[rsp+0x10] ; restore IA32_RTIT_STATUS wrmsr mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov rax, qword ptr ss:[rsp+0x8] ; restore IA32_RTIT_CTL wrmsr ret @Trace_Enable: mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov qword ptr ss:[rsp+0x8], rax ; save IA32_RTIT_STATUS and edx, 0xFFFF0000 ; IA32_RTIT_STATUS.PacketByteCnt = 0 wrmsr mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov qword ptr ss:[rsp+0x10], rax ; save IA32_RTIT_CTL and eax, 0xFFFFFFBF ; IA32_RTIT_CTL.CR3Filter = 0 or eax, 0x5 ; IA32_RTIT_CTL.OS = 1; IA32_RTIT_CTL.User = 1; and edx, 0xFFFF0000 ; IA32_RTIT_CTL.ADDRx_CFG = 0 wrmsr ret</code> </pre> <br><p>  Dieser Code muss in SMRAM abgelegt werden, und der √úbergang zum SMI-Manager muss gepatcht werden, um zu unserem Code zu gelangen.  All dies geschieht mit SmmBackdoor. </p><br><h2 id="rabota-s-trassoy">  Arbeite mit der Strecke </h2><br><p>  Mit dem SMI Manager Interceptor konnten wir den ersten Code-Trace von SMM schreiben.  Der folgende Befehl kann <strong>WinIPT auffordern</strong> , den <strong>Trace</strong> in einer Datei zu speichern: </p><br><p> <code>$ ipttool.exe --trace 1337 trace_file_name</code> </p> <br><p>  Deaktivieren der Ablaufverfolgung f√ºr einen Prozess: </p><br><p> <code>$ ipttool.exe --stop 1337</code> </p> <br><p>  Sie k√∂nnen versuchen, den <strong>Trace</strong> mit dem Dienstprogramm <a href="https://github.com/intel/libipt">dumppt</a> aus <a href="https://github.com/intel/libipt">libipt zu disassemblieren</a> . </p><br><p> <code>$ ptdump.exe --no-pad ./examples/trace_smm_handler_33 &gt; ./examples/trace_smm_handler_33_pt_dump.txt</code> </p> <br><p>  Ausgabebeispiel: </p><br><p><img src="https://habrastorage.org/webt/rr/iq/0e/rriq0ex1jsozdb6yuvicvg0i_ao.png"><br>  Abbildung 7. Der erste SMM-Befehlspfad </p><br><p>  Wir k√∂nnen einige Adressen sehen, es ist jedoch √§u√üerst schwierig, diese Informationen zu verwenden, da sie sehr niedrig sind. </p><br><p>  Um ein besser lesbares Aussehen zu erhalten, gibt es ein <strong>ptxed-</strong> Dienstprogramm (von libipt), das den Trace in ein Protokoll der ausgef√ºhrten Assembler-Anweisungen konvertiert.  Nat√ºrlich m√ºssen wir dem Dienstprogramm einen SMRAM-Speicherauszug bereitstellen, da das IPT-Protokoll keine Informationen √ºber die Werte von Speicherzellen oder welche Anweisungen ausgef√ºhrt wurden enth√§lt.  Es enth√§lt nur Informationen dar√ºber, welche √Ñnderungen im Kontrollfluss aufgetreten sind. </p><br><p> <code>$ ptxed.exe --pt tracesmm_12 --raw SMRAM_dump_cb000000_cb7fffff.bin:0xcb000000 &gt; tracesmm_12_ptasm</code> </p> <br><p><img src="https://habrastorage.org/webt/zb/5q/mh/zb5qmhqp5rlqaa2xi6qydeu0i_o.png"><br>  Abbildung 8. Assembler-Liste entsprechend dem IPT-Protokoll </p><br><p>  Es sieht schon viel besser aus, aber wenn der Code eine Schleife enth√§lt, wird die Ausgabe mit den gleichen Anweisungen verstopft. </p><br><h2 id="opredelyaem-pokrytie-koda-pri-pomoschi-trassy">  Definieren Sie die Codeabdeckung mithilfe der Ablaufverfolgung </h2><br><p>  F√ºr die Visualisierung der Berichterstattung haben wir das <a href="https://github.com/gaasedelen/lighthouse">Lighthouse-</a> Plugin f√ºr IDA Pro ausgew√§hlt, das das DRCOV-Format verwendet. </p><br><p>  Es wurden keine vorgefertigten Tools gefunden. <strong>Daher haben</strong> wir <strong>ptxed</strong> so ge√§ndert, dass dabei auch eine Coverage-Datei generiert wird.  Gepatchtes <strong>ptxed</strong> ist im <a href="https://github.com/sysenter-eip/smm_intel_pt/commit/8b7e23b3353fc04f886b9a226c1a34f768200822">Repository</a> verf√ºgbar.  Sehen Sie sich den Commit-Verlauf an, um festzustellen, was genau hinzugef√ºgt wurde. </p><br><p>  Nach Abschluss von ptxed wird die Datei SMRAM_dump_cb000000_cb7fffff.bin.log angezeigt, die Abdeckungsinformationen im DRCOV-Format enth√§lt. </p><br><p>  <strong>Hinweis:</strong> Bei der Disassembler-Synchronisation auf dem ersten PSB ist ein kleines Problem aufgetreten.  Wenn der PSB vor PGE generiert wird (der Z√§hler wird auf Null zur√ºckgesetzt, bevor der Trace erneut aktiviert wird), kann <strong>ptxed aus</strong> einem nicht ganz eindeutigen Grund nicht darauf synchronisiert werden.  Um dieses Problem zu umgehen, haben wir einen kleinen Patch erstellt.  Es ist nicht klar, ob dies ein Problem f√ºr <strong>ptxed</strong> selbst ist oder ob wir etwas falsch machen, indem wir IA32_RTIT_STATUS.PacketByteCnt zur√ºcksetzen. </p><br><p><img src="https://habrastorage.org/webt/pj/es/cq/pjescq_texdfmus7ljkpzxnrcaq.png"><br>  Abbildung 9. Ein Patch, mit dem Sie das PSB direkt vor dem PGE verwenden k√∂nnen </p><br><p>  Generierte Coverage-Dateien k√∂nnen in IDA Pro heruntergeladen werden und erhalten sch√∂ne Hervorhebungen sowie Statistiken zur prozentualen Abdeckung f√ºr jede Funktion. </p><br><p><img src="https://habrastorage.org/webt/xl/7x/al/xl7xalcnynzuvjrrnrniamo-mzw.png"><br>  Abbildung 10. IDA Pro Lighthouse-Plugin mit Informationen zur Codeabdeckung </p><br><p>  <strong>Hinweis:</strong> Das Lighthouse-Plugin funktioniert bei unvollst√§ndig analysierten Datenbanken etwas seltsam (ausf√ºhrbarer Code ist nicht beschriftet, Funktionen wurden nicht erstellt).  Wir haben dieses "Problem" auf die Funktion get_instructions_slice in der Datei \ lighthouse \ metadata.py zur√ºckgef√ºhrt, in der auch f√ºr die Adresse, an der die Funktion manuell erstellt wurde, 0 Anweisungen zur√ºckgegeben werden.  Das Plugin scheint den Cache zu benutzen und den neuen spezifischen Code zu ignorieren.  Dies kann umgangen werden, indem Sie Reanalyze im Programm aufrufen und IDB erneut √∂ffnen.  Erst danach kann das Plugin den neuen Code sehen und ihn ber√ºcksichtigen.  Da dieses Problem bei einem SMRAM-Speicherauszug (der beim ersten Start fast ausschlie√ülich aus undefiniertem Code besteht) sehr unpraktisch ist, haben wir eine kleine √Ñnderung am Lighthouse-Code vorgenommen, damit wir neuen Code manuell schneller definieren k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/rq/4m/d8/rq4md80-4y5bjhzyqvpgmjeyjpe.png"><br>  Abbildung 11. Es wurde eine Protokollmeldung hinzugef√ºgt, um den neuen Code zu identifizieren </p><br><h2 id="podderzhka-linux">  Linux-Unterst√ºtzung </h2><br><p>  Da alle unsere Tests unter Windows 10 x 64 durchgef√ºhrt wurden (wir ben√∂tigten ipt.sys, das im Windows October Creators Update 2018 ver√∂ffentlicht wurde), lassen Sie uns ein paar Worte √ºber die M√∂glichkeit sagen, dies unter Linux zu implementieren. </p><br><ul><li>  Es gibt ein Linux-Kernel- <strong>Perf-</strong> Modul, das dieselben WinIPT-Aktionen (ipt.sys) ausf√ºhren kann, einschlie√ülich der M√∂glichkeit, Code im Kernel-Modus zu verfolgen. </li><li>  Da die Backdoor-SMM-Oberfl√§che auf dem plattform√ºbergreifenden CHIPSEC-Framework basiert, funktioniert unser Patch auf einem Linux-System ohne √Ñnderungen. </li></ul><br><h2 id="vyvod">  Fazit </h2><br><p>  Wir haben die Aufgabe, einen in SMM ausgef√ºhrten Code-Trace mithilfe der Intel Processor Trace-Technologie zu erhalten, erfolgreich bew√§ltigt.  Ein √§hnliches Ergebnis k√∂nnte mit Hilfe teurer Ger√§te und Software erzielt werden, die nicht an alle verkauft werden.  Es hat uns gereicht, ein Motherboard und einen SPI-Programmierer zur Hand zu haben.  Die Geschwindigkeit der Entfernung der Spur ist wirklich beeindruckend, und es gibt keine Beschwerden √ºber die Genauigkeit des Ergebnisses. </p><br><p>  Wir hoffen, dass dieser Artikel anderen hilft, die Intel PT-Technologie zu nutzen, um Schwachstellen im SMM-Code zu untersuchen und zu suchen.  Die Anpassung unserer Arbeit an andere Motherboards sollte keine Schwierigkeiten verursachen (Intel Boot Guard nicht vergessen).  Die Hauptsache ist, vollst√§ndig zu verstehen, wie es funktioniert.  Am schwierigsten ist es zu bestimmen, wie der SMI-Dispatcher abgefangen und ein Shellcode f√ºr den Interceptor geschrieben werden soll.  In unserer Version wurden "verkabelte" Adressen verwendet, daher sollten Sie den Shellcode sorgf√§ltig auf ein anderes System √ºbertragen. </p><br><p>  Alle verwendeten Tools und Skripte sind im <a href="https://github.com/sysenter-eip/smm_intel_pt">Repository von GitHub</a> verf√ºgbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481692/">https://habr.com/ru/post/de481692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481676/index.html">Sicherheitswoche 52: Sicherheit f√ºr intelligente Lautsprecher und IP-Kameras</a></li>
<li><a href="../de481678/index.html">Pre-Holiday Review: N6IIT01 Player und YB04 Armature Headphones - Hi-Fi aus S√ºdchina</a></li>
<li><a href="../de481680/index.html">TodoMVC auf dap schreiben. Teil 2</a></li>
<li><a href="../de481684/index.html">Ein Laptop von Powerbank?</a></li>
<li><a href="../de481688/index.html">Warum Java lernen und wie man es effizient macht. Yandex-Bericht</a></li>
<li><a href="../de481694/index.html">Mein Weg zur Partitionierung in PostgreSQL</a></li>
<li><a href="../de481696/index.html">Regelw√§chter: Dynamische Pr√ºfungen f√ºr Go</a></li>
<li><a href="../de481698/index.html">WebRTC-Streaming in und um die virtuelle Realit√§t</a></li>
<li><a href="../de481700/index.html">√úber eine Tante</a></li>
<li><a href="../de481702/index.html">Vom Toaster bis zur Drohne. Wie ist das Internet der Dinge entstanden und warum hat es erst 30 Jahre sp√§ter gefeuert?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>