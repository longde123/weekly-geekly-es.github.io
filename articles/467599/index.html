<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∞Ô∏è ‚è´ ‚å®Ô∏è Representaci√≥n de gr√°ficos en 3D con OpenGL ü•© ‚úåüèΩ #‚É£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Renderizar gr√°ficos en 3D no es una tarea f√°cil, pero es extremadamente interesante y emocionante. Este art√≠culo es para aquellos que r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Representaci√≥n de gr√°ficos en 3D con OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  Introduccion </h2><br>  Renderizar gr√°ficos en 3D no es una tarea f√°cil, pero es extremadamente interesante y emocionante.  Este art√≠culo es para aquellos que reci√©n est√°n comenzando a familiarizarse con OpenGL o para aquellos que est√°n interesados ‚Äã‚Äãen c√≥mo funcionan las tuber√≠as gr√°ficas y qu√© son.  Este art√≠culo no proporcionar√° instrucciones exactas sobre c√≥mo crear un contexto y una ventana de OpenGL, o c√≥mo escribir su primera aplicaci√≥n de ventana de OpenGL.  Esto se debe a las caracter√≠sticas de cada lenguaje de programaci√≥n y a la elecci√≥n de una biblioteca o marco para trabajar con OpenGL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar√©</a> C ++ y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GLFW</a> ), especialmente porque es f√°cil encontrar un tutorial en la red para el idioma que le interesa.  Todos los ejemplos dados en el art√≠culo funcionar√°n en otros idiomas con una sem√°ntica de comandos ligeramente cambiada, por qu√© esto es as√≠, lo contar√© un poco m√°s adelante. <br><a name="habracut"></a><br><h2>  ¬øQu√© es OpenGL? </h2><br><p>  OpenGL es una especificaci√≥n que define una interfaz de software independiente de la plataforma para escribir aplicaciones utilizando gr√°ficos por computadora bidimensionales y tridimensionales.  OpenGL no es una implementaci√≥n, sino que solo describe los conjuntos de instrucciones que deben implementarse, es decir,  es una API </p><br><p>  Cada versi√≥n de OpenGL tiene su propia especificaci√≥n, trabajaremos desde la versi√≥n 3.3 a la versi√≥n 4.6, porque  Todas las innovaciones de la versi√≥n 3.3 afectan aspectos que son de poca importancia para nosotros.  Antes de comenzar a escribir su primera aplicaci√≥n OpenGL, le recomiendo que averig√ºe qu√© versiones admite su controlador (puede hacerlo en el sitio del proveedor de su tarjeta de video) y actualice el controlador a la √∫ltima versi√≥n. </p><br><h3>  Dispositivo OpenGL </h3><br><p>  OpenGL se puede comparar con una m√°quina de estado grande, que tiene muchos estados y funciones para cambiarlos.  El estado de OpenGL b√°sicamente se refiere al contexto de OpenGL.  Mientras trabajamos con OpenGL, veremos varias funciones de cambio de estado que cambiar√°n el contexto y realizaremos acciones dependiendo del estado actual de OpenGL. </p><br><p>  Por ejemplo, si le damos a OpenGL el comando de usar l√≠neas en lugar de tri√°ngulos antes de renderizar, OpenGL usar√° las l√≠neas para todas las representaciones posteriores hasta que cambiemos esta opci√≥n o cambiemos el contexto. </p><br><h3>  Objetos en OpenGL </h3><br><p>  Las bibliotecas OpenGL est√°n escritas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C</a> y tienen numerosas API para diferentes lenguajes, pero sin embargo son bibliotecas C.  Muchas construcciones de C no se traducen a lenguajes de alto nivel, por lo que OpenGL se desarroll√≥ utilizando una gran cantidad de abstracciones, una de estas abstracciones son los objetos. </p><br><p>  Un objeto en OpenGL es un conjunto de opciones que determina su estado.  Cualquier objeto en OpenGL puede describirse por su id y el conjunto de opciones de las que es responsable.  Por supuesto, cada tipo de objeto tiene sus propias opciones y un intento de configurar opciones inexistentes para el objeto dar√° lugar a un error.  Ah√≠ reside el inconveniente de usar OpenGL: se describe un conjunto de opciones con una estructura similar en C, cuyo identificador suele ser un n√∫mero, lo que no permite que el programador encuentre un error en la etapa de compilaci√≥n, porque  el c√≥digo err√≥neo y correcto es sem√°nticamente indistinguible. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Encontrar√° ese c√≥digo muy a menudo, por lo que cuando se acostumbre a c√≥mo es configurar una m√°quina de estado, ser√° mucho m√°s f√°cil para usted.  Este c√≥digo solo muestra un ejemplo de c√≥mo funciona OpenGL.  Posteriormente, se presentar√°n ejemplos reales. </p><br><p>  Pero hay ventajas.  La caracter√≠stica principal de estos objetos es que podemos declarar muchos objetos en nuestra aplicaci√≥n, establecer sus opciones, y cada vez que comenzamos las operaciones usando el estado OpenGL, simplemente podemos vincular el objeto con nuestra configuraci√≥n preferida.  Por ejemplo, esto puede ser objetos con datos del modelo 3D o algo que queremos dibujar en este modelo.  Ser propietario de varios objetos facilita el cambio entre ellos durante el proceso de renderizado.  Con este enfoque, podemos configurar muchos objetos necesarios para renderizar y usar sus estados sin perder tiempo valioso entre cuadros. </p><br><p>  Para comenzar a trabajar con OpenGL necesita familiarizarse con varios objetos b√°sicos sin los cuales no podemos mostrar nada.  Usando estos objetos como ejemplo, entenderemos c√≥mo vincular datos e instrucciones ejecutables en OpenGL. </p><br><h2>  Objetos base: sombreadores y programas de sombreadores. = </h2><br>  Shader es un peque√±o programa que se ejecuta en un acelerador de gr√°ficos (GPU) en un punto determinado de la tuber√≠a de gr√°ficos.  Si consideramos los sombreadores de manera abstracta, podemos decir que estas son las etapas de la tuber√≠a de gr√°ficos, que: <br><br><ol><li>  Sepa d√≥nde obtener datos para el procesamiento. </li><li>  Sepa c√≥mo procesar datos de entrada. </li><li>  Saben d√≥nde escribir datos para su posterior procesamiento. </li></ol><br><p>  Pero, ¬øc√≥mo se ve la tuber√≠a gr√°fica?  Muy simple, as√≠: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  Hasta ahora, en este esquema, solo estamos interesados ‚Äã‚Äãen la vertical principal, que comienza con la Especificaci√≥n de V√©rtice y termina con Frame Buffer.  Como se mencion√≥ anteriormente, cada sombreador tiene sus propios par√°metros de entrada y salida, que difieren en el tipo y n√∫mero de par√°metros. <br>  Describimos brevemente cada etapa de la tuber√≠a para comprender lo que hace: <br><br><ol><li>  Sombreador de v√©rtices: necesario para procesar datos de coordenadas 3D y todos los dem√°s par√°metros de entrada.  Muy a menudo, el sombreador de v√©rtices calcula la posici√≥n del v√©rtice en relaci√≥n con la pantalla, calcula las normales (si es necesario) y genera datos de entrada a otros sombreadores. </li><li>  Sombreador de teselaci√≥n y sombreador de control de teselaci√≥n: estos dos sombreadores son responsables de detallar las primitivas que provienen del sombreador de v√©rtices y preparar los datos para el procesamiento en el sombreador geom√©trico.  Es dif√≠cil describir de lo que son capaces estos dos sombreadores en dos oraciones, pero para que los lectores tengan una peque√±a idea, les dar√© un par de im√°genes con niveles de superposici√≥n bajos y altos: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Te aconsejo que leas este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> si quieres saber m√°s sobre la teselaci√≥n.  En esta serie de art√≠culos cubriremos la teselaci√≥n, pero no ser√° pronto. </li><li>  Sombreador geom√©trico: es responsable de la formaci√≥n de primitivas geom√©tricas a partir de la salida del sombreador de teselaci√≥n.  Usando el sombreador geom√©trico, puede crear nuevas primitivas a partir de las primitivas b√°sicas de OpenGL (GL_LINES, GL_POINT, GL_TRIANGLES, etc.), por ejemplo, usando el sombreador geom√©trico, puede crear un efecto de part√≠culas describiendo la part√≠cula solo por color, centro del racimo, radio y densidad. </li><li>  El sombreador de rasterizaci√≥n es uno de los sombreadores no programables.  Hablando en un lenguaje comprensible, traduce todas las primitivas gr√°ficas de salida en fragmentos (p√≠xeles), es decir  determina su posici√≥n en la pantalla. </li><li>  El sombreador de fragmentos es la √∫ltima etapa de la tuber√≠a de gr√°ficos.  El sombreador de fragmentos calcula el color del fragmento (p√≠xel) que se establecer√° en el b√∫fer de fotogramas actual.  Muy a menudo, en el sombreador de fragmentos, se calculan el sombreado y la iluminaci√≥n del fragmento, el mapeo de texturas y los mapas normales: todas estas t√©cnicas le permiten lograr resultados incre√≠blemente hermosos. </li></ol><br><p>  Los sombreadores OpenGL est√°n escritos en un lenguaje GLSL especial tipo C desde el cual se compilan y vinculan a un programa de sombreadores.  Ya en esta etapa, parece que escribir un programa de sombreado es una tarea extremadamente lenta, porque  debe determinar los 5 pasos de la tuber√≠a de gr√°ficos y vincularlos.  Afortunadamente, esto no es as√≠: los sombreadores de teselaci√≥n y geometr√≠a se definen en la tuber√≠a de gr√°ficos de forma predeterminada, lo que nos permite definir solo dos sombreadores: el v√©rtice y los fragmentos (a veces llamado sombreador de p√≠xeles).  Es mejor considerar estos dos sombreadores con un ejemplo cl√°sico: </p><br><div class="spoiler">  <b class="spoiler_title">Sombreador de v√©rtices</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sombreador de fragmentos</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de ensamblaje del sombreador</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Estos dos sombreadores simples no calculan nada, simplemente pasan los datos por la tuber√≠a.  Prestemos atenci√≥n a c√≥mo est√°n conectados los sombreadores de v√©rtices y fragmentos: en el sombreador de v√©rtices, se declara la variable Color en la que se escribir√° el color despu√©s de ejecutar la funci√≥n principal, mientras que en el sombreador de fragmentos se declara exactamente la misma variable con el calificador in, es decir.  como se describi√≥ anteriormente, el sombreador de fragmentos recibe datos del v√©rtice mediante un simple empuje de los datos a trav√©s de la tuber√≠a (pero en realidad no es tan simple). <br></p><blockquote>  Nota: Si no declara e inicializa una variable de tipo vec4 en el sombreador de fragmentos, no se mostrar√° nada en la pantalla. </blockquote><br>  Los lectores atentos ya han notado la declaraci√≥n de variables de entrada del tipo vec3 con calificadores de dise√±o extra√±os al comienzo del sombreador de v√©rtices, es l√≥gico suponer que esto es entrada, pero ¬øde d√≥nde lo obtenemos? <br><br><h2>  Objetos base: b√∫feres y matrices de v√©rtices </h2><br>  Creo que no vale la pena explicar qu√© son los objetos de b√∫fer, mejor consideraremos c√≥mo crear y llenar un b√∫fer en OpenGL. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  No hay nada dif√≠cil en esto, adjuntamos el b√∫fer generado al objetivo deseado (m√°s adelante descubriremos cu√°l) y cargamos los datos que indican su tama√±o y tipo de uso. </p><br><blockquote>  GL_STATIC_DRAW: los datos en el b√∫fer no se cambiar√°n. <br>  GL_DYNAMIC_DRAW: los datos en el b√∫fer cambiar√°n, pero no con frecuencia. <br>  GL_STREAM_DRAW: los datos en el b√∫fer cambiar√°n con cada llamada de sorteo. <br></blockquote><br><p>  Es genial, ahora nuestros datos se encuentran en la memoria de la GPU, el programa de sombreado est√° compilado y vinculado, pero hay una advertencia: ¬øc√≥mo sabe el programa d√≥nde obtener los datos de entrada para el sombreador de v√©rtices?  Descargamos los datos, pero no indicamos de d√≥nde los obtendr√≠a el programa de sombreado.  Este problema se resuelve con un tipo separado de objetos OpenGL: matrices de v√©rtices. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="imagen"><br><blockquote>  La imagen est√° tomada de este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial</a> . </blockquote><br><p>  Al igual que con los buffers, las matrices de v√©rtices se ven mejor utilizando su ejemplo de configuraci√≥n. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  Crear matrices de v√©rtices no es diferente de crear otros objetos OpenGL, el m√°s interesante comienza despu√©s de la l√≠nea: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Una matriz de v√©rtices (VAO) recuerda todos los enlaces y configuraciones que se realizan con √©l, incluida la uni√≥n de objetos de b√∫fer para la descarga de datos.  En este ejemplo, solo hay un objeto de este tipo, pero en la pr√°ctica puede haber varios.  Despu√©s de eso, se configura el atributo de v√©rtice con un n√∫mero espec√≠fico: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  ¬øD√≥nde conseguimos este n√∫mero?  ¬øRecuerda los calificadores de dise√±o para las variables de entrada del sombreador de v√©rtices?  Son ellos quienes determinan a qu√© atributo de v√©rtice se vincular√° la variable de entrada.  Ahora repase brevemente los argumentos de la funci√≥n para que no haya preguntas innecesarias: <br><ol><li>  El n√∫mero de atributo que queremos configurar. </li><li>  La cantidad de art√≠culos que queremos llevar.  (Dado que la variable de entrada del sombreador de v√©rtices con dise√±o = 0 es de tipo vec3, entonces tomamos 3 elementos de tipo flotante) </li><li>  Tipo de art√≠culos. </li><li>  ¬øEs necesario normalizar los elementos, si es un vector? </li><li>  El desplazamiento para el siguiente v√©rtice (dado que tenemos las coordenadas y los colores ubicados secuencialmente y cada uno tiene el tipo vec3, entonces cambiamos por 6 * sizeof (float) = 24 bytes). </li><li>  El √∫ltimo argumento muestra qu√© desplazamiento tomar para el primer v√©rtice.  (para coordenadas, este argumento es de 0 bytes, para colores de 12 bytes) </li></ol><br><p>  Todo ahora estamos listos para renderizar nuestra primera imagen. </p><br><blockquote>  Recuerde vincular el VAO y el programa de sombreado antes de invocar el render. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Si hiciste todo bien, entonces deber√≠as obtener este resultado: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  El resultado es impresionante, pero ¬øde d√≥nde vino el relleno de degradado en el tri√°ngulo, porque indicamos solo 3 colores: rojo, azul y verde para cada v√©rtice individual?  Esta es la magia del sombreador de rasterizaci√≥n: el hecho es que el valor de Color que establecemos en el v√©rtice no est√° entrando en el sombreador de fragmentos.  Transmitimos solo 3 v√©rtices, pero se generan muchos m√°s fragmentos (hay exactamente tantos fragmentos como p√≠xeles rellenos).  Por lo tanto, para cada fragmento, se toma el promedio de los tres valores de Color, dependiendo de qu√© tan cerca est√© de cada uno de los v√©rtices.  Esto se ve muy bien en las esquinas del tri√°ngulo, donde los fragmentos toman el valor de color que indicamos en los datos del v√©rtice. <br></p><blockquote>  Mirando hacia el futuro, dir√© que las coordenadas de textura se transmiten de la misma manera, lo que facilita la superposici√≥n de texturas en nuestras primitivas. </blockquote><br><p>  Creo que vale la pena terminar este art√≠culo, lo m√°s dif√≠cil est√° detr√°s de nosotros, pero lo m√°s interesante apenas est√° comenzando.  Si tiene preguntas o si vio un error en el art√≠culo, escr√≠balo en los comentarios, se lo agradecer√©. </p><br><p>  En el pr√≥ximo art√≠culo, veremos las transformaciones, aprenderemos sobre variables unifrom y aprenderemos c√≥mo imponer texturas en primitivas. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467599/">https://habr.com/ru/post/467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467589/index.html">Lo que necesitas saber sobre GDPR en 2019</a></li>
<li><a href="../467591/index.html">La nueva prueba resuelve la aproximaci√≥n de n√∫meros como pi</a></li>
<li><a href="../467593/index.html">(No relevante, reparado) Nota. C√≥mo Tele2 comparte el acceso a la cuenta personal de los nuevos suscriptores</a></li>
<li><a href="../467595/index.html">Recorriendo los centros de datos de Selectel. Dinosaur on Fire, VMware, C2F5H y el hombre lobo invisible</a></li>
<li><a href="../467597/index.html">Personalizaci√≥n de pautas de productos de Big Data con Vowpal Wabbit</a></li>
<li><a href="../467605/index.html">Todo lo que necesitas es URL</a></li>
<li><a href="../467607/index.html">Confesi√≥n del enemigo del estibador</a></li>
<li><a href="../467609/index.html">Crear una aplicaci√≥n m√≥vil en React Native</a></li>
<li><a href="../467611/index.html">Algoritmos de detecci√≥n de esquema de imagen</a></li>
<li><a href="../467615/index.html">C√≥mo crear Python wrapper y no volverse loco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>