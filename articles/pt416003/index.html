<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚀 👋🏼 🎨 Renderização de arquivo HTML: um capítulo do livro ReactPHP for Beginners de Skyeng 💃 🙅🏽 😒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O desenvolvedor de back-end de aplicativos móveis Skyeng, Sergey Zhuk, continua escrevendo bons livros. Desta vez, ele lançou um livro em russo para u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Renderização de arquivo HTML: um capítulo do livro ReactPHP for Beginners de Skyeng</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/416003/"><p><img src="https://habrastorage.org/webt/6v/oi/xx/6voixx5vd9au0asabvgmnckfj90.png"></p><br><p>  O desenvolvedor de back-end de aplicativos móveis Skyeng, Sergey Zhuk, continua escrevendo bons livros.  Desta vez, ele lançou um livro em russo para um público que domina o PHP.  Pedi a Sergey que compartilhasse um capítulo útil e auto-suficiente de seu livro e que desse aos leitores de Habra um código de desconto.  Abaixo estão os dois. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Primeiro, vamos lhe dizer o que paramos nos capítulos anteriores.</b> <div class="spoiler_text"><p> Escrevemos nosso servidor HTTP simples em PHP.  Temos o arquivo <code>index.php</code> principal - o script que inicia o servidor.  Aqui está o código de nível mais alto: criamos um loop de eventos, configuramos o comportamento do servidor HTTP e iniciamos o loop: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; $loop = React\EventLoop\Factory::create(); $router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); $router-&gt;load(<span class="hljs-string"><span class="hljs-string">'routes.php'</span></span>); $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $router($request); } ); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> React\Socket\Server(<span class="hljs-number"><span class="hljs-number">8080</span></span>, $loop); $server-&gt;listen($socket); $loop-&gt;run();</code> </pre> <br><p>  Para rotear solicitações, o servidor usa um roteador: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// src/Router.php use Psr\Http\Message\ServerRequestInterface; use React\Http\Response; class Router { private $routes = []; public function __invoke(ServerRequestInterface $request) { $path = $request-&gt;getUri()-&gt;getPath(); echo "Request for: $path\n"; $handler = $this-&gt;routes[$path] ?? $this-&gt;notFound($path); return $handler($request); } public function load($filename) { $routes = require $filename; foreach ($routes as $path =&gt; $handler) { $this-&gt;add($path, $handler); } } public function add($path, callable $handler) { $this-&gt;routes[$path] = $handler; } private function notFound($path) { return function () use ($path) { return new Response( 404, ['Content-Type' =&gt; 'text/html; charset=UTF-8'], "No request handler found for $path" ); }; } }</span></span></code> </pre> <br><p>  As rotas do arquivo <code>routes.php</code> são carregadas no <code>routes.php</code> .  Agora, apenas duas rotas foram anunciadas aqui: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Main page'</span></span> ); }, <span class="hljs-string"><span class="hljs-string">'/upload'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Upload page'</span></span> ); }, ];</code> </pre> <br><p>  Até agora, tudo é simples e nosso aplicativo assíncrono se encaixa em vários arquivos. </p></div></div><br><p>  Passamos a coisas mais "úteis".  As respostas de algumas palavras de um texto simples que aprendemos a derivar nos capítulos anteriores não parecem muito atraentes.  Precisamos retornar algo real, como uma página HTML. </p><br><p>  Então, onde colocamos esse HTML?  Obviamente, você pode codificar o conteúdo da página da web dentro do arquivo de rotas: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { $html = &lt;&lt;&lt;HTML &lt;!DOCTYPE html&gt; &lt;html lang=”en”&gt; &lt;head&gt; &lt;meta charset=”UTF-8”&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello, world &lt;/body&gt; &lt;/html&gt; HTML; return new Response( 200, ['Content-Type' =&gt; 'text/html'], $html ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Mas não faça isso!  Você não pode misturar lógica de negócios (roteamento) com apresentação (página HTML).  Porque  Imagine que você precise alterar algo no código HTML, por exemplo, a cor do botão.  E qual arquivo precisará ser alterado?  Arquivo com rotas <code>router.php</code> ?  Soa estranho, certo?  Faça alterações no roteiro para alterar a cor do botão ... </p><br><p>  Portanto, deixaremos as rotas em paz e, para as páginas HTML, criaremos um diretório separado.  Na raiz do projeto, adicione um novo diretório chamado páginas.  Então, dentro dele, criamos o arquivo <code>index.html</code> .  Esta será a nossa página principal.  Aqui está o seu conteúdo: </p><br><pre> <code class="php hljs">&lt;!DOCTYPE html&gt; &lt;html lang=<span class="hljs-string"><span class="hljs-string">"en"</span></span>&gt; &lt;head&gt; &lt;meta charset=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;link rel=<span class="hljs-string"><span class="hljs-string">"stylesheet"</span></span> href=<span class="hljs-string"><span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css"</span></span> &gt; &lt;/head&gt; &lt;body&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">row</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">action</span></span></span><span class="hljs-class">="/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upload</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">POST</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">justify</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">center</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">group</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Text</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textarea</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class">"&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">submit</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primary</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Submit</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  A página é bastante simples, contém apenas um elemento - o formulário.  O formulário dentro tem uma caixa de texto e um botão para enviar.  Também adicionei estilos de Bootstrap para tornar nossa página mais agradável. </p><br><h4 id="chtenie-faylov-kak-ne-nado-delat">  Lendo arquivos.  Como NÃO fazer </h4><br><p>  A abordagem mais direta é ler o conteúdo do arquivo dentro do manipulador de solicitações e retornar esse conteúdo como o corpo da resposta.  Algo assim: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  E, a propósito, vai funcionar.  Você pode tentar você mesmo: reinicie o servidor e recarregue a página <code>http://127.0.0.1:8080/</code> no seu navegador. </p><br><p><img src="https://habrastorage.org/webt/zq/dc/91/zqdc91cvy7a971jkniyw8hpxgzi.png"></p><br><p>  Então, o que há de errado aqui?  E porque não fazer isso?  Em resumo, porque haverá problemas se o sistema de arquivos começar a ficar mais lento. </p><br><h4 id="blokiruyuschie-i-neblokiruyuschie-vyzovy">  Bloqueando e não bloqueando chamadas </h4><br><p>  Deixe-me mostrar o que quero dizer com "bloqueio" de chamadas e o que pode acontecer quando um dos manipuladores de solicitação contém código de bloqueio.  Antes de retornar o objeto de resposta, adicione uma chamada à função <code>sleep()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { sleep(10); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Isso fará com que o manipulador de solicitações congele por 10 segundos antes de poder retornar uma resposta com o conteúdo da página HTML.  Observe que não tocamos no manipulador do endereço <code>/upload</code> .  Ao chamar a função <code>sleep(10)</code> , eu emulo a execução de algum tipo de operação de bloqueio. </p><br><p>  Então o que nós temos?  Quando o navegador solicita a página <code>/</code> , o manipulador aguarda 10 segundos e retorna a página HTML.  Quando abrimos o endereço <code>/upload</code> , seu manipulador deve retornar imediatamente uma resposta com a string 'Upload page'. </p><br><p>  Agora vamos ver o que acontece na realidade.  Como sempre, reiniciamos o servidor.  Agora, abra outra janela no seu navegador.  Na barra de endereço, digite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://127.0.0.1:8080/upload</a> , mas não abra esta página imediatamente.  Deixe esse endereço na barra de endereços por enquanto.  Em seguida, vá para a primeira janela do navegador e abra a página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://127.0.0.1:8080/</a> .  Enquanto esta página estiver carregando (lembre-se de que levará 10 segundos para fazer isso), vá rapidamente para a segunda janela e pressione “Enter” para carregar o endereço que foi deixado na barra de endereços ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://127.0.0.1:8080/upload</a> ) . </p><br><p>  O que conseguimos?  Sim, o endereço /, como esperado, leva 10 segundos para carregar.  Surpreendentemente, porém, a segunda página demorou o mesmo tempo para carregar, embora não tenhamos adicionado nenhuma chamada <code>sleep()</code> .  Alguma idéia de por que isso aconteceu? </p><br><p>  O ReactPHP é executado em um único thread.  Pode parecer que em um aplicativo assíncrono, as tarefas são executadas em paralelo, mas, na realidade, não é assim.  A ilusão de paralelismo é criada por um ciclo de eventos que alterna constantemente entre várias tarefas e as executa.  Mas em um determinado momento, apenas uma tarefa é sempre executada.  Isso significa que, se uma dessas tarefas demorar muito, ele bloqueará o loop de eventos, que não poderá registrar novos eventos e chamar manipuladores para eles.  E, finalmente, isso leva ao "congelamento" de todo o aplicativo, ele simplesmente perde a assincronia. </p><br><p>  OK, mas o que isso tem a ver com chamar <code>file_get_contents('pages/index.h')</code> ?  O problema aqui é que estamos acessando o sistema de arquivos diretamente.  Comparado a outras operações, como trabalhar com memória ou computação, trabalhar com o sistema de arquivos pode ser extremamente lento.  Por exemplo, se o arquivo for muito grande ou o próprio disco estiver lento, a leitura do arquivo poderá levar algum tempo e, como resultado, bloquear o loop de eventos. </p><br><p>  No modelo síncrono padrão, solicitação-resposta não é um problema.  Se o cliente solicitou um arquivo muito pesado, ele aguardará até que o arquivo seja baixado.  Uma solicitação tão pesada não afeta outros clientes.  Mas, no nosso caso, estamos lidando com um modelo assíncrono orientado a eventos.  Lançamos um servidor HTTP que deve processar constantemente as solicitações recebidas.  Se uma solicitação demorar muito para ser concluída, isso afetará todos os outros clientes do servidor. </p><br><p>  Como regra, lembre-se: </p><br><ul><li>  Você nunca pode bloquear um loop de eventos. </li></ul><br><p>  Então, como lemos o arquivo de forma assíncrona?  E aqui chegamos à segunda regra: </p><br><ul><li>  Quando uma operação de bloqueio não pode ser evitada, ela deve ser bifurcada no processo filho e continuar a execução assíncrona no encadeamento principal. </li></ul><br><p>  Então, depois de aprendermos como não fazer isso, vamos discutir a solução não-bloqueio correta. </p><br><h4 id="docherniy-process">  Processo filho </h4><br><p>  Toda a comunicação com o sistema de arquivos em um aplicativo assíncrono deve ser executada em processos filho.  Para gerenciar processos filhos em um aplicativo ReactPHP, precisamos instalar outro componente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Processo filho"</a> .  Este componente permite acessar as funções do sistema operacional para executar qualquer comando do sistema dentro do processo filho.  Para instalar este componente, abra um terminal na raiz do projeto e execute o seguinte comando: </p><br><p> <code>composer require react/child-process</code> </p> <br><h4 id="sovmestimost-s-windows">  <em>Compatibilidade com Windows</em> </h4><br><p>  <em>No sistema operacional Windows, os encadeamentos STDIN, STDOUT e STDERR estão bloqueando, o que significa que o componente Processo do Filho não poderá funcionar corretamente.</em>  <em>Portanto, esse componente foi projetado principalmente para funcionar apenas em sistemas nix.</em>  <em>Se você tentar criar um objeto da classe Process em um sistema Windows, uma exceção será lançada.</em>  <em>Mas o componente pode funcionar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows Subsystem for Linux (WSL)</a> .</em>  <em>Se você pretende usar este componente no Windows, precisará instalar o WSL.</em> </p><br><p>  Agora podemos executar qualquer comando shell dentro do processo filho.  Abra o arquivo <code>routes.php</code> e, em seguida, <code>routes.php</code> o manipulador da rota <code>/</code> .  Crie um objeto da classe <code>React\ChildProcess\Process</code> e, como um comando, passe <code>ls</code> para ele para obter o conteúdo do diretório atual: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request) { $childProcess = new Process('ls'); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Então precisamos iniciar o processo chamando o método <code>start()</code> .  O problema é que o método <code>start()</code> precisa de um objeto de loop de eventos.  Mas no arquivo <code>routes.php</code> não temos esse objeto.  Como passamos o loop de eventos de <code>index.php</code> para rotas diretamente para o manipulador de solicitações?  A solução para esse problema é "injeção de dependência". </p><br><h4 id="inekciya-zavisimostey">  Injeção de Dependência </h4><br><p>  Portanto, uma de nossas rotas precisa de um loop de eventos para funcionar.  Em nossa aplicação, apenas um componente conhece a existência de rotas - a classe <code>Router</code> .  Acontece que é sua responsabilidade fornecer um loop de eventos para as rotas.  Em outras palavras, o roteador precisa de um loop de eventos ou depende do loop de eventos.  Como expressamos explicitamente essa dependência no código?  Como tornar impossível criar um roteador sem passar um loop de eventos para ele?  Obviamente, através do construtor da classe <code>Router</code> .  Abra <code>Router.php</code> e adicione o construtor à classe <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">LoopInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $routes = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> LoopInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $loop; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoopInterface $loop)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop = $loop; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dentro do construtor, salve o loop de eventos passados ​​na propriedade privada <code>$loop</code> .  Isso é injeção de dependência quando fornecemos à classe os objetos de que ela precisa para trabalhar externamente. </p><br><p>  Agora que temos esse novo construtor, precisamos atualizar a criação do roteador.  Abra o arquivo <code>index.php</code> e corrija a linha em que criamos o objeto da classe <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// index.php $loop = React\EventLoop\Factory::create(); $router = new Router($loop); $router-&gt;load('routes.php');</span></span></code> </pre> <br><p>  Feito.  Volte para <code>routes.php</code> .  Como você provavelmente já adivinhou, aqui podemos usar a mesma idéia com <strong>injeção de dependência</strong> e adicionar um loop de eventos como um segundo parâmetro aos nossos manipuladores de consultas.  Altere o primeiro retorno de chamada e adicione o segundo argumento: um objeto que implementa <code>LoopInterface</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('ls'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Em seguida, precisamos passar o loop de eventos para o método <code>start()</code> do processo filho.  E onde o manipulador obtém o loop do evento?  E já está armazenado dentro do roteador na propriedade privada <code>$loop</code> .  Nós só precisamos passar quando o manipulador é chamado. </p><br><p>  <code>__invoke()</code> abrir a classe <code>Router</code> e atualizar o método <code>__invoke()</code> , adicionando o segundo argumento à chamada do manipulador de solicitações: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $path = $request-&gt;getUri()-&gt;getPath(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Request for: $path\n"</span></span>; $handler = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;routes[$path] ?? <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;notFound($path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $handler($request, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop); }</code> </pre> <br><p>  Isso é tudo!  Provavelmente, isso é <strong>injeção de dependência</strong> suficiente.  Uma jornada bastante grande do ciclo de eventos aconteceu, certo?  Do arquivo <code>index.php</code> à classe <code>Router</code> e, em seguida, da classe <code>Router</code> ao arquivo <code>routes.php</code> diretamente dentro dos retornos de chamada. </p><br><p>  Portanto, para confirmar que o processo filho fará sua mágica sem bloqueio, vamos substituir o <code>ls</code> simples pelo <code>ping 8.8.8.8</code> mais pesado.  Reinicie o servidor e tente novamente duas páginas em duas janelas diferentes.  Primeiro, <code>http://127.0.0.1:8080/</code> e depois <code>/upload</code> .  Ambas as páginas abrem rapidamente, sem demora, embora o comando <code>ping</code> seja executado no primeiro manipulador em segundo plano.  A propósito, isso significa que podemos fazer uma operação cara (por exemplo, processar arquivos grandes), sem bloquear o aplicativo principal. </p><br><h4 id="svyazyvaem-docherniy-process-i-otvet-s-pomoschyu-potokov">  Vincular processo filho e resposta usando threads </h4><br><p>  Vamos voltar ao nosso aplicativo.  Por isso, criamos um processo filho e o iniciamos, mas nosso navegador não exibe os resultados de uma operação bifurcada de forma alguma.  Vamos consertar. </p><br><p>  Como podemos nos comunicar com o processo filho?  No nosso caso, temos um <code>ls</code> execução que exibe o conteúdo do diretório atual.  Como chegamos a essa conclusão e a enviamos ao corpo da resposta?  A resposta curta é: tópicos. </p><br><p>  Vamos falar um pouco sobre processos.  Qualquer comando shell que você executa possui três fluxos de dados: STDIN, STDOUT e STDERR.  Transmita para saída e entrada padrão, além de transmitir erros.  Por exemplo, quando executamos o <code>ls</code> , o resultado desse comando é enviado diretamente para STDOUT (na tela do terminal).  Portanto, se precisarmos obter a saída de um processo, é necessário acesso ao fluxo de saída.  E isso é tão fácil quanto descascar peras.  Ao criar o objeto de resposta, substitua a chamada <code>file_get_contents()</code> por <code>$childProcess-&gt;stdout</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], $childProcess-&gt;stdout );</code> </pre> <br><p>  Todos os processos filhos têm três propriedades relacionadas aos fluxos <code>stdio</code> : <code>stdout</code> , <code>stdin</code> e <code>stderr</code> .  No nosso caso, queremos exibir a saída do processo em uma página da web.  Em vez de uma sequência no construtor da classe <code>Response</code> , passamos um fluxo como o terceiro argumento.  A classe <code>Response</code> é inteligente o suficiente para perceber que recebeu o fluxo e processá-lo adequadamente. </p><br><p>  Portanto, como sempre, reinicializamos o servidor e vemos o que fizemos.  Vamos abrir a página <code>http://127.0.0.1:8080/</code> no navegador: você deve ver uma lista de arquivos da pasta raiz do projeto. </p><br><p><img src="https://habrastorage.org/webt/mm/ui/za/mmuizadmcw-fzg1cekm0d1jpz3e.png"></p><br><p>  A etapa final é substituir o <code>ls</code> por algo mais útil.  Começamos este capítulo renderizando o arquivo <code>pages/index.html</code> usando a função <code>file_get_contents()</code> .  Agora, podemos ler este arquivo de forma absolutamente assíncrona, sem nos preocuparmos com o bloqueio do aplicativo.  Substitua o <code>ls</code> por <code>cat pages/index.html</code> . </p><br><p>  Se você não estiver familiarizado com o <code>cat</code> , ele será usado para concatenar e gerar arquivos.  Na maioria das vezes, esse comando é usado para ler um arquivo e enviar seu conteúdo para a saída padrão.  O comando <code>cat pages/index.html</code> lê o arquivo <code>cat pages/index.html</code> e imprime seu conteúdo em STDOUT.  E já estamos enviando <code>stdout</code> como o corpo da resposta.  Aqui está a versão final do arquivo <code>routes.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('cat pages/index.html'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], $childProcess-&gt;stdout ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Como resultado, todo esse código foi necessário apenas para substituir uma chamada para a função <code>file_get_contents()</code> .  Injeção de dependência, passando um objeto de loop de eventos, adicionando processos filhos e trabalhando com threads.  Tudo isso é apenas para substituir uma chamada de função.  Valeu a pena?  Resposta: sim, valeu a pena.  Quando algo puder bloquear o loop de eventos, e o sistema de arquivos puder definitivamente, certifique-se de que, eventualmente, ele será bloqueado e no momento mais inoportuno. </p><br><p>  Criar um processo filho toda vez que precisamos acessar o sistema de arquivos pode parecer uma sobrecarga extra que afetará a velocidade e o desempenho de nosso aplicativo.  Infelizmente, no PHP não há outra maneira de trabalhar com o sistema de arquivos de forma assíncrona.  Todas as bibliotecas PHP assíncronas usam processos filhos (ou extensões que as abstraem). </p><br><p>  Os leitores da Habra podem comprar o livro inteiro com desconto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . </p><br><p>  E lembramos que estamos sempre em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">busca de desenvolvedores legais</a> !  Venha, nos divertimos! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416003/">https://habr.com/ru/post/pt416003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415993/index.html">Remot, sua farinha impiedosa</a></li>
<li><a href="../pt415995/index.html">Desenvolvimento de CROC por dentro: pessoas, patos e muito trabalho</a></li>
<li><a href="../pt415997/index.html">Software de aprendizado de máquina Python</a></li>
<li><a href="../pt415999/index.html">O que é a bolsa de estudos da Apple e por que é mais do que apenas um ingresso da WWDC</a></li>
<li><a href="../pt416001/index.html">Mensagens de um site em VK - simples e eficaz - PHP + CUrl</a></li>
<li><a href="../pt416005/index.html">16 Reagir ferramentas para desenvolvedores de interface</a></li>
<li><a href="../pt416007/index.html">Quase complicado. O início da criação de uma "casa inteligente" sem fio. Baseado na tecnologia Linux, nos softwares Z-Wave e MajorDoMo</a></li>
<li><a href="../pt416009/index.html">Tente excrementos de coelho, é vigoroso, ele pega - extratos em farmacologia</a></li>
<li><a href="../pt416011/index.html">Padrão BIF: código front-end limpo e trabalho conveniente com dados do servidor</a></li>
<li><a href="../pt416013/index.html">Como começar a investir e economizar dinheiro: os especialistas da Dow Jones apontaram os cinco principais erros de traders iniciantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>