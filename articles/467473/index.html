<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö∞Ô∏è ü§≤üèø üÖæÔ∏è Y m√°s sobre tipos üî§ ‚Ü™Ô∏è üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Y m√°s sobre tipos 
 Me aventurar√≠a a volver a plantear este tema. Comenzar√© con un enlace a un art√≠culo de Mikhail Opanasenko (oms7) , que es muy impr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Y m√°s sobre tipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467473/"><h1>  Y m√°s sobre tipos </h1><br>  Me aventurar√≠a a volver a plantear este tema.  Comenzar√© con un enlace a un art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mikhail Opanasenko (oms7)</a> , que es muy impresionante en t√©rminos de la cantidad de trabajo realizado, as√≠ como en la cantidad de enlaces citados.  Comenz√≥ a preparar su material, sin saber acerca de esta publicaci√≥n, que posteriormente, despu√©s de la familiarizaci√≥n, llev√≥ a la necesidad de un procesamiento sustancial.  Para aquellos que ya han le√≠do este art√≠culo, les informo que en mi material, se estudian tipos m√°s diversos de datos, en particular, cadenas y n√∫meros reales, se utilizan las bibliotecas de impulso y bsd, y se mencionan algunos otros temas que faltan en el art√≠culo. <br><a name="habracut"></a><br>  Hay docenas de formas diferentes de organizar los elementos de datos en orden.  Entre ellos, hay aquellos que funcionan r√°pido, de modo que, por ejemplo, pueden ordenar cualquier matriz de datos ubicada en la RAM de la computadora en un m√°ximo de minutos.  M√°s espec√≠ficamente, se puede decir que la clasificaci√≥n r√°pida organiza mil millones de enteros en una buena computadora personal moderna en menos de cien segundos.  Si utiliza m√©todos primitivos y no r√°pidos, por ejemplo, clasificaci√≥n de burbujas o clasificaci√≥n de selecci√≥n, para clasificar un mayor n√∫mero de elementos, entonces el tiempo dedicado a dicho procesamiento de datos puede exceder cualquier expectativa; dicho "procesamiento" en realidad puede llevar varios d√≠as, semanas e incluso a√±os.  Esta gran diferencia es causada por el hecho de que el tiempo de clasificaci√≥n por m√©todos r√°pidos es aproximadamente proporcional a <i>N</i> log <i>N</i> , y primitivo - <i>N</i> <sup>2</sup> .  Con el aumento de <i>N, la</i> diferencia entre los dos valores se vuelve muy notable.  Por lo tanto, es razonable usar m√©todos primitivos solo para trabajar con datos peque√±os, por ejemplo, en computadoras modernas, hasta varios miles de elementos.  Tambi√©n es natural usarlos para ense√±ar los conceptos b√°sicos de programaci√≥n y pensamiento l√≥gico, ya que son mucho m√°s simples que los m√©todos r√°pidos. <br><br>  Me gustar√≠a entender los m√©todos de clasificaci√≥n existentes en las bibliotecas est√°ndar actuales.  Descubra cu√°n grande es la diferencia entre ellos en t√©rminos de sus caracter√≠sticas principales, velocidad de trabajo y tambi√©n sus caracter√≠sticas.  Adem√°s, consideraremos en el camino para la comparaci√≥n y ejercicios para la mente algunos m√©todos que no son dif√≠ciles de implementar.  Tambi√©n vale la pena se√±alar que el optimizador del compilador GCC y posiblemente otros compiladores buenos funcionan muy bien, acelerando el c√≥digo varias veces (a veces incluso m√°s de 5 veces). <br><br>  Comencemos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el m√©todo de</a> clasificaci√≥n de burbujas como el m√°s simple y el m√°s lento.  De acuerdo con este m√©todo, debe recorrer la matriz de datos una y otra vez, comparar elementos vecinos y cambiar sus lugares si se rompe el orden entre ellos.  Despu√©s de cada pasada, al menos un elemento (el m√°s grande o el m√°s peque√±o, depende del orden seleccionado) est√° en su lugar.  Adem√°s de la simplicidad, este m√©todo tiene una ventaja m√°s; no requiere memoria adicional.  Se puede observar una caracter√≠stica m√°s del m√©todo de burbuja: procesa muy r√°pidamente los datos ya ordenados y, en algunos casos, lo convierte en uno de los m√©todos m√°s r√°pidos.  Si los datos est√°n ordenados solo parcialmente, entonces este m√©todo funciona con ellos m√°s r√°pido, pero en la mayor√≠a de los casos solo muy ligeramente.  Para las pruebas, utilic√© la siguiente <a href="">implementaci√≥n</a> . <br><br>  Otro m√©todo lento es el tipo de selecci√≥n.  Aqu√≠, en cada pasada, primero se encuentran los elementos m√°s grandes y m√°s peque√±os en los datos y luego estos elementos se colocan en las posiciones extremas correspondientes al orden seleccionado.  En la pr√≥xima pasada, clasificamos los datos sin estos elementos extremos.  Este m√©todo es tan simple como la clasificaci√≥n de burbujas, y tampoco requiere memoria adicional, pero es notablemente m√°s r√°pido.  Adem√°s, la clasificaci√≥n mediante este m√©todo realiza un n√∫mero m√≠nimo de registros de permutaciones de elementos de datos.  Por lo tanto, cuando las permutaciones son mucho m√°s lentas que las comparaciones, el pedido por el m√©todo de selecci√≥n puede ser aceptable si el n√∫mero de elementos de datos es peque√±o.  Aqu√≠ est√° mi <a href="">implementaci√≥n</a> .  M√°s a menudo, esta clasificaci√≥n se realiza, colocando en su lugar solo un elemento por pase.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> clasificaci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mont√≥n</a> (o piramidal), que se discutir√° m√°s adelante, es la versi√≥n m√°s avanzada de la clasificaci√≥n en cuesti√≥n. <br><br>  El c√≥digo para el √∫ltimo m√©todo lento considerado, la ordenaci√≥n por inserci√≥n, es probablemente el m√°s corto de todos los c√≥digos que implementan la ordenaci√≥n, por lo que este m√©todo a veces es usado por ordenaciones r√°pidas complejas para casos en los que el n√∫mero de elementos a ordenar es peque√±o (varias decenas).  Es algo similar a ordenar por una burbuja, ya que aqu√≠ y all√° los elementos vecinos se comparan sucesivamente.  Pero la ordenaci√≥n por inserciones busca el siguiente elemento para la posici√≥n correcta en la parte ya ordenada de los datos, y no solo empuja el elemento extremo a la posici√≥n extrema.  Con este enfoque, tampoco se necesita memoria adicional.  Al igual que la clasificaci√≥n por burbujas, la clasificaci√≥n por inserci√≥n es muy r√°pida en datos ordenados y m√°s r√°pida en datos parcialmente ordenados.  En este √∫ltimo caso, significativamente m√°s r√°pido que la burbuja.  Por lo general, ordenar por inserciones es algo m√°s r√°pido que ordenar por selecci√≥n.  Y a diferencia de este √∫ltimo, como la clasificaci√≥n de burbujas, es estable.  Lo peor de todo es que la ordenaci√≥n por inserci√≥n funciona con datos en orden inverso, con lo que a veces se convierte en el m√°s lento de los m√°s lentos.  Para las pruebas, se utiliz√≥ la siguiente <a href="">implementaci√≥n</a> .  Se puede acelerar un poco si no utiliza b√∫squeda lineal, sino binaria, por ejemplo, usando la funci√≥n std :: bsearch.  Se puede lograr una aceleraci√≥n significativa mediante el uso de una estructura de tipo de lista, la inserci√≥n de un elemento en el que es muy r√°pido.  Tambi√©n puede notar que esta es la clasificaci√≥n m√°s natural: por ejemplo, generalmente se usa intuitivamente cuando se juega a las cartas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> clasificaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shell</a> es la m√°s simple entre los m√©todos r√°pidos y es bastante adecuada para los estudiantes que reci√©n comienzan a aprender programaci√≥n.  Es solo una modificaci√≥n de la clasificaci√≥n de burbujas.  La √∫nica diferencia entre ellos es que en la clasificaci√≥n de Shell, la distancia entre los elementos comparados se toma de pasillo en pasillo, de mayor en la primera pasada, a 1 en la √∫ltima, por lo que el m√©todo de Shell degenera en una clasificaci√≥n de burbujas primitiva en estas √∫ltimas pasadas.  Donald Shell public√≥ el algoritmo de clasificaci√≥n b√°sico que obtuvo su nombre en 1959.  Por lo tanto, esta es una de las primeras clasificaciones universales que funcionan r√°pidamente.  A modo de comparaci√≥n, el algoritmo de clasificaci√≥n r√°pida se public√≥ dos a√±os despu√©s, y la clasificaci√≥n popular o introspectiva de Tim se conoci√≥ solo en los a√±os 90.  Varios problemas matem√°ticos interesantes sin resolver est√°n asociados con la clasificaci√≥n de Shell, el principal de los cuales es c√≥mo seleccionar de manera √≥ptima los desplazamientos entre los elementos comparados.  Se encontraron algunas secuencias de registro, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A102549</a> .  Tales secuencias se encuentran a trav√©s de c√°lculos colosales, por lo que tienen una longitud muy corta, A102549 tiene solo 8 elementos, lo cual es suficiente solo para datos de hasta aproximadamente 3,000 elementos.  Para Big Data, las secuelas deben verse casi al azar.  Los valores usados ‚Äã‚Äãcercanos a las potencias de 2, <i>e</i> , 2.25 y 3. Los n√∫meros primos cercanos a las potencias de 2 mostraron los peores resultados, notablemente inferiores a los mejores.  Pero las otras tres opciones resultaron ser aproximadamente las mismas en t√©rminos de impacto en el rendimiento y probablemente muy cerca de lo √≥ptimo.  Adem√°s, en estos tres casos, el uso de n√∫meros primos no dio ventajas tangibles.  Es curioso que los sesgos propuestos en Wikipedia (con una base de 2.25) basados ‚Äã‚Äãen referencias a los trabajos correspondientes no mostraron los mejores resultados en las pruebas, aunque sus diferencias con los mejores fueron muy insignificantes (no m√°s del 5-10%).  El uso de A102549 como punto de partida tampoco dio resultados notables.  Mikhail Opanasenko tambi√©n trat√≥ de desentra√±ar la clasificaci√≥n de Shell y obtuvo un resultado interesante de que los desplazamientos elegidos por la f√≥rmula <i>s <sub>n + 1</sub> = 10s <sub>n</sub> / 3</i> dan un efecto muy bueno y tal vez incluso cerca del ideal.  Mis resultados confirman esto.  En muchos casos, fueron tales sesgos los que dieron el mejor resultado, aunque este no fue siempre el caso y la brecha con el resultado m√°s cercano fue bastante peque√±a (alrededor del 5%).  Mi <a href="">c√≥digo</a> para implementar clasificaciones de Shell utiliza tablas peque√±as con compensaciones, aunque si no usa n√∫meros primos, estas compensaciones para tablas se pueden calcular casi instant√°neamente, como se hizo en la implementaci√≥n de una de las variantes dadas de esta clasificaci√≥n. <br><br>  Es interesante que si tomamos las compensaciones cercanas a las potencias de los triples de una manera ligeramente diferente y usamos un algoritmo ligeramente diferente (ver <a href="">implementaci√≥n</a> ), entonces en n√∫meros de 32 bits obtendremos velocidades cercanas a las mejores, pero en n√∫meros m√°s largos y en las l√≠neas obtendremos una desaceleraci√≥n significativa, a veces M√°s del 100%.  Los resultados para el mejor algoritmo utilizado por oms7 tambi√©n se encuentran en la tabla a continuaci√≥n, pero aunque muestra buenos resultados en orden, est√° muy por detr√°s de los l√≠deres en t√©rminos de valores absolutos. <br><br>  ¬øHabr√° alguna manera de encontrar las mejores compensaciones?  Quiz√°s, pero me atrevo a sugerir que no sea pronto.  La ordenaci√≥n de shell se usa en el kernel de Linux, y en al menos una biblioteca C su c√≥digo se usa para la funci√≥n qsort () est√°ndar.  Se ha demostrado te√≥ricamente que la velocidad de clasificaci√≥n √≥ptima de Shell en orden es solo un poco m√°s lenta que los m√©todos logar√≠tmicos r√°pidos "reales".  De hecho, la dependencia del tiempo promedio de procesamiento de datos en su tama√±o para la clasificaci√≥n √≥ptima de Shell se describe mediante la f√≥rmula on <i>N</i> (log <i>N</i> / log log <i>N</i> ) <sup>2</sup> , que incluso para <i>N</i> muy grande <i>est√°</i> muy cerca de la f√≥rmula ‚àΩ <i>N</i> log <i>N</i> t√≠pica para otros m√©todos r√°pidos.  Por lo general, la ordenaci√≥n de Shell a menudo es incluso m√°s r√°pida que los m√©todos te√≥ricamente m√°s r√°pidos en orden y solo comienza a ceder ligeramente cuando se procesan matrices bastante grandes (del orden de 10 millones de elementos).  Esta clasificaci√≥n absolutamente no necesita memoria adicional y se comporta de manera estable para una amplia variedad de opciones para llenar datos, compar√°ndose favorablemente con clasificaciones r√°pidas.  El m√©todo Shell no posee la propiedad de estabilidad. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> ordenaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">r√°pida</a> es solo un poco m√°s compleja que el algoritmo de Shell y sigue siendo una de las formas m√°s r√°pidas de organizar datos dispersos aleatoriamente.  Sin embargo, esta clasificaci√≥n tiene varios inconvenientes.  Necesita memoria adicional y, en casos muy raros, funciona extremadamente lento, seg√∫n una dependencia cuadr√°tica.  La idea principal de este m√©todo es dividir los datos en dos partes: los datos en una parte deben ser m√°s o menos (depende del orden seleccionado) que en la otra.  Existen varios m√©todos para esta separaci√≥n.  Idealmente, con cada divisi√≥n, ambas partes deben tener aproximadamente el mismo tama√±o, y lo peor de todo, cuando una de las partes se compone de un solo elemento durante la divisi√≥n.  Consideremos varias implementaciones de algoritmos de ordenaci√≥n r√°pida, en particular, <a href="">el m√©todo Hoar</a> , en el que un elemento de referencia que divide los datos en dos partes se selecciona desde el medio de los datos ordenados. <br><br>  Tambi√©n consideramos el <a href="">algoritmo</a> extremadamente compacto de <a href="">Lomuto</a> , que a veces es un poco (aproximadamente 1%) m√°s r√°pido que el m√©todo Hoare considerado.  Sin embargo, en casos especiales t√≠picos, por ejemplo, en datos ordenados, inversos o malvariantes, el m√©todo de Lomuto muestra una lentitud extrema.  Adem√°s, entre las opciones consideradas para la ordenaci√≥n r√°pida, result√≥ ser el m√°s codicioso para el tama√±o de la pila durante las ejecuciones pr√°cticas: al ordenar matrices relativamente peque√±as, solo este tipo no ten√≠a suficientes 8 megabytes para la pila, tuve que establecer este tama√±o a trav√©s de ulimit more.  Tal avaricia por la pila conduce a grandes ralentizaciones cuando se procesan grandes datos (decenas de millones de l√≠neas), y tengo dificultades para llamar a su naturaleza.  Solo puedo afirmar que es mejor no utilizar esta clasificaci√≥n del siguiente p√°rrafo con dichos datos. <br><br>  El m√©todo Lomuto selecciona el √∫ltimo elemento como referencia, pero es posible implementar una ordenaci√≥n r√°pida sin ning√∫n <a href="">elemento de soporte</a> , m√°s precisamente, la selecci√≥n de tal elemento aqu√≠ ocurre como resultado de la bisecci√≥n de datos ya realizada.  Esta clasificaci√≥n por caracter√≠sticas de velocidad result√≥ estar cerca del m√©todo de Lomuto, aunque generalmente es un poco m√°s r√°pido, y en casos extremos es notablemente m√°s r√°pido que Lomuto, pero m√°s lento que Hoar. <br><br>  En 2009, se public√≥ un <a href="">algoritmo de</a> clasificaci√≥n r√°pida de dos anclajes, que se convirti√≥ en est√°ndar para el lenguaje Java.  Este algoritmo reduce el n√∫mero de permutaciones en un 20% en comparaci√≥n con los mejores t√≠picos, pero el n√∫mero de comparaciones no cambia.  Su autor es Vladimir Yaroslavsky.  Realmente funciona, como regla, m√°s r√°pido que otros tipos r√°pidos.  Lo optimic√© un poco, utilizando el hecho conocido desde hace mucho tiempo de que en la arquitectura x86, el intercambio generalmente funciona m√°s r√°pido que la asignaci√≥n, y para las cadenas C ++ es mucho, mucho m√°s r√°pido.  Todas las clasificaciones r√°pidas consideradas hasta ahora no tienen la propiedad de estabilidad. <br><br>  Se necesita memoria adicional para una clasificaci√≥n r√°pida para organizar llamadas recursivas.  Sin embargo, la segunda llamada de este tipo puede ser reemplazada por un bucle, al optimizar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recursi√≥n de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cola</a> , que en t√©rminos de velocidad puede no dar ganancias, pero reduce significativamente el tama√±o de los datos adicionales utilizados.  Implement√© la opci√≥n de clasificaci√≥n Hoar con esta optimizaci√≥n.  Adem√°s, en los programas del sistema, puede verificar el puntero de la pila y si se acerca a un valor cr√≠tico, simplemente puede restablecer todas las llamadas recursivas y comenzar a ordenar nuevamente; para este caso, es obvio que necesita usar la opci√≥n de clasificaci√≥n r√°pida que no se ralentiza en datos casi ordenados, por ejemplo , la versi√≥n propuesta anteriormente de Hoar.  Combatir el uso de memoria adicional puede considerarse la idea principal de la clasificaci√≥n r√°pida de la biblioteca de lenguaje C est√°ndar en GCC.  Generalmente abandon√≥ la recursi√≥n.  En cambio, usan su simulaci√≥n, que permite que un tercero reduzca la carga en la pila.  El c√≥digo result√≥ bastante grande, unas 150 l√≠neas.  Acerca de esta clasificaci√≥n, todav√≠a habr√° un poco de material a continuaci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> clasificaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hash</a> puede ser muy r√°pida, cercana a ‚àΩ <i>N.</i>  Sin embargo, a veces puede funcionar en una dependencia cuadr√°tica.  La velocidad de este m√©todo de clasificaci√≥n depende mucho de la entrada.  Si la funci√≥n hash distribuye los datos de manera uniforme sobre la matriz auxiliar, obtenemos la relaci√≥n lineal m√°s r√°pida.  Y si todos los datos se agrupan cerca de varios "centros de masa" muy separados o cuando hay muchos elementos de datos id√©nticos, es decir, cuando ocurren muchas colisiones de hash, obtenemos la peor dependencia de tipo ‚àΩ <i>N</i> <sup>2</sup> .  Al igual que con la ordenaci√≥n de √°rboles, para ordenar el hash, necesita una gran cantidad de datos adicionales, en la <a href="">lista de</a> c√≥digos a <a href="">continuaci√≥n</a> necesita, por ejemplo, 12 bytes adicionales para cada entero ordenable (int32, x86-64).  Una propiedad interesante de la clasificaci√≥n hash es la ausencia de operaciones de comparaci√≥n entre elementos de datos, lo que distingue esta clasificaci√≥n de todos los considerados anteriormente.  M√°s precisamente, estas operaciones son necesarias solo para colisiones.  Al ordenar los datos donde la clave coincide con el elemento de datos completo, puede usar un contador adicional para el n√∫mero de elementos id√©nticos, pero esta es una optimizaci√≥n bastante dudosa.  Tambi√©n puede usar un √°rbol binario en lugar de una lista para almacenar datos de colisiones hash, esto acelera enormemente el trabajo para casos particulares individuales cuando hay muchas colisiones, pero en general, cuando se usa un √°rbol binario, en muchos casos se ralentiza y esto a pesar del hecho de que en este caso el elemento los datos tienen que almacenar casi 100 bytes de informaci√≥n adicional.  Implement√© <a href="">tres opciones para la</a> clasificaci√≥n hash usando un √°rbol binario: uno usa un √°rbol desordenado y los otros dos usan √°rboles est√°ndar de las bibliotecas std y boost.  La ordenaci√≥n hash es pr√°cticamente inadecuada para ordenar cadenas de texto, excepto las muy cortas, ya que es imposible hacer una buena funci√≥n hash para dichos datos.  No pude adaptar el hash est√°ndar de C ++ (unordered_multiset) para ordenar: intent√© usar funciones hash mon√≥tonas y ordenar relaciones en lugar de igualdad; esto no funcion√≥. <br><br>  La ordenaci√≥n de matrices es muy similar a la anterior.  Tambi√©n se usa una matriz auxiliar, donde los valores son ingresados ‚Äã‚Äãpor la funci√≥n hash.  En caso de colisi√≥n, es necesario desplazar el fragmento continuo de los elementos ocupados a la posici√≥n izquierda o derecha, liberando la posici√≥n indicada por la funci√≥n hash para el nuevo elemento.  Para obtener una buena velocidad, es necesario que la matriz auxiliar sea varias veces (de 2-3) m√°s que la original.  Con un aumento en el tama√±o de la matriz auxiliar, la velocidad aumenta solo hasta un cierto l√≠mite, dependiendo de los datos ordenados y la funci√≥n hash asociada a ellos, y luego (t√≠picamente de 4 a 5) disminuye.  La velocidad de operaci√≥n es casi la misma que la del hash, pero en datos buenos un poco m√°s r√°pido y en datos malos es notablemente m√°s lento.  Este tipo tambi√©n necesita mucha memoria extra.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si limitamos el n√∫mero de elementos en la matriz ordenada a un poco m√°s de cuatro mil millones, entonces una matriz auxiliar triple requerir√° la misma cantidad de datos adicionales que la clasificaci√≥n con un hash, y una triplicada requerir√° 28 bytes, que es notablemente menor que para ordenar por un √°rbol, o mucho menos que un hash con arboles. Esta clasificaci√≥n tambi√©n es casi inadecuada para trabajar con cadenas. No hay un art√≠culo de Wikipedia sobre dicho algoritmo, pero aqu√≠ est√° mi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, en Wikipedia, en un buen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> general </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">, no</font></a><font style="vertical-align: inherit;"> se mencionan m√©todos intermedios como la ordenaci√≥n de matrices y el hash, que naturalmente se pueden colocar entre m√©todos basados ‚Äã‚Äãen la comparaci√≥n de elementos y m√©todos basados ‚Äã‚Äãen el valor absoluto de los elementos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una de las clasificaciones m√°s r√°pidas, que nunca utiliza comparaciones en absoluto, es la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">clasificaci√≥n por bits</font></a><font style="vertical-align: inherit;"> conocida desde el siglo XIX.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(clasificaci√≥n de radix). Su idea es muy simple: debe trabajar con grupos de bits de representaci√≥n de datos (para las pruebas tom√© grupos de 8, 11 y 16 bits). Se crean tablas para cada grupo, y los resultados se combinan de una manera relativamente simple. Hay dos formas principales de utilizar la ordenaci√≥n por bits. Es m√°s conveniente tomar los d√≠gitos para ordenar los n√∫meros de derecha a izquierda (esta es la opci√≥n LSD - D√≠gito menos significativo), y para ordenar las cadenas de izquierda a derecha (esta es la opci√≥n MSD - D√≠gito m√°s significativo). La ordenaci√≥n a nivel de bits suele ser significativamente m√°s r√°pida que cualquier otro m√©todo de ordenamiento de datos. Sorprendentemente, el soporte para la ordenaci√≥n bit a bit todav√≠a no es muy significativo: no est√° ni en boost ni en la biblioteca est√°ndar de C ++, ni siquiera conozco su versi√≥n para ninguna biblioteca conocida para trabajar con n√∫meros o cadenas de C ++. Este tipo tienepor supuesto, y desventajas. Es muy sensible al tipo de datos para la clasificaci√≥n, por ejemplo, necesita tener su propia versi√≥n de dicha clasificaci√≥n para datos de cada tama√±o, debe hacer opciones especiales para enteros sin signo y con signo, y el soporte para trabajar con n√∫meros reales puede requerir un poco de esfuerzo. Cuando se usa el orden del byte menos significativo al m√°s importante, su variante generalmente requiere memoria adicional, un poco m√°s que para los datos iniciales (esto es significativamente menor que para ordenar por un hash o una matriz, y a√∫n m√°s por un √°rbol). Adem√°s, esta opci√≥n es de poca utilidad para ordenar cadenas largas. Mi c√≥digo para este tiponecesita hacer opciones especiales para enteros sin signo y con signo, y el soporte para trabajar con n√∫meros reales puede requerir bastante esfuerzo. Cuando se usa el orden del byte menos significativo al m√°s importante, su variante generalmente requiere memoria adicional, un poco m√°s que para los datos iniciales (esto es significativamente menor que para ordenar por un hash o una matriz, y a√∫n m√°s por un √°rbol). Adem√°s, esta opci√≥n es de poca utilidad para ordenar cadenas largas. Mi c√≥digo para este tiponecesita hacer opciones especiales para enteros sin signo y con signo, y el soporte para trabajar con n√∫meros reales puede requerir bastante esfuerzo. Cuando se usa el orden del byte menos significativo al m√°s importante, su variante generalmente requiere memoria adicional, un poco m√°s que para los datos iniciales (esto es significativamente menor que para ordenar por un hash o una matriz, y a√∫n m√°s por un √°rbol). Adem√°s, esta opci√≥n es de poca utilidad para ordenar cadenas largas. Mi c√≥digo para este tipoEsta opci√≥n no es adecuada para clasificar cadenas largas. Mi c√≥digo para este tipoEsta opci√≥n no es adecuada para clasificar cadenas largas. Mi c√≥digo para este tipo</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se basa en el c√≥digo del art√≠culo oms7 mencionado. La opci√≥n de orden de byte inverso es m√°s vers√°til y muy adecuada para clasificar cadenas. Esta opci√≥n se puede implementar sin el uso de memoria adicional (el precio por esto es la p√©rdida de la propiedad de estabilidad), como se hace en la funci√≥n radixsort () de la biblioteca bsd. Mi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para esta opci√≥n, tambi√©n se basa en el c√≥digo oms7, usa memoria adicional, datos de origen un poco m√°s grandes, tiene la propiedad de estabilidad, pero no est√° optimizado para cadenas y, por lo tanto, muestra caracter√≠sticas de rendimiento significativamente peores que la funci√≥n similar sradixsort () de la biblioteca bsd ya mencionada . Esta clasificaci√≥n puede mostrar resultados sorprendentemente pobres cuando se trabaja con matrices num√©ricas peque√±as, trabajando varios √≥rdenes de magnitud m√°s lentamente que incluso la burbuja, aunque estamos hablando de valores muy peque√±os de no m√°s de unos pocos milisegundos y esta diferencia no es f√°cil de notar. Esto se debe al hecho de que utiliza matrices auxiliares de tama√±o peque√±o, pero al ordenar datos de tama√±o peque√±o, estos tama√±os peque√±os pueden ser m√°s grandes que los datos ordenados.Para evitar ralentizaciones, la opci√≥n "de izquierda a derecha" utiliza la clasificaci√≥n de inserci√≥n en lugar de la principal en estos casos. En conclusi√≥n, vale la pena se√±alar que esta es la √∫nica clasificaci√≥n relativamente popular conocida que siempre funciona de manera confiable a una velocidad de ‚àΩ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero el coeficiente de proporcionalidad aqu√≠ depende del tama√±o de los elementos de datos y para cadenas o n√∫meros largos puede ser bastante notable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una opci√≥n para la clasificaci√≥n MSD bit a bit es la clasificaci√≥n por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , una estructura de datos que le permite colocar de manera eficiente las claves de una matriz asociativa. Mi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a pesar de optimizar el uso de la memoria, result√≥ ser muy codiciosa. Por velocidad, se obtuvieron los mejores resultados al clasificar las l√≠neas largas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, consideraremos algunas clasificaciones que se pueden encontrar en las bibliotecas est√°ndar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con el r√°pido de la biblioteca est√°ndar de C (qsort, una variante de GCC), ya escrib√≠ sobre eso. Solo puedo agregar aqu√≠ que esta clasificaci√≥n, as√≠ como otras clasificaciones en C (por ejemplo, las siguientes de la biblioteca BSD) no son adecuadas para trabajar con datos de objetos, en particular, cadenas de C ++, que se debe al hecho de que dichos datos no son </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Teniendo la fuente, el problema se puede resolver f√°cilmente reemplazando las operaciones de memcpy con asignaciones regulares. Tambi√©n puede observar que en algunas bibliotecas C est√°ndar, esta clasificaci√≥n no necesariamente es r√°pida, sino que puede reemplazarse por otras. En la versi√≥n actual para GCC, esta clasificaci√≥n incluso tiene la propiedad de estabilidad. A veces hubo sorpresas con las clasificaciones en C mencionadas durante la recopilaci√≥n de datos, por ejemplo, cuando se trabaja con el tipo std :: vector a trav√©s de un objeto funcional, podr√≠an crear dificultades; puedo recomendar usarlo con datos de objetos con precauci√≥n. Seg√∫n las corridas, esta clasificaci√≥n a veces es relativamente lenta: es notablemente inferior en velocidad a otras implementaciones de clasificaci√≥n r√°pida cuando se trabaja con n√∫meros, pero cuando se trabaja con cadenas si es mejor, solo ordenar con dos puntos de control a veces lo adelanta,pero en l√≠neas largas, el qsort est√°ndar casi siempre lo supera. Lo m√°s interesante fue descubierto cuando intent√© ordenar mil millones de enteros con su ayuda: result√≥ que completar el tipo 7 conduce a una dependencia del tiempo cercana a una ley cuadr√°tica, es decir, a un posible "procesamiento" que dura varios a√±os (no esper√© el final y lo detuve a las 21 horas de carrera). Con menos datos, esta clasificaci√≥n generalmente puede seleccionar puntos de anclaje con los que funciona r√°pidamente.Con menos datos, esta clasificaci√≥n generalmente puede seleccionar puntos de anclaje con los que funciona r√°pidamente.Con menos datos, esta clasificaci√≥n generalmente puede seleccionar puntos de anclaje con los que funciona r√°pidamente.</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ordenaci√≥n </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">introspectiva</font></a><font style="vertical-align: inherit;"> se utiliza en la biblioteca est√°ndar de C ++, aunque el m√©todo exacto utilizado en std :: sort depende de la implementaci√≥n, siempre que se proporcione informaci√≥n sobre GCC. Seg√∫n las corridas, este es el segundo m√°s r√°pido despu√©s de la clasificaci√≥n de dispersi√≥n cuando se trabaja con n√∫meros, y la ventaja de la clasificaci√≥n de dispersi√≥n es peque√±a (de casi 0 a 30%), pero con la clasificaci√≥n de cadenas todo es mucho peor: puede ser 3-4 veces menor que los l√≠deres . En realidad, se trata de una clasificaci√≥n r√°pida, en la que se tienen en cuenta dos casos especiales: 1) si el n√∫mero de recursiones se ha vuelto demasiado grande, se produce el cambio a la clasificaci√≥n por mont√≥n; 2) si el n√∫mero de elementos para la clasificaci√≥n es peque√±o, se produce el cambio a la clasificaci√≥n por inserciones. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Clasificaci√≥n</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estable de la biblioteca est√°ndar de C ++ ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), como su nombre lo indica, tiene la propiedad de estabilidad: conserva el orden relativo entre elementos con la misma clave. Esta propiedad es relativamente rara vez necesaria, aunque escribo sobre ella sin fundamento, solo en base a mi propia experiencia. Puede usar memoria adicional, lo que lo hace m√°s r√°pido. Sorprendentemente, esta clasificaci√≥n suele ser m√°s r√°pida que std :: sort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el lenguaje python s√∫per popular, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clasificaci√≥n </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">de Tim</font></a><font style="vertical-align: inherit;"> se usa como est√°ndar </font><font style="vertical-align: inherit;">. Para las pruebas, utilic√© su versi√≥n del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio de github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Muestra buenos resultados r√©cord en datos parcialmente ordenados, pero en promedio sigue siendo notablemente m√°s lento que los l√≠deres. Por lo general, su velocidad es el promedio entre la clasificaci√≥n r√°pida y la clasificaci√≥n de Shell, aunque en l√≠neas generales a veces est√° cerca de los l√≠deres. Tiene la propiedad de la estabilidad. Implementa un algoritmo relativamente complicado, en cuya implementaci√≥n est√°ndar se descubri√≥ un error en 2015, que, sin embargo, requiere una situaci√≥n poco realista para su manifestaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca BSD C tiene ordenaci√≥n bit a bit ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radixsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y su versi√≥n estable (sradixsort). Desafortunadamente, estos dos tipos solo se pueden usar para C-strings. Como se ver√° en los datos de prueba, esta es la forma m√°s r√°pida de ordenar cadenas hoy en d√≠a y, por lo tanto, es sorprendente que no haya una opci√≥n est√°ndar para las cadenas de C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca cuenta con m√°s de BSD C especie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de combinaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mergesort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Esta clasificaci√≥n se conoce como una de las m√°s r√°pidas para el acceso secuencial a datos (archivos, listas) y probablemente se usa en la biblioteca est√°ndar de C ++ para ordenar listas (std :: list y std :: forward_list). Por cierto, era conocida desde 1948 y uno de sus desarrolladores era un matem√°tico muy conocido y especialista en los primeros sistemas inform√°ticos von Neumann. De los m√©todos r√°pidos, esta clasificaci√≥n no se distingue por las mejores caracter√≠sticas, aunque, por regla general, es algo m√°s r√°pida que los m√©todos Shell. Requiere memoria adicional y generalmente se implementa de manera sostenible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, todav√≠a hay clasificaci√≥n por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(mont√≥n). El mont√≥n generalmente se usa para una cola √≥ptima con prioridades, pero tambi√©n se puede usar para ordenar. Los montones de clasificaci√≥n no requieren memoria adicional, pero no tienen la propiedad de estabilidad. En velocidad para los n√∫meros, es significativamente (hasta 3-6 veces) m√°s lento que los m√©todos de Shell, pero para l√≠neas de l√≠neas no muy cortas, muestra muy buenos resultados, superando (al aumentar la longitud de la l√≠nea, la ventaja crece) m√©todos de Shell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ordenaci√≥n del mont√≥n tambi√©n est√° disponible en la biblioteca est√°ndar de C ++. Dicha clasificaci√≥n se realiza en dos operaciones: construir el mont√≥n (std :: make_heap) y luego ordenar ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: sort_heap)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Aqu√≠, a diferencia de la biblioteca bsd, la ordenaci√≥n es solo una de las operaciones para el mont√≥n. Por lo general, esta opci√≥n de clasificaci√≥n es ligeramente m√°s r√°pida que la anterior (la opci√≥n bsd muestra mejores resultados solo en n√∫meros cortos y l√≠neas s largas).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando la biblioteca est√°ndar de C ++, puede ordenar el √°rbol equilibrado binario (std :: multiset), simplemente llene el √°rbol y luego d√© la vuelta. Este m√©todo puede considerarse una clasificaci√≥n r√°pida no recursiva. Surge un problema en el hecho de que el asignador de memoria est√°ndar es notable por ser lento, por lo que para obtener los mejores resultados necesita usar su propio asignador, que se acelera en aproximadamente un 10-30%. Tambi√©n se puede observar que dicho m√©todo requiere una gran cantidad de memoria adicional, con g ++ para cada elemento de datos, adem√°s de eso, tambi√©n debe almacenar 32 bytes (en la arquitectura x86-64); ser√≠a interesante intentar almacenar dicho √°rbol como un mont√≥n, es decir, sin m√°s byte Si usa boost :: container :: multiset, necesita menos memoria: solo 24 bytes adicionales por elemento de datos. Sin embargo, como impulso,y la biblioteca est√°ndar mostr√≥ una sorpresa desagradable: en el proceso, a veces requer√≠an m√°s memoria de la necesaria. Quiz√°s esto se deba al equilibrio de los √°rboles binarios. C√≥digos</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca de impulso tiene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spreadsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un algoritmo que se invent√≥ en el siglo XXI. Este es el m√©todo general m√°s r√°pido disponible hoy en d√≠a en bibliotecas conocidas. Esta clasificaci√≥n utiliza algunas ideas bit a bit y, al igual que esta, puede ser bastante malhumorada sobre el tipo de argumentos. Por lo general, esta clasificaci√≥n muestra resultados r√©cord, a veces significativamente mejores que los de los competidores m√°s cercanos. La √∫nica excepci√≥n es la clasificaci√≥n de las l√≠neas C, donde es significativamente inferior a los m√©todos bit a bit de la biblioteca bsd. Al ordenar l√≠neas C largas, puede ser inferior a otros m√©todos, por ejemplo, la clasificaci√≥n por rotaci√≥n o la clasificaci√≥n r√°pida con dos puntos de anclaje. La clasificaci√≥n extendida (boost v1.62) mostr√≥ un </font><em><font style="vertical-align: inherit;">problema</font></em><font style="vertical-align: inherit;"> muy desagradable</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Al ordenar peque√±os (hasta 1000 elementos) arrays C-string, funciona con errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n hay un nuevo algoritmo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdqsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que mejora, seg√∫n lo declarado por el autor, la clasificaci√≥n introspectiva. Este nuevo algoritmo, que a√∫n no se describe en Wikipedia. Sus resultados, aunque no est√°n mal, pero no son particularmente impresionantes. Es m√°s lento que std :: sort en enteros cortos, pero m√°s r√°pido en cadenas y enteros largos. En ambos casos, la diferencia es bastante insignificante. Los mejores resultados para esta clasificaci√≥n se obtuvieron para cadenas largas de C ++: aqu√≠ es inferior, aunque notablemente, solo al l√≠der, la clasificaci√≥n extendida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En boost todav√≠a puedes encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spinsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este tambi√©n es un nuevo algoritmo que, a diferencia del anterior, tiene la propiedad de estabilidad y que a√∫n no se describe en Wikipedia. Por lo general, est√° cerca del l√≠der, pero con un notable retraso detr√°s de √©l. Requiere, aunque no demasiado, memoria adicional. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Terminemos</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat_stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la misma biblioteca de impulso. Este es otro nuevo algoritmo robusto que a√∫n no se describe en Wikipedia. Este es, con mucho, el m√©todo m√°s r√°pido, pero ligeramente inferior a la mayor√≠a de los otros m√©todos de biblioteca r√°pida. Utiliza muy poca memoria adicional (sin embargo, siempre necesita una tabla de tama√±o fijo de 8 KB) y a menudo es notablemente m√°s r√°pido que el m√©todo Shell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considera la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mesa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (en ms) de la operaci√≥n de estos algoritmos en una computadora con 8 GB de RAM con un procesador AMD Phenom ‚Ñ¢ II X4 955 @ 3.214 MHz. La computadora funcion√≥ durante un total de varios meses, y el tama√±o total de los datos recopilados en dos archivos json que se cargan con tablas es de casi 400 KB. Los tiempos est√°n dados por el promedio del n√∫mero de carreras; para tama√±os m√°s peque√±os, estas carreras fueron m√°s grandes. Trabajar con el cach√© de una manera bastante complicada cambia la velocidad de los c√°lculos, por lo que los resultados obtenidos son solo aproximados en el mejor de los casos (puedo suponer que las imprecisiones de tiempo pueden alcanzar hasta un 20%). Creo que en los mejores procesadores modernos para PC, el resultado puede obtenerse 2-3 veces m√°s r√°pido, pero debe tenerse en cuenta que muchos procesadores m√°s modernos funcionan al cambiar entre diferentes frecuencias y el resultado obtenido con ellos,Ser√° a√∫n m√°s aproximado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta y la siguiente tabla son interactivas. Adem√°s de los valores absolutos de los tiempos, tambi√©n puede ver sus valores en relaci√≥n con el promedio, la mediana, el m√≠nimo y el m√°ximo. Puedes cambiar la precisi√≥n en los personajes. Tambi√©n puede obtener relaciones de tiempo para diferentes tipos de rellenos y tipos de datos. Este √∫ltimo, por ejemplo, puede mostrar que la clasificaci√≥n de cadenas C es notablemente m√°s r√°pida que las cadenas C ++. Desde los m√©todos de clasificaci√≥n, tambi√©n puede seleccionar y ensamblar una variedad de subconjuntos. Por supuesto, puede establecer la clasificaci√≥n por cualquier columna. Desafortunadamente, no s√© c√≥mo usar Javascript en el art√≠culo en el centro, por lo que las tablas est√°n disponibles solo como referencia. En el caso de que github.io est√© sobrecargado, tambi√©n doy enlaces de respaldo a la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tabla.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tiempo se mide en milisegundos, pero seg√∫n la ley de dependencia del tiempo, para evitar coeficientes demasiado peque√±os, se dan f√≥rmulas para microsegundos. </font><font style="vertical-align: inherit;">Por lo tanto, si sustituimos el valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la f√≥rmula </font><font style="vertical-align: inherit;">, entonces el resultado tambi√©n debe dividirse entre 1000 para obtener un n√∫mero cercano al correspondiente de la tabla. </font><font style="vertical-align: inherit;">La ley de la dependencia del tiempo se deriva sobre la base de los tiempos obtenidos, de una comparaci√≥n de dos resultados (generalmente se toman los extremos). </font><font style="vertical-align: inherit;">Puede verificar la calidad de la ley derivada utilizando la opci√≥n de desviaci√≥n relativa del valor real de la salida.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunas conclusiones generales de los resultados de esta tabla: </font></font><br></p><ul><li> los mejores tipos de shell en datos de hasta 10 millones de elementos pueden superar el orden e incluso algunos tipos r√°pidos; </li><li>  timsort est√° muy cerca en velocidad qsort (clib), a veces adelantando algo, y a veces viceversa; </li><li>  La ordenaci√≥n en exceso y especialmente la clasificaci√≥n en √°rboles a menudo disminuyen notablemente, pero en el contexto de una burbuja o incluso una elecci√≥n, est√° claro que estos todav√≠a son m√©todos r√°pidos.  Curiosamente, ambos m√©todos a menudo tienen caracter√≠sticas muy similares: ambos construyen √°rboles.  Es f√°cil notar que las dependencias para el ordenamiento din√°mico y el ordenamiento arb√≥reo, aunque no son claramente cuadr√°ticas, obviamente no son <i>N</i> log <i>N</i> , pero mucho peores: comp√°relo con la ordenaci√≥n de Shell, que se comporta mucho mejor al aumentar el volumen de datos que el ordenamiento din√°mico o arb√≥reo. que ella misma es m√°s lenta que <i>N</i> log <i>N.</i>  Por lo tanto, las implementaciones pr√°cticas de las clasificaciones de mont√≥n y √°rbol no coinciden con sus especificaciones te√≥ricas; </li><li>  los datos sobre la clasificaci√≥n de cadenas muestran que las leyes de las dependencias de tiempo aqu√≠ no son las mismas que para los n√∫meros: las longitudes de las cadenas que se ordenan aqu√≠ de alguna manera se superponen a estas leyes.  Yo, desafortunadamente, no conozco las f√≥rmulas para clasificaciones conocidas que dar√≠an leyes exactas de dependencias de tiempo cuando se trabaja con cadenas; </li><li>  es interesante que la velocidad de trabajar con n√∫meros reales es casi la misma que los n√∫meros enteros; esto es una consecuencia del hecho de que en la arquitectura moderna x86 se realizan optimizaciones muy efectivas para trabajar con la pila; </li><li>  hash_sort mostr√≥ resultados bastante mediocres, esto es posible debido al hecho de que debido al uso de memoria adicional, el rendimiento de los cach√©s del procesador disminuye dr√°sticamente.  En datos aleatorios peque√±os (menos de cien mil elementos), la clasificaci√≥n hash supera a las mejores clasificaciones r√°pidas.  Tambi√©n puede notar que es posible nuevamente debido a los cach√©s, algunos de los resultados de esta clasificaci√≥n son muy extra√±os, por ejemplo, los enteros 10 <sup>5</sup> , 10 <sup>6</sup> y 10 <sup>7 de</sup> 32 bits cuando se usan rellenos parcialmente ordenados se ordenan por aproximadamente el mismo tiempo!  Alg√∫n tipo de efectos casi cu√°nticos.  :) Estoy seguro de que si buscas, puedes encontrar otros resultados dif√≠ciles de explicar. </li></ul><br><p>  Agregar√© algunas conclusiones m√°s sobre algunos casos especiales: <br></p><ul><li>  Algunos tipos de relleno de datos revelan debilidades en las clasificaciones r√°pidas.  Sin embargo, la elecci√≥n de un elemento de soporte de una manera complicada hace que la probabilidad de caer en una mala secuencia para clasificar sea pr√°cticamente cero.  Tambi√©n puede seleccionar un elemento de soporte en cada pase de diferentes maneras o al azar.  Quiz√°s lo hacen en qsort (clib).  El m√©todo Hoare en consideraci√≥n funciona muy lentamente solo en secuencias especialmente dise√±adas, que se encuentran por casualidad durante el trabajo pr√°ctico; este es un caso con una probabilidad de 2 <sup><i>N</i> -3</sup> / <i>N</i> <sup><i>N</i></sup> , es decir, un evento casi absolutamente imposible.  Aunque si consideramos secuencias en las que el m√©todo Hoar no funciona tan lentamente como sea posible, pero solo con una desaceleraci√≥n significativa, entonces hay muchos m√°s casos de este tipo, que, sin embargo, dejan la probabilidad de que un caso de procesamiento de datos inaceptablemente lento siga siendo pr√°cticamente insignificante, aunque muy molesto en su diferencia de cero  Tambi√©n es casi imposible obtener accidentalmente datos sobre los cuales la clasificaci√≥n r√°pida con dos puntos de control funcionar√° lentamente, de acuerdo con la ley cuadr√°tica.  Las opciones de clasificaci√≥n r√°pida de Lomuto sin y sin un elemento de soporte muestran resultados muy pobres en casi todos los casos de llenado en particular; </li><li>  en algunos casos especiales, la clasificaci√≥n de "burbujas" m√°s lenta da excelentes resultados, y algunas de las clasificaciones m√°s r√°pidas y r√°pidas, por el contrario, son muy malas; </li><li>  La clasificaci√≥n de hash mostr√≥ un resultado muy malo en los rellenos de los tipos 8 y 9, esto se debe a que la secuencia mon√≥tona se toma de valores consecutivos, comenzando por el m√°s peque√±o, y el 1% de los n√∫meros aleatorios se toma del rango del valor m√°s bajo al m√°ximo, lo que aburre todos los 99% consecutivos de los datos en un elemento hash.  Este caso demuestra muy bien los problemas que pueden surgir al usar esta clasificaci√≥n o clasificaci√≥n con una matriz con datos desconocidos; </li><li>  La clasificaci√≥n por selecci√≥n se comporta de manera muy estable en todos los tipos de relleno, las clasificaciones en mont√≥n y en √°rbol tambi√©n son bastante estables, sin picos ni ca√≠das evidentes.  Esto es cierto, por supuesto, para las clases de Shell, as√≠ como para la mayor√≠a de los otros m√©todos r√°pidos de las bibliotecas est√°ndar. </li></ul><br>  Ahora es el momento de hablar sobre los tipos de datos utilizados con los algoritmos de clasificaci√≥n: <br><br><ol><li>  enteros de 32 bits con signo (int32_t), pero solo se utilizaron no negativos.  Tambi√©n se tomaron otros datos num√©ricos solo no negativos; esto no reduce la generalidad de los resultados, pero hace que sea mucho m√°s f√°cil obtenerlos para algunos algoritmos; </li><li>  enteros, con signo de 64 bits (int64_t); </li><li>  enteros, con signo de 128 bits (__int128 - compatible con al menos GCC); </li><li>  estructuras de cinco enteros (int32_t), uno de los cuales se usa como clave (INT1P4).  Al ordenar dichos datos, el n√∫mero de permutaciones comienza a afectar el tiempo de c√°lculo de manera m√°s significativa, por lo tanto, los m√©todos con menos permutaciones obtienen alguna ventaja; </li><li>  n√∫meros reales como precisi√≥n doble, doble (n√∫meros flotantes); </li><li>  cadenas cortas C ++ y C. Se tomaron cadenas de 1 a 16 (cadenas cortas y cadenas c cortas); </li><li>  cadenas C y C ++ de longitud media, cuya longitud es de 1 a 256 (cadenas y cadenas c); </li><li>  l√≠neas largas C y C ++, cuya longitud es de 1 a 2 <sup>20</sup> (esto es un poco m√°s de un mill√≥n), y las l√≠neas se seleccionan para que su longitud promedio no exceda de 512, por lo que las l√≠neas se seleccionaron solo para relleno aleatorio, para otros casos, las l√≠neas simplemente se tomaron longitudes de 1 a 512 (cadenas largas y cadenas c largas). </li></ol><br><p>  Y tambi√©n sobre c√≥mo llenar la matriz fuente para ordenar: <br><br></p><ol><li>  por casualidad </li><li>  estrictamente ascendente (ordenado); </li><li>  estrictamente descendente (orden inverso, inverso); </li><li>  valores aleatorios del rango de 0 a 99 (peque√±a variaci√≥n, baja variaci√≥n 100); </li><li>  secuencia aleatoria de 0 y 1 (peque√±a variaci√≥n, baja variaci√≥n 2); </li><li>  constante 0 (extensi√≥n peque√±a, baja variaci√≥n 1); </li><li>  la secuencia que lleva la versi√≥n qsort (Hoare) a la ejecuci√≥n m√°s lenta.  Es curioso que existan exactamente 2 <sup><i>N</i> -3 de</sup> tales secuencias entre todas las secuencias de longitud <i>N</i> ; </li><li>  estrictamente ascendente, con la inserci√≥n de 1% de n√∫meros aleatorios (parcialmente ordenados); </li><li>  estrictamente descendente, con una inserci√≥n de 1% de variables aleatorias (parcialmente invertidas). </li></ol><br>  Debe enfatizarse que los datos aleatorios son el caso m√°s t√≠pico de llenar una matriz, todos los dem√°s m√©todos son extremadamente raros e incluso casi imposibles durante el funcionamiento normal de un determinado. <br><br>  Veamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> resultados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> prueba, donde las clasificaciones funcionan con todas las secuencias de datos posibles.  El n√∫mero de tales secuencias es igual al factorial de su longitud, por lo tanto, para las secuencias de longitud 12 hay 479'001'600 variantes: una buena PC moderna calcular√° su n√∫mero en menos de un minuto.  Si tomamos secuencias de longitud 14, obtenemos ya 87'178'291'200 variantes para varias horas de funcionamiento de la computadora.  Por lo tanto, la siguiente tabla muestra el tiempo promedio (en ciclos de procesador obtenidos mediante la instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RDTSC</a> ) de una clasificaci√≥n cuando se clasifican todas las permutaciones hasta solo 12. En los datos, se toman los tipos num√©ricos anteriores y las cadenas cortas.  Por supuesto, uno podr√≠a notar que las secuencias con elementos repetitivos no se consideran.  Sin embargo, me atrevo a sugerir que su presencia no cambiar√≠a cualitativamente los resultados, pero podr√≠a retrasar significativamente su recepci√≥n. <br><br>  Los resultados para datos tan peque√±os no son muy representativos, y especialmente para m√©todos de clasificaci√≥n complejos, pero a√∫n complementan la idea del comportamiento de clasificaci√≥n.  Algunos tipos, hasta donde yo s√©, reemplazan su algoritmo principal con otro cuando trabajan con matrices peque√±as: estos son tipos separados, r√°pidos con dos puntos de anclaje y radix_msd (los dos √∫ltimos usan insertos).  Y algunas clasificaciones (flat_stable y radix) usan tablas peque√±as, pero con tama√±os de datos peque√±os, estas tablas resultan ser mucho m√°s grandes que los datos en s√≠, lo que ralentiza en gran medida estos m√©todos en comparaci√≥n con otros y produce resultados extra√±os.  Tambi√©n se obtienen resultados extra√±os con otras clasificaciones bit a bit y con clasificaciones hash y array.  Tales resultados inusuales se explican f√°cilmente por el hecho de que el tiempo de preparaci√≥n de los datos antes de clasificar estos m√©todos para datos peque√±os es m√°s largo que el tiempo de clasificaci√≥n en s√≠.  Por supuesto, al medir intervalos de tiempo tan peque√±os (nanosegundos), la influencia de varios errores en la ley mostrada es mucho mayor que en la tabla anterior.  Por lo tanto, las leyes resultaron ser muy aproximadas, a menudo "con una deriva" a valores exagerados.  Esto √∫ltimo se explica parcialmente por el hecho de que cuando se trabaja con datos peque√±os, el tiempo de clasificaci√≥n en s√≠ se vuelve comparable al tiempo de invocar la funci√≥n de clasificaci√≥n y varias operaciones auxiliares necesarias para medir el tiempo.  El programa intenta restar la sobrecarga nombrada de la salida, pero resulta que se hace m√°s o menos aproximadamente.  Con todo esto, me atrevo a suponer que al comparar los resultados para diferentes tipos de datos y tener en cuenta los comentarios realizados, a veces puede hacer suposiciones que no est√°n muy lejos de ser precisas. <br><br>  En conclusi√≥n, otra tabla que muestra cu√°ntos m√©todos de prueba diferentes se requieren para ordenar memoria adicional.  Obviamente, este valor depende del sistema.  En mis pruebas, como ya escrib√≠, esto es x86-64, GCC.  La letra T significa el tama√±o del tipo en bytes (la longitud de la cadena no est√° incluida en este tama√±o: para las l√≠neas C es el tama√±o del puntero, para las l√≠neas C ++ es el tama√±o del descriptor, 32 bytes para x86-64 GCC), la letra L es el medio la longitud del tipo en bytes (para los n√∫meros esto es T, y para las cadenas es la longitud promedio de la cadena), la letra A puede tener el valor 1 o 0: esta es la alineaci√≥n con el borde de 64 bits y la letra M es la alineaci√≥n del asignador de memoria est√°ndar (se supone se alinea con un l√≠mite de 32 bytes).  El s√≠mbolo <sup>*</sup> significa que los datos para este tipo de clasificaci√≥n se obtuvieron solo sobre la base del an√°lisis de lectura del campo VmRSS desde / proc / PID / status (el campo mencionado es el tama√±o del programa de proceso). <br><br><div class="spoiler">  <b class="spoiler_title">Tabla de memoria adicional</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  M√©todo </th><th>  Adicci√≥n </th></tr><tr><td>  matriz * 1 </td><td align="center">  (T + 1/8) <i>N</i> </td></tr><tr><td>  matriz * k, k&gt; 1 </td><td align="center">  (T + 4k) <i>N</i> </td></tr><tr><td>  burbuja </td><td align="center">  0 0 </td></tr><tr><td>  clib_qsort </td><td align="center">  ‚âàT <i>N</i> / 2 a ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  plano_estable </td><td align="center">  ‚âàT <i>N</i> / 256 </td></tr><tr><td>  hash </td><td align="center">  (T + 8 + 4A) <i>N</i> </td></tr><tr><td>  hashbt </td><td align="center">  (T + 12) <i>N</i> </td></tr><tr><td>  hashbt_boost </td><td align="center">  (56 + T + 4A + M) <i>N</i> </td></tr><tr><td>  hashbt_std </td><td align="center">  (80 + T + 4A + M) <i>N</i> </td></tr><tr><td>  mont√≥n </td><td align="center">  0 0 </td></tr><tr><td>  inserci√≥n </td><td align="center">  0 0 </td></tr><tr><td>  mergesort_bsd </td><td align="center">  ‚âàTlog <sub>2</sub> <i>N</i> a T <i>N</i> <sup>*</sup> </td></tr><tr><td>  pdq </td><td align="center">  Tlog <i>n</i> </td></tr><tr><td>  clasificaci√≥n r√°pida </td><td align="center">  ‚âà16log <sub>2</sub> <i>N</i> a 16 <i>N</i> </td></tr><tr><td>  quicksort_tco </td><td align="center">  de 0 a <i>N</i> </td></tr><tr><td>  radix </td><td align="center">  NT <i>N</i> </td></tr><tr><td>  radix8_trie </td><td align="center">  de ‚âàT <i>N</i> + 24L a ‚âà (T + 24L + 12) <i>N</i> </td></tr><tr><td>  radix_bsd </td><td align="center">  0 0 </td></tr><tr><td>  radix_msd </td><td align="center">  NT <i>N</i> </td></tr><tr><td>  selecci√≥n </td><td align="center">  0 0 </td></tr><tr><td>  concha </td><td align="center">  0 0 </td></tr><tr><td>  girar </td><td align="center">  T <i>N</i> / 2 </td></tr><tr><td>  difundir </td><td align="center">  ‚âà0 </td></tr><tr><td>  sradix_bsd </td><td align="center">  NT <i>N</i> <sup>*</sup> </td></tr><tr><td>  stlsort </td><td align="center">  de 0 a ‚âàTlog <sub>2</sub> <i>N</i> <sup>*</sup> </td></tr><tr><td>  estable </td><td align="center">  de 0 a ‚âàT <i>N</i> / 2 <sup>*</sup> </td></tr><tr><td>  timsort </td><td align="center">  de 0 a ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  Tree_boost </td><td align="center">  (T + 24) <i>N</i> </td></tr><tr><td>  tree_stl </td><td align="center">  (T + 32) <i>N</i> </td></tr></tbody></table></div><br></div></div><br>  Existen, por supuesto, otros m√©todos de clasificaci√≥n, tanto primitivos como r√°pidos.  La biblioteca de impulso tiene algoritmos paralelos que le permiten aprovechar la presencia de n√∫cleos de procesador adicionales en el sistema.  Tambi√©n puede usar el contenedor de pedido autom√°tico boost :: container :: flat_multiset en lugar de std :: multiset, pero funciona muy lentamente. <br><br>  Aprovecho esta oportunidad para decir algunos comentarios sobre la biblioteca de impulso en general.  Recomiendo no pasar de largo.  Incluso las caracter√≠sticas que est√°n en la biblioteca est√°ndar en boost, como regla, se implementan mejor y, a veces (como las expresiones regulares, por ejemplo) son mucho mejores.  Si hablamos de contenedores, entonces en boost son notablemente m√°s grandes, y los que coinciden con los est√°ndar son a veces algo m√°s r√°pidos y a menudo tienen mejoras peque√±as, pero agradables.  Boost comprueba los tipos m√°s a fondo, lo que a veces puede ayudar a detectar errores casi evasivos que generalmente no se manifiestan, pero en algunas circunstancias pueden activarse inesperadamente.  Las desventajas de boost incluyen mensajes incondicionalmente completamente ilegibles y de gran volumen sobre errores de compilaci√≥n en muchas construcciones de esta biblioteca; esto, aunque en menor medida, se aplica a la biblioteca est√°ndar.  Es hora de que los desarrolladores de C ++ hagan algo al respecto. <br><br>  Todos los archivos con pruebas y algunos otros materiales relacionados se pueden tomar de mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> .  Si alguien est√° interesado en los datos de origen sin procesar, puede obtenerlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (1,4 MB).  Estar√© encantado de cualquier comentario, cr√≠tica y adiciones. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467473/">https://habr.com/ru/post/467473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467459/index.html">C√≥mo un microcontrolador puede leer datos a 1.6 Gbps</a></li>
<li><a href="../467461/index.html">RubyRussia 2019. Julian Pokrovsky: c√≥mo optimizar un monolito</a></li>
<li><a href="../467463/index.html">Solo divisi√≥n, o c√≥mo crear una teor√≠a matem√°tica y ganar $ 400K con ella. Serie tres, final</a></li>
<li><a href="../467465/index.html">¬øLa nube salvar√° los tel√©fonos inteligentes con un presupuesto ultrabajo?</a></li>
<li><a href="../467471/index.html">Soul Mikrotik contra ILV sin alma y el mismo proveedor</a></li>
<li><a href="../467475/index.html">Devuelva Thread.Abort () a .NET Core. Entrega de aplicaciones con su versi√≥n de CoreCLR y CoreFX</a></li>
<li><a href="../467477/index.html">Kubernetes 1.16: Aspectos destacados</a></li>
<li><a href="../467479/index.html">Kir Shatrov: Shopify comenz√≥ con Rails y aqu√≠ les encanta este marco.</a></li>
<li><a href="../467485/index.html">Resoluci√≥n de problemas con pwnable.kr 23 - calculadora md5. Nos ocupamos de Stack Canary. Conexi√≥n de bibliotecas C en python</a></li>
<li><a href="../467487/index.html">Sobre el futuro de los pagos de blockchain y criptomonedas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>