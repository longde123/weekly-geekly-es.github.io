<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèæ ‚ôëÔ∏è üë©üèΩ‚Äçüíª CPU-Kerne oder was ist SMP und was frisst es üôá üë®üèº‚Äçüîß üèâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Guten Tag, heute m√∂chte ich ein ziemlich einfaches Thema ansprechen, das gew√∂hnlichen Programmierern fast unbekannt ist, aber jeder von I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CPU-Kerne oder was ist SMP und was frisst es</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426497/"><h2>  Einf√ºhrung </h2><br>  Guten Tag, heute m√∂chte ich ein ziemlich einfaches Thema ansprechen, das gew√∂hnlichen Programmierern fast unbekannt ist, aber jeder von Ihnen hat es h√∂chstwahrscheinlich verwendet. <br>  Es geht um symmetrisches Multiprocessing (im Volksmund - SMP) - die Architektur, die in allen Multitasking-Betriebssystemen zu finden ist und nat√ºrlich ein wesentlicher Bestandteil davon ist.  Jeder wei√ü, dass der Prozessor umso leistungsf√§higer ist, je mehr Kerne ein Prozessor hat. Ja, aber wie kann ein Betriebssystem mehrere Kerne gleichzeitig verwenden?  Einige Programmierer gehen nicht auf diese Abstraktionsebene - sie brauchen sie einfach nicht, aber ich denke, jeder wird daran interessiert sein, wie SMP funktioniert. <br><a name="habracut"></a><br><h2>  Multitasking und seine Implementierung </h2><br>  Diejenigen, die jemals Computerarchitektur studiert haben, wissen, dass der Prozessor selbst nicht mehrere Aufgaben gleichzeitig ausf√ºhren kann. Multitasking gibt uns nur das Betriebssystem, das diese Aufgaben umschaltet.  Es gibt verschiedene Arten von Multitasking, aber das am besten geeignete, bequemste und am weitesten verbreitete ist das Verdr√§ngen von Multitasking (Sie k√∂nnen die Hauptaspekte auf Wikipedia lesen).  Es basiert auf der Tatsache, dass jeder Prozess (Aufgabe) seine eigene Priorit√§t hat, was sich darauf auswirkt, wie viel Prozessorzeit ihm zugewiesen wird.  Jede Aufgabe erh√§lt eine Zeitscheibe, in der der Prozess etwas unternimmt. Nach Ablauf der Zeitscheibe √ºbertr√§gt das Betriebssystem die Kontrolle auf eine andere Aufgabe.  Es stellt sich die Frage, wie Computerressourcen wie Speicher, Ger√§te usw. verteilt werden sollen.  zwischen Prozessen?  Alles ist sehr einfach: Windows macht es selbst, Linux verwendet ein Semaphorsystem.  Aber ein Kern ist nicht ernst, wir gehen weiter. <br><br><h3>  Interrupts und PIC </h3><br>  Vielleicht wird sich dies f√ºr einige als Neuigkeit herausstellen, f√ºr andere nicht, aber f√ºr die i386-Architektur (ich werde √ºber die x86-Architektur sprechen, ARM z√§hlt nicht, weil ich diese Architektur nicht studiert habe und nie darauf gesto√üen bin (selbst auf der Ebene des Schreibens eines Dienstes oder eines residenten Programms)) verwendet Interrupts (wir werden nur √ºber Hardware-Unterbrechungen, IRQ sprechen), um das Betriebssystem oder Programm √ºber ein Ereignis zu benachrichtigen.  Zum Beispiel gibt es einen Interrupt 0x8 (f√ºr gesch√ºtzte und lange Modi, zum Beispiel 0x20, abh√§ngig davon, wie der PIC konfiguriert wird, dazu sp√§ter mehr), der von PIT aufgerufen wird und beispielsweise Interrupts mit jeder erforderlichen Frequenz erzeugen kann.  Dann wird die Arbeit des Betriebssystems f√ºr die Verteilung von Zeitquanten auf 0 reduziert, wenn ein Interrupt aufgerufen wird, das Programm stoppt und die Steuerung beispielsweise dem Kernel gegeben wird, der wiederum die aktuellen Programmdaten (Register, Flags usw.) speichert und die Steuerung f√ºr den n√§chsten Prozess gibt . <br><br>  Wie Sie wahrscheinlich verstanden haben, sind Interrupts Funktionen (oder Prozeduren), die zu einem bestimmten Zeitpunkt vom Ger√§t oder vom Programm selbst aufgerufen werden.  Insgesamt unterst√ºtzt der Prozessor 16 Interrupts auf zwei PICs.  Der Prozessor verf√ºgt √ºber Flags, und eines davon ist das I-Flag - Interrupt Control.  Wenn Sie dieses Flag auf 0 setzen, verursacht der Prozessor keine Hardwareunterbrechungen.  Ich m√∂chte aber auch darauf hinweisen, dass es sogenannte NMIs - Non-Maskable Interrupts - gibt. Interrupt-Daten werden weiterhin aufgerufen, auch wenn Bit I auf 0 gesetzt ist. Mit der PIC-Programmierung k√∂nnen Sie Interrupt-Daten deaktivieren, jedoch nach R√ºckkehr von einem Interrupt mit IRET - sie werden wieder nicht verboten.  Ich stelle fest, dass Sie unter einem regul√§ren Programm den Interrupt-Aufruf nicht verfolgen k√∂nnen - Ihr Programm stoppt und wird erst nach einer Weile fortgesetzt, Ihr Programm bemerkt es nicht einmal (ja, Sie k√∂nnen √ºberpr√ºfen, ob der Interrupt aufgerufen wurde - aber warum? <br><br><h5>  PIC - Programmable Interrupt Controller </h5><br>  Aus dem Wiki: <br><blockquote>  In der Regel handelt es sich um ein elektronisches Ger√§t, das manchmal als Teil des Prozessors selbst oder als komplexe Chips seines Rahmens hergestellt wird und dessen Eing√§nge elektrisch mit den entsprechenden Ausg√§ngen verschiedener Ger√§te verbunden sind.  Die Eingangsnummer des Interrupt-Controllers wird durch ‚ÄûIRQ‚Äú angezeigt.  Diese Nummer sollte sowohl von der Interrupt-Priorit√§t als auch von der Eintragsnummer in der Interrupt-Vektortabelle (INT) unterschieden werden.  So werden beispielsweise in einem IBM PC im Real-Modus (MS-DOS wird in diesem Modus ausgef√ºhrt) des Prozessors f√ºr die Unterbrechung der Standardtastatur IRQ 1 und INT 9 verwendet. <br><br>  Die urspr√ºngliche IBM PC-Plattform verwendet ein sehr einfaches Interrupt-Schema.  Der Interrupt-Controller ist ein einfacher Z√§hler, der entweder nacheinander die Signale verschiedener Ger√§te durchl√§uft oder auf den Anfang zur√ºckgesetzt wird, wenn ein neuer Interrupt gefunden wird.  Im ersten Fall haben Ger√§te die gleiche Priorit√§t, im zweiten Fall haben Ger√§te mit einer niedrigeren (oder h√∂heren in der Z√§hlung) Seriennummer eine h√∂here Priorit√§t. </blockquote><br>  Wie Sie verstehen, handelt es sich hierbei um eine elektronische Schaltung, mit der Ger√§te Interrupt-Anforderungen senden k√∂nnen. In der Regel gibt es genau zwei davon. <br><br>  Kommen wir nun zum Thema des Artikels. <br><br><h2>  SMP </h2><br>  Um diesen Standard zu implementieren, wurden neue Schemata auf Motherboards installiert: APIC und ACPI.  Sprechen wir √ºber den ersten. <br><br>  APIC - Advanced Programmable Interrupt Controller, eine verbesserte Version von PIC.  Es wird in Multiprozessorsystemen verwendet und ist ein wesentlicher Bestandteil aller neuesten Intel-Prozessoren (und kompatibel).  APIC wird f√ºr die komplexe Interrupt-Weiterleitung und zum Senden von Interrupts zwischen Prozessoren verwendet.  Diese Dinge waren mit der √§lteren PIC-Spezifikation nicht m√∂glich. <br><br><h3>  Lokaler APIC und IO APIC </h3><br>  In einem APIC-basierten System besteht jeder Prozessor aus einem "Kern" und einem "lokalen APIC".  Der lokale APIC ist f√ºr die Verarbeitung der prozessorspezifischen Interrupt-Konfiguration verantwortlich.  Unter anderem enth√§lt es eine lokale Vektortabelle (LVT), die Ereignisse wie die "interne Uhr" und andere "lokale" Interruptquellen in einen Interruptvektor √ºbersetzt (z. B. kann der Kontakt LocalINT1 eine NMI-Ausnahme ausl√∂sen, w√§hrend " 2 ‚Äùzum entsprechenden LVT-Eingang). <br><br>  Weitere Informationen zum lokalen APIC finden Sie im "System Programming Guide" moderner Intel-Prozessoren. <br><br>  Dar√ºber hinaus gibt es ein APIC IO (z. B. Intel 82093AA), das Teil des Chipsatzes ist und eine Interrupt-Steuerung f√ºr mehrere Prozessoren bietet, einschlie√ülich statischer und dynamischer symmetrischer Verteilung von Interrupts f√ºr alle Prozessoren.  Auf Systemen mit mehreren E / A-Subsystemen kann jedes Subsystem seinen eigenen Satz von Interrupts haben. <br><br>  Jeder Interrupt-Pin wird einzeln als flanken- oder pegelgetriggert programmiert.  Der Interrupt-Vektor und die Interrupt-Steuerinformationen k√∂nnen f√ºr jeden Interrupt angegeben werden.  Das indirekte Registerzugriffsschema optimiert den Speicherplatz, der f√ºr den Zugriff auf die internen APIC-E / A-Register ben√∂tigt wird.  Um die Systemflexibilit√§t bei der Zuweisung von Speicherplatz zu erh√∂hen, k√∂nnen die beiden APIC-E / A-Register verschoben werden. Der Standardwert ist jedoch 0xFEC00000. <br><br><h3>  Initialisierung eines "lokalen" APIC </h3><br>  Der lokale APIC wird beim Booten aktiviert und kann durch Zur√ºcksetzen von Bit 11 IA32_APIC_BASE (MSR) deaktiviert werden (dies funktioniert nur bei Prozessoren mit einer Familie&gt; 5, da Pentium keinen solchen MSR hat). Dann empf√§ngt der Prozessor seine Interrupts direkt vom kompatiblen 8259 PIC .  Im Intel-Handbuch zur Softwareentwicklung hei√üt es jedoch, dass Sie den lokalen APIC nach dem Deaktivieren √ºber IA32_APIC_BASE erst einschalten k√∂nnen, wenn er vollst√§ndig zur√ºckgesetzt wurde.  Das APO IO kann auch so konfiguriert werden, dass es im Legacy-Modus arbeitet, sodass es ein 8259-Ger√§t emuliert. <br><br>  Lokale APICs werden der physischen Seite FEE00xxx zugeordnet (siehe Tabelle 8-1 Intel P4 SPG).  Diese Adresse ist f√ºr jeden lokalen APIC, der in der Konfiguration vorhanden ist, gleich. Dies bedeutet, dass Sie direkt auf die Register des lokalen APIC-Kernels zugreifen k√∂nnen, in dem Ihr Code gerade ausgef√ºhrt wird.  Beachten Sie, dass es einen MSR gibt, der die tats√§chliche APIC-Basis definiert (nur f√ºr Prozessoren mit einer Familie&gt; 5 verf√ºgbar).  MADT enth√§lt eine lokale APIC-Basis, und auf 64-Bit-Systemen kann es auch ein Feld enthalten, das eine 64-Bit-Neudefinition der Basisadresse angibt, die Sie stattdessen verwenden sollten.  Sie k√∂nnen die lokale APIC-Basis nur dort lassen, wo Sie sie finden, oder sie verschieben, wo immer Sie m√∂chten.  Hinweis: Ich glaube nicht, dass Sie es weiter als bis zu 4 GB RAM verschieben k√∂nnen. <br><br>  Damit der lokale APIC Interrupts empfangen kann, m√ºssen Sie das Spurious Interrupt Vector Register konfigurieren.  Der richtige Wert f√ºr dieses Feld ist die IRQ-Nummer, die Sie falschen Interrupts mit den unteren 8 Bits zuordnen m√∂chten, und das 8. Bit, das auf 1 gesetzt ist, um APIC tats√§chlich zu aktivieren (Einzelheiten finden Sie in der Spezifikation).  Sie m√ºssen eine Interrupt-Nummer ausw√§hlen, f√ºr die die unteren 4 Bits gesetzt sind.  Am einfachsten ist es, 0xFF zu verwenden.  Dies ist f√ºr einige √§ltere Prozessoren wichtig, da f√ºr diese Werte die unteren 4 Bits auf 1 gesetzt werden m√ºssen. <br><br>  Deaktivieren Sie den 8259 PIC korrekt.  Dies ist fast so wichtig wie die Konfiguration von APIC.  Sie tun dies in zwei Schritten: Maskieren aller Interrupts und Neuzuweisen des IRQ.  Durch das Verschleiern aller Interrupts werden diese im PIC deaktiviert.  Das erneute Zuordnen von Interrupts haben Sie wahrscheinlich bereits bei der Verwendung von PIC durchgef√ºhrt: Sie m√∂chten, dass Interrupt-Anforderungen bei 32 statt bei 0 beginnen, um Konflikte mit Ausnahmen zu vermeiden (im gesch√ºtzten und langen (langen) Prozessormodus, weil Die ersten 32 Interrupts sind Ausnahmen.  Dann sollten Sie vermeiden, diese Interruptvektoren f√ºr andere Zwecke zu verwenden.  Dies ist erforderlich, da trotz der Tatsache, dass Sie alle PIC-Interrupts maskiert haben, immer noch falsche Interrupts ausgel√∂st werden k√∂nnen, die dann f√§lschlicherweise als Ausnahmen in Ihrem Kernel verarbeitet werden. <br>  Fahren wir mit SMP fort. <br><br><h3>  Symmetrisches Multitasking: Initialisierung </h3><br>  Die Startreihenfolge ist f√ºr verschiedene CPUs unterschiedlich.  Das Intel Programmer's Guide (Abschnitt 7.5.4) enth√§lt ein Initialisierungsprotokoll f√ºr Intel Xeon-Prozessoren und gilt nicht f√ºr √§ltere Prozessoren.  Einen allgemeinen Algorithmus f√ºr alle Prozessortypen finden Sie unter Intel Multiprocessor Specification. <br><br>  F√ºr 80486 (mit externem APIC 8249DX) m√ºssen Sie IPIT INIT verwenden, gefolgt von der IPI-Deaktivierung der INIT-Ebene ohne SIPI.  Dies bedeutet, dass Sie ihnen nicht sagen k√∂nnen, wo sie mit der Ausf√ºhrung Ihres Codes (dem Vektorteil von SIPI) beginnen sollen, und sie beginnen immer mit der Ausf√ºhrung von BIOS-Code.  In diesem Fall setzen Sie den CMOS-BIOS-R√ºcksetzwert auf ‚ÄûWarmstart mit Weitsprung‚Äú (dh setzen Sie die CMOS-Position 0x0F auf 10), damit das BIOS jmp far ~ [0: 0x0469] ausf√ºhrt, und setzen dann das Segment und den Offset AP-Einstiegspunkte bei 0x0469. <br><br>  Das IPI "INIT Level De-Assert" wird auf neuen Prozessoren (Pentium 4 und Intel Xeon) nicht unterst√ºtzt, und AFAIK wird auf diesen Prozessoren vollst√§ndig ignoriert. <br><br>  F√ºr neuere Prozessoren (P6, Pentium 4) reicht ein SIPI aus, aber ich bin mir nicht sicher, ob √§ltere Intel-Prozessoren (Pentium) oder Prozessoren anderer Hersteller einen zweiten SIPI ben√∂tigen.  Es ist auch m√∂glich, dass ein zweiter SIPI im Falle eines Zustellungsfehlers f√ºr den ersten SIPI (Busrauschen usw.) vorhanden ist. <br><br>  Normalerweise sende ich das erste SIPI und warte dann ab, ob der AP die Anzahl der laufenden Prozessoren erh√∂ht.  Wenn dieser Z√§hler nicht innerhalb weniger Millisekunden erh√∂ht wird, sende ich einen zweiten SIPI.  Dies unterscheidet sich vom allgemeinen Intel-Algorithmus (der eine Verz√∂gerung von 200 Mikrosekunden zwischen SIPI aufweist), aber es ist nicht so einfach, eine Zeitquelle zu finden, die die Verz√∂gerung von 200 Mikrosekunden w√§hrend eines fr√ºhen Startvorgangs genau messen kann.  Ich habe auch festgestellt, dass auf realer Hardware, wenn die Verz√∂gerung zwischen SIPI zu lang ist (und Sie meine Methode nicht verwenden), der Haupt-AP den fr√ºhen AP-Startcode f√ºr das Betriebssystem zweimal ausf√ºhren kann (was in meinem Fall dazu f√ºhrt, dass das Betriebssystem dies denkt Wir haben doppelt so viele Prozessoren wie wir tats√§chlich sind. <br><br>  Sie k√∂nnen diese Signale auf dem Bus senden, um jedes vorhandene Ger√§t zu starten.  Sie k√∂nnen jedoch auch Prozessoren aktivieren, die speziell deaktiviert wurden (weil sie "defekt" waren). <br><br><h3>  Suchen Sie nach Informationen mithilfe der MT-Tabelle </h3><br>  Einige Informationen (die auf neueren Computern m√∂glicherweise nicht verf√ºgbar sind) sind f√ºr die Mehrfachverarbeitung vorgesehen.  Zuerst m√ºssen Sie die MP-Floating-Pointer-Struktur finden.  Es ist an einer 16-Byte-Grenze ausgerichtet und enth√§lt eine Signatur am Anfang von "_MP_" oder 0x5F504D5F.  Das Betriebssystem sollte in EBDA, im BIOS-ROM-Bereich und im letzten Kilobyte ‚ÄûBasisspeicher‚Äú angezeigt werden.  Die Gr√∂√üe des Basisspeichers wird in einem 2-Byte-Wert von 0x413 in Kilobyte minus 1 KB angegeben.  So sieht die Struktur aus: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  So sieht die Konfigurationstabelle aus, auf die die schwebende Struktur des Zeigers zeigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  Nach der Konfigurationstabelle befinden sich die Eintr√§ge entry_count, die weitere Informationen zum System enthalten, gefolgt von einer erweiterten Tabelle.  Eintr√§ge sind entweder 20 Bytes, um den Prozessor darzustellen, oder 8 Bytes f√ºr etwas anderes.  So sehen APIC-Prozessor- und E / A-Datens√§tze aus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Hier ist der IO APIC-Eintrag. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  Suchen Sie nach Informationen mit APIC </h3><br>  Sie finden die MADT-Tabelle (APIC) in ACPI.  In der Tabelle sind die lokalen APICs aufgef√ºhrt, deren Anzahl der Anzahl der Kerne auf Ihrem Prozessor entsprechen sollte.  Die Details dieser Tabelle sind nicht hier, aber Sie k√∂nnen sie im Internet finden. <br><br><h3>  Starten Sie AP </h3><br>  Nachdem Sie die Informationen gesammelt haben, m√ºssen Sie den PIC deaktivieren und sich auf den APIC I / O vorbereiten.  Sie m√ºssen auch den BSP des lokalen APIC konfigurieren.  Starten Sie dann den AP mit SIPI. <br><br>  <b>Code zum Starten von Kerneln:</b> <br><br>  Ich stelle fest, dass der Vektor, den Sie beim Start angeben, die Startadresse angibt: Vektor 0x8 - Adresse 0x8000, Vektor 0x9 - Adresse 0x9000 usw. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">org</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>] AP: jmp short bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0</span></span>x7c00 xor ax,ax mov ds,ax ; Mark CPU as active lock inc byte [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x9090 ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Wie Sie verstehen, m√ºssen Sie den Stapel f√ºr jeden Kern, jeden Kern, seine Interrupts usw. konfigurieren, damit das Betriebssystem viele Kerne verwenden kann. Das Wichtigste ist jedoch, dass bei Verwendung der symmetrischen Mehrfachverarbeitung alle Ressourcen der Kerne gleich sind: ein Speicher, Eine PCI usw. und das Betriebssystem k√∂nnen nur Aufgaben zwischen den Kernen parallelisieren. <br><br>  Ich hoffe, dass der Artikel nicht langweilig genug und recht informativ ist.  Ich denke, wir k√∂nnen das n√§chste Mal dar√ºber sprechen, wie sie fr√ºher auf dem Bildschirm gezeichnet haben (und jetzt zeichnen sie), ohne Shader und coole Grafikkarten zu verwenden. <br><br>  Viel Gl√ºck </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426497/">https://habr.com/ru/post/de426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
<li><a href="../de426489/index.html">√úber das Verh√§ltnis von Primzahlen und irrationalen Zahlen</a></li>
<li><a href="../de426491/index.html">Sicherheitswoche 39: Zum Tod von Google+</a></li>
<li><a href="../de426493/index.html">St√§ndige Rabatte von Hostern f√ºr Besucher von VPS und VPS.today Search</a></li>
<li><a href="../de426495/index.html">Solo Designer. Wie man eine Karriere aufbaut, wenn man alleine arbeitet</a></li>
<li><a href="../de426499/index.html">Bildungsprogramm f√ºr die Arbeit mit Lochkarten (oder die Geschichte, wie ‚ÄûBig Data‚Äú von 1890 bis 1970 verarbeitet wurde)</a></li>
<li><a href="../de426501/index.html">Lamoda von innen: Warum der Online-Shop von 300 Ingenieuren</a></li>
<li><a href="../de426503/index.html">SAP HANA-Funktionalit√§t als Datenbank f√ºr die SAP HANA Data Management Suite</a></li>
<li><a href="../de426505/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. Oktober</a></li>
<li><a href="../de426507/index.html">Erstellen einer Architektur: Arbeiten mit dem iOS-Koordinatormuster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>