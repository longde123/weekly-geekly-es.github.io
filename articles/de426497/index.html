<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏾 ♑️ 👩🏽‍💻 CPU-Kerne oder was ist SMP und was frisst es 🙇 👨🏼‍🔧 🏉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Guten Tag, heute möchte ich ein ziemlich einfaches Thema ansprechen, das gewöhnlichen Programmierern fast unbekannt ist, aber jeder von I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CPU-Kerne oder was ist SMP und was frisst es</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426497/"><h2>  Einführung </h2><br>  Guten Tag, heute möchte ich ein ziemlich einfaches Thema ansprechen, das gewöhnlichen Programmierern fast unbekannt ist, aber jeder von Ihnen hat es höchstwahrscheinlich verwendet. <br>  Es geht um symmetrisches Multiprocessing (im Volksmund - SMP) - die Architektur, die in allen Multitasking-Betriebssystemen zu finden ist und natürlich ein wesentlicher Bestandteil davon ist.  Jeder weiß, dass der Prozessor umso leistungsfähiger ist, je mehr Kerne ein Prozessor hat. Ja, aber wie kann ein Betriebssystem mehrere Kerne gleichzeitig verwenden?  Einige Programmierer gehen nicht auf diese Abstraktionsebene - sie brauchen sie einfach nicht, aber ich denke, jeder wird daran interessiert sein, wie SMP funktioniert. <br><a name="habracut"></a><br><h2>  Multitasking und seine Implementierung </h2><br>  Diejenigen, die jemals Computerarchitektur studiert haben, wissen, dass der Prozessor selbst nicht mehrere Aufgaben gleichzeitig ausführen kann. Multitasking gibt uns nur das Betriebssystem, das diese Aufgaben umschaltet.  Es gibt verschiedene Arten von Multitasking, aber das am besten geeignete, bequemste und am weitesten verbreitete ist das Verdrängen von Multitasking (Sie können die Hauptaspekte auf Wikipedia lesen).  Es basiert auf der Tatsache, dass jeder Prozess (Aufgabe) seine eigene Priorität hat, was sich darauf auswirkt, wie viel Prozessorzeit ihm zugewiesen wird.  Jede Aufgabe erhält eine Zeitscheibe, in der der Prozess etwas unternimmt. Nach Ablauf der Zeitscheibe überträgt das Betriebssystem die Kontrolle auf eine andere Aufgabe.  Es stellt sich die Frage, wie Computerressourcen wie Speicher, Geräte usw. verteilt werden sollen.  zwischen Prozessen?  Alles ist sehr einfach: Windows macht es selbst, Linux verwendet ein Semaphorsystem.  Aber ein Kern ist nicht ernst, wir gehen weiter. <br><br><h3>  Interrupts und PIC </h3><br>  Vielleicht wird sich dies für einige als Neuigkeit herausstellen, für andere nicht, aber für die i386-Architektur (ich werde über die x86-Architektur sprechen, ARM zählt nicht, weil ich diese Architektur nicht studiert habe und nie darauf gestoßen bin (selbst auf der Ebene des Schreibens eines Dienstes oder eines residenten Programms)) verwendet Interrupts (wir werden nur über Hardware-Unterbrechungen, IRQ sprechen), um das Betriebssystem oder Programm über ein Ereignis zu benachrichtigen.  Zum Beispiel gibt es einen Interrupt 0x8 (für geschützte und lange Modi, zum Beispiel 0x20, abhängig davon, wie der PIC konfiguriert wird, dazu später mehr), der von PIT aufgerufen wird und beispielsweise Interrupts mit jeder erforderlichen Frequenz erzeugen kann.  Dann wird die Arbeit des Betriebssystems für die Verteilung von Zeitquanten auf 0 reduziert, wenn ein Interrupt aufgerufen wird, das Programm stoppt und die Steuerung beispielsweise dem Kernel gegeben wird, der wiederum die aktuellen Programmdaten (Register, Flags usw.) speichert und die Steuerung für den nächsten Prozess gibt . <br><br>  Wie Sie wahrscheinlich verstanden haben, sind Interrupts Funktionen (oder Prozeduren), die zu einem bestimmten Zeitpunkt vom Gerät oder vom Programm selbst aufgerufen werden.  Insgesamt unterstützt der Prozessor 16 Interrupts auf zwei PICs.  Der Prozessor verfügt über Flags, und eines davon ist das I-Flag - Interrupt Control.  Wenn Sie dieses Flag auf 0 setzen, verursacht der Prozessor keine Hardwareunterbrechungen.  Ich möchte aber auch darauf hinweisen, dass es sogenannte NMIs - Non-Maskable Interrupts - gibt. Interrupt-Daten werden weiterhin aufgerufen, auch wenn Bit I auf 0 gesetzt ist. Mit der PIC-Programmierung können Sie Interrupt-Daten deaktivieren, jedoch nach Rückkehr von einem Interrupt mit IRET - sie werden wieder nicht verboten.  Ich stelle fest, dass Sie unter einem regulären Programm den Interrupt-Aufruf nicht verfolgen können - Ihr Programm stoppt und wird erst nach einer Weile fortgesetzt, Ihr Programm bemerkt es nicht einmal (ja, Sie können überprüfen, ob der Interrupt aufgerufen wurde - aber warum? <br><br><h5>  PIC - Programmable Interrupt Controller </h5><br>  Aus dem Wiki: <br><blockquote>  In der Regel handelt es sich um ein elektronisches Gerät, das manchmal als Teil des Prozessors selbst oder als komplexe Chips seines Rahmens hergestellt wird und dessen Eingänge elektrisch mit den entsprechenden Ausgängen verschiedener Geräte verbunden sind.  Die Eingangsnummer des Interrupt-Controllers wird durch „IRQ“ angezeigt.  Diese Nummer sollte sowohl von der Interrupt-Priorität als auch von der Eintragsnummer in der Interrupt-Vektortabelle (INT) unterschieden werden.  So werden beispielsweise in einem IBM PC im Real-Modus (MS-DOS wird in diesem Modus ausgeführt) des Prozessors für die Unterbrechung der Standardtastatur IRQ 1 und INT 9 verwendet. <br><br>  Die ursprüngliche IBM PC-Plattform verwendet ein sehr einfaches Interrupt-Schema.  Der Interrupt-Controller ist ein einfacher Zähler, der entweder nacheinander die Signale verschiedener Geräte durchläuft oder auf den Anfang zurückgesetzt wird, wenn ein neuer Interrupt gefunden wird.  Im ersten Fall haben Geräte die gleiche Priorität, im zweiten Fall haben Geräte mit einer niedrigeren (oder höheren in der Zählung) Seriennummer eine höhere Priorität. </blockquote><br>  Wie Sie verstehen, handelt es sich hierbei um eine elektronische Schaltung, mit der Geräte Interrupt-Anforderungen senden können. In der Regel gibt es genau zwei davon. <br><br>  Kommen wir nun zum Thema des Artikels. <br><br><h2>  SMP </h2><br>  Um diesen Standard zu implementieren, wurden neue Schemata auf Motherboards installiert: APIC und ACPI.  Sprechen wir über den ersten. <br><br>  APIC - Advanced Programmable Interrupt Controller, eine verbesserte Version von PIC.  Es wird in Multiprozessorsystemen verwendet und ist ein wesentlicher Bestandteil aller neuesten Intel-Prozessoren (und kompatibel).  APIC wird für die komplexe Interrupt-Weiterleitung und zum Senden von Interrupts zwischen Prozessoren verwendet.  Diese Dinge waren mit der älteren PIC-Spezifikation nicht möglich. <br><br><h3>  Lokaler APIC und IO APIC </h3><br>  In einem APIC-basierten System besteht jeder Prozessor aus einem "Kern" und einem "lokalen APIC".  Der lokale APIC ist für die Verarbeitung der prozessorspezifischen Interrupt-Konfiguration verantwortlich.  Unter anderem enthält es eine lokale Vektortabelle (LVT), die Ereignisse wie die "interne Uhr" und andere "lokale" Interruptquellen in einen Interruptvektor übersetzt (z. B. kann der Kontakt LocalINT1 eine NMI-Ausnahme auslösen, während " 2 ”zum entsprechenden LVT-Eingang). <br><br>  Weitere Informationen zum lokalen APIC finden Sie im "System Programming Guide" moderner Intel-Prozessoren. <br><br>  Darüber hinaus gibt es ein APIC IO (z. B. Intel 82093AA), das Teil des Chipsatzes ist und eine Interrupt-Steuerung für mehrere Prozessoren bietet, einschließlich statischer und dynamischer symmetrischer Verteilung von Interrupts für alle Prozessoren.  Auf Systemen mit mehreren E / A-Subsystemen kann jedes Subsystem seinen eigenen Satz von Interrupts haben. <br><br>  Jeder Interrupt-Pin wird einzeln als flanken- oder pegelgetriggert programmiert.  Der Interrupt-Vektor und die Interrupt-Steuerinformationen können für jeden Interrupt angegeben werden.  Das indirekte Registerzugriffsschema optimiert den Speicherplatz, der für den Zugriff auf die internen APIC-E / A-Register benötigt wird.  Um die Systemflexibilität bei der Zuweisung von Speicherplatz zu erhöhen, können die beiden APIC-E / A-Register verschoben werden. Der Standardwert ist jedoch 0xFEC00000. <br><br><h3>  Initialisierung eines "lokalen" APIC </h3><br>  Der lokale APIC wird beim Booten aktiviert und kann durch Zurücksetzen von Bit 11 IA32_APIC_BASE (MSR) deaktiviert werden (dies funktioniert nur bei Prozessoren mit einer Familie&gt; 5, da Pentium keinen solchen MSR hat). Dann empfängt der Prozessor seine Interrupts direkt vom kompatiblen 8259 PIC .  Im Intel-Handbuch zur Softwareentwicklung heißt es jedoch, dass Sie den lokalen APIC nach dem Deaktivieren über IA32_APIC_BASE erst einschalten können, wenn er vollständig zurückgesetzt wurde.  Das APO IO kann auch so konfiguriert werden, dass es im Legacy-Modus arbeitet, sodass es ein 8259-Gerät emuliert. <br><br>  Lokale APICs werden der physischen Seite FEE00xxx zugeordnet (siehe Tabelle 8-1 Intel P4 SPG).  Diese Adresse ist für jeden lokalen APIC, der in der Konfiguration vorhanden ist, gleich. Dies bedeutet, dass Sie direkt auf die Register des lokalen APIC-Kernels zugreifen können, in dem Ihr Code gerade ausgeführt wird.  Beachten Sie, dass es einen MSR gibt, der die tatsächliche APIC-Basis definiert (nur für Prozessoren mit einer Familie&gt; 5 verfügbar).  MADT enthält eine lokale APIC-Basis, und auf 64-Bit-Systemen kann es auch ein Feld enthalten, das eine 64-Bit-Neudefinition der Basisadresse angibt, die Sie stattdessen verwenden sollten.  Sie können die lokale APIC-Basis nur dort lassen, wo Sie sie finden, oder sie verschieben, wo immer Sie möchten.  Hinweis: Ich glaube nicht, dass Sie es weiter als bis zu 4 GB RAM verschieben können. <br><br>  Damit der lokale APIC Interrupts empfangen kann, müssen Sie das Spurious Interrupt Vector Register konfigurieren.  Der richtige Wert für dieses Feld ist die IRQ-Nummer, die Sie falschen Interrupts mit den unteren 8 Bits zuordnen möchten, und das 8. Bit, das auf 1 gesetzt ist, um APIC tatsächlich zu aktivieren (Einzelheiten finden Sie in der Spezifikation).  Sie müssen eine Interrupt-Nummer auswählen, für die die unteren 4 Bits gesetzt sind.  Am einfachsten ist es, 0xFF zu verwenden.  Dies ist für einige ältere Prozessoren wichtig, da für diese Werte die unteren 4 Bits auf 1 gesetzt werden müssen. <br><br>  Deaktivieren Sie den 8259 PIC korrekt.  Dies ist fast so wichtig wie die Konfiguration von APIC.  Sie tun dies in zwei Schritten: Maskieren aller Interrupts und Neuzuweisen des IRQ.  Durch das Verschleiern aller Interrupts werden diese im PIC deaktiviert.  Das erneute Zuordnen von Interrupts haben Sie wahrscheinlich bereits bei der Verwendung von PIC durchgeführt: Sie möchten, dass Interrupt-Anforderungen bei 32 statt bei 0 beginnen, um Konflikte mit Ausnahmen zu vermeiden (im geschützten und langen (langen) Prozessormodus, weil Die ersten 32 Interrupts sind Ausnahmen.  Dann sollten Sie vermeiden, diese Interruptvektoren für andere Zwecke zu verwenden.  Dies ist erforderlich, da trotz der Tatsache, dass Sie alle PIC-Interrupts maskiert haben, immer noch falsche Interrupts ausgelöst werden können, die dann fälschlicherweise als Ausnahmen in Ihrem Kernel verarbeitet werden. <br>  Fahren wir mit SMP fort. <br><br><h3>  Symmetrisches Multitasking: Initialisierung </h3><br>  Die Startreihenfolge ist für verschiedene CPUs unterschiedlich.  Das Intel Programmer's Guide (Abschnitt 7.5.4) enthält ein Initialisierungsprotokoll für Intel Xeon-Prozessoren und gilt nicht für ältere Prozessoren.  Einen allgemeinen Algorithmus für alle Prozessortypen finden Sie unter Intel Multiprocessor Specification. <br><br>  Für 80486 (mit externem APIC 8249DX) müssen Sie IPIT INIT verwenden, gefolgt von der IPI-Deaktivierung der INIT-Ebene ohne SIPI.  Dies bedeutet, dass Sie ihnen nicht sagen können, wo sie mit der Ausführung Ihres Codes (dem Vektorteil von SIPI) beginnen sollen, und sie beginnen immer mit der Ausführung von BIOS-Code.  In diesem Fall setzen Sie den CMOS-BIOS-Rücksetzwert auf „Warmstart mit Weitsprung“ (dh setzen Sie die CMOS-Position 0x0F auf 10), damit das BIOS jmp far ~ [0: 0x0469] ausführt, und setzen dann das Segment und den Offset AP-Einstiegspunkte bei 0x0469. <br><br>  Das IPI "INIT Level De-Assert" wird auf neuen Prozessoren (Pentium 4 und Intel Xeon) nicht unterstützt, und AFAIK wird auf diesen Prozessoren vollständig ignoriert. <br><br>  Für neuere Prozessoren (P6, Pentium 4) reicht ein SIPI aus, aber ich bin mir nicht sicher, ob ältere Intel-Prozessoren (Pentium) oder Prozessoren anderer Hersteller einen zweiten SIPI benötigen.  Es ist auch möglich, dass ein zweiter SIPI im Falle eines Zustellungsfehlers für den ersten SIPI (Busrauschen usw.) vorhanden ist. <br><br>  Normalerweise sende ich das erste SIPI und warte dann ab, ob der AP die Anzahl der laufenden Prozessoren erhöht.  Wenn dieser Zähler nicht innerhalb weniger Millisekunden erhöht wird, sende ich einen zweiten SIPI.  Dies unterscheidet sich vom allgemeinen Intel-Algorithmus (der eine Verzögerung von 200 Mikrosekunden zwischen SIPI aufweist), aber es ist nicht so einfach, eine Zeitquelle zu finden, die die Verzögerung von 200 Mikrosekunden während eines frühen Startvorgangs genau messen kann.  Ich habe auch festgestellt, dass auf realer Hardware, wenn die Verzögerung zwischen SIPI zu lang ist (und Sie meine Methode nicht verwenden), der Haupt-AP den frühen AP-Startcode für das Betriebssystem zweimal ausführen kann (was in meinem Fall dazu führt, dass das Betriebssystem dies denkt Wir haben doppelt so viele Prozessoren wie wir tatsächlich sind. <br><br>  Sie können diese Signale auf dem Bus senden, um jedes vorhandene Gerät zu starten.  Sie können jedoch auch Prozessoren aktivieren, die speziell deaktiviert wurden (weil sie "defekt" waren). <br><br><h3>  Suchen Sie nach Informationen mithilfe der MT-Tabelle </h3><br>  Einige Informationen (die auf neueren Computern möglicherweise nicht verfügbar sind) sind für die Mehrfachverarbeitung vorgesehen.  Zuerst müssen Sie die MP-Floating-Pointer-Struktur finden.  Es ist an einer 16-Byte-Grenze ausgerichtet und enthält eine Signatur am Anfang von "_MP_" oder 0x5F504D5F.  Das Betriebssystem sollte in EBDA, im BIOS-ROM-Bereich und im letzten Kilobyte „Basisspeicher“ angezeigt werden.  Die Größe des Basisspeichers wird in einem 2-Byte-Wert von 0x413 in Kilobyte minus 1 KB angegeben.  So sieht die Struktur aus: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  So sieht die Konfigurationstabelle aus, auf die die schwebende Struktur des Zeigers zeigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  Nach der Konfigurationstabelle befinden sich die Einträge entry_count, die weitere Informationen zum System enthalten, gefolgt von einer erweiterten Tabelle.  Einträge sind entweder 20 Bytes, um den Prozessor darzustellen, oder 8 Bytes für etwas anderes.  So sehen APIC-Prozessor- und E / A-Datensätze aus. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Hier ist der IO APIC-Eintrag. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  Suchen Sie nach Informationen mit APIC </h3><br>  Sie finden die MADT-Tabelle (APIC) in ACPI.  In der Tabelle sind die lokalen APICs aufgeführt, deren Anzahl der Anzahl der Kerne auf Ihrem Prozessor entsprechen sollte.  Die Details dieser Tabelle sind nicht hier, aber Sie können sie im Internet finden. <br><br><h3>  Starten Sie AP </h3><br>  Nachdem Sie die Informationen gesammelt haben, müssen Sie den PIC deaktivieren und sich auf den APIC I / O vorbereiten.  Sie müssen auch den BSP des lokalen APIC konfigurieren.  Starten Sie dann den AP mit SIPI. <br><br>  <b>Code zum Starten von Kerneln:</b> <br><br>  Ich stelle fest, dass der Vektor, den Sie beim Start angeben, die Startadresse angibt: Vektor 0x8 - Adresse 0x8000, Vektor 0x9 - Adresse 0x9000 usw. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">org</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>] AP: jmp short bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0</span></span>x7c00 xor ax,ax mov ds,ax ; Mark CPU as active lock inc byte [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x9090 ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Wie Sie verstehen, müssen Sie den Stapel für jeden Kern, jeden Kern, seine Interrupts usw. konfigurieren, damit das Betriebssystem viele Kerne verwenden kann. Das Wichtigste ist jedoch, dass bei Verwendung der symmetrischen Mehrfachverarbeitung alle Ressourcen der Kerne gleich sind: ein Speicher, Eine PCI usw. und das Betriebssystem können nur Aufgaben zwischen den Kernen parallelisieren. <br><br>  Ich hoffe, dass der Artikel nicht langweilig genug und recht informativ ist.  Ich denke, wir können das nächste Mal darüber sprechen, wie sie früher auf dem Bildschirm gezeichnet haben (und jetzt zeichnen sie), ohne Shader und coole Grafikkarten zu verwenden. <br><br>  Viel Glück </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426497/">https://habr.com/ru/post/de426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
<li><a href="../de426489/index.html">Über das Verhältnis von Primzahlen und irrationalen Zahlen</a></li>
<li><a href="../de426491/index.html">Sicherheitswoche 39: Zum Tod von Google+</a></li>
<li><a href="../de426493/index.html">Ständige Rabatte von Hostern für Besucher von VPS und VPS.today Search</a></li>
<li><a href="../de426495/index.html">Solo Designer. Wie man eine Karriere aufbaut, wenn man alleine arbeitet</a></li>
<li><a href="../de426499/index.html">Bildungsprogramm für die Arbeit mit Lochkarten (oder die Geschichte, wie „Big Data“ von 1890 bis 1970 verarbeitet wurde)</a></li>
<li><a href="../de426501/index.html">Lamoda von innen: Warum der Online-Shop von 300 Ingenieuren</a></li>
<li><a href="../de426503/index.html">SAP HANA-Funktionalität als Datenbank für die SAP HANA Data Management Suite</a></li>
<li><a href="../de426505/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. Oktober</a></li>
<li><a href="../de426507/index.html">Erstellen einer Architektur: Arbeiten mit dem iOS-Koordinatormuster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>