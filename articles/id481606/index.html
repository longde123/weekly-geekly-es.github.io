<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ‚ôüÔ∏è üåò Berlangganan statis menggunakan template Pengamat menggunakan C ++ dan mikrokontroler Cortex M4 üíáüèø üéõÔ∏è ü§¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kesehatan yang baik untuk semua! 


 Pada malam Tahun Baru, saya ingin terus berbicara tentang penggunaan C ++ pada mikrokontroler, kali ini saya akan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berlangganan statis menggunakan template Pengamat menggunakan C ++ dan mikrokontroler Cortex M4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481606/"><p><img src="https://habrastorage.org/webt/kq/jo/qx/kqjoqxpr1itcdx-_kq4luowkpqe.jpeg"></p><br><p>  Kesehatan yang baik untuk semua! </p><br><p>  Pada malam Tahun Baru, saya ingin terus berbicara tentang penggunaan C ++ pada mikrokontroler, kali ini saya akan mencoba untuk berbicara tentang menggunakan templat Observer (tapi selanjutnya saya akan menyebutnya Publisher-Subscriber atau hanya Subscriber, seperti kata-kata), serta penerapan langganan statis ke C ++ 17 dan keuntungan dari pendekatan ini di beberapa aplikasi. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Pelanggan Template adalah salah satu template paling umum yang digunakan dalam pengembangan perangkat lunak.  Dengan itu, misalnya, mereka melakukan pemrosesan klik tombol di Windows Form.  Dan memang, di tempat mana pun Anda perlu merespons perubahan dalam parameter sistem, apakah itu perubahan dalam file atau memperbarui nilai yang diukur dari sensor, inilah saatnya <del>  tanpa berpikir </del>  gunakan templat Pelanggan. </p><br><p>  Keuntungan dari templat ini adalah kami melepaskan pengetahuan tentang Penerbit dan Pelanggan tanpa terikat dengan objek tertentu.  Kami dapat menandatangani siapa saja kepada siapa pun, tanpa mempengaruhi implementasi objek Penerbit dan Pelanggan. </p><br><h2 id="nachalnye-usloviya">  Kondisi awal </h2><br><p>  Sebelum kita berkenalan dengan templat, mari kita sepakat dulu bahwa kami ingin mengembangkan perangkat lunak yang andal di mana: </p><br><ul><li>  jangan gunakan alokasi memori dinamis </li><li>  meminimalkan kerja dengan pointer </li><li>  kami menggunakan konstanta sebanyak mungkin sehingga tidak ada yang bisa mengubah siapa pun sebanyak mungkin </li><li>  tetapi pada saat yang sama kami menggunakan konstanta sesedikit mungkin yang terletak di RAM </li></ul><br><p>  Sekarang mari kita lihat implementasi standar dari template Pelanggan. </p><br><h2 id="standartnaya-realizaciya">  Implementasi standar </h2><br><p>  Misalkan kita memiliki tombol, dan ketika Anda mengklik tombol, kita perlu mengedipkan LED, tetapi berapa banyak dari mereka yang tidak diketahui sejauh ini, dan memang, Anda mungkin perlu berkedip bukan dengan LED, tetapi dengan sorotan pada kapal untuk mengirimkan pesan dalam kode Morse.  Penting bahwa kita tidak tahu siapa yang akan berlangganan.  Sayangnya, saya tidak memiliki sorotan, jadi semua contoh dalam artikel ini demi kesederhanaan dan pemahaman yang lebih baik dibuat dengan LED. </p><br><p>  Jadi, ketika Anda menekan tombol, Anda perlu memberi tahu LED tentang pers ini.  Pada gilirannya, setelah belajar tentang menekan LED harus beralih ke keadaan sebaliknya. <br>  Implementasi standar di UML adalah sebagai berikut ... </p><br><p><img src="https://habrastorage.org/webt/zu/8g/ro/zu8gro30gxgngc8w36oesxy9w2i.png"></p><br><p> Di sini kelas <code>ButtonController</code> bertanggung jawab atas pemungutan suara tombol dan memberi tahu pelanggan tentang klik, dan <code>Led</code> dalam hal ini adalah pelanggan.  Kedua kelas ini dipisahkan melalui <code>ISubsriber</code> dan <code>ISubsriber</code> dan tidak ada kelas yang tahu tentang yang lain.  Dengan demikian, objek apa pun yang diwarisi dari antarmuka <code>ISubscriber</code> dapat berlangganan acara dari <code>ButtonController</code> . </p><br><p>  Karena alokasi memori dinamis dilarang, saya mendeklarasikan array 3 elemen untuk berlangganan.  Yaitu  maksimal bisa 3 pelanggan.  Jadi, dalam perkiraan pertama, metode pemberitahuan pelanggan dari kelas <code>ButttonsController</code> mungkin terlihat </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          HandleEvent() for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } } ;</span></span></code> </pre> <br><p>  Semua garam dalam metode <code>Notify()</code> dari kelas <code>Publisher</code> .  Dalam metode ini, kita membahas daftar pelanggan dan memanggil metode <code>HandleEvent()</code> pada masing-masing pelanggan, dan ini keren, karena setiap pelanggan mengimplementasikan metode ini dengan caranya sendiri dan dapat melakukannya di sana. <del>  semua </del>  apa pun yang diinginkan hati Anda (pada kenyataannya, Anda harus berhati-hati, jika iblis tidak tahu apa yang dilakukan pelanggan di sana, Anda dapat memanggil metodenya, misalnya, dari gangguan dan Anda harus waspada untuk mencegah pelanggan melakukan hal-hal yang lama dan buruk) </p><br><p>  Dalam kasus kami, LED diizinkan untuk melakukan apa saja, sehingga ia melakukan peralihan statusnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Led</span></span></span><span class="hljs-class">:</span></span> ISubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Port::ODR::Toggle(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  Toggle() ; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Implementasi penuh semua kelas</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ISubscriber { virtual void HandleEvent() = 0; } ; struct IPublisher { virtual void Notify() const = 0; virtual void Subscribe(ISubscriber* subscriber) = 0; } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { static void Toggle() { Port::ODR::Toggle(1 &lt;&lt; pinNum); } void HandleEvent() override { Toggle() ; } }; struct ButtonController : IPublisher { void Run() { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } void Subscribe(ISubscriber* subscriber) override { if (index &lt; pSubscribers.size()) { pSubscribers[index] = subscriber ; index ++ ; } //   3   ...   } private: std::array&lt;ISubscriber*, 3&gt; pSubscribers ; std::size_t index = 0U ; } ;</span></span></code> </pre></div></div><br><p>  Bagaimana cara berlangganan melihat kode?  Jadi: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; ButtonController buttonController ; //  3  buttonController.Subscribe(&amp;Led1) ; buttonController.Subscribe(&amp;Led2) ; buttonController.Subscribe(&amp;Led3) ; //       buttonController.Run() ; }</span></span></code> </pre> <br><p>  Berita baiknya adalah kita dapat menandatangani objek apa pun dan waktu pembuatannya tidak masalah bagi kita.  Ini bisa berupa objek global, statis atau lokal.  Di satu sisi, ini bagus, tetapi di sisi lain, mengapa kita perlu berlangganan runtime dalam kode ini.  Memang, pada kenyataannya, di sini alamat objek <code>Led1</code> , <code>Led2</code> , <code>Led3</code> dikenal pada tahap kompilasi.  Jadi mengapa Anda tidak bisa berlangganan pada tahap kompilasi dan menyimpan array pointer ke pelanggan di ROM? </p><br><p>  Selain itu, ada risiko kesalahan potensial, misalnya, berapa banyak yang bertanya-tanya apa yang akan terjadi ketika memanggil metode <code>Subsribe()</code> jika dipanggil dari beberapa utas?  Kami dibatasi hanya untuk 3 pelanggan, dan apa yang terjadi jika kami menandatangani 4 LED? </p><br><p>  Dalam kebanyakan kasus, kami membutuhkan langganan ini sekali seumur hidup selama inisialisasi, kami hanya menyimpan pointer ke pelanggan dan hanya itu.  Pointer akan menjaga alamat pelanggan ini seumur hidup.  Dan hari itu tak terhindarkan ketika bisa dihancurkan <del>  karena wabah supernova </del>  (tentu saja, jika kita mempertimbangkan periode waktu yang cukup lama).  Tetapi bagaimanapun juga, kemungkinan kegagalan RAM jauh lebih tinggi daripada ROM dan tidak disarankan untuk menyimpan data permanen dalam RAM. </p><br><p>  Nah, berita buruknya adalah solusi arsitektur seperti itu membutuhkan banyak ruang di ROM dan RAM.  Untuk jaga-jaga, kami menulis berapa banyak ROM dan RAM yang dibutuhkan solusi ini: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  kode ro </th><th>  data ro </th><th>  data baru </th></tr></thead><tbody><tr><td>  main.o </td><td>  488 </td><td>  64 </td><td>  21 </td></tr></tbody></table></div><br><p>  Yaitu  total 552 byte dalam ROM dan 21 byte dalam RAM - katakanlah tidak begitu banyak untuk menekan tombol dan berkedip tiga LED. </p><br><p>  Nah, untuk melindungi diri dari masalah seperti itu dan mengurangi konsumsi sumber daya controller, mari kita pertimbangkan opsi dengan berlangganan statis. </p><br><h2 id="staticheskaya-podpiska">  Berlangganan Statis </h2><br><p>  Untuk membuat langganan menjadi statis, Anda dapat menggunakan beberapa pendekatan.  Saya akan menamai mereka seperti ini: </p><br><ul><li>  Yang tradisional adalah pendekatan yang sama, tetapi menggunakan konstruktor constexpr dan mengatur daftar pelanggan yang melaluinya. </li><li><del>  Tidak konvensional </del>  Menggunakan templat - mentransfer daftar pelanggan melalui parameter templat.  (di sini, templat adalah definisi dari bidang metaprogramming, bukan pola desain) </li></ul><br><h3 id="tradicionnyy-podhod-k-staticheskoy-podpiske">  Pendekatan tradisional untuk berlangganan statis </h3><br><p>  Mari kita coba berlangganan pada tahap kompilasi.  Untuk melakukan ini, kami sedikit mengubah arsitektur kami: </p><br><p><img src="https://habrastorage.org/webt/lr/_k/gy/lr_kgyobfgkebxpz9gfyqiod34u.png"></p><br><p>  Gambar tidak jauh berbeda dari aslinya, tetapi ada beberapa perbedaan: metode <code>Subscribe()</code> telah dihapus dan sekarang berlangganan akan dilakukan langsung di konstruktor.  Konstruktor harus menerima sejumlah variabel argumen, dan agar dapat masuk secara statis pada tahap kompilasi, ia akan menjadi <code>constexpr</code> .  Array pelanggan akan diinisialisasi di dalamnya dan inisialisasi ini dapat dilakukan pada waktu kompilasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*... args)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;ISubscriber <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt; result = {args...} ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; size) { pSubscribers[index] = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;ISubscriber*&gt;(it); } index ++ ; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-number"><span class="hljs-number">3U</span></span>; ISubscriber* pSubscribers[size] ; } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Kode lengkap untuk implementasi seperti itu</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPublisher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { constexpr Led() { } static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const override { Toggle() ; } }; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ButtonController : IPublisher { template&lt;typename... Args&gt; constexpr ButtonController(Args const*... args): pSubscribers() { std::initializer_list&lt;ISubscriber const*&gt; result = {args...} ; std::size_t index = 0U; for(auto it: result) { if (index &lt; size) { pSubscribers[index] = const_cast&lt;ISubscriber*&gt;(it); } index ++ ; } } void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } private: static constexpr std::size_t size = 3U; ISubscriber* pSubscribers[size] ; } ;</span></span></code> </pre></div></div><br><p>  Sekarang berlangganan dapat dilakukan pada waktu kompilasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController buttonController(&amp;Led1, &amp;Led2, &amp;Led3) ; buttonController.Run() ; return 0 ; } ;</span></span></code> </pre> <br><p>  Di sini, objek <code>buttonController</code> benar <code>buttonController</code> benar terletak di ROM bersama dengan array pointer ke pelanggan: </p><br><blockquote>  main :: buttonController 0x800'1f04 0x10 Data main.o [1] </blockquote><p>  Semuanya sepertinya tidak ada apa-apanya, kecuali bahwa kami hanya terbatas pada 3 pelanggan.  Dan kelas penerbit harus memiliki konstruktor constexpr dan secara umum benar-benar konstan untuk menjamin pointer ke pelanggan di ROM, jika tidak, bahkan dengan alamat pelanggan yang dikenal, objek kita, bersama dengan semua konten, akan kembali ke RAM. </p><br><p>  Dari kelemahan lain - karena fungsi virtual masih digunakan, tabel fungsi virtual sedikit demi sedikit ROM kami.  Dan sumber dayanya, meskipun terjangkau, tetapi tidak terbatas.  Dalam sebagian besar aplikasi, dimungkinkan untuk memalu dan mengambil mikrokontroler yang lebih besar, tetapi sering terjadi bahwa setiap byte penting, terutama ketika menyangkut produk yang diproduksi oleh ratusan ribu, seperti sensor fisik fisik. </p><br><p>  Mari kita lihat bagaimana keadaan dengan memori dalam solusi ini: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  kode ro </th><th>  data ro </th><th>  data baru </th></tr></thead><tbody><tr><td>  main.o </td><td>  172 </td><td>  76 </td><td>  0 </td></tr></tbody></table></div><br><p>  Dan meskipun hasilnya "menakjubkan": total konsumsi RAM adalah 0 byte, dan ROM adalah 248 byte, yang setengah dari jumlah pada solusi pertama, rasanya masih ada ruang untuk perbaikan.  Dari 248 byte ini, sekitar 50 hanya menempati tabel metode virtual. </p><br><p>  <u>Penyimpangan kecil:</u> <br>  Langkah dalam ukuran ROM 256 kB untuk mikrokontroler modern adalah norma (misalnya, mikrokontroler TI Cortex M4 memiliki ROM 256 kB, dan versi berikutnya sudah 512 kB).  Dan itu tidak akan menjadi sangat baik ketika, karena 50 byte tambahan, kita harus mengambil controller dengan ROM 256 kByte lebih besar dan lebih mahal, oleh karena itu, meninggalkan fungsi virtual dapat menghemat ... sebanyak 50 sen (perbedaan antara mikrokontroler di 256 dan 512 kBytes ROM adalah tentang 50-60 sen). </p><br><p>  Ini kedengarannya konyol untuk 1 mikrokontroler, tetapi dalam jumlah 400.000 perangkat per tahun, Anda dapat menghemat $ 200.000.  Sudah tidak terlalu lucu, tetapi mempertimbangkan jenis tikus apa.  mereka dapat menghargai tawaran dengan ijazah dan kartu hadiah untuk 3.000 rubel, sama sekali tidak ada keraguan tentang kebenaran menolak fungsi virtual dan menghemat 50 byte tambahan dalam ROM. </p><br><h3 id="netradicionnyy-podhod">  Pendekatan yang tidak konvensional </h3><br><p>  Mari kita lihat bagaimana Anda dapat melakukan hal yang sama tanpa fungsi virtual dan menyimpan lebih banyak ROM. </p><br><p>  Pertama, mari kita cari tahu bagaimana jadinya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; //   ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Tugas kami adalah memisahkan dua objek Publisher ( <code>ButtonController</code> ) dan Subscriber ( <code>Led</code> ) dari satu sama lain sehingga mereka tidak saling mengenal, tetapi pada saat yang sama <code>ButtonController</code> dapat memberi tahu <code>Led</code> . </p><br><p>  Anda dapat mendeklarasikan kelas <code>ButtonController</code> beberapa cara. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;&amp; subscriber1, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&amp; subscriber2, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;&amp; subscriber3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ subscriber1.HandleEvent() ; subscriber2.HandleEvent() ; subscriber3.HandleEvent() ; } ... } ;</code> </pre> <br><p>  Tapi Anda mengerti, di sini kita terikat pada tipe tertentu dan kita harus mengulang definisi kelas <code>BbuttonController</code> setiap kali dalam proyek baru.  Dan saya ingin mengambil dan menggunakan <code>ButtonController</code> di proyek baru tanpa <code>ButtonController</code> . </p><br><p>  C ++ 17 datang ke penyelamatan, di mana Anda tidak dapat menentukan jenisnya, tetapi minta kompiler untuk menyimpulkan jenisnya untuk Anda - inilah yang Anda butuhkan.  Kita bisa, seperti dalam pendekatan tradisional, melepaskan pengetahuan dari Penerbit dan Pelanggan, sementara jumlah pelanggan praktis tidak terbatas. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; } ... } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Cara kerja pass (..) berfungsi</b> <div class="spoiler_text"><p>  Metode <code>Notify()</code> memiliki fungsi panggilan ke <code>pass()</code> ; ia digunakan untuk memperluas parameter template dengan sejumlah variabel argumen </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; }</code> </pre> <br><p>  Implementasi fungsi <code>pass()</code> tidak dapat dibayangkan, hanya fungsi yang mengambil sejumlah variabel argumen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Bagaimana fungsi <code>HandleEvent()</code> berkembang menjadi beberapa panggilan untuk masing-masing pelanggan? </p><br><p>  Karena fungsi <code>pass()</code> mengambil beberapa argumen dari tipe apa pun, Anda bisa meneruskan beberapa argumen dari tipe <code>bool</code> , misalnya, Anda bisa memanggil fungsi <code>pass(true, true, true)</code> .  Dalam hal ini, tentu saja, tidak ada yang akan terjadi, tetapi kita tidak perlu. </p><br><p>  Baris <code>(subscribers.HandleEvent() , true)</code> menggunakan operator "," (koma), yang mengeksekusi kedua operan (dari kiri ke kanan) dan mengembalikan nilai operator kedua, yaitu, di sini <code>subscribers.HandleEvent()</code> akan dieksekusi terlebih dahulu, kemudian <code>true</code> dengan fungsinya <code>pass()</code> akan disetel ke <code>true</code> . </p><br><p>  Ya, "..." adalah entri standar untuk memperluas sejumlah variabel argumen.  Untuk kasus kami, tindakan dari kompiler dapat dijelaskan secara sangat skematis sebagai berikut: </p><br><pre> <code class="cpp hljs">pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; -&gt; pass((Led1.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led1.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led2.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led3.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ;</code> </pre> </div></div><br><p>  Alih-alih tautan, Anda dapat menggunakan pointer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> ... } ;</code> </pre> <br><p>  <strong>Tambahan:</strong> Sebenarnya, terima kasih kepada <a href="https://habr.com/ru/users/vamireh/" class="user_link">vamireh</a> yang <a href="https://habr.com/ru/post/481606/">menunjukkan</a> bahwa semua tarian ini bersama <del>  rebana </del>  fungsi <code>pass</code> dalam C ++ 17 tidak diperlukan.  Karena operator "," koma didukung dalam ekspresi lipatan (yang diperkenalkan dalam standar C ++ 17), kode disederhanakan lebih lanjut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ((subscribers.HandleEvent()), ...) ; } } ;</code> </pre> <br><p>  Secara arsitektur, ini terlihat sangat sederhana secara umum: </p><br><p><img src="https://habrastorage.org/webt/hx/di/jj/hxdijj1xdfvncxtdsr04a1qp_ve.png"></p><br><p>  Saya menambahkan kelas LCD lain di sini, tetapi murni sebagai contoh, untuk menunjukkan bahwa sekarang tidak masalah jenis dan jumlah pelanggan, yang utama adalah bahwa ia akan menerapkan metode <code>HandleEvent()</code> . </p><br><p>  Dan semua kode secara umum juga lebih mudah sekarang: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led { static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const { Toggle() ; } }; template &lt;auto&amp; ... subscribers&gt; struct ButtonController { void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const { ((subscribers.HandleEvent()), ...) ; } } ; int main() { //  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Panggilan <code>Notify()</code> pada metode <code>Run()</code> berubah menjadi panggilan sekuensial sederhana </p><br><pre> <code class="cpp hljs">Led1.HandleEvent() ; Led2.HandleEvent() ; Led3.HandleEvent() ;</code> </pre> <br><p>  Bagaimana dengan memori di sini? </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  kode ro </th><th>  data ro </th><th>  data baru </th></tr></thead><tbody><tr><td>  main.o </td><td>  186 </td><td>  4 </td><td>  0 </td></tr></tbody></table></div><br><p>  Total ROM 190 byte dan 0 byte RAM.  Sekarang pesanannya, hampir 3 kali lebih kecil dari versi standar, sementara itu melakukan hal yang persis sama. </p><br><p>  Dengan demikian, jika Anda memiliki alamat pelanggan yang diketahui sebelumnya dalam aplikasi dan Anda mengikuti ketentuan yang ditentukan pada awal artikel </p><br><div class="spoiler">  <b class="spoiler_title">Ketentuan di awal artikel</b> <div class="spoiler_text"><ul><li>  jangan gunakan alokasi memori dinamis </li><li>  meminimalkan kerja dengan pointer </li><li>  kami menggunakan konstanta sebanyak mungkin sehingga tidak ada yang bisa mengubah siapa pun sebanyak mungkin </li><li>  tetapi pada saat yang sama kami menggunakan konstanta sesedikit mungkin yang terletak di RAM </li></ul></div></div><br><p>  Dengan percaya diri, Anda dapat menggunakan implementasi dari template Penerbit-Pelanggan untuk mengurangi garis kode dan menghemat sumber daya, dan di sana Anda melihat dan Anda dapat mengklaim tidak hanya kartu hadiah, tetapi juga bonus berdasarkan hasil tahun ini. </p><br><p>  Contoh pengujian di <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">bawah IAR 8.40.2 ada di sini</a> </p><br><p>  Semua dengan kedatangan!  Dan semoga sukses di tahun baru! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481606/">https://habr.com/ru/post/id481606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481594/index.html">Pengembangan ‚Äúgenerator tegangan sederhana‚Äù sesuai dengan GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../id481596/index.html">Parsing ELK 7.5 pengaturan untuk analisis log Mikrotik</a></li>
<li><a href="../id481598/index.html">Kontribusi kecil untuk perang melawan platform kebun binatang UI Avalonia</a></li>
<li><a href="../id481600/index.html">Mesin Wiki Keluarga Bonsai: Hasil 2019</a></li>
<li><a href="../id481604/index.html">Bagaimana pengembang Chelyabinsk keras membuat game untuk Google Play dan jejaring sosial</a></li>
<li><a href="../id481610/index.html">PostgreSQL Antipatterns: memperbarui tabel besar yang sedang dimuat</a></li>
<li><a href="../id481612/index.html">Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer</a></li>
<li><a href="../id481616/index.html">Kubah geodesik. Tentang perangkat dan pengalaman perhitungan saya</a></li>
<li><a href="../id481618/index.html">MVP di Unity atau cara menyederhanakan hidup</a></li>
<li><a href="../id481620/index.html">Juniper SRX dan Cisco ASA: Next Series</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>