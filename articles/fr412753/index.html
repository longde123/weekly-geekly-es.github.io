<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèΩ ü§úüèΩ üë®üèæ‚Äçü§ù‚Äçüë®üèº Lancer l'affichage sur STM32 via LTDC ... sur les registres ‚ö†Ô∏è üôãüèº üàÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations! R√©cemment, un projet avait besoin de lancer un √©cran dot√© d'une interface LVDS. Pour impl√©menter la t√¢che, le contr√¥leur STM32F746 a √©t√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lancer l'affichage sur STM32 via LTDC ... sur les registres</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412753/"> Salutations!  R√©cemment, un projet avait besoin de lancer un √©cran dot√© d'une interface LVDS.  Pour impl√©menter la t√¢che, le contr√¥leur STM32F746 a √©t√© s√©lectionn√©, car  J'ai d√©j√† beaucoup travaill√© avec lui et il a le module LTDC, qui vous permet de travailler directement avec l'√©cran sans contr√¥leur.  Dans ce cas, le contr√¥leur est d√©j√† impl√©ment√© √† l'int√©rieur du microcontr√¥leur.  De plus, le dernier argument √©tait qu'il y avait un d√©bogage STM32F746-Disco sur cette pierre, que j'avais en main, ce qui signifie que je pouvais commencer √† travailler sur le projet sans attendre que la carte, les composants, etc. viennent √† moi. <br><br>  Aujourd'hui, je vais vous expliquer comment ex√©cuter le module LTDC, en travaillant avec des registres (CMSIS).  HAL et d'autres biblioth√®ques n'aiment pas et n'utilisent pas pour des raisons religieuses, mais cela est √©galement int√©ressant.  Vous verrez qu'√©lever des p√©riph√©riques complexes sur des registres est aussi simple qu'un SPI standard.  Int√©ressant?  Alors allons-y! <br><br><img src="https://habrastorage.org/webt/1q/dg/rd/1qdgrdp09rbyqcdhtzsvz8aqkbc.jpeg"><br><a name="habracut"></a><br><h2>  1. Un peu sur le LTDC </h2><br>  Ce module p√©riph√©rique est essentiellement un contr√¥leur, qui se trouve g√©n√©ralement sur le c√¥t√© de l'√©cran, par exemple SSD1963 et similaires.  Si nous regardons la structure du LTDC, nous verrons qu'il s'agit physiquement d'un bus parall√®le √† 24 bits + un acc√©l√©rateur graphique mat√©riel + un tableau de donn√©es en RAM, qui est en fait un tampon d'affichage (tampon de trame). <br><br><img src="https://habrastorage.org/webt/wm/g-/7k/wmg-7k_nhwtycbwgiefmyyagmxo.png"><br><br>  En sortie, nous avons un bus parall√®le ordinaire, qui contient 24 bits de couleur (8 bits par couleur du mod√®le RGB), des lignes de synchronisation, une ligne on / off d'affichage et une horloge pixel.  Ce dernier, en fait, est un signal d'horloge par lequel les pixels sont charg√©s dans l'affichage, c'est-√†-dire que si nous avons une fr√©quence de 9,5 MHz, alors en 1 seconde, nous pouvons charger 9,5 millions de pixels.  Ceci en th√©orie, bien s√ªr, dans la pratique, les chiffres sont un peu plus modestes en raison des d√©lais et d'autres choses. <br><br>  <u>Pour une introduction plus d√©taill√©e au LTDC, je vous conseille de lire quelques documents:</u> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un aper√ßu des capacit√©s du LTDC en F4, dans notre F7 tout est le m√™me</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Note d'application 4861. "Contr√¥leur d'affichage LCD-TFT (LTDC) sur les microcontr√¥leurs STM32"</a> </li></ol><br><h2>  2. Que devons-nous faire? </h2><br>  Les microcontr√¥leurs ST ont gagn√© en popularit√© pour une bonne raison, l'exigence la plus importante pour tous les composants √©lectroniques est la documentation, et tout va bien.  Le site est certes horrible, mais je vais laisser des liens vers toute la documentation.  Le fabricant nous √©vite les tourments et l'invention du v√©lo, donc √† la page 520 du <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel de r√©f√©rence RM0385,</a></i> des √©tapes en noir et blanc sont donn√©es, ce que nous devons faire: <br><br><img src="https://habrastorage.org/webt/bz/nx/ul/bznxulxfphrlrfmc_47lhv9wvgy.png"><br><br>  En fait, vous n'avez pas √† faire la moiti√© des t√¢ches d√©crites: il n'est pas n√©cessaire de d√©marrer ou est d√©j√† configur√© par d√©faut.  Pour le d√©marrage minimum, qui nous permet de dessiner des pixels, d'afficher des images, des graphiques, du texte, etc., il suffit de faire ce qui suit: <br><br><ul><li>  Activer l'horloge LTDC </li><li>  R√©glez le syst√®me d'horloge et la fr√©quence de sortie des donn√©es (horloge pixel) </li><li>  Configurer les ports d'E / S (GPIO) pour fonctionner avec LTDC </li><li>  Configurer les horaires pour notre mod√®le d'affichage </li><li>  <s>Ajustez la polarit√© des signaux.</s>  <s>D√©j√† fait par d√©faut</s> </li><li>  <s>Sp√©cifiez la couleur d'arri√®re-plan de l'affichage.</s>  <s>Nous ne le verrons pas encore, vous pouvez le laisser "√† z√©ro"</s> </li><li>  D√©finir la taille r√©elle de la zone visible de l'affichage pour un calque sp√©cifique </li><li>  S√©lectionnez le format de couleur: ARGB8888, RGB 888, RGB565, etc. </li><li>  Sp√©cifiez l'adresse du tableau qui servira de tampon de trame </li><li>  Indiquez la quantit√© de donn√©es sur une ligne (longueur en largeur) </li><li>  Indiquez le nombre de lignes (hauteur d'affichage) </li><li>  Inclure la couche avec laquelle nous travaillons </li><li>  Activer le module LTDC </li></ul><br>  Effrayant  Et j'avais peur, mais cela s'est av√©r√© fonctionner pendant 20 minutes avec toutes les proc√©dures.  Il y a une t√¢che, le plan est planifi√© et il ne reste plus qu'√† l'accomplir. <br><br><h2>  3. Configuration du syst√®me d'horloge </h2><br>  Le premier √©l√©ment dont nous avons besoin pour envoyer un signal d'horloge au module LTDC, cela se fait en √©crivant dans le registre RCC: <br><br><pre><code class="cpp hljs">RCC-&gt;APB2ENR |= RCC_APB2ENR_LTDCEN;</code> </pre> <br>  Ensuite, vous devez configurer la fr√©quence d'horloge du quartz externe (HSE) √† une fr√©quence de 216 MHz, c'est-√†-dire au maximum.  La premi√®re √©tape consiste √† allumer la source d'horloge √† partir du r√©sonateur √† quartz et √† attendre le drapeau pr√™t: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));</code> </pre><br>  R√©glez maintenant le d√©lai pour la m√©moire flash du contr√¥leur, comme  elle ne sait pas comment travailler √† la fr√©quence centrale.  Sa valeur, comme le reste des donn√©es, est extraite du manuel de r√©f√©rence: <br><br><pre> <code class="cpp hljs">FLASH-&gt;ACR |= FLASH_ACR_LATENCY_5WS;</code> </pre><br>  Maintenant, pour obtenir la fr√©quence souhait√©e, je vais diviser 25 MHz de l'entr√©e √† 25 et obtenir 1 MHz.  Ensuite, juste en PLL, je multiplie par 432, car  √† l'avenir, il y a un diviseur de fr√©quence avec une valeur minimale de / 2 et vous devez lui appliquer deux fois la fr√©quence.  Apr√®s cela, nous connectons l'entr√©e PLL √† notre r√©sonateur √† quartz (HSE): <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_4; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLN_8; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLSRC;</code> </pre><br>  Activez maintenant PLL et attendez le drapeau pr√™t: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>){}</code> </pre><br>  Nous attribuons la sortie de notre PLL comme source de la fr√©quence du syst√®me et attendons le drapeau pr√™t: <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {}</code> </pre><br>  Ceci termine le r√©glage g√©n√©ral de l'horloge et nous passons au r√©glage de la fr√©quence d'horloge (PLLSAI) pour notre affichage (horloge pixel).  Le signal pour PLLSAI selon la fiche technique est pris apr√®s le diviseur / 25, c'est-√†-dire, √† l'entr√©e, nous avons 1 MHz.  Nous devons obtenir une fr√©quence d'environ 9,5 MHz, pour cela, nous multiplions la fr√©quence de 1 MHz par 192, puis en utilisant deux diviseurs par 5 et 4, nous obtenons la valeur souhait√©e PLLSAI = 1 MHz * 192/5/4 = 9,6 MHz: <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7; RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIR_0 | RCC_PLLSAICFGR_PLLSAIR_2; RCC-&gt;DCKCFGR1 |= RCC_DCKCFGR1_PLLSAIDIVR_0; RCC-&gt;DCKCFGR1 &amp;= ~RCC_DCKCFGR1_PLLSAIDIVR_1;</code> </pre><br>  Comme derni√®re √©tape, nous activons PLLSAI pour l'affichage et attendons l'indicateur pr√™t √† travailler: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLSAION; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((RCC-&gt;CR &amp; RCC_CR_PLLSAIRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br>  Ceci termine la configuration de base du syst√®me d'horloge, afin de ne pas oublier et ensuite de ne pas souffrir, activons la synchronisation sur tous les ports d'entr√©e / sortie (GPIO).  Nous n'avons pas de batterie, au moins pour le d√©bogage, donc nous n'√©conomisons pas: <br><br><pre> <code class="cpp hljs">RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOBEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOCEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIODEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOEEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOFEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOGEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOHEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOJEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOKEN;</code> </pre><br><h2>  4. Configuration des ports d'E / S (GPIO) </h2><br>  La configuration de gpio est tr√®s simple - nous avons toutes les jambes du bus LTDC √† configurer comme sortie alternative et √† haute fr√©quence.  Pour ce faire, dans le manuel de r√©f√©rence √† la page 201, nous avons cette astuce: <br><br><img src="https://habrastorage.org/webt/m5/bw/e9/m5bwe9v-fev5yahji9hqc9iofno.png"><br><br>  Le tableau indique les bits des registres que vous devez d√©finir pour obtenir le param√®tre n√©cessaire.  Il convient de noter que toutes les accolades sont d√©sactiv√©es.  O√π chercher quelle fonction alternative inclure?  Et pour cela, allez √† la page 76 de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fiche technique</a> de notre contr√¥leur et consultez le tableau suivant: <br><br><img src="https://habrastorage.org/webt/d1/6a/6-/d16a6-uye3sjdb7rrf_m-qnz2os.png"><br><br>  Comme vous pouvez le voir, la logique du tableau est la plus simple: nous trouvons la fonction dont nous avons besoin, dans notre cas LTDC B0, puis nous regardons sur quel GPIO il se trouve (PE4, par exemple) et en haut nous voyons le num√©ro de la fonction alternative que nous utiliserons pour configurer (AF14 avec nous).  Pour configurer notre sortie en tant que sortie push-pull avec une fonction alternative, LTDC B0, nous devons √©crire le code suivant: <br><br><pre> <code class="cpp hljs">GPIOE-&gt;MODER &amp;= ~GPIO_MODER_MODER4; GPIOE-&gt;MODER |= GPIO_MODER_MODER4_1; GPIOE-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR4_1; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= ~GPIO_AFRL_AFRL4_0; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_2 | GPIO_AFRL_AFRL4_3;</code> </pre><br>  J'ai donn√© un exemple pour la broche PE4, qui correspond √† la broche B0 sur le bus LTDC, c'est-√†-dire qu'il s'agit d'un bit z√©ro de couleur bleue.  Pour toutes les autres conclusions, le r√©glage est identique, seules 2 conclusions m√©ritent une attention particuli√®re, l'une des pr√™tes comprend un √©cran, et l'autre son r√©tro-√©clairage.  Ils sont configur√©s comme une sortie push-pull normale, que tout le monde utilise pour faire clignoter une LED.  La configuration ressemble √† ceci: <br><br><pre> <code class="cpp hljs">GPIOK-&gt;MODER &amp;= ~GPIO_MODER_MODER3; GPIOK-&gt;MODER |= GPIO_MODER_MODER3_0;</code> </pre><br>  Ce param√®tre concerne la sortie PK3, qui active et d√©sactive notre r√©tro-√©clairage.  Soit dit en passant, vous pouvez √©galement le pousser pour r√©gler la luminosit√© en douceur.  Pour PI12, qui comprend un √©cran (DISP), tout est pareil.  La vitesse sur ces 2 broches est faible par d√©faut, car  certaines actions √† haute fr√©quence ne leur sont pas requises. <br><br>  Vous pouvez consulter tous les autres ports d'E / S sur la carte de circuit imprim√© de la carte de d√©bogage ou sur le sch√©ma de circuit de votre propre appareil. <br><br><h2>  5. Horaires et leurs param√®tres </h2><br>  Les d√©lais d'un point de vue physique sont des retards ordinaires.  Je pense que vous avez observ√© √† plusieurs reprises diverses perversions du type delay (1) lorsque vous avez examin√© des exemples de code sur des √©crans avec des contr√¥leurs SPI / I2C similaires √† ILI9341.  L√†, un d√©lai est n√©cessaire pour que le contr√¥leur, par exemple, ait le temps d'accepter la commande, de l'ex√©cuter, puis de faire quelque chose avec les donn√©es.  Dans le cas du LTDC, tout est √† peu pr√®s le m√™me, seulement nous ne ferons pas de b√©quilles et pourquoi pas - notre microcontr√¥leur lui-m√™me est capable de configurer les temporisations n√©cessaires dans le mat√©riel.  Pourquoi sont-ils n√©cessaires sur un √©cran sans contr√¥leur?  Oui, il est √©l√©mentaire qu'apr√®s avoir rempli la premi√®re ligne de pixels, passez √† la ligne suivante et revenez √† son d√©but.  Cela est d√ª √† la technologie de production des √©crans, et donc chaque mod√®le d'affichage sp√©cifique a ses propres horaires. <br><br>  Pour conna√Ætre les valeurs dont nous avons besoin, rendez-vous sur le site Web de ST et consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©ma de la carte de d√©bogage STM32F746-Disco</a> .  L√†, nous pouvons voir que l'affichage est <i>RK043FN48H-CT672B</i> et la documentation pour cela est disponible, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Nous sommes particuli√®rement int√©ress√©s par le tableau de la page 13 de la section 7.3.1: <br><br><img src="https://habrastorage.org/webt/t7/fk/ou/t7fkoukmcua7rsnn6bmema1dhio.png"><br><br>  Ce sont nos valeurs dont nous aurons besoin lors de la mise en place.  De plus, dans la documentation, il y a beaucoup plus qui est int√©ressant, par exemple, des diagrammes de signaux sur le bus et ainsi de suite, dont vous pourriez avoir besoin si, par exemple, vous voulez augmenter l'affichage en FPGA ou CPLD. <br><br>  Acc√©dez aux param√®tres.  Tout d'abord, afin de ne pas garder ces valeurs dans ma t√™te, je les disposerai sous forme de d√©finit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HSYNC ((uint16_t)30) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HBP ((uint16_t)13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HFP ((uint16_t)32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VSYNC ((uint16_t)10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VBP ((uint16_t)2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VFP ((uint16_t)2)</span></span></code> </pre><br>  Il y a une fonctionnalit√© int√©ressante.  <i>La largeur d'impulsion de</i> synchronisation, appel√©e <i>DISPLAY_HSYNC</i> , a une valeur dans le tableau uniquement pour la fr√©quence d'horloge de pixel de 5 MHz, mais pas pour 9 et 12 MHz.  Ce timing doit √™tre s√©lectionn√© pour votre affichage, j'ai obtenu cette valeur de 30, alors que dans les exemples de ST, c'√©tait diff√©rent.  Au premier d√©marrage, si vous avez une erreur avec son r√©glage, l'image sera d√©cal√©e soit vers la gauche, soit vers la droite.  Si c'est √† droite, on diminue le timing; si √† gauche, on l'augmente.  En fait, cela affecte l'origine de la zone visible, que nous verrons plus loin.  Gardez √† l'esprit, et l'image suivante de la page 24 de notre AN4861 vous aidera √† comprendre tout ce paragraphe: <br><br><img src="https://habrastorage.org/webt/nu/cd/gc/nucdgcesjmx8gqq-bjwfnusk0vc.png"><br><br>  Une petite abstraction est pratique ici.  Nous avons 2 zones d'affichage: visible et g√©n√©rale.  La zone visible a des dimensions avec une r√©solution d√©clar√©e de 480 par 272 pixels, et la zone totale est le visible + nos timings, dont il y a 3 de chaque c√¥t√©.  Il est √©galement utile de comprendre (ce n'est plus une abstraction) qu'un tick du syst√®me fait 1 pixel, donc la surface totale est de 480 pixels + HSYNC + HBP + HFP. <br><br>  Il est √©galement utile de r√©aliser que moins il y a de synchronisations, mieux c'est - l'affichage sera mis √† jour plus rapidement et la fr√©quence d'images augmentera l√©g√®rement.  Par cons√©quent, apr√®s la premi√®re ex√©cution, exp√©rimentez les synchronisations et r√©duisez-les autant que possible tout en conservant la stabilit√©. <br><br>  Pour d√©finir les horaires, je me suis fait une petite "feuille de triche" pour l'avenir dans le projet, cela vous aidera √©galement √† comprendre quelle figure sp√©cifique et o√π l'√©crire: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *************************** Timings for TFT display********************************** * * HSW = (DISPLAY_HSYNC - 1) * VSH = (DISPLAY_VSYNC - 1) * AHBP = (DISPLAY_HSYNC + DISPLAY_HBP - 1) * AVBP = (DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - 1) * TOTALW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - 1) * TOTALH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP - 1) * */</span></span></code> </pre><br>  D'o√π vient cette "feuille de triche" ... D'abord, vous avez vu une "formule" similaire quelques paragraphes auparavant.  Deuxi√®mement, allez √† la page 56 de notre AN4861: <br><br><img src="https://habrastorage.org/webt/sz/zf/yc/szzfyccwyqfw_t9ki0dazyck3ys.png"><br><br>  Certes, j'esp√®re que vous avez compris la signification physique des horaires avant l'apparition de cette feuille de triche et je suis s√ªr que vous auriez pu vous-m√™me la compiler.  Il n'y a rien de compliqu√©, et les images de RM et AN aident √† comprendre visuellement l'effet des temporisations sur le processus de formation d'image. <br><br>  Il est maintenant temps d'√©crire un code qui configure ces timings.  Dans la "feuille de triche" sont indiqu√©s les bits du registre dans lesquels √©crire, par exemple, TOTALH, et apr√®s le signe est √©gal √† la formule donnant √† la sortie un certain nombre.  D'accord?  Ensuite, nous √©crivons: <br><br><pre> <code class="cpp hljs">LTDC-&gt;SSCR |= ((DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;BPCR |= ((DISPLAY_HSYNC+DISPLAY_HBP<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC+DISPLAY_VBP<span class="hljs-number"><span class="hljs-number">-1</span></span>)); LTDC-&gt;AWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;TWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP <span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> |(DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  Et c'est tout avec les horaires!  Dans cette section, vous ne pouvez configurer que la couleur d'arri√®re-plan.  Je l'ai en noir par d√©faut, il est donc √©crit en z√©ro.  Si vous souhaitez modifier la couleur du calque d'arri√®re-plan (arri√®re-plan), vous pouvez √©galement √©crire n'importe quelle valeur, par exemple, <i>0xFFFFFFFF</i> et tout remplir en blanc: <br><br><pre> <code class="cpp hljs">LTDC-&gt;BCCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Il y a une merveilleuse illustration dans le <i>manuel de r√©f√©rence</i> , qui d√©montre clairement que nous avons en fait 3 couches: fond, couche 1 et couche 2. La couche de fond est "castr√©e" et ne peut √™tre remplie qu'avec une couleur sp√©cifique, mais elle peut √©galement √™tre incroyablement utile dans la mise en ≈ìuvre future conception graphique.  En outre, cette illustration montre clairement la priorit√© des calques, ce qui signifie que nous ne verrons la couleur de remplissage sur l'arri√®re-plan que lorsque les calques restants sont vides ou transparents. <br><br>  √Ä titre d'exemple, je montrerai l'une des pages du projet o√π, lors de la mise en ≈ìuvre du mod√®le, l'arri√®re-plan a √©t√© rempli avec une couleur et le contr√¥leur n'a pas redessin√© la page enti√®re, mais uniquement des secteurs individuels, ce qui a permis de recevoir environ 50-60 ips pour de nombreuses autres t√¢ches: <br><br><img src="https://habrastorage.org/webt/7b/yn/il/7byniliyqlnqy0yyzpfk8um7_mg.jpeg"><br><br><h2>  6. La derni√®re partie de la configuration LTDC </h2><br>  Les param√®tres LTDC sont divis√©s en 2 sections: les premi√®res sont communes √† l'ensemble du module LTDC et sont situ√©es dans le <i>groupe de</i> registres <i>LTDC</i> , et les secondes sont configur√©es dans l'une des deux couches et se trouvent dans les <i>groupes LTDC_Layer1</i> et <i>LTDC_Layer2</i> . <br><br>  Nous avons fait les r√©glages g√©n√©raux dans le paragraphe pr√©c√©dent, ceux-ci incluent le r√©glage des timings, le calque d'arri√®re-plan.  Nous passons maintenant √† la d√©finition des couches et selon notre liste, nous avons besoin de la taille r√©elle de la zone visible de la couche, qui est d√©crite sous la forme de 4 coordonn√©es (x0, y0, x1, y2), qui nous permettent d'obtenir les dimensions du rectangle.  La taille du calque visible peut √™tre inf√©rieure √† la r√©solution de l'affichage, personne ne d√©range pour rendre la taille du calque 100 pour 100 pixels.  Pour ajuster la taille de la zone visible, √©crivez le code suivant: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;WHPCR |= (((DISPLAY_WIDTH + DISPLAY_HBP + DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (DISPLAY_HBP + DISPLAY_HSYNC)); LTDC_Layer2-&gt;WVPCR |= (((DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) |(DISPLAY_VSYNC + DISPLAY_VBP));</code> </pre><br>  Comme vous pouvez le voir, tout est comme avec les horaires.  Les points de d√©part (x0, y0) de la zone visible consistent en la somme de deux temporisations: HSYNC + HBP et VSYNC + VBP.  Pour calculer les coordonn√©es du point final (x1, y1), la largeur et la hauteur en pixels sont simplement ajout√©es aux donn√©es de valeur. <br><br>  Vous devez maintenant configurer le format des donn√©es re√ßues.  La qualit√© maximale est obtenue lors de l'utilisation du format ARGB8888, mais en m√™me temps, nous obtenons la quantit√© maximale de m√©moire occup√©e.  Un pixel occupe 32 bits ou 4 octets, ce qui signifie que tout l'√©cran prend 4 * 480 * 272 = 522 240 octets, c'est-√†-dire la moiti√© de la m√©moire flash de notre contr√¥leur pas le plus faible.  N'ayez pas peur - la connexion de SDRAM externe et de m√©moire flash via QSPI r√©sout les probl√®mes de m√©moire et il n'y a aucune restriction sur ce format, nous nous r√©jouissons de bonne qualit√©.  Si vous souhaitez √©conomiser de l'espace ou si votre √©cran ne prend pas en charge le format 24 bits, des mod√®les plus adapt√©s sont utilis√©s pour cela, par exemple, RGB565.  Un format tr√®s populaire pour les √©crans et les cam√©ras, et surtout lors de son utilisation, 1 pixel ne prend que 5 + 6 + 5 = 16 bits ou 2 octets.  En cons√©quence, la quantit√© de m√©moire occup√©e par la couche sera 2 fois inf√©rieure.  Par d√©faut, le contr√¥leur a d√©j√† le format ARGB8888 configur√© et ressemble √† ceci: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;PFCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Si vous avez besoin d'un format diff√©rent de l'ARGB8888, passez aux pages 533 et 534 du <i>manuel de r√©f√©rence</i> et s√©lectionnez le format souhait√© dans la liste ci-dessous: <br><br><img src="https://habrastorage.org/webt/be/fg/qa/befgqaa2-iokyso1coeqhaii9zu.png"><br><br>  Maintenant, cr√©ez un tableau et passez son adresse au LTDC, il se transformera en un tampon de trame et sera un ¬´reflet¬ª de notre couche.  Par exemple, vous devez remplir le 1er pixel de la 1√®re ligne de couleur blanche, pour cela, il vous suffit d'√©crire la valeur de couleur (0xFFFFFFFF) dans le premier √©l√©ment de ce tableau.  Besoin de remplir le 1er pixel de la 2√®me rang√©e?  Ensuite, nous √©crivons √©galement la valeur de couleur dans l'√©l√©ment avec le nombre (480 + 1).  480 - faites une saut de ligne, puis ajoutez le nombre dans la ligne dont nous avons besoin. <br><br>  Ce param√®tre ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_WIDTH ((uint16_t)480) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HEIGHT ((uint16_t)272) const uint32_t imageLayer2[DISPLAY_WIDTH * DISPLAY_HEIGHT]; LTDC_Layer2-&gt;CFBAR = (uint32_t)imageLayer2;</span></span></code> </pre><br>  Dans le bon sens, apr√®s avoir configur√© LTDC, vous devez √©galement configurer la SDRAM afin de supprimer le modificateur <i>const</i> et d'obtenir le tampon de trame dans la RAM, car  La propre RAM de MK ne suffit pas, m√™me pour une couche de 4 octets.  Bien que cela ne fasse pas de mal pour tester la bonne configuration des p√©riph√©riques. <br><br>  Ensuite, vous devez sp√©cifier la valeur de la couche alpha, c'est-√†-dire la transparence de notre couche <i>Layer2</i> , pour cela nous √©crivons une valeur de 0 √† 255, o√π 0 est une couche compl√®tement transparente, 255 est compl√®tement opaque, c'est-√†-dire 100% visible: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CACR = <span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre> <br>  Selon notre plan, il est maintenant n√©cessaire d'enregistrer la taille de notre zone d'affichage visible en octets, pour cela nous √©crivons les valeurs correspondantes dans les registres: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CFBLR |= (((PIXEL_SIZE * DISPLAY_WIDTH) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (PIXEL_SIZE * DISPLAY_WIDTH + <span class="hljs-number"><span class="hljs-number">3</span></span>)); LTDC_Layer2-&gt;CFBLNR |= DISPLAY_HEIGHT;</code> </pre><br>  Les deux derni√®res √©tapes restent, √† savoir l'inclusion de la couche 2 et le module p√©riph√©rique LTDC lui-m√™me.  Pour ce faire, √©crivez les bits correspondants: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CR |= LTDC_LxCR_LEN; LTDC-&gt;GCR |= LTDC_GCR_LTDCEN;</code> </pre><br>  Ceci termine la configuration de notre module et vous pouvez travailler avec notre √©cran! <br><br><h2>  7. Un peu de travail avec LTDC </h2><br>  Tout travail avec l'√©cran se r√©sume d√©sormais √† l'√©criture de donn√©es dans le tableau <i>imageLayer2</i> , il a une taille de 480 par 272 √©l√©ments, ce qui correspond pleinement √† notre r√©solution et sugg√®re une v√©rit√© simple - <b>1 √©l√©ment de tableau = 1 pixel sur l'√©cran</b> . <br><br>  Par exemple, j'ai √©crit une image dans un tableau que j'ai converti dans <b>LCD Image Converter</b> , mais en r√©alit√©, il est peu probable que vos t√¢ches se limitent √† cela.  Il y a deux fa√ßons: utiliser une interface graphique pr√™te √† l'emploi et l'√©crire vous-m√™me.  Pour des t√¢ches relativement simples telles que la sortie de texte, la repr√©sentation graphique, etc., je vous conseille d'√©crire votre propre interface graphique, cela prendra un peu de temps et vous donnera une compr√©hension compl√®te de son fonctionnement.  Lorsque la t√¢che est grande et difficile, et que vous n'avez pas le temps de d√©velopper votre propre interface graphique, je vous conseille de faire attention aux solutions pr√™tes √† l'emploi, par exemple, uGFX et similaires. <br><br>  Les symboles de texte, de lignes et d'autres √©l√©ments sont intrins√®quement des tableaux de pixels, donc pour les impl√©menter, vous devez impl√©menter la logique vous-m√™me, mais vous devez commencer par la fonction la plus √©l√©mentaire - ¬´sortie pixel¬ª.  Il doit prendre 3 arguments: la coordonn√©e le long de X, la coordonn√©e le long de Y et, en cons√©quence, la couleur dans laquelle le pixel donn√© est peint.  Cela peut ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColorDisplay { RED = <span class="hljs-number"><span class="hljs-number">0xFFFF0000</span></span>, GREEN = <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>, BLUE = <span class="hljs-number"><span class="hljs-number">0xFF0000FF</span></span>, BLACK = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>, WHITE = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> } Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPixel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setY, Color Color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numBuffer = ((setY - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DISPLAY_WIDTH) + setX; imageLayer2[numBuffer] = Color; }</code> </pre><br>  Apr√®s avoir pris les coordonn√©es dans une fonction, nous les recalculons dans le num√©ro du tableau qui correspond √† la coordonn√©e donn√©e, puis √©crivons la couleur re√ßue sur l'√©l√©ment re√ßu.  Sur la base de cette fonction, vous pouvez d√©j√† impl√©menter des fonctions pour afficher la g√©om√©trie, le texte et d'autres ¬´goodies¬ª de l'interface graphique.  Je pense que l'id√©e est compr√©hensible, mais comment la concr√©tiser est √† votre discr√©tion. <br><br><h2>  R√©sum√© </h2><br>  Comme vous pouvez le voir, la mise en ≈ìuvre de p√©riph√©riques m√™me complexes sur les registres (CMSIS) n'est pas une t√¢che difficile, il vous suffit de comprendre comment cela fonctionne √† l'int√©rieur.  Bien s√ªr, il est maintenant √† la mode de d√©velopper un firmware sans comprendre ce qui se passe, mais c'est une impasse si vous envisagez de devenir ing√©nieur, et non ... <br><br>  Si vous comparez le code r√©sultant avec une solution en HAL ou SPL, vous remarquerez que le code √©crit dans les registres est plus compact.  En ajoutant quelques commentaires l√† o√π vous en avez besoin et en les enveloppant dans des fonctions, nous obtenons une lisibilit√© au moins pas pire que celle de HAL / SPL, et si vous vous souvenez que le <i>manuel de r√©f√©rence</i> documente les registres, alors travailler avec CMSIS est plus pratique. <br><br>  1) Le projet avec les sources dans TrueSTUDIO peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> <br><br>  2) Pour ceux qui sont plus √† l'aise de regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> <br><br>  3) T√©l√©chargez l'utilitaire pour convertir les images en code LCD Image Converter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412753/">https://habr.com/ru/post/fr412753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412741/index.html">Comment arr√™ter d'avoir peur que l'intelligence artificielle vous laisse sans travail</a></li>
<li><a href="../fr412743/index.html">Profession: Cyber ‚Äã‚Äãd√©tective</a></li>
<li><a href="../fr412747/index.html">MIS. Stockage de donn√©es m√©dicales</a></li>
<li><a href="../fr412749/index.html">L'√©lectronique en tant qu'art: le courant √©lectrique</a></li>
<li><a href="../fr412751/index.html">Calvitie: Th√©orie et pratique du traitement, partie 1 "Ma dihydrotestost√©rone, mon ennemi"</a></li>
<li><a href="../fr412755/index.html">Telegram a publi√© le serveur proxy MTProto officiel</a></li>
<li><a href="../fr412757/index.html">Ampoules LED au Japon</a></li>
<li><a href="../fr412759/index.html">Nouveau serveur proxy MTProto de Telegram</a></li>
<li><a href="../fr412763/index.html">Utilisation de la carte de rechargement Firefly-RK3288 avec le SoC RockChip RK3288 Capteur thermique num√©rique Microchip I2C - MCP9808</a></li>
<li><a href="../fr412765/index.html">Introduction au nouveau syst√®me de cartes de tuiles Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>