<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèæ üå©Ô∏è üö¥üèø Ein bisschen √ºber Multitasking in Mikrocontrollern üö• üê£ ü•ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein bisschen √ºber Multitasking 


 Jeder, der Tag f√ºr Tag oder von Fall zu Fall mit der Programmierung von Mikrocontrollern besch√§ftigt ist, wird fr√ºh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen √ºber Multitasking in Mikrocontrollern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454874/"><p>  <strong>Ein bisschen √ºber Multitasking</strong> </p><br><p>  Jeder, der Tag f√ºr Tag oder von Fall zu Fall mit der Programmierung von Mikrocontrollern besch√§ftigt ist, wird fr√ºher oder sp√§ter vor die Frage gestellt: Soll ich ein Multitask-Betriebssystem verwenden?  Es gibt ziemlich viele von ihnen im Netzwerk, und viele von ihnen sind kostenlos (oder fast kostenlos).  Einfach w√§hlen. </p><br><p>  √Ñhnliche Zweifel treten auf, wenn Sie auf ein Projekt sto√üen, bei dem der Mikrocontroller gleichzeitig mehrere verschiedene Aktionen ausf√ºhren muss.  Einige von ihnen sind nicht mit anderen verbunden, w√§hrend der Rest im Gegenteil nicht ohne einander auskommen kann.  Au√üerdem kann es zu viele von beiden geben.  Was ‚Äûzu viel‚Äú ist, h√§ngt davon ab, wer die Entwicklung bewertet oder wer sie durchf√ºhrt.  Nun, wenn es die gleiche Person ist. </p><br><p>  Es handelt sich vielmehr nicht um eine Quantit√§tsfrage, sondern um einen qualitativen Unterschied der Aufgaben in Bezug auf die Ausf√ºhrungsgeschwindigkeit oder einige andere Anforderungen.  Solche Gedanken k√∂nnen zum Beispiel entstehen, wenn das Projekt die Versorgungsspannung regelm√§√üig √ºberwachen muss (fehlt sie?), Sehr oft die Werte der Eingangsgr√∂√üen lesen und speichern (sie geben keine Ruhe), gelegentlich die Temperatur √ºberwachen und den L√ºfter steuern (es gibt nichts zu atmen), √ºberpr√ºfen Sie Ihre Beobachten Sie mit jemandem, dem Sie vertrauen (es ist gut, wenn Sie es befehlen), bleiben Sie mit dem Bediener in Kontakt (versuchen Sie, ihn nicht zu irritieren), √ºberpr√ºfen Sie die Pr√ºfsumme des permanenten Speichers des Programms auf Demenz (wenn eingeschaltet, einmal pro Woche oder morgens). <a name="habracut"></a></p><br><p>  Solche heterogenen Aufgaben k√∂nnen sehr sinnvoll und erfolgreich programmiert werden, wobei eine einzige Hintergrundaufgabe und Timer-Interrupts erforderlich sind.  Im Handler dieser Interrupts wird jedes Mal eines der ‚ÄûTeile‚Äú der n√§chsten Aufgabe ausgef√ºhrt.  Abh√§ngig von der Wichtigkeit, Dringlichkeit oder √§hnlichen √úberlegungen werden diese Herausforderungen h√§ufig f√ºr einige Aufgaben wiederholt, f√ºr andere jedoch selten.  Und doch m√ºssen wir sicherstellen, dass jede Aufgabe einen kurzen Teil der Arbeit erledigt, sich dann auf den n√§chsten kleinen Teil der Arbeit vorbereitet und so weiter.  Wenn Sie sich daran gew√∂hnen, erscheint dieser Ansatz nicht allzu kompliziert.  Unannehmlichkeiten treten auf, wenn Sie ein Projekt erstellen m√∂chten.  Oder zum Beispiel pl√∂tzlich auf einen anderen √ºbertragen.  Es sollte beachtet werden, dass die zweite oft schwieriger und ohne Pseudo-Viele-Aufgabe ist. </p><br><p>  Was aber, wenn Sie ein vorgefertigtes Betriebssystem f√ºr Mikrocontroller verwenden?  Sicher, viele machen es.  Dies ist eine gute Option.  Aber der Autor dieser Zeilen war und ist bis jetzt von der Idee gestoppt worden, dass es notwendig sein wird, dies zu verstehen, nachdem er viel Zeit verbracht hat, aus dem zu w√§hlen, was wir bekommen haben, und nur das zu verwenden, was wirklich ben√∂tigt wird.  Und tun Sie das alles, wohlgemerkt, und tauchen Sie in den Code eines anderen ein!  Und es gibt keine Gewissheit, dass dies in sechs Monaten nicht wiederholt werden muss, denn es wird vergessen. </p><br><p>  Mit anderen Worten, warum ben√∂tigen Sie eine vollst√§ndige Garage mit Werkzeugen und Vorrichtungen, wenn dort ein Fahrrad gelagert und verwendet wird? </p><br><p>  Daher bestand der Wunsch, einfache ‚ÄûWechsel‚Äú -Aufgaben nur f√ºr Cortex-M4 durchzuf√ºhren (naja, vielleicht sogar f√ºr M3 und M7).  Aber der alte, gute Wunsch, nicht viel zu belasten, verschwand nicht. </p><br><p>  Also machen wir das einfachste.  Eine kleine Anzahl von Aufgaben teilt sich die Ausf√ºhrungszeit zu gleichen Teilen.  Wie in Abbildung 1 unten tun dies vier Aufgaben.  Lassen Sie das Haupt Null sein, da es schwierig ist, sich ein anderes vorzustellen. </p><br><p><img src="https://habrastorage.org/webt/hz/er/47/hzer47qstbq61q9nj41xkqnquoo.jpeg"></p><br><p>  Auf diese Weise erhalten sie garantiert ihren Slot oder ihre Zeitspanne (Tick) und m√ºssen nicht √ºber das Vorhandensein anderer Aufgaben informiert sein.  Jede Aufgabe genau nach 3 Ticks erh√§lt wieder die M√∂glichkeit, etwas zu tun. </p><br><p>  Wenn jedoch eine der Aufgaben erforderlich ist, um auf ein externes Ereignis zu warten, z. B. durch Dr√ºcken einer Taste, wird die kostbare Zeit unseres Mikrocontrollers dumm verbracht.  Dem k√∂nnen wir nicht zustimmen.  Und unsere Kr√∂te (Gewissen) auch.  Es muss etwas getan werden. </p><br><p>  Und lassen Sie die Aufgabe, wenn sie bisher nichts zu tun hat, die von der Zecke verbleibende Zeit ihren Kameraden geben, die h√∂chstwahrscheinlich mit aller Kraft pfl√ºgen. </p><br><p>  Mit anderen Worten, das Teilen ist notwendig.  Lassen Sie Aufgabe 2 genau das tun, wie in Abbildung 2 dargestellt. </p><br><p><img src="https://habrastorage.org/webt/5j/dm/sv/5jdmsvttcr9cfs5ygk_giclmc5w.jpeg"></p><br><p>  Und warum sollte unsere Hintergrundaufgabe nicht den Rest der Zeit aufgeben d√ºrfen, wenn Sie noch warten m√ºssen?  Lassen wir es zu.  Wie in Abbildung 3 gezeigt. </p><br><p><img src="https://habrastorage.org/webt/jg/mh/q4/jgmhq4bmtd26vzif444qypg3c18.jpeg"></p><br><p>  Und wenn Sie wissen, dass einige der Aufgaben nicht bald erfordern, dass Sie etwas erneut √ºberpr√ºfen oder einfach nur arbeiten?  Und sie konnte sich ein wenig Schlaf g√∂nnen und verschwendete stattdessen Zeit und ging unter ihre F√º√üe.  Keine Bestellung, sie muss repariert werden.  Lassen Sie Aufgabe 3 ein St√ºck ihrer Zeit (oder tausend) verpassen.  Wie in Abbildung 4 gezeigt. </p><br><p><img src="https://habrastorage.org/webt/50/no/ma/50nomamrfalo_crb2hmf1nkalli.jpeg"></p><br><p>  Nun, wie wir sehen, haben wir eine faire Koexistenz von Aufgaben oder √Ñhnlichem skizziert.  Wir m√ºssen jetzt daf√ºr sorgen, dass sich unsere individuellen Aufgaben wie vorgeschrieben verhalten.  Und wenn wir versuchen, die Zeit zu sch√§tzen, lohnt es sich, sich an eine Sprache auf niedriger Ebene zu erinnern (ich habe keine Angst vor dem Wortassembler) und dem Compiler aus keiner Sprache auf hoher oder sehr hoher Ebene vollst√§ndig zu vertrauen.  In der Tat sind wir tief in unserem Herzen entschieden gegen jede Abh√§ngigkeit.  Dar√ºber hinaus vereinfacht die Tatsache, dass wir keinen Assembler ben√∂tigen, sondern nur von Cortex-M4, unser Leben. </p><br><p>  F√ºr den Stapel w√§hlen wir einen gemeinsamen RAM-Bereich aus, der sich f√ºllt, dh in Richtung abnehmender Speicheradressen.  Warum?  Nur weil es nicht anders funktioniert.  Wir werden diesen wichtigen Bereich mental in gleiche Abschnitte unterteilen, entsprechend der Anzahl der angegebenen maximalen Anzahl unserer Aufgaben.  Abbildung 5 zeigt dies f√ºr vier Aufgaben. </p><br><p><img src="https://habrastorage.org/webt/tp/tz/wo/tptzwopr7htrcuhwgb6y6ydfdae.jpeg"></p><br><p>  Als n√§chstes w√§hlen wir den Ort aus, an dem Kopien der Stapelzeiger f√ºr jede Aufgabe gespeichert werden.  Durch Unterbrechen des Timers, den wir als System-Timer verwenden, speichern wir alle Register der aktuellen Task in ihrem Stapelbereich (das SP-Register zeigt jetzt dorthin). Dann speichern wir seinen Stapelzeiger an einer speziellen Stelle (wir speichern seinen Wert) und erhalten den Stapelzeiger der n√§chsten Aufgabe ( Schreiben Sie von unserem speziellen Ort aus einen neuen Wert in das Register SP) und stellen Sie alle Register wieder her.  Ihre Kopien werden jetzt im SP-Register unserer n√§chsten Aufgabe angezeigt.  Nun, wir verlassen nat√ºrlich die Unterbrechung.  Dar√ºber hinaus wird der gesamte Kontext der n√§chsten Aufgabe in der Liste in den Registern angezeigt. </p><br><p>  Wahrscheinlich ist es √ºberfl√ºssig zu sagen, dass die n√§chste nach task3 in der Warteschlange main ist.  Und nat√ºrlich ist es nicht √ºberfl√ºssig, sich daran zu erinnern, dass der Cortex-M4 bereits √ºber einen SysTick-Timer und einen speziellen Interrupt verf√ºgt, und viele Hersteller von Mikrocontrollern wissen davon.  Wir werden es und diese Unterbrechung wie vorgesehen verwenden. </p><br><p>  Um diesen System-Timer zu starten und alle erforderlichen Vorbereitungen und √úberpr√ºfungen vorzunehmen, m√ºssen Sie das daf√ºr vorgesehene Verfahren anwenden. </p><br><pre><code class="plaintext hljs">U8 main_start_task_switcher(void);</code> </pre> <br><p>  Diese Routine gibt 0 zur√ºck, wenn alle Pr√ºfungen bestanden wurden, oder einen Fehlercode, wenn ein Fehler aufgetreten ist.  Grunds√§tzlich wird gepr√ºft, ob der Stapel korrekt ausgerichtet ist und ob gen√ºgend Platz daf√ºr vorhanden ist, und auch alle unsere speziellen Stellen sind mit Anfangswerten gef√ºllt.  Kurz gesagt, Langeweile. </p><br><p>  Wenn sich jemand den Text des Programms ansehen m√∂chte, kann er dies am Ende der Erz√§hlung problemlos tun, beispielsweise per E-Mail. </p><br><p>  Ja, ich habe v√∂llig vergessen, wenn wir die Register der n√§chsten Aufgabe zum ersten Mal in ihrem Leben aus dem Speicher nehmen. Es ist notwendig, dass sie aussagekr√§ftige Originalwerte erhalten.  Und da sie sie von ihrem Abschnitt des Stapels aufnimmt, m√ºssen Sie sie im Voraus dort ablegen und ihren Stapelzeiger bewegen, damit es bequem ist, sie zu nehmen.  Daf√ºr brauchen wir ein Verfahren </p><br><pre> <code class="plaintext hljs"> U8 task_run_and_return_task_number(U32 taskAddress);</code> </pre> <br><p>  An diese Unterroutine geben wir die 32-Bit-Adresse des Beginns unserer Aufgabe an, die wir ausf√ºhren m√∂chten.  Und sie (die Unterroutine) gibt uns die Nummer der Aufgabe an, die sich in einer speziellen allgemeinen Tabelle herausstellte, oder 0, wenn in der Tabelle kein Platz vorhanden war.  Dann k√∂nnen wir eine andere Aufgabe ausf√ºhren, dann eine andere und so weiter, obwohl alle drei zus√§tzlich zu unserer nie endenden Hauptaufgabe sind.  Sie wird niemandem ihre Nullnummer geben. </p><br><p>  Ein paar Worte zu den Priorit√§ten.  Die Hauptpriorit√§t war und ist es, den Leser nicht mit unn√∂tigen Details zu √ºberladen. </p><br><p>  Aber im Ernst, wir m√ºssen uns daran erinnern, dass es schlie√ülich Unterbrechungen von seriellen Schnittstellen, von mehreren SPI-Verbindungen, von einem Analog-Digital-Wandler, von einem anderen Timer gibt.  Und was passiert, wenn wir zu einer anderen Aufgabe (Kontext wechseln) wechseln, wenn wir uns im Handler einer Art Interrupt befinden?  Dies ist schlie√ülich keine legitime Aufgabe, sondern eine vor√ºbergehende Tr√ºbung des Programms.  Und wir werden diesen seltsamen Kontext als eine Art Aufgabe behalten.  Es wird eine Verwirrung geben: Der Kragen l√§sst sich nicht befestigen, die Kappe passt nicht.  H√∂r auf, nein, das ist aus einer anderen Geschichte. </p><br><p>  In unserem Fall ist dies einfach nicht zul√§ssig.  Wir d√ºrfen nicht zulassen, dass wir w√§hrend der Verarbeitung eines ungeplanten Interrupts den Kontext wechseln.  Hier sind die Priorit√§ten daf√ºr.  Wir m√ºssen nur ein bisschen warten und erst dann, wenn diese beispiellose K√ºhnheit endet, ruhig zu einer anderen Aufgabe wechseln.  Kurz gesagt, die Priorit√§t des Interrupts unseres Taskwechsels sollte schw√§cher sein als die Priorit√§t aller anderen verwendeten Interrupts.  Dies geschieht √ºbrigens auch in unserem Startvorgang, und dort wird es installiert, die h√∂chstm√∂gliche Priorit√§t. </p><br><p>  Ich wollte nicht reden, aber ich musste.  Unser Prozessor verf√ºgt √ºber zwei Betriebsmodi: privilegiert und nicht privilegiert.  Und auch zwei Register f√ºr den Stapelzeiger: <br>  Haupt-SP und SP-Prozess.  Wir werden also nicht gegen Kleinigkeiten tauschen, sondern nur den privilegierten Modus und nur den Hauptstapelzeiger verwenden.  Dar√ºber hinaus wurde dies alles bereits zu Beginn der Steuerung angegeben.  Wir werden unser Leben also nicht komplizieren. </p><br><p>  Es bleibt zu erinnern, dass jede Aufgabe sicher in der Lage sein m√∂chte, alles in die H√∂lle zu werfen und sich zu entspannen.  Und dies kann jederzeit w√§hrend des Arbeitstages geschehen, dh w√§hrend unserer Zecke.  Cortex-M4 bietet f√ºr solche F√§lle einen speziellen Assembler-Befehl SVC, den wir an unsere Situation anpassen werden.  Es f√ºhrt zu einer Unterbrechung, die uns zum Ziel f√ºhrt.  Und wir werden zulassen, dass die Aufgabe nicht nur nach dem Mittagessen den Arbeitsplatz verl√§sst, sondern auch morgen nicht kommt.  Warum, lass es nach den Ferien kommen.  Und wenn n√∂tig, lassen Sie es kommen, wenn die Reparatur abgeschlossen ist oder √ºberhaupt nicht kommt.  Zu diesem Zweck gibt es eine Prozedur, die die Aufgabe selbst verursachen kann. </p><br><pre> <code class="plaintext hljs"> void release_me_and_set_sleep_period(U32 ticks);</code> </pre> <br><p>  Diese Routine muss nur angeben, wie viele Zecken zum Ausruhen geplant sind.  Wenn 0, k√∂nnen Sie nur den Rest des aktuellen Ticks ausruhen.  Wenn 0xFFFFFFFF, wird die Aufgabe "schlafen", bis jemand aufwacht.  Alle anderen Zahlen geben die Anzahl der Ticks an, w√§hrend der sich die Aufgabe im Ruhezustand befindet. </p><br><p>  Damit jemand anderes von der Seite aufwachen oder ihn schlafen lassen konnte, musste ich solche Verfahren hinzuf√ºgen. </p><br><pre> <code class="plaintext hljs"> void task_wake_up_action(U8 taskNumber); void set_task_sleep_period(U8 taskNumber, U32 ticks);</code> </pre> <br><p>  Und f√ºr alle F√§lle sogar eine solche Unterroutine. </p><br><pre> <code class="plaintext hljs"> void task_remove_action(U8 taskNumber);</code> </pre> <br><p>  Grob gesagt streicht sie eine Aufgabe aus der Liste der Mitarbeiter.  Ehrlich gesagt wei√ü ich noch nicht, warum ich es geschrieben habe.  Pl√∂tzlich n√ºtzlich? </p><br><p>  Es ist Zeit zu zeigen, wie der Ort aussieht, an dem eine Aufgabe durch eine andere ersetzt wird, dh der Schalter selbst. </p><br><p>  F√ºr alle F√§lle erinnern wir uns, dass einige der Register beim Eingeben des Interrupts ohne unsere Teilnahme automatisch auf dem Stapel gespeichert werden (wie es in Cortex-M4 √ºblich ist).  Deshalb m√ºssen wir nur den Rest retten.  Dies ist unten zu sehen.  Lassen Sie sich nicht von dem, was Sie sehen, beunruhigen. Dies sind Cortex-M4-Assembler-Anweisungen (M3, M7), wie in der IAR Embedded Workbench beschrieben. </p><br><p>  Diejenigen, die noch keine Montageanleitung erhalten haben, glauben Sie mir einfach, sie sehen wirklich so aus.  Dies sind die Molek√ºle, aus denen jedes Programm unter dem ARM Cortex-M4 besteht. </p><br><pre> <code class="plaintext hljs">SysTick_Handler STMDB SP!,{R4-R11} ;   LDR R0,=timersTable ;    LDR R1,=stacksTable ;    LDR R2,[R0] ;R2   ()  STR SP,[R1,R2,LSL #2] ;   SP (R2 * 4) __st_next_check ADD R2,R2,#1 ;   CMP R2,#TASKS_LIMIT ;R2-TASKS_LIMIT  BLO __st_no_border_yet ;   MOV R2,#0 ;    (main) LDR R3,[R1] ; main SP MOV SP,R3 B __st_timer_ok __st_no_border_yet ;; LDR SP,[R1,R2,LSL #2] ;    (errata Cortex M4) ;; CMP SP,#0 ; LDR R3,[R1,R2,LSL #2] ;  SP      CMP R3,#0 ; =0     BEQ __st_next_check MOV SP,R3 LDR R3,[R0,R2,LSL #2] ;  suspend timer CBZ R3,__st_timer_ok ; 0    ,   ; CMP R3,#0xFFFFFFFF ; ,   BEQ __st_next_check SUB R3,R3,#1 ;  1 STR R3,[R0,R2,LSL #2] ;  suspend timer B __st_next_check __st_timer_ok STR R2,[R0] ;     LDMIA SP!,{R4-R11} ;  R4-R11 BX LR</code> </pre> <br><p>  Die Behandlung des von der Aufgabe selbst geordneten Interrupts, wenn der Rest des Ticks zur√ºckgegeben wird, sieht √§hnlich aus.  Der einzige Unterschied besteht darin, dass Sie sich sp√§ter noch darum k√ºmmern m√ºssen, ein wenig zu schlafen (oder gr√ºndlich einzuschlafen).  Es gibt eine Subtilit√§t.  Es m√ºssen zwei Aktionen ausgef√ºhrt werden: Schreiben Sie die gew√ºnschte Nummer in den Sleep-Timer und lassen Sie den SVC unterbrechen.  Die Tatsache, dass diese beiden Aktionen nicht atomar ablaufen (dh nicht beide gleichzeitig), beunruhigt mich ein wenig.  Stellen Sie sich f√ºr eine Millisekunde vor, wir h√§tten gerade den Timer gespannt und zu diesem Zeitpunkt war es Zeit, an einer anderen Aufgabe zu arbeiten.  Die andere begann, ihre Zecke auszugeben, w√§hrend unsere Aufgabe darin besteht, die n√§chsten Zecken wie erwartet zu schlafen (weil ihr Timer nicht Null ist).  Wenn es dann soweit ist, erh√§lt unsere Aufgabe ihr H√§kchen und gibt es sofort an, um die SVC zu unterbrechen, da diese beiden Aktionen noch ausgef√ºhrt werden m√ºssen.  Meiner Meinung nach wird nichts Schreckliches passieren, aber das Sediment wird bleiben.  Deshalb werden wir das tun.  Der zuk√ºnftige Schlaf-Timer wird an einen vorl√§ufigen Ort gestellt.  Es wird von dort von der Interruptroutine selbst von SVC √ºbernommen.  Atomizit√§t wird sozusagen erreicht.  Dies ist unten gezeigt. </p><br><pre> <code class="plaintext hljs">SVC_Handler LDR R0,__sysTickAddr ; SysTick  MOV R1,#6 ;   CSR ,   STR R1,[R0] ;Stop SysTimer MOV R1,#7 ; ,   STR R1,[R0] ;Start SysTimer ; STMDB SP!,{R4-R11} ;   LDR R0,=timersTable ;    LDR R1,=stacksTable ;    LDR R2,[R0] ;R2   ()  STR SP,[R1,R2,LSL #2] ;   SP (R2 * 4) LDR R3,=tmpTimersTable ;   tmpTimers LDR R3,[R3,R2,LSL #2] ;tmpTimer    STR R3,[R0,R2,LSL #2] ; timer  __svc_next_check ADD R2,R2,#1 ;   CMP R2,#TASKS_LIMIT ;R2-TASKS_LIMIT  BLO __svc_no_border_yet ;   MOV R2,#0 ;    (main) LDR R3,[R1] ; main SP MOV SP,R3 B __svc_timer_ok __svc_no_border_yet ;; LDR SP,[R1,R2,LSL #2] ;Restore SP does not work (errata Cortex M4) ;; CMP SP,#0 ; LDR R3,[R1,R2,LSL #2] ;  SP      CMP R3,#0 ; =0     BEQ __svc_next_check MOV SP,R3 LDR R3,[R0,R2,LSL #2] ;  suspend timer CBZ R3,__svc_timer_ok ; 0    ,   B __svc_next_check __svc_timer_ok STR R2,[R0] ;     LDMIA SP!,{R4-R11} ; R4-R11 BX LR</code> </pre> <br><p>  Es sei daran erinnert, dass sich alle diese Unterprogramme und Interrupt-Handler auf einen bestimmten Datenbereich beziehen, der vom Autor wie in Abbildung 7 dargestellt ausgef√ºhrt wird. </p><br><pre> <code class="plaintext hljs"> DATA SECTION .taskSwitcher:CODE:ROOT(2) __topStack DCD sfe(CSTACK) __botStack DCD sfb(CSTACK) __dimStack DCD sizeof(CSTACK) __sysAIRCRaddr DCD 0xE000ED0C __sysTickAddr DCD 0xE000E010 __sysSHPRaddr DCD 0xE000ED18 __sysTickReload DCD RELOAD ;******************************************************************************* ; Task table for concurrent tasks (main is number 0). ;******************************************************************************* SECTION TABLE:DATA:ROOT(2) DS32 1 ;stack shift due to FPU mainCopyCONTROL DS32 1 ;Needed to determine if FPU is used mainPSRvalue DS32 1 ;Copy from main ;*******************************************************************************</code> </pre> <br><p>  Um sicherzustellen, dass all das der gesunde Menschenverstand ist, musste der Autor ein kleines Projekt unter der IAR Embedded Workbench schreiben, in dem es ihm gelang, alles im Detail zu untersuchen und zu ber√ºhren.  Alles wurde auf dem STM32F303VCT6-Controller (ARM Cortex-M4) getestet.  Oder besser gesagt, mit der STM32F3DISCOVERY-Karte.  Es gibt gen√ºgend LEDs, um jede Aufgabe mit einer eigenen LED separat zu blinken. </p><br><p>  Es gibt noch ein paar weitere Funktionen, die ich n√ºtzlich fand.  Zum Beispiel eine Unterroutine, die in jedem Stapelbereich die Anzahl der nicht betroffenen W√∂rter z√§hlt, dh gleich Null bleibt.  Dies kann beim Debuggen hilfreich sein, wenn Sie √ºberpr√ºfen m√ºssen, ob das F√ºllen des Stapels mit der einen oder anderen Aufgabe zu nahe am Grenzwert liegt. </p><br><pre> <code class="plaintext hljs"> U32 get_task_stack_empty_space(U8 taskNum);</code> </pre> <br><p>  Ich m√∂chte noch eine Funktion erw√§hnen.  Dies ist eine Gelegenheit f√ºr die Aufgabe selbst, Ihre Nummer in der Liste herauszufinden.  Sie k√∂nnen es sp√§ter jemandem erz√§hlen. </p><br><pre> <code class="plaintext hljs">;******************************************************************************* ; Example: U8 get_my_number(void); ;     (). ..    . ;******************************************************************************* get_my_number LDR R0,=timersTable ;    (currentTaskNumber) LDR R0,[R0] ;  BX LR ;==============================================================</code> </pre> <br><p>  Das ist wahrscheinlich alles f√ºr den Moment. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454874/">https://habr.com/ru/post/de454874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454860/index.html">Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterst√ºtzen</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454868/index.html">Kompilieren von C in WebAssembly ohne Emscripten</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
<li><a href="../de454876/index.html">√úber das Entwerfen eines flexiblen Systems von Charakterf√§higkeiten in Spielen</a></li>
<li><a href="../de454878/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 3</a></li>
<li><a href="../de454880/index.html">"Nebensaison" im Leben eines Freiberuflers: Wie kann man √ºberleben und √ºberleben?</a></li>
<li><a href="../de454882/index.html">Die Architektur einer Ausnahmesituation: Punkt 2 von 4</a></li>
<li><a href="../de454884/index.html">Lesbare Testnamen in JS und im Verhaltensmuster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>