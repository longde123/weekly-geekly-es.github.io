<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔧 🛀🏿 🐌 CreateRemoteThread pour Linux 👨🏼‍🏭 👍🏼 🐵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WinAPI a une fonction CreateRemoteThread qui vous permet de démarrer un nouveau thread dans l'espace d'adressage d'un autre processus. Il peut être ut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CreateRemoteThread pour Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473740/"><p><img src="https://habrastorage.org/webt/qu/fi/43/qufi43ym9g9-ptbmm43ajv-e_-4.jpeg" width="300" align="right" alt="Mitsuha apporte de nouveaux flux">  WinAPI a une fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">CreateRemoteThread</a> qui vous permet de démarrer un nouveau thread dans l'espace d'adressage d'un autre processus.  Il peut être utilisé pour une variété d'injections de DLL, à la fois à des fins malveillantes (astuces dans les jeux, vol de mot de passe, etc.), et pour corriger un bug dans un programme en cours d'exécution à la volée, ou ajouter des plugins à des endroits où ils n'étaient pas fournis. </p><br><p>  En général, cette fonction a un utilitaire d'application douteux, il n'est donc pas surprenant que Linux ne dispose pas d'un analogue prêt à l'emploi de CreateRemoteThread.  Cependant, je me demandais comment le mettre en œuvre.  L'étude du sujet s'est transformée en une bonne aventure. </p><br><p>  Je vais expliquer en détail comment, à l'aide de la spécification ELF, une certaine connaissance de l'architecture x86_64 et des appels système Linux, écrire votre propre petit débogueur qui peut charger et exécuter du code arbitraire dans un processus déjà en cours d'exécution et de travail. </p><br><p>  La compréhension du texte nécessitera des connaissances de base sur la programmation système pour Linux: le langage C, les programmes d'écriture et de débogage dessus, une compréhension du rôle du code machine et de la mémoire dans l'ordinateur, le concept des appels système, la familiarité avec les principales bibliothèques et la lecture de la documentation. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Idées principales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Esquisse de solution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étape 1. Connexion au processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étape 2. Rechercher des bibliothèques en mémoire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étape 3. Analyse des images de la bibliothèque ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étape 4. Implémentation du shellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Étape 5. Démarrage d'un nouveau thread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><p>  En conséquence, j'ai pu «ajouter» la possibilité de prévisualiser les mots de passe dans le centre de contrôle Gnome: </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="démonstration d'injection au Gnome Control Center"></p><br><h2 id="osnovnye-idei">  Idées principales </h2><br><p>  S'il n'y avait aucune clause dans les exigences relatives au chargement de code dans un processus déjà en cours d'exécution, la solution serait extrêmement simple: LD_PRELOAD.  Cette variable d'environnement permet de charger une bibliothèque arbitraire avec l'application.  Dans les bibliothèques partagées, vous pouvez définir <em>des fonctions constructeur</em> qui s'exécutent lors du chargement de la bibliothèque. </p><br><p>  Ensemble, LD_PRELOAD et les constructeurs permettent l'exécution de code arbitraire dans n'importe quel processus utilisant un chargeur dynamique.  Il s'agit d'une fonctionnalité relativement bien connue souvent utilisée pour le débogage.  Par exemple, avec l'application, vous pouvez charger votre propre bibliothèque, qui définit les fonctions malloc () et free (), ce qui pourrait aider à détecter les fuites de mémoire. </p><br><p>  Malheureusement, LD_PRELOAD ne fonctionne qu'au démarrage du processus.  Il ne peut pas être utilisé pour charger une bibliothèque dans un processus déjà en cours d'exécution.  Il existe une fonction dlopen () pour charger les bibliothèques pendant le processus, mais, évidemment, le processus lui-même doit l'appeler pour charger les plugins. </p><br><blockquote> <strong>À propos des exécutables statiques</strong> <br><br>  LD_PRELOAD ne fonctionne qu'avec les programmes qui utilisent le chargeur dynamique.  Si le programme a été construit avec le commutateur <code>-static</code> , il inclut toutes les bibliothèques nécessaires.  Dans ce cas, la résolution des dépendances dans les bibliothèques est effectuée au moment de la génération et le programme n'est généralement pas prêt et n'est pas en mesure de charger dynamiquement les bibliothèques après l'assemblage, au moment de l'exécution. <br><br>  Dans les programmes assemblés statiquement, vous pouvez incorporer du code au moment de l'exécution, mais cela doit être fait d'une manière légèrement différente.  Et ce n'est pas entièrement sûr, car le programme n'est peut-être pas prêt pour un tel virage. </blockquote><p>  En général, il n'y a pas de solution pratique prête à l'emploi, vous devez écrire votre vélo.  Sinon, vous ne liriez pas ce texte :) </p><br><p>  Conceptuellement, pour forcer le processus de quelqu'un d'autre à exécuter une sorte de code, vous devez effectuer les actions suivantes: </p><br><ol><li>  Prenez le contrôle du processus cible. </li><li>  Chargez le code dans la mémoire du processus cible. </li><li>  Préparez le code téléchargé pour l'exécution dans le processus cible. </li><li>  Organisez l'exécution du code téléchargé par le processus cible. </li></ol><br><p>  Allons-y ... </p><br><h3 id="poluchenie-upravleniya-v-processe">  Prendre le contrôle du processus </h3><br><p>  Tout d'abord, nous devons subordonner le processus cible à notre volonté.  Après tout, les processus exécutent généralement uniquement leur propre code, ou le code des bibliothèques chargées, ou les résultats de la compilation JIT.  Mais certainement pas notre code. </p><br><p>  Une option consiste à utiliser une sorte de vulnérabilité dans le processus qui vous permet de prendre le contrôle.  Un exemple classique des tutoriels: buffer overflow, permettant de réécrire l'adresse de retour sur la pile.  C'est amusant, ça marche parfois même, mais pas adapté au cas général. </p><br><p>  Nous utiliserons une autre façon honnête de prendre le contrôle: le <em>débogage des appels système</em> .  Les débogueurs interactifs peuvent parfaitement arrêter les processus tiers, évaluer les expressions et bien d'autres choses.  Ils peuvent - nous pouvons. </p><br><p>  Sous Linux, l'appel système de débogage principal est <strong>ptrace ()</strong> .  Il vous permet de vous connecter aux processus, d'examiner leur statut et de contrôler la progression de leur exécution.  ptrace () est assez bien documenté seul, mais les détails de son utilisation ne sont clairs qu'en pratique. </p><br><h3 id="zagruzka-koda-v-pamyat-processa">  Chargement de code dans la mémoire de processus </h3><br><p>  Dans le cas de débordements de tampon, la charge utile ( <em>code shell</em> ) est généralement incluse dans le contenu qui déborde du même tampon.  Lorsque vous utilisez le débogueur, le code nécessaire peut être écrit directement dans la mémoire de processus.  Dans WinAPI, il existe une fonction spéciale WriteProcessMemory pour cela.  Linux à cet effet est conforme à la méthode UNIX: pour chaque processus du système, il existe un fichier <strong>/ proc / $ pid / mem</strong> , qui affiche la mémoire de ce processus.  Il est possible d'écrire quelque chose dans la mémoire de processus en utilisant l'entrée-sortie habituelle. </p><br><h3 id="podgotovka-koda-k-ispolneniyu">  Préparation du code pour l'exécution </h3><br><p>  Il ne suffit pas d'écrire du code en mémoire.  Il doit encore être écrit <em>dans la mémoire exécutable</em> .  Dans le cas de l'enregistrement via une vulnérabilité, cela présente des difficultés non triviales, mais comme nous pouvons contrôler complètement le processus cible, il ne nous sera pas difficile de trouver ou d'allouer la mémoire «correcte» pour nous-mêmes. </p><br><p>  Un autre point important de préparation est le code shell lui-même.  Dans ce document, nous voudrons probablement utiliser certaines fonctions des bibliothèques, telles que les entrées-sorties, les primitives graphiques, etc.  Cependant, nous devons écrire du code machine nu, qui en soi n'a aucune idée des adresses de toutes ces fonctions intéressantes dans les bibliothèques.  D'où les obtenez-vous? </p><br><p>  Pour simplifier la vie du système d'exploitation et compliquer la vie du code malveillant, les bibliothèques n'utilisent généralement pas d'adresses fixes (et contiennent <em>un code dit indépendant de la position</em> ).  Les adresses ne peuvent donc pas être devinées. </p><br><p>  Lorsque le processus démarre normalement, le <em>chargeur</em> qui effectue les <em>relocalisations</em> est chargé de déterminer les adresses exactes des bibliothèques.  Cependant, il ne remplit qu'une seule fois au départ.  Si le processus autorise le chargement dynamique des bibliothèques, il <em>contient</em> un <em>chargeur dynamique</em> qui peut faire de même pendant l'exécution du processus.  Cependant, l'adresse du chargeur dynamique n'est pas non plus fixe. </p><br><p>  En général, avec les bibliothèques, il y a quatre options: </p><br><ul><li>  n'utilisez pas du tout les bibliothèques, faites tout sur les appels système propres </li><li>  mettre des copies de toutes les bibliothèques nécessaires dans le code shell </li><li>  faites vous-même le travail du chargeur dynamique </li><li>  trouver un chargeur de démarrage dynamique et le faire charger nos bibliothèques </li></ul><br><p>  Nous choisirons ce dernier, car nous voulons les bibliothèques, et écrire notre chargeur de démarrage complet depuis longtemps.  Ce n'est pas la méthode la plus secrète, et non la plus intéressante, mais la plus simple, puissante et fiable. </p><br><h3 id="peredacha-upravleniya-kodu">  Transfert de contrôle au code </h3><br><p>  ptrace () vous permet de changer les registres du processeur, donc il ne devrait y avoir aucun problème avec le transfert du contrôle vers le code chargé et préparé: écrivez simplement l'adresse de notre code dans le registre% rip - et le tour est joué!  Cependant, en réalité, tout n'est pas si simple.  Les difficultés sont liées au fait que le processus débogué n'a en fait pas disparu et qu'il a également une sorte de code qui a été exécuté et continuera à être exécuté. </p><br><h2 id="eskiz-resheniya">  Esquisse de solution </h2><br><p>  Total, nous mettrons en œuvre notre flux dans un processus tiers comme suit: </p><br><ol><li>  Nous sommes connectés au processus cible de débogage. </li><li>  On retrouve les bibliothèques nécessaires en mémoire: <br><ul><li>  libdl - pour charger une nouvelle bibliothèque </li><li>  libpthread - pour démarrer un nouveau thread </li></ul></li><li>  On trouve les fonctions nécessaires dans les bibliothèques: <br><ul><li>  libdl: dlopen (), dlsym () </li><li>  libpthread: pthread_create (), pthread_detach () </li></ul></li><li><p>  Nous introduisons le code shell dans la mémoire du processus cible: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br></li><li>  Nous donnons le code shell à remplir. </li></ol><br><p>  En conséquence, les bibliothèques feront la bonne chose pour nous: elles chargeront notre bibliothèque avec le code dont nous avons besoin en mémoire et démarreront un nouveau thread exécutant ce code. </p><br><h3 id="ogranicheniya">  Limitations </h3><br><p>  L'approche décrite ci-dessus impose certaines limites: </p><br><ul><li>  Le chargeur de démarrage doit disposer de privilèges suffisants pour déboguer le processus cible. </li><li>  Le processus doit utiliser libdl (prêt pour le chargement dynamique des modules). </li><li>  Le processus doit utiliser libpthread (prêt pour le multithreading). </li><li>  Les applications statiques ne sont pas prises en charge. </li></ul><br><p>  De plus, personnellement, je suis trop paresseux pour me soucier du support des architectures tout-en-un, nous nous limiterons donc à x86_64.  (Même un x86 32 bits serait plus compliqué.) </p><br><p>  Comme vous pouvez le voir, tout cela met fin à une utilisation secrète avec des cibles malveillantes.  Cependant, la tâche conserve toujours un intérêt pour la recherche et laisse même une faible opportunité pour une utilisation industrielle. </p><br><h3 id="otstuplenie-ob-ispolzovanii-libdl-i-libpthread">  Digression: à propos de l'utilisation de libdl et libpthread </h3><br><p>  Un lecteur-lecteur expérimenté peut se demander: pourquoi avoir besoin de libdl si les fonctions internes __libc_dlopen_mode () et __libc_dlsym () sont déjà intégrées dans glibc, et libdl n'est qu'un wrapper sur elles?  De même, pourquoi exiger libpthread si un nouveau thread peut être facilement créé en utilisant l'appel système clone ()? </p><br><p>  En effet, sur Internet, il y a loin d'un exemple de leur utilisation: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/gaffe23/linux-inject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/TsarFox/hypodermic</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://hick.org/code/skape/papers/needle.txt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/ice799/injectso64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://www.ouah.org/subversiveld.pdf</a> </li></ul><br><p>  Ils sont même mentionnés dans la littérature populaire des hackers: </p><br><ul><li>  Apprendre l'analyse binaire Linux </li><li>  L'art de la médecine légale </li></ul><br><p>  Alors pourquoi pas?  Eh bien, au moins parce que nous n'écrivons pas de code malveillant où une solution appropriée qui omet 90% des vérifications, prend 20 fois moins d'espace, mais fonctionne également dans 80% des cas.  De plus, je voulais tout essayer de mes propres mains. </p><br><p>  En effet, libdl n'est pas <em>nécessaire</em> pour charger la bibliothèque dans le cas de glibc.  Son utilisation par le processus indique qu'il est clairement prêt pour le chargement de code dynamique.  Malgré cela, en principe, vous pouvez refuser d'utiliser libdl (étant donné que nous devrons également rechercher la glibc plus tard également). </p><br><blockquote>  <strong>Pourquoi dlopen () à l'intérieur de la glibc?</strong> <br><br>  C'est une question intéressante à sa manière.  Réponse courte: détails de mise en œuvre. <br><br>  Le point est le <em>commutateur de service de noms</em> (NSS) - l'une des parties de la glibc qui fournit la traduction de divers noms: noms de machines, protocoles, utilisateurs, serveurs de messagerie, etc. C'est elle qui est responsable de fonctions telles que getaddrinfo () pour obtenir des adresses IP en nom de domaine et getpwuid () pour obtenir des informations sur l'utilisateur par son identifiant numérique. <br><br>  NSS a une architecture modulaire et les modules se chargent dynamiquement.  En fait, pour cela, la glibc avait également besoin de mécanismes de chargement dynamique des bibliothèques.  C'est pourquoi lorsque vous essayez d'utiliser getaddrinfo () dans une application assemblée statiquement, l'éditeur de liens affiche un avertissement «incompréhensible»: <br><pre>
 /tmp/build/socket.o: Dans la fonction `Socket :: bind ':
 socket.o :(. text + 0x374): avertissement: utilisation de 'getaddrinfo' dans un lien statique
 les applications nécessitent au moment de l'exécution les bibliothèques partagées de la version glibc
 utilisé pour la liaison
</pre><br></blockquote><p>  En ce qui concerne les threads, un thread n'est généralement pas seulement une pile et un code exécutable, mais également des données globales stockées dans <em>un stockage local de threads</em> (TLS).  L'initialisation correcte d'un nouveau thread nécessite le fonctionnement coordonné du noyau du système d'exploitation, un chargeur de code binaire et un runtime de langage de programmation.  Par conséquent, un simple appel à clone () suffit pour créer un flux qui peut écrire dans le fichier "Hello world!", Mais cela peut ne pas fonctionner pour un code plus complexe qui a besoin d'accéder à TLS et à d'autres choses intéressantes cachées aux yeux du programmeur d'application. </p><br><p>  Un autre point lié au multithreading concerne les processus à un seul thread.  Que se passe-t-il si nous créons un nouveau thread dans un processus qui n'a pas été conçu comme multithread?  Bon comportement vague.  En effet, dans le processus, il n'y a pas de synchronisation du travail entre les threads, ce qui entraînera tôt ou tard une corruption des données.  Si nous exigeons que l'application utilise libpthread, alors nous pouvons être sûrs qu'elle est prête à fonctionner dans un environnement multithread (au moins elle devrait être prête). </p><br><h2 id="shag-1-podklyuchenie-k-processu">  Étape 1. Connexion au processus </h2><br><p>  Tout d'abord, nous devons nous connecter au processus cible pour le débogage, puis le déconnecter à nouveau.  C'est là que l'appel système <em>ptrace</em> () entre en jeu. </p><br><h3 id="pervyy-kontakt-s-ptrace">  Premier contact avec ptrace () </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Dans la documentation de ptrace (),</a> vous pouvez trouver presque toutes les informations nécessaires: </p><br><pre>   Fixation et détachement
        Un fil peut être attaché au traceur à l'aide de l'appel<font></font>
<font></font>
            ptrace (PTRACE_ATTACH, pid, 0, 0);<font></font>
<font></font>
        ou<font></font>
<font></font>
            ptrace (PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<font></font>
<font></font>
        PTRACE_ATTACH envoie SIGSTOP à ce fil.  Si le traceur le veut
        SIGSTOP n'a aucun effet, il doit le supprimer.  Notez que si
        d'autres signaux sont envoyés simultanément à ce fil pendant l'attachement, le
        le traceur peut voir le tracé entrer dans le signal-livraison-stop avec d'autres signaux
        nal (s) en premier!  La pratique habituelle consiste à réinjecter ces signaux jusqu'à
        SIGSTOP s'affiche, puis supprimer l'injection de SIGSTOP.  Le bug de conception
        voici qu'un attach ptrace et un SIGSTOP livré simultanément peuvent
        course et le SIGSTOP simultané peuvent être perdus.
</pre><br><p>  La première étape consiste donc à utiliser PTRACE_ATTACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_ATTACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Après ptrace (), le processus cible n'est pas tout à fait prêt pour le débogage.  Nous y sommes connectés, mais pour une étude interactive de l'état du processus, il faut l'arrêter.  ptrace () envoie un signal SIGSTOP au processus, mais nous devons encore attendre que le processus s'arrête réellement. </p><br><p>  Pour attendre, utilisez l'appel système <em>waitpid</em> ().  Dans le même temps, plusieurs cas limites intéressants méritent d'être notés.  Premièrement, le processus peut simplement se terminer ou mourir sans avoir reçu SIGSTOP.  Dans ce cas, nous ne pouvons rien faire.  Deuxièmement, un autre signal peut être préalablement envoyé au processus.  Dans ce cas, nous devons laisser le processus le traiter (en utilisant PTRACE_CONT), et nous-mêmes, continuer d'attendre plus longtemps notre SIGSTOP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      —   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSIGNALED(status) || WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status)) { <span class="hljs-comment"><span class="hljs-comment">/* *  WSTOPSIG()   , *   ptrace()   *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stop_signal = status &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop_signal == expected_signal) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, stop_signal) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   —   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="otklyuchenie-ot-processa">  Déconnexion du processus </h3><br><p>  Arrêter le processus de débogage est beaucoup plus simple: utilisez simplement PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  À proprement parler, la désactivation explicite du débogueur n'est pas toujours nécessaire.  Lorsque le processus de débogage se termine, il se déconnecte automatiquement de tous les processus débogués et les processus reprennent s'ils ont été arrêtés par ptrace ().  Cependant, si le processus débogué a été explicitement arrêté par le débogueur à l'aide du signal SIGSTOP sans utiliser ptrace (), il ne se réveillera pas sans le signal SIGCONT ou PTRACE_DETACH correspondant.  Par conséquent, il est préférable de se déconnecter culturellement des processus. </p><br><h3 id="nastroyka-ptrace_scope">  Paramètre Ptrace_scope </h3><br><p>  Le débogueur a un contrôle total sur le processus en cours de débogage.  Si quelqu'un pouvait déboguer quoi que ce soit, quelle serait l'étendue du code malveillant!  Il est évident que le débogage interactif est une activité assez spécifique, généralement nécessaire uniquement aux développeurs.  Pendant le fonctionnement normal du système, le plus souvent, il n'est pas nécessaire de déboguer les processus. </p><br><p>  Pour ces raisons, pour des raisons de sécurité, les systèmes désactivent généralement la possibilité de déboguer les processus par défaut.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">module de sécurité <strong>Yama en</strong></a> est responsable, géré via le fichier / proc / sys / kernel / yama / ptrace_scope.  Il propose quatre comportements: </p><br><ul><li>  0 - l'utilisateur peut déboguer tous les processus qu'il a démarrés </li><li>  1 - mode par défaut, seuls les processus démarrés par le débogueur peuvent être débogués </li><li>  2 - seul un administrateur système racine peut déboguer les processus </li><li>  3 - le débogage est interdit à tout le monde, le mode ne s'éteint qu'au redémarrage du système </li></ul><br><p>  De toute évidence, pour nos besoins, il sera nécessaire de pouvoir déboguer les processus lancés avant notre débogueur, donc pour les expériences, vous devrez soit basculer le système en mode développement en écrivant 0 dans un fichier ptrace_scope spécial (qui nécessite des droits d'administrateur): </p><br><pre> <code class="plaintext hljs">$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'</code> </pre> <br><p>  ou exécutez le débogueur en tant qu'administrateur: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread ...</code> </pre> <br><h3 id="rezultaty-pervogo-shaga">  Résultats de la première étape </h3><br><p>  Par conséquent, dans la première étape, nous sommes en mesure de nous connecter au processus cible en tant que débogueur et de nous en déconnecter plus tard. </p><br><p>  Le processus cible sera arrêté et nous pouvons nous assurer que le système d'exploitation nous voit vraiment comme un débogueur: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread --target $(pgrep docker) $ cat /proc/$(pgrep docker)/status | head Name: docker State: t (tracing stop) &lt;---    Tgid: 31330 Ngid: 0 Pid: 31330 PPid: 1 TracerPid: 2789 &lt;--- PID   Uid: 0 0 0 0 Gid: 0 0 0 0 FDSize: 64 $ ps a | grep [2]789 2789 pts/5 S+ 0:00 ./inject-thread --target 31330</code> </pre> <br><h2 id="shag-2-poisk-bibliotek-v-pamyati">  Étape 2. Rechercher des bibliothèques en mémoire </h2><br><p>  L'étape suivante est plus simple: vous devez trouver dans la mémoire du processus cible la bibliothèque avec les fonctions dont nous avons besoin.  Mais il y a beaucoup de mémoire, par où commencer et quoi exactement? </p><br><h3 id="fayl-procpidmaps">  Fichier / proc / $ pid / maps </h3><br><p>  Un fichier spécial nous aidera avec cela, à travers lequel le noyau indique quoi et où se trouve le processus en mémoire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Comme vous le savez</a> , dans le répertoire / proc de chaque processus, il y a un sous-répertoire.  Et il y a un fichier qui décrit <em>la carte mémoire du</em> processus: </p><br><pre> $ cat / proc / self / maps
 00400000-0040c000 r-xp 00000000 fe: 01 1044592 / bin / cat
 0060b000-0060c000 r - p 0000b000 fe: 01 1044592 / bin / cat
 0060c000-0060d000 rw-p 0000c000 fe: 01 1044592 / bin / cat
 013d5000-013f6000 rw-p 00000000 00:00 0 [tas]
 7f9920bd1000-7f9920d72000 r-xp 00000000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920d72000-7f9920f72000 --- p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f72000-7f9920f76000 r - p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f76000-7f9920f78000 rw-p 001a5000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7fc3f8381000-7fc3f8385000 rw-p 00000000 00:00 0
 7fc3f8385000-7fc3f83a6000 r-xp 00000000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f83ec000-7fc3f840e000 rw-p 00000000 00:00 0
 7fc3f840e000-7fc3f8597000 r - p 00000000 fe: 01 657286 / usr / lib / locale / locale-archive
 7fc3f8597000-7fc3f859a000 rw-p 00000000 00:00 0
 7fc3f85a3000-7fc3f85a5000 rw-p 00000000 00:00 0
 7fc3f85a5000-7fc3f85a6000 r - p 00020000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a6000-7fc3f85a7000 rw-p 00021000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a7000-7fc3f85a8000 rw-p 00000000 00:00 0
 7ffdb6f0e000-7ffdb6f2f000 rw-p 00000000 00:00 0 [pile]
 7ffdb6f7f000-7ffdb6f81000 r-xp 00000000 00:00 0 [vdso]
 7ffdb6f81000-7ffdb6f83000 r - p 00000000 00:00 0 [vvar]
 ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</pre><br><p>  Le contenu de ce fichier est généré à la volée par le noyau du système d'exploitation à partir de structures internes qui décrivent les régions mémoire du processus qui nous intéresse et contient les informations suivantes: </p><br><ul><li>  plage d'adresses attribuée à la région </li><li>  droits d'accès à la région <br><ul><li>  <code>r/-</code> : lire </li><li>  <code>w/-</code> : écrire </li><li>  <code>x/-</code> : exécution </li><li>  <code>p/s</code> : partage de mémoire avec d'autres processus </li></ul></li><li>  décalage de fichier (le cas échéant) </li><li>  code de l'appareil où se trouve le fichier affiché </li><li>  numéro d'inode du fichier (le cas échéant) </li><li>  chemin d'accès au fichier affiché (le cas échéant) </li></ul><br><p>  Certaines régions de la mémoire sont mappées sur des fichiers: lorsqu'un processus lit une telle mémoire, il lit en fait les données des fichiers correspondants à un décalage spécifique.  Si vous pouvez écrire dans une région, les modifications de la mémoire peuvent être visibles uniquement pour le processus lui <em>-</em> même (mécanisme de <em>copie sur écriture</em> , le mode <code>p</code> est privé) ou synchronisées avec le disque ( <code>s</code> mode <code>s</code> est partagé). </p><br><p>  Les autres régions sont <em>anonymes</em> - cette mémoire ne correspond à aucun fichier.  Le système d'exploitation donne simplement au processus un morceau de mémoire physique qu'il utilise.  De telles régions sont utilisées, par exemple, pour la mémoire de processus "normale": pile et tas.  Les régions anonymes peuvent être personnelles à un processus ou partagées entre plusieurs processus (mécanisme de <em>mémoire partagée</em> ). </p><br><p>  De plus, il y a plusieurs régions spéciales dans la mémoire marquées des pseudo-noms [vdso] et [vsyscall].  Ils sont utilisés pour optimiser certains appels système. </p><br><p>  Nous sommes intéressés par les régions où le contenu des fichiers de bibliothèque est affiché.  Si nous lisons la carte mémoire et filtrons les entrées qu'elle contient par le nom du fichier affiché, nous trouverons toutes les adresses occupées par les bibliothèques dont nous avons besoin.  Le format de la carte mémoire est spécialement adapté au traitement des programmes et se comprend facilement à l'aide des fonctions de la famille scanf (): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_proc_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_low = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_high = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> execute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> path_offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    /proc/$pid/maps */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"%lx-%lx %c%c%c%*c %*lx %*x:%*x %*d %n"</span></span>, &amp;vaddr_low, &amp;vaddr_high, &amp;read, &amp;write, &amp;execute, &amp;path_offset); <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(line + path_offset, library)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region) { region-&gt;vaddr_low = vaddr_low; region-&gt;vaddr_high = vaddr_high; region-&gt;readable = (read == <span class="hljs-string"><span class="hljs-string">'r'</span></span>); region-&gt;writeable = (write == <span class="hljs-string"><span class="hljs-string">'w'</span></span>); region-&gt;executable = (execute == <span class="hljs-string"><span class="hljs-string">'x'</span></span>); region-&gt;content = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 id="tayna-tretey-planety">    </h3><br><p>      ,  libc-2.19.so,     : </p><br><p><img src="https://habrastorage.org/webt/vf/lw/4m/vflw4m5jy3pwtbcxu0foudxnh3o.png" alt="  libc-2.19.so"></p><br><p>        2   -    ?  51?   ?  ? </p><br><p> ,    ,          . </p><br><p>  ,     <em></em>   ,         .  <em> </em>         ,    ,   ,           (, ,        ). </p><br><p>      ,  <em></em> (  4  ).    ,            . </p><br><p>  ,           .       —    —      .           2    —   ,        ( x86_64    4 , 2 , 1 ).                  . </p><br><h3 id="rezultaty-vtorogo-shaga">    </h3><br><p>     ,          : </p><br><ul><li>  libdl: dlopen()  dlsym() </li><li>  libpthread: pthread_create()  pthread_detach() </li></ul><br><p>    ,       ,   .      Linux       ( <em>address space layout randomization</em> , ASLR).        (- ,     ),             —    - . </p><br><p>       ,           ,      ,     /proc/$pid/maps.     ,          . </p><br><h2 id="shag-3-razbor-elf-obrazov-bibliotek">  3.  ELF-  </h2><br><p> ,      ,        ,   . </p><br><p>   : </p><br><pre> <code class="plaintext hljs">$ nm -D /lib/x86_64-linux-gnu/libdl-2.19.so | grep dlopen 0000000000001090 T dlopen</code> </pre> <br><p>  <em>nm</em>             .                . </p><br><p>   -  ,      nm     ,        .  ,      dlsym(). </p><br><h3 id="chtenie-pamyati-celevogo-processa">     </h3><br><p>   —    ELF-,    .        procfs.    UNIX way,         <strong>/proc/$pid/mem</strong> ,    —      (     /proc/$pid/maps). </p><br><p>   Linux           mmap(),         (    ,   ).            : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> offset = region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buffer) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_close_file; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_region(fd, offset, buffer, length) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_free_buffer; region-&gt;content = buffer; close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_free_buffer: <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); error_close_file: close(fd); error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, offset, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> remaining = length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = buffer; <span class="hljs-comment"><span class="hljs-comment">/* *     .   , *      ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remaining &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> count = read(fd, ptr, remaining); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; remaining -= count; ptr += count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>      ELF- .    , -,       ,  -,       . </p><br><h3 id="dvulikiy-elf">  ELF </h3><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">   ELF</a> —         Linux.      ,    ,      . </p><br><p>      ELF   .    ELF    <em></em>    .    —   <em></em> ,        .      ,  —    .        ELF-. </p><br><p> ,   libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/at/zw/up/atzwupwipysw3kip1yx95aa-eps.png" alt="   libdl-2.19.so"></p><br><p> (          <code>readelf --headers</code> .) </p><br><p>   ,    ,   (29  9).    —    ,           ,     .  ELF —    ,      .  Linux, ,    LOAD,      (     ). </p><br><p>   ELF-     ,         . ,       . </p><br><p>       ,   . «»    .     .bss,   ,      (    ). </p><br><p>  ,   ELF     —  ,     .       ... </p><br><h3 id="gde-lezhit-tablica-simvolov">    ? </h3><br><p>          ()   .        ,     dlsym(),       .  -   . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> ELF</a> (. 2-10).   ,        <strong>.dynamic</strong> ,     <strong>DYNAMIC</strong> .   .dynamic     ,  : </p><br><ul><li> <strong>.dynsym</strong> —     ; </li><li> <strong>.dynstr</strong> —     ; </li><li> <strong>.hash</strong> — -,   . </li></ul><br><p>    ,     ,       ELF: </p><br><p><img src="https://habrastorage.org/webt/yw/y9/7d/ywy97dqzszhxz1jmoe45851oebe.png" alt="Recherche de segment DYNAMIQUE"></p><br><p>     ELF,      (1),      (2),      (3),      (4) <del>  ,    </del>  . </p><br><h4 id="zagolovok-elf--tablica-segmentov">  ELF →   </h4><br><p> ()   ELF      &lt;elf.h&gt;, ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> </a> .   ,  ELF —      .    32-  64- ,      ,      ,   .          x86_64,    ELF  . </p><br><p>  ELF-    ( <strong>Elf64_Ehdr</strong> ).          ( <em>program headers</em> ),    <strong>e_phoff</strong>  <strong>e_phnum</strong> : </p><br><p><img src="https://habrastorage.org/webt/1z/al/rn/1zalrn30vwfxce_smmy4vylj55g.png" alt="En-tête ELF"></p><br><p>   —    ,   ,  ELF-   —     ,    ,     ,  ,    . </p><br><p>        e_phoff,       ,      .    e_phnum   e_phentsize  . </p><br><p>    (   ),        ELF —    64 . </p><br><h4 id="tablica-segmentov--segment-dynamic">   →  DYNAMIC </h4><br><p>      .   —      <strong>Elf64_Phdr</strong> ( 64- ELF-),   .      <strong>PT_DYNAMIC</strong>   <strong>p_type</strong> : </p><br><p><img src="https://habrastorage.org/webt/i0/rg/cp/i0rgcpji9bl9wbsvegzrree9zfm.png" alt="Table des segments ELF"></p><br><p>          : </p><br><ul><li> <strong>p_vaddr</strong> —   ,    ; </li><li> <strong>p_memsz</strong> —      . </li></ul><br><p>     .dynamic      0x2D88 (     ).        DYNAMIC     —   0x202D88.    0x210 (8448) .                . </p><br><h4 id="segment-dynamic--sekcii-dynsym-dynstr-hash">  DYNAMIC →  .dynsym, .dynstr, .hash </h4><br><p>  .dynamic,    DYNAMIC,      .       <strong>Elf64_Dyn</strong> ,   : </p><br><p><img src="https://habrastorage.org/webt/dd/jp/th/ddjpthosvl8irw8ekelw0bdkaug.png" alt="Balises de section DYNAMIC"></p><br><p>    8     <strong>d_val</strong>  <strong>d_ptr</strong> ,   8-  <strong>d_tag</strong> ,  ,    .      : </p><br><ul><li> <strong>DT_HASH</strong> (4) —    .hash ( d_ptr) </li><li> <strong>DT_STRTAB</strong> (5) —    .dynstr ( d_ptr) </li><li> <strong>DT_SYMTAB</strong> (6) —    .dynsym ( d_ptr) </li><li> <strong>DT_STRSZ</strong> (10) —     .dynstr ( d_val) </li><li> <strong>DT_NULL</strong> (0) —     </li></ul><br><p>       .     .dynamic     :  ,   ,    ,    . </p><br><p>    ,   DYNAMIC   <em></em>          ,    .      ,            ,  - ,   . </p><br><p>    .dynamic         ,          . -,   .dynstr   ,      ?     . </p><br><h3 id="poisk-funkciy-v-biblioteke">     </h3><br><p>            .     ,    <strong>.dynsym</strong>   ,        . (  «»   .symtab,      , ,  .    .) </p><br><h4 id="tablica-simvolov">   </h4><br><p>      <strong>Elf64_Sym</strong> ,        ELF — , , , .       <code>dlopen</code> : </p><br><p><img src="https://habrastorage.org/webt/pd/5_/qh/pd5_qhcculmqmjk7p6krar1czjy.png" alt="Table de caractères ELF"></p><br><p>      : </p><br><ul><li> <strong>st_name</strong> —  ,       </li><li> <strong>st_info</strong> —     (   ) </li><li> <strong>st_value</strong> —     </li></ul><br><p> (  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  nm</a>   ,  dlopen()     .text,   0x1090   .) </p><br><p>     ,       . </p><br><h4 id="tablica-strok">   </h4><br><p>   —     - ,    .            (   ).        <strong>.dynstr</strong> ,      libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/mg/b9/1v/mgb91vjtwrr_kqrncnrojgg6jum.png" alt="Table de rang ELF"></p><br><p> ,           ( «dlopen»,   0xA5)      ,    .        . </p><br><h4 id="hesh-tablica"> - </h4><br><p>  <strong>.hash</strong>  <em>-</em> ,       .   - —    —      ELF-,       . ,         .dynsym,       ,      .   ( )     - . </p><br><p>  -      &lt;elf.h&gt;,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> </a> (. 2-19).   -   ,   : </p><br><p><img src="https://habrastorage.org/webt/ez/a3/ku/eza3ku71zydhqm_e3je0xbtjec8.png" alt="table de hachage ELF"></p><br><p>  où </p><br><ul><li> nbuckets —    buckets </li><li> nchains —    chains (  ) </li><li> buckets —      </li><li> chains —      </li></ul><br><p>  -  : </p><br><ol><li>   <strong>h</strong>    . </li><li>   <strong>i</strong>  <code>buckets[h % nbuckets]</code> ,     . </li><li>      (     )  ,   . </li><li>    —  <code>chains[i % nchains]</code> . </li><li>   3—4           ,       . </li></ol><br><p>  -,  ELF: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*name) { h = (h &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + *name++; g = h &amp; <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g) h ^= g &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; h &amp;= ~g; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br><p> ,   <code>"dlopen"</code> -   112420542     : </p><br><p><img src="https://habrastorage.org/webt/zu/ch/4i/zuch4ibwuspxmog6_erhbq1evyg.png" alt="rechercher un personnage dans une bibliothèque"></p><br><p> libdl —    ,    39   ,      .  -           . </p><br><h3 id="rezultaty-tretego-shaga">    </h3><br><p>              ,          : </p><br><ul><li> dlopen()  dlsym()   libdl </li><li> pthread_create()  pthread_detach()   libpthread </li></ul><br><p>   ,    . </p><br><p>         .            .      ,       . </p><br><p>     ELF-    .       ,      (  ).        ,    . ,    ,     .               . </p><br><h2 id="shag-4-vnedrenie-shell-koda">  4.  - </h2><br><p>   ,    ,    <em>-</em> ,     :         ,   .   -  . </p><br><h3 id="soderzhimoe-shell-koda">  - </h3><br><p> ,   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*entry)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br><p>       ? </p><br><p> ,        —   .    ,     ,      ,       -  —  -     !    . </p><br><p>    —   -  .         ,    ,           :        . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      .rodata:   * .         , *        . */</span></span> .section .rodata <span class="hljs-comment"><span class="hljs-comment">/* *   .       . *      -:    ,  *  ,       . */</span></span> .global shellcode_start .global shellcode_address_dlopen .global shellcode_address_dlsym .global shellcode_address_pthread_create .global shellcode_address_pthread_detach .global shellcode_address_payload .global shellcode_address_entry .global shellcode_end <span class="hljs-comment"><span class="hljs-comment">/* *   dlopen().     #include &lt;dlfcn.h&gt;, *       . */</span></span> .set RTLD_LAZY, <span class="hljs-number"><span class="hljs-number">1</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_start: <span class="hljs-comment"><span class="hljs-comment">/* * void *payload = dlopen(shellcode_address_payload, RTLD_LAZY); * *        x86_64: * * -     %rdi, %rsi, %rdx, %rcx * -     %rax * -      * *         . * *       %rax,    *     . */</span></span> lea shellcode_address_payload(%rip),%rdi mov $RTLD_LAZY,%rsi mov shellcode_address_dlopen(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * void (*entry)(void) = dlsym(payload, shellcode_address_entry); */</span></span> mov %rax,%rdi lea shellcode_address_entry(%rip),%rsi mov shellcode_address_dlsym(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_t thread; * pthread_create(&amp;thread, NULL, entry, NULL); * *            * ,     pthread_create(). */</span></span> sub $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_detach(thread); * *    ,   ,  *     . */</span></span> mov (%rsp),%rdi add $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov shellcode_address_pthread_detach(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* *   - —    ,     *      ret.    *     ,  *      . */</span></span> int $<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *       ,   *   ,    - *     .   “  *  ” (global offset table, GOT),   *           . */</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlopen: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlsym: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_create: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_detach: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_payload: .space <span class="hljs-number"><span class="hljs-number">256</span></span> shellcode_address_entry: .space <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *  - . */</span></span> shellcode_end: .end</code> </pre> <br><p> ,   .      : </p><br><pre> <code class="plaintext hljs">$ as -o shellcode.o shellcode.S</code> </pre> <br><p>  ,      ,  ,   .            :   <em>  </em> (procedure linkage table, PLT),        . </p><br><p>     -    ,         (, )       .  <em>-</em>  <em></em> . </p><br><h3 id="razmeschenie-shell-koda-v-pamyati">  -   </h3><br><p>     <em>-</em>    . ,       ,   ,          .      ? </p><br><h4 id="trebovaniya-k-pamyati-pod-shell-kod">     - </h4><br><p>      ,       .      <em></em> ,       .    ,         .         ,       . </p><br><p>              (-  ),         :   ,    ,    . , ,   JIT-   ,       .    ? </p><br><h4 id="podhody-k-razmescheniyu-v-pamyati">      </h4><br><p>         : </p><br><ul><li>  -  ,     </li><li>   - ,    </li></ul><br><p>      ,  . -,    - ,     . -,       . -,      ,  -    -,     . </p><br><p>   ,      .     .  x86_64  <code>int $3</code>     — 0xCC —          .  ptrace()         PTRACE_POKETEXT — ,     8   , . ,          ,     . </p><br><p> ,  ,   ,       :        .     -       ,  . </p><br><h4 id="kak-vydelit-novuyu-pamyat">    ? </h4><br><p>  ,  !    malloc()! </p><br><p> .      ,      -,    .       .          ,     mmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shellcode_dst = mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); copy_shellcode(shellcode_dst, shellcode_src, shellcode_size); }</code> </pre> <br><p>  ,   ptrace()         ,     . </p><br><h3 id="vypolnenie-sistemnyh-vyzovov">    </h3><br><p>      ,     ?    ,            . Linux  x86_64   : </p><br><ul><li>       %rax </li><li>    —    —      %rsi, %rdi, %rdx, %r10, %r8, %r9 </li><li>   SYSCALL,     </li><li>       %rax </li></ul><br><p>  ptrace()           PTRACE_GETREGS  PTRACE_SETREGS.  ,        .   -   SYSCALL. </p><br><p>     :      ,       %rip.   ,   ,   SYSCALL. </p><br><h4 id="poisk-instrukcii-syscall">   SYSCALL </h4><br><p>    SYSCALL? ,    .   -   ,   <em>-</em>      .    —   libc.  ,  ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_syscall_instruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct library *library)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; library-&gt;region_count; i++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory_region</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">library</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">regions</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(region-&gt;readable &amp;&amp; region-&gt;executable)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *region_data = region-&gt;content; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> region_size = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * 0F 05 syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; region_size - <span class="hljs-number"><span class="hljs-number">1</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_data[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x0F</span></span> &amp;&amp; region_data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> region-&gt;vaddr_low + offset; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  /proc/$pid/maps</a> .  x86_64     ,    -   .     <em></em>   ,    0x0F 0x05.     , ,  ARM,       0xDF 0x00 ( SVC #0),  <em>  </em> . </p><br><h4 id="ispolzovanie-ptrace_getsetregs">  PTRACE_{GET,SET}REGS </h4><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct user_regs_struct *registers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_GETREGS, pid, registers, registers) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) err = -errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br><p>     <code>struct user_regs_struct</code> ,    &lt;sys/user.h&gt;.     .          .     ,        <em>varargs</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_regs_for_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct user_regs_struct *registers, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, va_list args)</span></span></span><span class="hljs-function"> </span></span>{ registers-&gt;rip = syscall_insn_vaddr; registers-&gt;rax = syscall_number; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args_count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: registers-&gt;rdi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: registers-&gt;rsi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: registers-&gt;rdx = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: registers-&gt;r10 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: registers-&gt;r8 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: registers-&gt;r9 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -E2BIG; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,   *      . */</span></span> get_registers(pid, &amp;old_registers); <span class="hljs-comment"><span class="hljs-comment">/* *      ,   * ,     . */</span></span> new_registers = old_registers; va_list args; va_start(args, args_count); set_regs_for_syscall(&amp;new_registers, syscall_insn_vaddr, syscall_number, args_count, args); va_end(args); set_registers(pid, &amp;new_registers); <span class="hljs-comment"><span class="hljs-comment">/* *    ,    *   ,    * (  ),    . *     . */</span></span> wait_for_syscall_completion(pid); <span class="hljs-comment"><span class="hljs-comment">/* *       *    . *        . */</span></span> get_registers(pid, &amp;new_registers); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = new_registers.rax; set_registers(pid, &amp;old_registers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h4 id="ispolzovanie-ptrace_syscall">  PTRACE_SYSCALL </h4><br><p>       :        ,    ? </p><br><p>      PTRACE_SYSCALL.   PTRACE_CONT,     .   ,    - :    ,    . </p><br><p> PTRACE_SYSCALL    SIGTRAP    :      (     )       (      ).  , ptrace()   ,          ,         . </p><br><p>  ,           SIGTRAP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_enter_exit_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_SYSCALL, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGTRAP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_completion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ wait_for_syscall_enter_exit_stop(pid); wait_for_syscall_enter_exit_stop(pid); }</code> </pre> <br><p>   —   ,    —       (wait_for_process_stop() <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).           .       ,     . </p><br><h4 id="opciya-ptrace_o_tracesysgood">  PTRACE_O_TRACESYSGOOD </h4><br><p>   , PTRACE_SYSCALL      :       ,   ,  -  .  ,      SIGTRAP       (    ). </p><br><p>     SIGTRAP       <em></em> .        PTRACE_O_TRACESYSGOOD,            : </p><br><ul><li> SIGTRAP — -     </li><li> SIGTRAP | 0x80 —     </li></ul><br><pre> <code class="diff hljs"> int ptrace_attach(pid_t pid) { if (ptrace(PTRACE_ATTACH, pid, 0, 0) &lt; 0) return -1; if (wait_for_process_stop(pid, SIGSTOP) &lt; 0) return -1; + /*     */ + unsigned long options = PTRACE_O_TRACESYSGOOD; + if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) + return -1; return 0; } static int wait_for_syscall_enter_exit_stop(pid_t pid) { if (ptrace(PTRACE_SYSCALL, pid, 0, 0) &lt; 0) return -1; - if (wait_for_process_stop(pid, SIGTRAP) &lt; 0) + if (wait_for_process_stop(pid, SIGTRAP | 0x80) &lt; 0) return -1; return 0; }</code> </pre> <br><h3 id="zagruzka-shell-koda-v-pamyat">  -   </h3><br><p> -       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_text[SHELLCODE_TEXT_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shellcode_size = shellcode_end - shellcode_start; <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,  . . */</span></span> prepare_shellcode(shellcode_text, shellcode_size); <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); }</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   -</a>    :      dlopen(),               . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> offset = shellcode_addr - shellcode_start; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(shellcode_text + offset, data, length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ copy_shellcode(shellcode_text, shellcode_start, shellcode_start, shellcode_size); copy_shellcode(shellcode_text, shellcode_address_dlopen, &amp;dlopen_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlopen_vaddr)); copy_shellcode(shellcode_text, shellcode_address_dlsym, &amp;dlsym_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlsym_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_create, &amp;pthread_create_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_create_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_detach, &amp;pthread_detach_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_detach_vaddr)); copy_shellcode(shellcode_text, shellcode_address_payload, payload, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(payload)); copy_shellcode(shellcode_text, shellcode_address_entry, entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry)); }</code> </pre> <br><p>     ,    ,      -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlopen[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlsym[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_create[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_detach[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_payload[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_entry[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_end[];</code> </pre> <br><p>      ,              . </p><br><p>    -        .         /proc/$pid/mem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_WRONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, vaddr, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = do_write_remote_memory(fd, data, size); close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left = size; <span class="hljs-comment"><span class="hljs-comment">/* *    ,  ,     *   ,       *      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> wrote = write(fd, data, left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrote &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; data += wrote; left -= wrote; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-chetvyortogo-shaga">    </h3><br><p> ,             - — « » .           .    - ,                . </p><br><h2 id="shag-5-zapusk-novogo-potoka">  5.    </h2><br><p>     -        .  ,    :    %rip  -,  PTRACE_SETREGS,  PTRACE_CONT    .     . </p><br><p> ,   ,    .      -?        ? </p><br><h3 id="pochemu-nuzhen-novyy-potok">     </h3><br><p>  ,    .    ,          « »  .  ,      .      : </p><br><ul><li>       </li><li>   (async-signal-safe)  </li></ul><br><p>      —     . dlopen()  pthread_create()     .        -  dlopen(),      dlopen()  ? </p><br><p>        -, ,   ,       . ,     pthread_create()    .     ,       (     ).     clone(). </p><br><blockquote> <strong>  pthread_create()?</strong> <br><br>     ,  -     ,         ? <br><br> :          clone(). <br><br>          ,    (libc)    (pthread).   clone()       <em> </em> (thread control block, TCB)  <em> </em> (thread-local storage, TLS),        ,  . .     pthread_create()    ,    . <br><br>    «»,      clone()        libc  pthread.        ,    . </blockquote><br><h3 id="podgotovka-k-zapusku-potoka">     </h3><br><p>      clone()      : </p><br><ul><li>      ? </li><li>    ? </li><li>    -? </li></ul><br><h4 id="obrabotka-zaversheniya-potoka">    </h4><br><p>      :     -? </p><br><p>     ,  -       :   ,   ,       ,       . </p><br><p>        .  ,     ,        .  Comment?  :     exit().          ,     . </p><br><p>         .     exit()   -: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+.set __NR_exit, 60 .set RTLD_LAZY, 1 @@ - /* - *  . - */ - int $3 + /* + * exit(0); + */ + xor %rdi,%rdi + mov $__NR_exit,%rax + syscall</span></span></code> </pre> <br><p>  :   exit() —    exit()   .   exit()    <em></em> ,    exit()    — <em> </em>   .    Linux     exit_group(). </p><br><h4 id="vydelenie-pamyati-pod-stek">     </h4><br><p>     .         .     ,      ,   PROT_EXEC: </p><br><pre> <code class="cpp hljs">shellcode_stack_vaddr = remote_mmap(target, syscall_vaddr, <span class="hljs-number"><span class="hljs-number">0</span></span>, SHELLCODE_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK | MAP_GROWSDOWN, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>   ,   Linux  x86_64  <em> </em> —  «»  ,     .  mmap()      ,   clone()     .  ,    mmap()  MAP_GROWSDOWN,       ,    . </p><br><h4 id="opciya-ptrace_o_traceclone">  PTRACE_O_TRACECLONE </h4><br><p>        .       ,   -   .         waitpid(),     :      ,          . </p><br><p>        —   PTRACE_O_TRACECLONE.          .  ,       . ,      ,     ,    .      ,       PTRACE_ATTACH  ,    . </p><br><p> -,       : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- unsigned long options = PTRACE_O_TRACESYSGOOD; + unsigned long options = PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACECLONE; if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) return -1;</span></span></code> </pre> <br><p> -,         clone(),    PTRACE_EVENT_CLONE,     ,  PTRACE_SYSCALL.        : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-void wait_for_syscall_completion(pid_t pid) +void wait_for_syscall_completion(pid_t pid, long syscall) { wait_for_syscall_enter_exit_stop(pid); + + /*  clone()   PTRACE_EVENT_CLONE */ + if (syscall == __NR_clone) + wait_for_clone_event(pid); wait_for_syscall_enter_exit_stop(pid); }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_clone_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, event) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     clone()  PID  ,    .         : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_ptrace_options</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_SETOPTIONS, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>   ,   clone()    ptrace(),  PTRACE_O_TRACECLONE.     ,     ,  -     . </p><br><h3 id="zapusk-novogo-potoka">    </h3><br><p>      ,   - .       clone()   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_shell_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, <span class="hljs-comment"><span class="hljs-comment">/*   **  */</span></span> shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shell_tid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">clone()    </a> :    ,   ,     ,  .      ,  . </p><br><p> CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_VM —         . ,   CLONE_FILES    <em></em>   ,    (  fork()).      —    <em></em> —      ,        .       . , CLONE_VM   ,       ,    . </p><br><p>  CLONE_THREAD       <em></em> :    Linux —  «   »,     .  , ,  getpid()         , kill() —   -   , execve() —       ,   . </p><br><p>  ,  clone()   fork():        ,    .      clone()      :    ,  —   .        . ( , ,        .) </p><br><p>    ,  pthread_create()    ,      ,    .     ? </p><br><h3 id="peredacha-upravleniya">   </h3><br><p>    fork()  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* fork() ,    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     execve() */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span></code> </pre> <br><p>  ,     .  clone()                 .            . </p><br><p>      <a href="" rel="nofollow"> </a> . ,   clone()      ,    .      syscall   ret,       ,     .           . </p><br><h4 id="poisk-pary-instrukciy-syscall--ret">    SYSCALL + RET </h4><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> ,       .      ,     syscall   ret: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-if (region_size &lt; 2) +if (region_size &lt; 3) continue; /* * 0F 05 syscall + * C3 retq */ -for (size_t offset = 0; offset &lt; region_size - 1; offset++) { +for (size_t offset = 0; offset &lt; region_size - 2; offset++) { if (region_data[offset + 0] == 0x0F &amp;&amp; - region_data[offset + 1] == 0x05) + region_data[offset + 1] == 0x05 &amp;&amp; + region_data[offset + 2] == 0xC3) { return region-&gt;vaddr_low + offset; } }</span></span></code> </pre> <br><p>  ,       . </p><br><h4 id="podgotovka-steka">   </h4><br><p>     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> prepare_shellcode()</a> ,    ,          : </p><br><pre> <code class="diff hljs"> void write_shellcode(void) { char shellcode_text[SHELLCODE_TEXT_SIZE]; size_t shellcode_size = shellcode_end - shellcode_start; /*   ,  ,  . . */ prepare_shellcode(shellcode_text, shellcode_size); /*   -   */ write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); + /*    «»   */ + unsigned long retaddr_vaddr = + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8; + write_remote_memory(target, retaddr_vaddr, + &amp;shellcode_text_vaddr, sizeof(shellcode_text_vaddr)); }</code> </pre> <br><p>  ,      ,     . </p><br><p>  ,     ,   <em></em> . System V ABI ,   ( %rsp)     16    .  <code>shellcode_stack_vaddr + SHELLCODE_STACK_SIZE</code>  :       (  4096 ),     1 .  8 ,     ,      retq,      -    .   -   : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- sub $8,%rsp + sub $16,%rsp /*   */ mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax</span></span></code> </pre> <br><p>     ,   %rsp    16       pthread_create().          SIGSEGV,     —     pthread_create()   ,       . </p><br><h4 id="zapusk-potoka">   </h4><br><p>        ,       - ,      clone(): </p><br><pre> <code class="diff hljs"> static int spawn_shell_thread() { shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, /*   **  */ - shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8); if (!shell_tid) return -1; return 0; }</code> </pre> <br><p>      ptrace()    SIGSTOP,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_thread_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait_for_process_stop(pid, SIGSTOP); }</code> </pre> <br><p>  C’est tout.               ptrace(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="zavershenie-potoka">   </h3><br><p>  ,    ,  ,    exit().        waitpid().     —  CLONE_THREAD   wait()  ,—    PTRACE_O_TRACECLONE,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEXITSTATUS(status); }</code> </pre> <br><p>    pthread ,   ,  pthread_join()      pthread       ,        . ,  —  .       ,   ,  . </p><br><h4 id="osvobozhdenie-pamyati">  Mémoire libre </h4><br><p>     ,  -   .     ,   -   ,      munmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_munmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ perform_syscall(pid, syscall_insn_vaddr, __NR_munmap, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) addr, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) len); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ remote_munmap(target, syscall_ret_vaddr, shellcode_text_vaddr, SHELLCODE_TEXT_SIZE); remote_munmap(target, syscall_ret_vaddr, shellcode_stack_vaddr, SHELLCODE_STACK_SIZE); }</code> </pre> <br><p> ,  ,     ,      —  ptrace()   .        (, SIGSTOP),    ,   <em> </em>    (    ): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kill(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="otklyuchenie-otladchika">   </h4><br><p> ,      ,    .     PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-pyatogo-shaga">    </h3><br><p>                   ,      .     ,         .   ,      . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      ?   . ,       ,      . </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="démonstration d'injection au Gnome Control Center"></p><br><p>    Linux    .     GTK+     .      ,       make: </p><br><pre> <code class="bash hljs">libpayload.so: payload.c $(CC) $(CFLAGS) $(shell pkg-config --cflags --libs gtk+-3.0) -shared -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre> <br><p>     entry()            GTK- —    GTK  UI      ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glib.h&gt; #include &lt;gtk/gtk.h&gt; static gboolean actual_entry(gpointer _arg) { /*       : */ hook_gtk_entry_constructor(); /*   FALSE,       */ return FALSE; } void entry(void) { /*    -,   */ g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, actual_entry, NULL, NULL); }</span></span></span></span></code> </pre> <br><p> ,   GTK   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GtkEntry</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> "input-purpose"</a>     .       «»,    ,      . </p><br><p> GTK   glib —     —      GtkEntry       .    constructed(),     .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*old_gtk_entry_constructed)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*    ,  ,   entry */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_gtk_entry_constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     GtkEntry */</span></span> GTypeClass *entry_type_class = g_type_class_peek(GTK_TYPE_ENTRY); GObjectClass *entry_object_class = G_OBJECT_CLASS(entry_type_class); <span class="hljs-comment"><span class="hljs-comment">/* *     "constructed"     . */</span></span> old_gtk_entry_constructed = entry_object_class-&gt;constructed; entry_object_class-&gt;constructed = new_gtk_entry_constructed; }</code> </pre> <br><p>   GtkEntry   : </p><br><ul><li>   ,  ,   </li><li>        </li></ul><br><p>  ,    GtkEntry  <em></em> ,   ,    .     ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"notify::input-purpose"</span></span>, G_CALLBACK(input_purpose_changed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-press"</span></span>, G_CALLBACK(icon_pressed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-release"</span></span>, G_CALLBACK(icon_released), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br><p>   .                ,         .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input_purpose_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry)</span></span></span><span class="hljs-function"> </span></span>{ GtkInputPurpose purpose = gtk_entry_get_input_purpose(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (purpose == GTK_INPUT_PURPOSE_PASSWORD) { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } }</code> </pre> <br><p>   : ,      ,   ,  -       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_pressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-add"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); }</code> </pre> <br><p>  C’est tout. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> GitHub</a>         (GPLv2). </p><br><p> ,       .   gdb         : </p><br><pre> <code class="plaintext hljs">$ gdb --pid $(pgrep target) \ --batch \ -ex 'compile file -raw shell-code.c'</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473740/">https://habr.com/ru/post/fr473740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473720/index.html">Deux façons de réaliser des tests unitaires fiables</a></li>
<li><a href="../fr473722/index.html">Isolement à distance, anxiété et dépression</a></li>
<li><a href="../fr473726/index.html">Il ne suffit pas de savoir ce que sont Mutex, Semaphore et async / wait. Vous devez tout savoir des quanta</a></li>
<li><a href="../fr473728/index.html">Mise en œuvre typique de la surveillance. Nikolay Sivko</a></li>
<li><a href="../fr473732/index.html">L'histoire de la fraude dans la construction d'un réseau câblé sous l'Arctique pour 1 milliard de dollars</a></li>
<li><a href="../fr473742/index.html">Imprimantes d'ingénierie Epson pour CAO et SIG et quelques mots sur la "conception robuste"</a></li>
<li><a href="../fr473748/index.html">Courbe de Bézier au service des économistes du travail</a></li>
<li><a href="../fr473750/index.html">Stereopi + WebRTC = téléprésence à domicile</a></li>
<li><a href="../fr473752/index.html">Quel est le problème avec la copie sur écriture pour Linux lors de la copie</a></li>
<li><a href="../fr473756/index.html">HTTPS DNS - Solution à moitié et incorrecte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>