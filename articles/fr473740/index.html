<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüîß üõÄüèø üêå CreateRemoteThread pour Linux üë®üèº‚Äçüè≠ üëçüèº üêµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WinAPI a une fonction CreateRemoteThread qui vous permet de d√©marrer un nouveau thread dans l'espace d'adressage d'un autre processus. Il peut √™tre ut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CreateRemoteThread pour Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473740/"><p><img src="https://habrastorage.org/webt/qu/fi/43/qufi43ym9g9-ptbmm43ajv-e_-4.jpeg" width="300" align="right" alt="Mitsuha apporte de nouveaux flux">  WinAPI a une fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">CreateRemoteThread</a> qui vous permet de d√©marrer un nouveau thread dans l'espace d'adressage d'un autre processus.  Il peut √™tre utilis√© pour une vari√©t√© d'injections de DLL, √† la fois √† des fins malveillantes (astuces dans les jeux, vol de mot de passe, etc.), et pour corriger un bug dans un programme en cours d'ex√©cution √† la vol√©e, ou ajouter des plugins √† des endroits o√π ils n'√©taient pas fournis. </p><br><p>  En g√©n√©ral, cette fonction a un utilitaire d'application douteux, il n'est donc pas surprenant que Linux ne dispose pas d'un analogue pr√™t √† l'emploi de CreateRemoteThread.  Cependant, je me demandais comment le mettre en ≈ìuvre.  L'√©tude du sujet s'est transform√©e en une bonne aventure. </p><br><p>  Je vais expliquer en d√©tail comment, √† l'aide de la sp√©cification ELF, une certaine connaissance de l'architecture x86_64 et des appels syst√®me Linux, √©crire votre propre petit d√©bogueur qui peut charger et ex√©cuter du code arbitraire dans un processus d√©j√† en cours d'ex√©cution et de travail. </p><br><p>  La compr√©hension du texte n√©cessitera des connaissances de base sur la programmation syst√®me pour Linux: le langage C, les programmes d'√©criture et de d√©bogage dessus, une compr√©hension du r√¥le du code machine et de la m√©moire dans l'ordinateur, le concept des appels syst√®me, la familiarit√© avec les principales biblioth√®ques et la lecture de la documentation. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Id√©es principales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Esquisse de solution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtape 1. Connexion au processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtape 2. Rechercher des biblioth√®ques en m√©moire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtape 3. Analyse des images de la biblioth√®que ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtape 4. Impl√©mentation du shellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtape 5. D√©marrage d'un nouveau thread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><p>  En cons√©quence, j'ai pu ¬´ajouter¬ª la possibilit√© de pr√©visualiser les mots de passe dans le centre de contr√¥le Gnome: </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="d√©monstration d'injection au Gnome Control Center"></p><br><h2 id="osnovnye-idei">  Id√©es principales </h2><br><p>  S'il n'y avait aucune clause dans les exigences relatives au chargement de code dans un processus d√©j√† en cours d'ex√©cution, la solution serait extr√™mement simple: LD_PRELOAD.  Cette variable d'environnement permet de charger une biblioth√®que arbitraire avec l'application.  Dans les biblioth√®ques partag√©es, vous pouvez d√©finir <em>des fonctions constructeur</em> qui s'ex√©cutent lors du chargement de la biblioth√®que. </p><br><p>  Ensemble, LD_PRELOAD et les constructeurs permettent l'ex√©cution de code arbitraire dans n'importe quel processus utilisant un chargeur dynamique.  Il s'agit d'une fonctionnalit√© relativement bien connue souvent utilis√©e pour le d√©bogage.  Par exemple, avec l'application, vous pouvez charger votre propre biblioth√®que, qui d√©finit les fonctions malloc () et free (), ce qui pourrait aider √† d√©tecter les fuites de m√©moire. </p><br><p>  Malheureusement, LD_PRELOAD ne fonctionne qu'au d√©marrage du processus.  Il ne peut pas √™tre utilis√© pour charger une biblioth√®que dans un processus d√©j√† en cours d'ex√©cution.  Il existe une fonction dlopen () pour charger les biblioth√®ques pendant le processus, mais, √©videmment, le processus lui-m√™me doit l'appeler pour charger les plugins. </p><br><blockquote> <strong>√Ä propos des ex√©cutables statiques</strong> <br><br>  LD_PRELOAD ne fonctionne qu'avec les programmes qui utilisent le chargeur dynamique.  Si le programme a √©t√© construit avec le commutateur <code>-static</code> , il inclut toutes les biblioth√®ques n√©cessaires.  Dans ce cas, la r√©solution des d√©pendances dans les biblioth√®ques est effectu√©e au moment de la g√©n√©ration et le programme n'est g√©n√©ralement pas pr√™t et n'est pas en mesure de charger dynamiquement les biblioth√®ques apr√®s l'assemblage, au moment de l'ex√©cution. <br><br>  Dans les programmes assembl√©s statiquement, vous pouvez incorporer du code au moment de l'ex√©cution, mais cela doit √™tre fait d'une mani√®re l√©g√®rement diff√©rente.  Et ce n'est pas enti√®rement s√ªr, car le programme n'est peut-√™tre pas pr√™t pour un tel virage. </blockquote><p>  En g√©n√©ral, il n'y a pas de solution pratique pr√™te √† l'emploi, vous devez √©crire votre v√©lo.  Sinon, vous ne liriez pas ce texte :) </p><br><p>  Conceptuellement, pour forcer le processus de quelqu'un d'autre √† ex√©cuter une sorte de code, vous devez effectuer les actions suivantes: </p><br><ol><li>  Prenez le contr√¥le du processus cible. </li><li>  Chargez le code dans la m√©moire du processus cible. </li><li>  Pr√©parez le code t√©l√©charg√© pour l'ex√©cution dans le processus cible. </li><li>  Organisez l'ex√©cution du code t√©l√©charg√© par le processus cible. </li></ol><br><p>  Allons-y ... </p><br><h3 id="poluchenie-upravleniya-v-processe">  Prendre le contr√¥le du processus </h3><br><p>  Tout d'abord, nous devons subordonner le processus cible √† notre volont√©.  Apr√®s tout, les processus ex√©cutent g√©n√©ralement uniquement leur propre code, ou le code des biblioth√®ques charg√©es, ou les r√©sultats de la compilation JIT.  Mais certainement pas notre code. </p><br><p>  Une option consiste √† utiliser une sorte de vuln√©rabilit√© dans le processus qui vous permet de prendre le contr√¥le.  Un exemple classique des tutoriels: buffer overflow, permettant de r√©√©crire l'adresse de retour sur la pile.  C'est amusant, √ßa marche parfois m√™me, mais pas adapt√© au cas g√©n√©ral. </p><br><p>  Nous utiliserons une autre fa√ßon honn√™te de prendre le contr√¥le: le <em>d√©bogage des appels syst√®me</em> .  Les d√©bogueurs interactifs peuvent parfaitement arr√™ter les processus tiers, √©valuer les expressions et bien d'autres choses.  Ils peuvent - nous pouvons. </p><br><p>  Sous Linux, l'appel syst√®me de d√©bogage principal est <strong>ptrace ()</strong> .  Il vous permet de vous connecter aux processus, d'examiner leur statut et de contr√¥ler la progression de leur ex√©cution.  ptrace () est assez bien document√© seul, mais les d√©tails de son utilisation ne sont clairs qu'en pratique. </p><br><h3 id="zagruzka-koda-v-pamyat-processa">  Chargement de code dans la m√©moire de processus </h3><br><p>  Dans le cas de d√©bordements de tampon, la charge utile ( <em>code shell</em> ) est g√©n√©ralement incluse dans le contenu qui d√©borde du m√™me tampon.  Lorsque vous utilisez le d√©bogueur, le code n√©cessaire peut √™tre √©crit directement dans la m√©moire de processus.  Dans WinAPI, il existe une fonction sp√©ciale WriteProcessMemory pour cela.  Linux √† cet effet est conforme √† la m√©thode UNIX: pour chaque processus du syst√®me, il existe un fichier <strong>/ proc / $ pid / mem</strong> , qui affiche la m√©moire de ce processus.  Il est possible d'√©crire quelque chose dans la m√©moire de processus en utilisant l'entr√©e-sortie habituelle. </p><br><h3 id="podgotovka-koda-k-ispolneniyu">  Pr√©paration du code pour l'ex√©cution </h3><br><p>  Il ne suffit pas d'√©crire du code en m√©moire.  Il doit encore √™tre √©crit <em>dans la m√©moire ex√©cutable</em> .  Dans le cas de l'enregistrement via une vuln√©rabilit√©, cela pr√©sente des difficult√©s non triviales, mais comme nous pouvons contr√¥ler compl√®tement le processus cible, il ne nous sera pas difficile de trouver ou d'allouer la m√©moire ¬´correcte¬ª pour nous-m√™mes. </p><br><p>  Un autre point important de pr√©paration est le code shell lui-m√™me.  Dans ce document, nous voudrons probablement utiliser certaines fonctions des biblioth√®ques, telles que les entr√©es-sorties, les primitives graphiques, etc.  Cependant, nous devons √©crire du code machine nu, qui en soi n'a aucune id√©e des adresses de toutes ces fonctions int√©ressantes dans les biblioth√®ques.  D'o√π les obtenez-vous? </p><br><p>  Pour simplifier la vie du syst√®me d'exploitation et compliquer la vie du code malveillant, les biblioth√®ques n'utilisent g√©n√©ralement pas d'adresses fixes (et contiennent <em>un code dit ind√©pendant de la position</em> ).  Les adresses ne peuvent donc pas √™tre devin√©es. </p><br><p>  Lorsque le processus d√©marre normalement, le <em>chargeur</em> qui effectue les <em>relocalisations</em> est charg√© de d√©terminer les adresses exactes des biblioth√®ques.  Cependant, il ne remplit qu'une seule fois au d√©part.  Si le processus autorise le chargement dynamique des biblioth√®ques, il <em>contient</em> un <em>chargeur dynamique</em> qui peut faire de m√™me pendant l'ex√©cution du processus.  Cependant, l'adresse du chargeur dynamique n'est pas non plus fixe. </p><br><p>  En g√©n√©ral, avec les biblioth√®ques, il y a quatre options: </p><br><ul><li>  n'utilisez pas du tout les biblioth√®ques, faites tout sur les appels syst√®me propres </li><li>  mettre des copies de toutes les biblioth√®ques n√©cessaires dans le code shell </li><li>  faites vous-m√™me le travail du chargeur dynamique </li><li>  trouver un chargeur de d√©marrage dynamique et le faire charger nos biblioth√®ques </li></ul><br><p>  Nous choisirons ce dernier, car nous voulons les biblioth√®ques, et √©crire notre chargeur de d√©marrage complet depuis longtemps.  Ce n'est pas la m√©thode la plus secr√®te, et non la plus int√©ressante, mais la plus simple, puissante et fiable. </p><br><h3 id="peredacha-upravleniya-kodu">  Transfert de contr√¥le au code </h3><br><p>  ptrace () vous permet de changer les registres du processeur, donc il ne devrait y avoir aucun probl√®me avec le transfert du contr√¥le vers le code charg√© et pr√©par√©: √©crivez simplement l'adresse de notre code dans le registre% rip - et le tour est jou√©!  Cependant, en r√©alit√©, tout n'est pas si simple.  Les difficult√©s sont li√©es au fait que le processus d√©bogu√© n'a en fait pas disparu et qu'il a √©galement une sorte de code qui a √©t√© ex√©cut√© et continuera √† √™tre ex√©cut√©. </p><br><h2 id="eskiz-resheniya">  Esquisse de solution </h2><br><p>  Total, nous mettrons en ≈ìuvre notre flux dans un processus tiers comme suit: </p><br><ol><li>  Nous sommes connect√©s au processus cible de d√©bogage. </li><li>  On retrouve les biblioth√®ques n√©cessaires en m√©moire: <br><ul><li>  libdl - pour charger une nouvelle biblioth√®que </li><li>  libpthread - pour d√©marrer un nouveau thread </li></ul></li><li>  On trouve les fonctions n√©cessaires dans les biblioth√®ques: <br><ul><li>  libdl: dlopen (), dlsym () </li><li>  libpthread: pthread_create (), pthread_detach () </li></ul></li><li><p>  Nous introduisons le code shell dans la m√©moire du processus cible: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br></li><li>  Nous donnons le code shell √† remplir. </li></ol><br><p>  En cons√©quence, les biblioth√®ques feront la bonne chose pour nous: elles chargeront notre biblioth√®que avec le code dont nous avons besoin en m√©moire et d√©marreront un nouveau thread ex√©cutant ce code. </p><br><h3 id="ogranicheniya">  Limitations </h3><br><p>  L'approche d√©crite ci-dessus impose certaines limites: </p><br><ul><li>  Le chargeur de d√©marrage doit disposer de privil√®ges suffisants pour d√©boguer le processus cible. </li><li>  Le processus doit utiliser libdl (pr√™t pour le chargement dynamique des modules). </li><li>  Le processus doit utiliser libpthread (pr√™t pour le multithreading). </li><li>  Les applications statiques ne sont pas prises en charge. </li></ul><br><p>  De plus, personnellement, je suis trop paresseux pour me soucier du support des architectures tout-en-un, nous nous limiterons donc √† x86_64.  (M√™me un x86 32 bits serait plus compliqu√©.) </p><br><p>  Comme vous pouvez le voir, tout cela met fin √† une utilisation secr√®te avec des cibles malveillantes.  Cependant, la t√¢che conserve toujours un int√©r√™t pour la recherche et laisse m√™me une faible opportunit√© pour une utilisation industrielle. </p><br><h3 id="otstuplenie-ob-ispolzovanii-libdl-i-libpthread">  Digression: √† propos de l'utilisation de libdl et libpthread </h3><br><p>  Un lecteur-lecteur exp√©riment√© peut se demander: pourquoi avoir besoin de libdl si les fonctions internes __libc_dlopen_mode () et __libc_dlsym () sont d√©j√† int√©gr√©es dans glibc, et libdl n'est qu'un wrapper sur elles?  De m√™me, pourquoi exiger libpthread si un nouveau thread peut √™tre facilement cr√©√© en utilisant l'appel syst√®me clone ()? </p><br><p>  En effet, sur Internet, il y a loin d'un exemple de leur utilisation: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/gaffe23/linux-inject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/TsarFox/hypodermic</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://hick.org/code/skape/papers/needle.txt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/ice799/injectso64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://www.ouah.org/subversiveld.pdf</a> </li></ul><br><p>  Ils sont m√™me mentionn√©s dans la litt√©rature populaire des hackers: </p><br><ul><li>  Apprendre l'analyse binaire Linux </li><li>  L'art de la m√©decine l√©gale </li></ul><br><p>  Alors pourquoi pas?  Eh bien, au moins parce que nous n'√©crivons pas de code malveillant o√π une solution appropri√©e qui omet 90% des v√©rifications, prend 20 fois moins d'espace, mais fonctionne √©galement dans 80% des cas.  De plus, je voulais tout essayer de mes propres mains. </p><br><p>  En effet, libdl n'est pas <em>n√©cessaire</em> pour charger la biblioth√®que dans le cas de glibc.  Son utilisation par le processus indique qu'il est clairement pr√™t pour le chargement de code dynamique.  Malgr√© cela, en principe, vous pouvez refuser d'utiliser libdl (√©tant donn√© que nous devrons √©galement rechercher la glibc plus tard √©galement). </p><br><blockquote>  <strong>Pourquoi dlopen () √† l'int√©rieur de la glibc?</strong> <br><br>  C'est une question int√©ressante √† sa mani√®re.  R√©ponse courte: d√©tails de mise en ≈ìuvre. <br><br>  Le point est le <em>commutateur de service de noms</em> (NSS) - l'une des parties de la glibc qui fournit la traduction de divers noms: noms de machines, protocoles, utilisateurs, serveurs de messagerie, etc. C'est elle qui est responsable de fonctions telles que getaddrinfo () pour obtenir des adresses IP en nom de domaine et getpwuid () pour obtenir des informations sur l'utilisateur par son identifiant num√©rique. <br><br>  NSS a une architecture modulaire et les modules se chargent dynamiquement.  En fait, pour cela, la glibc avait √©galement besoin de m√©canismes de chargement dynamique des biblioth√®ques.  C'est pourquoi lorsque vous essayez d'utiliser getaddrinfo () dans une application assembl√©e statiquement, l'√©diteur de liens affiche un avertissement ¬´incompr√©hensible¬ª: <br><pre>
 /tmp/build/socket.o: Dans la fonction `Socket :: bind ':
 socket.o :(. text + 0x374): avertissement: utilisation de 'getaddrinfo' dans un lien statique
 les applications n√©cessitent au moment de l'ex√©cution les biblioth√®ques partag√©es de la version glibc
 utilis√© pour la liaison
</pre><br></blockquote><p>  En ce qui concerne les threads, un thread n'est g√©n√©ralement pas seulement une pile et un code ex√©cutable, mais √©galement des donn√©es globales stock√©es dans <em>un stockage local de threads</em> (TLS).  L'initialisation correcte d'un nouveau thread n√©cessite le fonctionnement coordonn√© du noyau du syst√®me d'exploitation, un chargeur de code binaire et un runtime de langage de programmation.  Par cons√©quent, un simple appel √† clone () suffit pour cr√©er un flux qui peut √©crire dans le fichier "Hello world!", Mais cela peut ne pas fonctionner pour un code plus complexe qui a besoin d'acc√©der √† TLS et √† d'autres choses int√©ressantes cach√©es aux yeux du programmeur d'application. </p><br><p>  Un autre point li√© au multithreading concerne les processus √† un seul thread.  Que se passe-t-il si nous cr√©ons un nouveau thread dans un processus qui n'a pas √©t√© con√ßu comme multithread?  Bon comportement vague.  En effet, dans le processus, il n'y a pas de synchronisation du travail entre les threads, ce qui entra√Ænera t√¥t ou tard une corruption des donn√©es.  Si nous exigeons que l'application utilise libpthread, alors nous pouvons √™tre s√ªrs qu'elle est pr√™te √† fonctionner dans un environnement multithread (au moins elle devrait √™tre pr√™te). </p><br><h2 id="shag-1-podklyuchenie-k-processu">  √âtape 1. Connexion au processus </h2><br><p>  Tout d'abord, nous devons nous connecter au processus cible pour le d√©bogage, puis le d√©connecter √† nouveau.  C'est l√† que l'appel syst√®me <em>ptrace</em> () entre en jeu. </p><br><h3 id="pervyy-kontakt-s-ptrace">  Premier contact avec ptrace () </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Dans la documentation de ptrace (),</a> vous pouvez trouver presque toutes les informations n√©cessaires: </p><br><pre>   Fixation et d√©tachement
        Un fil peut √™tre attach√© au traceur √† l'aide de l'appel<font></font>
<font></font>
            ptrace (PTRACE_ATTACH, pid, 0, 0);<font></font>
<font></font>
        ou<font></font>
<font></font>
            ptrace (PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<font></font>
<font></font>
        PTRACE_ATTACH envoie SIGSTOP √† ce fil.  Si le traceur le veut
        SIGSTOP n'a aucun effet, il doit le supprimer.  Notez que si
        d'autres signaux sont envoy√©s simultan√©ment √† ce fil pendant l'attachement, le
        le traceur peut voir le trac√© entrer dans le signal-livraison-stop avec d'autres signaux
        nal (s) en premier!  La pratique habituelle consiste √† r√©injecter ces signaux jusqu'√†
        SIGSTOP s'affiche, puis supprimer l'injection de SIGSTOP.  Le bug de conception
        voici qu'un attach ptrace et un SIGSTOP livr√© simultan√©ment peuvent
        course et le SIGSTOP simultan√© peuvent √™tre perdus.
</pre><br><p>  La premi√®re √©tape consiste donc √† utiliser PTRACE_ATTACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_ATTACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Apr√®s ptrace (), le processus cible n'est pas tout √† fait pr√™t pour le d√©bogage.  Nous y sommes connect√©s, mais pour une √©tude interactive de l'√©tat du processus, il faut l'arr√™ter.  ptrace () envoie un signal SIGSTOP au processus, mais nous devons encore attendre que le processus s'arr√™te r√©ellement. </p><br><p>  Pour attendre, utilisez l'appel syst√®me <em>waitpid</em> ().  Dans le m√™me temps, plusieurs cas limites int√©ressants m√©ritent d'√™tre not√©s.  Premi√®rement, le processus peut simplement se terminer ou mourir sans avoir re√ßu SIGSTOP.  Dans ce cas, nous ne pouvons rien faire.  Deuxi√®mement, un autre signal peut √™tre pr√©alablement envoy√© au processus.  Dans ce cas, nous devons laisser le processus le traiter (en utilisant PTRACE_CONT), et nous-m√™mes, continuer d'attendre plus longtemps notre SIGSTOP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSIGNALED(status) || WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status)) { <span class="hljs-comment"><span class="hljs-comment">/* *  WSTOPSIG()   , *   ptrace()   *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stop_signal = status &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop_signal == expected_signal) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, stop_signal) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="otklyuchenie-ot-processa">  D√©connexion du processus </h3><br><p>  Arr√™ter le processus de d√©bogage est beaucoup plus simple: utilisez simplement PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  √Ä proprement parler, la d√©sactivation explicite du d√©bogueur n'est pas toujours n√©cessaire.  Lorsque le processus de d√©bogage se termine, il se d√©connecte automatiquement de tous les processus d√©bogu√©s et les processus reprennent s'ils ont √©t√© arr√™t√©s par ptrace ().  Cependant, si le processus d√©bogu√© a √©t√© explicitement arr√™t√© par le d√©bogueur √† l'aide du signal SIGSTOP sans utiliser ptrace (), il ne se r√©veillera pas sans le signal SIGCONT ou PTRACE_DETACH correspondant.  Par cons√©quent, il est pr√©f√©rable de se d√©connecter culturellement des processus. </p><br><h3 id="nastroyka-ptrace_scope">  Param√®tre Ptrace_scope </h3><br><p>  Le d√©bogueur a un contr√¥le total sur le processus en cours de d√©bogage.  Si quelqu'un pouvait d√©boguer quoi que ce soit, quelle serait l'√©tendue du code malveillant!  Il est √©vident que le d√©bogage interactif est une activit√© assez sp√©cifique, g√©n√©ralement n√©cessaire uniquement aux d√©veloppeurs.  Pendant le fonctionnement normal du syst√®me, le plus souvent, il n'est pas n√©cessaire de d√©boguer les processus. </p><br><p>  Pour ces raisons, pour des raisons de s√©curit√©, les syst√®mes d√©sactivent g√©n√©ralement la possibilit√© de d√©boguer les processus par d√©faut.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">module de s√©curit√© <strong>Yama en</strong></a> est responsable, g√©r√© via le fichier / proc / sys / kernel / yama / ptrace_scope.  Il propose quatre comportements: </p><br><ul><li>  0 - l'utilisateur peut d√©boguer tous les processus qu'il a d√©marr√©s </li><li>  1 - mode par d√©faut, seuls les processus d√©marr√©s par le d√©bogueur peuvent √™tre d√©bogu√©s </li><li>  2 - seul un administrateur syst√®me racine peut d√©boguer les processus </li><li>  3 - le d√©bogage est interdit √† tout le monde, le mode ne s'√©teint qu'au red√©marrage du syst√®me </li></ul><br><p>  De toute √©vidence, pour nos besoins, il sera n√©cessaire de pouvoir d√©boguer les processus lanc√©s avant notre d√©bogueur, donc pour les exp√©riences, vous devrez soit basculer le syst√®me en mode d√©veloppement en √©crivant 0 dans un fichier ptrace_scope sp√©cial (qui n√©cessite des droits d'administrateur): </p><br><pre> <code class="plaintext hljs">$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'</code> </pre> <br><p>  ou ex√©cutez le d√©bogueur en tant qu'administrateur: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread ...</code> </pre> <br><h3 id="rezultaty-pervogo-shaga">  R√©sultats de la premi√®re √©tape </h3><br><p>  Par cons√©quent, dans la premi√®re √©tape, nous sommes en mesure de nous connecter au processus cible en tant que d√©bogueur et de nous en d√©connecter plus tard. </p><br><p>  Le processus cible sera arr√™t√© et nous pouvons nous assurer que le syst√®me d'exploitation nous voit vraiment comme un d√©bogueur: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread --target $(pgrep docker) $ cat /proc/$(pgrep docker)/status | head Name: docker State: t (tracing stop) &lt;---    Tgid: 31330 Ngid: 0 Pid: 31330 PPid: 1 TracerPid: 2789 &lt;--- PID   Uid: 0 0 0 0 Gid: 0 0 0 0 FDSize: 64 $ ps a | grep [2]789 2789 pts/5 S+ 0:00 ./inject-thread --target 31330</code> </pre> <br><h2 id="shag-2-poisk-bibliotek-v-pamyati">  √âtape 2. Rechercher des biblioth√®ques en m√©moire </h2><br><p>  L'√©tape suivante est plus simple: vous devez trouver dans la m√©moire du processus cible la biblioth√®que avec les fonctions dont nous avons besoin.  Mais il y a beaucoup de m√©moire, par o√π commencer et quoi exactement? </p><br><h3 id="fayl-procpidmaps">  Fichier / proc / $ pid / maps </h3><br><p>  Un fichier sp√©cial nous aidera avec cela, √† travers lequel le noyau indique quoi et o√π se trouve le processus en m√©moire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Comme vous le savez</a> , dans le r√©pertoire / proc de chaque processus, il y a un sous-r√©pertoire.  Et il y a un fichier qui d√©crit <em>la carte m√©moire du</em> processus: </p><br><pre> $ cat / proc / self / maps
 00400000-0040c000 r-xp 00000000 fe: 01 1044592 / bin / cat
 0060b000-0060c000 r - p 0000b000 fe: 01 1044592 / bin / cat
 0060c000-0060d000 rw-p 0000c000 fe: 01 1044592 / bin / cat
 013d5000-013f6000 rw-p 00000000 00:00 0 [tas]
 7f9920bd1000-7f9920d72000 r-xp 00000000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920d72000-7f9920f72000 --- p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f72000-7f9920f76000 r - p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f76000-7f9920f78000 rw-p 001a5000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7fc3f8381000-7fc3f8385000 rw-p 00000000 00:00 0
 7fc3f8385000-7fc3f83a6000 r-xp 00000000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f83ec000-7fc3f840e000 rw-p 00000000 00:00 0
 7fc3f840e000-7fc3f8597000 r - p 00000000 fe: 01 657286 / usr / lib / locale / locale-archive
 7fc3f8597000-7fc3f859a000 rw-p 00000000 00:00 0
 7fc3f85a3000-7fc3f85a5000 rw-p 00000000 00:00 0
 7fc3f85a5000-7fc3f85a6000 r - p 00020000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a6000-7fc3f85a7000 rw-p 00021000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a7000-7fc3f85a8000 rw-p 00000000 00:00 0
 7ffdb6f0e000-7ffdb6f2f000 rw-p 00000000 00:00 0 [pile]
 7ffdb6f7f000-7ffdb6f81000 r-xp 00000000 00:00 0 [vdso]
 7ffdb6f81000-7ffdb6f83000 r - p 00000000 00:00 0 [vvar]
 ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</pre><br><p>  Le contenu de ce fichier est g√©n√©r√© √† la vol√©e par le noyau du syst√®me d'exploitation √† partir de structures internes qui d√©crivent les r√©gions m√©moire du processus qui nous int√©resse et contient les informations suivantes: </p><br><ul><li>  plage d'adresses attribu√©e √† la r√©gion </li><li>  droits d'acc√®s √† la r√©gion <br><ul><li>  <code>r/-</code> : lire </li><li>  <code>w/-</code> : √©crire </li><li>  <code>x/-</code> : ex√©cution </li><li>  <code>p/s</code> : partage de m√©moire avec d'autres processus </li></ul></li><li>  d√©calage de fichier (le cas √©ch√©ant) </li><li>  code de l'appareil o√π se trouve le fichier affich√© </li><li>  num√©ro d'inode du fichier (le cas √©ch√©ant) </li><li>  chemin d'acc√®s au fichier affich√© (le cas √©ch√©ant) </li></ul><br><p>  Certaines r√©gions de la m√©moire sont mapp√©es sur des fichiers: lorsqu'un processus lit une telle m√©moire, il lit en fait les donn√©es des fichiers correspondants √† un d√©calage sp√©cifique.  Si vous pouvez √©crire dans une r√©gion, les modifications de la m√©moire peuvent √™tre visibles uniquement pour le processus lui <em>-</em> m√™me (m√©canisme de <em>copie sur √©criture</em> , le mode <code>p</code> est priv√©) ou synchronis√©es avec le disque ( <code>s</code> mode <code>s</code> est partag√©). </p><br><p>  Les autres r√©gions sont <em>anonymes</em> - cette m√©moire ne correspond √† aucun fichier.  Le syst√®me d'exploitation donne simplement au processus un morceau de m√©moire physique qu'il utilise.  De telles r√©gions sont utilis√©es, par exemple, pour la m√©moire de processus "normale": pile et tas.  Les r√©gions anonymes peuvent √™tre personnelles √† un processus ou partag√©es entre plusieurs processus (m√©canisme de <em>m√©moire partag√©e</em> ). </p><br><p>  De plus, il y a plusieurs r√©gions sp√©ciales dans la m√©moire marqu√©es des pseudo-noms [vdso] et [vsyscall].  Ils sont utilis√©s pour optimiser certains appels syst√®me. </p><br><p>  Nous sommes int√©ress√©s par les r√©gions o√π le contenu des fichiers de biblioth√®que est affich√©.  Si nous lisons la carte m√©moire et filtrons les entr√©es qu'elle contient par le nom du fichier affich√©, nous trouverons toutes les adresses occup√©es par les biblioth√®ques dont nous avons besoin.  Le format de la carte m√©moire est sp√©cialement adapt√© au traitement des programmes et se comprend facilement √† l'aide des fonctions de la famille scanf (): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_proc_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_low = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_high = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> execute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> path_offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    /proc/$pid/maps */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"%lx-%lx %c%c%c%*c %*lx %*x:%*x %*d %n"</span></span>, &amp;vaddr_low, &amp;vaddr_high, &amp;read, &amp;write, &amp;execute, &amp;path_offset); <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(line + path_offset, library)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region) { region-&gt;vaddr_low = vaddr_low; region-&gt;vaddr_high = vaddr_high; region-&gt;readable = (read == <span class="hljs-string"><span class="hljs-string">'r'</span></span>); region-&gt;writeable = (write == <span class="hljs-string"><span class="hljs-string">'w'</span></span>); region-&gt;executable = (execute == <span class="hljs-string"><span class="hljs-string">'x'</span></span>); region-&gt;content = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 id="tayna-tretey-planety">    </h3><br><p>      ,  libc-2.19.so,     : </p><br><p><img src="https://habrastorage.org/webt/vf/lw/4m/vflw4m5jy3pwtbcxu0foudxnh3o.png" alt="  libc-2.19.so"></p><br><p>        2   -    ?  51?   ?  ? </p><br><p> ,    ,          . </p><br><p>  ,     <em></em>   ,         .  <em> </em>         ,    ,   ,           (, ,        ). </p><br><p>      ,  <em></em> (  4  ).    ,            . </p><br><p>  ,           .       ‚Äî    ‚Äî      .           2    ‚Äî   ,        ( x86_64    4 , 2 , 1 ).                  . </p><br><h3 id="rezultaty-vtorogo-shaga">    </h3><br><p>     ,          : </p><br><ul><li>  libdl: dlopen()  dlsym() </li><li>  libpthread: pthread_create()  pthread_detach() </li></ul><br><p>    ,       ,   .      Linux       ( <em>address space layout randomization</em> , ASLR).        (- ,     ),             ‚Äî    - . </p><br><p>       ,           ,      ,     /proc/$pid/maps.     ,          . </p><br><h2 id="shag-3-razbor-elf-obrazov-bibliotek">  3.  ELF-  </h2><br><p> ,      ,        ,   . </p><br><p>   : </p><br><pre> <code class="plaintext hljs">$ nm -D /lib/x86_64-linux-gnu/libdl-2.19.so | grep dlopen 0000000000001090 T dlopen</code> </pre> <br><p>  <em>nm</em>             .                . </p><br><p>   -  ,      nm     ,        .  ,      dlsym(). </p><br><h3 id="chtenie-pamyati-celevogo-processa">     </h3><br><p>   ‚Äî    ELF-,    .        procfs.    UNIX way,         <strong>/proc/$pid/mem</strong> ,    ‚Äî      (     /proc/$pid/maps). </p><br><p>   Linux           mmap(),         (    ,   ).            : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> offset = region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buffer) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_close_file; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_region(fd, offset, buffer, length) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_free_buffer; region-&gt;content = buffer; close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_free_buffer: <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); error_close_file: close(fd); error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, offset, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> remaining = length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = buffer; <span class="hljs-comment"><span class="hljs-comment">/* *     .   , *      ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remaining &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> count = read(fd, ptr, remaining); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; remaining -= count; ptr += count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>      ELF- .    , -,       ,  -,       . </p><br><h3 id="dvulikiy-elf">  ELF </h3><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">   ELF</a> ‚Äî         Linux.      ,    ,      . </p><br><p>      ELF   .    ELF    <em></em>    .    ‚Äî   <em></em> ,        .      ,  ‚Äî    .        ELF-. </p><br><p> ,   libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/at/zw/up/atzwupwipysw3kip1yx95aa-eps.png" alt="   libdl-2.19.so"></p><br><p> (          <code>readelf --headers</code> .) </p><br><p>   ,    ,   (29  9).    ‚Äî    ,           ,     .  ELF ‚Äî    ,      .  Linux, ,    LOAD,      (     ). </p><br><p>   ELF-     ,         . ,       . </p><br><p>       ,   . ¬´¬ª    .     .bss,   ,      (    ). </p><br><p>  ,   ELF     ‚Äî  ,     .       ... </p><br><h3 id="gde-lezhit-tablica-simvolov">    ? </h3><br><p>          ()   .        ,     dlsym(),       .  -   . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> ELF</a> (. 2-10).   ,        <strong>.dynamic</strong> ,     <strong>DYNAMIC</strong> .   .dynamic     ,  : </p><br><ul><li> <strong>.dynsym</strong> ‚Äî     ; </li><li> <strong>.dynstr</strong> ‚Äî     ; </li><li> <strong>.hash</strong> ‚Äî -,   . </li></ul><br><p>    ,     ,       ELF: </p><br><p><img src="https://habrastorage.org/webt/yw/y9/7d/ywy97dqzszhxz1jmoe45851oebe.png" alt="Recherche de segment DYNAMIQUE"></p><br><p>     ELF,      (1),      (2),      (3),      (4) <del>  ,    </del>  . </p><br><h4 id="zagolovok-elf--tablica-segmentov">  ELF ‚Üí   </h4><br><p> ()   ELF      &lt;elf.h&gt;, ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> </a> .   ,  ELF ‚Äî      .    32-  64- ,      ,      ,   .          x86_64,    ELF  . </p><br><p>  ELF-    ( <strong>Elf64_Ehdr</strong> ).          ( <em>program headers</em> ),    <strong>e_phoff</strong>  <strong>e_phnum</strong> : </p><br><p><img src="https://habrastorage.org/webt/1z/al/rn/1zalrn30vwfxce_smmy4vylj55g.png" alt="En-t√™te ELF"></p><br><p>   ‚Äî    ,   ,  ELF-   ‚Äî     ,    ,     ,  ,    . </p><br><p>        e_phoff,       ,      .    e_phnum   e_phentsize  . </p><br><p>    (   ),        ELF ‚Äî    64 . </p><br><h4 id="tablica-segmentov--segment-dynamic">   ‚Üí  DYNAMIC </h4><br><p>      .   ‚Äî      <strong>Elf64_Phdr</strong> ( 64- ELF-),   .      <strong>PT_DYNAMIC</strong>   <strong>p_type</strong> : </p><br><p><img src="https://habrastorage.org/webt/i0/rg/cp/i0rgcpji9bl9wbsvegzrree9zfm.png" alt="Table des segments ELF"></p><br><p>          : </p><br><ul><li> <strong>p_vaddr</strong> ‚Äî   ,    ; </li><li> <strong>p_memsz</strong> ‚Äî      . </li></ul><br><p>     .dynamic      0x2D88 (     ).        DYNAMIC     ‚Äî   0x202D88.    0x210 (8448) .                . </p><br><h4 id="segment-dynamic--sekcii-dynsym-dynstr-hash">  DYNAMIC ‚Üí  .dynsym, .dynstr, .hash </h4><br><p>  .dynamic,    DYNAMIC,      .       <strong>Elf64_Dyn</strong> ,   : </p><br><p><img src="https://habrastorage.org/webt/dd/jp/th/ddjpthosvl8irw8ekelw0bdkaug.png" alt="Balises de section DYNAMIC"></p><br><p>    8     <strong>d_val</strong>  <strong>d_ptr</strong> ,   8-  <strong>d_tag</strong> ,  ,    .      : </p><br><ul><li> <strong>DT_HASH</strong> (4) ‚Äî    .hash ( d_ptr) </li><li> <strong>DT_STRTAB</strong> (5) ‚Äî    .dynstr ( d_ptr) </li><li> <strong>DT_SYMTAB</strong> (6) ‚Äî    .dynsym ( d_ptr) </li><li> <strong>DT_STRSZ</strong> (10) ‚Äî     .dynstr ( d_val) </li><li> <strong>DT_NULL</strong> (0) ‚Äî     </li></ul><br><p>       .     .dynamic     :  ,   ,    ,    . </p><br><p>    ,   DYNAMIC   <em></em>          ,    .      ,            ,  - ,   . </p><br><p>    .dynamic         ,          . -,   .dynstr   ,      ?     . </p><br><h3 id="poisk-funkciy-v-biblioteke">     </h3><br><p>            .     ,    <strong>.dynsym</strong>   ,        . (  ¬´¬ª   .symtab,      , ,  .    .) </p><br><h4 id="tablica-simvolov">   </h4><br><p>      <strong>Elf64_Sym</strong> ,        ELF ‚Äî , , , .       <code>dlopen</code> : </p><br><p><img src="https://habrastorage.org/webt/pd/5_/qh/pd5_qhcculmqmjk7p6krar1czjy.png" alt="Table de caract√®res ELF"></p><br><p>      : </p><br><ul><li> <strong>st_name</strong> ‚Äî  ,       </li><li> <strong>st_info</strong> ‚Äî     (   ) </li><li> <strong>st_value</strong> ‚Äî     </li></ul><br><p> (  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  nm</a>   ,  dlopen()     .text,   0x1090   .) </p><br><p>     ,       . </p><br><h4 id="tablica-strok">   </h4><br><p>   ‚Äî     - ,    .            (   ).        <strong>.dynstr</strong> ,      libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/mg/b9/1v/mgb91vjtwrr_kqrncnrojgg6jum.png" alt="Table de rang ELF"></p><br><p> ,           ( ¬´dlopen¬ª,   0xA5)      ,    .        . </p><br><h4 id="hesh-tablica"> - </h4><br><p>  <strong>.hash</strong>  <em>-</em> ,       .   - ‚Äî    ‚Äî      ELF-,       . ,         .dynsym,       ,      .   ( )     - . </p><br><p>  -      &lt;elf.h&gt;,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> </a> (. 2-19).   -   ,   : </p><br><p><img src="https://habrastorage.org/webt/ez/a3/ku/eza3ku71zydhqm_e3je0xbtjec8.png" alt="table de hachage ELF"></p><br><p>  o√π </p><br><ul><li> nbuckets ‚Äî    buckets </li><li> nchains ‚Äî    chains (  ) </li><li> buckets ‚Äî      </li><li> chains ‚Äî      </li></ul><br><p>  -  : </p><br><ol><li>   <strong>h</strong>    . </li><li>   <strong>i</strong>  <code>buckets[h % nbuckets]</code> ,     . </li><li>      (     )  ,   . </li><li>    ‚Äî  <code>chains[i % nchains]</code> . </li><li>   3‚Äî4           ,       . </li></ol><br><p>  -,  ELF: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*name) { h = (h &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + *name++; g = h &amp; <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g) h ^= g &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; h &amp;= ~g; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br><p> ,   <code>"dlopen"</code> -   112420542     : </p><br><p><img src="https://habrastorage.org/webt/zu/ch/4i/zuch4ibwuspxmog6_erhbq1evyg.png" alt="rechercher un personnage dans une biblioth√®que"></p><br><p> libdl ‚Äî    ,    39   ,      .  -           . </p><br><h3 id="rezultaty-tretego-shaga">    </h3><br><p>              ,          : </p><br><ul><li> dlopen()  dlsym()   libdl </li><li> pthread_create()  pthread_detach()   libpthread </li></ul><br><p>   ,    . </p><br><p>         .            .      ,       . </p><br><p>     ELF-    .       ,      (  ).        ,    . ,    ,     .               . </p><br><h2 id="shag-4-vnedrenie-shell-koda">  4.  - </h2><br><p>   ,    ,    <em>-</em> ,     :         ,   .   -  . </p><br><h3 id="soderzhimoe-shell-koda">  - </h3><br><p> ,   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*entry)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br><p>       ? </p><br><p> ,        ‚Äî   .    ,     ,      ,       -  ‚Äî  -     !    . </p><br><p>    ‚Äî   -  .         ,    ,           :        . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      .rodata:   * .         , *        . */</span></span> .section .rodata <span class="hljs-comment"><span class="hljs-comment">/* *   .       . *      -:    ,  *  ,       . */</span></span> .global shellcode_start .global shellcode_address_dlopen .global shellcode_address_dlsym .global shellcode_address_pthread_create .global shellcode_address_pthread_detach .global shellcode_address_payload .global shellcode_address_entry .global shellcode_end <span class="hljs-comment"><span class="hljs-comment">/* *   dlopen().     #include &lt;dlfcn.h&gt;, *       . */</span></span> .set RTLD_LAZY, <span class="hljs-number"><span class="hljs-number">1</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_start: <span class="hljs-comment"><span class="hljs-comment">/* * void *payload = dlopen(shellcode_address_payload, RTLD_LAZY); * *        x86_64: * * -     %rdi, %rsi, %rdx, %rcx * -     %rax * -      * *         . * *       %rax,    *     . */</span></span> lea shellcode_address_payload(%rip),%rdi mov $RTLD_LAZY,%rsi mov shellcode_address_dlopen(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * void (*entry)(void) = dlsym(payload, shellcode_address_entry); */</span></span> mov %rax,%rdi lea shellcode_address_entry(%rip),%rsi mov shellcode_address_dlsym(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_t thread; * pthread_create(&amp;thread, NULL, entry, NULL); * *            * ,     pthread_create(). */</span></span> sub $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_detach(thread); * *    ,   ,  *     . */</span></span> mov (%rsp),%rdi add $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov shellcode_address_pthread_detach(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* *   - ‚Äî    ,     *      ret.    *     ,  *      . */</span></span> int $<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *       ,   *   ,    - *     .   ‚Äú  *  ‚Äù (global offset table, GOT),   *           . */</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlopen: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlsym: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_create: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_detach: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_payload: .space <span class="hljs-number"><span class="hljs-number">256</span></span> shellcode_address_entry: .space <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *  - . */</span></span> shellcode_end: .end</code> </pre> <br><p> ,   .      : </p><br><pre> <code class="plaintext hljs">$ as -o shellcode.o shellcode.S</code> </pre> <br><p>  ,      ,  ,   .            :   <em>  </em> (procedure linkage table, PLT),        . </p><br><p>     -    ,         (, )       .  <em>-</em>  <em></em> . </p><br><h3 id="razmeschenie-shell-koda-v-pamyati">  -   </h3><br><p>     <em>-</em>    . ,       ,   ,          .      ? </p><br><h4 id="trebovaniya-k-pamyati-pod-shell-kod">     - </h4><br><p>      ,       .      <em></em> ,       .    ,         .         ,       . </p><br><p>              (-  ),         :   ,    ,    . , ,   JIT-   ,       .    ? </p><br><h4 id="podhody-k-razmescheniyu-v-pamyati">      </h4><br><p>         : </p><br><ul><li>  -  ,     </li><li>   - ,    </li></ul><br><p>      ,  . -,    - ,     . -,       . -,      ,  -    -,     . </p><br><p>   ,      .     .  x86_64  <code>int $3</code>     ‚Äî 0xCC ‚Äî          .  ptrace()         PTRACE_POKETEXT ‚Äî ,     8   , . ,          ,     . </p><br><p> ,  ,   ,       :        .     -       ,  . </p><br><h4 id="kak-vydelit-novuyu-pamyat">    ? </h4><br><p>  ,  !    malloc()! </p><br><p> .      ,      -,    .       .          ,     mmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shellcode_dst = mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); copy_shellcode(shellcode_dst, shellcode_src, shellcode_size); }</code> </pre> <br><p>  ,   ptrace()         ,     . </p><br><h3 id="vypolnenie-sistemnyh-vyzovov">    </h3><br><p>      ,     ?    ,            . Linux  x86_64   : </p><br><ul><li>       %rax </li><li>    ‚Äî    ‚Äî      %rsi, %rdi, %rdx, %r10, %r8, %r9 </li><li>   SYSCALL,     </li><li>       %rax </li></ul><br><p>  ptrace()           PTRACE_GETREGS  PTRACE_SETREGS.  ,        .   -   SYSCALL. </p><br><p>     :      ,       %rip.   ,   ,   SYSCALL. </p><br><h4 id="poisk-instrukcii-syscall">   SYSCALL </h4><br><p>    SYSCALL? ,    .   -   ,   <em>-</em>      .    ‚Äî   libc.  ,  ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_syscall_instruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct library *library)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; library-&gt;region_count; i++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory_region</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">library</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">regions</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(region-&gt;readable &amp;&amp; region-&gt;executable)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *region_data = region-&gt;content; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> region_size = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * 0F 05 syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; region_size - <span class="hljs-number"><span class="hljs-number">1</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_data[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x0F</span></span> &amp;&amp; region_data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> region-&gt;vaddr_low + offset; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  /proc/$pid/maps</a> .  x86_64     ,    -   .     <em></em>   ,    0x0F 0x05.     , ,  ARM,       0xDF 0x00 ( SVC #0),  <em>  </em> . </p><br><h4 id="ispolzovanie-ptrace_getsetregs">  PTRACE_{GET,SET}REGS </h4><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct user_regs_struct *registers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_GETREGS, pid, registers, registers) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) err = -errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br><p>     <code>struct user_regs_struct</code> ,    &lt;sys/user.h&gt;.     .          .     ,        <em>varargs</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_regs_for_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct user_regs_struct *registers, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, va_list args)</span></span></span><span class="hljs-function"> </span></span>{ registers-&gt;rip = syscall_insn_vaddr; registers-&gt;rax = syscall_number; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args_count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: registers-&gt;rdi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: registers-&gt;rsi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: registers-&gt;rdx = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: registers-&gt;r10 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: registers-&gt;r8 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: registers-&gt;r9 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -E2BIG; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,   *      . */</span></span> get_registers(pid, &amp;old_registers); <span class="hljs-comment"><span class="hljs-comment">/* *      ,   * ,     . */</span></span> new_registers = old_registers; va_list args; va_start(args, args_count); set_regs_for_syscall(&amp;new_registers, syscall_insn_vaddr, syscall_number, args_count, args); va_end(args); set_registers(pid, &amp;new_registers); <span class="hljs-comment"><span class="hljs-comment">/* *    ,    *   ,    * (  ),    . *     . */</span></span> wait_for_syscall_completion(pid); <span class="hljs-comment"><span class="hljs-comment">/* *       *    . *        . */</span></span> get_registers(pid, &amp;new_registers); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = new_registers.rax; set_registers(pid, &amp;old_registers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h4 id="ispolzovanie-ptrace_syscall">  PTRACE_SYSCALL </h4><br><p>       :        ,    ? </p><br><p>      PTRACE_SYSCALL.   PTRACE_CONT,     .   ,    - :    ,    . </p><br><p> PTRACE_SYSCALL    SIGTRAP    :      (     )       (      ).  , ptrace()   ,          ,         . </p><br><p>  ,           SIGTRAP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_enter_exit_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_SYSCALL, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGTRAP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_completion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ wait_for_syscall_enter_exit_stop(pid); wait_for_syscall_enter_exit_stop(pid); }</code> </pre> <br><p>   ‚Äî   ,    ‚Äî       (wait_for_process_stop() <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).           .       ,     . </p><br><h4 id="opciya-ptrace_o_tracesysgood">  PTRACE_O_TRACESYSGOOD </h4><br><p>   , PTRACE_SYSCALL      :       ,   ,  -  .  ,      SIGTRAP       (    ). </p><br><p>     SIGTRAP       <em></em> .        PTRACE_O_TRACESYSGOOD,            : </p><br><ul><li> SIGTRAP ‚Äî -     </li><li> SIGTRAP | 0x80 ‚Äî     </li></ul><br><pre> <code class="diff hljs"> int ptrace_attach(pid_t pid) { if (ptrace(PTRACE_ATTACH, pid, 0, 0) &lt; 0) return -1; if (wait_for_process_stop(pid, SIGSTOP) &lt; 0) return -1; + /*     */ + unsigned long options = PTRACE_O_TRACESYSGOOD; + if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) + return -1; return 0; } static int wait_for_syscall_enter_exit_stop(pid_t pid) { if (ptrace(PTRACE_SYSCALL, pid, 0, 0) &lt; 0) return -1; - if (wait_for_process_stop(pid, SIGTRAP) &lt; 0) + if (wait_for_process_stop(pid, SIGTRAP | 0x80) &lt; 0) return -1; return 0; }</code> </pre> <br><h3 id="zagruzka-shell-koda-v-pamyat">  -   </h3><br><p> -       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_text[SHELLCODE_TEXT_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shellcode_size = shellcode_end - shellcode_start; <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,  . . */</span></span> prepare_shellcode(shellcode_text, shellcode_size); <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); }</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   -</a>    :      dlopen(),               . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> offset = shellcode_addr - shellcode_start; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(shellcode_text + offset, data, length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ copy_shellcode(shellcode_text, shellcode_start, shellcode_start, shellcode_size); copy_shellcode(shellcode_text, shellcode_address_dlopen, &amp;dlopen_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlopen_vaddr)); copy_shellcode(shellcode_text, shellcode_address_dlsym, &amp;dlsym_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlsym_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_create, &amp;pthread_create_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_create_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_detach, &amp;pthread_detach_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_detach_vaddr)); copy_shellcode(shellcode_text, shellcode_address_payload, payload, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(payload)); copy_shellcode(shellcode_text, shellcode_address_entry, entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry)); }</code> </pre> <br><p>     ,    ,      -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlopen[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlsym[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_create[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_detach[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_payload[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_entry[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_end[];</code> </pre> <br><p>      ,              . </p><br><p>    -        .         /proc/$pid/mem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_WRONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, vaddr, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = do_write_remote_memory(fd, data, size); close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left = size; <span class="hljs-comment"><span class="hljs-comment">/* *    ,  ,     *   ,       *      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> wrote = write(fd, data, left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrote &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; data += wrote; left -= wrote; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-chetvyortogo-shaga">    </h3><br><p> ,             - ‚Äî ¬´ ¬ª .           .    - ,                . </p><br><h2 id="shag-5-zapusk-novogo-potoka">  5.    </h2><br><p>     -        .  ,    :    %rip  -,  PTRACE_SETREGS,  PTRACE_CONT    .     . </p><br><p> ,   ,    .      -?        ? </p><br><h3 id="pochemu-nuzhen-novyy-potok">     </h3><br><p>  ,    .    ,          ¬´ ¬ª  .  ,      .      : </p><br><ul><li>       </li><li>   (async-signal-safe)  </li></ul><br><p>      ‚Äî     . dlopen()  pthread_create()     .        -  dlopen(),      dlopen()  ? </p><br><p>        -, ,   ,       . ,     pthread_create()    .     ,       (     ).     clone(). </p><br><blockquote> <strong>  pthread_create()?</strong> <br><br>     ,  -     ,         ? <br><br> :          clone(). <br><br>          ,    (libc)    (pthread).   clone()       <em> </em> (thread control block, TCB)  <em> </em> (thread-local storage, TLS),        ,  . .     pthread_create()    ,    . <br><br>    ¬´¬ª,      clone()        libc  pthread.        ,    . </blockquote><br><h3 id="podgotovka-k-zapusku-potoka">     </h3><br><p>      clone()      : </p><br><ul><li>      ? </li><li>    ? </li><li>    -? </li></ul><br><h4 id="obrabotka-zaversheniya-potoka">    </h4><br><p>      :     -? </p><br><p>     ,  -       :   ,   ,       ,       . </p><br><p>        .  ,     ,        .  Comment?  :     exit().          ,     . </p><br><p>         .     exit()   -: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+.set __NR_exit, 60 .set RTLD_LAZY, 1 @@ - /* - *  . - */ - int $3 + /* + * exit(0); + */ + xor %rdi,%rdi + mov $__NR_exit,%rax + syscall</span></span></code> </pre> <br><p>  :   exit() ‚Äî    exit()   .   exit()    <em></em> ,    exit()    ‚Äî <em> </em>   .    Linux     exit_group(). </p><br><h4 id="vydelenie-pamyati-pod-stek">     </h4><br><p>     .         .     ,      ,   PROT_EXEC: </p><br><pre> <code class="cpp hljs">shellcode_stack_vaddr = remote_mmap(target, syscall_vaddr, <span class="hljs-number"><span class="hljs-number">0</span></span>, SHELLCODE_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK | MAP_GROWSDOWN, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>   ,   Linux  x86_64  <em> </em> ‚Äî  ¬´¬ª  ,     .  mmap()      ,   clone()     .  ,    mmap()  MAP_GROWSDOWN,       ,    . </p><br><h4 id="opciya-ptrace_o_traceclone">  PTRACE_O_TRACECLONE </h4><br><p>        .       ,   -   .         waitpid(),     :      ,          . </p><br><p>        ‚Äî   PTRACE_O_TRACECLONE.          .  ,       . ,      ,     ,    .      ,       PTRACE_ATTACH  ,    . </p><br><p> -,       : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- unsigned long options = PTRACE_O_TRACESYSGOOD; + unsigned long options = PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACECLONE; if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) return -1;</span></span></code> </pre> <br><p> -,         clone(),    PTRACE_EVENT_CLONE,     ,  PTRACE_SYSCALL.        : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-void wait_for_syscall_completion(pid_t pid) +void wait_for_syscall_completion(pid_t pid, long syscall) { wait_for_syscall_enter_exit_stop(pid); + + /*  clone()   PTRACE_EVENT_CLONE */ + if (syscall == __NR_clone) + wait_for_clone_event(pid); wait_for_syscall_enter_exit_stop(pid); }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_clone_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, event) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     clone()  PID  ,    .         : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_ptrace_options</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_SETOPTIONS, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>   ,   clone()    ptrace(),  PTRACE_O_TRACECLONE.     ,     ,  -     . </p><br><h3 id="zapusk-novogo-potoka">    </h3><br><p>      ,   - .       clone()   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_shell_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, <span class="hljs-comment"><span class="hljs-comment">/*   **  */</span></span> shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shell_tid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">clone()    </a> :    ,   ,     ,  .      ,  . </p><br><p> CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_VM ‚Äî         . ,   CLONE_FILES    <em></em>   ,    (  fork()).      ‚Äî    <em></em> ‚Äî      ,        .       . , CLONE_VM   ,       ,    . </p><br><p>  CLONE_THREAD       <em></em> :    Linux ‚Äî  ¬´   ¬ª,     .  , ,  getpid()         , kill() ‚Äî   -   , execve() ‚Äî       ,   . </p><br><p>  ,  clone()   fork():        ,    .      clone()      :    ,  ‚Äî   .        . ( , ,        .) </p><br><p>    ,  pthread_create()    ,      ,    .     ? </p><br><h3 id="peredacha-upravleniya">   </h3><br><p>    fork()  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* fork() ,    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     execve() */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span></code> </pre> <br><p>  ,     .  clone()                 .            . </p><br><p>      <a href="" rel="nofollow"> </a> . ,   clone()      ,    .      syscall   ret,       ,     .           . </p><br><h4 id="poisk-pary-instrukciy-syscall--ret">    SYSCALL + RET </h4><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> ,       .      ,     syscall   ret: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-if (region_size &lt; 2) +if (region_size &lt; 3) continue; /* * 0F 05 syscall + * C3 retq */ -for (size_t offset = 0; offset &lt; region_size - 1; offset++) { +for (size_t offset = 0; offset &lt; region_size - 2; offset++) { if (region_data[offset + 0] == 0x0F &amp;&amp; - region_data[offset + 1] == 0x05) + region_data[offset + 1] == 0x05 &amp;&amp; + region_data[offset + 2] == 0xC3) { return region-&gt;vaddr_low + offset; } }</span></span></code> </pre> <br><p>  ,       . </p><br><h4 id="podgotovka-steka">   </h4><br><p>     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> prepare_shellcode()</a> ,    ,          : </p><br><pre> <code class="diff hljs"> void write_shellcode(void) { char shellcode_text[SHELLCODE_TEXT_SIZE]; size_t shellcode_size = shellcode_end - shellcode_start; /*   ,  ,  . . */ prepare_shellcode(shellcode_text, shellcode_size); /*   -   */ write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); + /*    ¬´¬ª   */ + unsigned long retaddr_vaddr = + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8; + write_remote_memory(target, retaddr_vaddr, + &amp;shellcode_text_vaddr, sizeof(shellcode_text_vaddr)); }</code> </pre> <br><p>  ,      ,     . </p><br><p>  ,     ,   <em></em> . System V ABI ,   ( %rsp)     16    .  <code>shellcode_stack_vaddr + SHELLCODE_STACK_SIZE</code>  :       (  4096 ),     1 .  8 ,     ,      retq,      -    .   -   : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- sub $8,%rsp + sub $16,%rsp /*   */ mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax</span></span></code> </pre> <br><p>     ,   %rsp    16       pthread_create().          SIGSEGV,     ‚Äî     pthread_create()   ,       . </p><br><h4 id="zapusk-potoka">   </h4><br><p>        ,       - ,      clone(): </p><br><pre> <code class="diff hljs"> static int spawn_shell_thread() { shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, /*   **  */ - shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8); if (!shell_tid) return -1; return 0; }</code> </pre> <br><p>      ptrace()    SIGSTOP,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_thread_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait_for_process_stop(pid, SIGSTOP); }</code> </pre> <br><p>  C‚Äôest tout.               ptrace(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="zavershenie-potoka">   </h3><br><p>  ,    ,  ,    exit().        waitpid().     ‚Äî  CLONE_THREAD   wait()  ,‚Äî    PTRACE_O_TRACECLONE,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEXITSTATUS(status); }</code> </pre> <br><p>    pthread ,   ,  pthread_join()      pthread       ,        . ,  ‚Äî  .       ,   ,  . </p><br><h4 id="osvobozhdenie-pamyati">  M√©moire libre </h4><br><p>     ,  -   .     ,   -   ,      munmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_munmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ perform_syscall(pid, syscall_insn_vaddr, __NR_munmap, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) addr, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) len); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ remote_munmap(target, syscall_ret_vaddr, shellcode_text_vaddr, SHELLCODE_TEXT_SIZE); remote_munmap(target, syscall_ret_vaddr, shellcode_stack_vaddr, SHELLCODE_STACK_SIZE); }</code> </pre> <br><p> ,  ,     ,      ‚Äî  ptrace()   .        (, SIGSTOP),    ,   <em> </em>    (    ): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kill(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="otklyuchenie-otladchika">   </h4><br><p> ,      ,    .     PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-pyatogo-shaga">    </h3><br><p>                   ,      .     ,         .   ,      . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      ?   . ,       ,      . </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="d√©monstration d'injection au Gnome Control Center"></p><br><p>    Linux    .     GTK+     .      ,       make: </p><br><pre> <code class="bash hljs">libpayload.so: payload.c $(CC) $(CFLAGS) $(shell pkg-config --cflags --libs gtk+-3.0) -shared -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre> <br><p>     entry()            GTK- ‚Äî    GTK  UI      ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glib.h&gt; #include &lt;gtk/gtk.h&gt; static gboolean actual_entry(gpointer _arg) { /*       : */ hook_gtk_entry_constructor(); /*   FALSE,       */ return FALSE; } void entry(void) { /*    -,   */ g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, actual_entry, NULL, NULL); }</span></span></span></span></code> </pre> <br><p> ,   GTK   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GtkEntry</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> "input-purpose"</a>     .       ¬´¬ª,    ,      . </p><br><p> GTK   glib ‚Äî     ‚Äî      GtkEntry       .    constructed(),     .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*old_gtk_entry_constructed)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*    ,  ,   entry */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_gtk_entry_constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     GtkEntry */</span></span> GTypeClass *entry_type_class = g_type_class_peek(GTK_TYPE_ENTRY); GObjectClass *entry_object_class = G_OBJECT_CLASS(entry_type_class); <span class="hljs-comment"><span class="hljs-comment">/* *     "constructed"     . */</span></span> old_gtk_entry_constructed = entry_object_class-&gt;constructed; entry_object_class-&gt;constructed = new_gtk_entry_constructed; }</code> </pre> <br><p>   GtkEntry   : </p><br><ul><li>   ,  ,   </li><li>        </li></ul><br><p>  ,    GtkEntry  <em></em> ,   ,    .     ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"notify::input-purpose"</span></span>, G_CALLBACK(input_purpose_changed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-press"</span></span>, G_CALLBACK(icon_pressed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-release"</span></span>, G_CALLBACK(icon_released), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br><p>   .                ,         .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input_purpose_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry)</span></span></span><span class="hljs-function"> </span></span>{ GtkInputPurpose purpose = gtk_entry_get_input_purpose(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (purpose == GTK_INPUT_PURPOSE_PASSWORD) { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } }</code> </pre> <br><p>   : ,      ,   ,  -       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_pressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-add"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); }</code> </pre> <br><p>  C‚Äôest tout. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> GitHub</a>         (GPLv2). </p><br><p> ,       .   gdb         : </p><br><pre> <code class="plaintext hljs">$ gdb --pid $(pgrep target) \ --batch \ -ex 'compile file -raw shell-code.c'</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473740/">https://habr.com/ru/post/fr473740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473720/index.html">Deux fa√ßons de r√©aliser des tests unitaires fiables</a></li>
<li><a href="../fr473722/index.html">Isolement √† distance, anxi√©t√© et d√©pression</a></li>
<li><a href="../fr473726/index.html">Il ne suffit pas de savoir ce que sont Mutex, Semaphore et async / wait. Vous devez tout savoir des quanta</a></li>
<li><a href="../fr473728/index.html">Mise en ≈ìuvre typique de la surveillance. Nikolay Sivko</a></li>
<li><a href="../fr473732/index.html">L'histoire de la fraude dans la construction d'un r√©seau c√¢bl√© sous l'Arctique pour 1 milliard de dollars</a></li>
<li><a href="../fr473742/index.html">Imprimantes d'ing√©nierie Epson pour CAO et SIG et quelques mots sur la "conception robuste"</a></li>
<li><a href="../fr473748/index.html">Courbe de B√©zier au service des √©conomistes du travail</a></li>
<li><a href="../fr473750/index.html">Stereopi + WebRTC = t√©l√©pr√©sence √† domicile</a></li>
<li><a href="../fr473752/index.html">Quel est le probl√®me avec la copie sur √©criture pour Linux lors de la copie</a></li>
<li><a href="../fr473756/index.html">HTTPS DNS - Solution √† moiti√© et incorrecte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>