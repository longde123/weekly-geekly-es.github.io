<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏼 🆙 👩🏾‍🤝‍👩🏼 Types pour les API HTTP écrites en Python: expérience Instagram 🚶🏽 🧒🏽 🥁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous publions le deuxième matériel de la série consacrée à l'utilisation de Python sur Instagram. La dernière fois, il vérifiait les type...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types pour les API HTTP écrites en Python: expérience Instagram</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/474308/">  Aujourd'hui, nous publions le deuxième matériel de la série consacrée à l'utilisation de Python sur Instagram.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La dernière</a> fois, il vérifiait les types de code de serveur Instagram.  Le serveur est un monolithe écrit en Python.  Il se compose de plusieurs millions de lignes de code et compte plusieurs milliers de points de terminaison Django. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/nn/gh/jg/nnghjgmcauejll98mv34awk3cok.jpeg"></a> <br><br>  Cet article explique comment Instagram utilise les types pour documenter les API HTTP et appliquer les contrats lors de leur utilisation. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Aperçu de la situation</font> </h2><br>  Lorsque vous ouvrez le client mobile Instagram, celui-ci, via HTTP, accède à l'API JSON de notre serveur Python (Django). <br><br>  Voici quelques informations sur notre système qui vous permettront de vous faire une idée de la complexité de l'API que nous utilisons pour organiser le travail du client mobile.  Voici donc ce que nous avons: <br><br><ul><li>  Plus de 2000 points de terminaison sur le serveur. </li><li>  Plus de 200 champs de niveau supérieur dans un objet de données client qui représente une image, une vidéo ou une histoire dans une application. </li><li>  Des centaines de programmeurs qui écrivent du code serveur (et encore plus qui traitent avec le client). </li><li>  Des centaines de validations de code serveur effectuées quotidiennement et modifiant l'API.  Cela est nécessaire pour assurer la prise en charge des nouvelles fonctionnalités du système. </li></ul><br>  Nous utilisons des types pour documenter nos API HTTP complexes et en constante évolution et pour appliquer les contrats lorsque nous les utilisons. <br><br><h2>  <font color="#3AC1EF">Les types</font> </h2><br>  Commençons par le tout début.  La description de la syntaxe des annotations de type dans le code Python est apparue dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 484</a> .  Pourquoi ajouter des annotations de type au code? <br><br>  Considérez la fonction qui télécharge des informations sur le héros de Star Wars: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id, calendar)</span></span></span><span class="hljs-function">:</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> id == <span class="hljs-number"><span class="hljs-number">1000</span></span>:         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Character(             id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,             name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,             birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calendar == Calendar.BBY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ...         )     ...</code> </pre> <br>  Pour comprendre cette fonction, vous devez lire son code.  Cela fait, vous pouvez découvrir les éléments suivants: <br><br><ul><li>  Il prend l'identifiant entier ( <code>id</code> ) du caractère. </li><li>  Il prend la valeur de l'énumération correspondante ( <code>calendar</code> ).  Par exemple, <code>Calendar.BBY</code> signifie «Avant la bataille de Yavin», c'est-à-dire «Avant la bataille de Yavin». </li><li>  Il renvoie des informations sur le personnage sous la forme d'une entité contenant des champs représentant l'identifiant de ce personnage, son nom et son année de naissance. </li></ul><br>  La fonction a un contrat implicite, dont le programmeur doit restaurer chaque fois qu'il lit le code de la fonction.  Mais le code de fonction n'est écrit qu'une seule fois, et vous devez le lire plusieurs fois, donc cette approche pour travailler avec ce code n'est pas particulièrement bonne. <br><br>  De plus, il est difficile de vérifier que le mécanisme qui appelle la fonction adhère au contrat implicite décrit ci-dessus.  De même, il est difficile de vérifier que ce contrat est respecté dans le corps de la fonction.  Dans une grande base de code, de telles situations peuvent entraîner des erreurs. <br><br>  Considérons maintenant la même fonction qui déclare les annotations de type: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Les annotations de type vous permettent d'exprimer explicitement le contrat de cette fonction.  Afin de comprendre ce qui doit être entré dans une fonction et ce que cette fonction renvoie, il suffit de lire sa signature.  Un système de vérification de type peut analyser statiquement la fonction et vérifier la conformité au contrat dans le code.  Cela vous permet de vous débarrasser de toute une classe d'erreurs! <br><br><h2>  <font color="#3AC1EF">Types pour diverses API HTTP</font> </h2><br>  Nous développerons une API HTTP qui vous permettra de recevoir des informations sur les héros de Star Wars.  Pour décrire le contrat explicite utilisé lors de l'utilisation de cette API, nous utiliserons des annotations de type. <br><br>  Notre API doit accepter l'identificateur de caractère ( <code>id</code> ) comme paramètre d'URL et la valeur de l'énumération du <code>calendar</code> comme paramètre de demande.  L'API doit renvoyer une réponse JSON avec des informations sur les caractères. <br><br>  Voici à quoi ressemble la demande d'API et la réponse qu'elle renvoie: <br><br><pre> <code class="plaintext hljs">curl -X GET https://api.starwars.com/characters/1000?calendar=BBY {    "id": 1000,    "name": "Luke Skywalker",    "birth_year": "19BBY" }</code> </pre> <br>  Pour implémenter cette API dans Django, vous devez d'abord enregistrer le chemin URL et la fonction d'affichage responsable de la réception de la requête HTTP effectuée le long de ce chemin et du retour de la réponse. <br><br><pre> <code class="python hljs">urlpatterns = [    url(<span class="hljs-string"><span class="hljs-string">"characters/&lt;id&gt;/"</span></span>, get_character) ]</code> </pre> <br>  La fonction, en entrée, accepte les paramètres de requête et d'URL (dans notre cas, <code>id</code> ).  Il analyse et convertit le paramètre de demande de <code>calendar</code> , qui est la valeur de l'énumération correspondante, en type requis.  Il charge les données de caractères du magasin et renvoie un dictionnaire sérialisé en JSON et enveloppé dans une réponse HTTP. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: IGWSGIRequest, id: str)</span></span></span><span class="hljs-function"> -&gt; JsonResponse:</span></span>    calendar = Calendar(request.GET.get(<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"BBY"</span></span>))    character = Store.get_character(id, calendar)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(character))</code> </pre> <br>  Bien que la fonction soit fournie avec des annotations de type, elle ne décrit pas explicitement le contrat matériel pour l'API HTTP.  À partir de la signature de cette fonction, nous ne pouvons pas trouver les noms ou les types de paramètres de demande, ou les champs de réponse et leurs types. <br><br>  Est-il possible de faire en sorte que la signature de la fonction-représentation soit exactement la même informative que la signature de la fonction précédemment considérée avec des annotations de type? <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Les paramètres de fonction peuvent être des paramètres de requête (URL, requête ou paramètres de corps de requête).  Le type de valeur renvoyé par la fonction peut représenter le contenu de la réponse.  Avec cette approche, nous aurions à notre disposition un contrat explicite et compréhensible pour l'API HTTP, dont le respect pourrait être assuré par un système de vérification de type. <br><br><h2>  <font color="#3AC1EF">Implémentation</font> </h2><br>  Comment mettre en œuvre cette idée? <br><br>  Nous utilisons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décorateur</a> pour convertir une fonction de représentation fortement typée en une fonction de représentation Django.  Cette étape ne nécessite pas de modifications en termes de travail avec le framework Django.  Nous pouvons utiliser le même middleware, les mêmes routes et d'autres composants auxquels nous sommes habitués. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view def get_character(id: int, calendar: Calendar) -&gt; Character:    ...</span></span></code> </pre> <br>  Considérez les détails de l' <code>api_view</code> décorateur <code>api_view</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        params = {            param_name: param.annotation(extract(request, param))            <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()        }        data = view(**params)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  C'est un morceau de code difficile à comprendre.  Analysons ses caractéristiques. <br>  Nous, en tant que valeur d'entrée, prenons une fonction de représentation fortement typée et l'enveloppons dans une fonction de représentation Django régulière, que nous renvoyons: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        ...    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Jetez maintenant un œil à l'implémentation de la fonction de vue Django.  Nous devons d'abord construire des arguments pour une fonction de présentation fortement typée.  Nous utilisons l'introspection et le module d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inspection</a> pour obtenir la signature de cette fonction et itérer sur ses paramètres: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()</code> </pre> <br>  Pour chaque paramètre, nous appelons la fonction d' <code>extract</code> , qui extrait la valeur du paramètre de la demande. <br><br>  Ensuite, nous convertissons le paramètre en le type attendu spécifié dans la signature (par exemple, convertissons le <code>calendar</code> de la chaîne en une valeur qui est un élément de l'énumération <code>Calendar</code> ). <br><br><pre> <code class="python hljs">param.annotation(extract(request, param))</code> </pre> <br>  Nous appelons une fonction de vue fortement typée avec les arguments que nous avons construits: <br><br><pre> <code class="python hljs">data = view(**params)</code> </pre> <br>  La fonction renvoie une valeur fortement typée de la classe <code>Character</code> .  Nous prenons cette valeur, la transformons en dictionnaire et l'enveloppons dans une réponse HTTP au format JSON: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))</code> </pre> <br>  Super!  Nous avons maintenant une fonction de vue Django qui encapsule une fonction de vue fortement typée.  Enfin, jetez un œil à la fonction d' <code>extract</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: HttpRequest, param: Parameter)</span></span></span><span class="hljs-function"> -&gt; Any:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.resolver_match.route.contains(<span class="hljs-string"><span class="hljs-string">f"&lt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{param}</span></span></span><span class="hljs-string">&gt;"</span></span>):        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.resolver_match.kwargs.get(param.name)    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.get(param.name)</code> </pre> <br>  Chaque paramètre peut être un paramètre URL ou un paramètre de demande.  Le chemin de l'URL de demande (le chemin que nous avons enregistré au tout début) est disponible dans l'objet route du système de localisateur d'URL Django.  Nous vérifions le nom du paramètre dans le chemin.  S'il y a un nom, alors nous avons un paramètre URL.  Cela signifie que nous pouvons en quelque sorte l'extraire de la demande.  Sinon, il s'agit d'un paramètre de requête et nous pouvons également l'extraire, mais d'une autre manière. <br><br>  C’est tout.  Il s'agit d'une implémentation simplifiée, mais elle illustre l'idée de base de taper une API. <br><br><h2>  <font color="#3AC1EF">Types de données</font> </h2><br>  Le type utilisé pour représenter le contenu de la réponse HTTP (c'est-à-dire <code>Character</code> ) peut être représenté soit par une classe de données soit par un dictionnaire typé. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une classe de</a> données est un format de description de classe compact qui représente des données. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass(frozen=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke = Character(    id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,    name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,    birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> )</code> </pre> <br>  Instagram utilise généralement des classes de données pour modéliser les objets de réponse HTTP.  Voici leurs principales caractéristiques: <br><br><ul><li>  Ils génèrent automatiquement des constructions de modèles et diverses méthodes d'assistance. </li><li>  Ils sont compréhensibles pour les systèmes de vérification de type, ce qui signifie que les valeurs peuvent être soumises à des vérifications de type. </li><li>  Ils maintiennent l'immunité grâce à la construction <code>frozen=True</code> . </li><li>  Ils sont disponibles dans la bibliothèque standard Python 3.7 ou en tant que backport dans l'index du package Python. </li></ul><br>  Malheureusement, Instagram a une base de code obsolète qui utilise de gros dictionnaires non typés, passés entre les fonctions et les modules.  Il ne serait pas facile de traduire tout ce code des dictionnaires en classes de données.  Par conséquent, nous utilisons des classes de données pour le nouveau code et dans du code obsolète, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des dictionnaires typés</a> . <br><br>  L'utilisation de dictionnaires typés nous permet d'ajouter des annotations de type aux objets du dictionnaire client et, sans changer le comportement d'un système de travail, d'utiliser les capacités de vérification de type. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mypy_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypedDict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TypedDict)</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke: Character = {<span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>} luke[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span> luke[<span class="hljs-string"><span class="hljs-string">"birth_year"</span></span>] = <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-comment"><span class="hljs-comment"># type error, birth_year expects a str luke["invalid_key"] # type error, invalid_key does not exist</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Gestion des erreurs</font> </h2><br>  La fonction d'affichage devrait renvoyer des informations de caractère sous la forme d'une entité de <code>Character</code> .  Que devons-nous faire si nous devons renvoyer une erreur au client? <br><br>  Vous pouvez lever une exception qui sera interceptée par le framework et convertie en une réponse HTTP avec des informations d'erreur. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view("GET") def get_character(id: str, calendar: Calendar) -&gt; Character:    try:        return Store.get_character(id)    except CharacterNotFound:        raise Http404Exception()</span></span></code> </pre> <br>  Cet exemple illustre également la méthode HTTP dans le décorateur, qui définit les méthodes HTTP autorisées pour cette API. <br><br><h2>  <font color="#3AC1EF">Les outils</font> </h2><br>  L'API HTTP est fortement typée à l'aide de la méthode HTTP, des types de demande et des types de réponse.  Nous pouvons introspecter cette API et déterminer qu'elle doit accepter une demande GET avec la chaîne <code>id</code> dans le chemin URL et avec la valeur de <code>calendar</code> liée à l'énumération correspondante dans la chaîne de requête.  Nous pouvons également apprendre qu'en réponse à une telle demande, une réponse JSON doit être fournie avec des informations sur la nature du <code>Character</code> . <br><br>  Que faire de toutes ces informations? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenAPI</a> est un format de description d'API sur la base duquel un riche ensemble d'outils auxiliaires est créé.  C'est tout un écosystème.  Si nous écrivons du code pour effectuer une introspection de point final et générer des spécifications OpenAPI basées sur les données reçues, cela signifiera que nous aurons les capacités de ces outils. <br><br><pre> <code class="python hljs">paths:  /characters/{id}:    get:      parameters:        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: path          name: id          schema:            type: integer          required: true        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: query          name: calendar          schema:            type: string            enum: [<span class="hljs-string"><span class="hljs-string">"BBY"</span></span>]      responses:        <span class="hljs-string"><span class="hljs-string">'200'</span></span>:          content:            application/json:              schema:                type: object                ...</code> </pre> <br>  Nous pouvons générer la documentation de l'API HTTP pour l'API <code>get_character</code> , qui comprend les noms, les types, les informations de demande et de réponse.  Il s'agit d'un niveau d'abstraction approprié pour les développeurs clients qui doivent répondre aux demandes au point de terminaison approprié.  Ils n'ont pas besoin de lire le code d'implémentation Python pour ce point de terminaison. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/673/e79/28e/673e7928eb5c55d4d6ec83c506eaf450.png"><br>  <i><font color="#999999">Documentation API</font></i> <br><br>  Sur cette base, vous pouvez créer des outils supplémentaires.  Par exemple, un moyen d'exécuter une demande à partir d'un navigateur.  Cela permet aux développeurs d'accéder aux API HTTP qui les intéressent sans avoir à écrire de code.  Nous pouvons même générer du code client de type sécurisé pour nous assurer que les types fonctionnent correctement à la fois sur le client et sur le serveur.  Pour cette raison, nous pouvons avoir à notre disposition une API strictement typée sur le serveur, dont les appels sont effectués en utilisant du code client strictement typé. <br><br>  De plus, nous pouvons créer un système de vérification de la compatibilité descendante.  Que se passe-t-il si nous publions une nouvelle version du code serveur pour accéder à l'API en question, nous devons utiliser <code>id</code> , <code>name</code> et <code>birth_year</code> , puis nous comprenons que nous ne connaissons pas les anniversaires de tous les personnages?  Dans ce cas, le paramètre <code>birth_year</code> être rendu facultatif, mais les anciennes versions de clients qui attendent un paramètre similaire peuvent simplement cesser de fonctionner.  Bien que nos API diffèrent par leur typage explicite, les types correspondants peuvent changer (par exemple, l'API changera si l'utilisation de l'année de naissance du personnage était d'abord obligatoire puis devenait facultative).  Nous pouvons suivre les modifications de l'API et avertir les développeurs d'API en leur donnant des invites au bon moment qu'en effectuant certaines modifications, ils peuvent perturber les performances des clients. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Il existe toute une gamme de protocoles d'application que les ordinateurs peuvent utiliser pour communiquer entre eux. <br><br>  Un côté de ce spectre est représenté par des cadres RPC comme Thrift et gRPC.  Ils diffèrent en ce qu'ils définissent généralement des types stricts pour les demandes et les réponses et génèrent du code client et serveur pour organiser le fonctionnement des demandes.  Ils peuvent se passer de HTTP et même de JSON. <br><br>  D'un autre côté, il existe des frameworks Web non structurés écrits en Python qui n'ont pas de contrats explicites pour les demandes et les réponses.  Notre approche offre des opportunités typiques pour des frameworks plus clairement structurés, mais en même temps vous permet de continuer à utiliser le bundle HTTP + JSON et contribue au fait que vous devez apporter un minimum de modifications au code de l'application. <br><br>  Il est important de noter que cette idée n'est pas nouvelle.  Il existe de nombreux frameworks écrits dans des langages fortement typés qui fournissent aux développeurs les fonctionnalités que nous avons décrites.  Si nous parlons de Python, alors c'est, par exemple, le framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">APIStar</a> . <br><br>  Nous avons réussi à commander l'utilisation de types pour l'API HTTP.  Nous avons pu appliquer l'approche décrite pour taper l'API dans l'ensemble de notre base de code car elle est bien applicable aux fonctions de présentation existantes.  La valeur de ce que nous avons fait est évidente pour tous nos programmeurs.  À savoir, nous parlons du fait que la documentation générée automatiquement est devenue un moyen de communication efficace entre ceux qui développent le serveur et ceux qui écrivent le client Instagram. <br><br>  <b>Chers lecteurs!</b>  Comment abordez-vous la conception des API HTTP dans vos projets Python? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474308/">https://habr.com/ru/post/fr474308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474294/index.html">Compatibilité binaire: maintenant ou jamais</a></li>
<li><a href="../fr474298/index.html">Mise en œuvre d'une opération de transfert de carte à carte de passerelle P2P</a></li>
<li><a href="../fr474300/index.html">Sauvegarde fiable, sécurisée et polyvalente pour U2F</a></li>
<li><a href="../fr474302/index.html">Comment écrire un script de test d'utilisabilité d'application efficace</a></li>
<li><a href="../fr474306/index.html">Rendre les styles de pointage, de mise au point et d'état actif différents</a></li>
<li><a href="../fr474310/index.html">Y a-t-il des nombres aléatoires dans CSS?</a></li>
<li><a href="../fr474312/index.html">Installation de l'interface graphique sur Windows Server Core</a></li>
<li><a href="../fr474316/index.html">Voiture électrique faite maison - partie 1. Comment tout a commencé et comment j'ai marqué 1000000 vues sur youtube</a></li>
<li><a href="../fr474318/index.html">Qu'est-ce qu'une table de table virtuelle?</a></li>
<li><a href="../fr474320/index.html">DDD Community Crisis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>