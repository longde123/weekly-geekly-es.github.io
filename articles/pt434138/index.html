<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≥ ü•ì üåï N√≥s escrevemos nossa pr√≥pria m√°quina virtual üõ¢Ô∏è üéñÔ∏è üë©üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste tutorial, mostrarei como escrever sua pr√≥pria m√°quina virtual (VM) que pode executar programas assembler como 2048 (meu amigo) ou Roguelike (meu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s escrevemos nossa pr√≥pria m√°quina virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/"> Neste tutorial, mostrarei como escrever sua pr√≥pria m√°quina virtual (VM) que pode executar programas assembler como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2048</a> (meu amigo) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Roguelike</a> (meu).  Se voc√™ sabe programar, mas deseja entender melhor o que est√° acontecendo dentro do computador e como as linguagens de programa√ß√£o funcionam, esse projeto √© para voc√™.  Escrever sua pr√≥pria m√°quina virtual pode parecer um pouco assustador, mas prometo que o t√≥pico √© surpreendentemente simples e instrutivo. <br><br>  <a href="">O c√≥digo final</a> possui cerca de 250 linhas em C. √â suficiente conhecer apenas o b√°sico de C ou C ++, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aritm√©tica bin√°ria</a> .  Qualquer sistema Unix (incluindo o macOS) √© adequado para constru√ß√£o e execu√ß√£o.  V√°rias APIs do Unix s√£o usadas para configurar a entrada e a exibi√ß√£o do console, mas elas n√£o s√£o essenciais para o c√≥digo principal.  (A implementa√ß√£o do suporte do Windows √© apreciada). <br><br><blockquote>  <b>Nota:</b> esta VM √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programa competente</a> .  Ou seja, voc√™ j√° est√° lendo o c√≥digo fonte no momento!  Cada peda√ßo de c√≥digo ser√° mostrado e explicado em detalhes, para que voc√™ tenha certeza de que nada est√° faltando.  O c√≥digo final √© criado por um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plexo</a> de blocos de c√≥digo.  Reposit√≥rio do projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Conte√∫dos </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdu√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de assembler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execu√ß√£o do programa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o de instru√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instru√ß√µes Cheat Sheet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Procedimentos de processamento de interrup√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Folha de dicas para rotinas de interrup√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Download de software</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registros Mapeados na Mem√≥ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recursos da plataforma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicializa√ß√£o da m√°quina virtual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√©todo alternativo em C ++</a> </li></ol><br><a name="2"></a><h1>  2. Introdu√ß√£o </h1><br><h3>  O que √© uma m√°quina virtual? </h3><br>  Uma m√°quina virtual √© um programa que age como um computador.  Ele simula um processador com v√°rios outros componentes de hardware, permitindo executar aritm√©tica, ler e gravar na mem√≥ria e interagir com dispositivos de entrada / sa√≠da como um computador f√≠sico real.  Mais importante ainda, a VM entende uma linguagem de m√°quina que voc√™ pode usar para programa√ß√£o. <br><br>  A quantidade de hardware que uma VM espec√≠fica simula depende de sua finalidade.  Algumas VMs reproduzem o comportamento de um computador espec√≠fico.  As pessoas n√£o t√™m mais o NES, mas ainda podemos jogar para o NES simulando o hardware no n√≠vel do software.  Esses emuladores devem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recriar com precis√£o</a> todos os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">detalhes</a> e todos os principais componentes de hardware do dispositivo original. <br><br>  Outras VMs n√£o correspondem a nenhum computador em particular, mas correspondem parcialmente a v√°rias de uma vez!  Isso √© feito principalmente para facilitar o desenvolvimento de software.  Imagine que voc√™ deseja criar um programa que √© executado em v√°rias arquiteturas de computadores.  A m√°quina virtual fornece uma plataforma padr√£o que fornece portabilidade.  N√£o h√° necessidade de reescrever o programa em diferentes dialetos do assembler para cada arquitetura.  Basta fazer apenas uma pequena VM em cada idioma.  Depois disso, qualquer programa pode ser gravado apenas uma vez na linguagem assembly de uma m√°quina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Nota: o</b> compilador resolve esses problemas, compilando uma <i>linguagem de alto n√≠vel</i> padr√£o para diferentes arquiteturas de processador.  A VM cria uma <i>arquitetura de CPU</i> padr√£o que √© simulada em v√°rios dispositivos de hardware.  Uma das vantagens do compilador √© que n√£o h√° sobrecarga de tempo de execu√ß√£o como a VM.  Embora os compiladores funcionem bem, escrever um novo compilador para v√°rias plataformas √© muito dif√≠cil, portanto, as VMs ainda s√£o √∫teis.  Na realidade, em diferentes n√≠veis, VM e compiladores s√£o usados ‚Äã‚Äãjuntos. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A Java Virtual Machine (JVM)</a> √© um exemplo de muito sucesso.  A pr√≥pria JVM √© de tamanho relativamente m√©dio; √© pequena o suficiente para um programador entender.  Isso permite que voc√™ escreva c√≥digos para milhares de dispositivos diferentes, incluindo telefones.  Ap√≥s implementar a JVM no novo dispositivo, qualquer programa Java, Kotlin ou Clojure gravado pode trabalhar nele sem altera√ß√µes.  Os √∫nicos custos ser√£o apenas a sobrecarga da pr√≥pria VM e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a abstra√ß√£o adicional</a> do n√≠vel da m√°quina.  Geralmente, esse √© um bom compromisso. <br><br>  Uma VM n√£o precisa ser grande ou onipresente para fornecer benef√≠cios semelhantes.  Os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">videogames</a> mais antigos costumavam usar pequenas VMs para criar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistemas de script</a> simples. <br><br>  As VMs tamb√©m s√£o √∫teis para isolar programas com seguran√ßa.  Um aplicativo √© a coleta de lixo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√£o h√° uma maneira trivial de</a> implementar a coleta autom√°tica de lixo em cima de C ou C ++, pois o programa n√£o pode ver sua pr√≥pria pilha ou vari√°veis.  No entanto, a VM est√° "fora" do programa em execu√ß√£o e pode observar todas as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncias a c√©lulas de mem√≥ria</a> na pilha. <br><br>  Outro exemplo desse comportamento √© demonstrado pelos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contratos inteligentes da Ethereum</a> .  Contratos inteligentes s√£o pequenos programas executados por cada n√≥ de valida√ß√£o no blockchain.  Ou seja, os operadores permitem a execu√ß√£o em suas m√°quinas de qualquer programa gravado por completamente estranhos, sem a oportunidade de estud√°-los com anteced√™ncia.  Para impedir a√ß√µes maliciosas, elas s√£o executadas em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VM</a> que n√£o tem acesso ao sistema de arquivos, rede, disco, etc.  Ethereum tamb√©m √© um bom exemplo de portabilidade.  Gra√ßas √† VM, voc√™ pode escrever contratos inteligentes sem levar em conta os recursos de muitas plataformas. <br><br><a name="3"></a><h1>  3. Arquitetura LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  Nossa VM simular√° um computador fict√≠cio chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LC-3</a> .  √â popular para ensinar aos alunos assembler.  Aqui, um conjunto simplificado de comandos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comparado ao x86</a> , mas mant√©m todos os conceitos b√°sicos que s√£o usados ‚Äã‚Äãnas CPUs modernas. <br><br>  Primeiro, voc√™ precisa simular os componentes de hardware necess√°rios.  Tente entender o que √© cada componente, mas n√£o se preocupe se n√£o tiver certeza de como ele se encaixa no cen√°rio geral.  Vamos come√ßar criando um arquivo em C. Cada peda√ßo de c√≥digo desta se√ß√£o deve ser colocado no escopo global deste arquivo. <br><br><h3>  A mem√≥ria </h3><br>  O LC-3 possui 65.536 c√©lulas de mem√≥ria (2 <sup>16</sup> ), cada uma das quais cont√©m um valor de 16 bits.  Isso significa que ele s√≥ pode armazenar 128 KB - muito menos do que voc√™ est√° acostumado!  Em nosso programa, essa mem√≥ria √© armazenada em uma matriz simples: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Registros </h3><br>  Um registro √© um slot para armazenar um valor na CPU.  Os registros s√£o como um "ambiente de trabalho" da CPU.  Para que ele possa trabalhar com alguns dados, ele deve estar em um dos registros.  Por√©m, como existem apenas alguns registros, apenas uma quantidade m√≠nima de dados pode ser baixada a qualquer momento.  Os programas solucionam esse problema carregando valores da mem√≥ria nos registradores, calculando valores em outros registradores e armazenando os resultados finais novamente na mem√≥ria. <br><br>  Existem apenas 10 registros no LC-3, cada um com 16 bits.  A maioria deles √© de uso geral, mas alguns t√™m fun√ß√µes atribu√≠das. <br><br><ul><li>  8 registradores de uso geral ( <code>R0-R7</code> ) </li><li>  1 registro do contador de equipes ( <code>PC</code> ) </li><li>  1 registro de sinalizador de condi√ß√£o ( <code>COND</code> ) </li></ul><br>  Registradores de uso geral podem ser usados ‚Äã‚Äãpara executar qualquer c√°lculo de software.  O contador de instru√ß√µes √© um n√∫mero inteiro n√£o assinado que √© o endere√ßo de mem√≥ria da pr√≥xima instru√ß√£o a ser executada.  Os sinalizadores de condi√ß√£o informam sobre o c√°lculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Como a mem√≥ria, armazenaremos os registros em uma matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Conjunto de instru√ß√µes </h3><br>  Uma instru√ß√£o √© um comando que informa ao processador para executar algum tipo de tarefa fundamental, por exemplo, adicionar dois n√∫meros.  A instru√ß√£o possui um <b>opcode</b> (c√≥digo de opera√ß√£o) indicando o tipo de tarefa que est√° sendo executada, bem como um conjunto de <b>par√¢metros</b> que fornecem entrada para a tarefa que est√° sendo executada. <br><br>  Cada <b>opcode</b> representa uma tarefa que o processador "sabe" como executar.  Existem 16 opcodes no LC-3.  Um computador pode calcular apenas a sequ√™ncia dessas instru√ß√µes simples.  O comprimento de cada instru√ß√£o √© 16 bits e os 4 bits esquerdos armazenam o c√≥digo de opera√ß√£o.  O restante √© usado para armazenar par√¢metros. <br><br>  Mais tarde discutiremos em detalhes o que cada instru√ß√£o faz.  Defina os seguintes opcodes no momento.  Certifique-se de manter este pedido para obter o valor de enum correto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Nota: A</b> arquitetura Intel x86 possui centenas de instru√ß√µes, enquanto outras arquiteturas como ARM e LC-3 s√£o muito poucas.  Conjuntos pequenos de instru√ß√µes s√£o chamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RISC</a> , enquanto conjuntos maiores s√£o chamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CISC</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geralmente</a> , grandes conjuntos de instru√ß√µes n√£o fornecem recursos fundamentalmente novos, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">frequentemente simplificam a escrita do c√≥digo do assembler</a> .  Uma instru√ß√£o CISC pode substituir v√°rias instru√ß√µes RISC.  No entanto, os processadores CISC s√£o mais complexos e caros para projetar e fabricar.  Essa e outras compensa√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o permitem chamar o design "ideal"</a> . </blockquote><br><h3>  Sinalizadores de condi√ß√£o </h3><br>  O registro <code>R_COND</code> armazena sinalizadores de condi√ß√£o que fornecem informa√ß√µes sobre o √∫ltimo c√°lculo realizado.  Isso permite que os programas verifiquem condi√ß√µes l√≥gicas, como <code>if (x &gt; 0) { ... }</code> . <br><br>  Cada processador possui muitos sinalizadores de status para sinalizar v√°rias situa√ß√µes.  O LC-3 usa apenas tr√™s sinalizadores de condi√ß√£o que mostram o sinal do c√°lculo anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Nota:</b> (O caractere <code>&lt;&lt;</code> √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">operador de deslocamento √† esquerda</a> . <code>(n &lt;&lt; k)</code> move os bits <code>n</code> esquerda por <code>k</code> lugares. Assim, <code>1 &lt;&lt; 2</code> √© igual a <code>4</code> Leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> se voc√™ n√£o estiver familiarizado com o conceito. Isso ser√° muito importante). </blockquote><br>  Conclu√≠mos a configura√ß√£o dos componentes de hardware da nossa m√°quina virtual!  Depois de adicionar inclus√µes padr√£o (veja o link acima), seu arquivo deve se parecer com o seguinte: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Aqui est√£o os links para as se√ß√µes numeradas do artigo, de onde v√™m os fragmentos de c√≥digo correspondentes.</font>  <font color="gray">Para uma lista completa, consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programa de trabalho</a> - aprox.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Exemplos de assembler </h1><br>  Agora, vejamos o programa assembler LC-3 para ter uma id√©ia do que a m√°quina virtual realmente faz.  Voc√™ n√£o precisa saber como programar no assembler ou entender tudo aqui.  Apenas tente ter uma id√©ia geral do que est√° acontecendo.  Aqui est√° um simples "Ol√° Mundo": <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Como em C, o programa executa uma instru√ß√£o de cima para baixo.  Mas, diferentemente de C, n√£o h√° √°reas aninhadas <code>{}</code> ou estruturas de controle como <code>if</code> ou <code>while</code> ;  apenas uma lista simples de operadores.  Portanto, √© muito mais f√°cil de executar. <br><br>  Observe que os nomes de alguns operadores correspondem aos c√≥digos de opera√ß√£o que definimos anteriormente.  Sabemos que as instru√ß√µes s√£o de 16 bits, mas cada linha parece com um n√∫mero diferente de caracteres.  Como √© poss√≠vel uma incompatibilidade? <br><br>  Isso ocorre porque o c√≥digo que estamos lendo √© escrito em <b>linguagem assembly</b> - em texto sem formata√ß√£o, leg√≠vel e grav√°vel.  Uma ferramenta, chamada <b>assembler</b> , converte cada linha de texto em uma instru√ß√£o bin√°ria de 16 bits que uma m√°quina virtual entende.  Essa forma bin√°ria, que √© essencialmente uma matriz de instru√ß√µes de 16 bits, √© chamada de <b>c√≥digo de m√°quina</b> e √© realmente executada por uma m√°quina virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Nota:</b> embora o compilador e o montador tenham um papel semelhante no desenvolvimento, eles n√£o s√£o os mesmos.  O assembler simplesmente codifica o que o programador escreveu no texto, substituindo os caracteres por sua representa√ß√£o bin√°ria e colocando-os em instru√ß√µes. </blockquote><br>  Os <code>.STRINGZ</code> e <code>.STRINGZ</code> parecem instru√ß√µes, mas n√£o.  Essas s√£o diretivas de assembler que geram parte do c√≥digo ou dados.  Por exemplo, <code>.STRINGZ</code> insere uma sequ√™ncia de caracteres em um local especificado em um programa bin√°rio. <br><br>  Loops e condi√ß√µes s√£o executados usando uma instru√ß√£o goto-like.  Aqui est√° outro exemplo que conta at√© 10. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Nota:</b> este tutorial n√£o precisa aprender a montagem.  Mas se voc√™ estiver interessado, pode escrever e criar seus pr√≥prios programas LC-3 usando as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas LC-3</a> . </blockquote><br><a name="5"></a><h1>  5. Execu√ß√£o do programa </h1><br>  Mais uma vez, os exemplos anteriores apenas d√£o uma id√©ia do que a VM faz.  Para escrever uma VM, voc√™ n√£o precisa de um entendimento completo do assembler.  Desde que voc√™ siga o procedimento apropriado para ler e executar instru√ß√µes, <i>qualquer programa</i> LC-3 funcionar√° corretamente, independentemente de sua complexidade.  Em teoria, uma VM pode at√© rodar um navegador ou um sistema operacional como o Linux! <br><br>  Se voc√™ pensa profundamente, essa √© uma ideia filosoficamente maravilhosa.  Os pr√≥prios programas podem produzir a√ß√µes arbitrariamente complexas que nunca esper√°vamos e que talvez n√£o consigamos entender.  Mas, ao mesmo tempo, toda a sua funcionalidade √© limitada ao c√≥digo simples, que escreveremos!  Ao mesmo tempo, sabemos tudo e nada sobre como cada programa funciona.  Turing mencionou essa id√©ia maravilhosa: <br><br><blockquote>  ‚ÄúA opini√£o de que as m√°quinas n√£o podem surpreender uma pessoa com nada se baseia, acredito, em um erro, do qual matem√°ticos e fil√≥sofos s√£o particularmente propensos.  Quero dizer a suposi√ß√£o de que, como algum fato se tornou propriedade da mente, imediatamente todas as consequ√™ncias desse fato se tornar√£o propriedade da mente. ‚Äù  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Procedimento </h3><br>  Aqui est√° a descri√ß√£o exata do procedimento para escrever: <br><br><ol><li>  Fa√ßa o download de uma instru√ß√£o da mem√≥ria no endere√ßo do registro do <code>PC</code> . </li><li>  Aumente <code>PC</code> registro do <code>PC</code> . </li><li>  Veja o c√≥digo de opera√ß√£o para determinar que tipo de instru√ß√£o seguir. </li><li>  Siga as instru√ß√µes usando seus par√¢metros. </li><li>  Volte para a etapa 1. </li></ol><br>  Voc√™ pode fazer a pergunta: "Mas se o loop continuar aumentando o contador na aus√™ncia de <code>if</code> ou <code>while</code> , as instru√ß√µes n√£o terminar√£o?"  A resposta √© n√£o.  Como j√° mencionamos, algumas instru√ß√µes do tipo goto alteram o fluxo de execu√ß√£o saltando pelo <code>PC</code> . <br><br>  Iniciamos o estudo desse processo como um exemplo do ciclo principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Implementa√ß√£o de instru√ß√µes </h1><br>  Agora sua tarefa √© fazer a implementa√ß√£o correta para cada c√≥digo de opera√ß√£o.  Uma especifica√ß√£o detalhada de cada instru√ß√£o est√° contida na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> .  A partir da especifica√ß√£o, voc√™ precisa descobrir como cada instru√ß√£o funciona e escrever uma implementa√ß√£o.  Isso √© mais f√°cil do que parece.  Aqui vou demonstrar como implementar dois deles.  O c√≥digo para o restante pode ser encontrado na pr√≥xima se√ß√£o. <br><br><h3>  ADICIONAR </h3><br>  A instru√ß√£o <code>ADD</code> pega dois n√∫meros, os adiciona e armazena o resultado em um registro.  A especifica√ß√£o est√° na documenta√ß√£o na p√°gina 526. Cada instru√ß√£o <code>ADD</code> √© a seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Existem duas linhas no diagrama, porque existem dois "modos" diferentes para esta instru√ß√£o.  Antes de explicar os modos, vamos tentar encontrar as semelhan√ßas entre eles.  Ambos come√ßam com quatro bits id√™nticos <code>0001</code> .  Este √© o valor do opcode para <code>OP_ADD</code> .  Os pr√≥ximos tr√™s bits s√£o marcados como <code>DR</code> para o registro de sa√≠da.  O registro de sa√≠da √© o local onde a quantidade √© armazenada.  Os tr√™s bits a seguir s√£o: <code>SR1</code> .  Este √© um registro que cont√©m o primeiro n√∫mero a ser adicionado. <br><br>  Assim, sabemos onde salvar o resultado e o primeiro n√∫mero a ser adicionado.  Resta apenas descobrir o segundo n√∫mero para adi√ß√£o.  Aqui as duas linhas come√ßam a diferir.  Observe que o quinto bit √© 0 na parte superior e 1. na parte inferior, que corresponde ao <i>modo direto</i> ou ao <i>modo de registro</i> .  No modo de registro, o segundo n√∫mero √© armazenado no registro, como o primeiro.  √â marcado como <code>SR2</code> e est√° contido nos bits dois a zero.  Os bits 3 e 4 n√£o s√£o usados.  No assembler, ser√° escrito assim: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  No modo imediato, em vez de adicionar o conte√∫do do registro, o valor imediato √© incorporado na pr√≥pria instru√ß√£o.  Isso √© conveniente porque o programa n√£o precisa de instru√ß√µes adicionais para carregar esse n√∫mero no registro da mem√≥ria.  Em vez disso, ele j√° est√° dentro da instru√ß√£o quando precisamos.  O problema √© que apenas pequenos n√∫meros podem ser armazenados l√°.  Para ser preciso, no m√°ximo 2 <sup>5</sup> = 32.  Isso √© mais √∫til para aumentar contadores ou valores.  No assembler, voc√™ pode escrever assim: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Aqui est√° um trecho da especifica√ß√£o: <br><br><blockquote>  Se o bit [5] for 0, o segundo operando de origem ser√° obtido do SR2.  Se o bit [5] for 1, o segundo operando de origem ser√° obtido expandindo imm5 para 16 bits.  Nos dois casos, o segundo operando de origem √© adicionado ao conte√∫do do SR1 e o resultado √© armazenado no DR.  (p. 526) </blockquote><br>  Isso √© semelhante ao que discutimos.  Mas o que √© uma "extens√£o de significado"?  Embora no modo direto o valor tenha apenas 5 bits, ele precisa ser adicionado com um n√∫mero de 16 bits.  Esses 5 bits devem ser expandidos para 16 para corresponder a outro n√∫mero.  Para n√∫meros positivos, podemos preencher os bits ausentes com zeros e obter o mesmo valor.  No entanto, para n√∫meros negativos, isso n√£o funciona.  Por exemplo, -1 em cinco bits √© <code>1 1111</code> .  Se voc√™ apenas preencher com zeros, obteremos <code>0000 0000 0001 1111</code> , que √© 32!  A expans√£o do valor evita esse problema preenchendo os bits com zeros para n√∫meros positivos e os com n√∫meros negativos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Nota:</b> se voc√™ estiver interessado em n√∫meros bin√°rios negativos, pode ler sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digos adicionais</a> .  Mas isso n√£o √© essencial.  Basta copiar o c√≥digo acima e us√°-lo quando a especifica√ß√£o indicar para expandir o valor. </blockquote><br>  A especifica√ß√£o tem a √∫ltima frase: <br><br><blockquote>  Os c√≥digos de condi√ß√£o s√£o definidos dependendo do resultado ser negativo, zero ou positivo.  (p. 526) </blockquote><br>  Anteriormente, definimos a condi√ß√£o de enumera√ß√£o de sinalizadores e agora √© hora de us√°-los.  Cada vez que um valor √© gravado no registro, precisamos atualizar os sinalizadores para indicar seu sinal.  Escrevemos uma fun√ß√£o para reutiliza√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Agora estamos prontos para escrever o c√≥digo para <code>ADD</code> : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Esta se√ß√£o tem muitas informa√ß√µes, ent√£o vamos resumir. <br><br><ul><li>  <code>ADD</code> pega dois valores e os armazena em um registro. </li><li>  No modo de registro, o segundo valor a ser adicionado est√° no registro. </li><li>  No modo direto, o segundo valor √© incorporado nos 5 bits certos da instru√ß√£o. </li><li>  Valores menores que 16 bits devem ser expandidos. </li><li>  Cada vez que a instru√ß√£o muda de caso, os sinalizadores de condi√ß√£o devem ser atualizados. </li></ul><br>  Voc√™ pode ficar impressionado escrevendo mais 15 instru√ß√µes.  No entanto, as informa√ß√µes obtidas aqui podem ser reutilizadas.  A maioria das instru√ß√µes usa uma combina√ß√£o de expans√£o de valor, v√°rios modos e atualiza√ß√µes de sinalizador. <br><br><h3>  LDI </h3><br>  LDI significa carregamento "indireto" ou "indireto" (carga indireta).  Esta instru√ß√£o √© usada para carregar um valor de um local de mem√≥ria em um registrador.  Especifica√ß√£o na p√°gina 532. <br><br>  Aqui est√° a apar√™ncia do layout bin√°rio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  Ao contr√°rio do <code>ADD</code> , n√£o h√° modos e menos par√¢metros.  Desta vez, o c√≥digo de opera√ß√£o √© <code>1010</code> , que corresponde ao valor da enumera√ß√£o <code>OP_LDI</code> .  Novamente, vemos um <code>DR</code> tr√™s bits (registro de sa√≠da) para armazenar o valor carregado.  Os bits restantes est√£o marcados como <code>PCoffset9</code> .  Este √© o valor imediato incorporado na instru√ß√£o (semelhante ao <code>imm5</code> ).  Como a instru√ß√£o √© carregada da mem√≥ria, podemos supor que esse n√∫mero seja um tipo de endere√ßo que diz de onde carregar o valor.  A especifica√ß√£o explica com mais detalhes: <br><br><blockquote>  O endere√ßo √© calculado expandindo os bits do valor <code>[8:0]</code> para 16 bits e adicionando esse valor ao <code>PC</code> ampliado.  O que √© armazenado na mem√≥ria neste endere√ßo √© o endere√ßo dos dados que ser√£o carregados no <code>DR</code> .  (p. 532) </blockquote><br>  Como antes, voc√™ precisa expandir esse valor de 9 bits, mas desta vez adicion√°-lo ao <code>PC</code> atual.  (Se voc√™ observar o ciclo de execu√ß√£o, o <code>PC</code> aumentou imediatamente ap√≥s o carregamento desta instru√ß√£o).  A soma resultante √© o endere√ßo do local na mem√≥ria e esse endere√ßo <i>cont√©m outro</i> valor, que √© o endere√ßo do valor de carregamento. <br><br>  Pode parecer uma maneira indireta de ler da mem√≥ria, mas √© necess√°rio.  A instru√ß√£o <code>LD</code> √© limitada a um deslocamento de endere√ßo de 9 bits, enquanto a mem√≥ria requer um endere√ßo de 16 bits.  <code>LDI</code> √© √∫til para carregar valores armazenados em algum lugar fora do computador atual, mas para us√°-los, o endere√ßo do local final deve ser armazenado nas proximidades.  Voc√™ pode pensar nisso como uma vari√°vel local em C, que √© um ponteiro para alguns dados: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Como antes, depois de escrever o valor no <code>DR</code> , os sinalizadores devem ser atualizados: <br><br><blockquote>  Os c√≥digos de condi√ß√£o s√£o definidos dependendo do resultado ser negativo, zero ou positivo.  (p. 532) </blockquote><br>  Aqui est√° o c√≥digo para este caso: ( <code>mem_read</code> discutido na pr√≥xima se√ß√£o): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Como eu disse, para esta instru√ß√£o usamos uma parte significativa do c√≥digo e do conhecimento adquirido anteriormente ao escrever <code>ADD</code> .  O mesmo com o restante das instru√ß√µes. <br><br>  Agora voc√™ precisa implementar o restante das instru√ß√µes.  Siga as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√µes</a> e use o c√≥digo j√° escrito.  O c√≥digo para todas as instru√ß√µes √© fornecido no final do artigo.  Dois dos opcodes mencionados anteriormente n√£o ser√£o necess√°rios: <code>OP_RTI</code> e <code>OP_RES</code> .  Voc√™ pode ignor√°-los ou cometer um erro se eles forem chamados.  Quando conclu√≠do, a maior parte da sua VM pode ser considerada completa! <br><br><a name="7"></a><h1>  7. Ber√ßo de acordo com as instru√ß√µes </h1><br>  Esta se√ß√£o cont√©m implementa√ß√µes completas das instru√ß√µes restantes, se voc√™ estiver preso. <br><br><h3>  RTI &amp; RES </h3><br>  (n√£o usado) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bit "And"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bitwise NOT</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Branch </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Jump </h3><br>  <code>RET</code> √© indicado como uma instru√ß√£o separada na especifica√ß√£o, pois esse √© outro comando no assembler.  Este √© realmente um caso especial do <code>JMP</code> .  <code>RET</code> ocorre sempre que <code>R1</code> √© 7. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Jump register </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Carregar </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Registro de carga </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Endere√ßo de carga efetivo </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Loja </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Loja indireta </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Registro de loja </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Procedimentos de manuseio de interrup√ß√£o </h1><br>  O LC-3 fornece v√°rias rotinas predefinidas para executar tarefas comuns e interagir com dispositivos de E / S.  Por exemplo, existem procedimentos para receber linhas de entrada e sa√≠da do teclado no console.  Eles s√£o chamados de rotinas de trap, que voc√™ pode considerar o sistema operacional ou a API do LC-3.  A cada subprograma √© atribu√≠do um c√≥digo de interrup√ß√£o (c√≥digo de intercepta√ß√£o) que o identifica (semelhante a um c√≥digo de opera√ß√£o).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para execut√°-lo, uma instru√ß√£o √© chamada </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o c√≥digo do subprograma desejado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defina enum para cada c√≥digo de interrup√ß√£o: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode estar se perguntando por que os c√≥digos de interrup√ß√£o n√£o est√£o inclu√≠dos nas instru√ß√µes. </font><font style="vertical-align: inherit;">Isso ocorre porque eles realmente n√£o adicionam ao LC-3 nenhuma nova funcionalidade, mas apenas fornecem uma maneira conveniente de concluir a tarefa (como as fun√ß√µes do sistema em C). </font><font style="vertical-align: inherit;">No simulador oficial do LC-3, os c√≥digos de interrup√ß√£o </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o escritos no assembler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Quando um c√≥digo de interrup√ß√£o √© chamado, o computador se move para o endere√ßo desse c√≥digo. </font><font style="vertical-align: inherit;">A CPU executa as instru√ß√µes do procedimento e, ap√≥s a conclus√£o, √© </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redefinida para o local em que a interrup√ß√£o foi acionada.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° especifica√ß√£o sobre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementar rotinas de interrup√ß√£o: exatamente o que elas devem fazer. Em nossa VM, agiremos de maneira um pouco diferente, escrevendo-os em C. Quando o c√≥digo de interrup√ß√£o for chamado, a fun√ß√£o C. ser√° chamada. Ap√≥s sua opera√ß√£o, a instru√ß√£o continuar√°. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora os procedimentos possam ser escritos no assembler e o computador f√≠sico LC-3 o seja, essa n√£o √© a melhor op√ß√£o para a VM. Em vez de escrever seus pr√≥prios procedimentos primitivos de entrada e sa√≠da, voc√™ pode usar os que est√£o dispon√≠veis em nosso sistema operacional. Isso melhorar√° a m√°quina virtual em nossos computadores, simplificar√° o c√≥digo e fornecer√° um n√≠vel mais alto de abstra√ß√£o para portabilidade.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um exemplo espec√≠fico √© a entrada do teclado. </font><font style="vertical-align: inherit;">A vers√£o do assembler usa um loop para verificar continuamente a entrada do teclado. </font><font style="vertical-align: inherit;">Mas tanto tempo do processador √© desperdi√ßado! </font><font style="vertical-align: inherit;">Usando a fun√ß√£o apropriada do sistema operacional, o programa pode dormir tranquilamente antes do sinal de entrada.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No operador de m√∫ltipla escolha para o c√≥digo de opera√ß√£o, </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicione outra op√ß√£o:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como nas instru√ß√µes, mostrarei como implementar um procedimento e fa√ßa o resto voc√™ mesmo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo de interrup√ß√£o √© </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado para retornar uma string com um zero final (da mesma forma </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em C). </font><font style="vertical-align: inherit;">Especifica√ß√£o na p√°gina 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir uma sequ√™ncia, devemos atribuir √† rotina de interrup√ß√£o uma sequ√™ncia a ser exibida. </font><font style="vertical-align: inherit;">Isso √© feito armazenando o endere√ßo do primeiro caractere </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes do in√≠cio do processamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir da especifica√ß√£o:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exiba a cadeia de caracteres ASCII na tela do console. </font><font style="vertical-align: inherit;">Os caracteres est√£o contidos em c√©lulas de mem√≥ria consecutivas, um caractere por c√©lula, iniciando no endere√ßo especificado em </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A sa√≠da termina quando um valor √© encontrado na mem√≥ria </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(p. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, diferentemente das cadeias C, aqui os caracteres s√£o armazenados </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o em um byte, mas em um local na mem√≥ria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A localiza√ß√£o da mem√≥ria do LC-3 √© de 16 bits, portanto, cada caractere na sequ√™ncia √© de 16 bits. </font><font style="vertical-align: inherit;">Para exibir isso na fun√ß√£o C, voc√™ precisa converter cada valor em um caractere e imprimi-los separadamente.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada mais √© necess√°rio para este procedimento. </font><font style="vertical-align: inherit;">As rotinas de interrup√ß√£o s√£o bem diretas se voc√™ conhece C. Agora, volte para as especifica√ß√µes e implemente o restante. </font><font style="vertical-align: inherit;">Como nas instru√ß√µes, o c√≥digo completo pode ser encontrado no final deste guia.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Folha de dicas para rotinas de interrup√ß√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta se√ß√£o cont√©m implementa√ß√µes completas das rotinas de interrup√ß√£o restantes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrada de caracteres </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sa√≠da de caracteres </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solicita√ß√£o de entrada de caracteres </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sa√≠da de linha </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encerramento do Programa </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Baixando Programas </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falamos muito sobre carregar e executar instru√ß√µes da mem√≥ria, mas como as instru√ß√µes entram na mem√≥ria em geral? </font><font style="vertical-align: inherit;">Ao converter um programa assembler em c√≥digo de m√°quina, o resultado √© um arquivo que cont√©m uma matriz de instru√ß√µes e dados. </font><font style="vertical-align: inherit;">Para fazer o download, basta copiar o conte√∫do diretamente para um endere√ßo na mem√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os primeiros 16 bits do arquivo de programa indicam o endere√ßo na mem√≥ria onde o programa deve iniciar. </font><font style="vertical-align: inherit;">Este endere√ßo √© chamado de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">origem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ele deve ser lido primeiro, ap√≥s o qual o restante dos dados √© lido na mem√≥ria do arquivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° o c√≥digo para carregar o programa na mem√≥ria LC-3:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que para cada valor carregado √© chamado </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Os programas LC-3 s√£o escritos em ordem direta de bytes, mas a maioria dos computadores modernos usa a ordem inversa. </font><font style="vertical-align: inherit;">Como resultado, precisamos inverter cada um carregado </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Se voc√™ acidentalmente usar um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computador estranho</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nada precisar√° ser alterado).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: A </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordem dos bytes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> refere-se √† forma como os bytes de um n√∫mero inteiro s√£o interpretados. </font><font style="vertical-align: inherit;">Na ordem inversa, o primeiro byte √© o d√≠gito menos significativo e, na ordem inversa, vice-versa. </font><font style="vertical-align: inherit;">Tanto quanto sei, a decis√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© principalmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitr√°ria. </font><font style="vertical-align: inherit;">Empresas diferentes tomaram decis√µes diferentes, agora temos implementa√ß√µes diferentes. </font><font style="vertical-align: inherit;">Para este projeto, voc√™ n√£o precisa mais saber nada sobre a ordem de bytes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione tamb√©m uma fun√ß√£o conveniente para </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que segue o caminho da string:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Registros mapeados </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns registros especiais n√£o est√£o dispon√≠veis na tabela de registros regulares. Em vez disso, um endere√ßo especial √© reservado para eles na mem√≥ria. Para ler e gravar nesses registros, basta ler e escrever na mem√≥ria deles. Eles s√£o chamados </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de registros mapeados na mem√≥ria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Geralmente eles s√£o usados ‚Äã‚Äãpara interagir com dispositivos de hardware especiais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o nosso LC-3, precisamos implementar dois registros mape√°veis. Este √© o registro de status do teclado ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e o registro de dados do teclado ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). O primeiro indica se a tecla foi pressionada e o segundo determina qual tecla foi pressionada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora seja poss√≠vel solicitar a entrada do teclado </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ela bloqueia a execu√ß√£o at√© que a entrada seja recebida. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permitir</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrogar o estado do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dispositivo enquanto continua a executar o programa, para que ele permane√ßa responsivo enquanto aguarda a entrada.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registradores mapeados complicam um pouco o acesso √† mem√≥ria. </font><font style="vertical-align: inherit;">N√£o podemos ler e gravar diretamente na matriz de mem√≥ria, mas, em vez disso, devemos chamar fun√ß√µes especiais - setter e getter. </font><font style="vertical-align: inherit;">Depois de ler a mem√≥ria do registro KBSR, o getter verifica o teclado e atualiza os dois locais na mem√≥ria.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© o √∫ltimo componente de uma m√°quina virtual! </font><font style="vertical-align: inherit;">Se voc√™ implementou o restante das rotinas e instru√ß√µes de interrup√ß√£o, est√° quase pronto para experiment√°-lo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo o que foi escrito deve ser adicionado ao arquivo C na seguinte ordem:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Recursos da plataforma </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta se√ß√£o cont√©m alguns detalhes tediosos necess√°rios para acessar o teclado e funcionar corretamente. </font><font style="vertical-align: inherit;">N√£o h√° nada de interessante ou informativo sobre a opera√ß√£o de m√°quinas virtuais. </font><font style="vertical-align: inherit;">Sinta-se copiar e colar gratuitamente! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ estiver tentando iniciar a VM em um sistema operacional diferente do Unix, como o Windows, essas fun√ß√µes dever√£o ser substitu√≠das pelas fun√ß√µes correspondentes do Windows.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo para extrair o caminho dos argumentos do programa e gerar um exemplo de uso, se estiverem ausentes. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo de configura√ß√£o de entrada do terminal espec√≠fico do Unix. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando o programa √© interrompido, queremos retornar o console √†s suas configura√ß√µes normais. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicializa√ß√£o da m√°quina virtual </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora voc√™ pode criar e executar a m√°quina virtual LC-3! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile o </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programa com seu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilador favorito.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixe a vers√£o compilada de </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execute o programa com o arquivo obj como argumento: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jogue em 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depura√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o programa n√£o funcionar corretamente, provavelmente voc√™ codificou incorretamente algum tipo de instru√ß√£o. </font><font style="vertical-align: inherit;">Pode ser dif√≠cil depurar. </font><font style="vertical-align: inherit;">Eu recomendo que voc√™ leia o c√≥digo de montagem do programa ao mesmo tempo - e com a ajuda do depurador, siga as instru√ß√µes passo a passo da m√°quina virtual, uma de cada vez. </font><font style="vertical-align: inherit;">Ao ler o c√≥digo, verifique se a VM vai para a instru√ß√£o pretendida. </font><font style="vertical-align: inherit;">Se ocorrer uma incompatibilidade, voc√™ descobrir√° qual instru√ß√£o causou o problema. </font><font style="vertical-align: inherit;">Releia a especifica√ß√£o e verifique novamente o c√≥digo.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. M√©todo alternativo em C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° uma maneira avan√ßada de executar instru√ß√µes que reduzem significativamente o tamanho do c√≥digo. Esta √© uma se√ß√£o completamente opcional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o C ++ suporta gen√©ricos poderosos durante o processo de compila√ß√£o, podemos criar partes das instru√ß√µes usando o compilador. Esse m√©todo reduz a duplica√ß√£o de c√≥digo e, na verdade, est√° mais pr√≥ximo do n√≠vel de hardware do computador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A id√©ia √© reutilizar as etapas comuns a cada instru√ß√£o. Por exemplo, algumas instru√ß√µes usam endere√ßamento indireto ou extens√£o de um valor e adicionam-no ao valor atual </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Concorda, seria bom escrever este c√≥digo uma vez para todas as instru√ß√µes?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considerando a instru√ß√£o como uma sequ√™ncia de etapas, vemos que cada instru√ß√£o √© apenas um rearranjo de v√°rias etapas menores. </font><font style="vertical-align: inherit;">Usaremos sinalizadores de bits para indicar quais etapas a seguir para cada instru√ß√£o. </font><font style="vertical-align: inherit;">O valor </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no bit do n√∫mero da instru√ß√£o indica que, para esta instru√ß√£o, o compilador deve incluir esta se√ß√£o do c√≥digo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eu aprendi sobre essa t√©cnica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no emulador NES desenvolvido pela Bisqwit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se voc√™ est√° interessado em emula√ß√£o ou NES, recomendo seus v√≠deos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras vers√µes do C ++ usam o c√≥digo j√° escrito. </font><font style="vertical-align: inherit;">Vers√£o completa </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434138/">https://habr.com/ru/post/pt434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434128/index.html">PHP Digest No. 146 (10 a 24 de dezembro de 2018) + Resultados de 2018</a></li>
<li><a href="../pt434130/index.html">Interface reativa. Palestra de Artyom Belov no FrontTalks 2018</a></li>
<li><a href="../pt434132/index.html">Compre uma TV e enrole-a: LG planeja come√ßar a vender TVs flex√≠veis no pr√≥ximo ano</a></li>
<li><a href="../pt434134/index.html">An√°lise dos resultados da Pesquisa Kaggle ML & DS 2018</a></li>
<li><a href="../pt434136/index.html">Anatomia Corporativa</a></li>
<li><a href="../pt434140/index.html">Uma Breve Hist√≥ria dos Recursos Ass√≠ncronos Javascript</a></li>
<li><a href="../pt434142/index.html">A equipe da QRL estabeleceu um prazo apertado para a migra√ß√£o de token</a></li>
<li><a href="../pt434146/index.html">Os 10 melhores filmes de TI</a></li>
<li><a href="../pt434150/index.html">Caracter√≠sticas da procura de emprego na Europa</a></li>
<li><a href="../pt434154/index.html">Conjunto de dados de ano novo 2018: sem√¢ntica aberta do idioma russo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>