<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏾 👑 🤦🏼 现代C ++中的初始化 🚬 🤰🏾 🆗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="众所周知，初始化语义是C ++最复杂的部分之一。 初始化的类型很多，用不同的语法描述，它们都以复杂而具有挑战性的方式进行交互。 C ++ 11带来了“通用初始化”的概念。 不幸的是，她引入了甚至更复杂的规则，反过来，它们在C ++ 14，C ++ 17中被阻塞，而在C ++ 20中又被更改。 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>现代C ++中的初始化</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469465/"><p><img src="https://habrastorage.org/webt/fy/g7/eb/fyg7ebgmdmbykh6evie2r7gx-zc.jpeg"></p><br><p> 众所周知，初始化语义是C ++最复杂的部分之一。 初始化的类型很多，用不同的语法描述，它们都以复杂而具有挑战性的方式进行交互。  C ++ 11带来了“通用初始化”的概念。 不幸的是，她引入了甚至更复杂的规则，反过来，它们在C ++ 14，C ++ 17中被阻塞，而在C ++ 20中又被更改。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C + +俄罗斯</a>会议上，Timur Doumler报告的视频和翻译被削减了。  Timur首先总结了C ++中初始化演变的历史结果，对初始化规则的当前版本，典型问题和意外之处进行了系统的概述，解释了如何有效使用所有这些规则，最后讨论了可以使初始化语义成为标准的新建议。 C ++ 20更加方便。 这个故事进一步代表了他。 </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>目录</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">默认初始化（C）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复制初始化（C）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚合初始化（C）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">静态初始化（C）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直接初始化（C ++ 98）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">值初始化（C ++ 03）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通用初始化（C ++ 11）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ 14的改进</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在C ++中正确初始化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分配的初始化（C ++ 20）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ 20中的更正</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚合类型的直接初始化（C ++ 20）</a> </li></ul><br><p><img src="https://habrastorage.org/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif"></p><br><p> 您现在看到的gif很好地传达了报告的主要信息。 大约六个月前，我在互联网上找到了它，并将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布</a>在我的Twitter上。 在给她的评论中，有人说缺少三种初始化类型。 开始进行讨论，在此期间我被邀请报告。 这样就开始了。 </p><br><p> 关于初始化Nikolay Yossutis已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">告诉过</a> 。 他的报告包括一张幻灯片，该幻灯片列出了初始化int的19种不同方式： </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-comment"><span class="hljs-comment">//undefined value int i2 = 42; //note: inits with 42 int i3(42); //inits with 42 int i4 = int(); //inits with 42 int i5{42}; //inits with 42 int i6 = {42}; //inits with 42 int i7{}; //inits with 0 int i8 = {}; //inits with 0 auto i9 = 42; //inits with 42 auto i10{42}; //C++11: std::initializer_list&lt;int&gt;, C++14: int auto i11 = {42}; //inits std::initializer_list&lt;int&gt; with 42 auto i12 = int{42}; //inits int with 42 int i13(); //declares a function int i14(7, 9); //compile-time error int i15 = (7, 9); //OK, inits int with 9 (comma operator) int i16 = int(7, 9); //compile-time error int i17(7, 9); //compile-time error auto i18 = (7, 9); //OK, inits int with 9 (comma operator) auto i19 = int(7, 9); //compile-time error</span></span></code> </pre> <br><p> 在我看来，这是编程语言的一种独特情况。 初始化变量是最简单的操作之一，但是在C ++中，这并非易事。 这种语言不太可能具有其他领域，近年来在该领域中将有尽可能多的关于偏离标准，更正和变更的报告。 初始化规则在标准之间变化，并且Internet上有无数关于如何在C ++中进行初始化的文章。 因此，对其进行系统的审查不是一件容易的事。 </p><br><p> 我将按时间顺序介绍材料：首先，我们将讨论从C继承的内容，然后是C ++ 98，然后是C ++ 03，C ++ 11，C ++ 14和C ++ 17。 我们将讨论常见的错误，并就正确的初始化提出建议。 我还将讨论C ++ 20中的创新。 报告末尾将显示一个概述表。 </p><br><a name="a1"></a><br><h1 id="inicializaciya-po-umolchaniyu-s"> 默认初始化（C） </h1><br><p> 在C ++中，很多东西都是从C继承的，这就是为什么我们将从它开始。 有几种方法可以在C中初始化变量。 它们可能根本不被初始化，这称为<em>默认初始化</em> 。 我认为这是一个不幸的名字。 事实是，没有为变量分配默认值，只是没有初始化。 如果在C ++和C中使用未初始化的变量，则会得到未定义的行为： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-comment"><span class="hljs-comment">// undefined behaviour }</span></span></code> </pre> <br><p> 自定义类型也是如此：如果在某些<code>struct</code>存在未初始化的字段，则在访问它们时，也会发生未定义的行为： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.i; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  C ++中已添加了许多新的构造：类，构造函数，公共，私有，方法，但这些都不会影响上述行为。 如果某些元素未在类中初始化，则在访问它时会发生未定义的行为： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_j</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.get_i(); <span class="hljs-comment"><span class="hljs-comment">// Undefined behaviour! }</span></span></code> </pre> <br><p> 默认情况下，没有神奇的方法可以在C ++中初始化类元素。 这是一个有趣的观点，在我从事C ++的职业生涯的最初几年中，我并不知道这一点。 我当时使用的编译器和IDE都没有以任何方式提醒我这一点。 我的同事在检查代码时没有注意此功能。 我非常确定，由于她的原因，这些年来我编写的代码中存在一些非常奇怪的错误。 在我看来，类应该初始化其变量似乎很明显。 </p><br><p> 在C ++ 98中，可以使用成员初始化器列表初始化变量。 但是，这种问题的解决方案并不是最佳的，因为它必须在每个构造函数中完成，而且这很容易忘记。 另外，初始化以声明变量的顺序进行，而不是以成员初始化列表的顺序进行： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++98: member initialiser list class Widget { public: Widget() : i(0), j(0) {} // member initialiser list int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i; int j; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p> 在C ++ 11中，添加了直接成员初始化程序，使用起来更加方便。 它们允许您同时初始化所有变量，这使您可以确信所有元素都已初始化： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11: default member initialisers class Widget { public: Widget() {} int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i = 0; // default member initialisers int j = 0; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p> 我的第一个建议：尽可能使用DMI（直接成员初始化器）。 它们既可以与内置类型（ <code>float</code>和<code>int</code> ）一起使用，也可以与对象一起使用。 初始化元素的习惯使我们更自觉地处理此问题。 </p><br><a name="a2"></a><br><h1 id="kopiruyuschaya-inicializaciya-s"> 复制初始化（C） </h1><br><p> 因此，默认情况下，从C继承的第一个初始化方法是初始化，因此不应使用它。 第二种方法是<em>复制初始化</em> 。 在这种情况下，我们通过等号表示变量-其值： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int main() { int i = 2; }</span></span></code> </pre> <br><p> 当参数按值传递给函数时，或按值从函数返回对象时，也使用复制初始化： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int square(int i) { return i * i; }</span></span></code> </pre> <br><p> 等号可能会给人以分配值的印象，但事实并非如此。 复制初始化不是值分配。 本报告中不会涉及拨款。 </p><br><p> 复制初始化的另一个重要属性：如果值的类型不匹配，则执行转换序列。 转换序列具有某些规则，例如，它不调用显式构造函数，因为它们不转换构造函数。 因此，如果对构造函数标记为显式的对象执行复制初始化，则会发生编译错误： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br><p> 而且，如果存在另一个非显式的构造函数，但类型更糟，则复制初始化将调用它，而忽略该显式的构造函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double)</span></span></code> </pre> <br><a name="a3"></a><br><h1 id="agregatnaya-inicializaciya-s"> 聚合初始化（C） </h1><br><p> 我想谈的第三种初始化类型是<em>聚合初始化</em> 。 当使用括号中的一系列值初始化数组时，将执行该命令： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><p> 如果您未指定数组的大小，则从括号中包含的值的数量派生它： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// array size deduction</span></span></code> </pre> <br><p> 聚合类使用相同的初始化，即，这些类只是公共元素的集合（聚合类的定义中还有其他一些规则，但现在我们不再赘述）： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> j; }; Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p> 此语法甚至在C和C ++ 98中都有效，并且从C ++ 11开始，您可以跳过其中的等号： </p><br><pre> <code class="cpp hljs">Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p> 聚合初始化实际上对每个元素使用副本初始化。 因此，如果您尝试对具有显式构造函数的多个对象使用聚合初始化（均等号和不带等号），则将对每个对象执行复制初始化，并且会发生编译错误： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ERROR Thingy thingy {3, 4}; // ERROR }</span></span></code> </pre> <br><p> 如果这些对象还有另一个非显式的构造函数，则将其调用，即使更不适合键入： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Thingy thingy {3, 4}; //  Widget(double) }</span></span></code> </pre> <br><p> 让我们考虑聚合初始化的另一个属性。 问题：该程序返回什么值？ </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.j; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"><p> 是的，零。 如果在聚合初始化期间跳过值数组中的某些元素，则相应的变量将设置为零。 这是一个非常有用的属性，因为有了它，永远不会有未初始化的元素。 它适用于聚合类和数组： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int[100] = {};</span></span></code> </pre> </div></div><br><p> 聚合初始化的另一个重要属性是省略了方括号（括号省略）。 您认为该程序返回什么价值？ 它有一个<code>Widget</code> ，它是两个<code>int</code>值的集合；还有<code>Thingy</code> ，它是<code>Widget</code>和<code>int</code>的集合。 如果将两个初始化值传递给<code>{1, 2}</code>什么？ </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy t = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tk; <span class="hljs-comment"><span class="hljs-comment">//   ? }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"><p> 答案是零。 在这里，我们正在处理子聚合，即嵌套的聚合类。 可以使用嵌套括号来初始化此类，但是您可以跳过这些括号对之一。 在这种情况下，执行子聚合的递归遍历，结果<code>{1, 2}</code>等效于<code>{{1, 2}, 0}</code> 。 诚然，此属性并不完全明显。 </p></div></div><br><a name="a4"></a><br><h1 id="staticheskaya-inicializaciya-s"> 静态初始化（C） </h1><br><p> 最后， <em>静态初始化</em>也从C继承：静态变量总是被初始化。 这可以通过几种方式来完成。 可以使用常量表达式初始化静态变量。 在这种情况下，初始化发生在编译时。 如果您没有为变量分配任何值，则将其初始化为零： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   statit int j; //   int main() { return i + j; }</span></span></code> </pre> <br><p> 即使<code>j</code>未初始化，该程序也会返回3。 如果变量不是由常量而是由对象初始化的，则可能会出现问题。 </p><br><p> 这是我正在处理的真实库中的示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Colour red = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p> 其中有一个Color类，并且将原色（红色，绿色，蓝色）定义为静态对象。 这是有效的操作，但是一旦在使用<code>red</code>的初始化器中出现另一个静态对象，就会出现不确定性，因为没有初始化变量的严格顺序。 您的应用程序可以访问未初始化的变量，然后崩溃。 幸运的是，在C ++ 11中，可以使用<code>constexpr</code>构造函数，然后我们要处理常量初始化。 在这种情况下，初始化顺序没有问题。 </p><br><p> 因此，从C语言继承了四种初始化类型：默认初始化，复制，聚合和静态初始化。 </p><br><a name="a5"></a><br><h1 id="pryamaya-inicializaciya-s98"> 直接初始化（C ++ 98） </h1><br><p> 让我们继续到C ++ 98。 区别C ++和C的最重要的功能也许是构造函数。 这是构造函数调用的示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p> 使用相同的语法，您可以初始化诸如<code>int</code>和<code>float</code>内置类型。 这种语法称为<em>直接初始化</em> 。 当我们在括号中有一个参数时，它总是被执行。 </p><br><p> 对于内置类型（ <code>int</code> ， <code>bool</code> ， <code>float</code> ），此处与复制初始化没有区别。 如果我们在谈论用户类型，那么与复制初始化不同，直接初始化可以传递多个参数。 实际上，为此，发明了直接初始化。 </p><br><p> 另外，直接初始化不执行转换序列。 而是使用重载分辨率调用构造函数。 直接初始化的语法与函数调用相同，并且使用与其他C ++函数相同的逻辑。 </p><br><p> 因此，在使用显式构造函数的情况下，尽管复制初始化会引发错误，但直接初始化可以正常工作： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w2(1); //   </span></span></code> </pre> <br><p> 在具有两个构造函数的情况下，其中一个构造函数是显式的，而第二个构造函数在类型上不太合适，第一个构造函数是使用直接初始化调用的，第二个构造函数是使用副本调用的。 在这种情况下，更改语法将导致调用另一个构造函数-这通常被忘记： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Widget w2(1); //  Widget(int)</span></span></code> </pre> <br><p> 当使用括号时，总是使用直接初始化，包括使用构造函数调用表示法初始化临时对象时，以及在括号和转换表达式中带有初始化器的<code>new</code>表达式中，都使用直接初始化： </p><br><pre> <code class="cpp hljs">useWidget(Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   auto* widget_ptr = new Widget(2, 3); // new-expression with (args) static_cast&lt;Widget&gt;(thingy); // cast</span></span></code> </pre> <br><p> 只要C ++本身存在，该语法就存在，并且它有一个重要的缺陷，Nikolai在主题演讲中提到了： <em>最令人烦恼的解析</em> 。 这意味着编译器可以将所有内容读为声明（声明），而将其读为声明。 </p><br><p> 考虑一个示例，其中有一个<code>Widget</code>类和一个<code>Thingy</code>类，以及一个接收<code>Widget</code>的<code>Thingy</code>构造函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Thingy(Widget) {} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Thingy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget())</span></span></span></span>; }</code> </pre> <br><p> 乍一看，似乎在<code>Thingy</code>初始化时，将创建的默认<code>Widget</code>传递给它，但实际上，该函数在此处声明。 此代码声明一个函数，该函数接收另一个函数作为输入，该函数不接收任何输入作为输入，并返回<code>Widget</code> ，而第一个函数返回<code>Thingy</code> 。 该代码编译没有错误，但是我们不太可能寻求这种行为。 </p><br><a name="a6"></a><br><h1 id="inicializaciya-znacheniem-c03"> 值初始化（C ++ 03） </h1><br><p> 让我们继续下一个版本-C ++ 03。 通常认为此版本没有重大更改，但事实并非如此。 在C ++ 03中，出现了值初始化，其中写入了空括号： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// UB  C++98, 0   C++03 }</span></span></code> </pre> <br><p> 在C ++ 98中，这里会发生未定义的行为，因为默认情况下会进行初始化，并且从C ++ 03开始，此程序将返回零。 </p><br><p> 规则是这样的：如果存在用户定义的默认构造函数，则使用值进行初始化会调用此构造函数，否则返回零。 </p><br><p> 使用自定义构造函数更详细地考虑这种情况： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Widget(); <span class="hljs-comment"><span class="hljs-comment">// value initialization } int main() { return get_widget().i; }</span></span></code> </pre> <br><p> 在此程序中，该函数初始化新<code>Widget</code>的值并返回它。 我们调用此函数并访问<code>Widget</code>对象的元素<code>i</code> 。 从C ++ 03开始，由于没有用户定义的默认构造函数，因此此处的返回值为零。 如果存在这样的构造函数，但没有初始化<code>i</code> ，那么我们将得到未定义的行为： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {} <span class="hljs-comment"><span class="hljs-comment">//   int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //   ,  UB }</span></span></code> </pre> <br><p> 值得注意的是，“用户定义”并不意味着“用户定义”。 这意味着用户必须提供构造函数的主体，即花括号。 如果在上面的示例中，将构造函数主体替换为<code>= default</code> （此功能已在C ++ 11中添加），则程序的含义将更改。 现在我们有了一个由用户定义的构造函数（用户定义），但是没有由用户提供的构造函数（用户提供），因此程序返回零： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// user-defined,   user-provided int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //  0 }</span></span></code> </pre> <br><p> 现在，让我们尝试<code>Widget() = default</code>移出类。 程序的含义再次更改： <code>Widget() = default</code>如果在类之外，则认为它是用户提供的构造函数。 程序再次返回未定义的行为。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; Widget::Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  user-provided Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //    , UB }</span></span></code> </pre> <br><p> 有一定的逻辑：在类外部定义的构造函数可以在另一个翻译单元内部。 编译器可能看不到此构造函数，因为它可能在另一个<code>.cpp</code>文件中。 因此，编译器无法得出关于此类构造函数的任何结论，也无法将带有主体的构造函数与<code>= default</code>的构造函数区分开。 </p><br><a name="a7"></a><br><h1 id="universalnaya-inicializaciya-c11"> 通用初始化（C ++ 11） </h1><br><p>  C ++ 11中有许多非常重要的更改。 特别是，引入了通用（统一）初始化，我更喜欢将其称为“独角兽初始化”，因为它很神奇。 让我们看看她为什么出现。 </p><br><p> 正如您已经注意到的那样，在C ++中，有许多具有不同行为的不同初始化语法。 带有括号的烦人的语法分析带来了许多不便。 开发人员也不喜欢聚合初始化只能用于数组，而不能用于<code>std::vector</code>类的容器。 相反，您必须执行<code>.reserve</code>和<code>.push_back</code> ，或使用各种令人毛骨悚然的库： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  : std::vector&lt;int&gt; vec = {0, 1, 2, 3, 4}; //   : std::vector&lt;int&gt; vec; vec.reserve(5); vec.push_back(0); vec.push_back(1); vec.push_back(2); vec.push_back(3); vec.push_back(4);</span></span></code> </pre> <br><p> 该语言的创建者试图通过使用大括号但不带等号的语法来解决所有这些问题。 假定这对于所有类型都是单一语法，其中使用花括号，并且不存在令人烦恼的解析问题。 在大多数情况下，此语法会起作用。 </p><br><p> 这种新的初始化称为<em>列表初始化</em> ，它有两种类型：直接和复制。 在第一种情况下，仅使用花括号，在第二种情况下，使用等号的花括号： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// direct-list-initialization Widget widget{1, 2}; // copy-list-initialization Widget widget = {1, 2};</span></span></code> </pre> <br><p> 用于初始化的列表称为<em>braced-init-list</em> 。 重要的是此列表不是对象；它没有类型。 从早期版本切换到C ++ 11不会对聚合类型造成任何问题，因此此更改并不重要。 但是现在括号中的列表具有新功能。 尽管没有类型，但可以将其隐藏转换为<code>std::initializer_list</code> ，它是一种特殊的新类型。 并且如果有一个接受<code>std::initializer_list</code>作为输入的构造函数，则此构造函数称为： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... vector(std::initializer_list&lt;T&gt; init); //   initializer_list }; std::vector&lt;int&gt; vec{0, 1, 2, 3, 4}; //  ^ </span></span></code> </pre> <br><p> 在我看来，从C ++委员会的角度来看， <code>std::initializer_list</code>不是最成功的解决方案。 对他来说弊大于利。 </p><br><p> 首先， <code>std::initializer_list</code>是带有<code>const</code>元素的固定大小的向量。 也就是说，它是一种类型，它具有迭代器返回的<code>begin</code>和<code>end</code>函数，它具有自己的迭代器类型，要使用它，您需要包括一个特殊的标头。 由于<code>std::initializer_list</code>元素是<code>const</code> ，因此无法移动，因此，如果上面代码中的<code>T</code>为仅移动类型，则该代码将不会执行。 </p><br><p> 接下来， <code>std::initializer_list</code>是一个对象。 实际上，我们使用它来创建和传输对象。 通常，编译器可以对此进行优化，但是从语义的角度来看，我们仍然处理不必要的对象。 </p><br><p> 几个月前，Twitter上进行了一项民意调查：如果您可以回到过去并从C ++中删除某些内容，那么您将删除哪些内容？ 所有投票中的大多数都恰好收到了<code>initializer_list</code> 。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://twitter.com/shafikyaghmour/status/1058031143935561728</a> </p><br><p>         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>   initializer_list</code></a> .         ,     . </p><br><p>  ,    .   ,     <code>initializer_list</code> ,              .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0, 0, 0 std::vector&lt;int&gt; v{3, 0}; //   3, 0</span></span></code> </pre> <br><p>   <code>vector</code>    <code>int</code>    ,    ,      ,   —  .       .       ,   <code>initializer_list</code>        , 3  0. </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">48</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" std::string s{48, 'a'}; // "0a"</span></span></code> </pre> <br><p>       48  «»,     «0».   ,   <code>string</code>    <code>initializer_list</code>  . 48   ,     .  ASCII  48 —   «0».   ,    ,    , <code>int</code>  <code>char</code> .         .    ,       ,   . </p><br><p>       .   ,    ?    ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;{N}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;().size(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>      ,    — 3.   <code>string</code>   <code>int</code> ,   1,    <code>std::vector&lt;std::int&gt;</code>   <code>initializer_list</code> .         <code>initializer_list</code> ,   .    <code>string</code>  <code>int</code>  <code>float</code> ,     ,  .      ,     . ,     emplace ,          .  ,     <code>{}</code>    . </p></div></div><br><p>   ,     . </p><br><p>         <br> . <br>    —   ( <code>{a}</code> )  <br>   ( <code>= {a}</code> ); <br>      : </p><br><ol><li>  «»   ,   <code>std::initializer_list</code> . <br>         —  . </li><li>    ,   <br>   <code>()</code>    . </li></ol><br><p>      . </p><br><p>  1:   <code>= {a}</code> ,      <code>a</code> , <br>     . </p><br><p>  2:   , <code>{}</code> . <br>           ,   <code>initializer_list</code> . <br>     <code>Widget&lt;int&gt; widget{}\</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Typename&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; widget{}; <span class="hljs-comment"><span class="hljs-comment">//    ? }</span></span></code> </pre> <br><p>  ,    ,  <code>initializer_list</code> ,      <code>initializer_list</code>   .        .      ,  ,  <code>initializer_list</code> .     ,   .  ,     . </p><br><p>       <code>{}</code> . , -,  ,   <code>Widget() = default</code>  <code>Widget() {}</code>    —     . </p><br><p> <code>Widget() = default</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{}; <span class="hljs-comment"><span class="hljs-comment">//   (),   vexing parse return widget.i; //  0 }</span></span></code> </pre> <br><p> <code>Widget() {}</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {}; <span class="hljs-comment"><span class="hljs-comment">// user-provided  int i; }; int main() { Widget widget{}; //  ,    return widget.i; //  ,  UB }</span></span></code> </pre> <br><p>      :   ,    (narrowing conversions).    <code>int</code>  <code>double</code> ,    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{<span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre> <br><p>    ,       <code>double</code> .   C++11,         ,      .          : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   ++11    C++98/03 }</span></span></code> </pre> <br><p> ,        , ,     ,       (brace elision).   ,       ,   . ,    <code>map</code> .       <code>map</code> ,     —  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; my_map {{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>   ,      .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; v1 {<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::vector&lt;std::string&gt; v2 {{"abc", "def"}}; // ??</span></span></code> </pre> <br><p> ,    ,     <code>initializer_list</code> .      <code>initializer_list</code>   ,   , ,     .           ,   .  , . </p><br><p>  <code>initializer_list</code>     —  <code>initializer_list</code> ,        .     ,    <code>const char*</code> . ,  <code>string</code>  ,     <code>char</code>    .        .     ,     ,   . </p><br><p> : </p><br><ul><li>       ; </li><li>       . </li></ul><br><p>  .    braced-init-list     .    : </p><br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// copy-list    } void f2(Widget); f2({3, 0}); // copy-list  </span></span></code> </pre> <br><p>     ,    ,    braced-init-list    .    braced-init-list ,       . </p><br><p> ,          .  StackOverflow   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,             . ,      .      ,      ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct A { A() {} A(const A&amp;) {} }; struct B { B(const A&amp;) {} }; void f(const A&amp;) { std::cout &lt;&lt; "A" &lt;&lt; std::endl; } void f(const B&amp;) { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } int main() { A a; f( {a} ); // A f( {{a}} ); // ambiguous f( {{{a}}} ); // B f({{{{a}}}}); // no matching function }</span></span></span></span></code> </pre> <br><a name="a8"></a><br><h1 id="uluchsheniya-v-s14">   ++14 </h1><br><p> ,      C++11 .      ,   ,        .    C++14.      ,    . </p><br><p> ,  ++11       direct member initializers,     .      ,  direct member initializers  .   ++14,      direct member initializers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    C++14</span></span></code> </pre> <br><p>        ,    <code>auto</code> .   ++11  <code>auto</code>  braced-init-list,       <code>std::initializer_list</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int int i(3); // int int i{3}; // int int i = {3}; // int auto i = 3; // int auto i(3); // int auto i{3}; //  ++11 — std::initializer_list&lt;int&gt; auto i = {3}; //  ++11 — std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p>   :   <code>auto i{3}</code> ,     <code>int</code> ,   <code>std::initializer_list&lt;int&gt;</code> .  ++14   ,  <code>auto i{3}</code>    <code>int</code> .          ,     . , <code>auto i = {3}</code>    <code>std::initializer_list&lt;int&gt;</code> .  ,     :      <code>int</code> ,     — <code>initializer_list</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int auto i(3); // int auto i{3}; //  ++14 — int,         auto i = {3}; //    std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p> ,  C++14      ,      ,  ,     ,       .   ,     . </p><br><p>     ,  ++14      : </p><br><ul><li><p>   ,   ,  <code>std::initializer_list</code> . </p><br></li><li><p>  <code>std::initializer_list</code>    move-only . </p><br></li><li><p>  c   ,  <code>emplace</code>  <code>make_unique</code>     . </p><br></li><li><p>    ,     : </p><br><ul><li>      ,  -; </li><li>       ; </li><li> auto     . </li></ul><br></li><li><p> ,    ,        . </p><br></li></ul><br><p>   : <code>assert(Widget(2,3))</code> ,  <code>assert(Widget{2,3})</code>  .   ,      ,       ,        .           ,     .    . </p><br><a name="a9"></a><br><h1 id="kak-pravilno-inicializirovat-v-c">     C++ </h1><br><p>       ,      ++. </p><br><p>     <code>int</code>   , . .     —      ,          . </p><br><p>      :   ,   ,  <code>std::initializer_list</code> ,   direct member initializers.          ,       . </p><br><p>  ,         é .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; setPosition(Point{<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget(Widget{});</code> </pre> <br><p>        braced-init-list —      . </p><br><pre> <code class="cpp hljs">setPosition({<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget({});</code> </pre> <br><p>      ,       ,    .   ,         —  ,       .  ,     ,     ,    ,   ,    .    ,   ,     <code>initializer_list</code> .        :     ,  ,   . </p><br><p>   : </p><br><ul><li><p> <code>= value</code>    </p><br></li><li><p> <code>= {args}</code>  <code>= {}</code> : </p><br><ul><li>    </li><li>    <code>std::initializer_list</code> </li><li>  direct member initialisation (    <code>(args)</code> ) </li></ul><br></li><li><p> <code>{args}</code>  <code>{}</code>     é  </p><br></li><li><p> <code>(args)</code>    </p><br></li></ul><br><p> ,   <code>(args)</code>     vexing parse.        .    2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,   ,          <code>auto</code> .     ,        :   <code>auto i;</code> —    .     ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>   ,        .  ,           ,     vexing parse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> thingy = Thingy();</code> </pre> <br><p>      «  auto» («almost always auto», AAA),   ++11  ++14       , , ,     <code>std::atomic&lt;int&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++11/14:  // std::atomic is neither copyable nor movable</span></span></code> </pre> <br><p>   ,  atomic    .   ,          ,    ,    ,       .  ++17    ,    ,      (guaranteed copy elision): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++17: OK, guaranteed copy elision</span></span></code> </pre> <br><p>        <code>auto</code> .   —  direct member initializers.     <code>auto</code>  . </p><br><p>  ++17    CTAD (class template argument deduction). ,              .        .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  CppCon,   CTAD</a> ,       .   ,  ++17   ,    ++11  ++14,   ,       .     ,    , ,   ,      . </p><br><a name="a10"></a><br><h1 id="naznachennaya-inicializaciya-s20">   (++20) </h1><br><p>     ++20,     .  ,  ,          : <em> </em> (designated initialization): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, .c = <span class="hljs-number"><span class="hljs-number">7</span></span>}; };</code> </pre> <br><p>  ,      .         ,      ,      .        ,       .      <code></code>  <code></code> ,  <code>b</code>  . </p><br><p>      ,  ,     ,     .       ,         . </p><br><p>       ,    ,   99,   : </p><br><ul><li><p>       ,         ,   .  ++   ,     ,    . : </p><br><pre> <code class="cpp hljs">Widget widget{.c = <span class="hljs-number"><span class="hljs-number">7</span></span>, .a = <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  ,     . </p><br></li><li><p>  ++      ,     <code>{.ce = 7};</code> ,    <code>{.c{.e = 7}}</code> : </p><br><pre> <code class="cpp hljs">Widget widget{.ce = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       ,      ,      : </p><br><pre> <code class="cpp hljs">Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       . , -,   ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>]{.[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li></ul><br><a name="a11"></a><br><h1 id="ispravleniya-v-c20">   C++20 </h1><br><p>      ++20       ,        .     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wg21.link/p1008</a> ). </p><br><p>   ++17    ,    ,        .             ,    ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; Widget widget1; <span class="hljs-comment"><span class="hljs-comment">//  Widget widget2{}; //   C++17,     C++20</span></span></code> </pre> <br><p>    ,       ,      .  ++20   .        ,              .  ,   .       ,    ,     ,   . </p><br><p>         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wg21.link/p1009</a> ). Braced-init-list     <code>new</code> ,   :        ,    ?  — ,    : braced-init-list      <code>new</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK double* p = new double[]{1, 2, 3}; //   C++17,   C++20</span></span></code> </pre> <br><p>    ,   ++11  braced-init-list.  ++   .        ,       . </p><br><a name="a12"></a><br><h1 id="pryamaya-inicializaciya-agregatnyh-tipov-c20">     (C++20) </h1><br><p> ,  ++20      .       ,             .  ++20  :         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wg21.link/p0960</a> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   C++20</span></span></code> </pre> <br><p>            .   ,        <code>emplace</code>  <code>make_unique</code> .      .  :   <code>auto</code> ,          : <em>58.11</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>   ,   :   uniform  2.0.     .         ,    , ,  ,           .  —  <code>initializer_list</code> :    ,    ,   — .    ,    .  ,   -     ,   — .       . </p><br><p> ,    .   direct member initializers.   <code>auto</code> .      direct member initializers —  ,    .   ,        .         — ,     . </p><br><p>    ,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .     —  ,   —  .     ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b8d/8a2/229/b8d8a2229e93baf65b78f738750ac635.png"></p><br><blockquote>   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C++ Russia 2019 Piter</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«Type punning in modern C++»</a> .     ,   ++20,  ,    ,    «»  ++  ,    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469465/">https://habr.com/ru/post/zh-CN469465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469455/index.html">从Nginx迁移到Envoy代理</a></li>
<li><a href="../zh-CN469457/index.html">盛会的去向</a></li>
<li><a href="../zh-CN469459/index.html">在智慧城市中连接物联网设备</a></li>
<li><a href="../zh-CN469461/index.html">“献给星星”：反宇宙的“今日启示录”</a></li>
<li><a href="../zh-CN469463/index.html">自然语言处理的趋势和预测</a></li>
<li><a href="../zh-CN469467/index.html">C ++与C＃</a></li>
<li><a href="../zh-CN469471/index.html">“ 5美分”谈排序</a></li>
<li><a href="../zh-CN469475/index.html">Flash的兴衰，是塑造现代网络的烦人插件</a></li>
<li><a href="../zh-CN469477/index.html">苹果该停止将iPad与PC进行比较了</a></li>
<li><a href="../zh-CN469479/index.html">量子概率从何而来</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>