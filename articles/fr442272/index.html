<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 👩🏽‍🔧 📧 Aller + = versionner le package 🎅🏾 ↩️ 👩🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article écrit en février 2018. 

 Go doit ajouter le contrôle de version des packages. 

 Plus précisément, vous devez ajouter le concept de versionin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aller + = versionner le package</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442272/"> <i><font color="gray">Article écrit en février 2018.</font></i> <br><br>  Go doit ajouter le contrôle de version des packages. <br><br>  Plus précisément, vous devez ajouter le concept de versioning au dictionnaire de travail et aux outils des développeurs Go afin que tout le monde utilise les mêmes numéros de version lorsqu'ils mentionnent le programme à créer, exécuter ou analyser.  La commande <code>go</code> doit indiquer exactement quelles versions de quels packages se trouvent dans un assembly particulier. <br><br>  La numérotation des versions vous permet de créer des assemblages reproductibles: si je publie la dernière version de mon programme, vous obtiendrez non seulement la dernière version de mon code, mais aussi les mêmes versions exactes de tous les packages dont mon code dépend, afin que nous créons des fichiers binaires complètement équivalents. <br><br>  Le contrôle de version garantit également que demain le programme sera construit exactement de la même manière qu'aujourd'hui.  Même si de nouvelles versions des dépendances sont publiées, <code>go</code> ne les utilisera pas sans une commande spéciale. <br><a name="habracut"></a><br>  Bien que vous deviez ajouter un contrôle de version, vous ne devez pas renoncer aux principaux avantages de la commande <code>go</code> : c'est la simplicité, la vitesse et la compréhensibilité.  Aujourd'hui, de nombreux programmeurs ne font pas attention aux versions et tout fonctionne bien.  Si vous faites le bon modèle, les programmeurs ne feront <i>toujours</i> pas attention aux numéros de version, tout fonctionnera mieux et deviendra plus clair.  Les workflows existants changeront à peine.  La sortie de nouvelles versions est très simple.  En général, le contrôle de version doit être abandonné et ne pas détourner l'attention du développeur. <br><br>  En bref, vous devez ajouter un contrôle de version du package, mais ne pas rompre.  Dans cet article, nous suggérons comment procéder, et présentons également un prototype que vous pouvez essayer maintenant et qui, je l'espère, deviendra la base d'une éventuelle intégration <code>go</code> .  J'espère que cet article sera le début d'une discussion productive sur ce qui fonctionne et ce qui ne fonctionne pas.  Sur la base de cette discussion, je ferai des ajustements à la fois à ma proposition et au prototype, puis je présenterai la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proposition officielle</a> pour ajouter une fonction facultative à Go 1.11. <br><br>  Cette proposition conserve tous les avantages de <code>go get</code> , mais ajoute des versions reproductibles, prend en charge le contrôle de version sémantique, élimine la commercialisation, supprime GOPATH au profit d'un flux de travail basé sur le projet et offre un départ en douceur de <code>dep</code> et de ses prédécesseurs.  Cependant, cette proposition n'en est encore qu'à ses débuts.  Si les détails ne sont pas corrects, nous les corrigerons avant que le travail n'entre dans la distribution principale de Go. <br><br><h1>  Situation générale </h1><br>  Avant d'examiner la proposition, regardons la situation actuelle et comment nous nous y sommes retrouvés.  Cette section est peut-être un peu trop grande, mais l'histoire apporte des leçons importantes et aide à comprendre pourquoi nous voulons changer quelque chose.  Si cela ne vous intéresse pas, vous pouvez immédiatement consulter l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">offre</a> ou lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de blog qui</a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">accompagne avec un exemple</a> . <br><br><h3>  <code>Makefile</code> , <code>goinstall</code> et <code>go get</code> </h3><br>  En novembre 2009, le compilateur, l'éditeur de liens et plusieurs bibliothèques ont été publiés avec la version initiale de Go.  Pour compiler et lier les programmes, il a fallu exécuter <code>6g</code> et <code>6l</code> , et nous avons inclus des exemples de makefiles dans le kit.  Le shell <code>gobuild</code> minimal pourrait compiler un paquet et écrire le makefile correspondant (dans la plupart des cas).  Il n'y avait aucun moyen établi de partager le code avec d'autres.  Nous savions que cela ne suffisait pas - mais nous avons publié ce que nous avions, en prévoyant de développer le reste avec la communauté. <br><br>  En février 2010, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons proposé goinstall</a> , une commande simple pour télécharger des packages à partir de référentiels de systèmes de contrôle de version tels que Bitbucket et GitHub.  <code>Goinstall</code> introduit des conventions sur les chemins d'importation qui sont désormais généralement acceptées.  Mais à cette époque, aucun code ne suivait ces conventions; <code>goinstall</code> au départ qu'avec des packages qui n'importaient que la bibliothèque standard.  Mais les développeurs sont rapidement passés à un accord unique que nous connaissons aujourd'hui, et l'ensemble des packages Go publiés est devenu un écosystème holistique. <br><br>  Goinstall a également corrigé les Makefiles, et avec eux la complexité des options de construction personnalisées.  Bien qu'il soit parfois gênant que les auteurs de packages ne puissent pas générer de code lors de chaque génération, cette simplification est extrêmement importante pour les <i>utilisateurs de</i> packages: ils n'ont pas à s'inquiéter d'installer le même ensemble d'outils que l'auteur a utilisé.  Cette simplification est également cruciale pour le fonctionnement des outils.  Makefile est une recette étape par étape requise pour compiler un package;  et l'application d'un autre outil comme <code>go vet</code> ou autocompletion au même package peut être assez difficile.  Même obtenir des dépendances correctement, pour reconstruire des packages si nécessaire et seulement si nécessaire, est beaucoup plus compliqué avec des Makefiles arbitraires.  Bien qu'à cette époque certaines personnes aient objecté qu'elles étaient privées de flexibilité, mais avec le recul, il devient clair que l'abandon du Makefile était la bonne étape: les avantages l'emportent de loin sur les inconvénients. <br><br>  En décembre 2011, en préparation de Go 1, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons introduit la commande go</a> , qui a remplacé <code>goinstall</code> par <code>go get</code> . <br><br>  En général, <code>go get</code> introduit des changements importants: il a permis aux développeurs de go d'échanger du code source et d'utiliser le travail de chacun.  Il a également isolé des parties du système de construction à l'intérieur de la commande <code>go</code> , de sorte qu'une automatisation importante à l'aide d'outils est devenue possible.  Mais <code>go get</code> manquer du concept de contrôle de version.  Dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">toutes premières discussions sur goinstall,</a> il est devenu clair: vous devez faire quelque chose avec le contrôle de version.  Malheureusement, on ne savait pas exactement quoi faire.  Au moins, dans l'équipe Go, nous ne comprenions pas cela clairement.  Lorsque <code>go get</code> demande un package, il obtient toujours la dernière copie, déléguant les opérations de téléchargement et de mise à jour à un système de contrôle de version tel que Git ou Mercurial.  Un tel "travail aveugle" a entraîné au moins deux défauts importants. <br><br><h3>  Gestion des versions et stabilité de l'API </h3><br>  Le premier inconvénient majeur de <code>go get</code> est que sans le concept de contrôle de version, il ne peut rien dire à l'utilisateur des changements à attendre dans cette mise à jour. <br><br>  En novembre 2013, une version de Go 1.2 a ajouté une entrée FAQ avec de tels conseils concernant la gestion des versions (le texte n'a pas changé pour la version Go 1.10): <br><br><blockquote>  Les packages à usage général devraient conserver une compatibilité ascendante à mesure qu'ils évoluent.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les recommandations de compatibilité de Go 1</a> sont pertinentes ici: ne supprimez pas les noms exportés, encouragez le balisage des littéraux composés, etc.  Si une nouvelle fonctionnalité est requise, ajoutez un nouveau nom au lieu de changer l'ancien.  En cas de changement fondamental, créez un nouveau package avec un nouveau chemin d'importation. </blockquote><br>  En mars 2014, Gustavo Niemeyer a lancé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gopkg.in</a> sous le couvert de "API stables pour le langage Go".  Ce domaine est une redirection GitHub <code>gopkg.in/yaml.v1</code> qui vous permet d'importer des chemins tels que <code>gopkg.in/yaml.v1</code> et <code>gopkg.in/yaml.v2</code> pour diverses <code>gopkg.in/yaml.v2</code> (éventuellement dans différentes branches) d'un référentiel Git.  Selon le versionnage sémantique, les auteurs devraient, lorsqu'ils apportent des modifications critiques, publier une nouvelle version majeure.  Ainsi, les versions ultérieures du chemin d'importation <code>v1</code> remplacent les précédentes et <code>v2</code> peut donner des API complètement différentes. <br><br>  En août 2015, Dave Cheney a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">soumis une proposition de contrôle de version sémantique</a> .  Au cours des prochains mois, cela a provoqué une discussion intéressante: tout le monde semblait d'accord pour dire que le balisage sémantique des versions est une excellente idée, mais personne ne savait comment les outils devraient fonctionner avec ces versions. <br><br>  Tous les arguments pour le versioning sémantique seront inévitablement critiqués en référence à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la loi</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hyrum</a> : <br><br><blockquote>  Le contrat de votre API devient sans importance avec un nombre suffisant d'utilisateurs.  Quelqu'un dépend de tout comportement observé du système. </blockquote><br>  Bien que la loi de Hyrum soit empiriquement correcte, le contrôle de version sémantique est toujours un moyen utile de générer des attentes sur la relation entre les versions.  Une mise à niveau de 1.2.3 à 1.2.4 ne devrait pas casser votre code, et une mise à niveau de 1.2.3 à 2.0.0 pourrait très bien.  Si le code cesse de fonctionner après la mise à jour vers 1.2.4, l'auteur acceptera très probablement un rapport de bogue et corrigera l'erreur dans la version 1.2.5.  Si le code a cessé de fonctionner (ou même compilé) après la mise à jour vers 2.0.0, alors ce changement était beaucoup plus susceptible d'être intentionnel et, en conséquence, il est peu probable que quelque chose soit corrigé dans 2.0.1. <br><br>  Je ne veux pas conclure de la loi de Hiram que le versioning sémantique est impossible.  Au lieu de cela, je crois que les assemblys doivent être utilisés avec précaution, en utilisant exactement les mêmes versions de chaque dépendance que l'auteur.  Autrement dit, l'assemblage par défaut doit être aussi reproductible que possible. <br><br><h3>  Assemblages distributeurs et reproductibles </h3><br>  Le deuxième inconvénient majeur de <code>go get</code> est que sans le concept de contrôle de version, une équipe ne peut pas fournir et même exprimer l'idée d'une construction reproductible.  Vous ne pouvez pas être sûr que les utilisateurs compilent la même version des dépendances de code que vous.  En novembre 2013, la FAQ suivante a été ajoutée à la FAQ pour Go 1.2: <br><br><blockquote>  Si vous utilisez un package externe et craignez qu'il ne change de façon inattendue, la solution la plus simple consiste à le copier dans le référentiel local (cette approche est utilisée par Google).  Enregistrez une copie avec un nouveau chemin d'importation qui l'identifie comme une copie locale.  Par exemple, vous pouvez copier <code>original.com/pkg</code> sur <code>you.com/external/original.com/pkg</code> .  L'un des outils de cette procédure est le goven de Kit Rerik. </blockquote><br>  Keith Rarik a démarré ce projet en mars 2012.  L'utilitaire <code>goven</code> copie la dépendance dans le référentiel local et met à jour tous les chemins d'importation pour refléter le nouvel emplacement.  De tels changements de code source sont nécessaires, mais désagréables.  Ils rendent difficile la comparaison et l'inclusion de nouvelles copies, et nécessitent également la mise à jour d'autres codes copiés à l'aide de cette dépendance. <br><br>  En septembre 2013, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Keith a introduit godep</a> , "un nouvel outil pour corriger les dépendances des packages".  La principale réalisation de <code>godep</code> été ce que nous appelons maintenant la vente, c'est-à-dire la copie des dépendances dans le projet <i>sans</i> changer les fichiers source, sans prise en charge directe des outils, en définissant GOPATH d'une certaine manière. <br><br>  En octobre 2014, Keith a proposé d'ajouter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge des «packages externes»</a> aux outils Go afin que les outils comprennent mieux les projets utilisant cette convention.  À ce moment-là, plusieurs <code>godep</code> style <code>godep</code> étaient déjà apparus.  Matt Farina a publié un article <code>godep</code> « <code>godep</code> gestionnaires de <code>godep</code> Sea of ​​Go» comparant <code>godep</code> aux <code>godep</code> , en particulier la <code>glide</code> . <br><br>  En avril 2015, Dave Cheney a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduit gb</a> , "un outil de construction basé sur un projet ... avec des générations répétées via la vente à la source", encore une fois sans réécrire les chemins d'importation (une autre motivation pour créer gb était d'éviter la nécessité de stocker du code dans des répertoires spécifiques dans GOPATH ce qui n'est pas toujours pratique). <br><br>  Ce printemps-là, Jason Buberlie a examiné la situation des systèmes de gestion de packages Go, y compris la duplication d'efforts multiples et le travail vain sur des utilitaires similaires.  Son enquête a clairement montré aux développeurs que la prise en charge de la vente sans réécrire les chemins d'importation doit être ajoutée à la commande <code>go</code> .  Dans le même temps, Daniel Theofanes a commencé à préparer des spécifications pour un format de fichier qui décrit l'origine exacte et la version du code dans le répertoire du fournisseur.  En juin 2015, nous avons accepté la proposition de Keith comme une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expérience de vente dans Go 1.5</a> , qui était incluse par défaut dans Go 1.6.  Nous avons encouragé les auteurs de tous les outils de vente à travailler avec Daniel pour adopter un format de fichier de métadonnées unique. <br><br>  L'introduction du concept de vente dans Go a permis à des outils comme le <code>vet</code> d'analyser les programmes de manière plus compétente, et aujourd'hui il a été utilisé par une douzaine ou deux gestionnaires de packages ou outils de vente.  En revanche, comme tout le monde a des formats de métadonnées différents, ils n'interagissent pas et ne peuvent pas facilement échanger des informations de dépendance. <br><br>  Plus fondamentalement, la vente est une solution incomplète au problème du contrôle de version.  Il fournit uniquement la reproductibilité de l'assemblage, mais n'aide pas à comprendre les versions du package et à décider laquelle utiliser.  Les gestionnaires de packages comme <code>glide</code> et <code>dep</code> ajoutent implicitement le concept de contrôle de version à Go, configurant le répertoire des fournisseurs d'une certaine manière.  Par conséquent, de nombreux outils de l'écosystème Go peuvent ne pas être en mesure d'obtenir les informations de version correctes.  Il est clair que Go a besoin d'un support direct pour les versions de packages. <br><br><h3>  Expérience de gestion des packages officiels </h3><br>  Lors de GopherCon 2016 le Hack Day (maintenant Community Day), un groupe de militants de Go s'est réuni pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discuter largement des problèmes de gestion des packages</a> .  L'un des résultats a été la formation d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comité et d'un groupe consultatif pour mener une gamme d'activités dans le but de créer un nouvel outil de gestion des colis</a> .  L'idée était qu'un outil unifié remplace les outils existants, bien qu'il soit toujours implémenté en dehors de la boîte à outils directe de Go à l'aide de catalogues de fournisseurs.  Le comité comprenait Andrew Gerrand, Ed Muller, Jesse Frazel et Sam Boyer, dirigé par Peter Burgon.  Ils ont préparé un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet de spécification</a> , puis Sam et ses assistants ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mis en œuvre le dep</a> .  Pour une compréhension de la situation générale, voir l'article de Sam de février 2016, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«So You Want to Write a Package Manager»,</a> son article de décembre 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Go Dependency Management Saga»,</a> et son discours de juillet 2017 à GopherCon, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«A New Era of Package Management in Allez</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> <br><br>  <code>Dep</code> effectue de nombreuses tâches: il s'agit d'une amélioration importante par rapport aux pratiques actuelles.  Il s'agit d'une étape importante vers une solution future, et en même temps une expérience - nous l'appelons une «expérience officielle» - qui nous aide à mieux comprendre les besoins des développeurs.  Mais <code>dep</code> pas un prototype direct de l'intégration possible des commandes <code>go</code> dans la gestion des versions des packages.  Il s'agit d'un moyen puissant, flexible et presque universel d'explorer l'espace des décisions de conception.  Il est similaire aux makefiles que nous avons combattus au tout début.  Mais dès que nous comprendrons mieux l'espace des décisions de conception et que nous pourrons le réduire à quelques fonctions clés qui devraient être prises en charge, cela aidera l'écosystème Go à supprimer d'autres fonctions, à réduire l'expressivité et à adopter des conventions contraignantes qui rendent les bases de code Go plus cohérentes et plus faciles à comprendre. <br><br>  Cet article est le début de la prochaine étape après <code>dep</code> : le premier prototype de l'intégration finale avec la commande <code>go</code> , l'équivalent batch de <code>goinstall</code> .  Un prototype est une commande distincte que nous appelons <code>vgo</code> : un remplacement <code>go</code> avec prise en charge de la gestion des versions des packages.  Il s'agit d'une nouvelle expérience, et nous verrons ce qui en sortira.  Comme lors de l'annonce de <code>goinstall</code> , certains projets et codes sont désormais compatibles avec <code>vgo</code> , tandis que d'autres nécessitent des modifications.  Nous supprimerons un certain contrôle et expressivité, tout comme les makefiles ont été supprimés afin de simplifier le système et d'éliminer la complexité pour les utilisateurs.  Plus important encore, nous recherchons des pionniers qui aideront à expérimenter avec <code>vgo</code> pour obtenir le plus d'avis possible. <br><br>  Démarrer une expérience avec <code>vgo</code> ne signifie pas arrêter le support <code>dep</code> : il restera disponible jusqu'à ce que nous <code>vgo</code> une intégration complète et ouverte avec <code>go</code> .  Nous essaierons également de faire la transition finale de <code>dep</code> à intégration avec <code>go</code> aussi fluide que possible, sous quelque forme que se fasse cette intégration.  Les projets qui n'ont pas encore été convertis en <code>dep</code> peuvent encore bénéficier de cette conversion (notez que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>godep</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>glide</code></a> arrêté le développement actif et encouragent la migration vers dep).  Peut-être que certains projets voudront passer directement à <code>vgo</code> si cela répond à leurs besoins. <br><br><h1>  Offrir </h1><br>  La proposition d'ajouter un contrôle de version à la commande <code>go</code> compose de quatre étapes.  Tout d'abord, acceptez la <i>règle de compatibilité d'importation</i> , qui est indiquée par la FAQ et gopkg.in: les versions plus récentes du package avec le chemin d'importation spécifié doivent être rétrocompatibles avec les versions plus anciennes.  Deuxièmement, adoptez un nouvel algorithme simple, connu sous le nom de <i>choix de la version minimale</i> pour déterminer quelles versions du package sont utilisées dans cet assemblage.  Troisièmement, introduisez le concept du <i>module</i> Go: des groupes de packages qui sont versionnés dans leur ensemble et déclarent les exigences minimales qui doivent être satisfaites par leurs dépendances.  Quatrièmement, déterminez comment intégrer tout cela dans votre commande <code>go</code> existante afin que les flux de travail de base ne changent pas de manière significative à partir d'aujourd'hui.  Dans le reste de cet article, nous examinons chacune de ces étapes.  Ils sont discutés plus en détail dans d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres articles de blog</a> . <br><br><h3>  Règle de compatibilité d'importation </h3><br>  Le principal problème avec les systèmes de gestion de packages est la tentative de résolution des incompatibilités.  Par exemple, la plupart des systèmes autorisent le package B à déclarer qu'il a besoin du package D de la version 6 ou ultérieure, puis autorisent le package C à déclarer qu'il requiert D la version 2, 3 ou 4, mais pas la version 5 ou ultérieure.  Ainsi, si vous souhaitez utiliser B et C dans votre package, vous n'avez pas de chance: vous ne pouvez sélectionner aucune version de D qui remplit les deux conditions et vous ne pouvez rien faire. <br><br>  Au lieu d'un système qui bloque inévitablement l'assemblage de grands programmes, notre proposition introduit une <i>règle de compatibilité à l'importation</i> pour les auteurs de packages: <br><br><blockquote>  Si l'ancien et le nouveau package ont le même chemin d'importation, le nouveau package doit être rétrocompatible avec l'ancien package. </blockquote><br>  La règle répète la FAQ mentionnée précédemment.  Ce texte se terminait par les mots: "En cas de changement radical, créez un nouveau package avec un nouveau chemin d'importation."           ,       .  ,           : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-yaml/yaml/v2"</span></span></code> </pre> <br>      2.0.0   ,        .        ,     Go      .    .                  v1  v2. <br><br>         ,         . ,  ,     ,             .      .      . <br><br><h3>    </h3><br>     ,  <code>dep</code>  <code>cargo</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">       </a> .  ,         . -,  «  »   -  ,   -   . ,   -     ,      ,    ,   . -,      ,    ,    «,    X»,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    X</a> . <br><br>      ,    <i>  </i> .    <i> </i>    .     ,       .  ,      ,   .      ,      ,       , ,  ,      . <br><br>           .   ,     ,      ,     .         ,    ,        ,      ,     .      ,      -  .       ,     ,    . <br><br>           . <br><br>   —      .      «,    »,     «,   ».     :  ()   .            . <br><br><h3>   Go </h3><br> <i></i> Go         ,    .     ,       .     Git      ,     Git .       ,      . <br><br>    <code>go.mod</code>        ,    . ,    <code>go.mod</code> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// My hello, world. module "rsc.io/hello" require ( "golang.org/x/text" v0.0.0-20180208041248-4e4a3210bb54 "rsc.io/quote" v1.5.2 )</span></span></code> </pre> <br>    ,     <code>rsc.io/hello</code> ,       : <code>golang.org/x/text</code>  <code>rsc.io/quote</code> .            ,    <code>go.mod</code> .     ,         -     . <br><br>      ,  <code>vgo</code>    ,    .   <code>rsc.io/quote</code> ,    <code>github.com/rsc/quote</code> ,   ,    1.5.2.    <code>golang.org/x/text</code>    .     ,  <i>v0.0.0-yyyymmddhhmmss-commit</i>      .         v0.0.0   <i>yyyymmddhhmmss-commit</i> .          ,   v0.0.0,    .      ,      . <br><br>     ,  <code>go.mod</code>     ,    ,          ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br> <code>Goinstall</code>   <code>go get</code>       ,   <code>git</code>  <code>hg</code> ,     ,   . ,   <code>bzr</code>       Bazaar.     ,  Go    HTTP   zip-.   <code>go get</code>       .   <code>vgo</code>   API      . <br><br>      zip-      -   .            -,              .        <code>go.mod</code>  ,   ,     . <br><br><h3>  <code>go</code> </h3><br>      <code>go</code>  .      ,    ,   <code>go build</code> , <code>go install</code> , <code>go run</code>  <code>go test</code> ,      .   <code>golang.org/x/text</code>           Go   . <br><br>     —   GOPATH    .   <code>go.mod</code>       ,       ,    <code>go.mod</code>    ,     ,      .     <code>git clone</code> , <code>cd</code> ,   .  .  GOPATH. <br><br><h1>  ? </h1><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«     Go»</a>  ,   <code>vgo</code> .    ,        <code>vgo</code> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> .   . <br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> vgo</a> .       .   <code>go.mod</code> .  ,       <code>go.mod</code> ,   <code>dep</code> , <code>glide</code> , <code>glock</code> , <code>godep</code> , <code>godeps</code> , <code>govend</code> , <code>govendor</code>    <code>gvt</code> ,  <code>vgo</code>      <code>go.mod</code> . <br><br>  ,  Go        .     ,     Go, —   ,       <code>go get</code> ,  GOPATH            GOPATH.          . <br><br>      - . ,    ,   <code>vgo</code>     .   ,  Go 1.11      Go,    ,   Go 1.12    .        ,  <code>go get</code> .    ,          ,    . <br><br>       <code>go get</code>        .       ,    .        ,  ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442272/">https://habr.com/ru/post/fr442272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442262/index.html">Secret du firmware</a></li>
<li><a href="../fr442264/index.html">Éliminer les opportunités de détournement de trafic</a></li>
<li><a href="../fr442266/index.html">Delta Chat - messager décentralisé au-dessus du courrier électronique</a></li>
<li><a href="../fr442268/index.html">AsyncIO Micropython: méthodes de synchronisation en programmation asynchrone</a></li>
<li><a href="../fr442270/index.html">5 erreurs à éviter lors de la création de modèles 3D pour l'impression 3D</a></li>
<li><a href="../fr442274/index.html">Dart 2. Programmation asynchrone: flux de données</a></li>
<li><a href="../fr442278/index.html">Guide de l'utilisateur Kibana. Visualisation. Partie 6</a></li>
<li><a href="../fr442280/index.html">Apprentissage automatique dans Dodo. Comment lancer une nouvelle direction si vous êtes développeur</a></li>
<li><a href="../fr442282/index.html">Dart 2. Programmation asynchrone: futurs</a></li>
<li><a href="../fr442284/index.html">NoVerify: le linter pour PHP de l'équipe VKontakte est maintenant dans le domaine public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>