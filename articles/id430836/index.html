<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèº üë∑üèª üÜï Kotlin: statis itu tidak ada üìù ü§õüèø ü§∞üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan berbicara tentang penggunaan statika di Kotlin. 
 Mari kita mulai. 
 Kotlin tidak memiliki statis! 

 Ini dinyatakan dalam dokumentas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: statis itu tidak ada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br>  Artikel ini akan berbicara tentang penggunaan statika di Kotlin. <br>  Mari kita mulai. <br>  Kotlin tidak memiliki statis! <br><br>  Ini dinyatakan dalam dokumentasi resmi. <br><br>  Dan sepertinya ini bisa menyelesaikan artikel.  Tapi biarkan saya, bagaimana caranya?  Lagipula, jika di Android Studio Anda memasukkan kode Java ke file Kotlin, maka konverter pintar akan melakukan keajaiban, ubah semuanya menjadi kode dalam bahasa yang benar dan itu akan berfungsi!  Tetapi bagaimana dengan kompatibilitas penuh dengan Java? <br><br>  Pada titik ini, pengembang mana pun, yang belajar tentang kurangnya statis di Kotlin, akan masuk ke dokumentasi dan forum untuk mengatasi masalah ini.  Mari kita berkumpul bersama, penuh perhatian dan susah payah.  Saya akan mencoba menyimpan pertanyaan sesedikit mungkin pada akhir artikel ini. <a name="habracut"></a><br><br>  Apa itu statis di Jawa?  Ada: <br><ul><li>  bidang statis kelas </li><li>  metode kelas statis </li><li>  kelas bersarang statis </li></ul><br><br>  Mari kita lakukan percobaan (ini adalah hal pertama yang terlintas dalam pikiran). <br><br>  Buat kelas Java sederhana: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br>  Semuanya mudah di sini: di kelas kita membuat bidang statis dan metode statis.  Kami melakukan segalanya secara publik untuk percobaan dengan akses dari luar.  Kami menghubungkan bidang dan metode secara logis. <br><br>  Sekarang buat kelas Kotlin kosong dan coba salin semua konten dari kelas SimpleClassJava1 ke dalamnya.  Kami menjawab "ya" untuk pertanyaan yang dihasilkan tentang konversi dan melihat apa yang terjadi: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br>  Tampaknya ini bukan yang kita butuhkan ... Untuk memastikan hal ini, kita akan mengkonversi bytecode kelas ini ke kode Java dan melihat apa yang terjadi: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br>  Ya  Semuanya persis seperti yang terlihat.  Tidak statis di sini.  Konverter hanya memotong pengubah statis di tanda tangan, seolah-olah tidak ada.  Untuk jaga-jaga, kami akan segera membuat kesimpulan: jangan membabi buta pada konverter, kadang-kadang dapat membawa kejutan yang tidak menyenangkan. <br><br>  Ngomong-ngomong, sekitar enam bulan yang lalu, mengonversi kode Java yang sama ke Kotlin akan menunjukkan hasil yang sedikit berbeda.  Jadi sekali lagi: berhati-hatilah dengan konversi otomatis! <br><br>  Kami bereksperimen lebih lanjut. <br><br>  Kami pergi ke kelas mana saja di Kotlin dan mencoba memanggil elemen statis dari kelas Java di dalamnya: <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br>  Inilah caranya!  Semuanya dipanggil dengan sempurna, bahkan pelengkapan otomatis kode memberi tahu kita segalanya!  Cukup penasaran. <br><br>  Sekarang mari kita beralih ke bagian yang lebih penting.  Memang, pencipta Kotlin memutuskan untuk menjauh dari statis dalam bentuk di mana kita terbiasa menggunakannya.  Mengapa kami melakukan hal itu dan kami tidak akan membahas sebaliknya - ada banyak perselisihan dan pendapat tentang hal ini di jaringan.  Kami hanya akan mencari cara untuk hidup dengannya.  Secara alami, kami tidak hanya kekurangan statika.  Kotlin memberi kita satu set alat yang dengannya kita dapat mengkompensasi yang hilang.  Mereka cocok untuk penggunaan di dalam ruangan.  Dan kompatibilitas penuh yang dijanjikan dengan kode Java.  Ayo pergi! <br><br>  Hal tercepat dan termudah yang dapat Anda sadari dan mulai gunakan adalah alternatif yang kami tawarkan alih-alih metode statis - fungsi tingkat paket.  Apa ini  Ini adalah fungsi yang bukan milik kelas mana pun.  Yaitu, jenis logika yang ada di ruang hampa di suatu tempat di ruang paket.  Kami dapat menjelaskannya di file apa pun di dalam paket yang menarik minat kami.  Misalnya, beri nama file ini JustFun.kt dan letakkan di paket <code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br>  Konversi bytecode dari file ini di Java dan lihat ke dalam: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  Kita melihat bahwa di Jawa suatu kelas dibuat yang namanya memperhitungkan nama file di mana fungsi dijelaskan, dan fungsi itu sendiri berubah menjadi metode statis. <br><br>  Sekarang jika kita ingin memanggil fungsi <code>testFun</code> di Kotlin dari kelas (atau fungsi yang sama) yang terletak di <code>package com.example.mytestapplication</code> (yaitu, paket yang sama dengan fungsi), maka kita dapat mengaksesnya tanpa trik tambahan.  Jika kita memanggilnya dari paket lain, maka kita harus mengimpor, yang akrab bagi kita dan biasanya berlaku untuk kelas: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br>  Jika kita berbicara tentang memanggil fungsi t <code>estFun</code> dari kode Java, maka kita selalu perlu mengimpor fungsi, terlepas dari paket mana kita memanggilnya: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br>  Dokumentasi mengatakan bahwa dalam kebanyakan kasus, alih-alih metode statis, cukup bagi kita untuk menggunakan fungsi tingkat paket.  Namun, menurut pendapat pribadi saya (yang tidak harus bertepatan dengan pendapat orang lain), metode penerapan statika ini hanya cocok untuk proyek-proyek kecil. <br>  Ternyata fungsi-fungsi ini bukan milik kelas mana pun secara eksplisit.  Secara visual, panggilan mereka tampak seperti panggilan ke metode kelas (atau induknya) di mana kita berada, yang kadang-kadang bisa membingungkan.  Nah dan yang utama - hanya ada satu fungsi dengan nama itu di paket.  Bahkan jika kita mencoba membuat fungsi dengan nama yang sama di file lain, sistem akan memberi kita kesalahan.  Jika kita berbicara tentang proyek besar, maka cukup sering kita memiliki, misalnya, pabrik yang berbeda memiliki metode statis dengan nama yang sama. <br><br>  Mari kita lihat alternatif lain untuk menerapkan metode dan bidang statis. <br><br>  Ingat apa bidang statis suatu kelas.  Bidang kelas ini milik kelas yang dideklarasikan, tetapi bukan milik turunan spesifik kelas, yaitu dibuat dalam satu instance untuk seluruh kelas. <br><br>  Kotlin menawarkan kepada kami untuk tujuan ini menggunakan beberapa entitas tambahan, yang juga ada dalam satu salinan.  Dengan kata lain, singleton. <br><br>  Kotlin memiliki kata kunci objek untuk mendeklarasikan singletones. <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br>  Objek seperti itu diinisialisasi dengan malas, yaitu, pada saat panggilan pertama kepada mereka. <br><br>  Ok, ada juga singletones di Jawa, di mana statistiknya? <br><br>  Untuk kelas apa pun di Kotlin, kita dapat membuat objek pendamping atau pendamping.  Seorang lajang terikat pada kelas tertentu.  Ini dapat dilakukan dengan menggunakan 2 kata kunci <code>companion  object</code> bersamaan: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br>  Di sini kita memiliki kelas <code>SimpleClassKotlin1</code> , di dalamnya kita mendeklarasikan singleton dengan kata kunci objek dan mengikatnya ke objek di dalamnya yang dideklarasikan dengan kata kunci pendamping.  Di sini Anda dapat memperhatikan fakta bahwa, tidak seperti deklarasi singleton sebelumnya (MySingltoneClass), nama kelas singleton tidak diindikasikan.  Jika objek tersebut dinyatakan sebagai pendamping, maka objek tersebut tidak boleh disebutkan namanya.  Maka secara otomatis akan dinamai <code>Companion</code> .  Jika perlu, kita bisa mendapatkan instance kelas pendamping dengan cara ini: <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br>  Namun, panggilan ke properti dan metode kelas pendamping dapat dilakukan secara langsung, melalui panggilan ke kelas yang dilampirkan: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br>  Itu sudah terlihat seperti memanggil bidang dan kelas statis, kan? <br><br>  Jika perlu, kita dapat memberi nama kelas pendamping, tetapi dalam praktiknya hal ini sangat jarang dilakukan.  Dari fitur-fitur menarik dari kelas yang menyertainya, dapat dicatat bahwa, seperti kelas biasa, ia dapat mengimplementasikan antarmuka, yang terkadang dapat membantu kami menambahkan sedikit lebih banyak urutan ke kode: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br>  Kelas pendamping hanya dapat memiliki satu kelas.  Namun, tidak ada yang melarang kita untuk mendeklarasikan sejumlah objek tunggal di dalam kelas, tetapi dalam hal ini kita harus secara eksplisit menentukan nama kelas ini dan, dengan demikian, menunjukkan nama ini ketika merujuk ke bidang dan metode kelas ini. <br><br>  Berbicara tentang kelas yang dideklarasikan sebagai objek, kita dapat mengatakan bahwa kita juga dapat mendeklarasikan objek bersarang di dalamnya, tetapi kita tidak dapat mendeklarasikan objek pendamping di dalamnya. <br><br>  Sudah waktunya untuk melihat "di bawah tenda."  Ambil kelas sederhana kami: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br>  Sekarang dekompilasi bytecode-nya di Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  Kami melihat apa yang terjadi. <br><br>  Properti objek pendamping direpresentasikan sebagai bidang statis kelas kami: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br>  Ini tampaknya persis seperti yang kita inginkan.  Namun, bidang ini bersifat pribadi dan diakses melalui pengambil dan penyetel kelas pendamping kami, yang disajikan di sini sebagai <code>public static final class</code> , dan turunannya disajikan sebagai konstanta: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  Fungsi companionFun tidak menjadi metode statis kelas kami (mungkin seharusnya tidak).  Tetap fungsi singleton diinisialisasi di kelas SimpleClassKotlin1.  Namun, jika Anda memikirkannya, maka secara logis ini adalah tentang hal yang sama. <br><br>  Dengan kelas <code>OneMoreObject</code> situasinya sangat mirip.  Perlu dicatat hanya bahwa di sini, tidak seperti pendampingnya, bidang kelas nilai tidak pindah ke kelas <code>SimpleClassKotlin1</code> , tetapi tetap di <code>OneMoreObject</code> , tetapi juga menjadi statis dan menerima pengambil dan penyetel yang dihasilkan. <br><br>  Mari kita coba memahami semua hal di atas. <br>  Jika kita ingin menerapkan bidang statis atau metode kelas di Kotlin, maka untuk ini kita harus menggunakan objek pengiring yang dideklarasikan di dalam kelas ini. <br>  Memanggil bidang dan fungsi ini dari Kotlin akan terlihat persis sama dengan memanggil statika di Jawa.  Tetapi bagaimana jika kita mencoba memanggil bidang dan fungsi ini di Jawa? <br><br>  Autocomplete memberi tahu kami bahwa panggilan berikut tersedia: <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br>  Artinya, di sini kita tidak akan pergi dari mana pun langsung menunjukkan nama pendamping.  Dengan demikian, nama yang ditugaskan ke objek pengiring default digunakan di sini.  Sangat tidak nyaman, bukan? <br><br>  Namun demikian, pencipta Kotlin memungkinkan untuk membuatnya terlihat lebih akrab di Jawa.  Dan ada beberapa cara untuk melakukan ini. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br>  Jika kita menerapkan anotasi ini ke bidang <code>companionField</code> objek <code>companionField</code> kita, maka ketika mengkonversi bytecode ke Java, kita melihat bahwa field statis <code>companionField</code> SimpleClassKotlin1 tidak lagi pribadi, tetapi publik, dan pengambil dan penyetel untuk pendampingField hilang dalam kelas <code>Companion</code> statis.  Sekarang kita dapat mengakses <code>companionField</code> dari kode Java dengan cara biasa. <br><br>  Cara kedua adalah menentukan pengubah <code>lateinit</code> untuk properti <code>lateinit</code> pendamping, properti dengan inisialisasi terlambat.  Jangan lupa bahwa ini hanya berlaku untuk properti-var, dan tipenya harus non-nol dan tidak boleh primitif.  Yah, jangan lupa tentang aturan untuk berurusan dengan properti seperti itu. <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br>  Dan satu cara lagi: kita dapat mendeklarasikan properti dari objek pendamping dengan menetapkan konstanta pengubah.  Mudah ditebak bahwa ini harus menjadi properti-val. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br>  Dalam setiap kasus ini, kode Java yang dihasilkan akan berisi bidang statis publik biasa, dalam kasus const, bidang ini juga akan final.  Tentu saja, perlu dipahami bahwa masing-masing dari 3 kasing ini memiliki tujuan logisnya sendiri, dan hanya yang pertama dirancang khusus untuk kemudahan penggunaan dengan Java, sisanya mendapatkan "roti" ini seolah-olah dalam sebuah beban. <br><br>  Harus dicatat secara terpisah bahwa pengubah const dapat digunakan untuk properti objek, objek pendamping, dan untuk properti tingkat paket.  Dalam kasus terakhir, kita mendapatkan yang sama dengan menggunakan fungsi level paket dan dengan batasan yang sama.  Kode Java dihasilkan dengan bidang publik statis di kelas, yang namanya memperhitungkan nama file yang kami gambarkan konstanta.  Paket hanya dapat memiliki satu konstanta dengan nama yang ditentukan. <br><br>  Jika kita ingin fungsi objek pengiring juga dikonversi ke metode statis saat membuat kode Java, maka untuk ini kita perlu menerapkan penjelasan <code>@JvmStatic</code> ke fungsi ini. <br>  Juga diperbolehkan untuk menerapkan anotasi <code>@JvmStatic</code> pada properti objek pendamping (dan hanya objek tunggal).  Dalam hal ini, properti tidak akan berubah menjadi bidang statis, tetapi pengambil dan penyetel statis untuk properti ini akan dihasilkan.  Untuk pemahaman yang lebih baik, lihat kelas Kotlin ini: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br>  Dalam hal ini, panggilan berikut ini valid dari Jawa: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br>  Panggilan berikut ini valid dari Kotlin: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br>  Jelas bahwa untuk Java Anda harus menggunakan 3 yang pertama, dan untuk Kotlin yang 2. yang kedua. Sisa panggilan hanya valid. <br><br>  Sekarang tinggal mengklarifikasi yang terakhir.  Bagaimana dengan kelas bersarang statis?  Semuanya sederhana di sini - analog dari kelas semacam itu di Kotlin adalah kelas bersarang reguler tanpa pengubah: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br>  Setelah mengonversi bytecode ke Java, kita melihat: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br>  Memang inilah yang kami butuhkan.  Jika kita tidak ingin kelasnya final, maka dalam kode Kotlin kita tentukan pengubah terbuka untuknya.  Saya ingat ini untuk berjaga-jaga. <br><br>  Saya pikir Anda bisa meringkas.  Memang, di Kotlin sendiri, seperti yang dikatakan, tidak ada bentuk statis di mana kita terbiasa melihatnya.  Tetapi seperangkat alat yang diusulkan memungkinkan kita untuk menerapkan semua jenis statika dalam kode Java yang dihasilkan.  Kompatibilitas penuh dengan Java juga disediakan, dan kami dapat langsung memanggil bidang statis dan metode kelas Java dari Kotlin. <br>  Dalam kebanyakan kasus, menerapkan stat di Kotlin memerlukan beberapa baris kode lagi.  Mungkin ini adalah satu dari sedikit, atau mungkin satu-satunya kasus ketika Anda perlu menulis lebih banyak di Kotlin.  Namun, Anda dengan cepat terbiasa dengannya. <br>  Saya pikir dalam proyek di mana Kotlin dan kode Java dibagikan, Anda dapat secara fleksibel mendekati pilihan bahasa yang digunakan.  Sebagai contoh, menurut saya Java lebih cocok untuk menyimpan konstanta.  Tetapi di sini, seperti dalam banyak hal lain, ada baiknya dipandu oleh akal sehat dan aturan untuk menulis kode dalam proyek. <br><br>  Dan di akhir artikel, inilah informasi semacam itu.  Mungkin di masa depan, Kotlin masih akan memiliki pengubah statis yang menghilangkan banyak masalah dan membuat kehidupan pengembang lebih mudah, dan kode lebih pendek.  Saya membuat asumsi ini dengan menemukan teks yang sesuai dalam paragraf 17 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi fitur Kotlin</a> . <br>  Benar, dokumen ini berasal dari Mei 2017, dan di halaman sudah akhir 2018. <br><br>  Itu semua untuk saya.  Saya pikir topiknya sudah dipilah secara mendetail.  Pertanyaan tulis di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430836/">https://habr.com/ru/post/id430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430826/index.html">Bagaimana cara mengembangkan manajer pengembangan</a></li>
<li><a href="../id430828/index.html">Pengalaman dalam menggunakan layar LCD berdasarkan produk MELT</a></li>
<li><a href="../id430830/index.html">Black Friday, tradisi dan idiom bahasa Inggris tentang berbelanja</a></li>
<li><a href="../id430832/index.html">Harga Black Friday Manusia</a></li>
<li><a href="../id430834/index.html">10 Dosa Mematikan Pembicara</a></li>
<li><a href="../id430838/index.html">Keajaiban pemasaran orang banyak, atau bagaimana mempromosikan bisnis dengan ulasan</a></li>
<li><a href="../id430840/index.html">Bukti apa yang dapat meyakinkan ahli matematika jika tidak ada bukti yang kuat?</a></li>
<li><a href="../id430842/index.html">Kami menggunakan blockchain untuk memerangi korupsi dan cyberbullying</a></li>
<li><a href="../id430844/index.html">Bagaimana memilih baterai untuk UPS</a></li>
<li><a href="../id430846/index.html">Apa yang baru: detail tentang implementasi arsitektur Zen 2 baru mulai dikenal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>