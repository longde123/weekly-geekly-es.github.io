<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔭 👧🏿 🕛 Recréer un ancien jeu DOS en C ++ 17 👨🏾‍🎤 ⏸️ 🙇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 2016, j'ai commencé à travailler sur un projet de loisir pour l'ingénierie inverse du jeu Duke Nukem II et recréer son moteur à partir de zéro. Le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recréer un ancien jeu DOS en C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454570/">  En 2016, j'ai commencé à travailler sur un projet de loisir pour l'ingénierie inverse du jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Duke Nukem II</a> et recréer son moteur à partir de zéro.  Le projet s'appelle Rigel Engine et est disponible en open source ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">sa page sur GitHub</a> ).  Aujourd'hui, plus de deux ans et demi plus tard, sur mon moteur, vous pouvez déjà parcourir tout l'épisode de shareware du jeu original avec un gameplay presque identique à l'original.  Voici une vidéo avec le passage du premier niveau: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Z3gCS5LvC2s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Que peut-il faire?  Rigel Engine fonctionne comme un remplacement complet du binaire DOS d'origine ( <code>NUKEM2.EXE</code> ).  Vous pouvez le copier dans le répertoire du jeu et il considère toutes les données qu'il contient, ou spécifier le chemin d'accès aux données du jeu comme argument de la ligne de commande.  Le moteur est construit et exécuté sous Windows, Mac OS X et Linux.  Il est basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">SDL</a> et OpenGL 3 / OpenGL ES 2 et est écrit en C ++ 17. <br><br>  Il implémente la logique de jeu de tous les ennemis et les mécanismes de jeu de l'épisode Shareware, ainsi que la plupart du système de menus.  De plus, vous pouvez y importer des jeux enregistrés et un tableau des meilleurs scores du jeu d'origine. <br><a name="habracut"></a><br>  De plus, le moteur présente des avantages par rapport à l'original: <br><br><ul><li>  Aucun émulateur ou ancien matériel requis, aucun paramètre requis </li><li>  Aucun écran de chargement - sélectionnez "nouveau jeu" dans le menu, appuyez sur Entrée et démarrez immédiatement le jeu </li><li>  Plusieurs effets sonores peuvent être joués en même temps, ce qui était impossible dans l'original </li><li>  Il n'y a aucune restriction sur le nombre d'effets simultanés de particules, d'explosions, etc. </li><li>  Enregistrer des fichiers et des listes de meilleurs scores pour chaque joueur </li><li>  Menus beaucoup plus réactifs </li></ul><br>  Jusqu'à présent, je ne considère pas que le moteur Rigel soit complètement «prêt à l'emploi».  Mais c'est une grande étape de développement et une bonne occasion d'écrire à nouveau sur le moteur (anciens articles publiés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> ).  Commençons par jeter un œil à l'état actuel du code et découvrez comment j'y suis parvenu. <br><br><h2>  Combien de code contient le moteur? </h2><br>  Au moment de la rédaction, RigelEngine se compose de 270 fichiers source contenant plus de 25 000 lignes de code (pas de commentaires / lignes vides).  Parmi ceux-ci, 10 fichiers et 2,5 mille lignes sont des tests unitaires.  Une ventilation détaillée des lignes vides et des commentaires est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> . <br><br>  Que contient tout ce code?  Un peu d'infrastructure commune et de fonctions de support, telles que des choses de base comme le rendu, et un tas de petits morceaux de logique.  En plus de tout cela, les plus grandes pièces sont: <br><br><ul><li>  analyseurs / téléchargeurs pour 14 formats de fichiers différents utilisés dans le jeu original - 2 mille lignes de code (LOC) </li><li>  logique de comportement / logique de jeu pour 24 ennemis / objets hostiles - 3.8k LOC </li><li>  logique de jeu pour 14 éléments interactifs et mécaniques de jeu - LOC 2k </li><li>  logique de contrôle du joueur - 1.2k LOC </li><li>  154 entrées de configuration (la valeur de santé de chaque ennemi, le nombre de points reçus pour les objets collectés, etc.) - 1k LOC </li><li>  31 spécifications pour les effets de destruction (effets déclenchés par la destruction d'un ennemi ou d'un autre objet destructible) - 254 LOC </li><li>  code de commande de la caméra - 159 LOC </li><li>  interpréteur de langage de description du menu du jeu / cinématique - 643 LOC </li><li>  Le HUD et autre code UI est 818 LOC </li><li>  5 écrans / modes en dehors du menu, par exemple, l'animation initiale, l'écran bonus, etc.  - 789 LOC </li></ul><br>  Bien sûr, tout ce code devait être écrit, ce qui nous amène à la question suivante. <br><br><h2>  Combien de travail at-il fallu? </h2><br>  Bien que deux ans et demi se soient écoulés depuis le début du projet, je n'y ai pas travaillé tout ce temps.  Pendant quelques mois, je n'ai pas du tout fait de projet, dans certains autres, je n'y ai passé que quelques heures.  Mais il y a eu des moments où j'ai travaillé très activement sur le moteur Rigel.  En regardant le calendrier de validation sur Github, vous pouvez avoir une idée approximative de la répartition de mon travail au fil du temps: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c55/7f6/ee0/c557f6ee023574c46aea645b0001824d.png"></div><br>  Selon le calendrier, nous constatons que 1081 commits ont été effectués dans la branche principale.  Cependant, avant même de créer le dépôt, je travaillais sur un dossier fermé, dans lequel il y avait 247 commits supplémentaires, ce qui nous donne au total 1328 commits.  De plus, il y avait plusieurs branches de prototype que j'ai utilisées pour la recherche et l'expérimentation, mais jamais combinées avec la principale;  en outre, avant de fusionner, j'ai parfois compressé de grandes histoires de commit en plus courtes. <br><br>  Je dois également dire que l'écriture de code n'était pas la seule partie du projet - l'ingénierie inverse était une autre partie importante.  J'ai passé pas mal d'heures à étudier le code désassemblé du fichier exécutable d'origine dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Ida Pro</a> (dans la version gratuite), à ​​prendre des notes, à écrire du pseudocode et à planifier la mise en œuvre des éléments de ma version.  De plus, j'ai testé activement le jeu original, en le lançant dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">DOSBox</a> et sur l'équipement d'origine (différentes machines 386 et 486 achetées sur eBay).  J'ai collecté des niveaux de test pour l'observation séparée d'ennemis spécifiques et l'étude des mécanismes de jeu, enregistré des clips vidéo à l'aide de DOSBox et parcouru les images image par image pour confirmer mes conclusions lors de l'étude du code assembleur.  Une fois l'ennemi ou la mécanique du jeu réalisés, j'enregistrais généralement un clip vidéo de ma version et le comparais image par image avec l'original pour confirmer l'exactitude de mon implémentation. <br><br>  Voici quelques photos de mes notes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/884/da3/b64/884da3b64a95ce531a3d5dbb456265bc.jpg"></div><br>  <i>Reverse engineering du code de contrôle de la caméra.</i>  <i>Un grand rectangle indique l'écran.</i>  <i>Les lignes en pointillés indiquent les zones qu'un joueur peut déplacer sans déplacer la caméra.</i>  <i>Si vous êtes intéressé, le code de contrôle de la caméra lui-même peut être trouvé <a href="" rel="noopener">ici</a> .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/2d3/5c6/ec42d35c6ee85e375b8ed6d94d37e24d.jpg"></div><br>  <i>Remarques générales pour vous aider à comprendre le code assembleur.</i>  <i>À gauche se trouve la procédure de mise à jour du jeu original à un niveau élevé.</i>  <i>À droite se trouvent des notes sur les champs de bits indiquant l'état de certains objets de jeu.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/677/f8f/839677f8f3f9854d8e8ce6d349da396c.jpg"></div><br>  <i>Transcription du code assembleur en pseudocode.</i>  <i>Habituellement, je le fais assez mécaniquement, transcris sans penser à ce que fait le code, puis utilise la version en pseudo-code pour comprendre la logique sous-jacente.</i>  <i>Et sur la base de cela, j'ai déjà trouvé ma mise en œuvre.</i>  <i>Voir le code fini <a href="" rel="noopener">ici</a> .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/fd3/848/8dafd384867291ec44dc8bb9d9ff15b2.jpg"></div><br>  <i>Pseudo-code d'une version nettoyée de la logique ennemie.</i>  <i>Les en-têtes indiquent l'état de la machine d'état, le code ci-dessous explique ce qui doit se passer dans les états respectifs.</i>  <i>Il a été créé sur la base d'un pseudocode brut obtenu par transcription de code assembleur.</i>  <i>Le code prêt peut être trouvé <a href="" rel="noopener">ici</a> .</i> <br><br>  En fin de compte, le travail sur le projet s'est avéré très excitant, et j'en ai beaucoup appris: sur l'ingénierie inverse, l'assembleur x86 16 bits, la programmation VGA de bas niveau, les restrictions sévères auxquelles les développeurs de jeux PC ont dû faire face au début des années 90;  en outre, j'ai fait de nombreuses découvertes sur les fonctionnalités internes du jeu original et sur la façon dont certaines d'entre elles ont été mises en œuvre de manière étrange et bizarre - ce sujet en soi mérite une série de publications distinctes. <br><br><h2>  Et ensuite </h2><br>  En plus d'ajouter les dernières fonctions restantes et de finaliser le support de la version enregistrée, j'ai plusieurs idées pour améliorer et étendre les capacités du moteur Rigel, sans parler du nettoyage et de la refactorisation du code - comme d'habitude, la meilleure façon de créer une architecture logicielle n'apparaît qu'après la création de ce logiciel. <br><br>  En ce qui concerne les améliorations futures, voici quelques points que j'ai pensé à mettre en œuvre: <br><br><ul><li>  Mouvement fluide avec interpolation.  Le jeu met à jour sa logique environ 15 fois par seconde, et dans le jeu original, c'est aussi la fréquence d'images pour le rendu.  D'un autre côté, le moteur Rigel peut facilement fonctionner avec une fréquence de 60 FPS et plus.  Pour le moment, ces cadres supplémentaires ne donnent aucun avantage, mais je pense qu'ils peuvent être utilisés pour des cadres intermédiaires afin de réaliser un défilement et un mouvement des objets plus fluides.  La logique du jeu fonctionnera toujours à la même vitesse, mais les objets se déplaceront en douceur et ne «sauteront» pas avec un incrément de 8 pixels, comme ils le font actuellement.  Plus tôt, j'ai créé un prototype d'un tel système, et il a fière allure, bien qu'il doive être amélioré. </li><li>  Prise en charge de la manette de jeu.  Dans le jeu d'origine, les joysticks sont pris en charge et DosBox peut les émuler sur des manettes modernes, mais leur configuration peut être difficile - la préparation de la configuration et l'étalonnage dans le jeu sont nécessaires.  Sans oublier que tous les boutons du contrôleur ne sont pas pris en charge, mais pour utiliser le menu, vous devez toujours prendre un clavier.  Par conséquent, je crois que le support du contrôleur natif améliorera considérablement le gameplay. </li><li>  Amélioration du son.  Actuellement, tous les effets sonores ont le même volume.  Les objets produisant du son, par exemple, les champs de force, deviennent nettement audibles lorsqu'ils touchent l'écran et se détachent tout aussi fortement.  J'étais curieux de savoir comment ils sonneraient si le volume des effets dans la distance diminuait.  Par exemple, nous pouvions à peine entendre le champ de force lorsqu'il n'était pas encore sur l'écran, et à l'approche, il devenait plus fort. </li><li>  Caméra à distance / voir la plupart du niveau.  Le jeu n'a pas été conçu pour cela, donc cette possibilité peut endommager le gameplay - le joueur commencera à voir des ennemis qui ne sont pas actifs en dehors de l'écran, etc.  Mais je me demande encore à quoi il ressemblera et jouera.  Au final, les joueurs se sont très souvent plaints de ce jeu pour leur incapacité à voir une partie suffisante du niveau.  Il serait intéressant d'ajouter l'option d'éteindre le HUD ou de le remplacer par un plus minimal en utilisant la transparence. </li><li>  Augmentez la résolution graphique.  Cette fonctionnalité se trouve souvent dans de nombreux ports / recréation de jeux, et ce serait formidable de l'ajouter ici.  Le moteur vous permet déjà de remplacer les graphiques de sprites par vos propres images, mais jusqu'à présent, ils ne peuvent pas avoir une résolution plus élevée, car tout est rendu dans un petit tampon avec une augmentation d'échelle ultérieure.  Tout d'abord, vous devez remplacer cette approche afin que la mise à l'échelle puisse être effectuée pour des objets individuels. </li></ul><br>  Je n'ai pas de feuille de route pour l'avenir, je peux donc mettre en œuvre ces points dans n'importe quel ordre.  Mais avant tout cela, la prochaine étape sera l'intégration de Dear ImGui pour assembler davantage le menu d'options, qui n'est pas encore dans le jeu;  en outre, il activera ou désactivera les améliorations ci-dessus.  En fin de compte, je dirai que je serai reconnaissant pour toute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">aide dans le travail sur GitHub</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454570/">https://habr.com/ru/post/fr454570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454552/index.html">Docker-compose Comment attendre que le conteneur soit prêt</a></li>
<li><a href="../fr454556/index.html">Nouvelles du monde d'OpenStreetMap n ° 462 (05.21.2019-27.05.2019)</a></li>
<li><a href="../fr454558/index.html">PHP Digest n ° 157 (20 mai - 3 juin 2019)</a></li>
<li><a href="../fr454562/index.html">Pourquoi le concept de bytecode n'est pas aussi pertinent qu'auparavant</a></li>
<li><a href="../fr454568/index.html">Mozilla a qualifié la «mauvaise» distribution de packages Web signée numériquement par Google</a></li>
<li><a href="../fr454574/index.html">Apprentissage automatique en microfinance: construire un modèle de notation pour les clients avec un historique de crédit vide</a></li>
<li><a href="../fr454576/index.html">Les auteurs de GandCrab cessent de travailler: ils prétendent en avoir assez volé</a></li>
<li><a href="../fr454578/index.html">Comment connecter la galerie PhotoSwipe dans la vue Web Android</a></li>
<li><a href="../fr454582/index.html">La longueur du tableau doit-elle être stockée dans une variable locale en C #?</a></li>
<li><a href="../fr454584/index.html">École de développement d'interface: analyse des tâches pour Minsk et un nouvel ensemble à Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>