<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏼 👩🏼‍🎤 👖 Tumpukan dan antrian adalah dua paradigma buruk dan apa yang bisa dilakukan untuk itu ☝🏻 🚶🏼 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada dua struktur data yang diketahui oleh setiap programmer dan yang dianggap sebagai aksioma yang bahkan tidak ada yang mencoba menganalisis apakah m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tumpukan dan antrian adalah dua paradigma buruk dan apa yang bisa dilakukan untuk itu</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430070/"><p>  Ada dua struktur data yang diketahui oleh setiap programmer dan yang dianggap sebagai aksioma yang bahkan tidak ada yang mencoba menganalisis apakah mereka diperlukan, apakah ada manfaat dari mereka dan apakah kerusakan ini tidak melebihi mereka. </p><a name="habracut"></a><br><h2 id="ochered">  Antrian </h2><br><p>  Pertama-tama, kita akan membahas antrian.  Apa arti dari antrian?  Antrian adalah buffer.  Dan kapan kita membutuhkan buffer?  Ketika kita tidak punya waktu untuk memproses acara yang masuk dengan kecepatan kedatangan mereka. <br>  Sehubungan dengan hal tersebut di atas, satu pertanyaan muncul: mengapa?  Jawabannya adalah kita berharap sesuatu akan terjadi dan tiba-tiba sistem akan memungkinkan kita untuk memproses peristiwa. </p><br><p>  Pertama, mari kita bahas paragraf pertama.  Apa yang harus terjadi pada sistem, yang <strong>tiba</strong> - <strong>tiba</strong> berhenti mengerem dan mulai mencerna data lebih cepat?  Kemungkinan besar, beberapa proses intensif sumber daya hanya akan berakhir dan membebaskan sumber daya.  Tetapi bagaimana jika ini tidak terjadi?  Apa yang harus dilakukan dengan data?  Diketahui bahwa: kita baru meresetnya, atau keseluruhan sistem hanya hang karena kekurangan sumber daya. </p><br><p>  Bebek, ada dua pertanyaan: </p><br><ol><li>  Dan mengapa Anda tidak dapat langsung mengirimkan data jika kami tahu bahwa kami tidak memiliki sumber daya untuk memprosesnya?  Itu sebabnya tidak mungkin membuat antrian dari satu elemen? </li><li>  Atau pertanyaan sebaliknya.  Mengapa kita memiliki ilusi dan tidak menyediakan sistem dengan jumlah sumber daya yang diperlukan untuk memproses data pada tingkat penerimaan? </li></ol><br><p>  Jawaban atas pertanyaan-pertanyaan ini, pada kenyataannya, jelas.  Kami sama sekali tidak tahu bagaimana merancang perangkat lunak dan sistem perangkat keras.  Karena jika kita tahu cara mendesainnya, maka kita akan tahu berapa banyak data input yang kita miliki, tingkat penerimaan mereka, berapa banyak yang kita butuhkan untuk memprosesnya, dan dengan demikian, kita dapat menghitung kebutuhan nyata akan sumber daya.  Tetapi keadaan terkini dari alat dan metodologi pengembangan TIK, dengan pengecualian bagian dari sistem teknologi (dan tidak semuanya), tidak memungkinkan kita untuk membuat perhitungan objektif kebutuhan sumber daya. </p><br><p>  Dan kami menutup kekurangan ini dengan segala macam penyangga, khususnya, dalam bentuk antrian.  Sebagai hasilnya, kami memiliki bom yang diletakkan di fondasi bangunan bahkan pada tingkat lubang fondasi, karena kruk ini berfungsi sebagai sumber dari berbagai penghinaan dan sulit untuk memahami masalah dengan keandalan, keamanan dan hanya kualitas pekerjaan. </p><br><p>  Tapi, mari kita lanjutkan, di depan kita adalah struktur "favorit" saya yang paling - tumpukan! </p><br><h2 id="stek">  Tumpukan </h2><br><p>  Itu sudah pasti, seperti yang pernah dikatakan Hoar tentang Null, bahwa ini adalah kesalahan satu miliar dolar, sehingga hal yang sama dapat dikatakan tentang tumpukan itu. </p><br><p>  Ini adalah salah satu struktur paling bermasalah yang digunakan dalam TIK dan penghindaran maksimumnya dalam praktik menciptakan perangkat keras dan lunak, hingga pemberantasan total, sangat diinginkan. </p><br><p>  Jadi apa sebenarnya masalah tumpukan?  Ya, persis sama dengan antrian.  Tumpukan pada dasarnya mustahil untuk diatur.  Segera setelah ada seseorang yang <strong>secara akurat</strong> memprediksi berapa banyak memori yang dibutuhkan oleh program arbitrer mana pun, saya secara pribadi meminta maaf dan menulis sebuah artikel besar bahwa saya salah dan meminta pengampunan. </p><br><p>  Tetapi sesuatu mengatakan kepada saya bahwa ini tidak mungkin terjadi di masa mendatang. </p><br><p>  Mari kita menganalisis mengapa kita perlu tumpukan?  Ya, persis sama, untuk mana antrian.  Ini adalah buffer.  Artinya, ini adalah tongkat penyangga untuk pikiran malas yang tidak ingin merancang perangkat lunak dan sistem perangkat keras dengan benar. </p><br><blockquote>  Jadi pelajarannya adalah ini: rekursi harus dihindari di mana ada solusi berulang yang jelas.  Namun, ini tidak berarti bahwa rekursi harus dibuang dengan cara apa pun.  Ada banyak contoh bagus menggunakan rekursi, yang akan kami tunjukkan di bagian dan bab selanjutnya.  Fakta bahwa ada implementasi prosedur rekursif pada mesin yang hampir non-rekursif membuktikan bahwa untuk tujuan praktis, setiap program rekursif dapat diubah menjadi program yang murni iteratif.  Namun, ini membutuhkan kerja eksplisit dengan tumpukan rekursi, dan tindakan ini sering mengaburkan esensi program sehingga sulit dipahami.  Kesimpulan: algoritma yang bersifat rekursif dan tidak berulang, perlu dirumuskan sebagai prosedur rekursif. <br>  Nicklaus Wirth.  Algoritma dan struktur data </blockquote><p>  Setuju dengan master tentang opsi konversi, saya tidak setuju dengan pendekatan lembutnya untuk menggunakan stack. </p><br><p>  Saya mengedepankan teorema: algoritma stack dapat dikonversi ke loop, dan mereka yang tidak dapat dikonversi buruk. </p><br><p>  Praktik memanggil subprogram dengan melewati parameter melalui stack harus dihentikan, dan rekursi yang tidak berkembang ke loop dan praktik yang banyak digunakan lainnya juga harus pergi ke sana. </p><br><p>  Kami dapat mengganti tumpukan untuk kasus-kasus berikut: </p><br><ol><li>  Rekursi, diimplementasikan dalam bentuk memperluas algoritma stack ke dalam satu loop dengan blok data yang diubah selama eksekusi dari loop. </li><li>  Jika Anda perlu mentransfer parameter, maka Anda akan mengatur sistem firmware dengan pengiriman pesan.  Dan tentang pengiriman pesan, kita masuk ke baris yang dijelaskan di bagian pertama artikel.  Jika Anda benar-benar ingin tumpukan, maka jelas Anda tidak harus mendorong puluhan dan ratusan kilobyte objek di sana, tetapi Anda perlu mengalokasikan memori untuk ini secara normal, di heap. </li></ol><br><p>  Pada saat yang sama, di tingkat atas, programmer dapat menggunakan struktur data apa pun, dan terserah kompiler untuk mengubahnya sehingga tidak termasuk penggunaan stack. </p><br><p>  Tentu saja, beberapa peluang mungkin akan hilang, tetapi ini, jika dipertimbangkan secara rinci, bukan fakta. </p><br><h2 id="blockout">  Blockout </h2><br><p>  Pada 1995, dengan teman sekelas saya, saya merumuskan prinsip-prinsip membangun sistem operasi yang mengecualikan kedua paradigma ini. </p><br><p>  Prinsip-prinsipnya adalah sebagai berikut: </p><br><ol><li>  Perangkat lunak - jaringan proses yang berinteraksi. </li><li>  Interaksi proses dilakukan melalui pertukaran pesan. </li><li>  Jaringan proses berinteraksi diatur sebagai berikut: sumber pesan utama dalam jaringan semacam itu <strong>hanya</strong> peristiwa dari dunia luar yang dipasok oleh peralatan, konsumen akhir pesan <strong>hanyalah</strong> perangkat yang melakukan tindakan di dunia luar.  Artinya, jaringan dimulai di dunia nyata dan berakhir di dalamnya. </li><li>  Proses tidak dapat memiliki prioritas.  Prioritas hanya dapat memiliki jaringan proses. </li><li>  Jaringan <strong>tidak pernah</strong> buffer pesan.  Kompleks perangkat keras-perangkat lunak harus diatur sedemikian rupa untuk mengelola untuk memproses pesan dengan kecepatan penerimaan mereka dari dunia luar. </li><li>  Kompleks perangkat keras adalah jaringan node komputasi yang terhubung oleh saluran komunikasi. </li><li>  Setiap node memiliki "biaya", tergantung pada kekuatan pemrosesan, ukuran memori, faktor beban dan berat, dengan mempertimbangkan biaya pembuatan dan pemeliharaannya. </li><li>  Setiap saluran komunikasi memiliki "biaya", tergantung pada bandwidth, kemacetan dan koefisien bobotnya, dengan mempertimbangkan biaya pembuatan dan pemeliharaannya. </li><li>  Sistem operasi menyediakan peluncuran proses dalam menanggapi pesan yang masuk dan perutean pesan. </li><li>  Sistem operasi memastikan distribusi proses dan pesan antar node komputasi, mengoptimalkan fungsi f (cpu, mem) pada topologi jaringan, dengan mempertimbangkan biaya pengiriman kode proses dan pesan ke node. </li><li>  Mengingat konstruksi sistem, Anda selalu dapat <strong>secara akurat</strong> menghitung jumlah memori yang diperlukan untuk proses tersebut.  Jumlah waktu penghitungan yang dibutuhkan dapat dihitung <strong>secara akurat</strong> berdasarkan analisis algoritma. </li></ol><br><h2 id="processor-bind">  Prosesor BIND </h2><br><p>  Sebagai bagian dari karir mengajarnya, bersama siswa, ia pernah berpartisipasi dalam kontes emulator CPU IEEE.  Prosesor stackless tujuan umum arsitektur Harvard dikembangkan menggunakan sistem perintah yang mirip dengan ARM sebelumnya.  Juga, gagasan transporter yang dilupakan dimasukkan ke dalam CPU dan prosesor dilengkapi dengan 16 saluran menerima-transmisi 8-bit. </p><br><p>  Karenanya, tidak ada operasi panggilan / pengembalian dalam prosesor.  Hanya transisi kondisional / tanpa syarat yang dimungkinkan.  Karena hampir tidak ada yang menulis di assembler sekarang, semua pertanyaan tentang membuat program dalam kode mesin seharusnya ditugaskan ke kompiler. </p><br><p>  Tujuan utama dari prosesor ini adalah untuk secara mulus mendukung prinsip-prinsip Blockout OS di tingkat perangkat keras dengan menciptakan jaringan prosesor di simpul komputasi lokal yang dihubungkan oleh saluran komunikasi yang prosesnya sudah akan didistribusikan. </p><br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Teks menunjukkan kelemahan fatal dari antrian dan menumpuk struktur data.  Prinsip-prinsip merancang perangkat lunak dan sistem perangkat keras yang memungkinkan untuk mengecualikan struktur ini dari praktik aplikasi diberikan. </p><br><p>  Teks ini, lebih tepatnya, kompilasi pemikiran yang telah terjadi sepanjang karir di bidang IT, sehingga, untuk mereduksi semuanya menjadi satu tempat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430070/">https://habr.com/ru/post/id430070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430058/index.html">Proses gelombang dalam saluran hidrolik. Dasar-dasarnya</a></li>
<li><a href="../id430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - keajaiban pemrograman</a></li>
<li><a href="../id430062/index.html">Layanan microser. Pengembangan dan pola refactoring dengan contoh-contoh Java</a></li>
<li><a href="../id430064/index.html">C ++: sesi arkeologi spontan dan mengapa Anda tidak harus menggunakan fungsi variabel dalam gaya C</a></li>
<li><a href="../id430068/index.html">Urutan kepompong</a></li>
<li><a href="../id430072/index.html">Server-Sisi Swift Meremehkan: Wawancara dengan Paul Hudson</a></li>
<li><a href="../id430074/index.html">Betapa aku hampir ketahuan virus mencoba menjual sepatu bot</a></li>
<li><a href="../id430076/index.html">Siaran gratis DotNext 2018 Moskow</a></li>
<li><a href="../id430078/index.html">Bagaimana cara mengontrol peralatan listrik, model yang dikendalikan oleh radio, kereta bayi bermotor dengan pandangan sekilas</a></li>
<li><a href="../id430080/index.html">Pindah ke cluster yang menjalankan 1C-Bitrix: Web Environment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>