<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧦 🤴🏻 📨 Replikasi tingkat tinggi di Tarantool DBMS 🍇 🕞 🥃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, saya membuat aplikasi untuk Tarantool DBMS - ini adalah platform yang dikembangkan oleh Mail.ru Group yang menggabungkan DBMS berkinerja tinggi d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Replikasi tingkat tinggi di Tarantool DBMS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455146/">  Hai, saya membuat aplikasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool</a> DBMS - ini adalah platform yang dikembangkan oleh Mail.ru Group yang menggabungkan DBMS berkinerja tinggi dan server aplikasi di Lua.  Solusi Tarantool berbasis kecepatan tinggi dicapai, khususnya, dengan mendukung mode DBMS dalam memori dan kemampuan untuk mengeksekusi logika aplikasi bisnis dalam ruang alamat tunggal dengan data.  Ini memastikan persistensi data menggunakan transaksi ACID (log WAL disimpan pada disk).  Tarantool memiliki replikasi bawaan dan dukungan sharding.  Dimulai dengan versi 2.1, kueri SQL didukung.  Tarantool adalah sumber terbuka dan berlisensi di bawah BSD Sederhana.  Ada juga versi Perusahaan komersial. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4aa/22f/d04/4aa22fd046775dd3b44af444ddcde28d.jpg"><br>  <i>Rasakan kekuatannya!</i>  <i>(... aka nikmati pertunjukannya)</i> <br><br>  Semua hal di atas menjadikan Tarantool platform yang menarik untuk membuat aplikasi basis data yang sangat banyak.  Dalam aplikasi seperti itu, replikasi data seringkali menjadi perlu. <br><a name="habracut"></a><br>  Seperti disebutkan di atas, Tarantool memiliki replikasi data bawaan.  Prinsip kerjanya adalah eksekusi berurutan pada replika semua transaksi yang terdapat dalam wizard log (WAL).  Biasanya, replikasi tersebut (kami akan menyebutnya <i>tingkat rendah di</i> bawah) digunakan untuk memberikan toleransi kesalahan dari aplikasi dan / atau untuk mendistribusikan beban bacaan antara node cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/31b/83b/d1c31b83b1c71220a514deebb7d49952.png"><br>  <i>Fig.</i>  <i>1. Replikasi dalam cluster</i> <br><br>  Contoh skenario alternatif adalah transfer data yang dibuat dalam satu basis data ke basis data lain untuk pemrosesan / pemantauan.  Dalam kasus terakhir, solusi yang lebih mudah mungkin menggunakan replikasi <i>tingkat tinggi -</i> replikasi data pada tingkat logika bisnis aplikasi.  Yaitu  Kami tidak menggunakan solusi siap pakai yang dibangun ke dalam DBMS, tetapi kami sendiri menerapkan replikasi di dalam aplikasi yang kami kembangkan.  Pendekatan ini memiliki kelebihan dan kekurangan.  Kami daftar pro. <br><br>  1. Menghemat lalu lintas: <br><br><ul><li>  Anda tidak dapat mentransfer semua data, tetapi hanya sebagian saja (misalnya, Anda hanya dapat mentransfer beberapa tabel, beberapa kolom atau catatan mereka yang memenuhi kriteria tertentu); <br></li><li>  tidak seperti replikasi tingkat rendah, yang dilakukan secara terus-menerus dalam mode asinkron (diimplementasikan dalam versi Tarantool saat ini - 1.10) atau mode sinkron (untuk diimplementasikan dalam versi Tarantool yang akan datang), replikasi tingkat tinggi dapat dilakukan dengan sesi (mis., aplikasi pertama kali melakukan sinkronisasi data - sesi pertukaran) data, maka ada jeda dalam replikasi, setelah sesi pertukaran berikutnya terjadi, dll); <br></li><li>  jika catatan telah berubah beberapa kali, Anda hanya dapat mentransfer versi terbarunya (tidak seperti replikasi tingkat rendah, di mana semua perubahan yang dilakukan pada wizard akan dimainkan secara berurutan pada replika). <br></li></ul><br>  2. Tidak ada kesulitan dengan implementasi pertukaran melalui HTTP, yang memungkinkan Anda untuk menyinkronkan basis data jauh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/551/551/7aa/5515517aaa739f6260023c5e8ff30bf0.png"><br>  <i>Fig.</i>  <i>2. Replikasi HTTP</i> <br><br>  3. Struktur basis data di mana data dikirimkan tidak harus sama (apalagi, dalam kasus umum, bahkan dimungkinkan untuk menggunakan DBMS, bahasa pemrograman, platform, dll.) Yang berbeda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/830/85a/64b/83085a64b69ff5dba2431db97213fa82.png"><br>  <i>Fig.</i>  <i>3. Replikasi dalam sistem heterogen</i> <br><br>  Kelemahannya adalah bahwa rata-rata, pemrograman lebih rumit / lebih mahal daripada konfigurasi, dan alih-alih mengatur fungsionalitas bawaan, Anda harus mengimplementasikannya sendiri. <br><br>  Jika dalam situasi Anda keuntungan di atas memainkan peran yang menentukan (atau kondisi yang diperlukan), maka masuk akal untuk menggunakan replikasi tingkat tinggi.  Mari kita pertimbangkan beberapa cara untuk mengimplementasikan replikasi data tingkat tinggi di Tarantool DBMS. <br><br><h2>  Minimalisasi lalu lintas </h2><br>  Jadi, salah satu manfaat replikasi tingkat tinggi adalah menghemat lalu lintas.  Agar keuntungan ini dapat sepenuhnya terwujud, perlu untuk meminimalkan jumlah data yang dikirimkan selama setiap sesi pertukaran.  Tentu saja, orang tidak boleh lupa bahwa pada akhir sesi penerima data harus disinkronkan dengan sumber (setidaknya untuk bagian dari data yang terlibat dalam replikasi). <br><br>  Bagaimana cara meminimalkan jumlah data yang ditransfer selama replikasi tingkat tinggi?  Solusi "di dahi" mungkin pemilihan data berdasarkan tanggal-waktu.  Untuk melakukan ini, Anda bisa menggunakan bidang tanggal-waktu yang sudah ada di tabel (jika ada).  Misalnya, dokumen "pesanan" mungkin memiliki bidang "waktu yang diperlukan untuk eksekusi pesanan" - <code>delivery_time</code> .  Masalah dengan solusi ini adalah bahwa nilai-nilai di bidang ini tidak harus dalam urutan yang sesuai dengan pembuatan pesanan.  Dengan demikian, kami tidak dapat mengingat nilai maksimum bidang <code>delivery_time</code> dikirim selama sesi pertukaran sebelumnya, dan pada sesi pertukaran berikutnya, pilih semua catatan dengan nilai yang lebih tinggi dari bidang <code>delivery_time</code> .  Di interval antara sesi pertukaran, catatan dengan nilai yang lebih kecil dari bidang <code>delivery_time</code> dapat ditambahkan.  Selain itu, pesanan dapat mengalami perubahan, yang tidak memengaruhi bidang <code>delivery_time</code> .  Dalam kedua kasus, perubahan tidak akan dikirim dari sumber ke penerima.  Untuk mengatasi masalah ini, kita perlu mengirimkan data "tumpang tindih".  Yaitu  selama setiap sesi pertukaran, kami akan mentransfer semua data dengan nilai bidang <code>delivery_time</code> yang melebihi beberapa titik di masa lalu (misalnya, N jam dari saat ini).  Namun, jelas bahwa untuk sistem besar pendekatan ini sangat berlebihan dan dapat mengurangi penghematan lalu lintas yang kami tuju.  Selain itu, tabel yang dikirimkan mungkin tidak memiliki bidang tanggal-waktu. <br><br>  Solusi lain, yang lebih kompleks dalam hal implementasi, adalah mengakui penerimaan data.  Dalam hal ini, pada setiap sesi pertukaran, semua data dikirimkan, tanda terima yang tidak dikonfirmasi oleh penerima.  Untuk implementasi, Anda perlu menambahkan kolom Boolean ke tabel sumber (misalnya, <code>is_transferred</code> ).  Jika penerima mengonfirmasi penerimaan rekaman, bidang terkait disetel ke <code>true</code> , setelah itu rekaman tidak lagi terlibat dalam pertukaran.  Opsi implementasi ini memiliki kelemahan berikut.  Pertama, untuk setiap catatan yang ditransfer, perlu untuk menghasilkan dan mengirim konfirmasi.  Secara kasar, ini dapat dibandingkan dengan menggandakan jumlah data yang ditransfer dan mengarah ke penggandaan jumlah perjalanan bolak-balik.  Kedua, tidak ada kemungkinan mengirim catatan yang sama ke beberapa penerima (penerima pertama akan mengkonfirmasi penerimaan untuk diri mereka sendiri dan untuk semua orang). <br><br>  Metode, tanpa kekurangan di atas, adalah menambahkan kolom ke tabel yang akan dikirim untuk melacak perubahan dalam barisnya.  Kolom seperti itu bisa dari tipe tanggal-waktu dan harus disetel / dimutakhirkan oleh aplikasi untuk waktu saat ini setiap kali menambah / mengubah catatan (secara atomis dengan menambahkan / mengubah).  Sebagai contoh, mari kita sebut kolom <code>update_time</code> .  Setelah menyimpan nilai maksimum bidang kolom ini untuk catatan yang ditransfer, kita dapat memulai sesi pertukaran berikutnya dari nilai ini (pilih catatan dengan nilai bidang <code>update_time</code> melebihi nilai yang disimpan sebelumnya).  Masalah dengan pendekatan yang terakhir adalah bahwa perubahan data dapat terjadi dalam mode batch.  Akibatnya, nilai bidang di kolom <code>update_time</code> tidak unik.  Dengan demikian, kolom ini tidak dapat digunakan untuk output data batch (halaman).  Untuk output data halaman per halaman, akan perlu untuk menemukan mekanisme tambahan yang cenderung memiliki efisiensi sangat rendah (misalnya, mengambil dari database semua catatan dengan <code>update_time</code> atas nilai yang ditentukan dan mengeluarkan sejumlah catatan, mulai dari offset tertentu dari awal sampel). <br><br>  Anda dapat meningkatkan efisiensi transfer data dengan sedikit meningkatkan pendekatan sebelumnya.  Untuk melakukan ini, kami akan menggunakan tipe integer (integer panjang) sebagai nilai kolom kolom untuk melacak perubahan.  <code>row_ver</code> kolom tersebut <code>row_ver</code> .  Nilai bidang kolom ini harus tetap disetel / dimutakhirkan setiap kali catatan dibuat / dimodifikasi.  Tetapi dalam kasus ini, bidang akan ditugaskan bukan tanggal-waktu saat ini, tetapi nilai beberapa penghitung meningkat satu.  Akibatnya, kolom <code>row_ver</code> akan berisi nilai unik dan dapat digunakan tidak hanya untuk menghasilkan data "delta" (data ditambahkan / diubah setelah akhir sesi pertukaran sebelumnya), tetapi juga untuk paginasi yang sederhana dan efisien. <br><br>  Metode terakhir yang diusulkan untuk meminimalkan jumlah data yang ditransfer sebagai bagian dari replikasi tingkat tinggi menurut saya paling optimal dan universal.  Mari kita bahas lebih detail. <br><br><h2>  Transfer data menggunakan penghitung versi baris </h2><br><h4>  Implementasi server / master </h4><br>  Dalam MS SQL Server, untuk menerapkan pendekatan ini, ada tipe kolom khusus - <code>rowversion</code> .  Setiap basis data memiliki penghitung, yang bertambah satu setiap kali Anda menambah / mengubah catatan dalam tabel yang memiliki kolom tipe <code>rowversion</code> .  Nilai penghitung ini secara otomatis ditetapkan ke bidang kolom ini dalam catatan yang ditambahkan / diubah.  Tarantool DBMS tidak memiliki mekanisme bawaan yang serupa.  Namun, di Tarantool, tidak sulit untuk mengimplementasikannya secara manual.  Pertimbangkan bagaimana ini dilakukan. <br><br>  Pertama, sedikit terminologi: tabel di Tarantool disebut spasi, dan catatan disebut tuple.  Di Tarantool, Anda bisa membuat urutan.  Urutan tidak lebih dari generator bernama nilai integer yang diurutkan.  Yaitu  inilah yang kita butuhkan untuk tujuan kita.  Di bawah ini kita akan membuat urutan seperti itu. <br><br>  Sebelum Anda melakukan operasi database apa pun di Tarantool, Anda harus menjalankan perintah berikut: <br><br><pre> <code class="lua hljs">box.cfg{}</code> </pre> <br>  Akibatnya, Tarantool akan mulai menulis snapshot dan log transaksi ke direktori saat ini. <br><br>  Buat urutan <code>row_version</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_version'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Opsi <code>if_not_exists</code> memungkinkan <code>if_not_exists</code> untuk menjalankan skrip pembuatan beberapa kali: jika objek ada, Tarantool tidak akan mencoba membuatnya kembali.  Opsi ini akan digunakan dalam semua perintah DDL berikutnya. <br><br>  Mari kita buat spasi sebagai contoh. <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Di sini kita mengatur nama ruang ( <code>goods</code> ), nama-nama bidang dan jenisnya. <br><br>  Bidang penambahan otomatis Tarantool juga dibuat menggunakan urutan.  Buat kunci primer peningkatan-otomatis untuk bidang <code>id</code> : <br><br><pre> <code class="lua hljs">box.schema.sequence.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, { if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Tarantool mendukung beberapa jenis indeks.  Paling sering, indeks jenis TREE dan HASH digunakan, yang didasarkan pada struktur yang sesuai dengan namanya.  TREE adalah tipe indeks yang paling serbaguna.  Ini memungkinkan Anda untuk mengambil data secara teratur.  Tetapi untuk pilihan kesetaraan, HASH lebih cocok.  Oleh karena itu, disarankan untuk menggunakan HASH untuk kunci utama (yang kami lakukan). <br><br>  Untuk menggunakan kolom <code>row_ver</code> untuk mengirimkan data yang diubah, Anda harus mengikat nilai urutan <code>row_ver</code> ke bidang di kolom ini.  Tapi tidak seperti kunci utama, nilai bidang di kolom <code>row_ver</code> harus meningkat satu, tidak hanya saat menambahkan catatan baru, tetapi juga ketika mengubah yang sudah ada.  Untuk melakukan ini, Anda bisa menggunakan pemicu.  Tarantool memiliki dua jenis pemicu untuk spasi: <code>before_replace</code> dan <code>on_replace</code> .  Pemicu dipicu setiap kali data dalam ruang diubah (untuk setiap tuple yang terpengaruh oleh perubahan, fungsi pemicu dipicu).  Tidak seperti <code>on_replace</code> , <code>before_replace</code> trigger memungkinkan Anda untuk memodifikasi data tuple yang memicu pelatuk dijalankan.  Dengan demikian, jenis pemicu terakhir cocok untuk kita. <br><br><pre> <code class="lua hljs">box.space.goods:before_replace(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old, new)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> box.tuple.new({new[<span class="hljs-number"><span class="hljs-number">1</span></span>], new[<span class="hljs-number"><span class="hljs-number">2</span></span>], new[<span class="hljs-number"><span class="hljs-number">3</span></span>], box.sequence.row_version:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  Pemicu ini menggantikan nilai bidang <code>row_ver</code> dari tuple yang disimpan dengan nilai urutan <code>row_version</code> berikutnya. <br><br>  Agar dapat mengekstraksi data dari ruang <code>goods</code> di kolom <code>row_ver</code> , buat indeks: <br><br><pre> <code class="lua hljs">box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'row_ver'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'TREE'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Jenis indeks adalah pohon ( <code>TREE</code> ), karena  kita perlu mengambil data dalam urutan nilai yang naik di kolom <code>row_ver</code> . <br><br>  Tambahkan beberapa data ke ruang: <br><br><pre> <code class="lua hljs">box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'pencil'</span></span>, <span class="hljs-number"><span class="hljs-number">321</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'brush'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'watercolour'</span></span>, <span class="hljs-number"><span class="hljs-number">456</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'album'</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'notebook'</span></span>, <span class="hljs-number"><span class="hljs-number">800</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'rubber'</span></span>, <span class="hljs-number"><span class="hljs-number">531</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'ruler'</span></span>, <span class="hljs-number"><span class="hljs-number">135</span></span>}</code> </pre> <br>  Karena  bidang pertama adalah penghitung kenaikan otomatis, sebagai gantinya kami lulus nol.  Tarantool akan secara otomatis menggantikan nilai berikutnya.  Demikian pula, Anda dapat melewatkan nil sebagai nilai bidang di kolom <code>row_ver</code> - atau tidak menentukan nilai sama sekali, karena  kolom ini mengambil posisi terakhir di ruang. <br><br>  Periksa hasil dari sisipan: <br><br><pre> <code class="lua hljs">tarantool&gt; box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>() <span class="hljs-comment"><span class="hljs-comment">--- - - [1, 'pen', 123, 1] - [2, 'pencil', 321, 2] - [3, 'brush', 100, 3] - [4, 'watercolour', 456, 4] - [5, 'album', 101, 5] - [6, 'notebook', 800, 6] - [7, 'rubber', 531, 7] - [8, 'ruler', 135, 8] ...</span></span></code> </pre> <br>  Seperti yang Anda lihat, bidang pertama dan terakhir diisi secara otomatis.  Sekarang akan mudah untuk menulis fungsi untuk paging membongkar <code>goods</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> page_size = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> index = box.space.goods.index.row_ver <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> goods = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tuple <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> index:<span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(row_ver, { iterator = <span class="hljs-string"><span class="hljs-string">'GT'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = tuple:tomap({ names_only = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(goods, obj) counter = counter + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> counter &gt;= page_size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goods <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Fungsi ini mengambil sebagai parameter nilai <code>row_ver</code> dari catatan terakhir yang diterima (0 untuk panggilan pertama) dan mengembalikan kumpulan data yang diubah berikutnya (jika ada, jika tidak array kosong). <br><br>  Pengambilan data di Tarantool dilakukan melalui indeks.  Fungsi <code>get_goods</code> menggunakan <code>row_ver</code> index untuk mengambil data yang diubah.  Jenis iterator adalah GT (Lebih Besar Dari, lebih dari).  Ini berarti bahwa iterator akan secara berurutan melintasi nilai indeks mulai dari nilai berikutnya setelah kunci yang dilewati. <br><br>  Iterator mengembalikan tupel.  Agar selanjutnya dapat mentransfer data melalui HTTP, perlu untuk mengubah tuple ke struktur yang nyaman untuk serialisasi berikutnya.  Dalam contoh, fungsi <code>tomap</code> standar digunakan untuk ini.  Alih-alih menggunakan <code>tomap</code> Anda dapat menulis fungsi Anda sendiri.  Misalnya, kami mungkin ingin mengganti <code>name</code> bidang <code>name</code> , bukan meneruskan bidang <code>code</code> , dan menambahkan bidang <code>comment</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unflatten_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = {} obj.id = tuple.id obj.goods_name = tuple.name obj.comment = <span class="hljs-string"><span class="hljs-string">'some comment'</span></span> obj.row_ver = tuple.row_ver <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Ukuran halaman dari data output (jumlah catatan dalam satu bagian) ditentukan oleh variabel <code>page_size</code> .  Dalam contoh, nilai <code>page_size</code> adalah 5. Dalam program nyata, ukuran halaman biasanya lebih penting.  Itu tergantung pada ukuran rata-rata tuple ruang.  Ukuran halaman yang optimal dapat dipilih secara empiris dengan mengukur waktu transfer data.  Semakin besar halaman, semakin kecil jumlah perjalanan pulang pergi antara pihak pengirim dan penerima.  Jadi, Anda dapat mengurangi total waktu untuk mengunggah perubahan.  Namun, jika ukuran halaman terlalu besar, kami akan membutuhkan server terlalu lama untuk membuat serial pilihan.  Akibatnya, mungkin ada keterlambatan dalam memproses permintaan lain yang datang ke server.  Parameter <code>page_size</code> dapat diambil dari file konfigurasi.  Untuk setiap ruang yang ditransmisikan, Anda dapat mengatur nilai Anda sendiri.  Namun, untuk sebagian besar spasi, nilai default (misalnya, 100) mungkin cocok. <br><br>  <code>get_goods</code> fungsi <code>get_goods</code> dalam modul.  Buat file repl.lua yang berisi deskripsi variabel <code>page_size</code> dan fungsi <code>get_goods</code> .  Di akhir file, tambahkan fungsi ekspor: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get_goods = get_goods }</code> </pre><br>  Untuk memuat modul, jalankan: <br><br><pre> <code class="lua hljs">tarantool&gt; repl = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'repl'</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- ...</span></span></code> </pre><br>  Mari kita jalankan fungsi <code>get_goods</code> : <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 1 code: 123 name: pen id: 1 - row_ver: 2 code: 321 name: pencil id: 2 - row_ver: 3 code: 100 name: brush id: 3 - row_ver: 4 code: 456 name: watercolour id: 4 - row_ver: 5 code: 101 name: album id: 5 ...</span></span></code> </pre> <br>  Ambil nilai bidang <code>row_ver</code> dari baris terakhir dan panggil fungsi itu lagi: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 6 code: 800 name: notebook id: 6 - row_ver: 7 code: 531 name: rubber id: 7 - row_ver: 8 code: 135 name: ruler id: 8 ...</span></span></code> </pre> <br>  Dan lagi: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - [] ...</span></span></code> </pre> <br>  Seperti yang Anda lihat, dengan penggunaan ini, fungsi halaman-demi-halaman mengembalikan semua catatan ruang <code>goods</code> .  Halaman terakhir diikuti oleh pilihan kosong. <br><br>  Kami akan membuat perubahan pada ruang: <br><br><pre> <code class="lua hljs">box.space.goods:update(<span class="hljs-number"><span class="hljs-number">4</span></span>, {{<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'copybook'</span></span>}}) box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>} box.space.goods:<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">'folder'</span></span>, <span class="hljs-number"><span class="hljs-number">432</span></span>}</code> </pre> <br>  Kami mengubah nilai bidang <code>name</code> untuk satu catatan dan menambahkan dua catatan baru. <br><br>  Ulangi panggilan fungsi terakhir: <br><br><pre> <code class="lua hljs">tarantool&gt; repl.get_goods(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">--- - - row_ver: 9 code: 800 name: copybook id: 6 - row_ver: 10 code: 234 name: clip id: 9 - row_ver: 11 code: 432 name: folder id: 10 ...</span></span></code> </pre> <br>  Fungsi mengembalikan catatan yang diubah dan ditambahkan.  Dengan demikian, fungsi <code>get_goods</code> memungkinkan <code>get_goods</code> untuk mendapatkan data yang telah berubah sejak panggilan terakhirnya, yang merupakan dasar dari metode replikasi yang sedang dipertimbangkan. <br><br>  Kami meninggalkan output hasil melalui HTTP dalam bentuk JSON di luar ruang lingkup artikel ini.  Anda dapat membacanya di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/ru/company/mailru/blog/272141/</a> <br><br><h4>  Implementasi bagian klien / budak </h4><br>  Pertimbangkan seperti apa penerapan sisi penerima.  Buat ruang di sisi penerima untuk menyimpan data yang diunduh: <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.goods:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'id'</span></span> }, sequence = <span class="hljs-string"><span class="hljs-string">'goods_id'</span></span>, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Struktur ruang menyerupai struktur ruang di sumbernya.  Tetapi karena kami tidak akan mentransfer data yang diterima di tempat lain, kolom <code>row_ver</code> di ruang penerima.  Di bidang <code>id</code> akan ditulis pengidentifikasi sumber.  Oleh karena itu, di sisi penerima, tidak perlu membuatnya secara otomatis. <br><br>  Selain itu, kami membutuhkan ruang untuk menyimpan nilai <code>row_ver</code> : <br><br><pre> <code class="lua hljs">box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-string"><span class="hljs-string">'row_ver'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">format</span></span> = { { name = <span class="hljs-string"><span class="hljs-string">'space_name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> }, { name = <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span> } }, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) box.space.row_ver:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { parts = { <span class="hljs-string"><span class="hljs-string">'space_name'</span></span> }, unique = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'HASH'</span></span>, if_not_exists = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br>  Untuk setiap ruang yang dimuat (field <code>space_name</code> ), kami akan menyimpan di sini nilai <code>row_ver</code> terakhir dimuat ( <code>value</code> bidang).  Kunci utama adalah kolom <code>space_name</code> . <br><br>  Mari kita buat fungsi untuk memuat data ruang <code>goods</code> melalui HTTP.  Untuk melakukan ini, kita memerlukan pustaka yang mengimplementasikan klien HTTP.  Baris berikut memuat pustaka dan instantiate klien HTTP: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http_client = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http.client'</span></span>).new()</code> </pre> <br>  Kami juga membutuhkan perpustakaan untuk deserialisasi json: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> json = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'json'</span></span>)</code> </pre> <br>  Ini cukup untuk membuat fungsi pemuatan data: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, row_ver)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> url = (<span class="hljs-string"><span class="hljs-string">'%s?rowVer=%s'</span></span>):<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(url, <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(row_ver)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> data = http_client:request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, body, { keepalive_idle = <span class="hljs-number"><span class="hljs-number">1</span></span>, keepalive_interval = <span class="hljs-number"><span class="hljs-number">1</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.decode(data.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Fungsi melakukan permintaan HTTP di url, meneruskan <code>row_ver</code> ke dalamnya sebagai parameter, dan mengembalikan hasil deserialized dari permintaan. <br><br>  Fungsi menyimpan data yang diterima adalah sebagai berikut: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(goods)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> n = #goods box.atomic(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, n <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> obj = goods[i] box.space.goods:put( obj.id, obj.name, obj.code) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Siklus menyimpan data dalam ruang <code>goods</code> ditempatkan dalam transaksi (fungsi <code>box.atomic</code> digunakan untuk ini) untuk mengurangi jumlah operasi disk. <br><br>  Akhirnya, fungsi sinkronisasi <code>goods</code> antariksa lokal dengan sumber dapat diimplementasikan sebagai berikut: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync_goods</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tuple = box.space.row_ver:get(<span class="hljs-string"><span class="hljs-string">'goods'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row_ver = tuple <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tuple.value <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set your url here: local url = 'http://127.0.0.1:81/test/goods/list' while true do local goods = load_goods(url, row_ver) local count = #goods if count == 0 then return end save_goods(goods) row_ver = goods[count].rowVer box.space.row_ver:put({'goods', row_ver}) end end</span></span></code> </pre> <br>  Pertama, kita membaca nilai <code>row_ver</code> sebelumnya disimpan untuk ruang <code>goods</code> .  Jika tidak ada (sesi pertukaran pertama), maka kami mengambil nol sebagai <code>row_ver</code> .  Selanjutnya, dalam loop, kami membuat paginate data yang dimodifikasi dari sumber ke url yang ditentukan.  Pada setiap iterasi, kami menyimpan data yang diterima di ruang lokal yang sesuai dan memperbarui nilai <code>row_ver</code> (dalam <code>row_ver</code> row_ver dan dalam variabel <code>row_ver</code> ) - kami mengambil nilai <code>row_ver</code> dari baris terakhir dari data yang dimuat. <br><br>  Untuk melindungi dari loop yang tidak disengaja (jika terjadi kesalahan dalam program), <code>while</code> dapat diganti dengan <code>for</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ = <span class="hljs-number"><span class="hljs-number">1</span></span>, max_req <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ...</code> </pre> <br>  Sebagai hasil dari fungsi <code>sync_goods</code> , <code>goods</code> di penerima akan berisi versi terbaru dari semua catatan ruang <code>goods</code> di sumber. <br><br>  Jelas, penghapusan data tidak dapat disiarkan dengan cara ini.  Jika kebutuhan seperti itu ada, Anda dapat menggunakan tanda penghapusan.  <code>is_deleted</code> bidang boolean <code>is_deleted</code> ruang <code>goods</code> dan bukannya menghapus catatan secara fisik, gunakan penghapusan logis - setel nilai bidang <code>is_deleted</code> menjadi <code>true</code> .  Terkadang, alih- <code>is_deleted</code> bidang Boolean <code>is_deleted</code> , lebih nyaman menggunakan bidang yang <code>deleted</code> , yang menyimpan tanggal-waktu penghapusan logis catatan.  Setelah melakukan penghapusan logis, catatan yang ditandai untuk dihapus akan ditransfer dari sumber ke penerima (sesuai dengan logika yang dibahas di atas). <br><br>  Urutan <code>row_ver</code> dapat digunakan untuk mentransfer data dari ruang lain: tidak perlu membuat urutan terpisah untuk setiap ruang yang ditransmisikan. <br><br>  Kami memeriksa cara replikasi data tingkat tinggi yang efektif dalam aplikasi menggunakan Tarantool DBMS. <br><br><h2>  Kesimpulan </h2><br><ol><li>  Tarantool DBMS adalah produk yang menarik dan menjanjikan untuk membuat aplikasi yang sangat dimuat. <br></li><li>  Replikasi tingkat tinggi menyediakan pendekatan yang lebih fleksibel untuk transfer data dibandingkan dengan replikasi tingkat rendah. <br></li><li>  Metode replikasi tingkat tinggi yang dipertimbangkan dalam artikel memungkinkan seseorang untuk meminimalkan jumlah data yang dikirimkan dengan hanya mentransfer catatan-catatan yang telah berubah sejak sesi pertukaran terakhir. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455146/">https://habr.com/ru/post/id455146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455130/index.html">3 alat populer untuk mengatur penyebaran berkelanjutan (Continuous Deployment)</a></li>
<li><a href="../id455132/index.html">Barang Antik: Philips Velo 1, mimpi buruk penggemar teknologi</a></li>
<li><a href="../id455134/index.html">Apa yang diingat di Heisenbug masa lalu, dan apa yang akan terjadi selanjutnya?</a></li>
<li><a href="../id455138/index.html">JetBrains Night Moscow: bagaimana keadaannya</a></li>
<li><a href="../id455144/index.html">Bersiap untuk 2020: 8 tren dalam pengembangan JavaScript sisi klien yang perlu Anda ketahui</a></li>
<li><a href="../id455148/index.html">Kami menyelesaikan tugas pengambilan keputusan berdasarkan data</a></li>
<li><a href="../id455152/index.html">Tingkatkan aplikasi seluler Anda menggunakan teknologi pembelajaran mesin</a></li>
<li><a href="../id455156/index.html">Tugas sequencing domestik (Juni, 2019)</a></li>
<li><a href="../id455158/index.html">Keajaiban metodologi akuntansi: dana depresiasi</a></li>
<li><a href="../id455160/index.html">Entity Framework 6 dengan Pencarian Teks Lengkap via LINQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>