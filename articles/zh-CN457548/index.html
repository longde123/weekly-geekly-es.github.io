<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛡️ 🕍 🕚 在TMS320F28027上产生多相PWM信号 🌓 👨🏾‍🍳 👹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="很久很久以前  在遥远的星系中  我写了一篇关于德州仪器（TI）专用Piccolo控制器的简短文章 ，该控制器旨在控制电源转换器和电驱动器。 这些控制器在许多任务中都是非常强大的开发工具，我想针对它们编写其他内容……简单而有用。 


 最近，我很困惑地开发出用于电机控制的控制器，因此，形成了本文的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在TMS320F28027上产生多相PWM信号</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p> 很久很久以前 <del> 在遥远的星系中 </del> 我写了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于德州仪器（TI）专用Piccolo控制器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简短文章</a> ，该控制器旨在控制电源转换器和电驱动器。 这些控制器在许多任务中都是非常强大的开发工具，我想针对它们编写其他内容……简单而有用。 </p><br><p> 最近，我很困惑地开发出用于电机控制的控制器，因此，形成了本文的主题-今天，我将讨论形成用于电机控制的三相PWM的过程，并说明TMS320F28与其他控制器（例如STM32F334，STM32G484，XMC4200等）之间的有益区别。 </p><br><p> 作为一个立场，我将使用正在开发的控制器，las，我无法详细讨论熨斗部件。 但是，如果我说控制器是基于TMS320F28027 + DRV8353RSRGZT捆绑包构建的，那么您可以查看驱动器数据手册并查看常规电路概念，并且在此模块上进行调试，并且参考设计已经开放。 </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="BLDC驱动程序"></p><br><p> 原则上，在相同类型的电路上，可以控制“消耗”电压水平和普通三相的BLDC电机，这些电机已经需要正弦输出。 我将显示两个选项，因为 通向正弦的路径是通过电压电平的形成。 </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="示波器编号1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze"> 关于铁的一点 </h1><br><p> 从理论上说，驱动器的动力部分由3个半桥转换器组成，可能所有的变桨器和用于控制所有直升机中的BLDC引擎的控制器都以类似的方式制造： </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="三相桥"></p><br><p> 一个区别-我没有输入整流器，因为 控制器最初由恒定电压供电。 在我的案例中，电源是一个18650电池形式的锂离子电池组件，使用的DRV8353RSRGZT驱动器仅可以控制3个功率半桥，在石头的使用版本中，还内置有运算放大器，可与分流器一起用作电流传感器，内置dc / dc，它可以吸收高达70 ... 80V的电压，所有这些都可以通过SPI灵活配置。 例如，能够调节晶体管控制的最大脉冲电流非常方便。 </p><br><p> 同样在该系列中，驱动器具有一组不同的功能，例如，具有模拟控制，非SPI或无内置dc / dc和无运算放大器。 在价格上，它们并没有太大的区别，您可能已经理解，我采取了最“大胆”的做法。 整个外观看起来非常漂亮，但是我轻而易举地采用了驱动程序绑定的设计，但发现了两个重大问题。 实际上，只有一个问题-这是强烈的过热现象： </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="热像仪"></p><br><p> 但是此问题是由两个原因引起的。 实际上，问题的实质是驱动程序本身过热。 在温度记录图上，驱动程序被加载了5A的电流（对他来说几乎是闲置的），而驱动程序和MK本身则被加热了一点。 晶体管甚至不可见，它们具有PCB温度，在5A时热量损失很小。 </p><br><ul><li>  <strong>错误1</strong> <br> 老实说，我曾被我的一个朋友提示，我想这是最后一件事-驱动器具有内置的dc / dc，可接收15 ... 50V输入并输出3.3V来为MK，逻辑，比较器和运算放大器供电。 看来我的项目有采用单独芯片形式的LM5008和LM5017微芯片，并且在电流为100-150 mA时没有明显发热的情况下，我将电压从60V平稳地降低到3.3V，但是一切都变得棘手-转换器的总体效率在电流下约为65-70％ 300毫安！ 事实是，转换器本身可以提供3.3V的电压，但效率极低，最好将输出电压设置为10-12-15V。 当输出为12V 100 mA时，我的驱动器实际上停止了预热，效率达到了令人愉快的88％。  <strong>解决该问题的方法</strong>是使用内置的dc / dc将输入电压从15 ... 50V降低至12V，然后使用已经便宜的外部dc / dc将其从12V降低至3.3V。 </li></ul><br><br><ul><li>  <strong>错误2</strong> <br> 第二个错误更明显，而我第一件事就是尽我所能。 事实是，对于QFN封装中的芯片，主要热量通过“腹部”散发出去，通常位于GND上，并通过多个过孔（过孔）紧贴地面，所有热量都从那里平静地散发。 最初，我没有考虑到电压差较大的内置dc / dc的微不足道的效率，因此，热压降（“腹部”）紧贴在内层的实心GND多边形上，而在外层上，我的腹部下方没有铜作为多边形，这丝毫没有困扰我地线 结果，结果是在芯片上释放了约0.5 W的热量，并散布在电路板的内层，即效率非常差。  <strong>该问题的解决方案</strong>是您需要在外层（底层）上进行接地测试，而不要这样做： </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="电路板"></p><br><p> 结果，在铁的第二次修订中，这些错误已得到纠正：添加了一个外部DC / DC转换器12-3.3V，并且在底层上另外填充了GND多边形，并在其上植入了芯片焊盘+保留了内部固体接地多边形。 经过这样的改进后，连续运行中的温度从+82降至+43 <sup>o</sup> C： </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="热分析图"></p><br><p> 如您所见，由于损耗的减少，在相同条件下温度已显着降低，而且热量现在在电路板上的分布更加均匀，并且不会使驱动器或微控制器局部过热。 原则上，一切都是铁，没有其他有趣的事情发生并且稳定地工作。 因此，他们可能建议使用<strong>DRV8353</strong>驱动程序。 </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup"> 实施120 <sup>o</sup>的硬件相移 </h1><br><p> 三相网络的一个特点是各相的电流不是同步的，而是相对于相邻的相移120 <sup>o</sup> 。 通常，这120 <sup>o</sup>相移是什么？ 简而言之，这是一代的起点偏移了周期的1/3。 从数学角度来看，信号周期为<em>2π</em> ，这意味着第二个信号必须移动2π/ 3，第三个信号必须移动4π/ 3。 从电子角度来看，该周期由计时器的倒计时周期设置。 例如，当以60 MHz为时钟频率时，我们希望获得一个频率为50 kHz的PWM，这意味着计时器的倒数周期将为0到1200（600000000 Hz / 50000 Hz = 1200）。 现在，要获得3个相移为120 <sup>o的相，</sup>我们无需触摸第一相，将第二相的当前值加+400，将当前相加+800。 </p><br><p> 如果我们在皮质内核上使用微控制器，则可以通过编写数学公式或使用事件同步来实现转换。 为什么让ST，NXP和其他公司不仅仅注册将写入偏移值的位置，这总是让我感到惊奇。 幸运的是，TI在他们的TMS320F28xxx中做到了这一点，只需设置一个寄存器即可设置移位！ 我不会告诉您为什么软件解决方案不是最佳解决方案，我只是说它很快就考虑了MK公式。 具有事件同步功能的版本已经足够了，在stm上我可以做到这一点，但是此选项不允许“即时”更改相位值，也就是说，对于某些移相桥，仅保留软件版本。 控制相位硬件的优势是吗？ 由您决定，我的任务是告诉您这是可能的。 对我来说，当我们谈论控制具有三相输出的电驱动器或电压逆变器时，这是显而易见的优点。 </p><br><p> 现在，让我们以3个互补对的形式配置PWM信号的生成，它们具有死区时间和相移。 到目前为止还没有正弦。 我将使用以下对：EPWM1​​A + EPWM1​​B，EPWM2A + EPWM2B和EPWM4A + EPWM4B。 这些是从微控制器传递到驱动器的信号。 </p><br><ul><li>  <strong>第一步</strong> <br> 必须使用<em>GPAMUX</em>寄存器将GPIO多路复用器配置为与PWM配合使用，并关闭对电源<em>的</em>输出上<em>拉</em> ，以便在打开所有支路时都没有log.1并且按键也不会打开。 当前的保护固然可以节省，但最好不要这样做。 还应该记住，要访问设置寄存器，您需要使用<em>EALLOW</em>命令获得它，然后使用<em>EDIS</em>命令重新打开覆盖保护。 </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>第二步</strong> <br> 设置PWM信号生成。 必须获得50 kHz的频率和120 <sup>o</sup>的相移。 在这种情况下，我使用通常的PWM，因为在此控制器中还具有HRPWM，因此记住这一点很重要。  PWM模块的时钟频率为60 MHz的核心频率，我在TMS320的第一篇文章中演示了如何设置PLL频率，我将不再赘述，但是在文章末尾将有一个包含代码的存档，可以在那儿窥视。 </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p> 现在，再详细一点……在<em>TBPRD</em>寄存器中，写上句点，或者说“ period / 2”，因为 我们考虑两个方向的计时器，结果发现周期600对应于互补对模式下50 kHz输出PWM信号的频率。 在<em>TBPHS</em>寄存器中， <em>我们</em>写入需要偏移的相位值，在本例中为600的400，对应于2π/ 3。 值得注意的是，我们没有移动第一阶段，因此对于它而言，偏移是0，对于第二阶段而言，偏移是400，但是对于第三阶段，写800似乎是合乎逻辑的，但是600中的800并非完全如此...因此，他们写的移位不是相对于第一阶段，而是相对于前一个阶段，即第二阶段。 结果，我们在第三阶段中写入400，这对应于阶段2和3之间的2π/ 3，并且由于第二阶段已经移位，因此在阶段1和3之间将存在“2π/ 3 +2π/ 3 =4π / 3”，从电子学的角度来看，一切看起来都是合乎逻辑的。 </p><br><p> 为了使各阶段了解谁在相对于谁移动，需要一个凸台，因此使用<em>PHSEN</em>位将EPWM1​​设置为主模式，并将EPWM2和EPWM4分别设置为从模式。 使用<em>SYNCOSEL</em>位， <em>还可以</em>设置<em>同步</em> “点”，即从何处读取移位。  EPWM1​​与计时器的开始同步，即零周期，并且EPWM2和EPWM4已经相对于前一个通道的信号边沿同步：EPWM2的前一个通道是EPWM1​​，而EPWM4的前一个通道是EPWM2。 </p><br><p> 现在仍然需要打开互补对并设置停滞时间。 使用<em>POLSEL</em>位， <em>我们</em>设置一个非反向PWM，即，在达到比较器（参考）的设置值时，在输出端会生成一个对数。  1.在<em>OUT_MODE中，我们</em>在信号的边缘和下降沿设置死区时间。 因此，在寄存器<em>DBFED</em>和<em>DBRED</em>中，以滴答为<em>单位</em>写入<em>停滞</em>时间的持续时间。 </p><br><ul><li>  <strong>第三步</strong> <br> 现在，仍然需要将占空比值写入与每个通道相对应的<em>CMPA</em>寄存器中，您可以观察到结果。 </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="三相PWM"></p><br><p> 瞧！ 示波器探头连接到驱动器输出。 黄色通道是我们的EPWM1​​，即主机。 蓝色通道是EPWM2，它相对于黄色通道偏移了2π/ 3（或400个样本），绿色通道又偏移了400个样本。 这样我们得到3个相位，每个相位偏移120 <sup>o</sup> 。 </p><br><p> 现在，将示波器探头从功率桥的输出传输到微控制器发出的控制信号，并检查互补对内的停滞时间： </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="示波器编号2"></p><br><p> 如您所见，设置的死区时间与实际死区时间相对应。 一个采样的持续时间为<em>1 / 60,000,000 Hz = 16.6 ns</em> ，我们得到20个采样，相当于20.6的死区时间<em>16</em> ns = 332 ns，*大约是在示波器上观察到的时间。 </p><br><p> 实际上，它可以用现在的形式派上用场。 对于那些对<strong>交错的dc / dc转换器</strong>感兴趣的人，最明显的选择是多相dc / dc转换<strong>器</strong> 。 这是一个非常有趣的技术解决方案，可以显着减小功率电感的尺寸，减小电容器的输出电容并提高效率。 在简单的TMS320F28027上，您可以实现4相转换器，而所有这些都将非常简单地在代码中并且仅在硬件中实现。 </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie"> 我们产生一个三相交流电压 </h1><br><p> 在许多问题中，仅在输出上获得离散值0或VCC是不够的；需要正弦波。 我有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a>讨论单相交流电压的形成，并在此处使用“表格”方法，即，最初计算了正弦波的值。 原则上，这也可以在三相中完成，但是我想展示一个替代选择，即实时或实时计算占空比值。 </p><br><p> 有一个功能。 在这种情况下，PWM频率也是50 kHz，并且在此信号的两个周期之间设置了相移。 因此，当我们以50 Hz的频率调制正弦波时，硬件相移会“丢失”，它将仍然存在于PWM之间，但不会出现在正弦波内部，因此必须通过软件完成。 三角函数对TMS320F28027来说很沉重，但是对我来说并不是很忙，所以让它来数一数。 如果您的任务需要大量计算，则需要具有TMU和FPU的控制器，例如TMS320F280049，它可以使运算速度更快。 </p><br><p> 要将占空比值加载到PWM中，我们需要一个计时器，该计时器的周期将设置采样频率。 我需要一个20 ms（1 / 50Hz = 20 ms）的周期，我将采取正弦波的步数，例如20，因此，应该以0.02 s / 20 = 0.001 ms = 1 kHz的频率生成一个中断，在此中断中，我会将值写入PWM 。 为简单起见，我将使用一个常规的<em>CPU0</em>计时器并对其进行配置： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  <em>InitCpuTimers</em>和<em>ConfigCpuTimer功能是</em>标准<em>功能</em> ，所有设置都在其中，我们只需要传输核心频率（60 MHz）和计数周期（以微秒为单位）（1000μs= 1 ms），就相当于1 kHz，我们需要它。 因此，在配置函数中的何处启用中断并传递中断处理程序的地址，一切都会在此发生。 </p><br><p> 现在，需要再次“发明”正弦公式，为此，您需要了解学校的三角学知识，仅此而已。 等等...我们有一个函数<strong><em>y = sin（x）</em></strong>让我们绘制这个函数： </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y =罪（x）"></p><br><p> 如您在图表上所见，y的幅度从-1到1变化，但我们希望从0到1，因为 最小幅度为0V，最大幅度为（等于1），我们有+ VCC。 要“汲取” -1 ... + 1，我们需要双相营养，但事实并非如此。 您需要向正方向移动图表。 如果我们仅将其提起，则它将从0变为+2，而最多只能为+1。 因此，您需要除以2之类的东西！ 让我们从简单地划分和绘制<strong><em>y =（sin（x）/ 2）开始：</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y =（正弦（x）/ 2）"></p><br><p> 是的 现在该图的范围是-0.5到+0.5，即幅度为1。它已经更好了，但是我们还没有消除负值，因此我们只需要将图上移到0.5，为此，我们只需要将此值添加到结果中并得到公式即可<strong><em>y = 0.5 +（sin（x）/ 2）</em></strong>并绘制此函数的图形： </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0.5 +（正弦（x）/ 2）"></p><br><p> 现在，一切都变得绝对完美：正弦波的振幅为0到1，不存在负值。 公式<strong><em>y = 0.5 +（sin（x）/ 2）</em></strong>描述了第一相，现在有必要添加相移以获得相2和3。为此<em>，</em>分别从<em>x</em>减去2π/ 3和4π/ 3，并获得剩余的公式<strong><em>y = 0.5 +（正弦（x-2π/ 3）/ 2）</em></strong>和<strong><em>y = 0.5 +（正弦（x-4π/ 3）/ 2）。</em></strong> 我们构建了3个图，看它是否看起来像事实： </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3阶段"></p><br><p> 还不错！ 当他们谈论三相网络或异步电动机时，该图类似于电气工程教科书中通常绘制的图。 顺便说一句，2.0943是2π/ 3，而4.1866是4π/ 3，我只是立即数了一下，它们就出现在我的代码中。 共有3个等式： </p><br><ul><li>  A相<strong><em>-y = 0.5 +（sin（x）/ 2）</em></strong> </li><li>  B相<strong><em>-y = 0.5 +（正弦（x-2π/ 3）/ 2）</em></strong> </li><li>  C相<strong><em>-y = 0.5 +（sin（x-4π/ 3）/ 2）</em></strong> </li></ul><br><p> 在数学方面，一切似乎都很简单明了，但现在需要针对微控制器的实际情况进行调整。 我们的正弦波不是模拟的，而是具有“阶梯”的，即它是离散的，因为在我的情况下，我们只能设置电压或0V或+ 15V（VCC）。 较早前，我写道我将有20个步骤，因此在1个时期内我将有20个计算。 </p><br><p> 首先，让我们决定用什么代替<em>x</em> 。 我们的正弦曲线的周期为<em>2π</em> ，这意味着采样步长为<em>2π/ 20</em> 。 因此，正弦曲线将由20个点组成，就好像我们在这些点上建立图形并在它们之间近似一样。 结果，第一步的值将为<strong><em>sin（2π*（1/20），</em></strong>第二步的值为<strong><em>sin（2π*（2/20）），</em></strong>第三步的值为<strong>sin（2π <em>（3/20））</em></strong> ，依此类推，当我们如果达到<em>20/20</em> ，则表示周期已结束，必须重新开始计数。根据收到的数据，让我们更正以下公式： </p><br><ul><li>  A相<strong><em>-y = 0.5 +（sin（2π*（n / N））/ 2）</em></strong> </li><li>  B相<strong><em>-y = 0.5 +（正弦（2π*（n / N）-2π/ 3）/ 2）</em></strong> </li><li>  C相<strong><em>y = 0.5 +（正弦（2π*（n / N）-4π/ 3）/ 2）</em></strong> </li></ul><br><p> 现在，我们现在考虑图上每个特定点的正弦值。 因此， <strong>n</strong>是当前步骤， <strong>N</strong>是总步骤（20）。 在这些公式之后，我们得到一个从0到1的值，但实际上我们并不是以抽象的幅度进行运算。 在我们的情况下，幅度取决于占空比，因为 占空比从0更改为600（通过PWM设置），然后0为0，并且1等于600。基于此，让我们将其重新计算为一个真实公式，以获取将要加载到CMPA <em>PWM寄存器中的值</em> ： </p><br><ul><li>  A相- <strong><em>占空比1 = A <em>（0.5 +（sin（2π</em> （n / N））/ 2））</em></strong> </li><li>  B相- <strong><em>占空比2 = A <em>（0.5 +（正弦（2π</em> （n / N）-2π/ 3）/ 2））</em></strong> </li><li>  C相- <strong><em>占空比4 = A <em>（0.5 +（正弦（2π</em> （n / N）-4π/ 3）/ 2））</em></strong> </li></ul><br><p> 因此， <strong>A</strong>是振幅的最大值，即600， <strong>n</strong>是当前步长， <strong>N</strong>是步长总数（20）。 占空比1，占空比2，占空比4的值是占空比的转换后的实际值，将其加载到<em>CMPA中。</em> 现在，让我们为更新的中断处理程序编写代码，并声明所有必需的变量： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// π const float piTwo = 6.2831; // 2π const float phaseShifted120deg = 2.0943; // 2π/3 const float phaseShifted240deg = 4.1866; // 4π/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p> 如您所见，该代码是最简单的，如果您了解需要执行的操作以及要解决的问题中的简单数学运算。 每次调用该中断时，我们都会递增包含步骤号的<em>activeStep</em>变量，该变量从0变为20，然后重置。 事实证明，在一个时期内，我们为每个阶段执行20个步骤和20个计算。 为了不总是在公式中计算<em>2π/ 3</em>和<em>4π/ 3</em> ，我立即将它们计算为常数。 </p><br><p> 计算结果极小，对于此MK来说绝对没有。 如果需要，可以大大增加点数，例如最多200个。这完全取决于任务。 通过更改中断调用频率和步数可以更改PWM频率。 您还可以更改可变<em>幅度</em>并更改电源转换器输出上的电压。 </p><br><p> 将代码下载到微​​控制器后，您将获得相应的图片： </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="示波器编号1"></p><br><p> 如果沿<em>Y</em>拉伸图形，则最好查看信号缺陷。 这是由于采样步骤数量少的结果，因此应用了条件规则： <strong>点数越多，信号越美观。</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="波形图3"></p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 今天，我谈到了多相系统中相移形成的过程，原则上没有什么复杂的，尤其是在使用TMS320F28时。 其余的取决于算法，原则上，在Runet的广阔领域中，有很多文章讨论了控制和无刷电机，异步以及各种各样的其他事情，您只需要改变逻辑即可。 </p><br><p> 我希望这些材料会有用，并且阅读起来不会特别无聊。 与往常一样，源被附加： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将项目与Code Composer Studio一起存档</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457548/">https://habr.com/ru/post/zh-CN457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457534/index.html">认证版本-我们选择的耙</a></li>
<li><a href="../zh-CN457538/index.html">如何使用中断的Yandex.Cloud虚拟机并节省解决大型问题的费用</a></li>
<li><a href="../zh-CN457540/index.html">一年之后，Intel Optane DC永久内存</a></li>
<li><a href="../zh-CN457542/index.html">黑客和保护加密驱动器LUKS</a></li>
<li><a href="../zh-CN457546/index.html">演示日：这一切为何，怎么做UPD + Broadcast</a></li>
<li><a href="../zh-CN457550/index.html">需要保护数字产业免受什么伤害</a></li>
<li><a href="../zh-CN457552/index.html">Zafasadia的登山者。 拉赫塔中心塔楼的小样如何工作</a></li>
<li><a href="../zh-CN457558/index.html">EvilParcel漏洞分析</a></li>
<li><a href="../zh-CN457560/index.html">代币化的股票：如何在首次公开募股前成为普通投资者</a></li>
<li><a href="../zh-CN457562/index.html">Ivideon Counter 3D：由谁，如何以及为什么对访问者进行计数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>