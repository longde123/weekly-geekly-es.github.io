<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈷️ 🕠 👩🏽‍🔧 Comment les tests peuvent vous aider à créer votre propre kit d'interface utilisateur 🖤 👩🏿‍🌾 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour ceux qui n'aiment pas les longues introductions, passons directement aux conclusions - écrivez des tests pour vos composants. Sérieusement, c'est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les tests peuvent vous aider à créer votre propre kit d'interface utilisateur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481528/"> Pour ceux qui n'aiment pas les longues introductions, passons directement aux conclusions - écrivez des tests pour vos composants.  Sérieusement, c'est tout ce que je veux dire.  Mais ne prenons pas cela trop au sérieux, imaginons que ce sont les conclusions d'un théorème, un théorème frontal.  Et maintenant, nous devrons trouver des preuves. <br><a name="habracut"></a><br>  Alors, imaginons.  Qu'est-ce qui est commun dans le développement informatique, pas seulement dans le frontend, le backend ou la conception, les langages de programmation, la gestion, les méthodologies et ainsi de suite?  Je suppose qu'il y a un seul principe principal - la décomposition et les composants. <br><br>  Que nous le voulions ou non, que nous comprenions ce que nous écrivons ou non, nous travaillons avec des composants, nous décomposons toujours les tâches en plus petites. <br><br>  Et en se réunissant pour la millionième fois pour écrire la prochaine implémentation de la table pour notre magnifique kit d'interface utilisateur, je me suis dit - quel travail préliminaire dois-je faire?  Que faut-il exactement écrire?  Et par où commencer? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/120/eb4/600120eb4a5523a073af57d1d56e36b4.png" alt="image"><br><br>  Après avoir parlé avec des coéquipiers, j'ai entendu quelques conseils.  J'en ai vraiment aimé un.  Comme je suis fan de singularité et d'un peu de graphql, on m'a demandé de ne rien écrire du tout.  Utilisez la balise {table} et un réseau de neurones traitera cette table, créera une requête graphql et remplira la table avec des données.  Facile :). <br>  Mais comme on dit - «il y a une faille fatale dans n'importe quel système», j'ai commencé à réfléchir à «comment inventer ma propre roue».  Et les gens intelligents ont déjà tout inventé devant nous.  Nous, les milléniaux, ne pouvons que réorganiser les assiettes et nommer les choses différemment. <br><br>  Je suis prêt à présenter mon propre ensemble de principes de prototypage de kits d'interface utilisateur - IDOLS!  Jetons un coup d'oeil! <br><br>  Je représente la ségrégation d'interface, D signifie l'inversion de dépendance, O signifie ... je plaisante, bien sûr, c'est SOLIDE <br><br>  Toutes les tentatives de formaliser le travail avec des composants sont réduites à cela.  Ces principes peuvent être étendus indéfiniment, mais tout est toujours le résultat final est réduit à ces cinq.  Si nous parlons bien sûr de POO ou CBP (programmation par composants). <br><br>  Chargeons ces principes dans notre «RAM» et passons en revue les points. <br><br><h3>  S - Responsabilité unique </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/512/df3/3b6/512df33b63f26500f8925f172b4a9915.gif" alt="image"><br>  Hmm, s'il te plait ne le fais pas ... <br><br>  Utilisez un composant spécial pour différents cas.  Vous ne devez PAS créer un composant, qui sera capable de couper quelque chose et d'arracher quelque chose en même temps.  Faites deux morceaux différents. <br><br><h3>  O - Ouvert / Fermé </h3><br>  Le principe dit que vos composants doivent être ouverts pour les améliorations et fermés pour les modifications, en d'autres termes, vous pouvez réutiliser votre composant dans un autre composant, mais vous ne devez pas changer votre composant s'il respecte déjà le principe de la responsabilité unique. <br><br><h3>  L - Substitution de Liskov </h3><br>  Petite extension du principe précédent, toute instance d'une sous-classe peut être utilisée à la place d'une instance de la classe de base.  Je ne sais pas comment ce principe s'inscrit dans le contexte des composants, il s'agit très probablement d'une duplication du principe précédent. <br><br><h3>  I - Ségrégation des interfaces </h3><br>  Nous en parlerons encore plus loin, maintenant nous pouvons dire qu'il vaut mieux donner à l'autre développeur beaucoup de petites interfaces qu'une grande mais pour tout.  Comparons les exemples ci-dessous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5b/7bb/981/b5b7bb981c678f483ebed5cf91971716.png" alt="image"><br>  Tout se configure en un seul endroit, non maintenable, non réutilisable ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/576/dc0/c47/576dc0c47a3c8edc5f21ecb64153f42b.png" alt="image"><br>  Tout en tant que constructeur, assemblez comme vous le souhaitez et commodément <br><br><h3>  D - Inversion de dépendance </h3><br>  Le principe selon lequel les différentes parties de l'application ne doivent rien savoir les unes des autres et ne doivent être héritées que par le biais d'interfaces communes.  Ici, nous parlons davantage de réutilisation et de réduction de la connectivité des composants.  Le composant du tableau n'a pas besoin de savoir d'où et comment les données proviennent, il a seulement besoin de connaître le DataLoader conditionnel, qui peut être n'importe quoi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/7c7/a9a/3cf7c7a9a29d4616f239367d4c13027f.png" alt="image"><br><br>  Mais un point de vue ne nous suffit pas.  Puisque dans cette situation, il est très facile de devenir l'otage de cette idée.  Par conséquent, nous considérons le développement de composants d'un autre côté, du côté de la conception. <br><br>  Dans ce cas, nous considérerons l'une des approches de conception de plus en plus populaires, à savoir la conception atomique.  Relativement parlant, la conception atomique est une autre façon de décomposer les éléments de l'interface utilisateur en les comparant avec une hiérarchie de la physique et de la biologie. <br><br>  Jetons donc un coup d'œil à la conception atomique. <br><br><h3>  Jetons </h3><br>  Le premier niveau est les jetons, quelqu'un inclut cela dans le modèle, quelqu'un non, mais cela vaut la peine d'être mentionné.  Les jetons (couleurs, tailles de police, espacements, animations) sont toutes les primitives que nous pouvons réutiliser sur n'importe quelle plateforme. <br><br>  Il convient de noter que plus nous sommes élevés dans la hiérarchie de la conception atomique, plus la réutilisation diminue.  Mais plus à ce sujet plus tard. <br><br><h3>  Atomes </h3><br>  Viennent ensuite les atomes (composants simples sans logique, entrées, boutons).  Le premier niveau est l'endroit où les composants apparaissent et ce qu'ils produisent.  Les atomes n'ont aucun état, affichent uniquement un balisage de style statique. <br><br><h3>  Molécules </h3><br>  Les atomes s'assemblent ensuite en molécules (liaisons composantes plus complexes).  Les molécules peuvent avoir leur propre état, mais ce n'est pas un état commercial, il peut s'agir d'un état de configuration (comme isOpen).  Nous pouvons deviner que les molécules ressemblent plus à un proxy entre le premier état des affaires et la façon dont nous alignons le contenu de nos atomes ou enfants en fonction de cet état. <br><br>  Les molécules sont le dernier niveau où nous pouvons rencontrer le style. <br><br><h3>  Organismes </h3><br>  Les molécules constituent des organismes (groupes de travail intégrés de composants), par exemple un en-tête, un pied de page, etc.  Les organismes ne savent rien des autres organismes et styles, c'est nos «conteneurs d'ADN» notre logique métier, qui savent le montrer et quand il faut le changer. <br><br><h3>  Modèles / Pages </h3><br>  Le dernier niveau de conception atomique.  Ce niveau représente les groupes d'organismes inclus dans la page actuelle. <br><br>  Nous pouvons faire la composition des organismes sur la page via des molécules, puis appeler cette page comme «mise en page» et la réutiliser en changeant nos organismes à l'intérieur. <br><br>  En utilisant ces deux approches (SOLID et Atomic), nous essaierons de formuler quelques recommandations lors du développement de composants.  Donc, ces recommandations seront nécessaires pour que nous comprenions ce que nous faisons exactement quand nous disons «créer un autre composant». <br><br>  Étant donné que ces composants fonctionneront avec d'autres développeurs, nous garderons cela à l'esprit lorsque nous installerons l'interface et l'API. <br><br>  Nous pouvons commencer à développer notre interface idéale. <br><br>  La première chose à faire est de ne pas commencer à développer une interface idéale.  L'interface idéale est son manque.  Une interface est un obstacle entre ce que vous avez fait et quand elle commence à fonctionner.  C'est une douleur qui doit être évitée. <br><br>  Ainsi, la meilleure solution serait la suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/283/6cc/b782836ccaf89f564af263a1dc2eb274.png" alt="image"><br>  Cela nous amène en douceur à ce qui suit: <br><br><h3>  1. Déterminez l'état du composant </h3><br>  Si un développeur qui utilise ce composant le voit pour la première fois, faites-en un peu d'intégration, traduisez le composant dans de nouveaux états à mesure que la complexité des paramètres augmente et informez-en le développeur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a0/57c/fab/9a057cfab3b778d2db16ff7781442a0f.png" alt="image"><br><br>  Les états peuvent être complètement différents à différents moments. <br>  Vide → Téléchargement → Chargement → Chargement d'une autre pièce → Complètement chargé → Erreur, etc. <br>  Guidez les développeurs à travers toutes les combinaisons possibles d'états, enseignez-leur pendant qu'ils travaillent. <br><br>  Lorsque l'on traite des problèmes d'état, on tombe involontairement sur le problème des états par défaut.  À cause de cela, la deuxième recommandation. <br><br><h3>  2. Définissez les valeurs par défaut </h3><br>  Avec cet article, vous pouvez tuer deux oiseaux avec une pierre, vous fournissez non seulement des informations de base au développeur sur ce qui se passe avec l'application mais pour vous, l'absence de l'une ou l'autre variable ne sera pas une surprise qui casse tout.  De plus, de vilains contrôles de leur présence ne sont en principe pas nécessaires. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af5/319/7d2/af53197d2ee168059b47030a793bf8a8.png" alt="image"><br><br>  De plus, si le développeur souhaite toujours ajouter des paramètres, il est nécessaire de l'aider à ce sujet, et de ne pas interférer. <br><br>  Compte tenu de la théorie de Richard Gregory, les gens explorent le monde qui les entoure sur la base d'expériences visuelles antérieures.  Et si votre composant change quelque chose sous son capot et que vous souhaitez en informer le développeur, appelez vos hooks et rappels de manière prévisible. <br><br><h3>  3. Pas besoin de réinventer la roue </h3><br>  Pas changePasswordInputValue, mais onChange, car si c'est votre "molécule", il sera toujours clair ce que la valeur va changer. <br><br>  Eh bien, essayez de suivre les règles générales de dénomination, le préfixe on pour les événements, les verbes pour les actions, et si vous utilisez le drapeau booléen isDisabled à un endroit, puis utilisez-le partout, vous n'avez plus besoin de isEnabled, soyez cohérent. <br><br>  La prochaine chose à laquelle vous devez faire attention est que lorsque vous avez fini de travailler sur le composant, vous le transmettez, d'autres développeurs travailleront plus loin avec lui.  Et si quelque chose ne va pas avec votre composant, vous devrez commencer un nouveau cercle de développement: le développeur trouve un bogue ou ne peut pas faire quelque chose qu'il veut → ouvre le problème → vous cherchez un temps pour le corriger → pensez à la cohérence → corrigez → mettre à jour les packages → annoncer aux développeurs → mettre à jour les packages → essayer de faire ce qu'ils voulaient il y a une semaine. <br><br><h3>  4. Essayez de donner aux développeurs autant de contrôle que possible </h3><br>  Comme s'ils avaient écrit ce composant en ce moment - une conclusion directe de l'un des principes de SOLID <br>  Supposons que vous autorisiez la transmission d'un morceau de texte à votre composant.  Si ce texte est présent, il sera affiché, mais vous vous souvenez également de la règle sur les états par défaut et écrivez la condition que si le texte n'est pas transmis, affichez le texte par défaut.  Donc, sur un bon ton, cela donnera au développeur d'indiquer explicitement que le texte n'est pas nécessaire ici. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/a1a/730/c4ca1a7300df915ee720aeaf1d211d31.png" alt="image"><br><br>  Eh bien, si vous considérez qu'en premier lieu nous commençons à travailler avec des composants atomiques, la recommandation suivante vient d'ici. <br><br><h3>  5. Gardez vos composants propres et secs afin que les abstractions ne fuient pas (KISS). </h3><br>  Comment suivre ça?  - tout simplement, n'écrivez pas de code dans votre composant.  Seul le modèle et comment il dessine les données d'entrée.  Si vous devez faire une carte, filtrer, réduire sur les données, vous avez des constantes qui ne peuvent pas être redéfinies à l'extérieur, votre modèle utilise des littéraux, ce qui est faux - ce n'est plus un atome, mais autre chose, c'est plus difficile à maintenir.  Cela doit être évité. <br><br>  Nous avons donc obtenu une liste de recommandations qu'il serait bon de suivre. <br><br><ol><li>  Définir l'état </li><li>  Définir la valeur par défaut </li><li>  Ne réinventez pas la roue </li><li>  Laissez-les (devs) gouverner </li><li>  Keep It Simple, Stupid (KISS) </li></ol><br>  Mais notre cerveau est tellement agencé qu'après avoir écrit deux ou trois composantes - nous commençons à penser que nous n'avons pas besoin d'examiner cette liste pour vérifier tous les points.  Et nous savons que parmi les tâches les plus complexes et les plus faciles, nous choisissons toujours la plus facile car elle fonctionne comme ça.  Nous aimons économiser notre énergie, nous en avons besoin, en réserve.  Par conséquent, ces listes sont toujours perdues dans la confluence jusqu'à des temps meilleurs, et nous continuons à corriger les bogues vers le maître. <br><br>  Ce n'est que si nous comprenons qu'il sera plus facile que de ne pas dormir pendant deux semaines d'affilée de rendre sage pour nous, en général, de corriger les bugs en production, nous rendrons la tâche plus difficile (pour des raisons objectives) et plus facile (pour notre raisons). <br><br>  Comment alors tromper notre cerveau et faire fonctionner les recommandations? <br><br>  Eh bien, essayons d'automatiser cela. <br><br><h3>  Automatisation </h3><br>  Nous pouvons utiliser le bundle eslint + lefthook ou tout autre outil git-hooks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/d27/576/ca4d27576be845430a6c9f8f63266e17.png" alt="image"><br><br>  Nous décrivons les règles de la façon dont nous voulons voir nos variables et comment notre code doit être stylisé.  Nous interdisons les nombres magiques et les littéraux dans les modèles, nous attendons de nous que nous écrivions des quais pour notre code immédiatement.  Nous raccrochons ces vérifications pour un crochet git et recevons des notifications automatiques que notre code est mauvais et doit être mis à jour. <br><br>  Mais ce n'est pas une solution miracle et nous ne pouvons pas respecter toutes les recommandations.  Seulement une partie. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/011/93c/bd8/01193cbd83fd6e04332f434db6a41ddb.png" alt="image"><br><br>  De cette façon, nous ne pouvons pas gérer nos états possibles et ne pouvons garantir que les autres développeurs obtiendront ce qu'ils veulent.  Nous pouvons simplement supposer, par exemple, que quelque chose retournera de toute façon (aka valeur par défaut) mais pas plus. <br><br>  Ensuite, vous pouvez essayer une autre façon.  Développer nos composants via SDD.  Développement piloté par le livre de contes. <br><br><h3>  Développement basé sur un livre de contes </h3><br>  Nous avons un fichier d'histoire sous la forme où nous décrivons tous les états possibles du composant.  Et un livre d'histoires rassemblant ces histoires. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d4/cd7/ae4/3d4cd7ae4d32a947e46e20302ceed45e.png" alt="image"><br>  Nos histoires sur le composant <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/33a/4e8/74b33a4e84ead0e44854f1d217222e11.png" alt="image"><br>  Comment le livre d'histoires nous montre des histoires <br><br>  Développer vos composants indépendamment de l'environnement de travail est non seulement un plus pour la pureté des composants, mais cela vous permettra également de voir immédiatement quels états ne sont pas couverts par les tests et lesquels, en principe, sont absents. <br><br>  Mais au final, cela ne nous donnera pas non plus tout ce que nous voulons. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1f/cd1/000/d1fcd1000db741827c30f198dd5caf1d.png" alt="image"><br><br>  Il ne reste donc qu'une chose. <br><br><h3>  Tests et instantanés </h3><br>  Puisque nos composants sont des atomes et des molécules, il devient un plaisir d'écrire des tests unitaires, chaque composant est responsable d'une fonctionnalité que nous pouvons facilement tester en éliminant plusieurs éléments de la liste des recommandations à la fois. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/1e7/454/eb31e7454245f6427aa2667263a1b8b5.png" alt="image"><br><br>  Nous pouvons mettre en place des contrôles instantanés, ce qui nous permettra de surveiller l'état de nos composants et d'apprendre toutes les modifications à l'avenir. <br><br>  Nous pouvons utiliser un faisceau avec une enzyme pour contrôler nos attentes pendant le développement.  Et étrangement, en ce qui concerne les recommandations dans lesquelles nous attendons quelque chose d'un développeur qui écrit du code, seuls les tests et leur écriture conviennent le mieux.  Ils ont été littéralement inventés pour cela. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/012/7de/3e7/0127de3e73e263b686cb9fbe8f7d0dea.png" alt="image"><br><br>  Et c'est parti ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/e0d/adf/0f8e0dadfc1c7d70455e70a06f691ce1.png" alt="image"><br><br>  Rédigez des tests pour vos composants.  Merci. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481528/">https://habr.com/ru/post/fr481528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481514/index.html">Travailler avec la bibliothèque Newtonsoft.Json avec un exemple réel. Partie 1</a></li>
<li><a href="../fr481516/index.html">La complexité de l'élaboration d'un vaisseau spatial</a></li>
<li><a href="../fr481518/index.html">Project Management Professional (PMP): 6e édition Quoi? Pourquoi? et pourquoi?</a></li>
<li><a href="../fr481522/index.html">Sur la barre inférieure, ou contre la présomption de santé mentale</a></li>
<li><a href="../fr481524/index.html">Audit simultané pendant le vote électronique</a></li>
<li><a href="../fr481530/index.html">Nevanger: Nourrir pour la vitesse</a></li>
<li><a href="../fr481532/index.html">Forensics de la mémoire, Rubber Duck et mots de passe GPO. Résolution de problèmes avec r0ot-mi. 2e partie</a></li>
<li><a href="../fr481534/index.html">Delphi est-il en train de mourir - Faux</a></li>
<li><a href="../fr481536/index.html">L'histoire du système des noms de domaine: les protocoles de «guerre»</a></li>
<li><a href="../fr481538/index.html">20 mythes SEO à mourir en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>