<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘â€ğŸ¤â€ğŸ§‘ ğŸ‘°ğŸ¼ ğŸ… Alami 1440 migrasi basis data ğŸ¦’ ğŸ“„ ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan Oracle DBA. Dia sudah lebih dari tiga puluh tahun, dia sedikit kelebihan berat badan, mengenakan rompi, dia memiliki tanda akses rahasia ke ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alami 1440 migrasi basis data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wrike/blog/414441/"><img src="https://habrastorage.org/webt/pv/6j/9e/pv6j9e1v5h6g8nvmd5am7bhtmb8.jpeg"><br><br>  Bayangkan Oracle DBA.  Dia sudah lebih dari tiga puluh tahun, dia sedikit kelebihan berat badan, mengenakan rompi, dia memiliki tanda akses rahasia ke semua pangkalan yang tergantung di lehernya, dan dalam ringkasan setengah halaman dari sertifikasi yang dia lewati.  Sabtu  Hari rilis besar.  Klimaks.  Saatnya melempar perubahan ke basis data.  Dia mengetik sqlplus, menekan ENTER, dan suatu tempat layar hitam ke dalam kekosongan, kilometer dari perintah SQL terburu-buru.  Sama seperti dalam perang bintang.  Lima menit kemudian, semuanya sudah siap.  Satu jam kemudian, rilisnya selesai.  Pekerjaan selesai, hari itu sukses.  Sekarang Anda dapat memiliki beberapa gelas bir. <br><a name="habracut"></a><br>  Hal lain adalah hari Senin.  Ternyata beberapa perintah tidak dieksekusi karena kesalahan, yang, bagaimanapun, tidak menghentikan skrip dalam mengejar kekosongan hitam yang tak terkendali.  Tugas yang sudah sulit untuk mencari tahu apa yang rusak adalah rumit oleh beberapa tekanan dari kepemimpinan.  Secara umum, Senin tidak berhasil. <br><br>  Tentu saja, ini adalah cerita fiksi.  Ini tidak pernah terjadi pada siapa pun.  Setidaknya, itu tidak akan terjadi jika pekerjaan mengubah skema basis data telah diselenggarakan melalui migrasi. <br><br><h3>  Apa itu alat migrasi basis data? </h3><br>  Gagasan mengelola perubahan skema database melalui migrasi sangat sederhana: <br><br><ol><li>  Setiap perubahan dikeluarkan sebagai file migrasi terpisah. </li><li>  File migrasi mencakup perubahan langsung dan mundur. </li><li>  Aplikasi migrasi ke database dilakukan oleh utilitas khusus. </li></ol><br>  Contoh migrasi paling sederhana: <br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- 20180618152059: create sequence for some_table CREATE SEQUENCE some_table_seq; --//@UNDO DROP SEQUENCE some_table_seq;</span></span></code> </pre> <br>  Pendekatan ini memberikan banyak keuntungan dibandingkan mengatur perubahan dalam file SQL yang umum.  Tidak adanya konflik penggabungan tidak sia-sia. <br><br>  Lebih mengejutkan lagi bahwa pendekatan itu sendiri telah mendapatkan popularitas relatif baru-baru ini.  Tampaknya kerangka kerja Ruby on Rails, di mana alat migrasi awalnya dibangun, adalah ketenaran utama dari pendekatan, itu adalah akhir tahun 2005.  Sedikit lebih awal, Martin Fowler, 2003 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang pendekatan tersebut. Mungkin, intinya adalah bahwa pengembangan mulai secara aktif mengadaptasi penggunaan sistem kontrol versi hanya pada awal abad ini.  Kembali pada tahun 2000, paragraf pertama dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes Joel Spolsky</a> adalah <i>"Apakah Anda menggunakan kontrol sumber?"</i>  - ini menunjukkan bahwa tidak semua orang menggunakan sistem kontrol versi pada saat itu.  Tapi kami terganggu. <br><br><h3>  Delapan tahun dengan Migrasi MyBatis </h3><br>  Kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wrike</a> mulai menggunakan pendekatan perubahan basis data melalui migrasi pada 2010, 29 Maret, jam setengah dua belas.  Sejak itu, kami telah menerapkan 1.440 migrasi, yang mengandung 6.436 perubahan langsung dan 5.015 terbalik.  Secara umum, kami telah memperoleh beberapa pengalaman menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi MyBatis</a> bersama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PostgreSQL</a> . <br><br>  Singkatnya, kita tidak pernah menyesal.  Jika Anda tidak menggunakan Migrasi atau yang serupa, sekarang saatnya untuk memulai.  Ya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pentium 4</a> juga ketinggalan jaman. <br><br>  Tapi itu membosankan untuk berbicara tentang manfaat dari apa pun, mari kita langsung ke kesulitan. <br><br><h3>  Spesifikasi postgreSQL </h3><br>  Mungkin tidak ada kesulitan dengan menulis migrasi untuk Postgres, mungkin, kecuali dua: <br><ul><li>  Anda tidak dapat membuat indeks, </li><li>  Anda tidak dapat menambahkan kolom NOT NULL. </li></ul><br>  Tidak, sebenarnya itu mungkin, hanya saja tidak dengan cara yang sepenuhnya jelas.  Saat membuat indeks, Anda harus selalu menentukan <i>CREATE INDEX CONCURRENTLY</i> , jika tidak Anda akan merusak produksi, karena Postgres akan mengunci tabel selama durasi pembuatan indeks, dan ini bisa memakan waktu yang cukup lama.  Tentu saja, pengembang melupakannya sekali, Anda harus selalu mengingat kehalusan ini.  Di sini orang bisa menulis tes.  Tapi ini hanya sedikit ketidaknyamanan. <br><br>  Membuat kolom NOT NULL lebih rumit, di sini Anda perlu membuat perubahan dalam empat langkah: <br><ol><li>  Buat kolom NULL (di Postgres gratis). </li><li>  Setel kolom DEFAULT ke nilai. </li><li>  Dalam satu lingkaran, perbarui nilai NULL secara bertahap dalam DEFAULT. </li><li>  Setel SET BUKAN NULL. </li></ol><br>  Tangkapan terbesar di sini adalah di paragraf ketiga.  Nilai NULL perlu diperbarui dalam bagian, karena <code>UPDATE some_table SET some_column='' WHERE some_column IS NULL</code> ;  akan memblokir tabel, seperti halnya dengan indeks, dengan konsekuensi yang sama.  Dan Migrasi hanya dapat menjalankan perintah SQL, sehingga skrip tersebut harus digulirkan ke dalam produksi dengan tangan.  Kesenangan di bawah rata-rata.  Sekarang, jika sebuah siklus dapat ditulis dalam Migrasi, tidak akan ada masalah.  Mungkin ini diimplementasikan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kait</a> . <br><br>  Membuat indeks <code>UNIQUE</code> dan mengubah <code>PRIMARY KEY</code> juga membutuhkan beberapa keterampilan, tetapi operasi ini relatif jarang dipikirkan. <br><br><h3>  Khusus kluster </h3><br>  Alat manajemen migrasi basis data bagus selama Anda memiliki satu basis data.  Lebih menyenangkan jika Anda memiliki beberapa pangkalan.  Terutama jika Anda memiliki beberapa jenis database, yang masing-masing memiliki beberapa contoh. <br><br>  Akibatnya, setelah <code>git pull</code> pengembang harus memutar perubahan ke instance pertama dari database pertama, kemudian ke instance kedua, lalu ke instance pertama dari database kedua dan seterusnya - prinsip seperti itu.  Di sini tepat untuk menulis utilitas untuk mengelola utilitas manajemen migrasi basis data.  Otomatisasi total. <br><br><h3>  Juggling peran </h3><br>  Bukan rahasia lagi bahwa peran sebagai entitas tidak hidup di tingkat basis data yang terpisah, tetapi di tingkat seluruh server basis data, setidaknya di Postgres.  Dalam hal ini, Anda mungkin perlu menentukan <code>REVOKE INSERT ON some_table FROM some_role</code> ;  Masih mungkin untuk mengharapkan peran yang telah dikonfigurasikan sebelumnya dalam produksi, tetapi untuk dev atau pementasan ini sudah sulit.  Pada saat yang sama, dalam pengembangan, tentu saja, semua database ada di server lokal yang sama, jadi Anda tidak dapat menulis <code>CREATE ROLE</code> dalam migrasi, dan <code>IF NOT EXISTS</code> tidak didukung.  Semuanya diselesaikan dengan mudah: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_roles <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rolname = <span class="hljs-string"><span class="hljs-string">'some_role'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROLE</span></span> <span class="hljs-string"><span class="hljs-string">"some_role"</span></span> NOLOGIN; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$;</code> </pre><br>  Lihat itu!  Saya menangkap dan melemparkannya, menangkap dan melempar, itu sangat sederhana. <br><br><h3>  Sedikit realitas pembangunan </h3><br>  Pengembang membuat kesalahan, dan bahkan dalam migrasi SQL, ini terjadi.  Biasanya kesalahan bisa dilihat dalam ulasan, tetapi bisa juga tidak biasa.  Jika kita berbicara tentang perubahan langsung, maka tiang tembok di sana masih belum mencapai produksi - terlalu banyak tahapan verifikasi.  Tetapi dengan perubahan sebaliknya, insiden dapat muncul.  Untuk menghindari kesalahan dalam migrasi UNDO, saat menguji migrasi, Anda harus melakukan tidak hanya <code>./migrate up</code> , tapi <code>./migrate up</code> , lalu <code>./migrate down</code> , lalu lagi <code>./migrate up</code> .  Ini tidak rumit, Anda hanya perlu memastikan bahwa empat puluh pengembang selalu melakukan ini.  Dengan cara yang baik, utilitas dapat melakukan kombo seperti itu untuk lingkungan pengembang secara otomatis. <br><br><h3>  Lingkungan uji </h3><br>  Jika lingkungan pengujian berumur pendek: misalkan Anda membuat sebuah wadah, menginisialisasi database dan menjalankan tes integrasi, seharusnya tidak ada masalah.  Kami <code>./migrate bootstrap</code> , lalu <code>./migrate up</code> , dan Anda selesai.  Saat itulah jumlah migrasi melebihi seribu, proses ini dapat ditunda.  Sayang sekali ketika database diinisialisasi lebih lama dari tes dijalankan.  Kita harus menghindar. <br><br>  Dengan lingkungan yang berumur panjang, itu masih lebih sulit.  QA, Anda tahu, mereka tidak ingin melihat database bersih tanpa cela ketika mereka mulai bekerja.  Saya tidak tahu mengapa demikian, tetapi fakta adalah fakta.  Jadi keadaan basis yang digunakan dalam pengujian manual harus dijaga dalam integritas.  Dan ini tidak selalu mudah. <br><br>  Kehalusannya adalah bahwa jika migrasi diterapkan ke database, pengenal migrasi ditulis ke sana.  Dan jika kode migrasi kemudian diubah, basis data tidak akan terpengaruh.  Jika perubahan tidak kritis, kode dapat berhasil diproduksi.  Sinkronisasi Rss.  Tentu saja, ini memalukan.  Prinsip pertama bekerja dengan migrasi adalah jangan pernah mengubah migrasi tertulis, tetapi selalu buat yang baru.  Tetapi kadang-kadang saya merasa seperti meraba-raba - Saya akan berubah sedikit di sini, tidak ada yang akan rusak, karena kebenarannya.  Tentu saja!  Silakan! <br><br>  Jika migrasi ditandatangani setelah peninjauan, akan mungkin untuk melarang penerapan draft untuk pementasan.  Dan dimungkinkan untuk menyimpan tidak hanya pengidentifikasi migrasi di <code>changelog</code> , tetapi juga <code>checksum</code> - juga berguna. <br><br><h3>  Kembali seperti semula </h3><br>  Belokan berbahaya terjadi ketika tugas dibatalkan: mereka lakukan, lakukan, dan berubah pikiran.  Ini situasi normal.  Setelah kode tidak lagi diperlukan, cabang harus dihapus.  Dan ada migrasi ... dan dia sudah dalam pementasan ... ah, ... oops.  Alasan yang bagus untuk memeriksa apakah Anda dapat memulihkan cadangan repositori.  Meskipun mengingat bahwa mungkin ada yang lebih mudah. <br><br>  Pada saat yang sama, migrasi adalah teks.  Dan dimungkinkan untuk menyimpan teks ini di sana, di <code>changelog</code> .  Lalu, jika migrasi dari kode hilang, tidak masalah untuk alasan apa, itu selalu bisa dibatalkan.  Dan bahkan secara otomatis. <br><br><h3>  Lakukan undo lagi </h3><br>  Bagian UNDO pasti dibutuhkan.  Tapi mengapa menulisnya?  Tentu saja, ada beberapa kasus yang menarik, tetapi sebagian besar perubahannya adalah <code>CREATE TABLE</code> atau <code>ADD COLUMN</code> atau <code>CREATE INDEX</code> .  Bagi mereka, utilitas dapat menghasilkan operasi terbalik secara otomatis, langsung menggunakan kode SQL.  Tentu saja ada kekhususan.  <code>CREATE TABLE ${name}</code> - ini adalah tim khusus, tiba-tiba tidak standar.  Ya, dan untuk menghasilkan <code>DROP TABLE ${name}</code> , Anda harus dapat mengurai ekspresi hingga kata ketiga.  Meskipun, secara umum, ini adalah tugas teknis yang sepenuhnya layak.  Bisa di luar kotak. <br><br><h3>  Kesimpulan </h3><br>  Tentu saja, saya menemukan kesalahan.  Migrasi MyBatis dipahami sebagai utilitas sederhana dan universal, minimal terkait dengan spesifikasi basis data.  Dan dia lebih dari membenarkan dirinya sendiri.  Tetapi tampaknya beberapa perbaikan kecil akan membuatnya jauh lebih baik, terutama bila digunakan jarak jauh. <br>  - <br>  <i>Dmitry Mamonov / Wrike</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414441/">https://habr.com/ru/post/id414441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414427/index.html">Apa yang bisa dilakukan oleh printer 3D? Laporan dari pembuat pameran Faire Bay Area 2018</a></li>
<li><a href="../id414429/index.html">Cara belajar bahasa asing tanpa guru. Bagian 1. "Pengalaman saya"</a></li>
<li><a href="../id414431/index.html">Mitap JavaJam. Javista berdebat, arung jeram, eksperimen dan layanan mikro</a></li>
<li><a href="../id414433/index.html">Kami berjalan di sekitar kota dengan bijak: ketika saya melakukan layanan untuk membangun rute jalan kaki yang menarik</a></li>
<li><a href="../id414437/index.html">Pemblokiran telegram memicu peningkatan biaya startup lokal</a></li>
<li><a href="../id414443/index.html">Fitur panggilan fungsi di C ++</a></li>
<li><a href="../id414445/index.html">Meningkatkan Zimbra dengan Zextras Suite</a></li>
<li><a href="../id414447/index.html">Macam-macam sepanjang masa</a></li>
<li><a href="../id414449/index.html">Cara berteman dengan semua operator di stadion dan tidak menaburnya dengan ratusan antena</a></li>
<li><a href="../id414451/index.html">"Kalender Tester" untuk bulan Juni. Penguji harus menangkap bug, membaca Caner dan mengatur gerakan.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>