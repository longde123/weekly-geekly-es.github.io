<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ö üë®üèº‚Äçüîß ‚ûó Klasse JavaScript Unterst√ºtzung der JavaScript-Serialisierung üóØÔ∏è üöµ üßôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Derzeit entwickle ich einen Javascript-Schema-Editor. W√§hrend dieser Arbeit bin ich auf ein Problem gesto√üen, auf das sich dieser Artikel k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klasse JavaScript Unterst√ºtzung der JavaScript-Serialisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog">  Prolog </h3><br><p>  Derzeit entwickle ich einen Javascript-Schema-Editor. W√§hrend dieser Arbeit bin ich auf ein Problem gesto√üen, auf das sich dieser Artikel konzentrieren wird, n√§mlich die Serialisierung und Deserialisierung komplexer Datenobjekte. </p><br><p> Ohne auf Details des Projekts einzugehen, stelle ich fest, dass das Schema meiner Idee nach ein Array von Elementen (Eckpunkten) ist, die von der Basisklasse geerbt wurden.  Dementsprechend implementiert jede untergeordnete Klasse ihre eigene Logik.  Dar√ºber hinaus enthalten die Eckpunkte Verkn√ºpfungen miteinander (Pfeile), die ebenfalls erhalten bleiben m√ºssen.  Theoretisch k√∂nnen sich Eckpunkte direkt oder durch andere Eckpunkte auf sich selbst beziehen.  Standard JSON.stringify kann ein solches Array nicht serialisieren, daher habe ich beschlossen, einen eigenen Serializer zu erstellen, der die beiden beschriebenen Probleme l√∂st: </p><br><ol><li>  M√∂glichkeit, Klasseninformationen w√§hrend der Serialisierung zu speichern und w√§hrend der Deserialisierung wiederherzustellen. </li><li>  Die M√∂glichkeit, Links zu Objekten zu speichern und wiederherzustellen, einschlie√ülich  zyklisch. </li></ol><br><p>  Lesen Sie mehr √ºber die Erkl√§rung des Problems und seine L√∂sung unter dem Schnitt. </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Github Serializer Projekt </h3><br><p>  Link zum Github-Projekt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . <br>  Komplexe Beispiele befinden sich auch im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">test-src</a> . </p><br><p>  Rekursiver Serializer: <a href="">Link</a> . <br>  Flat Serializer: <a href="">Link</a> . </p><br><h3 id="postanovka-zadachi">  Erkl√§rung des Problems </h3><br><p>  Wie bereits erw√§hnt, besteht die anf√§ngliche Aufgabe darin, beliebige Schaltkreise f√ºr den Editor zu serialisieren.  Um keine Zeit mit der Beschreibung des Editors zu verschwenden, setzen wir die Aufgabe einfacher.  Angenommen, wir m√∂chten eine formale Beschreibung eines einfachen Algorithmusschemas unter Verwendung von ES6-Javascript-Klassen erstellen und dieses Schema dann serialisieren und deserialisieren. </p><br><p>  Im Internet habe ich ein geeignetes Bild des einfachsten Algorithmus zur Bestimmung des Maximums von zwei Werten gefunden: </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="Bild"></p><br><p>  Hier muss ich sagen, dass ich kein Javascript-Entwickler bin und meine "Muttersprache" C # ist. Der Ansatz zur L√∂sung des Problems wird daher durch die Erfahrung der objektorientierten Entwicklung in C # bestimmt.  In diesem Diagramm sehe ich die Eckpunkte der folgenden Typen (bedingte Namen und spezielle Rollen spielen keine Rolle): </p><br><ul><li>  Scheitelpunkt starten (Start) </li><li>  Letzter H√∂hepunkt (Ziel) </li><li>  Team Top (Befehl) </li><li>  Zuweisungsscheitelpunkt (Let) </li><li>  Verifikation Verifikation oben (wenn) </li></ul><br><p>  Diese Scheitelpunkte unterscheiden sich in ihrem Datensatz oder ihrer Semantik voneinander, werden jedoch alle vom Basisscheitelpunkt (Knoten) geerbt.  An derselben Stelle wird in der Node-Klasse das Verkn√ºpfungsfeld beschrieben, das Verkn√ºpfungen zu anderen Scheitelpunkten enth√§lt, und die addLink-Methode erm√∂glicht das Hinzuf√ºgen dieser Verkn√ºpfungen.  Den vollst√§ndigen Code aller Klassen finden Sie <a href="">hier</a> . </p><br><p>  Schreiben wir den Code, der die Schaltung aus dem Bild sammelt, und versuchen wir, das Ergebnis zu serialisieren. </p><br><div class="spoiler">  <b class="spoiler_title">Algorithmus-Design-Code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p>  Wenn wir dieses Schema mit JSON.stringify serialisieren, erhalten wir etwas Schreckliches.  Ich werde die ersten Zeilen des Ergebnisses geben, in denen ich meine Kommentare hinzugef√ºgt habe: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify Ergebnis</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p>  Weil  Der erste Scheitelpunkt enthielt eine Verkn√ºpfung zum zweiten und zu den nachfolgenden. Als Ergebnis seiner Serialisierung wurde die gesamte Schaltung serialisiert.  Dann wurde der zweite Peak serialisiert und alles, was davon abhing, und so weiter.  Sie k√∂nnen die urspr√ºnglichen Links aus diesem Hash nur durch Bezeichner wiederherstellen. Sie helfen jedoch nicht, wenn einer der Scheitelpunkte direkt oder √ºber andere Scheitelpunkte auf sich selbst verweist.  In diesem Fall <u>l√∂st</u> der Serializer <u>einen nicht erfassten TypeError aus: Konvertieren einer kreisf√∂rmigen Struktur in einen JSON-</u> Fehler.  Wenn es nicht klar ist, ist hier das einfachste Beispiel, das diesen Fehler generiert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://jsfiddle.net/L4guo86w/</a> . </p><br><p>  Dar√ºber hinaus enth√§lt JSON keine Informationen zu den Quellklassen, sodass nicht verstanden werden kann, welcher Typ jeder Scheitelpunkt vor der Serialisierung war. </p><br><p>  Als ich diese Probleme erkannte, ging ich online und suchte nach vorgefertigten L√∂sungen.  Es gab viele, aber die meisten waren sehr sperrig oder erforderten eine spezielle Beschreibung der serialisierbaren Klassen. Daher wurde beschlossen, ein eigenes Fahrrad herzustellen.  Und ja, ich liebe Fahrr√§der. </p><br><h3 id="koncepciya-serializatora">  Serializer-Konzept </h3><br><p>  Dieser Abschnitt richtet sich an diejenigen, die mit mir an der Erstellung eines Serialisierungsalgorithmus teilnehmen m√∂chten, wenn auch virtuell. </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh">  Speichern von Datentypinformationen </h4><br><p>  Eines der Probleme mit Javascript ist das Fehlen von Metadaten, die in Sprachen wie C # oder Java (Attribute und Reflexion) Wunder wirken k√∂nnen.  Andererseits brauche ich keine superkomplexe Serialisierung mit der F√§higkeit, eine Liste von serialisierbaren Feldern, Validierungen und anderen Chips zu definieren.  Daher besteht die Hauptidee darin, dem Objekt Informationen zu seinem Typ hinzuzuf√ºgen und es mit normalem JSON.stringify zu serialisieren. </p><br><p>  Bei der Suche nach L√∂sungen stie√ü ich auf einen interessanten Artikel, dessen Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äû6 falsche M√∂glichkeiten zum Hinzuf√ºgen von Typinformationen in JSON‚Äú bedeutet</a> .  Tats√§chlich sind die Methoden sehr gut, und ich habe die unter Nummer 5 gew√§hlt. Wenn Sie zu faul sind, um den Artikel zu lesen, ich dies jedoch sehr empfehle, werde ich diese Methode kurz beschreiben: Wenn Sie ein Objekt serialisieren, verpacken wir es in ein anderes Objekt mit dem einzigen Ein Feld, dessen Name das Format <code>"@&lt;type&gt;"</code> hat und dessen Wert die Daten des Objekts sind.  W√§hrend der Deserialisierung extrahieren wir den Typnamen, erstellen das Objekt aus dem Konstruktor neu und lesen die Daten seiner Felder. </p><br><p>  Wenn wir Links aus unserem obigen Beispiel entfernen, serialisiert Standard JSON.stringify Daten wie folgt: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p>  Und unser Serializer wird es so verpacken: </p><br><div class="spoiler">  <b class="spoiler_title">Serialisierungsergebnis</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p>  Nat√ºrlich gibt es einen Nachteil: Der Serializer muss wissen, welche Typen er serialisieren kann, und die Objekte selbst sollten keine Felder enthalten, deren Name mit einem Hund beginnt.  Das zweite Problem wird jedoch durch Vereinbarung mit den Entwicklern oder durch Ersetzen des Hundesymbols durch etwas anderes gel√∂st, und das erste Problem wird in einer Codezeile gel√∂st (siehe unten ein Beispiel).  Wir wissen genau, was wir serialisieren werden, oder? </p><br><h4 id="reshenie-problemy-so-ssylkami">  L√∂sen des Linkproblems </h4><br><p>  Es ist noch einfacher in Bezug auf den Algorithmus, aber schwieriger zu implementieren. </p><br><p>  Wenn Sie Instanzen von Klassen serialisieren, die im Serializer registriert sind, speichern wir sie im Cache und weisen ihnen eine Seriennummer zu.  Wenn wir diese Instanz in Zukunft erneut treffen, f√ºgen wir in der ersten Definition diese Nummer hinzu (der Feldname hat die Form <code>"@&lt;type&gt;|&lt;index&gt;"</code> ) und f√ºgen am Ort der Serialisierung den Link in Form eines Objekts ein </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p>  W√§hrend der Deserialisierung betrachten wir also, was genau der Wert des Feldes ist.  Wenn dies eine Zahl ist, extrahieren wir das Objekt anhand dieser Zahl aus dem Cache.  Ansonsten ist dies seine erste Definition. </p><br><p>  Lassen Sie uns den Link vom ersten Anfang des Schemas zum zweiten zur√ºckf√ºhren und das Ergebnis betrachten: </p><br><div class="spoiler">  <b class="spoiler_title">Serialisierungsergebnis</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p>  Es sieht auf den ersten Blick nicht sehr klar aus, weil  Der zweite Scheitelpunkt wird zuerst im ersten im Link-Kommunikationsobjekt definiert, aber es ist wichtig, dass dieser Ansatz funktioniert.  Au√üerdem habe ich die zweite Version des Serializers erstellt, die den Baum nicht in der Tiefe, sondern in der Breite umgeht, wodurch solche "Leitern" vermieden werden. </p><br><h3 id="sozdanie-serializatora">  Serializer erstellen </h3><br><p>  Dieser Abschnitt richtet sich an diejenigen, die an der Umsetzung der oben beschriebenen Ideen interessiert sind. </p><br><h4 id="zagotovka-serializatora">  Serializer leer </h4><br><p>  Wie jeder andere Serializer verf√ºgt auch unser Serializer √ºber zwei Hauptmethoden: Serialisieren und Deserialisieren.  Dar√ºber hinaus ben√∂tigen wir eine Methode, die dem Serializer mitteilt, welche Klassen serialisiert (registriert) und welche nicht (ignoriert) werden sollen.  Letzteres ist erforderlich, um DOM-Elemente, JQuery-Objekte oder andere Datentypen, die nicht serialisiert werden k√∂nnen oder die nicht serialisiert werden m√ºssen, nicht zu serialisieren.  In meinem Editor speichere ich beispielsweise ein visuelles Element, das einem Scheitelpunkt oder Link entspricht.  Es wird w√§hrend der Initialisierung erstellt und sollte nat√ºrlich nicht in die Datenbank fallen. </p><br><div class="spoiler">  <b class="spoiler_title">Serializer-Shell-Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p>  Erkl√§rungen </p><br><p>  Um eine Klasse zu registrieren, m√ºssen Sie ihren Konstruktor auf zwei Arten an die Registrierungsmethode √ºbergeben: </p><br><ol><li>  registrieren (MyClass) </li><li>  registrieren ('MyNamespace.MyClass', MyClass) </li></ol><br><p>  Im ersten Fall wird der Klassenname aus dem Namen der Konstruktorfunktion extrahiert (im IE nicht unterst√ºtzt), im zweiten Fall geben Sie den Namen selbst an.  Die zweite Methode ist vorzuziehen, weil  Erm√∂glicht die Verwendung von Namespaces. Der erste dient dazu, integrierte Javascript-Typen mit neu definierter Serialisierungslogik zu registrieren. </p><br><p>  In unserem Beispiel lautet die Initialisierung des Serializers wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  Das Schema-Objekt enth√§lt Beschreibungen aller Vertex-Klassen, sodass der Klassenregistrierungscode in eine Zeile passt. </p><br><h4 id="kontekst-serializacii-i-deserializacii">  Der Kontext von Serialisierung und Deserialisierung </h4><br><p>  M√∂glicherweise haben Sie die kryptischen Klassen SerializationContext und DeserializationContext bemerkt.  Sie erledigen die ganze Arbeit und werden in erster Linie ben√∂tigt, um die Daten von verschiedenen Serialisierungs- / Deserialisierungsprozessen zu trennen, weil  F√ºr jeden Anruf m√ºssen Zwischeninformationen gespeichert werden - ein Cache mit serialisierten Objekten und eine Seriennummer f√ºr die Verbindung. </p><br><h4 id="serializationcontext">  SerializationContext </h4><br><p>  Ich werde im Detail nur den rekursiven Serializer analysieren, weil  ihr "flaches" Gegenst√ºck ist etwas komplizierter und unterscheidet sich nur in seiner Herangehensweise an die Verarbeitung eines Baumes von Objekten. </p><br><p>  Beginnen wir mit dem Konstruktor: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p>  Ich <code>this.__proto__.__proto__ = ser;</code> , die mysteri√∂se Linie zu erkl√§ren <code>this.__proto__.__proto__ = ser;</code> <br>  Bei der Eingabe des Konstruktors akzeptieren wir das Objekt des Serializers selbst, und diese Zeile erbt unsere Klasse davon.  Dies erm√∂glicht den Zugriff auf Serializer-Daten. <br>  Zum Beispiel bezieht sich <code>this._ignore</code> auf eine Liste ignorierter Klassen des Serializers selbst (die "schwarze Liste"), was sehr n√ºtzlich ist.  Andernfalls m√ºssten wir so etwas <code>this._serializer._ignore</code> . </p><br><p>  Hauptserialisierungsmethode: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p>  Es ist zu beachten, dass wir drei grundlegende Datentypen verarbeiten: Arrays, Objekte und einfache Werte.  Befindet sich der Konstruktor eines Objekts in der "schwarzen Liste", wird dieses Objekt nicht serialisiert. </p><br><p>  Array-Serialisierung: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Sie k√∂nnen √ºber die Karte k√ºrzer schreiben, dies ist jedoch nicht kritisch.  Nur eines ist wichtig - den Wert auf undefiniert pr√ºfen.  Wenn das Array eine nicht serialisierbare Klasse enth√§lt, f√§llt sie ohne diese Pr√ºfung als undefiniert in das Array, was nicht sehr gut ist.  Auch in meiner Implementierung werden Arrays ohne Schl√ºssel serialisiert.  Theoretisch k√∂nnen Sie den Algorithmus zum Serialisieren von assoziativen Arrays verfeinern, aber f√ºr diese Zwecke bevorzuge ich die Verwendung von Objekten.  Dar√ºber hinaus mag JSON.stringify auch keine assoziativen Arrays. </p><br><p>  Objektserialisierung: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p>  Offensichtlich ist dies der schwierigste Teil des Serialisierers, sein Herz.  Nehmen wir es auseinander. </p><br><p>  Zun√§chst pr√ºfen wir, ob der Klassenkonstruktor im Serializer registriert ist.  Wenn nicht, ist dies ein einfaches Objekt, f√ºr das die Dienstprogrammmethode <code>serializeObjectInner</code> aufgerufen wird. </p><br><p>  Andernfalls pr√ºfen wir, ob dem Objekt eine eindeutige Kennung <strong>__uuid zugewiesen wurde</strong> .  Dies ist eine einfache Z√§hlervariable, die allen Serialisierern gemeinsam ist und verwendet wird, um den Verweis auf die Klasseninstanz im Cache zu behalten.  Sie k√∂nnten darauf verzichten und die Instanz selbst ohne Schl√ºssel im Cache speichern. Um dann zu √ºberpr√ºfen, ob das Objekt im Cache gespeichert ist, m√ºssten Sie den gesamten Cache durchgehen, und hier reicht es aus, den Schl√ºssel zu √ºberpr√ºfen.  Ich denke, dies ist schneller in Bezug auf die interne Implementierung von Objekten in Browsern.  Au√üerdem serialisiere ich absichtlich keine Felder, die mit zwei Unterstrichen beginnen, damit das Feld <strong>__uuid</strong> nicht wie andere private Klassenfelder in den resultierenden json f√§llt.  Wenn dies f√ºr Ihre Aufgabe nicht akzeptabel ist, k√∂nnen Sie diese Logik √§ndern. </p><br><p>  Als n√§chstes suchen wir anhand des Werts von <strong>__uuid</strong> nach einem Objekt, das die Instanz der Klasse im Cache beschreibt ( <strong>zwischengespeichert</strong> ). </p><br><p>  Wenn ein solches Objekt vorhanden ist, wurde der Wert bereits fr√ºher serialisiert.  In diesem Fall weisen wir dem Objekt eine Seriennummer zu, falls dies noch nicht geschehen ist: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p>  Der Code sieht verwirrend aus und kann vereinfacht werden, indem allen von uns serialisierten Klassen eine Nummer zugewiesen wird.  Zum Debuggen und Wahrnehmen des Ergebnisses ist es jedoch besser, wenn die Nummer nur den Klassen zugewiesen wird, zu denen in Zukunft Verkn√ºpfungen bestehen. </p><br><p>  Wenn die Nummer vergeben ist, geben wir den Link gem√§√ü dem Algorithmus zur√ºck: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p>  Wenn das Objekt zum ersten Mal serialisiert wird, erstellen wir eine Instanz seines Caches: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p>  Und dann serialisieren Sie es: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p>  Es gibt eine √úberpr√ºfung der Implementierung der Serialisierungsschnittstelle durch die Klasse (die sp√§ter erl√§utert wird) sowie die Konstruktion von <code>Object.keys(cached.ref)[0]</code> .  Tatsache ist, dass cached.ref einen Link zum Wrapper-Objekt <code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> , aber der Name des Objektfelds ist uns unbekannt, weil  Zu diesem Zeitpunkt wissen wir noch nicht, ob der Name die Objektnummer (Index) enthalten wird.  Dieses Konstrukt extrahiert einfach das erste und einzige Feld des Objekts. </p><br><p>  Schlie√ülich die Dienstprogrammmethode zum Serialisieren von Objektinternalen: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p>  Wir erstellen ein neues Objekt und kopieren die Felder aus dem alten hinein. </p><br><h4 id="deserializationcontext">  DeserializationContext </h4><br><p>  Der Deserialisierungsprozess funktioniert in umgekehrter Reihenfolge und erfordert keine besonderen Kommentare. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti">  Zus√§tzliche Funktionen </h3><br><h4 id="interfeys-serializacii">  Serialisierungsschnittstelle </h4><br><p>  In Javascript gibt es keine Schnittstellenunterst√ºtzung, aber wir k√∂nnen uns darauf einigen, dass diese Methoden f√ºr die Serialisierung bzw. Deserialisierung verwendet werden, wenn die Klasse die Serialisierungs- und Deserialisierungsmethoden implementiert. </p><br><p>  Dar√ºber hinaus k√∂nnen Sie mit Javascript diese Methoden f√ºr integrierte Typen implementieren, z. B. f√ºr Datum: </p><br><div class="spoiler">  <b class="spoiler_title">Datum im ISO-Format serialisieren</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p>  Die Hauptsache ist, sich daran zu erinnern, den Datumstyp zu registrieren: <code>serializer.register(Date);</code>  . </p><br><p>  Ergebnis: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p>  Einzige Einschr√§nkung: Das Ergebnis der Serialisierung sollte keine Ganzzahl sein, weil  In diesem Fall wird es als Referenz auf das Objekt interpretiert. </p><br><p>  Ebenso k√∂nnen Sie einfache Klassen in Zeichenfolgen serialisieren.  Ein Beispiel f√ºr die Serialisierung der Color-Klasse, die die Farbe beschreibt, in die Zeile <code>#rrggbb</code> befindet sich auf <a href="">github</a> . </p><br><h4 id="ploskiy-serializator">  Flacher Serializer </h4><br><p>  Speziell f√ºr Sie, liebe Leser, habe ich die <a href="">zweite Version des Serializers geschrieben</a> , die den Baum von Objekten nicht rekursiv in der Tiefe, sondern iterativ in der Breite mithilfe einer Warteschlange durchl√§uft. </p><br><p>  Zum Vergleich werde ich ein Beispiel f√ºr die Serialisierung der ersten beiden Eckpunkte unseres Schemas in beiden F√§llen geben. </p><br><div class="spoiler">  <b class="spoiler_title">Rekursiver Serializer (Serialisierung in der Tiefe)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Flat Serializer (Serialisierung weit)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p>  Pers√∂nlich mag ich die zweite Option noch mehr als die erste, aber es sollte beachtet werden, dass Sie bei Auswahl einer der Optionen die andere nicht verwenden k√∂nnen.  Es geht nur um die Links.  Beachten Sie, dass im Flat Serializer eine Verkn√ºpfung zum zweiten Scheitelpunkt vor seiner Beschreibung steht. </p><br><h3 id="plyusy-i-minusy-serializatora">  Vor- und Nachteile des Serializers </h3><br><p>  Vorteile: </p><br><ul><li>  Der Serializer-Code ist recht einfach und kompakt (etwa 300 Zeilen, von denen die H√§lfte Kommentare sind). </li><li>  Der Serializer ist einfach zu bedienen und erfordert keine Bibliotheken von Drittanbietern. </li><li>  Die Serialisierungsschnittstelle f√ºr die willk√ºrliche Serialisierung von Klassen ist integriert. </li><li>  Das Ergebnis ist angenehm f√ºr das Auge (IMHO). </li><li>  Die Entwicklung eines √§hnlichen Serializers / Deserializers in anderen Sprachen ist kein Problem.  Dies kann erforderlich sein, wenn das Ergebnis der Serialisierung auf der R√ºckseite verarbeitet wird. </li></ul><br><p>  Nachteile: </p><br><ul><li>  Der Serializer erfordert die Registrierung von Klassen, die serialisiert werden k√∂nnen. </li><li>  Die Feldnamen von Objekten unterliegen geringf√ºgigen Einschr√§nkungen. </li><li>  Der Serializer ist noob in Javascript geschrieben, daher kann er Fehler und Fehler enthalten. </li><li>  Die Leistung bei gro√üen Datenmengen kann darunter leiden. </li></ul><br><p>  Ein Minus ist auch, dass der Code in ES6 geschrieben ist.  Nat√ºrlich ist es m√∂glich, auf fr√ºhere Versionen von Javascript zu konvertieren, aber ich habe die Kompatibilit√§t des resultierenden Codes mit verschiedenen Browsern nicht √ºberpr√ºft. </p><br><h3 id="drugie-moi-publikacii">  Meine anderen Ver√∂ffentlichungen </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lokalisierung von Projekten in .NET mit einem Funktionsinterpreter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºllen von Textvorlagen mit modellbasierten Daten.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET-Implementierung mit IL-Funktionen (Dynamic Bytecode)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413113/">https://habr.com/ru/post/de413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413103/index.html">3CX v15.5 Update 5 Beta und REST-Integration mit AmoCRM ver√∂ffentlicht</a></li>
<li><a href="../de413105/index.html">Hinweise des IoT-Anbieters. Aktivierung und Sicherheit in LoraWAN</a></li>
<li><a href="../de413107/index.html">√úbersetzung des Svelto.ECS-Projekt-Wikis. ECS-Framework f√ºr Unity3D</a></li>
<li><a href="../de413109/index.html">So erstellen Sie eine SaaS-Produktintegrationsplattform: Poster Cloud Checkout Experience</a></li>
<li><a href="../de413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../de413117/index.html">So programmieren Sie sicher in Bash</a></li>
<li><a href="../de413119/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 317 (28. Mai - 3. Juni 2018)</a></li>
<li><a href="../de413121/index.html">Fototour von Moskau Coworking #tceh</a></li>
<li><a href="../de413123/index.html">JETZT in NoSQL-Datenbanken</a></li>
<li><a href="../de413125/index.html">Die Gentherapie gibt kleinen Patienten mit Muskelatrophie eine √úberlebenschance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>