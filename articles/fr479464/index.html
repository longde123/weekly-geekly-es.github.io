<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🧚🏿 👩🏽‍💻 Tuyaux et filtres. Exemple d'application et d'implémentation à l'aide de Spring 🤬 🎊 💦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explique l'utilisation du modèle Pipes & Filters. 


 Tout d'abord, nous analyserons un exemple de fonction, que nous réécrirons plus tard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tuyaux et filtres. Exemple d'application et d'implémentation à l'aide de Spring</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479464/"><p>  Cet article explique l'utilisation du modèle Pipes &amp; Filters. </p><br><p>  Tout d'abord, nous analyserons un exemple de fonction, que nous réécrirons plus tard en utilisant le modèle mentionné ci-dessus.  Les changements dans le code se produiront progressivement et chaque fois que nous créerons une version utilisable jusqu'à ce que nous nous attardions sur la solution en utilisant DI (dans cet exemple Spring). </p><br><p>  Ainsi, nous créerons plusieurs solutions, offrant la possibilité d'en utiliser une. <br>  Au final, nous comparons les implémentations initiales et finales, examinons des exemples d'application dans des projets réels et résumons. </p><a name="habracut"></a><br><h2 id="zadacha">  Défi </h2><br><p>  Supposons que nous ayons un tas de vêtements que nous obtenons du séchage et que nous devons maintenant déplacer dans le placard.  Il s'avère que les données (vêtements) proviennent d'un service distinct et la tâche consiste à fournir ces données au client sous la bonne forme (dans un placard à partir duquel il peut obtenir des vêtements). </p><br><p>  Dans la plupart des cas, vous ne pouvez pas utiliser les données reçues sous la forme dans laquelle elles nous parviennent.  Ces données doivent être vérifiées, transformées, triées, etc. <br>  Supposons qu'un client exige que les vêtements soient repassés s'ils sont neufs. </p><br><p> Ensuite, pour la première fois, nous créons un <code>Modifier</code> , dans lequel nous prescrivons les changements: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { <span class="hljs-comment"><span class="hljs-comment">// }); } }</span></span></code> </pre> <br><p>  À ce stade, tout est simple et clair.  Écrivons un test qui vérifie que tous les vêtements froissés ont été repassés. </p><br><p>  Mais au fil du temps, de nouvelles exigences apparaissent et chaque fois que la fonctionnalité de la classe <code>Modifier</code> développe: </p><br><ul><li>  Ne mettez pas de linge sale dans le placard. </li><li>  Les chemises, vestes et pantalons doivent être accrochés aux épaules. </li><li>  Les chaussettes qui fuient doivent être cousues en premier </li><li>  ... </li></ul><br><p>  La séquence des changements est également importante.  Par exemple, vous ne pouvez pas d'abord suspendre des vêtements sur leurs épaules, puis repasser. </p><br><p>  Ainsi, à un moment donné, <code>Modifier</code> peut prendre la forme suivante: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); (); (); (); <span class="hljs-comment"><span class="hljs-comment">//   return ; } private void (List&lt;&gt; ) { .stream() .filter(.class::isInstance) .map(.class::cast) .filter(::) .forEach(o -&gt; { // }); } private void (List&lt;&gt; ) { .stream() .filter(___) .forEach(o -&gt; { //   }); } private void (List&lt;&gt; ) { .removeIf(::); } private void (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { // }); } //  }</span></span></code> </pre> <br><p>  En conséquence, les tests sont devenus plus compliqués, qui doivent maintenant au moins vérifier chaque étape individuellement. </p><br><p>  Et lorsqu'une nouvelle exigence arrive, en regardant le code, nous décidons que le moment est venu pour la refactorisation. </p><br><h2 id="refactoring">  Refactoring </h2><br><p>  La première chose qui attire votre attention est la casse fréquente de tous les vêtements.  Donc, la première étape, nous déplaçons tout en un cycle, et transférons également le contrôle de propreté au début du cycle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   } return result; } private void ( ) { if( instanceof ){ // ()  } } private void ( ) { if(___.test()){ //   } } private void ( ) { if(.()){ // } } //  }</span></span></code> </pre> <br><p>  Maintenant, le temps de traitement des vêtements est réduit, mais le code est encore trop long pour une classe et pour le corps du cycle.  Essayons d'abord de raccourcir le corps du cycle. </p><br><ul><li><p>  Après avoir vérifié la propreté, vous pouvez effectuer tous les appels dans une méthode de <code>modify( )</code> distincte <code>modify( )</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); modify(o); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( o)</span></span></span><span class="hljs-function"> </span></span>{ (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br></li><li><p>  Vous pouvez combiner tous les appels en un seul <code>Consumer</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;&gt; modification = ((Consumer&lt;&gt;) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::); <span class="hljs-comment"><span class="hljs-comment">//   public List&lt;&gt; modify(List&lt;&gt; ){ return .stream() .filter(o -&gt; !o.()) .peek(modification) .collect(Collectors.toList()); }</span></span></code> </pre> <br><blockquote>  Blunt: coup d'oeil <br>  J'ai utilisé peek pour faire court.  Sonar dira qu'un tel code ne devrait pas être fait, car  Javadoc indique à Peek que la méthode existe principalement pour le débogage.  Mais si vous le réécrivez sur la carte: .map (o -&gt; {modification.accept (o); return o;}), alors IDEA dira qu'il vaut mieux utiliser peek </blockquote><br></li></ul><br><blockquote>  Trébuchement: Consommateur <br>  Un exemple avec Consumer (et suivant avec Function) est donné pour montrer les capacités du langage. </blockquote><p>  Maintenant, le corps du cycle est devenu plus court, mais jusqu'à présent, la classe elle-même est encore trop grande et contient trop d'informations (connaissance de toutes les étapes). </p><br><p>  Essayons de résoudre ce problème en utilisant des modèles de programmation déjà établis.  Dans ce cas, nous utiliserons des <code>Pipes &amp; Filters</code> . </p><br><h2 id="pipes--filters">  Tuyaux et filtres </h2><br><p>  <a href="https://docs.microsoft.com/ru-ru/azure/architecture/patterns/pipes-and-filters">Le modèle de canal et de filtre</a> <a href="https://medium.com/nuances-of-programming/%25D0%25BA%25D1%2580%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B8%25D0%25B9-%25D0%25BE%25D0%25B1%25D0%25B7%25D0%25BE%25D1%2580-10-%25D0%25BF%25D0%25BE%25D0%25BF%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-81647be5c46f">décrit une approche</a> dans laquelle les données entrantes passent par plusieurs étapes de traitement. </p><br><p>  Essayons d'appliquer cette approche à notre code. </p><br><h3 id="shag-1">  Étape 1 </h3><br><p>  En fait, notre code est déjà proche de ce modèle.  Les données obtenues passent par plusieurs étapes indépendantes.  Jusqu'à présent, chaque méthode est un filtre, et la <code>modify</code> elle-même décrit le canal, filtrant d'abord tous les vêtements sales. </p><br><p>  Maintenant, nous allons transférer chaque étape dans une classe distincte et voir ce que nous obtenons: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-comment"><span class="hljs-comment">//  public Modifier( ,  ,   //  ) { this. = ; this. = ; this. = ; //  } public List&lt;&gt; modify(List&lt;&gt; ) { return .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { .(o); .(o); .(o); //  }) .collect(Collectors.toList()); } }</span></span></code> </pre> <br><p>  Ainsi, nous avons placé le code dans des classes distinctes, simplifiant les tests de transformations individuelles (et créant la possibilité de réutiliser les étapes).  L'ordre des appels détermine la séquence des étapes. </p><br><p>  Mais la classe elle-même connaît toujours toutes les étapes individuelles, contrôle l'ordre et dispose ainsi d'une énorme liste de dépendances.  En plus d'ajouter une nouvelle étape, nous serons obligés non seulement d'écrire une nouvelle classe, mais aussi de l'ajouter à <code>Modfier</code> . </p><br><h3 id="shag-2">  Étape 2 </h3><br><p>  Simplifiez le code à l'aide de Spring. <br>  Créez d'abord une interface pour chaque étape: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; }</code> </pre><br><p>  <code>Modifier</code> lui-même sera désormais beaucoup plus court: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Modification&gt; steps; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Modifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Modification&gt; steps)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps = steps; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { steps.forEach(m -&gt; m.modify(o)); }) .collect(Collectors.toList()); } }</code> </pre> <br><p>  Maintenant, pour ajouter une nouvelle étape, il vous suffit d'écrire une nouvelle classe qui implémente l'interface de <code>Modification</code> et de mettre <code>@Component</code> au-dessus.  Spring le trouvera et l'ajoutera à la liste. </p><br><p>  <code>Modifer</code> lui <code>Modifer</code> même <code>Modifer</code> sait rien des étapes individuelles, ce qui crée une «connexion faible» entre les composants. </p><br><p>  La seule difficulté est de régler la séquence.  Pour ce faire, Spring a une annotation <code>@Order</code> dans laquelle vous pouvez passer une valeur int.  La liste est triée par ordre croissant. <br>  Ainsi, il peut arriver qu'en ajoutant une nouvelle étape au milieu de la liste, vous deviez modifier les valeurs de tri des étapes existantes. </p><br><blockquote>  Spring aurait pu être supprimé si toutes les implémentations connues avaient été transmises manuellement au constructeur Modifier.  Cela aidera à résoudre le problème de tri, mais compliquera encore une fois l'ajout de nouvelles étapes. </blockquote><br><h3 id="shag-3">  Étape 3 </h3><br><p>  Nous passons maintenant le test de propreté dans une étape distincte.  Pour ce faire, nous réécrivons notre interface afin qu'elle renvoie toujours une valeur: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); }</code> </pre> <br><p>  Vérifiez la propreté: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Order</span></span>(Ordered.HIGHEST_PRECEDENCE) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CleanFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(.()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } }</code> </pre> <br><p>  <code>Modifier.modify</code> - <code>Modifier.modify</code> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .map(o -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modified = o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step : steps){ modified = step.modify(o); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modified == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; }) .filter(Objects::nonNull) .collect(Collectors.toList()); }</code> </pre> <br><p>  Dans cette version, <code>Modifier</code> ne dispose d'aucune information sur les données.  Il les transmet simplement à chaque étape connue et recueille les résultats. </p><br><p>  Si l'une des étapes renvoie null, le traitement de ce vêtement est interrompu. </p><br><p>  Un principe similaire est utilisé dans Spring pour les HandlerInterceptors.  Avant et après l'appel du contrôleur, tous les intercepteurs appropriés pour cette URL sont appelés.  Dans le même temps, il renvoie vrai ou faux dans la méthode preHandle pour indiquer si le traitement et l'appel des intercepteurs suivants peuvent continuer </p><br><h3 id="shag-n">  Étape n </h3><br><p>  L'étape suivante consiste à ajouter la méthode des <code>matches</code> à l'interface de <code>Modification</code> , dans laquelle les étapes d'un attribut distinct des vêtements sont vérifiées: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;} }</code> </pre> <br><p>  Pour cette raison, vous pouvez légèrement simplifier la logique des méthodes de <code>modify</code> en déplaçant les vérifications des classes et des propriétés dans une méthode distincte. </p><br><p>  Une approche similaire est utilisée dans le filtre Spring (Request), mais la principale différence est que chaque filtre est un wrapper autour du suivant et appelle explicitement FilterChain.doFilter pour continuer le traitement. </p><br><h2 id="itogo">  Total </h2><br><p>  Le résultat final est très différent de la version initiale.  En les comparant, nous pouvons tirer les conclusions suivantes: </p><br><ul><li>  L'implémentation basée sur Pipes &amp; Filters simplifie la classe <code>Modifier</code> elle-même. </li><li>  Des responsabilités mieux réparties et des connexions «faibles» entre les composants. </li><li>  Plus facile de tester des étapes individuelles. </li><li>  Ajoutez et supprimez des étapes plus facilement. </li><li>  Un peu plus difficile de tester toute une chaîne de filtres.  Nous avons déjà besoin de IntegrationTests. </li><li>  Plus de cours </li></ul><br><p>  En fin de compte, une option plus pratique et flexible que l'original. </p><br><p>  De plus, vous pouvez simplement paralléliser le traitement des données en utilisant le même parallelStream. </p><br><h3 id="chto-ne-reshaet-dannyy-primer">  Ce que cet exemple ne résout pas </h3><br><ol><li>  La description du modèle indique que les filtres individuels peuvent être réutilisés en créant une autre chaîne de filtres (canal). <br><ul><li>  D'une part, cela est facile à faire en utilisant <code>@Qualifier</code> . </li><li>  En revanche, définir un ordre différent avec <code>@Order</code> échouera. </li></ul></li><li>  Pour des exemples plus complexes, vous devrez utiliser plusieurs chaînes, utiliser des chaînes imbriquées et toujours modifier l'implémentation existante. <br><ul><li>  Ainsi, par exemple, la tâche: "pour chaque chaussette, recherchez une paire et mettez-les dans une instance de &lt;? Extends Clothing&gt;" ne rentrera pas bien dans l'implémentation décrite, car  Maintenant, pour chaque orteil, vous devez trier tout le linge et modifier la liste de données initiale. </li><li>  Pour résoudre ce problème, vous pouvez écrire une nouvelle interface qui accepte et renvoie une liste &lt;Clothing&gt; et transfère vers une nouvelle chaîne.  Mais vous devez faire attention à la séquence des appels des chaînes elles-mêmes, si les chaussettes ne peuvent être cousues que par l'hôtel. </li></ul></li></ol><br><h2 id="spasibo-za-vnimanie">  Merci de votre attention. </h2></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479464/">https://habr.com/ru/post/fr479464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479450/index.html">AppCode 2019.3: fonctionne plus rapidement, comprend mieux Swift, connaît Mac Catalyst et affiche facilement les messages d'assemblage</a></li>
<li><a href="../fr479452/index.html">Comment le système de noms de domaine s'est développé: l'ère ARPANET</a></li>
<li><a href="../fr479458/index.html">Beauté ou praticité dans la salle des serveurs</a></li>
<li><a href="../fr479460/index.html">Un guide pour les voitures volantes</a></li>
<li><a href="../fr479462/index.html">Sérialisation en C ++</a></li>
<li><a href="../fr479466/index.html">Habraiting 2019: statistiques et classement des meilleurs articles pour 2019</a></li>
<li><a href="../fr479468/index.html">Edge of Honesty et John Doe</a></li>
<li><a href="../fr479474/index.html">Pourquoi l'auto-organisation des équipes est-elle si importante dans Scrum et pourquoi il ne peut y avoir de managers</a></li>
<li><a href="../fr479478/index.html">Plug-in Java sans douleur</a></li>
<li><a href="../fr479480/index.html">SDK SARIF et ses erreurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>