<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 🤸 🅿️ Otomatisasi pengujian layanan berbayar di iOS ⚽️ 🍋 🙍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi mereka yang tertarik dengan topik otomatisasi di iOS, saya punya dua berita - baik dan buruk. Bagus: dalam aplikasi iOS untuk layanan berbayar, h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomatisasi pengujian layanan berbayar di iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/">  Bagi mereka yang tertarik dengan topik otomatisasi di iOS, saya punya dua berita - baik dan buruk.  Bagus: dalam aplikasi iOS untuk layanan berbayar, hanya satu titik integrasi yang digunakan - pembelian dalam aplikasi (pembelian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">internal dalam aplikasi</a> ).  Buruk: Apple tidak menyediakan alat apa pun untuk mengotomatiskan pembelian pengujian. <br><br>  Pada artikel ini, saya sarankan Anda dan saya mencari metode otomatisasi universal yang melampaui kebaikan dan kejahatan Apple.  Artikel ini akan berguna bagi siapa saja yang mengintegrasikan layanan pihak ketiga yang merupakan kotak hitam ke dalam aplikasi mereka: iklan, streaming, manajemen lokasi, dll. Biasanya, integrasi seperti itu sangat sulit untuk diuji, karena tidak ada cara untuk secara fleksibel mengkonfigurasi layanan pihak ketiga untuk menguji aplikasi. <br><br><img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br><a name="habracut"></a><br>  <i>Nama saya Victor Koronevich, saya Senior Test Automation Engineer di Badoo.</i>  <i>Terlibat dalam otomatisasi seluler selama lebih dari sepuluh tahun.</i>  <i>Bersama dengan kolega saya Vladimir Solodov, kami membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> ini di konferensi Heisenbug.</i>  <i>Dia juga membantu saya mempersiapkan teks ini.</i> <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kami menjelaskan metode apa yang digunakan Badoo untuk menguji integrasi dengan penyedia pembayaran, yang kami miliki lebih dari 70. Dalam artikel ini kami akan berbicara lebih banyak tentang bagaimana kami berhasil mencapai otomatisasi yang stabil dan murah untuk menguji layanan berbayar dalam aplikasi iOS. <br><br>  Mari kita mulai dengan gambaran umum penelitian kami: <br><br><ol><li>  Definisi masalah <br></li><li>  Pernyataan masalah <br></li><li>  Solusi No. 1.  Apple Sandbox <br></li><li>  Keputusan nomor 2.  Fungsi Metode Mock dan Menggunakan Objek Palsu <br></li><li>  Penilaian keputusan: risiko utama <br></li><li>  Hasil <br></li><li>  Kesimpulan <br></li></ol><br><h2>  Definisi masalah </h2><br>  Otomasi perlu dilakukan ketika kebutuhan alami muncul.  Kapan saat ini datang bersama kami? <br><br>  Ada banyak fitur gratis di aplikasi Badoo, tetapi yang berbayar memberi pengguna lebih banyak opsi.  Mereka mendapatkannya dalam dua cara: untuk pinjaman - mata uang internal Badoo - atau dengan membeli langganan premium.  Untuk sejumlah kredit tertentu, Anda dapat meningkatkan profil Anda di hasil pencarian ke tempat pertama, membuat hadiah kepada pengguna lain, dan banyak lagi.  Langganan premium berlaku untuk jangka waktu tertentu dan memberikan beberapa opsi sekaligus: nyalakan mode tembus pandang, lihat orang-orang yang telah menunjukkan simpati kepada Anda, membatalkan hasil pemilihan Anda, dan lainnya. <br><br>  Fitur-fitur ini muncul di Badoo secara bertahap.  Dan beberapa tahun yang lalu, kami menguji layanan berbayar di aplikasi iOS hanya secara manual.  Tetapi ketika fitur dan layar baru muncul, pengujian manual semakin lama semakin memakan waktu.  Persyaratan untuk perubahan dalam aplikasi berasal dari sisi yang berbeda: dari pengembang sisi klien, pengembang sisi server dan bahkan penyedia Apple sendiri.  Untuk satu tester, satu iterasi pengujian mulai memakan waktu sekitar delapan jam.  Menjadi tidak mungkin untuk mendapatkan umpan balik cepat untuk pengembang di cabang mereka dalam waktu 30 menit, yang akhirnya dapat berdampak negatif terhadap daya saing produk. <br><br>  Kami ingin mendapatkan hasil tes secepat mungkin.  Dan mereka mengalami masalah: bagaimana mengatur pengujian regresi layanan berbayar di aplikasi iOS kami dengan biaya murah untuk mendapatkan hasil yang cepat dan stabil? <br><br><h2>  Pernyataan masalah </h2><br>  Jadi, dengan mempertimbangkan secara spesifik proses pengiriman produk akhir dan ukuran tim kami, kami ingin: <br><br><ul><li>  Uji setiap pembelian dalam aplikasi klien (pembayaran dan langganan satu kali); <br></li></ul><br><ul><li>  ulangi pengujian berulang 10-20 kali sehari; <br></li><li>  Dapatkan hasil pengujian ~ 150 skrip pengujian dalam waktu kurang dari setengah jam; <br></li><li>  singkirkan kebisingan; <br></li><li>  dapat menjalankan tes pada cabang tertentu dari kode pengembang, terlepas dari hasil menjalankan lainnya. <br></li></ul><br>  Sekarang kita telah merumuskan tugas, sekarang saatnya untuk memulai perjalanan ke dunia insinyur yang luar biasa dan solusinya. <br><br><h2>  Solusi No. 1.  Apple Sandbox </h2><br>  Pertama-tama, kami mulai mencari informasi tentang mengatur pengujian otomatis layanan berbayar dalam dokumentasi Apple.  Dan mereka tidak menemukan apa pun.  Dukungan otomasi terlihat sangat sedikit.  Jika sesuatu muncul, maka pengaturan otomasi dengan alat yang diusulkan sulit (mari kita ingat setidaknya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UIAutomation</a> , serta waktu ketika utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xcrun simctl</a> pertama untuk iOS Simulator muncul) dan Anda harus mencari solusi rekayasa, termasuk di segmen open-source. <br><br>  Dalam dokumentasi Apple untuk menguji layanan berbayar, Anda hanya dapat menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple Sandbox</a> .  Tidak jelas bagaimana mengikat kotak pasir ini dengan otomatisasi, tetapi kami memutuskan untuk meneliti solusi ini dengan serius.  Fakta bahwa kotak pasir Android stabil memberi kami kepercayaan diri, dan pada saat itu kami sudah berhasil menulis tes di Android.  Mungkin kotak pasir Apple akan sama baiknya? <br><br>  Tetapi ketika kami menerapkan autotest menggunakan kotak pasir ini, kami minum sepenuhnya.  Mari kita cepat membahas masalah utama. <br><br><h3>  1. Kelompok pengguna uji </h3><br>  Keterbatasan utama untuk otomatisasi telah menjadi fitur konten di kumpulan pengguna uji, yang harus memastikan kemandirian peluncuran autotests. <br><br>  Untuk menjalankan hanya satu pembelian-otomatis dari pembelian berlangganan, kita perlu: <br><br><ol><li>  ambil pengguna baru untuk otorisasi di kotak pasir; <br></li><li>  ubah pada simulator ID Apple tertaut saat ini; <br></li><li>  Masuk ke Badoo dengan Badoo <br></li><li>  sampai ke layar pembelian berlangganan dan pilih produk; <br></li><li>  Konfirmasikan pembelian dan masuk melalui ID Apple; <br></li><li>  pastikan pembelian berhasil; <br></li><li>  kirim pengguna Badoo untuk dibersihkan; <br></li><li>  hapus pengguna kotak pasir dari langganan. <br></li></ol><br>  Jika Anda mencoba untuk segera menggunakan pengguna yang sama dalam pengujian berikutnya, maka tidak mungkin untuk membeli langganan kedua.  Anda harus menunggu hingga langganan pertama "memburuk", atau berhenti berlangganan di pengaturan.  Seperti yang kami katakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> pertama, kotak pasir memiliki masa berlaku berlangganan tertentu.  Jika Anda membeli langganan "selama sebulan", maka Anda harus menunggu lima menit untuk menutupnya secara otomatis.  Proses berhenti berlangganan itu sendiri juga tidak cepat. <br><br>  Karenanya, untuk menjalankan pengujian baru yang sama, kita harus menunggu hingga langganan berakhir, atau mengambil pengguna "bersih" lainnya.  Jika kita ingin menjalankan dua tes secara bersamaan secara independen satu sama lain, maka kita perlu memiliki setidaknya dua pengguna kotak pasir di kolam.  Jadi, untuk menjalankan 100 tes otomatis secara paralel dalam 100 utas, kita membutuhkan 100 pengguna yang berbeda. <br><br>  Dan sekarang mari kita bayangkan bahwa kita melakukan uji diri pada dua agen, yang masing-masing dapat menjalankannya dalam 100 utas.  Dalam hal ini, kami membutuhkan setidaknya 200 pengguna! <br><br><h3>  2. Pemberitahuan "Buruk" </h3><br>  Nah, apa yang tidak bercanda!  Kami mengorganisasikan kumpulan pengguna dan mulai menonton bagaimana tes berjalan.  Mereka jatuh di sepanjang jalan, tetapi mayoritas - untuk alasan baru yang tidak kita ketahui.  Kami mulai memahami dan menyadari bahwa ketika mengotorisasi, mengonfirmasi pembelian, dan bekerja sebagai pengguna di kotak pasir, App Store mengirimkan peringatan: misalnya, meminta nama pengguna dan kata sandi baru, mengkonfirmasi otorisasi dengan mengklik tombol "OK", memberikan informasi tentang kesalahan internal dengan tombol "OK" .  Terkadang mereka muncul, kadang tidak.  Dan jika mereka muncul, maka selalu dalam urutan yang berbeda. <br><br><img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br><br>  Bagaimana mungkin kesalahan yang mencurigakan diabaikan begitu saja dalam autotest?  Dan jika kesalahan nyata tiba, lalu apa yang harus saya lakukan?  Area ini secara otomatis menjadi "zona buta" bagi kami, dan kami harus menulis penangan khusus untuk semua peringatan yang mungkin datang dari App Store. <br><br>  Semua ini membuat tes lebih lambat: <br><br><ul><li>  peringatan dapat sampai pada langkah-langkah berbeda dari skenario pengujian, menghancurkan gagasan utama pengujian - Skenario Tes yang Dapat Diprediksi;  kami harus menambahkan penangan kesalahan yang mengharapkan serangkaian peringatan yang diketahui yang mungkin muncul akan muncul; <br></li><li>  terkadang variasi baru lansiran tiba atau kesalahan lainnya terjadi, jadi kami harus memulai kembali pengujian yang jatuh;  ini meningkatkan waktu berjalan semua tes. <br></li></ul><br><h3>  3. Apakah ada tes? </h3><br>  Jadi, pengguna di kolam diblokir, lalu dibersihkan selama n menit.  Kami menjalankan pengujian dalam 120 utas, dan sudah ada cukup banyak pengguna di kumpulan ini, tetapi ini tidak cukup.  Kami membuat sistem manajemen pengguna kami, membuat penangan yang waspada - dan kemudian hal itu terjadi.  Kotak pasir telah menjadi tidak tersedia selama beberapa hari untuk setiap pengguna tes. <br><br>  Tidak ada yang mengharapkan ini.  Dan ini adalah jerami terakhir di piala kesabaran kami, yang akhirnya membunuh cinta kotak pasir Apple dan membuat kami memulai jalan di luar yang baik dan yang jahat.  Kami menyadari bahwa kami tidak memerlukan otomatisasi semacam itu dan kami tidak ingin menderita lagi dengan keputusan berbahaya ini. <br><br><h2>  Keputusan nomor 2.  Fungsi Metode Mock dan Menggunakan Objek Palsu </h2><br>  Jadi, kami minum masalah dengan otomatisasi di kotak pasir Apple.  Tapi jangan berpikir bahwa di dunia seluler semuanya benar-benar buruk.  Di Android, kotak pasir jauh lebih stabil - Anda dapat menjalankan autotest di sana. <br><br>  Mari kita coba cari solusi lain untuk iOS.  Tapi bagaimana cara melihatnya?  Di mana mencarinya?  Mari kita lihat sejarah pengujian dan pengembangan perangkat lunak: apa yang terjadi pada dunia gila Apple?  Apa yang orang-orang yang telah menulis banyak buku dan memperoleh otoritas di dunia otomasi dan pengembangan perangkat lunak? <br><br>  Saya segera teringat karya “Pola Tes Unit: Refactoring Test Code”, yang ditulis oleh Gerard Mesaroche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditinjau oleh</a> Martin Fowler), - menurut pendapat saya, salah satu buku terbaik untuk penguji yang mengetahui setidaknya satu bahasa pemrograman tingkat tinggi dan ingin melakukan otomatisasi .  Beberapa bab dari buku ini yang ditujukan untuk menguji SUT secara terpisah dari komponen lain aplikasi, yang merupakan "kotak hitam" kami, dapat membantu kami. <br><br><h3>  1. Pengantar moka dan palsu </h3><br>  Perlu dicatat bahwa dalam dunia pengujian otomatis tidak ada batas yang diterima secara umum antara konsep Tes Ganda, Test Stub, Test Spy, Mock Object, Obyek Palsu, Objek Dummy.  Anda harus selalu mempertimbangkan terminologi penulis.  Kita hanya membutuhkan dua konsep dari dunia besar Uji Ganda: fungsi tiruan dan objek palsu.  Apa ini  Dan mengapa kita membutuhkan ini?  Kami memberikan definisi singkat tentang konsep-konsep ini sehingga kami tidak memiliki perbedaan pendapat. <br><br>  Misalkan kita memiliki aplikasi dan komponen yang dibangun di dalamnya, yang bagi kita adalah "kotak hitam".  Di dalam aplikasi, kita dapat memanggil fungsi dengan mengakses komponen ini dan mendapatkan hasil dari fungsi-fungsi ini.  Bergantung pada hasilnya, aplikasi kita bereaksi dengan cara tertentu.  Kadang-kadang hasil dari eksekusi fungsi dapat berupa keseluruhan entitas dengan sekelompok bidang yang mencerminkan data pengguna yang sebenarnya. <br><br>  Pergantian fungsi untuk yang lain yang mengembalikan hasil yang diinginkan, sebut saja fungsi tiruan, atau cukup tiruan.  Fungsi-fungsi ini mungkin memiliki tanda tangan yang sama, tetapi ini adalah dua fungsi yang berbeda. <br><br>  Dan substitusi entitas yang diperoleh sebagai hasil dari fungsi untuk entitas palsu (berisi data yang diperlukan di bidang, dan kadang-kadang bahkan data yang rusak) akan disebut implementasi objek palsu.  Anda dapat membaca lebih lanjut tentang ini dalam buku yang saya sebutkan di atas, atau dalam ringkasan lainnya untuk pengujian dan pengembangan perangkat lunak. <br><br>  Untuk menyelesaikannya, mari kita tekankan beberapa fitur menggunakan fungsi tiruan dan objek palsu: <br><br><ol><li>  Untuk membuat basah fungsinya, Anda perlu mengakses kode sumber dan tahu cara kerja aplikasi dengan komponen dari dalam di tingkat pengembang. <br></li><li>  Untuk mengimplementasikan objek palsu, Anda perlu mengetahui struktur objek nyata. <br></li><li>  Menggunakan fungsi tiruan memungkinkan konfigurasi aplikasi yang fleksibel dengan komponen. <br></li><li>  Menggunakan objek palsu memungkinkan Anda untuk memberikan entitas dengan properti apa pun. <br></li></ol><br>  Metode moki dan objek palsu sangat ideal untuk mengisolasi operasi komponen dalam aplikasi.  Mari kita lihat bagaimana kita dapat menerapkan metode ini untuk menyelesaikan masalah kita, di mana App Store akan menjadi komponennya.  Karena kekhasan menggunakan metode ini, pertama-tama kita harus beralih ke mempelajari sifat pekerjaan aplikasi kita dengan komponen, dan kemudian ke implementasi teknis untuk membuat mokeys dan benda palsu tertentu. <br><br><h2>  2. Bagaimana pembelian nyata terjadi </h2><br>  Sebelum kita mulai mendeskripsikan interaksi semua bagian sistem, mari kita sorot aktor utama: <br><br><ul><li>  pengguna aplikasi - aktor apa pun yang melakukan tindakan dengan aplikasi, itu bisa seseorang, atau mungkin ada skrip yang melakukan instruksi yang diperlukan; <br></li><li>  aplikasi (dalam kasus kami, kami menggunakan aplikasi iOS Badoo yang diinstal di simulator iOS); <br></li><li>  server - aktor yang memproses permintaan dari aplikasi dan mengirim kembali respons atau pemberitahuan asinkron tanpa permintaan klien (dalam hal ini, kami maksudkan satu server Badoo abstrak untuk menyederhanakan struktur); <br></li><li>  App Store adalah aktor yang merupakan "kotak hitam" bagi kami: kami tidak tahu bagaimana pengaturannya di dalam, tetapi kami tahu antarmuka publiknya untuk memproses pembelian dalam aplikasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka kerja StoreKit</a> ), dan juga tahu cara memeriksa data di server Apple. <br></li></ul><br>  Mari kita lihat bagaimana pembelian terjadi.  Seluruh proses dapat dilihat pada diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>  <i><font color="gray">Gambar 1. Skema pembayaran di App Store</font></i> <br><br>  Kami akan menjelaskan langkah demi langkah tindakan utama para aktor. <br><br>  1. Titik awal adalah keadaan semua aktor sebelum membuka layar dengan daftar produk. <br><br>  Apa layar ini dan bagaimana kita mendapatkannya? <br><br>  Misalkan seorang pengguna menemukan orang yang menarik, membuka profilnya, menulis satu pesan dan ingin mengirim hadiah.  Mengirim hadiah adalah layanan berbayar.  Pengguna dapat menggulir profil ke bagian untuk mengirim hadiah atau langsung memilih hadiah dari obrolan. <br><br>  Jika pengguna memilih hadiah dan tidak memiliki uang di akun, maka ia akan melihat daftar paket pinjaman yang berbeda (Wisaya Pembayaran) untuk pembelian.  Titik awal dalam contoh kita adalah daftar hadiah.  Dalam diagram, kita dapat mempertimbangkan titik seperti itu di layar apa pun sebelum menampilkan daftar produk untuk pembelian pinjaman atau berlangganan. <br><br>  2. Membuka daftar produk. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br>  Kami berada di titik awal, misalnya, pada daftar hadiah.  Pengguna memilih salah satu hadiah dalam aplikasi.  Aplikasi membuat permintaan ke server kami untuk mendapatkan daftar kemungkinan paket pinjaman ID Produk (100, 550, 2000, 5000).  Server mengembalikan daftar ini ke aplikasi. <br><br>  Selanjutnya, aplikasi mengirimkan daftar ID Produk yang diterima untuk verifikasi ke aktor App Store (kerangka kerja iOS sistem StoreKit yang masuk ke server Apple).  Ini mengembalikan daftar produk yang terbukti - dan sebagai hasilnya, aplikasi menunjukkan kepada pengguna daftar akhir dari paket pinjaman dengan ikon dan harga. <br><br>  3. Pemilihan produk dan pembuatan tanda terima. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br>  Pengguna memilih produk berbayar.  App Store memerlukan bukti pembelian dan otorisasi melalui Apple ID.  Setelah otorisasi pengguna yang berhasil, kontrol ditransfer ke aplikasi.  Aplikasi sedang menunggu tanda terima untuk dihasilkan di dalam paketnya sendiri.  Pengguna saat ini melihat matahari, yang mengunci layar.  Tanda terima itu dibuat dapat dipahami menggunakan metode appStoreReceiptURL dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bundle</a> .  Setelah cek dihasilkan oleh App Store, aplikasi memilih cek dari paketnya dan mengirimkan permintaan dengan cek dan data pengguna ke server Badoo. <br><br>  4. Memeriksa cek di server Badoo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br>  Segera setelah server Badoo menerima cek dan data pengguna, itu mengirim mereka kembali ke sisi server Apple untuk melakukan siklus verifikasi pertama.  Ini adalah salah satu rekomendasi dari Apple.  Kemudian, dalam siklus verifikasi pertama ini, server menerima informasi tentang status langganan saat ini. <br><br>  5. Mengirim pemberitahuan push (pemberitahuan push) dari server. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br>  Server Badoo lagi memproses informasi yang diterima setelah verifikasi oleh Apple dan mengirimkan aplikasi tanggapan bersama dengan pemberitahuan push. <br><br>  6. Pemberitahuan push dalam aplikasi. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br>  Jika itu adalah pembelian pinjaman, maka segera saldo pengguna dalam aplikasi akan berubah dan dia akan melihat hadiah yang dikirim dalam obrolan.  Jika ini adalah pembelian berlangganan, maka pengguna harus menunggu pemberitahuan push terakhir bahwa berlangganan diaktifkan. <br><br><h3>  3. Penentuan dependensi dan tes loop </h3><br><br>  Untuk diskusi lebih lanjut, kami memperkenalkan dua konsep lagi - ketergantungan eksternal dan rangkaian pengujian. <br><br><h4>  Ketergantungan eksternal </h4><br>  Yang kami maksud dengan dependensi eksternal adalah setiap interaksi dengan komponen, yang bagi kami merupakan "kotak hitam".  Dalam hal ini, App Store bertindak sebagai komponen seperti itu dalam bentuk kerangka kerja sistem iOS (StoreKit), yang digunakan aplikasi iOS kami, dan server Apple, tempat permintaan verifikasi. <br><br>  Mengelola dependensi ini dalam kondisi nyata tidak mungkin, aplikasi dipaksa untuk menanggapi sinyal output dari kotak hitam (lihat Gambar. 2). <br><br>  Kami memiliki tiga dependensi eksternal: <br><br><ol><li>  Memeriksa Produk StoreKit. <br></li><li>  Menerima dan mengganti tanda terima pembelian. <br></li><li>  Memeriksa cek di server Badoo. <br></li></ol><br><img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>  <i><font color="gray">Gambar 2. Ketergantungan eksternal</font></i> <br><br><h4>  Sirkuit pengujian </h4><br>  Sirkuit pengujian - ini adalah bagian dari jalur yang akan kami lalui dan periksa selama proses pengujian. <br><br><img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>  <i><font color="gray">Gambar 3. Test loop</font></i> <br><br>  Tujuan dari pekerjaan kami untuk menghilangkan dependensi adalah untuk membangun sirkuit pengujian yang sedekat mungkin dengan jalur nyata dan memungkinkan Anda untuk mengecualikan semua dependensi eksternal dan kontrol transfer ke sisi Anda. <br><br>  Kami mempertimbangkan setiap ketergantungan secara berurutan. <br><br><h3>  4. Isolasi ketergantungan: implementasi teknis </h3><br>  Di perusahaan kami, untuk penerapan pembayaran, konsep PPP diambil, yang didasarkan pada antarmuka Penyedia Pembayaran.  Ini adalah antarmuka utama untuk berinteraksi dengan aktor App Store (StoreKit) di dalam aplikasi kami, yang memiliki dua metode utama: <br><br><ol><li>  mempersiapkan adalah metode yang bertanggung jawab untuk memeriksa produk; <br></li><li>  makePayment adalah metode yang memproses pembelian dalam aplikasi. <br></li></ol><br>  Semua pembayaran di iOS di-refactored sesuai dengan konsep ini, yang memungkinkan kami untuk mendapatkan Penyedia Pembayaran Mock kelas yang sederhana dan nyaman.  Ini adalah antarmuka utama untuk berinteraksi dengan salinan nyaman perilaku StoreKit di dalam aplikasi kita.  Apa artinya "copy nyaman"?  Penyedia ini memiliki ejekan dari metode persiapan dan pembayaran yang melakukan apa yang kita inginkan.  Mari kita lihat contoh potongan kode, bagaimana kita berhasil mengintegrasikan moki. <br><br><h4>  Ketergantungan No. 1.  Memeriksa Produk StoreKit </h4><br>  Untuk memeriksa daftar produk, gunakan fungsi persiapan, yang mengembalikan daftar produk yang diperiksa.  Kita dapat menggunakan tiruan di mana kita mematikan cek dan mengembalikan daftar produk yang masuk sebagai diverifikasi sepenuhnya.  Dengan demikian, ketergantungan akan dihilangkan. <br><br><img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>  <i><font color="gray">Gambar 4. Skema eliminasi ketergantungan pertama</font></i> <br><br>  Di bagian paling atas arsitektur dalam aplikasi kita adalah Penyedia Pembayaran.  Ini mencerminkan antarmuka penyedia yang mungkin dalam aplikasi.  Kode untuk mengimplementasikan mok dapat ditemukan di kelas Penyedia Pembayaran Mock. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeKitTransactionID: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products } ... }</code> </pre> <br>  <i><font color="gray">Daftar 1. Mock client check</font></i> <br><br>  Di Penyedia Pembayaran Mock, kita bisa melihat penerapan metode persiapan.  Keajaiban moka sangat sederhana: metode ini melewatkan memeriksa produk di sisi StoreKit, dan itu hanya mengembalikan daftar produk yang masuk.  Implementasi persiapan yang sebenarnya terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validatedProducts = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.productsSource.validate(products: products) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> validatedProducts }</code> </pre><br>  <i><font color="gray">Listing 2. Penyedia Pembayaran Toko Nyata</font></i> <br><br><h3>  Ketergantungan No. 2.  Menerima dan mengganti tanda terima pembelian </h3><br>  Ketergantungan kedua sedikit lebih rumit: kita harus menghapus otorisasi terlebih dahulu agar tidak menjaga kumpulan akun pengguna, dan kemudian entah bagaimana mendapatkan cek itu sendiri.  Kami cukup menghapus formulir otorisasi: <br><br><img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>  <i><font color="gray">Gambar 5. Menghapus formulir otorisasi saat melakukan pembayaran</font></i> <br><br>  Tidak sesederhana itu dengan cek.  Ada banyak pertanyaan: <br><br><ol><li>  Bagaimana cara mendapatkan tanda terima untuk produk yang tepat sebelumnya? <br></li><li>  Jika kami menerima cek, lalu kapan dan bagaimana cara memasangnya di dalam aplikasi? <br></li></ol><br>  Di sini aktor "Pengguna" memiliki peran baru - QA.  Ketika kami menjalankan tes, kami tidak hanya dapat mengklik tombol pada antarmuka, tetapi juga memanggil metode API dari kerangka uji (metode yang mensimulasikan tindakan pengguna) dan layanan REST API (metode yang dapat melakukan keajaiban dari layanan Badoo internal).  Kami di Badoo menggunakan alat QA API yang sangat kuat (Anda dapat menemukan semua kemampuannya di tautan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://vimeo.com/116931200</a> ).  Dialah yang membantu kami dalam pengujian dan memberikan cek untuk produk yang tepat di sisi server Badoo.  Server Badoo adalah tempat terbaik untuk menghasilkan cek: ada enkripsi dan dekripsi cek, sehingga server tahu segalanya tentang struktur data ini. <br><br>  Setelah kami menerima cek palsu, kami bisa memasukkannya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pintu belakang</a> di sisi aplikasi.  Selanjutnya, aplikasi akan mengirimkan cek palsu bersama dengan data pengguna ke server kami. <br><br><img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>  <i><font color="gray">Gambar 6. Skema untuk penerimaan</font></i> <br><br>  Bagaimana ini menjadi mungkin secara teknis? <br><br>  1. Untuk menyiapkan cek palsu di aplikasi, kami dapat menggunakan backdoor yang menyimpan cek palsu di bidang tanda terima MockPaymentProvider: <br><br><pre> <code class="swift hljs">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">BUILD_FOR_AUTOMATION</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadooAppDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMockPurchaseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> receipt: String?)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">PaymentProvidersFactory</span></span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt = receipt } ... } #endif</code> </pre> <br>  <i><font color="gray">Daftar 3. Backdoor cek palsu</font></i> <br><br>  2. Aplikasi ini dapat menerima cek kami berkat MockPaymentProvider, di mana kami menggunakan tiruan makePayment dan cek tersimpan di MockPaymentProvider.receipt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePayment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transaction: BPDPaymentTransactionContext)</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiptData = <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt?.data(using: .utf8) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">BPDPurchaseReceiptRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkService.send(request, completion: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (<span class="hljs-number"><span class="hljs-number">_</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receipt = request.responsePayload() { sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt) } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate?.paymentProvider(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailTransaction: transaction) } } }</code> </pre> <br>  <i><font color="gray">Listing 4. Memanggil moka pemrosesan pembelian dengan cek palsu</font></i> <br><br>  3. Mendapatkan cek palsu <br><br>  Untuk mendapatkan cek palsu, kami menggunakan metode di server (lihat Listing 5).  Dibutuhkan array default dengan data untuk menghasilkan data pemeriksaan dan menambahkan data yang diperlukan untuk produk tertentu. <br><br><pre> <code class="php hljs">$new_receipt_model = array_replace_recursive( <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;getDefaultModel(), //       //,      $this-&gt;enrichModelUsingSubscription($nr), //        $this-&gt;enrichModelUsingInput($input) ); //  $new_receipt = $this-&gt;signReceipt( json_encode($new_receipt_model, true), $new_receipt_model );</span></span></code> </pre><br>  <i><font color="gray">Listing 5. Server bagian dari pembuatan cek</font></i> <br><br>  Untuk mengulangi struktur cek yang sebenarnya, pemeriksaan kustom yang dikirim oleh aplikasi harus dienkripsi menggunakan sertifikat.  Kami menggunakan sertifikat kerja kami alih-alih sertifikat Apple. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt, $response)</span></span></span><span class="hljs-function">  </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     base64 $receipt = 'Subject: ' . base64_encode(json_encode($response)) . PHP_EOL . PHP_EOL . $receipt; file_put_contents($receipt_file, $receipt); ... //    $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, 'file://'.$path_cert, 'file://'.$path_key, [], PKCS7_BINARY); ... //  $signed_content_with_headers = file_get_contents($signed_receipt_file); list($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers); //  return str_replace(["\r\n", "\r", "\n"], '', $signed_content); }</span></span></code> </pre><br>  <i><font color="gray">Listing 6. Metode untuk menandatangani cek dengan sertifikat</font></i> <br><br>  4. Hasilnya, dalam ujian kita mendapatkan: <br><br><pre> <code class="ruby hljs">(<span class="hljs-regexp"><span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|service_type|</span></span> <span class="hljs-comment"><span class="hljs-comment">#    service_details = parse_options(service_type) #  QA API (  Badoo) receipt = QaApi::Billing.order_get_app_store_receipt(service_details) #   Backdoors.set_fake_receipt(receipt) end</span></span></code> </pre><br>  <i><font color="gray">Daftar 7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah</a> uji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gherkin</a> untuk kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mentimun</a></font></i> <br><br><h3>  Ketergantungan No. 3.  Memeriksa cek di server Badoo </h3><br>  Untuk menghapus ketergantungan ketiga, Anda harus menyingkirkan verifikasi cek di server.  Penting untuk diingat bahwa verifikasi dilakukan dalam dua tahap.  Pada tahap pertama, cek diautentikasi berdasarkan tanda tangan dan sertifikat.  Pada detik - cek dikirim ke App Store.  Jika validasi berhasil pada tahap ini, kami akan menerima cek yang didekripsi yang dapat diproses. <br><br><img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>  <i><font color="gray">Gambar 7. Menghapus verifikasi server</font></i> <br><br>  Pertama, server melakukan verifikasi awal dari pemeriksaan dalam metode verifikasiReceiptByCert dari kelas induk.  Ini memverifikasi tanda tangan dengan sertifikat App Store.  Dalam hal pemeriksaan palsu, verifikasi ini akan gagal karena ditandatangani oleh sertifikat kami, dan kami akan memanggil metode untuk verifikasi dengan verifikasi sertifikat lokalReceiptByLocalCert.  Dalam metode ini, kami akan mencoba mendekripsi cek menggunakan sertifikat lokal, dan jika berhasil, kami akan menempatkan hasil dekripsi di bidang internal local_receipt kelas anak (metode addLocallyVerifiedReceipt). <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">)  </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceiptByCert($receipt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($result)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;verifyReceiptByLocalCert($receipt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyReceiptByLocalCert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt)</span></span></span><span class="hljs-function"> </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response)); } unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">) </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  <i><font color="gray">Daftar 8. Verifikasi awal</font></i> <br><br>  Selama verifikasi sekunder (verifikasiReceipt), kami mendapatkan nilai bidang local_receipt dari kelas anak getLocallyVerifiedReceipt.  Jika tidak kosong, maka kami menggunakan nilainya sebagai hasil verifikasi. <br><br>  Jika bidangnya kosong, maka kami memanggil verifikasi sekunder dari kelas <i>induk</i> ( <i>parent</i> :: verifikasiReceipt).  Di sana kami membuat permintaan ke App Store untuk verifikasi di sisinya.  Hasil verifikasi dalam kedua kasus adalah cek yang didekripsi. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLocallyVerifiedReceipt($receipt_encoded); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($response)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($response, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceipt($receipt_encoded, $shared_secret, $env); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre> <br>  <i><font color="gray">Listing 9. Verifikasi sekunder</font></i> <br><br><h3>  5. Uji coba video: beli pinjaman dan langganan </h3><br><h4>  Tes nomor 1.  Pembelian Berlangganan </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Kapan <br></td><td>  Saya masuk ke aplikasi sebagai pengguna baru dengan foto <br></td></tr><tr><td>  Dan <br></td><td>  Saya menghasilkan cek penagihan berlangganan satu bulan yang baru <br></td></tr><tr><td>  Dan <br></td><td>  Saya pergi ke profil saya <br></td></tr><tr><td>  Lalu <br></td><td>  Saya memastikan langganan dinonaktifkan <br></td></tr><tr><td>  Kapan <br></td><td>  Saya membuka daftar produk <br></td></tr><tr><td>  Dan <br></td><td>  Saya membeli paket berlangganan satu bulan <br></td></tr><tr><td>  Lalu <br></td><td>  Saya memeriksa notifikasi pembelian yang berhasil <br></td></tr><tr><td>  Dan <br></td><td>  Saya memastikan langganan diaktifkan <br></td></tr></tbody></table></div><br>  Video uji coba: <br><br><img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br><h4>  Nomor tes 2.  Membeli pinjaman dan mengirim hadiah </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Kapan <br></td><td>  Saya masuk ke aplikasi sebagai pengguna baru dengan foto <br></td></tr><tr><td>  Dan <br></td><td>  Saya menambahkan sepuluh kredit ke profil saya <br></td></tr><tr><td>  Dan <br></td><td>  Saya menghasilkan cek kredit baru untuk 550 kredit <br></td></tr><tr><td>  Dan <br></td><td>  Saya membuat Leela pengguna baru <br></td></tr><tr><td>  Dan <br></td><td>  Leela memilih Ya untukku <br></td></tr><tr><td>  Dan <br></td><td>  Saya pergi ke People Nearby dan membuka profil Leela <br></td></tr><tr><td>  Dan <br></td><td>  Saya memilih "Ya" untuk Leela <br></td></tr><tr><td>  Lalu <br></td><td>  Saya memeriksa halaman pertandingan <br></td></tr><tr><td>  Kapan <br></td><td>  Saya memilih untuk mengirim hadiah reguler <br></td></tr><tr><td>  Lalu <br></td><td>  Saya memeriksa layar pembayaran dengan daftar paket <br></td></tr><tr><td>  Kapan <br></td><td>  Saya memilih untuk membeli 550 kredit <br></td></tr><tr><td>  Lalu <br></td><td>  Saya memeriksa notifikasi pembelian yang berhasil <br></td></tr><tr><td>  Dan <br></td><td>  Saya memastikan Leela menerima hadiah obrolan <br></td></tr></tbody></table></div><br><br>  Video uji coba: <br><br><img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br><br><h2>  Penilaian keputusan: risiko utama </h2><br>  Menghapus ketergantungan eksternal membawa risiko tertentu. <br><br>  1. Konfigurasi salah. <br><br>  Karena verifikasi tidak ada di pihak kami, kami dapat mengonfigurasi produk kami secara tidak benar di pihak Apple.  Untuk melindungi dari kesalahan, kami menulis tes unit sisi server terpisah, yang memeriksa bahwa semua produk yang kami mulai di sisi Apple cocok dengan produk yang kami miliki di konfigurasi kami. <br><br>  2. Kasus perbatasan. <br><br>  Misalnya, ketika pembayaran sepenuhnya selesai, pengguna menerima pemberitahuan bahwa ia telah menyelesaikan, tetapi aplikasi kami tidak dapat menemukan cek yang harus dipalsukan sebagai akibat dari melakukan pembayaran ini.  Risikonya terletak pada kenyataan bahwa kita sendiri melampirkan cek dengan bantuan pintu belakang, dan kita secara alami tidak dapat melacak kasus seperti itu.  Untuk mengkompensasi risiko ini, kami melakukan pemeriksaan end-to-end menggunakan kotak pasir atau pembayaran nyata setelah rilis. <br><br>  3. Tidak adil palsu atau penipuan. <br><br>  Setelah membaca artikel ini, Anda mungkin berpikir bahwa karena Badoo menggunakan cek palsu, Anda dapat melampirkan sesuatu yang palsu kepada kami dan menggunakan layanan ini secara gratis.  Agar risiko ini tidak terwujud, kami menandatangani semuanya dengan sertifikat kami sendiri dan membatasi penggunaan moks dan cek palsu untuk tes fungsional yang hanya dijalankan di lingkungan pengembangan kami. <br><br>  4. Ubah format cek. <br><br>  Ini adalah risiko paling serius.  Mengubah format pemeriksaan dimungkinkan ketika Apple mengubah sesuatu tanpa memperingatkan kami.  Kami memiliki kasus seperti itu: ketika beralih ke iOS 11, format cek benar-benar berubah.  Kami membuat cek palsu di server kami dan menggunakannya dalam pengujian.  Semuanya sempurna dengan kami: semua bidang ada di tempatnya, semuanya indah, semuanya sedang diproses.  Tetapi ketika kami beralih ke sistem nyata, tidak ada yang berhasil.  Bidang yang signifikan pada cek tidak lagi ada. <br><br>  Bagaimana cara mengkompensasi risiko ini?  Pertama, kami tidak mengecualikan kemungkinan pengujian end-to-end dari kotak pasir sebelum rilis dan pembayaran riil setelah rilis.  Sekarang kami berada dalam fase aktif proyek untuk memeriksa notifikasi, ketika kami mencoba untuk mengklasifikasikan semua cek yang kami terima dari produksi berdasarkan apakah kami memahami apa itu atau tidak mengerti.  Jika jawabannya tidak, maka kami mulai memproses semuanya secara manual, melihat apa yang telah berubah, apa yang salah, apa yang perlu diubah dalam sistem kami. <br><div class="scrollable-table"><table><tbody><tr><td>  Resiko <br></td><td>  Alasan <br></td><td>  Bagaimana cara memberi kompensasi <br></td></tr><tr><td>  konfigurasi yang salah <br></td><td>  hapus cek <br></td><td>  unit test di server <br></td></tr><tr><td>  kasus tepi <br>  (periksa tidak terkirim) <br></td><td>  gunakan backdoor <br></td><td>  E2E-cek (kotak pasir dan pembayaran riil) <br></td></tr><tr><td>  penipuan penipuan, penipuan <br></td><td>  pemberitahuan dan periksa pembuatan di server <br></td><td>  sertifikat sendiri <br></td></tr><tr><td>  ubah format cek <br></td><td>  pemberitahuan dan periksa pembuatan di server <br></td><td>  verifikasi notifikasi nyata dan cek pada prod (proyek baru), <br>  E2E-cek (kotak pasir dan pembayaran riil) <br></td></tr></tbody></table></div><br><h2>  Hasil </h2><br><br>  Pertimbangkan keuntungan utama yang bisa kami dapatkan sebagai hasil dari penerapan metode moki dan objek palsu. <br><br><h4>  Otomatisasi layanan berbayar yang murah, cepat, dan stabil di iOS </h4><br>  Bersama dengan tim pengujian manual iOS (terima kasih khusus kepada Colin Chan), kami dapat menulis lebih dari 150 tes otomatis untuk pembayaran.  Ini adalah jumlah pertanggungan yang cukup besar untuk satu area aplikasi. <br><br>  Berkat paralelisasi, kami bisa mendapatkan hasilnya hanya dalam 15-20 menit pada cabang pengembang klien iOS atau pengembang server penagihan.  Sebelum otomatisasi, pengujian manual pada area ini oleh satu orang membutuhkan waktu delapan jam. <br><br>  Kami juga dapat menguji sebagian besar kasus uji dengan menyiapkan Penyedia Pembayaran Mock melalui moki seperti yang kami butuhkan.  Dengan bantuan mooks, kami belajar cara mematikan pemeriksaan produk dan mensimulasikan kasus ketika pemeriksaan dilakukan sebagian.  Dengan demikian, kami membuka kasus yang tidak dapat kami uji secara prinsip sebelumnya. <br><br><h4>  Regresi fungsional dalam pengembangan fitur baru </h4><br>  Otomasi bekerja sangat baik dalam kasus-kasus tersebut ketika pengembang dalam proses mengerjakan fitur baru memengaruhi fungsionalitas lama.  Kami memiliki contoh ketika pengembang melakukan fitur kompleks dengan caching dan menjalankan pengujian otomatis kami.  Beberapa dari mereka jatuh dalam kesalahan.  Dia melihatnya dan memperbaikinya.  Kemudian dia memulai lagi autotest - dan lagi, sesuatu jatuh.  Akibatnya, ia melakukan serangkaian iterasi sampai saat ketika semuanya mulai bekerja secara normal di sisi aplikasi. <br><br><h4>  Regresi fungsional dalam refactoring pembayaran </h4><br>  Mungkin otomatisasi paling sukses dan efisien yang mungkin terjadi di bidang refactoring kode.  Dalam hal ini, hanya perubahan implementasi internal - tidak perlu mengubah kode autotest.  UI tidak berubah dengan cara apa pun, dan uji coba dapat didorong secara efisien. <br><br><h4>  Menguji fitur eksperimental dari Apple: masa tenggang </h4><br>  Sistem serupa sepenuhnya dapat dipertukarkan saat Anda menguji integrasi baru yang belum diimplementasikan di kotak pasir.  Begitu juga dengan masa tenggang.  Fungsi ini tidak ada di kotak pasir.  Masa tenggang di Apple belum tersedia untuk semua orang.  Ini adalah proyek percontohan yang diterapkan Badoo dengan Apple.  Untuk memeriksa masa tenggang, kami perlu menambahkan sepotong kode JSON di sini: <br><br><pre> <code class="json hljs">pending_renewal_info:[ { expiration_intent: <span class="hljs-number"><span class="hljs-number">2</span></span> grace_period_expires_date: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> Etc/GMT auto_renew_product_id: badoo.productId original_transaction_id: <span class="hljs-number"><span class="hljs-number">560000361869085</span></span> is_in_billing_retry_period: <span class="hljs-number"><span class="hljs-number">1</span></span> grace_period_expires_date_pst: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> America/Los_Angeles product_id: badoo.productId grace_period_expires_date_ms: <span class="hljs-number"><span class="hljs-number">1556207457000</span></span> auto_renew_status: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  <i><font color="gray">Listing 10. Masa tenggang untuk berlangganan</font></i> <br><br>  Kami melakukan ini dengan sangat mudah hanya dalam beberapa detik.  Dalam sistem kami, kami dapat menguji reaksi kami terhadap fitur baru.  Sekarang kami menjalankan fungsi ini pada prod. <br><br><h4>  Pengujian kualitas produk dalam metode komposisi </h4><br>  Sebagai hasil dari penelitian kami, kami dapat menggambarkan metode yang menghilangkan kebisingan dari ketergantungan eksternal.  Ini membantu pengembang klien dalam proses mengembangkan fitur menemukan bug pada tahap awal. <br><br>  Tetapi jangan berpikir bahwa kami dapat menguji semuanya dengan metode ini.  Untuk menguji semuanya, lebih baik menggunakan komposisi metode: pengujian dengan kartu nyata pada produk, pengujian di kotak pasir, metode mokes dan benda palsu, unit dan pengujian integrasi.  Harap ingat keseimbangan piramida pengujian dan jangan mencoba menyelesaikan semua masalah dengan satu metode.  Hal ini dapat menyebabkan otomatisasi yang menyedihkan di kotak pasir, hingga pengujian manual yang menyedihkan dengan kartu nyata dari semua kasus dan banyak kesalahan serius lainnya di tempat di mana penampilan mereka adalah yang paling menyakitkan. <br><br><h2>  Kesimpulan </h2><br>  Sebagai hasil dari penelitian kami, kami mendapatkan metode pengujian yang murah, cepat dan stabil tidak hanya layanan berbayar di iOS, tetapi juga komponen apa pun yang tertanam dalam aplikasi sebagai "kotak hitam".  Sekarang di Badoo kami menerapkan metode ini untuk pengujian pada penyedia berbayar Android (Global Charge, Boku, Centili) yang memiliki kotak pasir tidak stabil atau batasan lainnya.  Kami juga menggunakan metode moki untuk menguji iklan, streaming, dan geolokasi. <br><br>  Perlu dikatakan bahwa proses memperkenalkan metode baru tidak cepat.  Saya harus bernegosiasi dengan empat tim: iOS QA, iOS Dev, Billing QA, Billing Dev.  Tidak semua orang ingin beralih ke metode baru, takut risiko.  Kadang-kadang itu adalah dogmatis: selama bertahun-tahun kami menguji di kotak pasir, dan kekuatan utama yang dapat menghancurkan dogma adalah keinginan para penguji penagihan dan platform iOS untuk mengubah situasi dan menyingkirkan siksaan.  Kemudian, pengembang menyadari kelebihan metode ini sebagai diagnostik yang akurat (kami tidak dapat menemukan bug di kotak pasir, tetapi bug dari klien atau server kami), fleksibilitas dalam menyiapkan komponen (kami dapat dengan mudah menguji kasus negatif pada tingkat integrasi) dan, tentu saja, jawabannya adalah 30 menit di cabang dengan kode yang dikembangkan. <br><br>  Banyak terima kasih kepada semua orang yang telah membaca sampai akhir.  Terima kasih banyak kepada semua orang yang telah membantu dan berpartisipasi dalam proyek ini.  Terima kasih khusus kepada orang-orang ini: <br><br><ul><li>  Peter Kolpashchikov adalah pengembang iOS yang membantu membuat moki di sisi klien dan mengembangkan konsep PPP; <br></li><li>  Vladimir Solodov - QA Penagihan, yang membantu dengan QA API untuk menghasilkan cek palsu dan checkout dari server penagihan; <br></li><li>  Maxim Filatov dan Vasily Stepanov - Tim Penagihan Billing, yang membantu dengan kode server penagihan; <br></li><li>  iOS Dev Team - pengembang yang dapat memperbaiki pembayaran kami dalam konsep baru, memungkinkan penggunaan moka; <br></li><li>  Tim QA iOS adalah tim pengujian yang luar biasa yang menulis banyak uji coba; <br></li><li>  Billing Tim QA - penguji yang membantu meneliti masalah. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460667/">https://habr.com/ru/post/id460667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460651/index.html">Pertemuan Society of Anonymous Testers: TMS, pemantauan pemantauan, penilaian kualitas pencarian dan tes iOS asli</a></li>
<li><a href="../id460655/index.html">Bagaimana saya mematahkan Telegram</a></li>
<li><a href="../id460659/index.html">Menggunakan Pipa untuk Pivoting</a></li>
<li><a href="../id460661/index.html">Semua yang perlu Anda ketahui tentang Node.js</a></li>
<li><a href="../id460665/index.html">Draft FAQ: Mengapa standar C ++ keluar setiap tiga tahun?</a></li>
<li><a href="../id460669/index.html">Bagaimana memastikan keamanan pengembangan, menghemat waktu dan saraf</a></li>
<li><a href="../id460671/index.html">Kepemilikan dan pinjaman dalam D</a></li>
<li><a href="../id460673/index.html">Paparkan keajaiban DiffUtil</a></li>
<li><a href="../id460675/index.html">Ekstraksi Data Pembelajaran Mesin</a></li>
<li><a href="../id460683/index.html">Proyektor Acara Laravel dan Konsep Pembuatan Acara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>