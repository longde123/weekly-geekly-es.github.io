<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏿 🥝 👩🏽‍✈️ Interupsi Eksternal dalam sistem x86. Bagian 1. Mengganggu evolusi pengontrol ◼️ 🤳🏻 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah tentang proses pengiriman interupsi dari perangkat eksternal dalam sistem x86. Mencoba menjawab pertanyaan seperti: 



- Apa itu p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interupsi Eksternal dalam sistem x86. Bagian 1. Mengganggu evolusi pengontrol</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446312/">  Artikel ini adalah tentang proses pengiriman interupsi dari perangkat eksternal dalam sistem x86.  Mencoba menjawab pertanyaan seperti: <br><br><ul><li>  Apa itu pic dan untuk apa? </li><li>  Apa itu APIC dan untuk apa?  Apa tujuan LAPIC dan I / O APIC? </li><li>  Apa perbedaan antara APIC, xAPIC, dan x2APIC? </li><li>  Apa itu MSI?  Apa perbedaan antara MSI dan MSI-X? </li><li>  Apa peran tabel $ PIR, MPtable, dan ACPI? </li></ul><br>  Jika Anda ingin mengetahui jawaban untuk salah satu dari pertanyaan ini, atau jika Anda hanya ingin tahu tentang evolusi pengendali interupsi, silakan, selamat datang. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Bagi mereka yang tidak tahu apa itu interupsi, berikut adalah kutipan dari Wikipedia: <br><blockquote> Dalam pemrograman sistem, interupsi adalah sinyal ke prosesor yang dipancarkan oleh perangkat keras atau perangkat lunak yang mengindikasikan suatu peristiwa yang perlu segera diperhatikan.  Sebuah interupsi memberi tahu prosesor pada kondisi prioritas tinggi yang memerlukan gangguan kode saat ini yang dijalankan prosesor.  Prosesor merespons dengan menangguhkan aktivitasnya saat ini, menyimpan keadaannya, dan menjalankan fungsi yang disebut interrupt handler (atau interrupt service rutin, ISR) untuk menangani peristiwa tersebut.  Gangguan ini bersifat sementara, dan, setelah pengendali interupsi selesai, prosesor melanjutkan aktivitas normal. <br><br>  Ada dua jenis interupsi: interupsi perangkat keras dan interupsi perangkat lunak (softirqs): <br><br><ul><li>  Gangguan perangkat keras digunakan oleh perangkat untuk berkomunikasi yang memerlukan perhatian dari sistem operasi.  Secara internal, gangguan hardware diimplementasikan menggunakan sinyal peringatan elektronik yang dikirim ke prosesor dari perangkat eksternal, yang merupakan bagian dari komputer itu sendiri, seperti pengontrol disk, atau periferal eksternal.  Misalnya, menekan tombol pada keyboard atau menggerakkan mouse memicu gangguan perangkat keras yang menyebabkan prosesor membaca ketukan tombol atau posisi mouse.  Tindakan memulai interupsi perangkat keras disebut sebagai permintaan interupsi (IRQ). </li><li>  Gangguan perangkat lunak disebabkan oleh kondisi luar biasa pada prosesor itu sendiri, atau instruksi khusus dalam rangkaian instruksi yang menyebabkan gangguan ketika dijalankan.  Yang pertama sering disebut jebakan atau pengecualian dan digunakan untuk kesalahan atau peristiwa yang terjadi selama pelaksanaan program yang cukup luar biasa sehingga tidak dapat ditangani dalam program itu sendiri.  Misalnya, pengecualian bagi-oleh-nol akan dilemparkan jika unit logika aritmatika prosesor diperintahkan untuk membagi angka dengan nol karena instruksi ini merupakan kesalahan dan tidak mungkin. </li></ul></blockquote><br>  Artikel ini membahas tentang gangguan hardware / eksternal IRQ. <br><br>  Apa tujuan dari interupsi?  Misalnya, kami ingin melakukan tindakan dengan paket yang masuk dari kartu jaringan segera setelah paket tersebut tiba.  Jika Anda tidak ingin terus bertanya pada kartu jaringan, "Apakah paket saya sudah tiba?"  dan buang waktu prosesor Anda, Anda dapat menggunakan IRQ interupsi perangkat keras eksternal.  Jalur interupsi dari perangkat harus terhubung ke jalur INTR CPU, dan setelah setiap paket diterima, kartu jaringan akan membuat sinyal melalui jalur ini.  CPU akan merasakan sinyal ini dan tahu bahwa kartu jaringan memiliki informasi untuk itu.  Baru setelah itu CPU akan membaca paket yang masuk. <br><br>  Tetapi apa yang harus kita lakukan jika ada banyak perangkat eksternal?  Akan sangat tidak produktif untuk membuat satu ton pin INTR pada CPU untuk semuanya. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Untuk mengatasi masalah ini, sebuah chip khusus ditemukan - sebuah pengontrol interupsi. <br><br><h3>  Foto </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">osdev</a> ) <br><br>  Chip pengendali interupsi pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel 8259 PIC</a> .  Itu memiliki 8 jalur input (IRQ0-7) dan 1 jalur output (yang menghubungkan pengontrol interupsi dengan jalur INTR CPU).  Ketika ada interupsi dari salah satu perangkat pada jalur inputnya, 8259 akan membuat sinyal melalui jalur INTR.  Setelah itu CPU akan tahu bahwa beberapa perangkat memerlukan perhatian segera, dan prosesor akan menanyakan PIC mana dari 8 jalur input (IRQx) yang merupakan sumber interupsi ini.  Ada beberapa overhead untuk jajak pendapat ini, tetapi sekarang kami memiliki 8 jalur interupsi alih-alih 1. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Segera 8 baris tidak cukup.  Untuk menambah jumlah garis interupsi, dua pengontrol 8259 (master dan slave) dihubungkan dalam kaskade (Dual PIC). <br><br>  IRQ dari 0 hingga 7 diproses dengan Intel 8259 PIC (master) pertama, dan IRQ dari 8 hingga 15 diproses dengan Intel 8259 PIC (master) kedua.  Hanya master yang terhubung ke CPU dan dapat memberi sinyal tentang interupsi yang masuk.  Jika ada interupsi pada jalur 8-15, PIC kedua (slave) akan memberi sinyal tentang hal itu kepada master di jalur IRQ2, dan setelah itu master akan memberi sinyal CPU.  Interupsi bertingkat ini menghilangkan 1 dari 16 baris, tetapi membuat total 15 interupsi untuk semua perangkat eksternal. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Skema ini diadopsi oleh komunitas, dan sekarang ketika seseorang berbicara tentang PIC (Programm Interrupt Controller) yang mereka maksudkan adalah sistem Dual PIC ini.  Setelah beberapa waktu, pengendali 8259 ditingkatkan dan mendapat nama baru: 8259A.  Dengan pengontrol ini, sistem DUAL PIC dimasukkan ke dalam chipset.  Pada saat bus utama untuk koneksi perangkat eksternal adalah ISA, sistem ini cukup.  Itu hanya diperlukan bahwa perangkat yang berbeda tidak terhubung ke jalur IRQ yang sama, karena interupsi ISA tidak dapat dibagikan. <br><br>  Pemetaan interupsi perangkat cukup standar: <br><br>  Contoh (dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): <br>  IRQ 0 - timer sistem <br>  IRQ 1 - pengontrol keyboard <br>  IRQ 2 - cascade (interupsi dari slave controller) <br>  IRQ 3 - port serial COM2 <br>  IRQ 4 - port serial COM1 <br>  IRQ 5 - port paralel 2 dan 3 atau kartu suara <br>  IRQ 6 - pengontrol floppy <br>  IRQ 7 - port paralel 1 <br>  Penghitung waktu IRQ 8 - RTC <br>  IRQ 9 - ACPI <br>  IRQ 10 - terbuka / SCSI / NIC <br>  IRQ 11 - terbuka / SCSI / NIC <br>  IRQ 12 - pengendali mouse <br>  IRQ 13 - co-prosesor matematika <br>  IRQ 14 - saluran ATA 1 <br>  IRQ 15 - saluran ATA 2 <br><br>  Konfigurasi dan bekerja dengan 8259 chip dilakukan dengan port I / O: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Daftar </th><th>  I / O port </th></tr><tr><td>  Master pic </td><td>  Perintah </td><td>  0x0020 </td></tr><tr><td>  Master pic </td><td>  Data </td><td>  0x0021 </td></tr><tr><td>  Foto budak </td><td>  Perintah </td><td>  0x00A0 </td></tr><tr><td>  Foto budak </td><td>  Data </td><td>  0x00A1 </td></tr></tbody></table></div><br>  Dokumentasi lengkap 8259A dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Bus PCI kemudian menggantikan bus ISA.  Sayangnya, jumlah perangkat mulai melebihi angka 15. Juga bukan bus ISA statis, perangkat di bus PCI dapat ditambahkan ke sistem secara dinamis yang berpotensi menyebabkan masalah lebih banyak lagi.  Namun untungnya, interupsi dalam bus PCI dapat dibagi, sehingga dimungkinkan untuk menghubungkan banyak perangkat ke satu jalur interupsi IRQ.  Pada akhirnya, untuk mengatasi masalah kurangnya jalur interupsi, diputuskan untuk mengelompokkan interupsi dari semua perangkat PCI ke jalur PIRQ (Programmable Interrupt Request). <br><br>  Sebagai contoh, misalkan kita memiliki 4 jalur interupsi gratis pada pengontrol PIC dan 20 perangkat PCI.  Kami dapat menggabungkan interupsi dari 5 perangkat menjadi satu baris PIRQx, dan menghubungkan garis PIRQx ini ke pengontrol PIC.  Dalam hal ini jika ada interupsi pada salah satu jalur PIRQx, prosesor harus menanyakan semua perangkat yang terhubung ke baris ini tentang interupsi untuk mengetahui siapa yang bertanggung jawab untuknya, tetapi pada akhirnya itu menyelesaikan masalah.  Perangkat yang menghubungkan jalur interupsi PCI ke jalur PIRQ sering disebut router PIR. <br><br>  Dengan metode ini, perlu untuk memastikan bahwa garis PIRQx tidak terhubung ke garis dengan interupsi ISA (karena ini akan menghasilkan konflik) dan bahwa garis PIRQx seimbang (semakin banyak perangkat yang kita hubungkan ke satu garis, semakin banyak perangkat yang dibutuhkan CPU. untuk polling ketika perlu memeriksa perangkat mana yang bertanggung jawab atas interupsi). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Catatan</b> : pada gambar, pemetaan perangkat PCI -&gt; PIR digambarkan secara abstrak, karena dalam kasus sebenarnya ini sedikit lebih rumit.  Di dunia nyata setiap perangkat PCI memiliki 4 jalur interupsi (INTA, INTB, INTC, INTD) dan hingga 8 fungsi, di mana setiap fungsi hanya dapat memiliki satu dari interupsi INTx ini.  Garis INTx mana yang akan digunakan oleh setiap fungsi ditentukan oleh konfigurasi chipset. <br><br>  Pada dasarnya fungsi mereka adalah blok logis yang terpisah.  Misalnya, satu perangkat PCI dapat memiliki fungsi pengontrol Smbus, fungsi pengontrol SATA, dan fungsi jembatan LPC.  Dari sudut pandang sistem operasi (OS), setiap fungsi seperti perangkat terpisah dengan ruang konfigurasi sendiri (PCI config). <br><br>  Informasi tentang perutean interupsi pengontrol PIC dikirim ke OS oleh BIOS, dengan bantuan tabel $ PIR dan melalui register 3Ch (INT_LN Interrupt Line (R / W)) dan 3Dh (INT_PN Interrupt Pin (RO)) dari ruang konfigurasi PCI untuk setiap fungsi. <br><br>  Spesifikasi untuk tabel $ PIR baru-baru ini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Microsoft</a> , tetapi saat ini tidak tersedia.  Dimungkinkan untuk memahami konten tabel dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi PCI BIOS</a> [4.2.2.  Dapatkan Opsi Perutean Interupsi PCI] atau dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (tautan terakhir dalam bahasa Rusia, tetapi Anda dapat mencoba google "Spesifikasi Tabel Perutean PCI IRQ") <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">osdev</a> ) <br><br>  Metode terakhir bekerja hingga sistem multiprosesor tiba.  Secara alami, PIC hanya dapat mengirim interupsi ke satu CPU, dan dalam sistem multiprosesor diinginkan untuk memuat CPU secara seimbang.  Solusi untuk masalah ini adalah antarmuka APIC baru (Advanced PIC). <br><br>  Kontroler khusus yang disebut LAPIC (Local APIC) telah ditambahkan untuk setiap prosesor, serta kontroler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">I / O APIC</a> untuk routing yang mengganggu dari perangkat eksternal.  Semua pengontrol ini digabungkan dalam bus umum dengan nama APIC (perhatikan bahwa sistem modern menggunakan bus sistem standar alih-alih bus APIC terpisah untuk tugas ini). <br><br>  Ketika interupsi eksternal tiba pada input I / O APIC, pengontrol akan mengirimkan pesan interupsi ke LAPIC dari salah satu CPU sistem.  Dengan cara ini kontroler I / O APIC membantu menyeimbangkan beban interupsi antar prosesor. <br><br>  Chip APIC pertama adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">82489DX</a> , yang merupakan chip terpisah yang memiliki LAPIC dan I / O APIC yang terhubung.  Untuk sistem prosesor ganda diperlukan tiga chip seperti itu: dua untuk LAPIC dan satu untuk I / O APIC.  Fungsionalitas LAPIC kemudian langsung dimasukkan dalam prosesor, dan bagian I / O APIC dipisahkan ke chip 82093AA. <br><br>  I / O APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">82093AA</a> memiliki 24 input, dan arsitektur APIC dapat mendukung hingga 16 CPU.  Interupsi 0-15 merupakan interupsi ISA lama untuk kompatibilitas dengan sistem yang lebih lama, dan interupsi 16-23 ditujukan untuk semua perangkat PCI.  Dengan pembatasan ini semua konflik antara ISA dan interupsi PCI dapat dengan mudah dihindari.  Dengan meningkatnya jumlah jalur interupsi bebas, dimungkinkan juga untuk meningkatkan jumlah saluran PIRQx. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Pemrograman I / O APIC dan LAPIC dilakukan dengan bantuan MMIO.  Register LAPIC biasanya ditempatkan pada alamat 0xFEE00000, dan I / O APIC mendaftar pada alamat 0xFE0000, meskipun dimungkinkan untuk mengkonfigurasi ulang mereka. <br><br>  Seperti dalam kasus PIC, chip yang terpisah pada awalnya menjadi bagian dari chipset nanti. <br><br>  Arsitektur APIC kemudian dimodernisasi, dan varian barunya bernama xAPIC (x-extended).  Dengan kompatibilitas penuh mundur, jumlah total CPU yang mungkin dalam sistem ditingkatkan menjadi 256. <br><br>  Langkah selanjutnya dalam pengembangan arsitektur bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">x2APIC</a> .  Jumlah CPU yang mungkin dalam sistem meningkat menjadi 2 ^ 32.  Pengontrol ini dapat bekerja dalam mode kompatibilitas mundur dengan xAPIC, atau mereka dapat bekerja dalam mode x2APIC baru.  Dalam mode baru ini, pemrograman pengontrol tidak dilakukan melalui MMIO, tetapi melalui register MSR (yang jauh lebih cepat).  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> , dukungan IOMMU diperlukan untuk mode ini. <br><br>  Penting untuk dicatat bahwa ada kemungkinan untuk memiliki beberapa pengontrol APIC I / O dalam sistem.  Misalnya, satu untuk 24 interupsi di southbridge dan yang lain untuk 32 interupsi di northbridge.  Dalam konteks I / O APIC, interupsi biasanya disebut GSI (Global System Interrupt).  Jadi, sistem yang disebutkan sebelumnya memiliki GSI 0-55. <br><br>  Bagaimana kita dapat menentukan apakah CPU memiliki LAPIC internal dan arsitektur APIC apa yang didukungnya?  Dimungkinkan untuk menjawab pertanyaan ini dengan memeriksa bit-flag dari CPUID. <br>  Untuk membantu OS menemukan LAPIC dan I / O APIC, BIOS harus menyajikan informasi tentang mereka baik melalui MPtable (metode lama) atau melalui tabel ACPI (tabel MADT dalam kasus ini).  Selain informasi umum, MPtable dan ACPI (dalam hal ini tabel DSDT) harus berisi informasi tentang interrupt routing.  Ini berarti informasi tentang perangkat mana yang menggunakan jalur interupsi (mirip dengan tabel $ PIR). <br><br>  Anda dapat membaca tentang MPtable dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20121002210153/">spesifikasi</a> resmi.  Sebelumnya spesifikasinya ada di situs web Intel, tetapi saat ini hanya mungkin menemukannya dalam versi arsip.  Spesifikasi ACPI dapat ditemukan di situs web UEFI (versi saat ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2</a> ).  Perlu diperhatikan bahwa dengan ACPI dimungkinkan untuk mendeklarasikan perutean interupsi untuk sistem tanpa APIC (alih-alih menyediakan tabel $ PIR yang terpisah). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> ) <br><br>  Varian terakhir dari APIC adalah baik, tetapi bukan tanpa kerugian.  Semua jalur interupsi dari perangkat membuat sistem sangat rumit dan dengan demikian meningkatkan kemungkinan kesalahan.  PCI express bus datang untuk menggantikan PCI bus, yang menyederhanakan semua sistem interupsi sepenuhnya.  Itu tidak memiliki garis interupsi sama sekali.  Untuk sinyal interupsi kompatibilitas mundur (INTx #) ditiru dengan jenis pesan terpisah.  Dengan jalur interupsi PCI, koneksi mereka dibuat dengan kabel fisik.  Dengan jalur interupsi PCI express, koneksi logis dan dibuat oleh PCI express bridges.  Tetapi dukungan legacy INTx interrupts ini hanya ada untuk kompatibilitas dengan PCI bus.  PCI express memperkenalkan metode pengiriman interupsi yang sepenuhnya baru - MSI (Message Signaled Interrupts).  Dalam metode ini, perangkat memberi sinyal tentang interupsi hanya dengan menulis ke tempat khusus di wilayah MMIO CPU LAPIC. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Sebelumnya perangkat PCI tunggal (ini berarti semua fungsinya) hanya dapat memiliki 4 interupsi, tetapi sekarang menjadi mungkin untuk mengatasi hingga 32 interupsi. <br><br>  Dalam kasus MSI tidak ada pembagian garis interupsi: setiap interupsi secara alami sesuai dengan perangkatnya. <br><br>  MSI menyela juga memecahkan satu masalah lagi.  Misalnya, mari kita bayangkan situasi di mana perangkat melakukan transaksi penulisan-memori, dan ingin memberi sinyal tentang penyelesaiannya melalui interupsi.  Tetapi transaksi tulis dapat ditunda di bus dalam proses transmisi (dan perangkat tidak dapat mengetahuinya).  Dalam hal ini sinyal tentang interupsi akan datang ke CPU terlebih dahulu, sehingga prosesor akan membaca data yang belum valid.  Jika MSI digunakan, informasi tentang MSI ditransmisikan dengan cara yang sama seperti pesan data, sehingga tidak bisa datang lebih awal. <br><br>  Perlu diperhatikan bahwa interupsi MSI tidak dapat bekerja tanpa LAPIC, tetapi MSI dapat menggantikan I / O APIC (satu lagi penyederhanaan desain). <br><br>  Setelah beberapa waktu, metode MSI diperluas ke MSI-X.  Sekarang setiap perangkat dapat memiliki hingga 2048 interupsi.  Sekarang juga memungkinkan untuk menentukan CPU mana yang harus memproses interupsi.  Ini bisa sangat berguna untuk perangkat dengan beban tinggi, seperti kartu jaringan misalnya. <br><br>  Tidak perlu untuk tabel BIOS terpisah untuk dukungan MSI.  Tetapi perangkat harus menunjukkan dukungan MSI melalui salah satu Kemampuan dalam ruang PCI Config-nya.  Juga, driver perangkat harus mencakup semua dukungan yang diperlukan untuk bekerja dengan MSI. <br><br><h3>  Kesimpulan </h3><br>  Pada artikel ini, kami telah mempelajari informasi tentang evolusi pengontrol interupsi dan telah mendapatkan pengetahuan teori umum tentang pengiriman interupsi dari perangkat eksternal dalam sistem x86. <br><br>  Pada bagian selanjutnya kita akan berlatih dan melihat bagaimana cara melibatkan masing-masing pengendali interupsi yang disebutkan di Linux. <br><br>  Pada bagian ketiga kita akan melihat ke dalam kode coreboot dan melihat pengaturan apa yang diperlukan dalam chipset untuk perutean interupsi yang benar. <br><br><h4>  Tautan: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interrupt Controllers (Stuff in the Middle)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang dilakukan berbagai interupsi dalam PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengurangi Latensi Interupsi Melalui Penggunaan Pesan Signaling Interrupts</a> </li></ul><br><h4>  Segmen yang diakui </h4><br>  Terima kasih khusus kepada Jacob Garber dari komunitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coreboot yang</a> telah membantu saya dengan terjemahan artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446312/">https://habr.com/ru/post/id446312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446300/index.html">Bagaimana mengoordinasikan penerbangan probe ke stratosfer (apa yang akan kita temui dalam praktik saat peluncuran)</a></li>
<li><a href="../id446302/index.html">9 kutipan dari Habraseminar 2019 untuk blogger, pengusaha, dan SDM</a></li>
<li><a href="../id446304/index.html">Fungsi fisik yang tidak dapat dipertanggungjawabkan: perlindungan untuk elektronik terhadap penyalinan ilegal</a></li>
<li><a href="../id446306/index.html">Perang nuklir di masa lalu yang jauh?</a></li>
<li><a href="../id446308/index.html">Apakah perekrutan rujukan masih hidup di TI?</a></li>
<li><a href="../id446316/index.html">Hanya ruang! Sepotong besar titanium dalam 6,5 hari</a></li>
<li><a href="../id446320/index.html">Bagaimana pemindai 3D diizinkan meninggalkan unit kontrol jembatan skala penuh</a></li>
<li><a href="../id446322/index.html">Kriptografi di Jawa. Utilitas Keytool</a></li>
<li><a href="../id446324/index.html">Navigasi di DataGrip dengan Yandex.Navigator</a></li>
<li><a href="../id446326/index.html">Memecahkan masalah lalu lintas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>