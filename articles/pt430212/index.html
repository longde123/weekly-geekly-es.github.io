<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∑Ô∏è ‚ô†Ô∏è üë®üèΩ‚Äçüíª OpenSceneGraph: No√ß√µes b√°sicas de geometria de cena üê™ üìÜ üîñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 O OpenGL, que √© o back-end do OpenSceneGraph, usa primitivas geom√©tricas (como pontos, linhas, tri√¢ngulos e faces poligonais) para con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: No√ß√µes b√°sicas de geometria de cena</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagem"><br><br><h1>  1. Introdu√ß√£o </h1><br>  O OpenGL, que √© o back-end do OpenSceneGraph, usa primitivas geom√©tricas (como pontos, linhas, tri√¢ngulos e faces poligonais) para construir todos os objetos no mundo tridimensional. <br><br>  Essas primitivas s√£o definidas por dados sobre seus v√©rtices, que incluem as coordenadas dos v√©rtices, componentes normais, dados de cores e coordenadas de textura.  Esses dados s√£o armazenados em matrizes especiais.  As primitivas podem ser formadas, por exemplo, especificando para os objetos que os descrevem uma lista de √≠ndices de v√©rtices.  Esse m√©todo √© chamado de m√©todo de matriz de v√©rtices; elimina o armazenamento de v√©rtices redundantes na mem√≥ria e apresenta bom desempenho. <br><br>  Al√©m disso, o OpenGL pode usar o mecanismo das chamadas <i>listas de exibi√ß√£o</i> , quando as primitivas preparadas na mem√≥ria de v√≠deo podem ser reutilizadas, o que acelera significativamente a exibi√ß√£o de objetos est√°ticos. <br><br>  Por padr√£o, o OSG usa o m√©todo da matriz de v√©rtices e o m√©todo da lista de exibi√ß√£o para renderizar a geometria.  No entanto, a estrat√©gia de renderiza√ß√£o pode ser alterada, dependendo de como os dados geom√©tricos s√£o apresentados.  Neste artigo, abordaremos as t√©cnicas b√°sicas para trabalhar com geometria no OSG. <br><a name="habracut"></a><br><h1>  1. Classes Geode e Drawable </h1><br>  A classe osg :: Geode √© um terminal, o chamado n√≥ "folha" da √°rvore de cenas.  Ele n√£o pode ter n√≥s filhos, mas cont√©m todas as informa√ß√µes necess√°rias para renderizar a geometria.  Seu nome, Geode, √© abrevia√ß√£o de n√≥ de geometria. <br><br>  Os dados geom√©tricos a serem processados ‚Äã‚Äãpelo mecanismo s√£o armazenados no conjunto de objetos da classe osg :: Drawable, gerenciados pela classe osg :: Geode.  A classe osg :: Drawable √© uma classe puramente virtual.  Um n√∫mero de subclasses √© herdado dele, que s√£o modelos tridimensionais, imagens e texto processados ‚Äã‚Äãpelo pipeline OpenGL.  OSG refere-se a drawable como todos os elementos que podem ser desenhados pelo mecanismo. <br><br>  A classe osg :: Geode fornece v√°rios m√©todos para anexar e desanexar drawables: <br><br><ul><li>  M√©todo p√∫blico addDrawable () - passa um ponteiro para um elemento desenh√°vel em uma inst√¢ncia da classe osg :: Geode.  Todos esses elementos s√£o controlados pelos ponteiros inteligentes osg :: ref_ptr &lt;&gt;. <br></li><li>  O m√©todo p√∫blico removeDrawable () e removeDrawables () remove o objeto de osg :: Geode e diminui a contagem de refer√™ncia para ele.  O m√©todo removeDrawable () usa como √∫nico par√¢metro um ponteiro para o elemento de interesse, e o m√©todo removeDrawables () usa dois par√¢metros: o √≠ndice inicial e o n√∫mero de elementos a serem removidos da matriz de objetos osg :: Geode. <br></li><li>  O m√©todo getDrawable () retorna um ponteiro para um elemento no √≠ndice passado como par√¢metro. <br></li><li>  O m√©todo getNumDrawables () retorna o n√∫mero total de elementos anexados ao osg :: Geode.  Por exemplo, para remover todos os elementos do osg :: Geode, voc√™ pode usar esse c√≥digo <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Desenho de formas simples </h1><br>  O OSG fornece a classe osg :: ShapeDrawable, que √© a descendente da classe osg :: Drawable e projetada para criar primitivas tridimensionais simples.  Esta classe inclui um objeto osg :: Shape que armazena informa√ß√µes sobre geometria espec√≠fica e outros par√¢metros.  As primitivas s√£o geradas usando o m√©todo setShape (), por exemplo <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  cria uma caixa retangular com um centro geom√©trico no ponto (1.0, 0.0, 0.0) com largura e altura de 10 e profundidade de 5 unidades.  A classe osg :: Vec3 define um vetor no espa√ßo tridimensional (al√©m disso, as classes osg :: Vec2 e osg :: Vec4 que descrevem vetores da dimens√£o correspondente tamb√©m s√£o apresentadas). <br><br>  As primitivas mais populares s√£o representadas no OSG pelas classes osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder e osg :: Sphere. <br><br>  Considere um exemplo da aplica√ß√£o desse mecanismo. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Este exemplo especialmente n√£o precisa de coment√°rios: no programa s√£o criadas tr√™s formas simples, ap√≥s a compila√ß√£o e o lan√ßamento, veremos esse resultado <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  O mecanismo mostrado no exemplo √© simples e direto, mas n√£o √© a maneira mais eficaz de criar geometria e pode ser usado exclusivamente para testes.  A classe osg :: Geometry √© usada para criar geometria em aplicativos baseados em OSG de alto desempenho. <br><br><h1>  3. Armazenamento de dados de geometria: classes osg :: Array e osg :: Geometry </h1><br>  A classe osg :: Array √© uma classe abstrata b√°sica, da qual v√°rios descendentes s√£o herdados, projetados para armazenar dados que s√£o passados ‚Äã‚Äãpara as fun√ß√µes do OpenGL.  Trabalhar com essa classe √© semelhante ao trabalho com std :: vector da biblioteca padr√£o C ++.  O c√≥digo a seguir ilustra como adicionar um vetor a uma matriz de v√©rtices usando o m√©todo push_back () <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  As matrizes OSG s√£o alocadas na pilha e gerenciadas por ponteiros inteligentes.  No entanto, isso n√£o se aplica a elementos de matriz, como osg :: Vec3 ou osg :: Vec2, que tamb√©m podem ser criados na pilha. <br><br>  A classe osg :: Geometry √© um inv√≥lucro sobre fun√ß√µes OpenGL que funcionam com matrizes de v√©rtices.  √â derivado da classe osg :: Drawable e pode ser facilmente adicionado √† lista de objetos osg :: Geode.  Essa classe usa as matrizes descritas acima como entrada e as utiliza para gerar geometria usando o OpenGL. <br><br><h1>  4. V√©rtices e seus atributos </h1><br>  Um v√©rtice √© uma unidade at√¥mica de primitivas de geometria.  Ele possui v√°rios atributos que descrevem um ponto no espa√ßo bidimensional ou tridimensional.  Os atributos incluem: posi√ß√£o, cor, vetor normal, coordenadas de textura, coordenadas de neblina e assim por diante.  A parte superior deve sempre ter uma posi√ß√£o no espa√ßo, pois para outros atributos, eles podem estar presentes opcionalmente.  O OpenGL suporta 16 atributos b√°sicos de v√©rtice e pode usar matrizes diferentes para armazen√°-los.  Todas as matrizes de atributos s√£o suportadas pela classe osg :: Geometry e podem ser definidas usando m√©todos do conjunto de formul√°rios * Array (). <br><br>  <b>Atributos de v√©rtice no OpenSceneGraph</b> <br><table><tbody><tr><th>  Atributo </th><th>  Tipo de dados </th><th>  M√©todo Osg :: Geometry </th><th>  Chamada equivalente ao OpenGL </th></tr><tr><td>  Posi√ß√£o </td><td>  3 vetores </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3 vetores </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Cor </td><td>  4 vetores </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Cor secund√°ria </td><td>  4 vetores </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Coordenadas de nevoeiro </td><td>  flutuar </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Coordenadas de textura </td><td>  2 ou 3 vetores </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Outros atributos </td><td>  Definido pelo Usu√°rio </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  Em princ√≠pio, √© necess√°rio definir seus pr√≥prios atributos para cada um dos v√©rtices, o que leva √† forma√ß√£o de v√°rias matrizes de atributos do mesmo tamanho - caso contr√°rio, a incompatibilidade nos tamanhos das matrizes pode levar a um comportamento indefinido do mecanismo.  O OSG suporta v√°rios m√©todos para vincular atributos de v√©rtice, por exemplo <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  significa que cada v√©rtice e cada cor do v√©rtice est√£o correlacionados um a um.  No entanto, se voc√™ olhar para esse c√≥digo <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  ent√£o ele aplica uma cor a toda a geometria.  Da mesma forma, os relacionamentos entre outros atributos podem ser configurados chamando os m√©todos setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () e setVertexAttribBinding (). <br><br><h1>  5. Conjuntos de primitivas de geometria </h1><br>  A pr√≥xima etapa ap√≥s definir as matrizes de atributos de v√©rtice √© descrever como os dados de v√©rtice ser√£o renderizados.  A classe virtual osg :: PrimitiveSet √© usada para controlar as primitivas geom√©tricas geradas pelo renderizador a partir de um conjunto de v√©rtices.  A classe osg :: Geometry fornece v√°rios m√©todos para trabalhar com conjuntos de primitivas de geometria: <br><br><ul><li>  addPrimitiveSet () - passa um ponteiro para um conjunto de primitivas em um objeto osg :: Geometry. <br></li><li>  removePrimitiveSet () - remove um conjunto de primitivas.  Como par√¢metros, leva o √≠ndice inicial de conjuntos e o n√∫mero de conjuntos a serem exclu√≠dos. <br></li><li>  getPrimitiveSet () - retorna um conjunto de primitivas no √≠ndice passado como par√¢metro. <br></li><li>  getNumPrimitiveSets () - retorna o n√∫mero total de conjuntos de primitivas associadas a essa geometria. <br></li></ul><br>  A classe osg :: PrimitiveSet √© abstrata e n√£o pode ser instanciada, mas v√°rias classes derivadas que encapsulam conjuntos de primitivas com as quais o OpenGL opera, como osg :: DrawArrays e osg :: DrawElementsUInt, herdam dela. <br><br>  A classe osg :: DrawArrays usa v√°rios elementos consecutivos de uma matriz de v√©rtices para construir uma primitiva geom√©trica.  Ele pode ser criado e anexado √† geometria chamando um m√©todo. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  O primeiro modo de par√¢metro define o tipo primitivo para os tipos primitivos correspondentes do OpenGL: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS e GL_POLY. <br><br>  O primeiro e o segundo par√¢metros especificam o primeiro √≠ndice na matriz de v√©rtices e o n√∫mero de v√©rtices a partir dos quais a geometria deve ser gerada.  <strong>Al√©m disso, o OSG n√£o verifica se o n√∫mero especificado de v√©rtices √© suficiente para construir a geometria especificada pelo modo, o que pode levar √† falha do aplicativo!</strong> <br><br><h1>  6. Exemplo - desenhe um quadrado pintado </h1><br>  Implementamos todos os itens acima como um exemplo simples <br><br><div class="spoiler">  <b class="spoiler_title">O c√≥digo fonte completo para o exemplo quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Ap√≥s a compila√ß√£o e execu√ß√£o, obtemos um resultado semelhante a este <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Este exemplo precisa de esclarecimentos.  Ent√£o, primeiro, criamos uma matriz de v√©rtices do quadrado, na qual suas coordenadas s√£o armazenadas <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Em seguida, definimos a matriz de normais.  No nosso caso simples, n√£o precisamos criar um normal para cada v√©rtice - apenas descreva um vetor unit√°rio direcionado perpendicularmente ao plano do quadrado <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Defina uma cor para cada v√©rtice <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Agora crie um objeto de geometria onde a descri√ß√£o do nosso quadrado ser√° armazenada, que ser√° processada pela renderiza√ß√£o.  Passamos uma matriz de v√©rtices para essa geometria <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Passando uma matriz de normais, informamos ao mecanismo que um √∫nico normal ser√° usado para todos os v√©rtices, especificando o m√©todo de liga√ß√£o ("liga√ß√£o") das normais BIND_OVAERALL <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  Passando as cores dos v√©rtices, pelo contr√°rio, indicamos que cada v√©rtice ter√° sua pr√≥pria cor <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Agora crie um conjunto de primitivas para geometria.  Indicamos que as faces quadradas (GL_QUADS) devem ser geradas a partir da matriz de v√©rtices, tomando o v√©rtice com o √≠ndice 0 como o primeiro v√©rtice e o n√∫mero total de v√©rtices ser√° 4 <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Bem, acho que n√£o vale a pena explicar a transfer√™ncia de geometria e o lan√ßamento da renderiza√ß√£o <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  O c√≥digo acima √© equivalente ao design a seguir no OpenGL puro <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. V√©rtices de indexa√ß√£o em primitivas </h1><br>  A classe osg :: DrawArrays funciona bem ao ler dados de v√©rtice diretamente de matrizes, sem intervalos.  No entanto, isso n√£o √© t√£o eficaz quando o mesmo v√©rtice pode pertencer a v√°rias faces de um objeto.  Vejamos um exemplo. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  O cubo tem oito v√©rtices.  No entanto, como pode ser visto na figura (observamos o desdobramento do cubo no avi√£o), alguns v√©rtices pertencem a mais de uma face.  Se voc√™ construir um cubo de 12 faces triangulares, esses v√©rtices ser√£o repetidos e, em vez de um conjunto de 8 v√©rtices, obteremos um conjunto de 36 v√©rtices, a maioria dos quais na verdade √© o mesmo v√©rtice! <br><br>  No OSG, existem as classes osg :: DrawElementsUInt, osg :: DrawElementsUByte e osg :: DrawElementsUShort, que usam matrizes de √≠ndice de v√©rtice como dados para resolver o problema descrito.  Matrizes de √≠ndices armazenam √≠ndices de v√©rtices de primitivas que descrevem faces e outros elementos da geometria.  Ao aplicar essas classes a um cubo, √© suficiente armazenar uma matriz de oito v√©rtices associados a faces por meio de matrizes de √≠ndices. <br><br>  Classes do tipo osg :: DrawElements * s√£o constru√≠das da mesma maneira que a classe padr√£o std :: vector.  Esse c√≥digo pode ser usado para adicionar √≠ndices. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Este c√≥digo define a face frontal do cubo mostrado na figura. <br><br>  Vamos considerar mais um exemplo ilustrativo - um octaedro <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  √â interessante porque cont√©m apenas seis v√©rtices, mas cada v√©rtice entra em at√© quatro faces triangulares!  Podemos criar uma matriz de 24 v√©rtices para exibir todas as oito faces usando osg :: DrawArrays.  No entanto, faremos o contr√°rio - armazenaremos os v√©rtices em uma matriz de seis elementos e geraremos faces usando a classe osg :: DrawElementsUInt. <br><br><div class="spoiler">  <b class="spoiler_title">Fonte completa para o exemplo do octaedro</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Vamos analisar esse c√≥digo em mais detalhes.  Claro, a primeira coisa que fazemos √© criar uma matriz de seis v√©rtices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Inicializamos cada v√©rtice diretamente acessando o vetor de suas coordenadas usando a opera√ß√£o de desreferenciamento do ponteiro e operador [] (lembramos que osg :: Array √© semelhante em seu dispositivo a std :: vector). <br><br>  Agora crie faces como uma lista de √≠ndices de v√©rtices <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  As faces ser√£o triangulares, haver√° 8, o que significa que a lista de √≠ndices deve conter 24 elementos.  Os √≠ndices de faces v√£o sequencialmente nesta matriz: por exemplo, a face 0 √© formada pelos v√©rtices 0, 1 e 2;  face 1 - v√©rtices 0, 4 e 1;  face 2 - v√©rtices 4, 5 e 1 e assim por diante.  Os v√©rtices s√£o listados no sentido anti-hor√°rio se voc√™ olhar para a face da face (veja a figura acima). <br><br>  Etapas adicionais para criar a geometria que executamos nos exemplos anteriores.  A √∫nica coisa que n√£o fizemos foi a gera√ß√£o autom√°tica de normais suavizados (m√©dia), que realizamos neste exemplo chamando <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  De fato, se os v√©rtices de uma face s√£o dados, √© f√°cil calcular o normal para ela.  Nos v√©rtices em que v√°rias faces convergem, uma certa m√©dia normal √© calculada - as normais das faces convergentes s√£o somadas e a soma resultante √© normalizada novamente.  Essas opera√ß√µes (e muito mais!) Podem ser executadas pelo pr√≥prio mecanismo usando classes da biblioteca osgUtil.  Portanto, em nosso exemplo, adicionaremos uma instru√ß√£o ao vinculador para criar nosso programa com esta biblioteca no arquivo * .pro <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  Como resultado, obtemos o seguinte resultado <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Para entender como isso funciona, considere o pipeline do OpenGL <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  O mecanismo da matriz de v√©rtices reduz o n√∫mero de chamadas do OpenGL.  Ele armazena dados de v√©rtice na mem√≥ria do aplicativo, que √© usada no lado do cliente.  O pipeline do OpenGL no lado do servidor obt√©m acesso a v√°rias matrizes de v√©rtices.  Como mostrado no diagrama, o OpenGL recebe dados do buffer de v√©rtice no lado do cliente e, de maneira ordenada, executa a montagem de primitivas.  √â assim que os dados s√£o processados ‚Äã‚Äãusando os m√©todos set * Array () da classe osg :: Geometry.  A classe osg :: DrawArrays passa por essas matrizes diretamente e as exibe. <br><br>  Ao usar osg :: DrawElements *, a dimens√£o das matrizes de v√©rtices √© reduzida e o n√∫mero de v√©rtices transferidos para o pipeline √© reduzido.  Uma matriz de √≠ndices permite criar um cache de v√©rtices no lado do servidor.  O OpenGL l√™ dados de v√©rtices do cache, em vez de ler a partir do buffer de v√©rtices no lado do cliente.  Isso aumenta significativamente o desempenho geral da renderiza√ß√£o. <br><br><h1>  8. T√©cnicas de processamento de malha poligonal </h1><br>  O OpenSceneGraph suporta v√°rias t√©cnicas para processar a malha poligonal de objetos de geometria de cena.  Esses m√©todos de pr√©-processamento, como redu√ß√£o de pol√≠gono e mosaico, s√£o frequentemente usados ‚Äã‚Äãpara criar e otimizar modelos poligonais.  Eles t√™m uma interface simples, mas, no processo, realizam muitos c√°lculos complexos e n√£o s√£o muito adequados para execu√ß√£o instant√¢nea. <br><br>  As t√©cnicas descritas incluem: <br><br><ol><li>  osgUtil :: Simplifier - reduzindo o n√∫mero de tri√¢ngulos na geometria.  O m√©todo p√∫blico simplify () √© usado para simplificar a geometria do modelo. <br></li><li>  osgUtil :: SmootingVisitor - c√°lculo de normais.  O m√©todo smooth () pode ser usado para gerar normais suavizados para o modelo, em vez de calcul√°-los independentemente e defini-los explicitamente por meio de uma matriz de normais. <br></li><li>  osgUtil :: TangentSpaceGenerator - gera√ß√£o de vetores de base tangente para v√©rtices do modelo.  √â iniciado chamando o m√©todo generate () e salva o resultado retornado pelos m√©todos getTangentArray (), getNormalArray () e getBinormalArray ().  Esses resultados podem ser usados ‚Äã‚Äãpara v√°rios atributos de v√©rtice ao escrever sombreadores no GLSL. <br></li><li>  osgUtil :: Tesselator - executa mosaico de uma malha poligonal - divide primitivas complexas em uma sequ√™ncia de simples (m√©todo retesselatePolygons ()) <br></li><li>  osgUtil :: TriStripVisitor - converte uma superf√≠cie geom√©trica em um conjunto de faixas de faces triangulares, o que permite renderizar com consumo eficiente de mem√≥ria.  O m√©todo stripify () converte um conjunto de primitivas de modelo em geometria com base no conjunto GL_TRIANGLE_STRIP. <br></li></ol><br>  Todos os m√©todos aceitam a geometria do objeto como um par√¢metro passado pelo osg :: Geometry &amp; link, por exemplo, como este <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  onde geom se refere a uma inst√¢ncia da geometria descrita por um ponteiro inteligente. <br><br>  As classes osg :: Simplifier, osg :: SmoothingVisitor e osg :: TriStripVisitor podem trabalhar diretamente com n√≥s no gr√°fico de cena, por exemplo <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  O m√©todo accept () processa todos os n√≥s filhos at√© que a opera√ß√£o especificada seja aplicada a todos os n√≥s terminais desta parte da √°rvore de cenas armazenada nos n√≥s do tipo osg :: Geode. <br><br>  Vamos tentar a t√©cnica do mosaico na pr√°tica. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de exemplo do tesselator completo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Com base na posi√ß√£o espacial dos v√©rtices neste exemplo, √© claro que estamos tentando criar um pol√≠gono n√£o convexo de oito v√©rtices, usando a gera√ß√£o de uma face do tipo GL_POLYGON.  A montagem e execu√ß√£o deste exemplo mostra que o resultado que esperamos n√£o funciona - o exemplo √© exibido incorretamente <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Para corrigir esse problema, a geometria constru√≠da deve ser colocada em mosaico antes de pass√°-la ao visualizador <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  ap√≥s o qual obtemos o resultado correto <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Como isso funciona?  Um pol√≠gono n√£o convexo, sem o uso de mosaico correto, n√£o ser√° exibido como esperamos, pois o OpenGL, buscando otimizar o desempenho, o considerar√° um pol√≠gono simples e convexo ou simplesmente o ignorar√°, o que pode gerar resultados completamente inesperados. <br><br>  A classe osgUtil :: Tessellator usa algoritmos para transformar um pol√≠gono convexo em uma s√©rie de n√£o-convexos - no nosso caso, transforma a geometria em GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br>          .    setWindingType()     ,   GLU_TESS_WINDING_ODD  GLU_TESS_WINDING_NONZERO,        . <br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, obtivemos um entendimento b√°sico de como a geometria de objetos tridimensionais √© armazenada e processada no mecanismo OSG. </font><font style="vertical-align: inherit;">N√£o pense que os exemplos simples e n√£o muito impressionantes considerados no artigo s√£o o limite das capacidades do mecanismo. </font><font style="vertical-align: inherit;">Apenas esses exemplos podem ajudar o desenvolvedor a entender a mec√¢nica do OpenSceneGraph e, sem esse entendimento, √© dif√≠cil imaginar o trabalho de coisas mais complexas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este artigo √© baseado na tradu√ß√£o e processamento do texto dos cap√≠tulos correspondentes do livro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Guia do Iniciante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Todos os exemplos s√£o verificados por mim pessoalmente, e seu c√≥digo fonte est√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispon√≠vel aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para continuar ...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430212/">https://habr.com/ru/post/pt430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430202/index.html">Escrevendo um sistema de part√≠culas que interagem com pares em C ++ usando o DirectX 11</a></li>
<li><a href="../pt430204/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 18: ‚ÄúNavega√ß√£o Privada na Internet‚Äù, Parte 1</a></li>
<li><a href="../pt430206/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 18: Navega√ß√£o Privada na Internet, Parte 2</a></li>
<li><a href="../pt430208/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 18: ‚ÄúNavega√ß√£o Privada na Internet‚Äù, parte 3</a></li>
<li><a href="../pt430210/index.html">Teste minha paci√™ncia pela Academia de Seguran√ßa Check Point</a></li>
<li><a href="../pt430216/index.html">Pelo que entendi, como muitos doces ou a classifica√ß√£o de mercadorias, verificando o aplicativo</a></li>
<li><a href="../pt430218/index.html">Otimiza√ß√£o de energia STM32: um guia pr√°tico</a></li>
<li><a href="../pt430220/index.html">Como transformar um hub USB ‚Äúcenten√°rio‚Äù em um gerenciado de forma inteligente e economizar US $ 300</a></li>
<li><a href="../pt430222/index.html">Engenheiro S√™nior em busca de trabalho. Como passei por 20 entrevistas com RH e o que penso sobre isso</a></li>
<li><a href="../pt430224/index.html">Transtorno esquizot√≠pico: um olhar por dentro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>