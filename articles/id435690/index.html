<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 😞 🎵 [Apa yang salah dengan GraphQL] ... Dan cara menghadapinya 👨‍👨‍👦‍👦 👇🏻 💸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya , kami memeriksa titik-titik yang tidak nyaman dalam sistem tipe GraphQL. 
 Dan sekarang kita akan mencoba untuk mengalahkan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Apa yang salah dengan GraphQL] ... Dan cara menghadapinya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435690/"><p>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , kami memeriksa titik-titik yang tidak nyaman dalam sistem tipe GraphQL. <br>  Dan sekarang kita akan mencoba untuk mengalahkan beberapa dari mereka.  Semua tertarik, tolong, di bawah kucing. </p><a name="habracut"></a><br><p>  Penomoran partisi sesuai dengan masalah yang berhasil saya atasi. </p><br><h3 id="12-non_null-input">  1.2 INPUT NON_NULL </h3><br><p>  Pada titik ini, kami memeriksa ambiguitas yang menghasilkan fitur implementasi nullable di GraphQL. </p><br><p> Dan masalahnya adalah bahwa hal itu tidak memungkinkan untuk menerapkan konsep pembaruan parsial dari awal - analog dari metode HTTP <code>PATCH</code> dalam arsitektur REST.  Dalam komentar tentang materi masa lalu, saya banyak dikritik karena pemikiran "REST".  Saya hanya bisa mengatakan bahwa arsitektur CRUD mengharuskan saya untuk ini.  Dan saya belum siap untuk melepaskan manfaat dari REST, hanya karena "jangan lakukan ini."  Ya, dan solusi untuk masalah ini ditemukan. </p><br><p>  Jadi, kembali ke masalahnya.  Seperti yang kita semua tahu, skrip CRUD saat memperbarui catatan terlihat seperti ini: </p><br><ol><li>  Punya catatan dari belakang. </li><li>  Bidang rekaman yang diedit. </li><li>  Mengirim catatan ke belakang. </li></ol><br><p>  Konsep pembaruan parsial, dalam hal ini, harus memungkinkan kami untuk mengirim kembali hanya bidang-bidang yang telah diubah. <br>  Jadi, jika kita mendefinisikan model input dengan cara ini </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">input</span></span> ExampleInput { foo: String! bar: <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> }</code> </pre> <br><p>  lalu ketika memetakan variabel tipe <code>ExampleInput</code> dengan nilai ini </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"foo"</span></span>: <span class="hljs-string"><span class="hljs-string">"bla-bla-bla"</span></span> }</code> </pre> <br><p>  pada DTO dengan struktur ini: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">ExampleDTO</span></span> { foo: <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> <span class="hljs-comment"><span class="hljs-comment">#   bar: ?String #   }</span></span></code> </pre> <br><p>  kami mendapatkan objek DTO dengan nilai ini: </p><br><pre> <code class="plaintext hljs">{ foo: "bla-bla-bla", bar: null }</code> </pre> <br><p>  dan saat memetakan variabel dengan nilai ini </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"foo"</span></span>: <span class="hljs-string"><span class="hljs-string">"bla-bla-bla"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bar"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  kami mendapatkan objek DTO dengan nilai yang sama seperti terakhir kali: </p><br><pre> <code class="plaintext hljs">{ foo: "bla-bla-bla", bar: null }</code> </pre> <br><p>  Yaitu, terjadi entropi - kami kehilangan informasi tentang apakah bidang ditransmisikan dari klien atau tidak. <br>  Dalam kasus ini, tidak jelas apa yang perlu dilakukan dengan bidang objek akhir: jangan menyentuhnya karena klien tidak lulus bidang, atau mengaturnya ke <code>null</code> karena klien lulus <code>null</code> . </p><br><p>  Sebenarnya, GraphQL adalah protokol RPC.  Dan saya mulai memikirkan bagaimana saya melakukan hal-hal seperti itu di belakang dan prosedur apa yang harus saya panggil untuk melakukan persis seperti yang saya inginkan.  Dan di backend, saya melakukan pembaruan parsial bidang seperti ini: </p><br><pre> <code class="php hljs">$repository-&gt;find(<span class="hljs-number"><span class="hljs-number">42</span></span>)-&gt;setFoo(<span class="hljs-string"><span class="hljs-string">'bla-bla-lba'</span></span>);</code> </pre> <br><p>  Artinya, saya benar-benar tidak menyentuh setter properti entitas, kecuali saya perlu mengubah nilai properti ini.  Jika Anda menggeser ini ke skema GraphQL, Anda mendapatkan hasil berikut: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Mutation { entityRepository: EntityManager! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> EntityManager { update(id: ID!): <span class="hljs-attribute"><span class="hljs-attribute">PersitedEntity</span></span> } type PersitedEntity { setFoo(foo: String!): String! setBar(foo: String): <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> }</code> </pre> <br><p>  Sekarang, jika kita mau, kita bisa memanggil metode <code>setBar</code> , dan mengatur nilainya ke nol, atau tidak menyentuh metode ini, dan kemudian nilainya tidak akan berubah.  Dengan demikian, implementasi <code>partial update</code> bagus keluar.  Tidak lebih buruk dari <code>PATCH</code> dari REST yang terkenal. </p><br><blockquote>  Dalam komentar tentang materi sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">summerwind</a> bertanya: mengapa kita perlu <code>partial update</code> ?  Saya menjawab: ada bidang yang SANGAT besar. </blockquote><br><h1 id="3-polimorfizm">  3. Polimorfisme </h1><br><p>  Sering terjadi bahwa Anda perlu tunduk pada entitas input yang agak "satu dan sama" tetapi tidak cukup.  Saya akan menggunakan contoh membuat akun dari materi sebelumnya. </p><br><pre> <code class="lua hljs">#   AccountInput { login: <span class="hljs-string"><span class="hljs-string">"Acme"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"***"</span></span>, subject: OrganiationInput { title: <span class="hljs-string"><span class="hljs-string">"Acme Inc"</span></span> } }</code> </pre> <br><pre> <code class="lua hljs">#    AccountInput { login: <span class="hljs-string"><span class="hljs-string">"Acme"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"***"</span></span>, subject: PersonInput { firstName: <span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">"Pupkin"</span></span>, } }</code> </pre> <br><p>  Jelas, kami tidak dapat mengirimkan data dengan struktur seperti itu untuk satu argumen - GraphQL tidak akan mengizinkan kami melakukan ini.  Jadi, Anda harus menyelesaikan masalah ini. </p><br><p>  <strong>Metode 0 - dahi</strong> </p><br><p>  Hal pertama yang terlintas dalam pikiran adalah pemisahan bagian variabel dari input: </p><br><pre> <code class="plaintext hljs">input AccountInput { login: String! password: Password! subjectOrganization: OrganiationInput subjectPerson: PersonInput }</code> </pre> <br><p>  Hmm ... ketika saya melihat kode seperti itu, saya sering mengingat Josephine Pavlovna.  Itu tidak cocok untukku. </p><br><p>  <strong>Metode 1 - tidak di dahi, tetapi di dahi</strong> <br>  Kemudian fakta datang ke bantuan saya bahwa untuk mengidentifikasi entitas, saya menggunakan saya menggunakan UUID (umumnya saya merekomendasikannya kepada semua orang - itu akan membantu lebih dari sekali).  Dan ini berarti bahwa saya dapat membuat entitas yang valid secara langsung pada klien, mengikatnya bersama dengan pengidentifikasi, dan mengirimkannya ke back-end secara terpisah. </p><br><p>  Maka kita dapat melakukan sesuatu dalam semangat: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">input</span></span> AccountInput { login: String! password: Password! subject: SubjectSelectInput! } <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> SubjectSelectInput { id: ID! } <span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Mutation { createAccount( organization: OrganizationInput, person: PersonInput, account: AccountInput! ): Account! }</code> </pre> <br><p>  atau, yang ternyata lebih nyaman (mengapa lebih nyaman, saya akan memberi tahu Anda ketika kita sampai pada generasi antarmuka pengguna), membaginya menjadi metode yang berbeda: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> Mutation { createAccount(account: AccountInput!): Account! createOrganization(organization: OrganizationInput!): Organization! createPerson(person: PersonInput!) : Person! }</code> </pre> <br><p>  Kemudian, kita perlu mengirim permintaan untuk membuat Akun dan membuat Organisasi / membuat Orang <br>  satu batch.  Perlu dicatat bahwa pemrosesan batch harus dibungkus dalam suatu transaksi. </p><br><p>  <strong>Metode 2 - skalar ajaib</strong> <br>  Caranya adalah skalar di GraphQL tidak hanya <code>Int</code> , <code>Sting</code> , <code>Float</code> , dll.  Ini umumnya apa saja (well, sementara JSON dapat menangani ini, tentu saja). <br>  Maka kita bisa mendeklarasikan skalar: </p><br><pre> <code class="plaintext hljs">scalar SubjectInput</code> </pre> <br><p>  Lalu, tulis pawang Anda di situ, dan itu tidak dikukus.  Kemudian kita dapat dengan mudah memasukkan bidang variabel ke input. </p><br><p>  Cara mana yang harus dipilih?  Saya menggunakan keduanya, dan telah mengembangkan aturan untuk diri saya sendiri: <br>  Jika entitas induk adalah Root Agregat untuk anak, maka saya memilih metode kedua, jika tidak, yang pertama. </p><br><h2 id="4-dzheneriki">  4. Generik. </h2><br><p>  Semuanya sepele di sini dan saya tidak menghasilkan sesuatu yang lebih baik daripada pembuatan kode.  Dan tanpa Rails (paket railt / sdl) saya tidak akan bisa (atau lebih tepatnya, saya akan melakukan hal yang sama dengan kruk).  Kuncinya adalah bahwa Rail memungkinkan Anda untuk menentukan arahan tingkat dokumen (tidak ada posisi untuk arahan dalam lembar spesifikasi). </p><br><pre> <code class="plaintext hljs">directive @example on DOCUMENT</code> </pre> <br><p>  Artinya, arahan tidak dilampirkan pada apa pun selain dokumen di mana mereka dipanggil. </p><br><p>  Saya memperkenalkan arahan berikut: </p><br><pre> <code class="plaintext hljs">directive @defineMacro(name: String!, template: String!) on DOCUMENT directive @macro(name: String!, arguments: [String]) on DOCUMENT</code> </pre> <br><p>  Saya pikir tidak ada yang perlu menjelaskan esensi makro ... </p><br><p>  Itu saja untuk saat ini.  Saya tidak berpikir bahwa materi ini akan menyebabkan suara sebanyak masa lalu.  Semua sama, judul di sana cukup "kuning") </p><br><p>  Dalam komentar di artikel sebelumnya, warga Khabrovsk tenggelam karena berbagi akses ... sehingga artikel selanjutnya adalah tentang otorisasi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435690/">https://habr.com/ru/post/id435690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435680/index.html">AWS menunjukkan jari tengah open source</a></li>
<li><a href="../id435682/index.html">Ulasan Printer Pembuat Kopi Cafe</a></li>
<li><a href="../id435684/index.html">Oak Ridge National Laboratory telah memecahkan masalah utama pengembang perangkat luar angkasa: kekurangan plutonium-238</a></li>
<li><a href="../id435686/index.html">Pavel Durov melikuidasi Telegram Messenger LLP</a></li>
<li><a href="../id435688/index.html">Contoh Aplikasi Server Klien Berkibar</a></li>
<li><a href="../id435692/index.html">Y Combinator: "Pada awalnya, beberapa perusahaan teknologi terbesar terlihat seperti mainan"</a></li>
<li><a href="../id435694/index.html">Bagaimana dan mengapa kami mengoptimalkan algoritma untuk membersihkan cache SLAB di kernel Linux</a></li>
<li><a href="../id435696/index.html">Antiquities: 1997 Computer Advertising</a></li>
<li><a href="../id435698/index.html">Menulis manajer memori Anda sendiri yang baik</a></li>
<li><a href="../id435700/index.html">8 Pertanyaan Wawancara Vue.js Terburuk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>