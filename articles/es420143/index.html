<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎿 👼 🤐 Rendimiento de Kotlin en Android 🧒🏾 🥨 🧝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hablemos hoy sobre el rendimiento de Kotlin en Android en producción. Veamos debajo del capó, implemente optimizaciones difíciles, compare el código d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendimiento de Kotlin en Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Hablemos hoy sobre el rendimiento de Kotlin en Android en producción.  Veamos debajo del capó, implemente optimizaciones difíciles, compare el código de bytes.  Finalmente, abordaremos seriamente la comparación y mediremos los puntos de referencia. <br><br>  Este artículo se basa en un informe de <strong>Alexander Smirnov</strong> en AppsConf 2017 y ayudará a determinar si es posible escribir código en Kotlin, que no será inferior a Java en velocidad. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Alexander Smirnov CTO en PapaJobs, dirige el video blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android en Faces</a> , y también es uno de los organizadores de la comunidad Mosdroid. <br><a name="habracut"></a><br>  Comencemos con sus expectativas. <br><br><blockquote>  ¿Crees que Kotlin en tiempo de ejecución es más lento que Java?  O mas rapido?  ¿O tal vez no hay mucha diferencia?  Después de todo, ambos trabajan en el código de bytes que nos proporciona la máquina virtual. </blockquote><br>  Vamos a hacerlo bien.  Tradicionalmente, cuando surge la cuestión de comparar el rendimiento, todos quieren ver puntos de referencia y números específicos.  Desafortunadamente, para Android no hay JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Microbenchmark Harness</a> ), por lo que no podemos medir cuán genial se puede hacer en Java.  Entonces, ¿qué podemos hacer para hacer la medición, como se describe a continuación? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Si alguna vez intentas medir tu código de esta manera, uno de los desarrolladores de JMH estará triste, llorará y vendrá a ti en un sueño, nunca lo hagas. <br><br>  En Android, puede hacer puntos de referencia, en particular, Google demostró esto en la E / S del año pasado.  Dijeron que mejoraron enormemente la máquina virtual, en este caso ART, y si en Android 4.1 una asignación de un objeto tomaba entre 600 y 700 nanosegundos, en la octava versión tardaría unos 60 nanosegundos.  Es decir  pudieron medirlo con tanta precisión en una máquina virtual.  Por qué no podemos hacer tampoco: no tenemos tales herramientas. <br><br>  Si miramos toda la documentación, lo único que podemos encontrar es la recomendación anterior, cómo medir la IU: <br><br>  <strong>adb shell dumpsys gfxinfo% nombre_paquete%</strong> <br><br>  En realidad, hagámoslo de esta manera y veamos al final lo que dará.  Pero primero, determinaremos qué mediremos y qué más podemos hacer. <br><br><blockquote>  La siguiente pregunta.  ¿Dónde crees que el rendimiento es importante cuando creas una aplicación de primera clase? <br><br><ol><li>  Definitivamente en todas partes. </li><li>  UI Hilo. </li><li>  Vista personalizada + animaciones. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  Lo que más me gusta es la primera opción, pero lo más probable es que se crea que es imposible hacer que todo el código funcione muy, muy rápidamente y es importante que al menos no haya UiThread o una vista personalizada.  También estoy de acuerdo con esto: es muy, muy importante.  El hecho de que en su secuencia JSON separada se deserialice durante 10 milisegundos más, nadie se dará cuenta. <br><br>  La psicología de la Gestalt dice que cuando parpadeamos, durante unos 150-300 milisegundos, el ojo humano está fuera de foco y no ve lo que realmente está sucediendo allí.  Y luego estos 10 milisegundos de clima no.  Pero si volvemos a la psicología gestalt, es importante no lo que realmente veo y lo que realmente sucede, pero lo que entiendo como usuario es importante. <br><br>  Es decir  Si hacemos que el usuario piense que lo tiene todo muy, muy rápido, pero de hecho simplemente será golpeado maravillosamente, por ejemplo, con la ayuda de una hermosa animación, entonces estará satisfecho, incluso si de hecho no lo es. <br><br>  Los motivos de psicología de la Gestalt en iOS se han estado moviendo durante bastante tiempo.  Por lo tanto, si toma dos aplicaciones con el mismo tiempo de procesamiento, pero en plataformas diferentes, y las pone lado a lado, parecerá que en iOS todo es más rápido.  La animación en iOS se procesa un poco más rápido, la animación anterior comienza en el inicio y muchas otras animaciones, por lo que es hermosa. <br><br>  Entonces, la <strong>primera regla es pensar en el usuario.</strong> <br><br>  Y para la segunda regla, debes sumergirte en el hardcore. <br><br><h2>  ESTILO KOTLIN <br></h2><br>  Para evaluar honestamente el rendimiento de Kotlin, lo compararemos con Java.  Por lo tanto, resulta que es imposible medir algunas cosas que solo están en Kotlin, por ejemplo: <br><br><ul><li>  Colección Api. </li><li>  Parámetros predeterminados del método. </li><li>  Clases de datos. </li><li>  Tipos reificados. </li><li>  Corutinas </li></ul><br>  <strong>La API de colección</strong> que nos proporciona Kotlin es muy buena, muy rápida.  En Java, esto simplemente no existe, solo hay diferentes implementaciones.  Por ejemplo, la biblioteca Liteweight Stream API será más lenta porque hace todo lo mismo que Kotlin, pero con una o dos asignaciones adicionales a la operación, ya que todo se convierte en un objeto adicional. <br><br>  Si tomamos la API de Stream de Java 8, funcionará más lentamente que la API de Kotlin Collection, pero con una condición: no hay tal parálisis en la API de Collection como en Java 8. Si habilitamos paralelo, en grandes cantidades de datos, la API de Stream en Java omitirá la API de Kotlin Collection.  Por lo tanto, no podemos comparar tales cosas, porque llevamos a cabo la comparación precisamente desde el punto de vista de Android. <br><br>  La segunda cosa, que me parece que no se puede comparar, son <strong>los parámetros predeterminados del Método</strong> , una característica muy interesante que, por cierto, está en Dart.  Cuando llama a algún método, puede tener algunos parámetros que pueden tener algún valor, pero pueden ser NULL.  Y por lo tanto, no crea 10 métodos diferentes, sino que hace un método y dice que uno de los parámetros puede ser NULL, y en el futuro lo usará sin ningún parámetro.  Es decir  él mirará, el parámetro ha llegado o no ha venido.  Es muy conveniente porque puede escribir mucho menos código, pero el inconveniente es que tiene que pagar por ello.  Este es el azúcar sintáctico: usted, como desarrollador, cree que este es un método API, pero en realidad, debajo del capó, cada variación del método con parámetros faltantes se genera en el código de bytes.  Y cada uno de estos métodos también verifica poco a poco si este parámetro ha llegado.  Si llegó, entonces está bien, si no fue así, entonces creamos una máscara de bits, y dependiendo de esta máscara de bits, el método original que escribió se llama realmente.  Operaciones bit a bit, todo <em>si / de lo contrario</em> cuesta un poco de dinero, pero muy poco, y es normal que tenga que pagar por conveniencia.  Me parece que esto es absolutamente normal. <br><br>  El siguiente elemento que no se puede comparar son las <strong>clases de datos</strong> . <br><br>  Todos lloran que en Java hay parámetros para los que hay clases de modelo.  Es decir  toma parámetros y realiza más métodos, captadores y establecedores para todos estos parámetros.  Resulta que para una clase con diez parámetros, todavía necesita un conjunto completo de captadores, setters y un montón más.  Además, si no usa generadores, entonces tiene que escribir con las manos, lo que generalmente es terrible. <br><br>  Kotlin te permite alejarte de todo.  Primero, dado que hay propiedades en Kotlin, no necesita escribir getters y setters.  No tiene <strong>parámetros de clase, todas las propiedades</strong> .  En cualquier caso, creemos que sí.  En segundo lugar, si escribe que se trata de clases de datos, se generará un montón de todo lo demás.  Por ejemplo, equals (), toStrung () / hasCode (), etc. <br><br>  Por supuesto, esto también tiene inconvenientes.  Por ejemplo, no necesitaba comparar todos los 20 parámetros de mis clases de datos a la vez en mis iguales (), solo necesitaba comparar 3. A alguien no le gusta todo esto porque el rendimiento se pierde en esto y, además, se genera mucho funciones de servicio, y el código compilado es bastante voluminoso.  Es decir, si escribe todo a mano, habrá menos código que si usa clases de datos. <br><br>  No uso clases de datos por otro motivo.  Anteriormente, había restricciones en la expansión de tales clases y algo más.  Ahora todos están mejor con esto, pero el hábito permanece. <br><br>  ¿Qué es muy, muy bueno en Kotlin, y qué será siempre más rápido que Java?  Se trata de <strong>tipos Reified</strong> , que, por cierto, también está en Dart. <br><br>  Sabes que cuando usas genéricos, el borrado de tipo se borra en la etapa de compilación y en tiempo de ejecución ya no sabes qué objeto de este genérico se usa realmente. <br><br>  Con los tipos Reified, no necesita usar la reflexión en muchos lugares, cuando en Java lo necesitaría, porque con los métodos en línea es con Reified que conoce el tipo y, por lo tanto, resulta que no usa la reflexión y su código funciona más rápido.  La magia <br><br>  Y hay <strong>corutinas</strong> .  Son geniales, me gustan mucho, pero en el momento de la presentación se incluyeron solo en la versión alfa, por lo que no fue posible hacer comparaciones correctas con ellos. <br><br><h2>  CAMPOS <br></h2><br>  Así que vamos adelante, pasemos a lo que podemos comparar con Java y a lo que podemos influir en general. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Como dije, no tenemos parámetros para la clase, tenemos propiedades. <br><br>  Tenemos var, tenemos val, tenemos una clase externa, una de las propiedades de las cuales es @JvmField, y veremos qué sucede realmente con la función work (): sumamos el valor del campo a y el campo b de nuestra propia clase y valores del campo a y el campo b de la clase externa, que se escribe en el campo inmutable c. <br><br>  La pregunta es qué, de hecho, se llamará en d = a + b.  Todos sabemos que esta propiedad una vez, se llamará al captador de esta clase para este parámetro. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Pero si miramos el código de bytes, veremos que realmente se está accediendo a getfield.  Es decir, esto en el bytecode no es una llamada a la función InvokeVirtual, sino un acceso directo al campo.  No hay nada que se nos prometió inicialmente, que tenemos todas las propiedades, no los campos.  Resulta que Kotlin nos está engañando, hay un atractivo directo. <br><br>  ¿Qué sucede si vemos qué bytecode se genera para otra línea: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Anteriormente, si estaba accediendo a una propiedad privada, siempre tenía una llamada InvokeVirtual.  Si se trataba de una propiedad privada, el acceso a ella se realizó a través de GetField.  GetField es mucho más rápido que InvokeVirtual, la especificación de Android afirma que acceder a un campo directamente es de 3 a 7 veces más rápido.  Por lo tanto, se recomienda que siempre se refiera a Field, y no a través de getters o setters.  Ahora, especialmente en la octava máquina virtual ART, ya habrá números diferentes, pero si aún es compatible con 4.1, esto será cierto. <br><br>  Por lo tanto, resulta que todavía es beneficioso para nosotros tener GetField, y no InvokeVirtual. <br><br>  Ahora, puede obtener GetField si está accediendo a una propiedad de su propia clase, o si esta es una propiedad pública, debe establecer @JvmField.  Entonces, exactamente lo mismo en el bytecode será una llamada GetField, que es 3 a 7 veces más rápida. <br><br>  Está claro que aquí hablamos en nanosegundos y, con un trono, es muy, muy pequeño.  Pero, por otro lado, si lo hace en el hilo de la interfaz de usuario, por ejemplo, en el método ondraw accede a algún tipo de vista, esto afectará la representación de cada cuadro, y puede hacerlo un poco más rápido. <br><br>  <strong>Si sumamos todas las optimizaciones, en resumen, puede dar algo.</strong> <br><br><h2>  ¿ESTÁTICA? <br></h2><br>  ¿Qué pasa con la estática?  Todos sabemos que en Kotlin, la estática es un objeto complementario.  Anteriormente, probablemente haya agregado algún tipo de etiqueta, por ejemplo, estática pública, estática final, etc., si convierte esto al código de Kotlin, obtendrá un objeto complementario, que escribirá algo como lo siguiente: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  ¿Crees que esta entrada es idéntica a la declaración final estática estándar en Java?  ¿Es estático o no? </blockquote><br>  Sí, de hecho, Kotlin declara que aquí está en Kotlin: estático, ese objeto dice que es estático.  En realidad, esto no es estático. <br><br>  Si observamos el bytecode generado, veremos lo siguiente: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Se genera un Test.Companion; un objeto singleton para el que se crea la instancia, esta instancia se escribe en su propio campo.  Después de eso, el acceso a uno de los objetos complementarios se produce a través de este objeto.  Toma getstatic, es decir, una instancia estática de esta clase, e invoca la función getK invokevirtual en ella, y exactamente lo mismo para la función work2.  Entonces entendemos que no es estático. <br><br>  Esto es importante, porque en las JVM más antiguas, la invookestatic era aproximadamente un 30% más rápida que la invokevirtual.  Ahora, por supuesto, en HotSpot, la virtualización optimizada se está volviendo realmente genial, y es casi invisible.  Sin embargo, debe tener esto en cuenta, especialmente porque hay una asignación adicional y una ubicación adicional en 4ST1 es de 700 nanosegundos, demasiado. <br><br>  Echemos un vistazo al código Java que sale si implementa el código de bytes de forma inversa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Se crea un campo estático, se crea una implementación final estática del objeto Companion, se crean captadores y establecedores y, como puede ver, haciendo referencia al campo estático en el interior, aparece un método estático adicional.  Todo es lo suficientemente triste. <br><br>  ¿Qué podemos hacer para asegurarnos de que no sea estático?  Podemos intentar agregar @JvmField y @JvmStatic y ver qué sucede. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Diré de inmediato que no se alejará de @JvmStatic, será el mismo objeto, ya que este es un objeto complementario, habrá una asignación adicional de este objeto y habrá una llamada adicional. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Pero la llamada cambiará solo para k, porque será @JvmField, se tomará directamente como getstatic, ya no se generarán getters y setters.  Pero para la función work2 nada cambiará. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  La segunda opción sobre cómo crear estática se propone en la documentación de Kotlin, por lo que se dice que solo podemos crear un objeto, y este será un código estático. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  En realidad, esto tampoco es así. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Resulta que hacemos una llamada de instancia getstatic desde singletone, que se crea, y llamamos exactamente los mismos métodos virtuales. <br><br>  La única forma en que podemos lograr invokestatic es Funciones de orden superior.  Cuando simplemente escribimos alguna función fuera de la clase, por ejemplo, fun test2 se llamará realmente como static. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Además, lo más interesante es que se creará una clase, un objeto, en este caso testKt, generará un objeto para sí mismo, generará una función que se pone en este objeto, y ahora se llamará como invocatático. <br><br>  Por qué se hizo esto es incomprensible.  Muchos no están contentos con esto, pero hay quienes consideran que tal implementación es bastante normal.  Desde la máquina virtual, incl.  El arte está mejorando, ahora no es tan crítico.  En la octava versión de Android, al igual que en HotSpot, todo está optimizado, pero estas pequeñas cosas afectan ligeramente el rendimiento general. <br><br><h2>  NULABILIDAD <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Este es el siguiente ejemplo interesante.  Parece que notamos que el segundo puede ser anulable, y debe verificarse antes de hacer algo con él.  En este caso, espero que tengamos uno si.  Cuando este código se implementa si el segundo no es igual a cero, entonces creo que la ejecución irá más allá y solo se generará primero. <br><br>  ¿Cómo se desarrolla todo esto en el código Java?  En realidad habrá un cheque. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Obtendremos Intrinsics inicialmente.  Digamos que yo digo que este <br><br>  Si se expandirá en un operador ternario.  Pero además de esto, aunque incluso arreglamos que el primer parámetro no puede ser anulable, aún se verificará a través de Intrinsics. <br><br>  Intrinsics es una clase interna en Kotlin que tiene un cierto conjunto de parámetros y verificaciones.  Y cada vez que hace que el parámetro del método no sea anulable, lo verifica de todos modos.  Por qué  Entonces, que trabajamos en Interop Java, y puede suceder que espere que no sea anulable aquí, pero con Java vendrá de algún lado. <br><br>  Si marca esto, irá más allá en el código, y luego, después de 10-20 llamadas al método, hará algo con un parámetro que, aunque puede no ser anulable, pero por alguna razón resultó ser.  Todo se enamorará de ti y no podrás entender lo que realmente sucedió.  Para evitar esta situación, cada vez que pase el parámetro nulo, aún tendrá que verificarlo.  Y si es anulable, habrá una excepción. <br><br>  Este cheque también vale algo, y si hay muchos de ellos, entonces no será muy bueno. <br><br>  Pero, de hecho, si hablamos de HotSpot, 10 llamadas de estos Intrínsecos tomarán alrededor de cuatro nanosegundos.  Esto es muy, muy pequeño, y no debe preocuparse por esto, pero este es un factor interesante. <br><br><h2>  Primitivas <br></h2><br>  En Java existen los primitivos.  En Kotlin, como todos sabemos, no hay primitivas, siempre operamos con objetos.  En Java, se utilizan para proporcionar un mayor rendimiento para los objetos en algunos cálculos menores.  Agregar dos objetos es mucho más costoso que agregar dos primitivas.  Considera un ejemplo. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Hay tres números, para los dos primeros se deducirá el tipo no nulo, y alrededor del tercero decimos que puede ser anulable. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Si observa el código de bytes y ve qué código Java se genera, los dos primeros números no son nulos y, por lo tanto, pueden ser primitivos.  Pero la primitiva no puede contener Nulo, solo un objeto puede hacer esto, por lo que se generará un objeto para el tercer número. <br><br><h2>  AUTOBOXING <br></h2><br>  Cuando trabaje con primitivas y realice una operación con primitivas y no primitivas, necesitará traducir una de ellas en una primitiva o en un objeto. <br><br>  Y, al parecer, no es sorprendente que si realiza operaciones con nullable y no nullable en Kotlin, pierda un poco de rendimiento.  Además, si hay muchas operaciones de este tipo, entonces pierde mucho. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  ¿Ves dónde estará aquí el boxeo / unboxing?  Tampoco vi hasta que miré el bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  En realidad, esperaba que hubiera algo como esta comparación: si la cadena no es nula y está vacía, se establece en verdadero, de lo contrario se establece en falso.  Todo parece ser simple, pero en realidad se genera el siguiente código: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Miremos adentro.  Se toma la variable <em>a</em> , se emite en CharSequence, después de que se ha echado, que también se ha gastado durante algún tiempo, se llama otra verificación - StringsKt.isBlank - así es como se escribe la función de extensión para CharSequence, por lo que se emite y se envía.  Como la primera expresión puede ser anulable, la toma y hace Boxeo, y la envuelve todo en Boolean.valueOf.  Por lo tanto, la primitiva verdadera también se convierte en un objeto, y solo después de eso, la verificación ya tiene lugar y se llama a Intrinsics.areEqual. <br><br>  Parecería una operación tan simple, pero un resultado tan inesperado.  De hecho, hay muy pocas de esas cosas.  Pero cuando puede tener nullable / no nullable, puede generar muchas de esas cosas, y una que nunca hubiera esperado.  Por lo tanto, le recomiendo que se aleje de la oscuridad lo antes posible.  Es decir  <strong>llegue a la inmunidad de los valores lo antes posible y aléjese de los valores nulables</strong> para que no opere nulo lo más rápido posible. <br><br><h2>  Bucles <br></h2><br>  La próxima cosa interesante. <br><br>  Puede usar el usual for, que está en Java, pero también puede usar la nueva API conveniente: escriba la enumeración de elementos en la lista de inmediato. ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     —   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   «»,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        −1,  until ,   ,    .   ,    ,    ranges.  Es decir   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    —   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   — Xno-param-assertions —    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  — ,     .     ,    ,    0,04 . ,  ,        —   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  —   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   — . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420143/">https://habr.com/ru/post/es420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420131/index.html">Método de minería probabilístico de Bitcoin</a></li>
<li><a href="../es420133/index.html">Modelado de sistemas dinámicos: ¿cómo se mueve la luna?</a></li>
<li><a href="../es420135/index.html">Esto también es Toshiba: productos inesperados de la corporación japonesa</a></li>
<li><a href="../es420139/index.html">Libro "Ingeniería de confiabilidad del sitio. Fiabilidad y fiabilidad como en Google »</a></li>
<li><a href="../es420141/index.html">Desde el MPP DBMS cargado - Data Lake lleno de vida con herramientas analíticas: comparta los detalles de la creación</a></li>
<li><a href="../es420145/index.html">¿Cómo es el día de trabajo de los miembros de PC AppsConf?</a></li>
<li><a href="../es420147/index.html">OpenSource en Clojure</a></li>
<li><a href="../es420151/index.html">Más fácil de lo que parece. Capítulo 12</a></li>
<li><a href="../es420153/index.html">Impresión 3D de piezas complejas hechas de ABS y PLA con mucho soporte</a></li>
<li><a href="../es420155/index.html">Intel Datacenter SSD. Grandes volúmenes y nuevos nombres.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>