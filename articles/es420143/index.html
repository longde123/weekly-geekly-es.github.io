<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéø üëº ü§ê Rendimiento de Kotlin en Android üßíüèæ ü•® üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hablemos hoy sobre el rendimiento de Kotlin en Android en producci√≥n. Veamos debajo del cap√≥, implemente optimizaciones dif√≠ciles, compare el c√≥digo d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendimiento de Kotlin en Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Hablemos hoy sobre el rendimiento de Kotlin en Android en producci√≥n.  Veamos debajo del cap√≥, implemente optimizaciones dif√≠ciles, compare el c√≥digo de bytes.  Finalmente, abordaremos seriamente la comparaci√≥n y mediremos los puntos de referencia. <br><br>  Este art√≠culo se basa en un informe de <strong>Alexander Smirnov</strong> en AppsConf 2017 y ayudar√° a determinar si es posible escribir c√≥digo en Kotlin, que no ser√° inferior a Java en velocidad. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Alexander Smirnov CTO en PapaJobs, dirige el video blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android en Faces</a> , y tambi√©n es uno de los organizadores de la comunidad Mosdroid. <br><a name="habracut"></a><br>  Comencemos con sus expectativas. <br><br><blockquote>  ¬øCrees que Kotlin en tiempo de ejecuci√≥n es m√°s lento que Java?  O mas rapido?  ¬øO tal vez no hay mucha diferencia?  Despu√©s de todo, ambos trabajan en el c√≥digo de bytes que nos proporciona la m√°quina virtual. </blockquote><br>  Vamos a hacerlo bien.  Tradicionalmente, cuando surge la cuesti√≥n de comparar el rendimiento, todos quieren ver puntos de referencia y n√∫meros espec√≠ficos.  Desafortunadamente, para Android no hay JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Microbenchmark Harness</a> ), por lo que no podemos medir cu√°n genial se puede hacer en Java.  Entonces, ¬øqu√© podemos hacer para hacer la medici√≥n, como se describe a continuaci√≥n? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Si alguna vez intentas medir tu c√≥digo de esta manera, uno de los desarrolladores de JMH estar√° triste, llorar√° y vendr√° a ti en un sue√±o, nunca lo hagas. <br><br>  En Android, puede hacer puntos de referencia, en particular, Google demostr√≥ esto en la E / S del a√±o pasado.  Dijeron que mejoraron enormemente la m√°quina virtual, en este caso ART, y si en Android 4.1 una asignaci√≥n de un objeto tomaba entre 600 y 700 nanosegundos, en la octava versi√≥n tardar√≠a unos 60 nanosegundos.  Es decir  pudieron medirlo con tanta precisi√≥n en una m√°quina virtual.  Por qu√© no podemos hacer tampoco: no tenemos tales herramientas. <br><br>  Si miramos toda la documentaci√≥n, lo √∫nico que podemos encontrar es la recomendaci√≥n anterior, c√≥mo medir la IU: <br><br>  <strong>adb shell dumpsys gfxinfo% nombre_paquete%</strong> <br><br>  En realidad, hag√°moslo de esta manera y veamos al final lo que dar√°.  Pero primero, determinaremos qu√© mediremos y qu√© m√°s podemos hacer. <br><br><blockquote>  La siguiente pregunta.  ¬øD√≥nde crees que el rendimiento es importante cuando creas una aplicaci√≥n de primera clase? <br><br><ol><li>  Definitivamente en todas partes. </li><li>  UI Hilo. </li><li>  Vista personalizada + animaciones. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  Lo que m√°s me gusta es la primera opci√≥n, pero lo m√°s probable es que se crea que es imposible hacer que todo el c√≥digo funcione muy, muy r√°pidamente y es importante que al menos no haya UiThread o una vista personalizada.  Tambi√©n estoy de acuerdo con esto: es muy, muy importante.  El hecho de que en su secuencia JSON separada se deserialice durante 10 milisegundos m√°s, nadie se dar√° cuenta. <br><br>  La psicolog√≠a de la Gestalt dice que cuando parpadeamos, durante unos 150-300 milisegundos, el ojo humano est√° fuera de foco y no ve lo que realmente est√° sucediendo all√≠.  Y luego estos 10 milisegundos de clima no.  Pero si volvemos a la psicolog√≠a gestalt, es importante no lo que realmente veo y lo que realmente sucede, pero lo que entiendo como usuario es importante. <br><br>  Es decir  Si hacemos que el usuario piense que lo tiene todo muy, muy r√°pido, pero de hecho simplemente ser√° golpeado maravillosamente, por ejemplo, con la ayuda de una hermosa animaci√≥n, entonces estar√° satisfecho, incluso si de hecho no lo es. <br><br>  Los motivos de psicolog√≠a de la Gestalt en iOS se han estado moviendo durante bastante tiempo.  Por lo tanto, si toma dos aplicaciones con el mismo tiempo de procesamiento, pero en plataformas diferentes, y las pone lado a lado, parecer√° que en iOS todo es m√°s r√°pido.  La animaci√≥n en iOS se procesa un poco m√°s r√°pido, la animaci√≥n anterior comienza en el inicio y muchas otras animaciones, por lo que es hermosa. <br><br>  Entonces, la <strong>primera regla es pensar en el usuario.</strong> <br><br>  Y para la segunda regla, debes sumergirte en el hardcore. <br><br><h2>  ESTILO KOTLIN <br></h2><br>  Para evaluar honestamente el rendimiento de Kotlin, lo compararemos con Java.  Por lo tanto, resulta que es imposible medir algunas cosas que solo est√°n en Kotlin, por ejemplo: <br><br><ul><li>  Colecci√≥n Api. </li><li>  Par√°metros predeterminados del m√©todo. </li><li>  Clases de datos. </li><li>  Tipos reificados. </li><li>  Corutinas </li></ul><br>  <strong>La API de colecci√≥n</strong> que nos proporciona Kotlin es muy buena, muy r√°pida.  En Java, esto simplemente no existe, solo hay diferentes implementaciones.  Por ejemplo, la biblioteca Liteweight Stream API ser√° m√°s lenta porque hace todo lo mismo que Kotlin, pero con una o dos asignaciones adicionales a la operaci√≥n, ya que todo se convierte en un objeto adicional. <br><br>  Si tomamos la API de Stream de Java 8, funcionar√° m√°s lentamente que la API de Kotlin Collection, pero con una condici√≥n: no hay tal par√°lisis en la API de Collection como en Java 8. Si habilitamos paralelo, en grandes cantidades de datos, la API de Stream en Java omitir√° la API de Kotlin Collection.  Por lo tanto, no podemos comparar tales cosas, porque llevamos a cabo la comparaci√≥n precisamente desde el punto de vista de Android. <br><br>  La segunda cosa, que me parece que no se puede comparar, son <strong>los par√°metros predeterminados del M√©todo</strong> , una caracter√≠stica muy interesante que, por cierto, est√° en Dart.  Cuando llama a alg√∫n m√©todo, puede tener algunos par√°metros que pueden tener alg√∫n valor, pero pueden ser NULL.  Y por lo tanto, no crea 10 m√©todos diferentes, sino que hace un m√©todo y dice que uno de los par√°metros puede ser NULL, y en el futuro lo usar√° sin ning√∫n par√°metro.  Es decir  √©l mirar√°, el par√°metro ha llegado o no ha venido.  Es muy conveniente porque puede escribir mucho menos c√≥digo, pero el inconveniente es que tiene que pagar por ello.  Este es el az√∫car sint√°ctico: usted, como desarrollador, cree que este es un m√©todo API, pero en realidad, debajo del cap√≥, cada variaci√≥n del m√©todo con par√°metros faltantes se genera en el c√≥digo de bytes.  Y cada uno de estos m√©todos tambi√©n verifica poco a poco si este par√°metro ha llegado.  Si lleg√≥, entonces est√° bien, si no fue as√≠, entonces creamos una m√°scara de bits, y dependiendo de esta m√°scara de bits, el m√©todo original que escribi√≥ se llama realmente.  Operaciones bit a bit, todo <em>si / de lo contrario</em> cuesta un poco de dinero, pero muy poco, y es normal que tenga que pagar por conveniencia.  Me parece que esto es absolutamente normal. <br><br>  El siguiente elemento que no se puede comparar son las <strong>clases de datos</strong> . <br><br>  Todos lloran que en Java hay par√°metros para los que hay clases de modelo.  Es decir  toma par√°metros y realiza m√°s m√©todos, captadores y establecedores para todos estos par√°metros.  Resulta que para una clase con diez par√°metros, todav√≠a necesita un conjunto completo de captadores, setters y un mont√≥n m√°s.  Adem√°s, si no usa generadores, entonces tiene que escribir con las manos, lo que generalmente es terrible. <br><br>  Kotlin te permite alejarte de todo.  Primero, dado que hay propiedades en Kotlin, no necesita escribir getters y setters.  No tiene <strong>par√°metros de clase, todas las propiedades</strong> .  En cualquier caso, creemos que s√≠.  En segundo lugar, si escribe que se trata de clases de datos, se generar√° un mont√≥n de todo lo dem√°s.  Por ejemplo, equals (), toStrung () / hasCode (), etc. <br><br>  Por supuesto, esto tambi√©n tiene inconvenientes.  Por ejemplo, no necesitaba comparar todos los 20 par√°metros de mis clases de datos a la vez en mis iguales (), solo necesitaba comparar 3. A alguien no le gusta todo esto porque el rendimiento se pierde en esto y, adem√°s, se genera mucho funciones de servicio, y el c√≥digo compilado es bastante voluminoso.  Es decir, si escribe todo a mano, habr√° menos c√≥digo que si usa clases de datos. <br><br>  No uso clases de datos por otro motivo.  Anteriormente, hab√≠a restricciones en la expansi√≥n de tales clases y algo m√°s.  Ahora todos est√°n mejor con esto, pero el h√°bito permanece. <br><br>  ¬øQu√© es muy, muy bueno en Kotlin, y qu√© ser√° siempre m√°s r√°pido que Java?  Se trata de <strong>tipos Reified</strong> , que, por cierto, tambi√©n est√° en Dart. <br><br>  Sabes que cuando usas gen√©ricos, el borrado de tipo se borra en la etapa de compilaci√≥n y en tiempo de ejecuci√≥n ya no sabes qu√© objeto de este gen√©rico se usa realmente. <br><br>  Con los tipos Reified, no necesita usar la reflexi√≥n en muchos lugares, cuando en Java lo necesitar√≠a, porque con los m√©todos en l√≠nea es con Reified que conoce el tipo y, por lo tanto, resulta que no usa la reflexi√≥n y su c√≥digo funciona m√°s r√°pido.  La magia <br><br>  Y hay <strong>corutinas</strong> .  Son geniales, me gustan mucho, pero en el momento de la presentaci√≥n se incluyeron solo en la versi√≥n alfa, por lo que no fue posible hacer comparaciones correctas con ellos. <br><br><h2>  CAMPOS <br></h2><br>  As√≠ que vamos adelante, pasemos a lo que podemos comparar con Java y a lo que podemos influir en general. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Como dije, no tenemos par√°metros para la clase, tenemos propiedades. <br><br>  Tenemos var, tenemos val, tenemos una clase externa, una de las propiedades de las cuales es @JvmField, y veremos qu√© sucede realmente con la funci√≥n work (): sumamos el valor del campo a y el campo b de nuestra propia clase y valores del campo a y el campo b de la clase externa, que se escribe en el campo inmutable c. <br><br>  La pregunta es qu√©, de hecho, se llamar√° en d = a + b.  Todos sabemos que esta propiedad una vez, se llamar√° al captador de esta clase para este par√°metro. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Pero si miramos el c√≥digo de bytes, veremos que realmente se est√° accediendo a getfield.  Es decir, esto en el bytecode no es una llamada a la funci√≥n InvokeVirtual, sino un acceso directo al campo.  No hay nada que se nos prometi√≥ inicialmente, que tenemos todas las propiedades, no los campos.  Resulta que Kotlin nos est√° enga√±ando, hay un atractivo directo. <br><br>  ¬øQu√© sucede si vemos qu√© bytecode se genera para otra l√≠nea: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Anteriormente, si estaba accediendo a una propiedad privada, siempre ten√≠a una llamada InvokeVirtual.  Si se trataba de una propiedad privada, el acceso a ella se realiz√≥ a trav√©s de GetField.  GetField es mucho m√°s r√°pido que InvokeVirtual, la especificaci√≥n de Android afirma que acceder a un campo directamente es de 3 a 7 veces m√°s r√°pido.  Por lo tanto, se recomienda que siempre se refiera a Field, y no a trav√©s de getters o setters.  Ahora, especialmente en la octava m√°quina virtual ART, ya habr√° n√∫meros diferentes, pero si a√∫n es compatible con 4.1, esto ser√° cierto. <br><br>  Por lo tanto, resulta que todav√≠a es beneficioso para nosotros tener GetField, y no InvokeVirtual. <br><br>  Ahora, puede obtener GetField si est√° accediendo a una propiedad de su propia clase, o si esta es una propiedad p√∫blica, debe establecer @JvmField.  Entonces, exactamente lo mismo en el bytecode ser√° una llamada GetField, que es 3 a 7 veces m√°s r√°pida. <br><br>  Est√° claro que aqu√≠ hablamos en nanosegundos y, con un trono, es muy, muy peque√±o.  Pero, por otro lado, si lo hace en el hilo de la interfaz de usuario, por ejemplo, en el m√©todo ondraw accede a alg√∫n tipo de vista, esto afectar√° la representaci√≥n de cada cuadro, y puede hacerlo un poco m√°s r√°pido. <br><br>  <strong>Si sumamos todas las optimizaciones, en resumen, puede dar algo.</strong> <br><br><h2>  ¬øEST√ÅTICA? <br></h2><br>  ¬øQu√© pasa con la est√°tica?  Todos sabemos que en Kotlin, la est√°tica es un objeto complementario.  Anteriormente, probablemente haya agregado alg√∫n tipo de etiqueta, por ejemplo, est√°tica p√∫blica, est√°tica final, etc., si convierte esto al c√≥digo de Kotlin, obtendr√° un objeto complementario, que escribir√° algo como lo siguiente: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  ¬øCrees que esta entrada es id√©ntica a la declaraci√≥n final est√°tica est√°ndar en Java?  ¬øEs est√°tico o no? </blockquote><br>  S√≠, de hecho, Kotlin declara que aqu√≠ est√° en Kotlin: est√°tico, ese objeto dice que es est√°tico.  En realidad, esto no es est√°tico. <br><br>  Si observamos el bytecode generado, veremos lo siguiente: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Se genera un Test.Companion; un objeto singleton para el que se crea la instancia, esta instancia se escribe en su propio campo.  Despu√©s de eso, el acceso a uno de los objetos complementarios se produce a trav√©s de este objeto.  Toma getstatic, es decir, una instancia est√°tica de esta clase, e invoca la funci√≥n getK invokevirtual en ella, y exactamente lo mismo para la funci√≥n work2.  Entonces entendemos que no es est√°tico. <br><br>  Esto es importante, porque en las JVM m√°s antiguas, la invookestatic era aproximadamente un 30% m√°s r√°pida que la invokevirtual.  Ahora, por supuesto, en HotSpot, la virtualizaci√≥n optimizada se est√° volviendo realmente genial, y es casi invisible.  Sin embargo, debe tener esto en cuenta, especialmente porque hay una asignaci√≥n adicional y una ubicaci√≥n adicional en 4ST1 es de 700 nanosegundos, demasiado. <br><br>  Echemos un vistazo al c√≥digo Java que sale si implementa el c√≥digo de bytes de forma inversa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Se crea un campo est√°tico, se crea una implementaci√≥n final est√°tica del objeto Companion, se crean captadores y establecedores y, como puede ver, haciendo referencia al campo est√°tico en el interior, aparece un m√©todo est√°tico adicional.  Todo es lo suficientemente triste. <br><br>  ¬øQu√© podemos hacer para asegurarnos de que no sea est√°tico?  Podemos intentar agregar @JvmField y @JvmStatic y ver qu√© sucede. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Dir√© de inmediato que no se alejar√° de @JvmStatic, ser√° el mismo objeto, ya que este es un objeto complementario, habr√° una asignaci√≥n adicional de este objeto y habr√° una llamada adicional. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Pero la llamada cambiar√° solo para k, porque ser√° @JvmField, se tomar√° directamente como getstatic, ya no se generar√°n getters y setters.  Pero para la funci√≥n work2 nada cambiar√°. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  La segunda opci√≥n sobre c√≥mo crear est√°tica se propone en la documentaci√≥n de Kotlin, por lo que se dice que solo podemos crear un objeto, y este ser√° un c√≥digo est√°tico. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  En realidad, esto tampoco es as√≠. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Resulta que hacemos una llamada de instancia getstatic desde singletone, que se crea, y llamamos exactamente los mismos m√©todos virtuales. <br><br>  La √∫nica forma en que podemos lograr invokestatic es Funciones de orden superior.  Cuando simplemente escribimos alguna funci√≥n fuera de la clase, por ejemplo, fun test2 se llamar√° realmente como static. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Adem√°s, lo m√°s interesante es que se crear√° una clase, un objeto, en este caso testKt, generar√° un objeto para s√≠ mismo, generar√° una funci√≥n que se pone en este objeto, y ahora se llamar√° como invocat√°tico. <br><br>  Por qu√© se hizo esto es incomprensible.  Muchos no est√°n contentos con esto, pero hay quienes consideran que tal implementaci√≥n es bastante normal.  Desde la m√°quina virtual, incl.  El arte est√° mejorando, ahora no es tan cr√≠tico.  En la octava versi√≥n de Android, al igual que en HotSpot, todo est√° optimizado, pero estas peque√±as cosas afectan ligeramente el rendimiento general. <br><br><h2>  NULABILIDAD <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Este es el siguiente ejemplo interesante.  Parece que notamos que el segundo puede ser anulable, y debe verificarse antes de hacer algo con √©l.  En este caso, espero que tengamos uno si.  Cuando este c√≥digo se implementa si el segundo no es igual a cero, entonces creo que la ejecuci√≥n ir√° m√°s all√° y solo se generar√° primero. <br><br>  ¬øC√≥mo se desarrolla todo esto en el c√≥digo Java?  En realidad habr√° un cheque. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Obtendremos Intrinsics inicialmente.  Digamos que yo digo que este <br><br>  Si se expandir√° en un operador ternario.  Pero adem√°s de esto, aunque incluso arreglamos que el primer par√°metro no puede ser anulable, a√∫n se verificar√° a trav√©s de Intrinsics. <br><br>  Intrinsics es una clase interna en Kotlin que tiene un cierto conjunto de par√°metros y verificaciones.  Y cada vez que hace que el par√°metro del m√©todo no sea anulable, lo verifica de todos modos.  Por qu√©  Entonces, que trabajamos en Interop Java, y puede suceder que espere que no sea anulable aqu√≠, pero con Java vendr√° de alg√∫n lado. <br><br>  Si marca esto, ir√° m√°s all√° en el c√≥digo, y luego, despu√©s de 10-20 llamadas al m√©todo, har√° algo con un par√°metro que, aunque puede no ser anulable, pero por alguna raz√≥n result√≥ ser.  Todo se enamorar√° de ti y no podr√°s entender lo que realmente sucedi√≥.  Para evitar esta situaci√≥n, cada vez que pase el par√°metro nulo, a√∫n tendr√° que verificarlo.  Y si es anulable, habr√° una excepci√≥n. <br><br>  Este cheque tambi√©n vale algo, y si hay muchos de ellos, entonces no ser√° muy bueno. <br><br>  Pero, de hecho, si hablamos de HotSpot, 10 llamadas de estos Intr√≠nsecos tomar√°n alrededor de cuatro nanosegundos.  Esto es muy, muy peque√±o, y no debe preocuparse por esto, pero este es un factor interesante. <br><br><h2>  Primitivas <br></h2><br>  En Java existen los primitivos.  En Kotlin, como todos sabemos, no hay primitivas, siempre operamos con objetos.  En Java, se utilizan para proporcionar un mayor rendimiento para los objetos en algunos c√°lculos menores.  Agregar dos objetos es mucho m√°s costoso que agregar dos primitivas.  Considera un ejemplo. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Hay tres n√∫meros, para los dos primeros se deducir√° el tipo no nulo, y alrededor del tercero decimos que puede ser anulable. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Si observa el c√≥digo de bytes y ve qu√© c√≥digo Java se genera, los dos primeros n√∫meros no son nulos y, por lo tanto, pueden ser primitivos.  Pero la primitiva no puede contener Nulo, solo un objeto puede hacer esto, por lo que se generar√° un objeto para el tercer n√∫mero. <br><br><h2>  AUTOBOXING <br></h2><br>  Cuando trabaje con primitivas y realice una operaci√≥n con primitivas y no primitivas, necesitar√° traducir una de ellas en una primitiva o en un objeto. <br><br>  Y, al parecer, no es sorprendente que si realiza operaciones con nullable y no nullable en Kotlin, pierda un poco de rendimiento.  Adem√°s, si hay muchas operaciones de este tipo, entonces pierde mucho. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  ¬øVes d√≥nde estar√° aqu√≠ el boxeo / unboxing?  Tampoco vi hasta que mir√© el bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  En realidad, esperaba que hubiera algo como esta comparaci√≥n: si la cadena no es nula y est√° vac√≠a, se establece en verdadero, de lo contrario se establece en falso.  Todo parece ser simple, pero en realidad se genera el siguiente c√≥digo: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Miremos adentro.  Se toma la variable <em>a</em> , se emite en CharSequence, despu√©s de que se ha echado, que tambi√©n se ha gastado durante alg√∫n tiempo, se llama otra verificaci√≥n - StringsKt.isBlank - as√≠ es como se escribe la funci√≥n de extensi√≥n para CharSequence, por lo que se emite y se env√≠a.  Como la primera expresi√≥n puede ser anulable, la toma y hace Boxeo, y la envuelve todo en Boolean.valueOf.  Por lo tanto, la primitiva verdadera tambi√©n se convierte en un objeto, y solo despu√©s de eso, la verificaci√≥n ya tiene lugar y se llama a Intrinsics.areEqual. <br><br>  Parecer√≠a una operaci√≥n tan simple, pero un resultado tan inesperado.  De hecho, hay muy pocas de esas cosas.  Pero cuando puede tener nullable / no nullable, puede generar muchas de esas cosas, y una que nunca hubiera esperado.  Por lo tanto, le recomiendo que se aleje de la oscuridad lo antes posible.  Es decir  <strong>llegue a la inmunidad de los valores lo antes posible y al√©jese de los valores nulables</strong> para que no opere nulo lo m√°s r√°pido posible. <br><br><h2>  Bucles <br></h2><br>  La pr√≥xima cosa interesante. <br><br>  Puede usar el usual for, que est√° en Java, pero tambi√©n puede usar la nueva API conveniente: escriba la enumeraci√≥n de elementos en la lista de inmediato. ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     ‚Äî   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   ¬´¬ª,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        ‚àí1,  until ,   ,    .   ,    ,    ranges.  Es decir   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    ‚Äî   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   ‚Äî Xno-param-assertions ‚Äî    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  ‚Äî ,     .     ,    ,    0,04 . ,  ,        ‚Äî   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  ‚Äî   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   ‚Äî . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420143/">https://habr.com/ru/post/es420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420131/index.html">M√©todo de miner√≠a probabil√≠stico de Bitcoin</a></li>
<li><a href="../es420133/index.html">Modelado de sistemas din√°micos: ¬øc√≥mo se mueve la luna?</a></li>
<li><a href="../es420135/index.html">Esto tambi√©n es Toshiba: productos inesperados de la corporaci√≥n japonesa</a></li>
<li><a href="../es420139/index.html">Libro "Ingenier√≠a de confiabilidad del sitio. Fiabilidad y fiabilidad como en Google ¬ª</a></li>
<li><a href="../es420141/index.html">Desde el MPP DBMS cargado - Data Lake lleno de vida con herramientas anal√≠ticas: comparta los detalles de la creaci√≥n</a></li>
<li><a href="../es420145/index.html">¬øC√≥mo es el d√≠a de trabajo de los miembros de PC AppsConf?</a></li>
<li><a href="../es420147/index.html">OpenSource en Clojure</a></li>
<li><a href="../es420151/index.html">M√°s f√°cil de lo que parece. Cap√≠tulo 12</a></li>
<li><a href="../es420153/index.html">Impresi√≥n 3D de piezas complejas hechas de ABS y PLA con mucho soporte</a></li>
<li><a href="../es420155/index.html">Intel Datacenter SSD. Grandes vol√∫menes y nuevos nombres.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>