<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍋 🚶🏽 ♈️ Tests métamorphiques: pourquoi presque personne ne connaît cette technique prometteuse 🛤️ ♒️ 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je dois admettre: je lis ACM Magazine . Cela fait de moi un «nerd», même selon les normes des programmeurs. Entre autres choses, j'ai appris de ce mag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests métamorphiques: pourquoi presque personne ne connaît cette technique prometteuse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454458/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72f/519/09c/72f51909cfdef1e922264489be381bac.jpg" alt="image"></div><br>  Je dois admettre: je lis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACM Magazine</a> .  Cela fait de moi un «nerd», même selon les normes des programmeurs.  Entre autres choses, j'ai appris de ce magazine sur les «tests métamorphiques».  Je n'avais jamais entendu parler de lui auparavant, comme toutes les personnes à qui j'ai demandé.  Mais la littérature scientifique sur ce sujet est étonnamment volumineuse: il existe de nombreux exemples incroyablement réussis de son application dans des domaines de recherche complètement différents.  Alors, pourquoi n'avons-nous pas entendu parler de lui avant?  Il n'y a qu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seul</a> article pour les personnes extérieures à la communauté scientifique.  Maintenant, qu'il y en ait deux. <br><br><h2>  Bref historique </h2><br>  La plupart des tests écrits utilisent des <strong>oracles</strong> .  Autrement dit, vous connaissez la réponse et vérifiez explicitement si les calculs donnent la bonne réponse. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_dist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> p1 = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) p2 = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> dist(p1, p2) == <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  En plus des tests Oracle, il existe également des tests manuels.  Le testeur s'assoit devant l'ordinateur et compare les données d'entrée avec les résultats.  À mesure que les systèmes deviennent plus complexes, les tests manuels deviennent de moins en moins utiles.  Chacun d'eux ne vérifie qu'un seul point dans un espace d'état beaucoup plus grand, et nous avons besoin de quelque chose qui explore tout l'espace d'état. <br><br>  Cela nous amène à <strong>des tests génératifs</strong> : écrire des tests couvrant un ensemble aléatoire dans un espace d'états.  Le style de test génératif le plus populaire est le <strong>test basé sur les propriétés</strong> , ou PBT.  Nous trouvons la «propriété» de la fonction, puis générons les valeurs d'entrée et vérifions si les valeurs de sortie correspondent à cette propriété. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_dist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> p1 = random_point() p2 = random_point() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> dist(p1, p2) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  L'avantage du PBT est qu'il couvre plus d'espace.  Son inconvénient est la perte de spécificité.  Ce n'est <em>plus un</em> test Oracle!  Nous ne savons pas quelle devrait être la réponse, et la fonction peut être erronée, mais d'une manière qui a la même propriété.  Ici, nous nous appuyons sur l'heuristique. <br><a name="habracut"></a><br>  Un problème sérieux avec PBT est de trouver de bonnes propriétés.  La plupart des fonctions ont des propriétés générales simples et des propriétés spécifiques complexes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les propriétés générales</a> peuvent être appliquées à un grand nombre de fonctions, mais elles ne nous donnent pas beaucoup d'informations.  Des propriétés plus spécifiques donnent plus d'informations, mais elles sont plus difficiles à trouver et ne sont applicables que dans des zones de tâches limitées.  Si vous avez une fonction qui détermine si un graphe est acyclique, alors quels tests de propriétés écrirez-vous?  Vont-ils vous donner l'assurance que la fonction est correcte? <br><br><h2>  La motivation </h2><br>  Considérons maintenant une tâche plus complexe.  Imaginez que vous vouliez écrire un convertisseur parole-texte (STT) pour l'anglais.  Il reçoit un fichier son et affiche le texte.  Comment le testeriez-vous? <br><br>  La façon la plus simple d'utiliser un oracle à main.  Dictez la phrase et vérifiez si le texte de sortie correspond.  Mais ce n'est même pas assez proche!  La gamme de la parole humaine <em>est immense</em> .  Il serait préférable de tester 1 000 voire 10 000 fichiers audio différents.  Les oracles portables avec transcription seraient trop coûteux.  Cela signifie que nous devons utiliser à la place des tests basés sur les propriétés. <br><br>  Mais comment générer des entrées?  Par exemple, nous pouvons créer des lignes aléatoires, les passer à travers un convertisseur texte-parole (text-to-speech, TTS), puis nous assurer que notre STT produit le même texte.  Mais cela nous donne encore une fois une gamme très limitée de voix humaine.  Le TTS peut-il créer des changements d'intonation, «avaler» des mots, imiter un fort accent?  Si nous ne pouvons pas les traiter, le STT sera-t-il particulièrement utile?  Il est préférable d'utiliser des textes arbitraires, par exemple, des enregistrements de la radio, des podcasts et des vidéos en ligne. <br><br>  Maintenant, un nouveau problème se pose.  Lors de l'utilisation de TTS, nous avons commencé avec du texte écrit.  Dans le cas de fichiers sonores arbitraires, nous ne les avons pas, et en même temps, nous ne voulons pas transcrire manuellement.  Au lieu de cela, nous sommes limités à utiliser des propriétés.  Quelles propriétés devons-nous tester?  Exemples des propriétés les plus simples: «le programme ne plante pas avec les données entrantes» (une bonne propriété) ou «il ne convertit pas la musique acoustique en mots» (peut-être?).  Ces propriétés ne couvrent pas très bien la vérification de la tâche principale du programme et augmentent légèrement la confiance dans sa qualité. <br><br>  Nous avons donc deux tâches.  Premièrement, nous avons besoin d'une grande quantité de données sous forme de discours.  Deuxièmement, nous devons comprendre comment les convertir en tests utiles sans passer de longues heures à transcrire manuellement des voix en oracles. <br><br><h2>  Test métamorphique </h2><br>  Pour tout cela, la sortie est considérée séparément.  Et si nous les intégrions dans un contexte plus large?  Par exemple, si un clip audio est transcrit dans la sortie de sortie, alors nous devons <em>toujours</em> <code>out</code> avec: <br><br><ul><li>  Double volume </li><li>  Fréquence croissante </li><li>  Accélérez </li><li>  Ajout de bruit de fond </li><li>  Ajout de bruit de véhicule </li><li>  Toute combinaison de ce qui précède. </li></ul><br>  Ce sont toutes des transformations «simples» que nous pouvons facilement tester.  Par exemple, pour un test avec «bruit de véhicule», nous pouvons prélever 10 échantillons de bruit de voiture, les mettre sur un clip audio et vérifier si les résultats de reconnaissance des 11 versions correspondent.  Nous pouvons doubler ou augmenter le volume, transformant 11 versions en 33 versions, puis doubler le rythme pour obtenir 66 versions.  Ce principe peut être appliqué à chaque clip audio de notre base de données, augmentant considérablement l'espace des données entrantes. <br><br>  La présence de 66 versions pour comparaison est assez pratique.  Mais ce n'est pas tout: nous n'avons toujours pas besoin de savoir quelle devrait être la sortie.  Si les 66 conversions reviennent, le test a réussi, si au moins une renvoie autre chose, le test a échoué.  À aucun moment, nous n'avons besoin de vérifier ce qui est contenu dans <code>out</code> .  C'est extrêmement important.  Nous augmentons donc considérablement l'espace de test avec très peu d'implication humaine.  Par exemple, nous pouvons télécharger un épisode de la série, effectuer des conversions et vérifier si tous les résultats de leur conversion en texte <sup>1</sup> correspondent.  Nous avons obtenu des tests utiles <em>sans écouter le clip vocal</em> .  Maintenant, nous pouvons générer des tests complexes et profonds sans utiliser d'oracle! <br><br>  Deux ensembles de données d'entrée, ainsi que leurs données de sortie, sont connectés l'un à l'autre.  Une telle propriété liée à l'ensemble des données entrantes / sortantes est appelée <strong>lien métamorphique</strong> <sup>2</sup> .  Les tests qui appliquent cette propriété sont appelés <strong>tests métamorphiques</strong> .  Dans les systèmes complexes, les relations métamorphiques intéressantes peuvent être trouvées plus facilement que les propriétés intéressantes des données entrantes / sortantes individuelles. <br><br>  Disons-le un peu plus formellement: si nous avons <code>x</code> et <code>f(x)</code> , alors nous pouvons effectuer quelques transformations de <code>x</code> pour obtenir <code>x2</code> et <code>f(x2)</code> .  Dans le cas de STT, nous vérifions simplement <code>f(x) = f(x2)</code> , mais nous pouvons utiliser toutes les relations entre les deux ensembles de données.  Il peut y avoir des relations métamorphiques comme <code>f(x2) &gt; f(x)</code> ou "est <code>f(x2)/f(x)</code> une valeur entière."  De manière similaire, ce principe peut être étendu à plusieurs ensembles de données d'entrée à l'aide de <code>f(x)</code> et <code>f(x3)</code> .  Un exemple de ceci est la comparaison des résultats d'un moteur de recherche sans filtres avec les résultats d'un moteur avec un ou deux filtres.  Dans la majorité des descriptions des cas d'utilisation que j'ai lus, seuls deux ensembles de données d'entrée sont utilisés, car même ils sont suffisants pour trouver des bugs fous. <br><br><h2>  Exemples d'utilisation </h2><br>  En parlant de cas d'utilisation: quelle est l'efficacité des tests métamorphiques dans la pratique?  C'est une chose de parler d'une technique de façon abstraite ou de donner des exemples artificiels.  Les études de cas sont utiles pour trois raisons.  Premièrement, il montre si la méthode fonctionne réellement.  Deuxièmement, vous pouvez en apprendre davantage sur les difficultés potentielles lors de l'utilisation de MT.  Troisièmement, les exemples nous montrent <em>comment</em> utiliser la technique.  Toute connexion métamorphique utilisée dans l'exemple d'utilisation peut être essayée pour s'adapter à la solution de nos problèmes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tests métamorphiques: un examen des défis et des opportunités</a> fournit une liste de nombreuses études, mais ce sont tous des articles scientifiques.  Voici les plus intéressants.  Les articles marqués d'un <code>(pdf)</code> sont présentés, comme vous pouvez le deviner, au format PDF. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">METTLE: A Metamorphic Testing Approach to Validating Nonupervised Machine Learning Methods</a> (pdf).  Ici, 11 relations métamorphiques différentes sont décrites pour tester le clustering non contrôlé, par exemple, "obtiendrons-nous le même résultat si nous mélangeons les données d'entrée?"  »et« les données d'entrée supplémentaires aux bords des grappes appartiennent-elles à ces grappes? »  Différents modèles varient selon les relations.  Par exemple, environ 5% des modèles k-means testés avec mélange de l'ordre des points entrants ont une erreur de clustering moyenne de 20% </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DeepTest: Test automatisé de voitures autonomes pilotées par un réseau de neurones profonds</a> (pdf).  Le sujet de l'article est les systèmes de vision des pilotes automatiques dans les voitures.  Exemples de relations métamorphiques (MS): «ajout d'un filtre pluie» ou «légère inclinaison de l'image».  Les auteurs ont affiché les résultats de l'échantillonnage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> : presque tous les systèmes qu'ils ont testés ne faisaient pas face à leurs fonctions lors du changement de la SEP. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test automatisé des compilateurs de shaders graphiques</a> (pdf).  Les injections du code «mort» et des constantes d'exécution dans les shaders ont conduit à la disparition d'objets dans les images ou à leur transformation en bruit.  Des recherches sur la base de leur travail ont créé une startup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20180710214938/">GraphicsFuzz</a> , qui a été achetée par Google, et le site est fermé. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test métamorphique des API Web RESTful</a> (pdf).  Aurons-nous les mêmes éléments lorsque la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pagination</a> changera?  Et si vous les triiez par date?  Cet article répertorie un tas de bogues dans Spotify et Youtube. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une approche innovante pour tester les programmes de bioinformatique à l'aide de tests métamorphiques</a> (anciennement pdf, mais maintenant non).  Recherchez des erreurs dans les données de bioinformation.  Je connais mal la bioinformatique, mais l'article montre que les MS sont également utiles dans des domaines spécialisés. </li></ul><br><h2>  Le problème </h2><br>  Oh, donc <i>toutes</i> ces sources sont en PDF. <br><br>  Il a fallu plusieurs heures pour trouver tous ces articles.  Et ce problème est associé au plus grand obstacle au développement de la MT: tous les liens ci-dessus sont des <strong>prépublications</strong> ou des premières ébauches d'articles scientifiques futurs.  Quand je commence à comprendre des techniques peu connues, je me pose d'abord la question: "pourquoi sont-elles peu connues?"  Parfois, la raison est évidente, parfois c'est un ensemble complexe de petites raisons, parfois le problème est simplement que la méthodologie est «malheureuse». <br><br>  Dans le cas de MT, le problème est évident.  <strong>Presque toutes les informations sont cachées derrière un paywall scientifique.</strong>  Si vous voulez étudier la MT, vous devez soit avoir accès au journal, soit passer plusieurs heures à chercher des prépublications <sup>3</sup> . <br><br><h2>  Etude complémentaire </h2><br>  L'inventeur de MT est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ty Chen</a> .  Il est devenu le moteur de nombreuses études.  D'autres chercheurs dans ce domaine sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zhi Quan Zhou</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sergio Segura</a> ;  tous deux ont publié toutes leurs prépublications sur Internet.  La plupart des travaux de recherche sont effectués par l'une de ces personnes. <br><br>  Le meilleur endroit pour commencer est probablement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test métamorphique: un examen des défis et des opportunités</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une enquête sur le test métamorphique</a> .  Bien que cet article soit écrit sur les <em>tests</em> métamorphiques, les chercheurs ont également appliqué les relations métamorphiques en général à une grande variété d'autres disciplines, par exemple, la vérification de code formelle et le débogage.  Je n'ai pas encore étudié ces domaines d'application de la technique en détail, mais cela vaut probablement la peine de les examiner également. <br><br>  Du point de vue de l'applicabilité, il peut théoriquement être possible d'adapter la plupart des bibliothèques PBT pour vérifier les propriétés métamorphiques.  En fait, le premier exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quickcheck</a> teste la SEP, et dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet</a> essai sur PBT, la SEP est indirectement appliquée.  <em>En général,</em> il me semble que la plupart des recherches PBT se concentrent sur la génération et le découpage efficaces des données entrantes, et la recherche MT se concentre principalement sur la détermination de ce que nous devons vraiment tester.  Par conséquent, ces techniques sont susceptibles de se compléter. <br><br>  <em>Merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brian Ng</a> pour son aide à la recherche.</em> <br><br><h3>  Post-scriptum: demande </h3><br>  En fait, il n'est pas surprenant que je n'avais jamais entendu parler de cette technique auparavant.  Il existe de nombreuses techniques vraiment intéressantes et utiles qui n'ont pas pu laisser leur minuscule bulle.  J'ai découvert les MT par hasard plutôt que par des recherches actives. <br><br>  Si vous savez quelque chose qui mérite d'être largement utilisé, <a href="">écrivez-moi</a> . <br><br><hr><br><ol><li>  Eh bien, il peut y avoir des problèmes évidents: il peut y avoir de la musique dans le podcast, des fragments de discours dans d'autres langues, etc.  Mais la théorie est fiable: si nous pouvons obtenir des échantillons de parole, nous pouvons les utiliser dans le cadre des tests sans transcription / balisage manuel préalable. </li><li>  Dans les spécifications, l'idée correspondante est les <strong>hyperpropriétés</strong> - les propriétés des ensembles de comportements, plutôt que les comportements individuels.  La plupart des études hyperspécifiques sont liées à la sécurité du HS.  Si je comprends bien, ses HS sont un surensemble de MS. </li><li>  J'avais une deuxième hypothèse, aujourd'hui réfutée: puisque la plupart des principaux chercheurs de Chine et de Hong Kong, cette technique est peut-être mieux connue dans les communautés de programmeurs qui communiquent en mandarin plutôt qu'en anglais.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brian Eun a</a> testé cette hypothèse pour moi, mais n'a trouvé aucun signe significatif de l'utilisation de la technique par les Chinois. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454458/">https://habr.com/ru/post/fr454458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454444/index.html">Nous profilons le chargement de Habr ou comment 189 requêtes sur la page rendent l'influence</a></li>
<li><a href="../fr454446/index.html">Quoi de neuf en C # 8?</a></li>
<li><a href="../fr454450/index.html">Comment Edison a inventé le sans fil et n'a rien compris</a></li>
<li><a href="../fr454452/index.html">Nous affichons le contenu sur l'image reconnue selon certaines règles</a></li>
<li><a href="../fr454456/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 7. FAQ</a></li>
<li><a href="../fr454460/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 300 (27 mai - 2 juin)</a></li>
<li><a href="../fr454462/index.html">Photogramme sans papier photo</a></li>
<li><a href="../fr454464/index.html">Développement de tests visuels basés sur Gemini et Storybook</a></li>
<li><a href="../fr454470/index.html">La vie avant l'exécution. Rapport Yandex</a></li>
<li><a href="../fr454472/index.html">Ce que vous devez savoir sur le dernier correctif de routeur de Cisco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>