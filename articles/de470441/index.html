<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😂 📃 👩🏿‍🎤 Größen verschiedener Arten von Java-Objekten 👼 💃🏾 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Enthält das Java-Objekt: 



- Felder in der Oberklasse deklariert? 
- private Felder in einer Oberklasse deklariert? 
- Methoden? 
- Arr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Größen verschiedener Arten von Java-Objekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470441/"><h1>  Einführung </h1><br>  Enthält das Java-Objekt: <br><br><ul><li>  Felder in der Oberklasse deklariert? </li><li>  private Felder in einer Oberklasse deklariert? </li><li>  Methoden? </li><li>  Array-Elemente? </li><li>  Array Länge? </li><li>  ein anderes Objekt (an sich)? </li><li>  Hash-Code? </li><li>  Typ (eigene)? </li><li>  Name (eigener)? </li></ul><br>  Antworten auf diese (und andere) Fragen erhalten Sie über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Klassenbibliothek org.openjdk.jol</a> , mit der wir insbesondere verstehen können, dass das Objekt ein Speicherbereich ist: <br><br><ul><li>  enthält: <ul><li>  Header (bis zu 16 Bytes) und darin: <br><ul><li>  Hash-Code </li><li>  Typreferenz </li><li>  Array-Länge (für Array) </li></ul></li><li>  Alle Felder (einschließlich privat), die in allen Oberklassen deklariert sind </li><li>  oder Array-Elemente (für ein Array) </li></ul></li><li>  nicht enthalten: <br><ul><li>  statische Variablen </li><li>  Methoden </li><li>  andere Objekte in dir </li><li>  eigener Name (dh das Objekt hat keinen Namen) </li></ul><br></li></ul><br><h1>  Vorbereitung </h1><br>  Hier sind die Ergebnisse der Auswertung des Speichers von Objekten verschiedener Typen mit der Methode aus der Beschreibung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pakets java.lang.instrument</a> (siehe auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Diese Ergebnisse ermöglichen es uns, die meisten der oben gestellten Fragen zu beantworten. <br><a name="habracut"></a><br>  Die folgenden Schritte müssen ausgeführt werden: <br><br><ol><li>  Erstellen Sie eine Agentenklasse mit der Premain-Methode: <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String, Instrumentation)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> </li><li>  Erstellen Sie ein Archiv mit der Agentenklasse und der Manifestdatei mit dem Inhalt: <br><pre> <code class="plaintext hljs">Premain-class: --</code> </pre> </li><li>  Erstellen Sie eine ausführbare Klasse zur Auswertung des Speichers. </li><li>  Geben Sie beim Starten der virtuellen Maschine das Archiv mit dem Parameter "-javaagent" an: <br><pre> <code class="plaintext hljs">java -javaagent:- --</code> </pre> <br></li></ol><br>  Beginnen wir mit einem Testfall.  Der Einfachheit halber verwenden wir ein unbenanntes Paket. <br><br><h4>  Schritt 1. Erstellen Sie eine Testagentenklasse </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.instrument.Instrumentation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String notUsedHere, Instrumentation i)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"premain"</span></span>); } }</code> </pre> <br>  Wir kompilieren: <br><br><pre> <code class="plaintext hljs">javac A.java</code> </pre> <br><h4>  Schritt 2. Erstellen Sie eine m.txt-Manifestdatei mit: </h4><br><pre> <code class="plaintext hljs">Premain-class: A  </code> </pre><br>  <em>ACHTUNG: Die zweite Zeile der Datei muss leer sein und darf keine Leerzeichen enthalten.</em> <br><br>  Erstellen Sie das A.jar-Archiv: <br><br><pre> <code class="plaintext hljs">jar cmf m.txt A.jar A.class</code> </pre> <br><h4>  Schritt 3. Erstellen Sie eine ausführbare Testklasse </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] notUsedHere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     System.out.println("main"); } }</span></span></code> </pre> <br>  Wir kompilieren: <br><br><pre> <code class="plaintext hljs">javac M.java</code> </pre> <br><h4>  Schritt 4. Durchführen </h4><br><pre> <code class="plaintext hljs">java -javaagent:A.jar M</code> </pre> <br>  Ergebnis: <pre> <code class="plaintext hljs">premain main</code> </pre><br>  Gibt an, dass zuerst die Premain-Methode der Agentenklasse und dann die Hauptmethode der ausführbaren Klasse aufgerufen wurde. <br><br>  Erstellen Sie nun die gewünschte Agentenklasse: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.instrument.Instrumentation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      private static Instrumentation ins; public static void premain(String notUsedHere, Instrumentation i) { ins = i; } public static Instrumentation instrumentation() {return ins;} }</span></span></code> </pre> <br>  und ausführbare Klasse: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] notUsedHere)</span></span></span><span class="hljs-function"> </span></span>{ mem(<span class="hljs-string"><span class="hljs-string">"Object"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o, Object ref)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(o + <span class="hljs-string"><span class="hljs-string">": "</span></span> + objectBytesEstimate(ref)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectBytesEstimate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object ref)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A.instrumentation() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Not initialized instrumentation."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A.instrumentation().getObjectSize(ref); } }</code> </pre> <br>  Methode <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObjectSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object --)</span></span></span></span></code> </pre> <br>  Gibt eine SCHÄTZUNG der Größe (Anzahl der Bytes) des Speichers zurück, der vom Objekt an der angegebenen Verbindung belegt wird.  Es muss berücksichtigt werden, dass die resultierende Schätzung für eine andere virtuelle Maschine unterschiedlich sein kann.  Die Werte für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jdk-13</a> werden hier aufgelistet. <br><br>  Wir führen aus: <br><br><pre> <code class="plaintext hljs">javac *.java jar cmf m.txt A.jar A.class java -javaagent:A.jar M</code> </pre> <br>  und wir bekommen das Ergebnis: <br><br><pre> <code class="plaintext hljs">Object: 16</code> </pre> <br>  Dies zeigt, dass ein leeres Objekt vom Typ Object hier (BY ASSESSMENT) 16 Bytes belegt.  Von diesen belegen 12 Bytes den Header, und 4 Bytes am Ende dienen dazu, die Länge des Objekts an einer 8-Byte-Grenze auszurichten. <br><br><h1>  Ergebnisse </h1><br>  Weitere Beispiele enthalten nur den Code, der in der Hauptmethode der Klasse M platziert ist. Sie sollten für jedes Beispiel mit den folgenden Befehlen ausgeführt werden: <br><br><pre> <code class="plaintext hljs">javac M.java java -javaagent:A.jar M</code> </pre><br>  Das erneute Erstellen von A.jar ist nicht erforderlich. <br><br>  Um beispielsweise eine Schätzung der Speichergröße eines Objekts eines beliebigen Typs ohne Felder zu erhalten, fügen wir den Code in die Hauptmethode ein: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{}; mem(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C()); <span class="hljs-comment"><span class="hljs-comment">// Empty: 16</span></span></code> </pre> <br>  Das im Kommentar angegebene Ergebnis zeigt, dass ein Objekt ohne Felder so viele Bytes belegt wie ein Objekt vom Typ Objekt. <br><br>  Weiter das Ergebnis des Programms: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {int a,b; } mem(2, new C());} // 2: 24 {class C {int a,b,c; } mem(3, new C());} // 3: 24 {class C {int a,b,c,d;} mem(4, new C());} // 4: 32</span></span></code> </pre><br>  gibt an, dass jedes int-Feld 4 Bytes benötigt.  Ich stelle fest, dass hier jede Zeile ein separater Block ist, mit dem Sie denselben Namen für verschiedene Klassen verwenden können. <br><br>  Jedes lange Feld besteht aus 8 Bytes: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 24 {class C {long a,b; } mem(2, new C());} // 2: 32 {class C {long a,b,c;} mem(3, new C());} // 3: 40</span></span></code> </pre><br>  Jedes boolesche Feld benötigt 1 Byte (für diese VM): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {boolean a,b; } mem(2, new C());} // 2: 16 {class C {boolean a,b,c; } mem(3, new C());} // 3: 16 {class C {boolean a,b,c,d; } mem(4, new C());} // 4: 16 {class C {boolean a,b,c,d,e;} mem(5, new C());} // 5: 24</span></span></code> </pre><br>  Jedes Referenzfeld benötigt 4 Bytes (für diese VM): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{Boolean a; } mem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 1: 16 {class C {Integer a; } mem(1, new C());} // 1: 16 {class C {Long a; } mem(1, new C());} // 1: 16 {class C {C a; } mem(1, new C());} // 1: 16 {class C {Boolean a,b; } mem(2, new C());} // 2: 24 {class C {Integer a,b; } mem(2, new C());} // 2: 24 {class C {Long a,b; } mem(2, new C());} // 2: 24 {class C {C a,b; } mem(2, new C());} // 2: 24 {class C {Boolean a,b,c; } mem(3, new C());} // 3: 24 {class C {Integer a,b,c; } mem(3, new C());} // 3: 24 {class C {Long a,b,c; } mem(3, new C());} // 3: 24 {class C {C a,b,c; } mem(3, new C());} // 3: 24 {class C {Boolean a,b,c,d;} mem(4, new C());} // 4: 32 {class C {Integer a,b,c,d;} mem(4, new C());} // 4: 32 {class C {Long a,b,c,d;} mem(4, new C());} // 4: 32 {class C {C a,b,c,d;} mem(4, new C());} // 4: 32</span></span></code> </pre><br>  Ein Feld vom Typ String benötigt wie jede Referenz auch 4 Byte: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{String a; } mem(<span class="hljs-string"><span class="hljs-string">" null"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// null: 16 {class C {String a=""; } mem(" empty", new C());} // empty: 16 {class C {String a="A"; } mem("1-char", new C());} // 1-char: 16 {class C {String a="1234567";} mem("7-char", new C());} // 7-char: 16</span></span></code> </pre><br>  Ein Array-Referenzfeld benötigt wie jedes Referenzfeld auch 4 Bytes: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; } mem(<span class="hljs-string"><span class="hljs-string">"null"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// null: 16 {class C {int[] a = {}; } mem(" 0", new C());} // 0: 16 {class C {int[] a = new int[1]; } mem(" 1", new C());} // 1: 16 {class C {int[] a = new int[7]; } mem(" 7", new C());} // 7: 16 {class C {int[][] a = {}; } mem(" 00", new C());} // 00: 16 {class C {int[][] a = new int[1][1];} mem(" 11", new C());} // 11: 16 {class C {int[][] a = new int[7][7];} mem(" 77", new C());} // 77: 16</span></span></code> </pre><br>  Das Subtypobjekt enthält jedes in der Oberklasse deklarierte Feld, unabhängig vom Zugriffsmodifikator: <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a;} mem(<span class="hljs-string"><span class="hljs-string">"0+1"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 0+1: 24 {class S {private long a;} class C extends S { } mem("1+0", new C());} // 1+0: 24</span></span></code> </pre><br>  Das Subtypobjekt enthält ein Feld, das in der Oberklasse mit demselben Namen wie in der Unterklasse deklariert ist (das sogenannte versteckt - versteckt): <br><br><pre> <code class="java hljs">{<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a,b;} mem(<span class="hljs-string"><span class="hljs-string">"0+2"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());} <span class="hljs-comment"><span class="hljs-comment">// 0+2: 32 {class S {long a;} class C extends S {long a; } mem("1+1", new C());} // 1+1: 32</span></span></code> </pre><br>  Ein Subtypobjekt enthält jedes Feld, das in jeder seiner Oberklassen deklariert ist: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a; } mem(<span class="hljs-string"><span class="hljs-string">"1+1+1"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C()); <span class="hljs-comment"><span class="hljs-comment">// 1+1+1: 40 class D { long a,b,c;} mem("0+0+3", new D()); // 0+0+3: 40</span></span></code> </pre><br>  Wenden Sie sich an Arrays.  Wie Sie wissen, ist ein Array eine spezielle Art von Objekt, dessen Elemente sich im Objekt selbst befinden. Daher wächst die Größe des vom Array belegten Speichers mit der Anzahl der Elemente: <br><br><pre> <code class="java hljs">{<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; mem(<span class="hljs-string"><span class="hljs-string">" 0"</span></span>, a);} <span class="hljs-comment"><span class="hljs-comment">// 0: 16 {long[] a = new long[ 1]; mem(" 1", a);} // 1: 24 {long[] a = new long[ 2]; mem(" 2", a);} // 2: 32 {long[] a = new long[ 3]; mem(" 3", a);} // 3: 40 {long[] a = new long[100]; mem("100", a);} // 100: 816</span></span></code> </pre><br>  Und für die Reihe von Links: <br><br><pre> <code class="java hljs">{Long[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Long[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; mem(<span class="hljs-string"><span class="hljs-string">" 0"</span></span>, a);} <span class="hljs-comment"><span class="hljs-comment">// 0: 16 {Long[] a = new Long[ 1]; mem(" 1", a);} // 1: 24 {Long[] a = new Long[ 2]; mem(" 2", a);} // 2: 24 {Long[] a = new Long[ 3]; mem(" 3", a);} // 3: 32 {Long[] a = new Long[100]; mem("100", a);} // 100: 416</span></span></code> </pre><br>  Aus Neugier vergleichen wir nun die Größen mehrerer Objekte unterschiedlichen Typs: <br><br><pre> <code class="java hljs">mem(<span class="hljs-string"><span class="hljs-string">" Object"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object()); <span class="hljs-comment"><span class="hljs-comment">// Object: 16 mem(" String", new String("ABC")); // String: 24 mem(" Exception", new Exception()); // Exception: 40 mem(" int.class", int.class); // int.class: 112 mem(" int[].class", int[].class); // int[].class: 112 mem("Object.class", Object.class); // Object.class: 112 mem("System.class", System.class); // System.class: 160 mem("String.class", String.class); // String.class: 136</span></span></code> </pre><br>  Das gleiche gilt für verschiedene JDK auf einem 64-Bit-Prozessor: <br><br><pre>                 jdk1.6.0_45 jdk1.7.0_80 jdk1.8.0_191 jdk-9 jdk-12 jdk-13
                 ----------- ----------- ------------ ------ ------ ---- - -
       Objekt: 16 16 16 16 16 16
       Zeichenfolge: 32 24 24 24 24 24
    Ausnahme: 32 32 32 40 40 40
    int.class: 104 88 104 112 104 112
  int []. class: 584 544 480 112 104 112
 Objektklasse: 600 560 496 112 104 112
 Systemklasse: 624 560 496 144 152 160
 String.class: 696 640 624 136 128 136 </pre><br>  Die Schätzung der Stringgröße beträgt 24 Byte, obwohl die String-Klasse viele statische Variablen sowie statische und nicht statische Methoden enthält.  Dies weist zweifellos auf das Fehlen statischer Variablen und Methodencodes im Objekt hin.  Gleiches gilt für ein Objekt jeglichen Typs. <br><br>  Abschließend eine Erinnerung: Alle Daten zur Größe des Objekts werden geschätzt und können von Ausführung zu Ausführung und natürlich für verschiedene virtuelle Maschinen in gewissem Maße variieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470441/">https://habr.com/ru/post/de470441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470417/index.html">Industrie 4.0: Autonome Unternehmensideen von SAP und KUKA</a></li>
<li><a href="../de470423/index.html">Edition-basierte Neudefinition. Teil 2</a></li>
<li><a href="../de470425/index.html">30.000 US-Dollar für die Lösung der Probleme von Regel 30 für zellulare Automaten - ein Wettbewerb von Stephen Wolfram</a></li>
<li><a href="../de470429/index.html">Unentwickeltes ERP in der Produktion: auf der Intensivstation oder in einer Leichenhalle? (Fortsetzung)</a></li>
<li><a href="../de470437/index.html">Digitaler Durchbruch: Finale des weltgrößten Hackathons</a></li>
<li><a href="../de470443/index.html">Kontinuierliche Profilerstellung in Go</a></li>
<li><a href="../de470445/index.html">Der erste Prototyp eines Quantencomputers in Russland wurde bei NUST „MISiS“ vorgestellt.</a></li>
<li><a href="../de470447/index.html">Anatomie der Sprecher: Wahrheit und Fiktion über NXT-Emitter</a></li>
<li><a href="../de470449/index.html">Top-Fähigkeiten Sie müssen ein Front-End-Entwickler sein</a></li>
<li><a href="../de470451/index.html">Wie der grüne Junior in die IT kam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>