<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ®Ô∏è üé¶ üöç Ne forcez pas les auditeurs √† r√©fl√©chir üßîüèø ‚úåÔ∏è üìΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 



 Au cours du processus de d√©veloppement, il est souvent n√©cessaire de cr√©er une instance d'une classe dont le nom est stock√© dans le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ne forcez pas les auditeurs √† r√©fl√©chir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie">  Pr√©sentation </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  Au cours du processus de d√©veloppement, il est souvent n√©cessaire de cr√©er une instance d'une classe dont le nom est stock√© dans le fichier de configuration XML, ou d'appeler une m√©thode dont le nom est √©crit sous forme de cha√Æne comme valeur de l'attribut d'annotation.  Dans de tels cas, la r√©ponse est une: ¬´Utilisez la r√©flexion!¬ª. </p><br><p>  Dans la nouvelle version de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CUBA Platform, l'</a> une des t√¢ches pour am√©liorer le framework √©tait de se d√©barrasser de la cr√©ation explicite de gestionnaires d'√©v√©nements dans les classes de contr√¥leur des √©crans d'interface utilisateur.  Dans les versions pr√©c√©dentes, les d√©clarations du gestionnaire dans la m√©thode d'initialisation du contr√¥leur √©taient tr√®s encombr√©es par le code, donc dans la septi√®me version, nous avons d√©cid√© de tout nettoyer. </p><a name="habracut"></a><br><p> Un √©couteur d'√©v√©nements n'est qu'une r√©f√©rence √† la m√©thode qui doit √™tre appel√©e au bon moment (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mod√®le Observer</a> ).  Un tel mod√®le est assez simple √† impl√©menter √† l'aide de la classe <code>java.lang.reflect.Method</code> .  Au d√©marrage, il vous suffit d'analyser les classes, d'en extraire les m√©thodes annot√©es, d'enregistrer les r√©f√©rences et d'utiliser les liens pour appeler la ou les m√©thodes lorsque l'√©v√©nement se produit, comme cela se fait dans la plupart des frameworks.  La seule chose qui nous a arr√™t√©s, c'est que de nombreux √©v√©nements sont traditionnellement g√©n√©r√©s dans l'interface utilisateur, et lorsque vous utilisez l'API de r√©flexion, vous devez payer un certain prix sous la forme de l'heure de l'appel de m√©thode.  Par cons√©quent, nous avons d√©cid√© de voir comment vous pouvez cr√©er des gestionnaires d'√©v√©nements sans utiliser la r√©flexion. </p><br><p>  Nous avons d√©j√† publi√© des documents sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MethodHandles</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LambdaMetafactory sur un habr</a> , et ce mat√©riel est une sorte de continuation.  Nous examinerons les avantages et les inconv√©nients de l'utilisation de l'API de r√©flexion, ainsi que les alternatives - g√©n√©rer du code avec la compilation AOT et LambdaMetafactory, et comment il a √©t√© utilis√© dans le cadre CUBA. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  R√©flexion: ancienne.  Bon  Fiable </h2><br><p>  <em>En informatique, la r√©flexion ou la r√©flexion (l'holonyme de l'introspection, r√©flexion en anglais) d√©signe un processus au cours duquel un programme peut suivre et modifier sa propre structure et son comportement lors de l'ex√©cution.</em>  (c) Wikip√©dia. </p><br><p>  Pour la plupart des d√©veloppeurs Java, la r√©flexion n'est jamais une nouveaut√©.  Il me semble que sans ce m√©canisme, Java ne serait pas devenu ce Java qui occupe d√©sormais une large part de march√© dans le d√©veloppement de logiciels applicatifs.  Pensez-y: proxy, liaison de m√©thodes aux √©v√©nements via des annotations, injection de d√©pendance, aspects, et m√™me instanciation du pilote JDBC dans les toutes premi√®res versions de JDK!  La r√©flexion partout, est la pierre angulaire de tous les cadres modernes. </p><br><p>  Y a-t-il des probl√®mes avec la r√©flexion appliqu√©e √† notre t√¢che?  Nous en avons identifi√© trois: </p><br><p>  <em>Vitesse</em> - un appel de m√©thode via l'API Reflection est plus lent qu'un appel direct.  Dans chaque nouvelle version de la JVM, les d√©veloppeurs acc√©l√®rent constamment les appels par la r√©flexion, le compilateur JIT essaie d'optimiser encore plus le code, mais de toute fa√ßon, la diff√©rence par rapport √† l'appel de m√©thode directe est notable. </p><br><p>  <em>Saisie</em> - si vous utilisez <code>java.lang.reflect.Method</code> dans le code, ce n'est qu'une r√©f√©rence √† une m√©thode.  Et nulle part il n'est √©crit combien de param√®tres sont pass√©s et de quel type ils sont.  Un appel avec des param√®tres incorrects g√©n√©rera une erreur lors de l'ex√©cution, et non au stade de la compilation ou du t√©l√©chargement de l'application. </p><br><p>  <em>Transparence</em> - si la m√©thode appel√©e par r√©flexion √©choue, nous devrons parcourir plusieurs appels <code>invoke()</code> avant d'arriver au fond de la cause r√©elle de l'erreur. </p><br><p>  Mais si nous regardons le code des gestionnaires d'√©v√©nements Spring ou JPA dans Hibernate, il y aura √† l'int√©rieur de bons vieux <code>java.lang.reflect.Method</code> .  Et dans un avenir proche, je pense que cela ne devrait pas changer.  Ces cadres sont trop volumineux et trop li√©s √† eux, et il semble que les performances des gestionnaires d'√©v√©nements c√¥t√© serveur soient suffisantes pour r√©fl√©chir √† ce que vous pouvez remplacer les appels par le biais de la r√©flexion. </p><br><p>  Et quelles sont les autres options? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  Compilation AOT et g√©n√©ration de code - acc√©l√©rez les applications! </h2><br><p>  Le premier candidat pour remplacer l'API de r√©flexion est la g√©n√©ration de code.  Maintenant, des frameworks tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Micronaut</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quarkus</a> ont commenc√© √† appara√Ætre, qui tentent de r√©soudre deux probl√®mes: r√©duire la vitesse de lancement de l'application et r√©duire la consommation de m√©moire.  Ces deux mesures sont essentielles √† notre √©poque de conteneurs, de microservices et d'architectures sans serveur, et de nouveaux cadres tentent de r√©soudre ce probl√®me par compilation AOT.  En utilisant diff√©rentes techniques (vous pouvez lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> par exemple), le code de l'application est modifi√© de telle sorte que tous les appels r√©flexifs aux m√©thodes, constructeurs, etc.  remplac√© par des appels directs.  Ainsi, vous n'avez pas besoin d'analyser les classes et de cr√©er des beans au d√©marrage de l'application, et JIT optimise le code plus efficacement au moment de l'ex√©cution, ce qui augmente consid√©rablement les performances des applications construites sur de telles infrastructures.  Cette approche pr√©sente-t-elle des inconv√©nients?  R√©ponse: bien s√ªr qu'il y en a. </p><br><p>  Tout d'abord, vous n'ex√©cutez pas le code que vous avez √©crit. Le code source change pendant la compilation, donc si quelque chose ne va pas, il est parfois difficile de comprendre o√π se trouve l'erreur: dans votre code ou dans l'algorithme de g√©n√©ration (g√©n√©ralement dans le v√¥tre, bien s√ªr )  Et √† partir de l√†, le probl√®me de d√©bogage se pose - vous devez d√©boguer votre propre code. </p><br><p>  La seconde - pour ex√©cuter une application √©crite dans le framework avec la compilation AOT, vous avez besoin d'un outil sp√©cial.  Vous ne pouvez pas simplement obtenir et ex√©cuter une application √©crite en Quarkus, par exemple.  Nous avons besoin d'un plugin sp√©cial pour maven / gradle, qui pr√©-traitera votre code.  Et maintenant, en cas d'erreurs dans le framework, vous devez mettre √† jour non seulement les biblioth√®ques, mais aussi le plugin. </p><br><p>  En v√©rit√©, la g√©n√©ration de code n'est pas non plus nouvelle dans le monde Java; elle n'est pas apparue avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Micronaut</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quarkus</a> .  Sous une forme ou une autre, certains frameworks l'utilisent.  Ici, nous pouvons rappeler lombok, aspectj avec sa g√©n√©ration pr√©liminaire de code pour aspects ou eclipselink, qui ajoute du code aux classes d'entit√© pour une d√©s√©rialisation plus efficace.  Chez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CUBA,</a> nous utilisons la g√©n√©ration de code pour g√©n√©rer des √©v√©nements sur les changements dans l'√©tat d'une entit√© et pour inclure des messages de validateur dans le code de classe pour simplifier le travail avec les entit√©s dans l'interface utilisateur. </p><br><p>  Pour les d√©veloppeurs CUBA, l'impl√©mentation de la g√©n√©ration de code statique pour les gestionnaires d'√©v√©nements serait une √©tape extr√™me car de nombreuses modifications devaient √™tre apport√©es √† l'architecture interne et au plugin pour la g√©n√©ration de code.  Y a-t-il quelque chose qui ressemble √† de la r√©flexion mais plus rapide? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory - m√™mes appels de m√©thode, mais plus rapide </h2><br><p>  Java 7 a introduit une nouvelle instruction pour la JVM - <code>invokedynamic</code> .  √Ä son sujet, il y a un excellent rapport de Vladimir Ivanov sur jug.ru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Con√ßue √† l'origine pour √™tre utilis√©e dans des langages dynamiques comme Groovy, cette instruction √©tait un excellent candidat pour invoquer des m√©thodes en Java sans utiliser la r√©flexion.  Parall√®lement √† la nouvelle instruction, une API associ√©e est apparue dans le JDK: </p><br><ul><li>  Class <code>MethodHandle</code> - est r√©apparu en Java 7, mais n'est pas encore tr√®s souvent utilis√© </li><li>  <code>LambdaMetafactory</code> - cette classe est d√©j√† de Java 8, elle est devenue un d√©veloppement ult√©rieur de l'API pour les appels dynamiques, utilise <code>MethodHandle</code> int√©rieur. </li></ul><br><p>  Il semblait que <code>MethodHandle</code> , √©tant essentiellement un pointeur typ√© vers une m√©thode (constructeur, etc.), serait capable de jouer le r√¥le de <code>java.lang.reflect.Method</code> .  Et les appels seront plus rapides, car toutes les v√©rifications de type qui sont effectu√©es dans l'API Reflection avec chaque appel, dans ce cas, ne sont effectu√©es qu'une seule fois, lorsque le <code>MethodHandle</code> . </p><br><p>  Mais h√©las, le pur <code>MethodHandle</code> s'est av√©r√© encore plus lent que les appels via l'API de r√©flexion.  Des gains de performances peuvent √™tre obtenus en rendant <code>MethodHandle</code> statique, mais pas dans tous les cas.  Il y a une excellente discussion sur la vitesse des appels <code>MethodHandle</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur la liste de diffusion OpenJDK</a> . </p><br><p>  Mais lorsque la classe <code>LambdaMetafactory</code> , il y avait une r√©elle chance d'acc√©l√©rer les appels de m√©thode.  <code>LambdaMetafactory</code> permet de cr√©er un objet lambda et d'envelopper un appel de m√©thode direct, qui peut √™tre obtenu via le <code>MethodHandle</code> .  Et puis, en utilisant l'objet g√©n√©r√©, vous pouvez appeler la m√©thode souhait√©e.  Voici un exemple de la g√©n√©ration qui encapsule la m√©thode getter pass√©e en param√®tre √† BiFunction: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  En cons√©quence, nous obtenons une instance de BiFunction au lieu de Method.  Et maintenant, m√™me si nous avons utilis√© Method dans notre code, le remplacer par BiFunction n'est pas difficile.  Prenez le vrai code (l√©g√®rement simplifi√©, vrai) pour appeler le gestionnaire de m√©thode, marqu√© <code>@EventListener</code> dans Spring Framework: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  Et voici le m√™me code, mais qui utilise un appel de m√©thode via un lambda: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Modifications minimes, la fonctionnalit√© est la m√™me, mais elle pr√©sente des avantages: </p><br><p>  <em>Un lambda a un type</em> - il est sp√©cifi√© lors de la cr√©ation, donc appeler "juste une m√©thode" √©chouera. </p><br><p>  <em>La pile de trace est plus courte</em> - lors de l'appel d'une m√©thode via un lambda, un seul appel suppl√©mentaire est ajout√© - <code>apply()</code> .  Et c'est tout.  Ensuite, la m√©thode elle-m√™me est appel√©e. </p><br><p>  Mais la vitesse doit √™tre mesur√©e. </p><br><h3 id="zameryaem-skorost">  Mesurer la vitesse </h3><br><p>  Pour tester l'hypoth√®se, nous avons fait un microbenchmark en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JMH</a> pour comparer le temps d'ex√©cution et le d√©bit lors de l'appel de la m√™me m√©thode de diff√©rentes mani√®res: via l'API de r√©flexion, via LambdaMetafactory, et avons √©galement ajout√© un appel de m√©thode direct pour comparaison.  Des liens vers la m√©thode et les lambdas ont √©t√© cr√©√©s et mis en cache avant le d√©but du test. </p><br><p>  Param√®tres de test: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  Le test lui-m√™me peut √™tre t√©l√©charg√© depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> et ex√©cut√© par vous-m√™me, si vous √™tes int√©ress√©. </p><br><p>  R√©sultats des tests pour Oracle JDK 11.0.2 et JMH 1.21 (les chiffres peuvent varier, mais la diff√©rence reste notable et √† peu pr√®s la m√™me): </p><br><table><thead><tr><th>  <strong>Test - Obtenez de la valeur</strong> </th><th>  <strong>D√©bit (ops / us)</strong> </th><th>  <strong>Temps d'ex√©cution (us / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0,0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0,0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0,0048 </td></tr><tr><td>  <strong>Test - D√©finir la valeur</strong> </td><td>  <strong>D√©bit (ops / us)</strong> </td><td>  <strong>Temps d'ex√©cution (us / op</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0,0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0,0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0,0031 </td></tr></tbody></table><br><p>  En moyenne, il s'est av√©r√© que l'appel d'une m√©thode via un lambda est environ 30% plus rapide que via une API de r√©flexion.  Il y a une autre grande discussion sur les performances d'invocation de m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> si quelqu'un est int√©ress√© par les d√©tails.  En bref - le gain de vitesse est obtenu, entre autres, du fait que les lambdas g√©n√©r√©s peuvent √™tre ins√©r√©s dans le code du programme, et les v√©rifications de type ne sont pas encore effectu√©es, contrairement √† la r√©flexion. </p><br><p>  Bien s√ªr, ce benchmark est assez simple, il n'inclut pas les m√©thodes d'appel dans une hi√©rarchie de classes ou mesure la vitesse d'appel des m√©thodes finales.  Mais nous avons fait des mesures plus complexes, et les r√©sultats ont toujours √©t√© en faveur de l'utilisation de LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Utiliser </h2><br><p>  Dans le cadre de la version 7 de CUBA, dans les contr√¥leurs d'interface utilisateur, vous pouvez utiliser l'annotation <code>@Subscribe</code> pour ¬´signer¬ª une m√©thode pour certains √©v√©nements d'interface utilisateur.  En interne, cela est impl√©ment√© sur <code>LambdaMetafactory</code> , des liens vers les m√©thodes d'√©coute sont cr√©√©s et mis en cache lors du premier appel. </p><br><p>  Cette innovation a permis de clarifier consid√©rablement le code, notamment dans le cas de formulaires avec un grand nombre d'√©l√©ments, une interaction complexe et, par cons√©quent, avec un grand nombre de gestionnaires d'√©v√©nements.  Un exemple simple de CUBA QuickStart: Imaginez que vous devez recalculer le montant de la commande lors de l'ajout ou de la suppression d'articles de produit.  Vous devez √©crire du code qui ex√©cute la m√©thode <code>calculateAmount()</code> lorsque la collection change dans l'entit√©.  √Ä quoi cela ressemblait avant: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  Et dans CUBA 7, le code ressemble √† ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  Conclusion: le code est plus propre et il n'y a pas de m√©thode magique <code>init()</code> , qui a tendance √† se d√©velopper et √† se remplir de gestionnaires d'√©v√©nements avec une complexit√© croissante du formulaire.  Et pourtant - nous n'avons m√™me pas besoin de cr√©er un champ avec le composant auquel nous sommes abonn√©s, CUBA trouvera ce composant par ID. </p><br><h3 id="vyvody">  Conclusions </h3><br><p>  Malgr√© l'√©mergence d'une nouvelle g√©n√©ration de frameworks avec compilation AOT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Micronaut</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quarkus</a> ), qui ont des avantages ind√©niables par rapport aux frameworks ¬´traditionnels¬ª (principalement, ils sont compar√©s √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring</a> ), il y a toujours une √©norme quantit√© de code √©crit en utilisant l'API de r√©flexion (et merci pour le m√™me printemps).  Et il semble que Spring Framework soit actuellement encore le leader parmi les frameworks de d√©veloppement d'applications et nous travaillerons avec du code bas√© sur la r√©flexion pendant longtemps. </p><br><p>  Et si vous songez √† utiliser l'API Reflection dans votre code - qu'il s'agisse d'une application ou d'un framework - r√©fl√©chissez-y √† deux fois.  Tout d'abord, sur la g√©n√©ration de code, puis sur MethodHandles / LambdaMetafactory.  La deuxi√®me m√©thode peut s'av√©rer plus rapide et les efforts de d√©veloppement ne seront pas d√©pens√©s plus que dans le cas de l'utilisation de l'API Reflection. </p><br><p>  <em>Quelques liens plus utiles:</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une alternative plus rapide √† Java Reflection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Piratage d'expressions Lambda en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Handles de m√©thode en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Reflection, mais beaucoup plus rapide</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi LambdaMetafactory est 10% plus lent qu'un MethodHandle statique mais 80% plus rapide qu'un MethodHandle non statique?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trop rapide, trop m√©gamorphique: qu'est-ce qui influence les performances des appels de m√©thode en Java?</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447022/">https://habr.com/ru/post/fr447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447010/index.html">Pas pour longtemps la musique jou√©e ... ou comment l'OS Elbrus n'est jamais devenu gratuit</a></li>
<li><a href="../fr447014/index.html">Structures de r√©f√©rence jetables en C # 8.0</a></li>
<li><a href="../fr447016/index.html">25 ans plus tard: une entrevue avec Linus Torvalds</a></li>
<li><a href="../fr447018/index.html">L'enrichissement quantique dans une interpr√©tation multi-monde</a></li>
<li><a href="../fr447020/index.html">La productivit√© n'est pas une question de gestion du temps, mais de gestion de l'attention</a></li>
<li><a href="../fr447024/index.html">Comment combiner les avantages d'un ordinateur portable et d'un ordinateur de bureau? Analyse du probl√®me et des solutions</a></li>
<li><a href="../fr447026/index.html">Nous √©crivons le chargeur OTA pour ATmega128RFA1 (dans le cadre de l'appareil Smart Response XE)</a></li>
<li><a href="../fr447028/index.html">Anciens fichiers de st√©ganographie: nous masquons les donn√©es directement dans les secteurs</a></li>
<li><a href="../fr447034/index.html">Un nouveau bug dans Telegram Desktop vous permet de lire le dernier message</a></li>
<li><a href="../fr447036/index.html">Un cocktail pour une alimentation saine - il est √©labor√© par une startup de l'acc√©l√©rateur de l'ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>