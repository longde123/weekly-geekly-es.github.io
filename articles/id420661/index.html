<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘Ÿ ğŸ”¥ ğŸ¤¦ğŸ¼ Infrastruktur cloud berkelanjutan ğŸ’† ğŸ¤³ğŸ» ğŸ§—ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Demonstrasi penggunaan alat sumber terbuka seperti Packer dan Terraform untuk terus memberikan perubahan infrastruktur ke lingkungan cloud favorit pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastruktur cloud berkelanjutan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420661/"> Demonstrasi penggunaan alat sumber terbuka seperti Packer dan Terraform untuk terus memberikan perubahan infrastruktur ke lingkungan cloud favorit pengguna. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FJvl13EYtBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Materi tersebut didasarkan pada presentasi oleh Paul Stack pada konferensi musim gugur kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOops</a> 2017. Paul adalah pengembang infrastruktur yang dulu bekerja di HashiCorp dan berpartisipasi dalam mengembangkan alat yang digunakan oleh jutaan orang (misalnya, Terraform).  Dia sering berbicara di konferensi dan menyampaikan praktik dari garis depan implementasi CI / CD, prinsip-prinsip organisasi yang tepat dari bagian operasi, dan mampu menjelaskan dengan jelas mengapa administrator melakukan ini.  Sisa artikel ini diriwayatkan sebagai orang pertama. <br><a name="habracut"></a><br>  Jadi, mari kita mulai segera dengan beberapa temuan kunci. <br><br><h3>  Server yang berjalan lama menyebalkan </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7f5/1dc/232/7f51dc232bf87288dc7f5c1bf7140a0d.jpg"><br><br>  Saya sebelumnya bekerja di sebuah organisasi di mana kami menggunakan Windows Server 2003 pada tahun 2008, dan hari ini mereka masih dalam produksi.  Dan perusahaan semacam itu tidak sendirian.  Menggunakan desktop jarak jauh pada server ini, mereka menginstal perangkat lunak secara manual, mengunduh file biner dari Internet.  Ini adalah ide yang sangat buruk, karena servernya tidak tipikal.  Anda tidak dapat menjamin bahwa hal yang sama terjadi dalam produksi seperti di lingkungan pengembangan Anda, di lingkungan menengah, di lingkungan QA. <br><br><h3>  Infrastruktur Tidak Berubah </h3><br>  Pada 2013, artikel Chad Foiler muncul di blog Chad Foiler berjudul "Lempar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server Anda dan bakar kode Anda: infrastruktur yang tidak dapat diubah dan komponen yang dapat dibuang"</a> .  Ini sebagian besar adalah percakapan bahwa infrastruktur abadi adalah jalan ke depan.  Kami telah menciptakan infrastruktur, dan jika kami perlu mengubahnya, kami membuat infrastruktur baru.  Pendekatan ini sangat umum di cloud, karena ini cepat dan murah.  Jika Anda memiliki pusat data fisik, ini sedikit rumit.  Jelas, jika Anda menjalankan virtualisasi pusat data, segalanya menjadi lebih mudah.  Namun, jika Anda masih menjalankan server fisik setiap kali, dibutuhkan waktu lebih lama untuk memasukkan yang baru daripada memodifikasi yang sudah ada. <br><br><h3>  Infrastruktur Sekali Pakai </h3><br>  Menurut programmer fungsional, "immutable" sebenarnya adalah istilah yang salah untuk fenomena ini.  Karena agar benar-benar tidak dapat diubah, infrastruktur Anda memerlukan sistem file hanya baca: tidak ada file yang akan ditulis secara lokal, tidak ada yang akan dapat menggunakan SSH atau RDP, dll.  Jadi, nampaknya infrastruktur itu tidak berubah. <br><br>  Terminologi itu dibahas di Twitter selama enam atau bahkan delapan hari oleh beberapa orang.  Pada akhirnya, mereka sepakat bahwa "infrastruktur satu kali" adalah formulasi yang lebih tepat.  Ketika siklus hidup "infrastruktur satu kali" berakhir, ia dapat dengan mudah dihancurkan.  Anda tidak perlu mempertahankannya. <br><br>  Saya akan memberikan analogi.  Sapi pertanian umumnya tidak dianggap sebagai hewan peliharaan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be9/a17/baf/be9a17baf223a45e34c63684197cc2ce.png"><br><br>  Ketika Anda memiliki ternak di pertanian, Anda tidak memberi mereka nama individu.  Setiap individu memiliki nomor dan tag.  Begitu pula dengan server.  Jika Anda masih memiliki server yang dibuat secara manual dalam produksi pada tahun 2006, mereka memiliki nama yang signifikan, misalnya, "SQL Database on Production 01".  Dan mereka memiliki arti yang sangat spesifik.  Dan jika salah satu server crash, neraka dimulai. <br><br>  Jika salah satu hewan dalam kawanan mati, peternak hanya membeli yang baru.  Ini adalah "infrastruktur satu kali." <br><br><h3>  Pengiriman terus menerus </h3><br>  Jadi, bagaimana Anda menggabungkan ini dengan Pengiriman Berkelanjutan? <br>  Semua yang saya bicarakan sekarang telah ada selama beberapa waktu.  Saya hanya mencoba menggabungkan ide pengembangan infrastruktur dan pengembangan perangkat lunak. <br><br>  Pengembang perangkat lunak telah lama berkomitmen untuk pengiriman berkelanjutan dan integrasi berkelanjutan.  Sebagai contoh, Martin Fowler menulis tentang integrasi berkelanjutan di blog-nya pada awal 2000-an.  Jez Humble telah lama mempromosikan pengiriman berkelanjutan. <br><br>  Jika Anda melihat lebih dekat, tidak ada yang dibuat khusus untuk kode sumber perangkat lunak.  Ada definisi standar dari Wikipedia: <i>pengiriman berkelanjutan adalah serangkaian praktik dan prinsip yang bertujuan untuk membuat, menguji, dan merilis perangkat lunak secepat mungkin</i> . <br><br>  Definisi ini tidak berarti aplikasi web atau API, ini tentang perangkat lunak secara umum.  Membuat perangkat lunak teka-teki membutuhkan banyak potongan puzzle.  Dengan cara ini Anda dapat mempraktikkan pengiriman berkelanjutan untuk kode infrastruktur dengan cara yang sama. <br><br>  Pengembangan infrastruktur dan aplikasi adalah arah yang cukup dekat.  Dan orang yang menulis kode aplikasi juga menulis kode infrastruktur (dan sebaliknya).  Dunia-dunia ini mulai bersatu.  Tidak ada lagi pemisahan dan perangkap khusus dari masing-masing dunia. <br><br><h3>  Prinsip dan Praktik Pengiriman Berkelanjutan </h3><br>  Pengiriman berkelanjutan memiliki sejumlah prinsip: <br><br><ul><li>  Proses rilis / penyebaran perangkat lunak harus dapat diulang dan dapat diandalkan. <br></li><li>  Otomatiskan semuanya! <br></li><li>  Jika suatu prosedur sulit atau menyakitkan, lakukan lebih sering. <br></li><li>  Simpan semuanya di kontrol sumber. <br></li><li>  Selesai - berarti "belum dirilis". <br></li><li>  Padukan pekerjaan dengan kualitas! <br></li><li>  Setiap orang bertanggung jawab untuk proses rilis. <br></li><li>  Tingkatkan kontinuitas. <br></li></ul><br>  Tetapi yang lebih penting, pengiriman berkelanjutan memiliki empat praktik.  Bawa mereka dan transfer langsung ke infrastruktur: <br><br><ul><li>  Buat file biner hanya sekali.  Bangun server Anda sekali.  Di sini kita berbicara tentang "disposability" dari awal. <br></li><li>  Gunakan mekanisme penyebaran yang sama di setiap lingkungan.  Jangan mempraktikkan penyebaran yang berbeda dalam pengembangan dan produksi.  Anda harus menggunakan jalur yang sama di setiap lingkungan.  Ini sangat penting. <br></li><li>  Uji penyebaran Anda.  Saya telah membuat banyak aplikasi.  Saya menciptakan banyak masalah karena saya tidak mengikuti mekanisme penyebaran.  Anda harus selalu memeriksa apa yang terjadi.  Dan saya tidak mengatakan bahwa Anda harus menghabiskan lima atau enam jam untuk pengujian skala besar.  Cukup "tes asap".  Anda memiliki bagian penting dari sistem, yang, seperti Anda ketahui, memungkinkan Anda dan perusahaan Anda menghasilkan uang.  Jangan terlalu malas untuk memulai pengujian.  Jika tidak, mungkin ada gangguan yang akan membebani perusahaan Anda. <br></li><li>  Dan akhirnya, hal yang paling penting.  Jika ada yang rusak, segera hentikan dan perbaiki!  Anda tidak bisa membiarkan masalah tumbuh dan menjadi semakin buruk.  Anda harus memperbaikinya.  Ini sangat penting. <br></li></ul><br>  Adakah yang membaca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman berkelanjutan</a> ? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cad/9eb/b6f/cad9ebb6f6c3562724d78ef5a0454e7e.png"><br><br>  Saya yakin perusahaan Anda akan membayar Anda salinan yang dapat Anda transfer dalam tim.  Saya tidak mengatakan bahwa Anda harus duduk dan menghabiskan hari libur membacanya.  Jika ya, Anda mungkin ingin keluar dari IT.  Tetapi saya merekomendasikan untuk secara berkala menguasai bagian-bagian kecil dari buku ini, mencernanya dan memikirkan cara memindahkannya ke lingkungan Anda, ke budaya Anda dan ke proses Anda.  Sepotong kecil sekaligus.  Karena pasokan berkelanjutan adalah percakapan tentang peningkatan berkelanjutan.  Tidak mudah untuk duduk di kantor bersama kolega dan bos dan memulai percakapan dengan pertanyaan: "Bagaimana kita akan menerapkan pengiriman berkelanjutan?", Kemudian tulis 10 hal di papan tulis dan setelah 10 hari pahami bahwa Anda menerapkannya.  Ini membutuhkan banyak waktu, menyebabkan banyak protes, karena dengan diperkenalkannya perubahan budaya. <br><br>  Hari ini kita akan menggunakan dua alat: Terraform dan Packer (keduanya adalah pengembangan Hashicorp).  Diskusi lebih lanjut akan tentang mengapa kita harus menggunakan Terraform dan bagaimana mengintegrasikannya ke lingkungan kita.  Bukan kebetulan saya berbicara tentang dua alat ini.  Sampai baru-baru ini, saya juga bekerja di Hashicorp.  Tetapi bahkan setelah saya meninggalkan Hashicorp, saya masih berkontribusi pada kode alat-alat ini, karena saya benar-benar merasa sangat berguna. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/4b0/807/5d04b08076e6d28da7cc17589d79de6d.png"><br><br>  Terraform mendukung interaksi dengan penyedia.  Penyedia adalah cloud, layanan Saas, dll. <br><br>  Di dalam setiap penyedia layanan cloud, ada beberapa sumber daya, seperti subnet, VPC, load balancer, dll. Menggunakan DSL (bahasa khusus domain), Anda memberi tahu Terraform seperti apa infrastruktur Anda nantinya. <br><br>  Terraform menggunakan teori grafik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c7/142/7d2/1c71427d2d18431acfe78d79797f9948.png"><br><br>  Anda mungkin tahu teori grafik.  Node adalah bagian dari infrastruktur kami, seperti load balancer, subnet, atau VPC.  Iga adalah hubungan antara sistem ini.  Ini semua yang saya pribadi anggap perlu diketahui tentang teori grafik untuk menggunakan Terraform.  Kami serahkan sisanya pada ahlinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/db7/fe6/8dedb7fe6a72bd36d371f3576e841cfa.png"><br><br>  Terraform sebenarnya menggunakan grafik terarah karena ia tahu tidak hanya hubungan, tetapi juga urutannya: bahwa A (misalkan A adalah VPC) harus disetel ke B, yang merupakan subnet.  Dan B harus dibuat sebelum C (instance), karena ada prosedur yang ditentukan untuk membuat abstraksi di Amazon atau cloud lainnya. <br>  Informasi lebih lanjut tentang topik ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YouTube oleh</a> Paul Hinze, yang masih menjadi Direktur Infrastruktur di Hashicorp.  Dengan referensi - percakapan yang hebat tentang infrastruktur dan teori grafik. <br><br><h3>  Berlatih </h3><br>  Menulis kode jauh lebih baik daripada mendiskusikan teori. <br><br>  Saya sebelumnya membuat AMI (Gambar Mesin Amazon).  Saya menggunakan Packer untuk membuatnya dan akan menunjukkan kepada Anda bagaimana melakukannya. <br><br>  AMI adalah turunan dari server virtual di Amazon, sudah ditentukan sebelumnya (dalam hal konfigurasi, aplikasi, dll.) Dan dibuat dari gambar.  Saya suka bahwa saya dapat membuat AMI baru.  Pada dasarnya, AMI adalah wadah Docker saya. <br><br>  Jadi, saya punya AMI, mereka punya ID.  Pergi ke antarmuka Amazon, kami melihat bahwa kami hanya memiliki satu AMI dan tidak lebih: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b65/563/4cbb65563af0eea258e8c5cdc936a318.png"><br><br>  Saya bisa menunjukkan kepada Anda apa yang ada dalam AMI ini.  Semuanya sangat sederhana. <br><br>  Saya memiliki templat file JSON: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"variables"</span></span>: { <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, <span class="hljs-string"><span class="hljs-string">"builders"</span></span>: [{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"amazon-ebs"</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'region'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'source_ami'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_pty"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"t2.micro"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_username"</span></span>: <span class="hljs-string"><span class="hljs-string">"ubuntu"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"associate_public_ip_address"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_virtualization_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hvm"</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"application_instance-{{isotime \"2006-01-02-1504\"}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>: { <span class="hljs-string"><span class="hljs-string">"Version"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'version'}}"</span></span> } }], <span class="hljs-string"><span class="hljs-string">"provisioners"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"10m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo apt-get update -y"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo apt-get install -y ntp nginx"</span></span> ] }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/nginx.conf"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/index.html"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo mkdir -p /usr/share/nginx/html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/index.html /usr/share/nginx/html/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/nginx.conf /etc/nginx/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo systemctl enable nginx.service"</span></span> ] } ] }</code> </pre> <br>  Kami memiliki variabel yang kami lewati, dan Packer memiliki daftar yang disebut Builder untuk area yang berbeda;  ada banyak dari mereka.  Builder menggunakan sumber AMI khusus, yang saya berikan dalam pengenal AMI.  Saya memberinya nama pengguna dan kata sandi SSH, dan juga menunjukkan apakah ia memerlukan alamat IP publik sehingga orang dapat mengaksesnya dari luar.  Dalam kasus kami, ini tidak terlalu penting, karena ini adalah contoh AWS untuk Packer. <br>  Kami juga menetapkan nama dan tag AMI. <br><br>  Anda tidak perlu menguraikan kode ini.  Dia di sini hanya untuk menunjukkan kepada Anda bagaimana dia bekerja.  Bagian terpenting di sini adalah versinya.  Ini akan menjadi relevan nanti ketika kita memasuki Terraform. <br><br>  Setelah builder memanggil instance, agen provisi diluncurkan di atasnya.  Saya sebenarnya menginstal NCP dan nginx untuk menunjukkan kepada Anda apa yang dapat saya lakukan di sini.  Saya menyalin beberapa file dan hanya mengatur konfigurasi nginx.  Semuanya sangat sederhana.  Lalu saya aktifkan nginx sehingga dimulai saat instance dimulai. <br><br>  Jadi, saya punya server aplikasi dan berfungsi.  Saya bisa menggunakannya di masa depan.  Namun, saya selalu memeriksa templat Packer saya.  Karena ini adalah konfigurasi JSON di mana Anda mungkin mengalami beberapa masalah. <br>  Untuk melakukan ini, saya menjalankan perintah: <br><br> <code>make validate <br></code> <br>  Saya mendapatkan jawaban bahwa templat Packer berhasil diverifikasi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f0/aa3/1a7/2f0aa31a768c26246877688d0c81cc9e.png"><br><br>  Ini hanya sebuah perintah, jadi saya bisa menghubungkannya ke alat CI (siapa pun).  Bahkan, itu akan menjadi proses: jika pengembang mengubah templat, permintaan tarikan dihasilkan, alat CI akan memeriksa permintaan, melakukan yang setara dengan memeriksa templat dan menerbitkan templat jika berhasil verifikasi.  Semua ini dapat digabungkan dalam "Master". <br>  Kami mendapatkan aliran untuk template AMI - Anda hanya perlu meningkatkan versinya. <br><br>  Misalkan pengembang telah membuat versi baru AMI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/3b9/546/dc93b95464ccf7b7e6fbe959d4a5ddf0.png"><br><br>  Saya hanya akan memperbaiki versi dalam file dari 1.0.0 ke 1.0.1 untuk menunjukkan kepada Anda perbedaan: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Version: 1.0.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Saya akan kembali ke baris perintah dan memulai pembuatan AMI. <br>  Saya tidak suka menjalankan tim yang sama.  Saya suka membuat AMI dengan cepat, jadi saya menggunakan makefiles.  Mari kita lihat bersama <code>cat</code> di makefile saya: <br><br> <code>cat Makefile <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/163/0e4/bea/1630e4bea410b10ffcbb5fce2a27d595.png"><br><br>  Ini makefile saya.  Saya bahkan memberikan Bantuan: Saya mengetik <code>make</code> dan klik tab, dan itu menunjukkan kepada saya semua target. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74d/cbb/611/74dcbb6110c7350483735a0f96d9fe90.png"><br><br>  Jadi, kita akan membuat versi AMI baru 1.0.1. <br><br> <code>make ami <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/879/16c/482/87916c482f6410c8a2fc73c150308409.png"><br><br>  Kembali ke Terraform. <br><br>  Saya menekankan bahwa ini bukan kode produksi.  Ini sebuah demonstrasi.  Ada cara untuk melakukan hal yang sama dengan lebih baik. <br><br>  Saya menggunakan modul Terraform di mana-mana.  Karena saya tidak lagi bekerja di Hashicorp, jadi saya bisa mengutarakan pendapat saya tentang modul.  Bagi saya, modul berada pada level enkapsulasi.  Misalnya, saya ingin merangkum semua yang berhubungan dengan VPC: jaringan, subnet, tabel perutean, dll. <br><br>  Apa yang sedang terjadi di dalam?  Pengembang yang bekerja dengan ini mungkin tidak peduli.  Mereka perlu memiliki pemahaman dasar tentang bagaimana cloud bekerja, apa itu VPC.  Tetapi tidak perlu mempelajari detailnya.  Hanya orang yang benar-benar perlu mengganti modul yang harus memahaminya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/90c/b85/1a890cb85c3fb6a6580e8b6a25492f4f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/177/a14/a24/177a14a241d80ee6bcc2cf64f194ce4e.png"><br><br>  Di sini saya akan membuat sumber daya AWS dan modul VPC.  Apa yang sedang terjadi di sini?  Ambil <code>cidr_block</code> tingkat <code>cidr_block</code> dan buat tiga subnet pribadi dan tiga subnet publik.  Berikut ini adalah daftar acilities_zones.  Tetapi kita tidak tahu apa zona aksesibilitas ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26b/ec1/4ea/26bec14eab18a025c33c2a871c4d3ed4.png"><br><br>  Kami akan membuat VPN.  Hanya saja, jangan gunakan modul VPN ini.  Ini adalah openVPN, yang membuat satu instance AWS yang tidak memiliki sertifikat.  Hanya menggunakan alamat IP publik dan disebutkan di sini hanya untuk menunjukkan kepada Anda bahwa kami dapat terhubung ke VPN.  Ada alat yang lebih nyaman untuk membuat VPN.  Butuh waktu sekitar 20 menit dan dua bir untuk menulis sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae3/a5f/8a6/ae3a5f8a6561b2b9f726e2e129dfcb2f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/6a8/f0e/7b9/6a8f0e7b965f44255365d50ad64669e0.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/078/e4c/073/078e4c073df61b68e97372c7e4730f5b.png"><br><br>  Lalu kami membuat <code>application_tier</code> , yang merupakan grup penskalaan otomatis - penyeimbang beban.  Beberapa konfigurasi startup didasarkan pada AMI-ID, dan menggabungkan beberapa subnet dan zona ketersediaan, dan juga menggunakan kunci SSH. <br>  Mari kita kembali ke ini sebentar lagi. <br><br>  Saya sudah menyebutkan zona ketersediaan.  Mereka berbeda untuk akun AWS yang berbeda.  Akun saya di AS di Timur mungkin memiliki akses ke zona A, B, dan D. Akun AWS Anda mungkin memiliki akses ke B, C dan E. Jadi, dengan memperbaiki nilai-nilai ini dalam kode, kami akan menghadapi masalah.  Kami di Hashicorp menyarankan agar kami dapat membuat sumber data sedemikian sehingga kami dapat bertanya kepada Amazon apa yang tersedia bagi kami.  Di bawah tenda, kami meminta deskripsi tentang zona ketersediaan, dan kemudian mengembalikan daftar semua zona untuk akun Anda.  Berkat ini, kami dapat menggunakan sumber data untuk AMI. <br><br>  Sekarang kita sampai ke bagian bawah demonstrasi saya.  Saya membuat grup penskalaan otomatis yang menjalankan tiga instance.  Secara default, mereka semua memiliki versi 1.0.0. <br><br>  Ketika kami menggunakan versi baru AMI, saya akan memulai konfigurasi Terraform lagi, ini akan mengubah konfigurasi peluncuran, dan layanan baru akan menerima versi kode berikutnya, dll. Dan kita bisa mengendalikannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53e/030/d08/53e030d08a8820f28ce8970bdb2bcee8.png"><br><br>  Kami melihat bahwa Packer selesai dan kami memiliki AMI baru. <br>  Saya kembali ke Amazon, menyegarkan halaman dan melihat AMI kedua. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab7/966/88d/ab796688d7e117c00b12343d54547a3a.png"><br><br>  Kembali ke Terraform. <br><br>  Dimulai dengan versi 0.10, Terraform telah membagi penyedia menjadi repositori terpisah.  Dan perintah <code>init terraform</code> mendapatkan salinan dari penyedia yang diperlukan untuk dijalankan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a71/f24/5c1/a71f245c166bffd9cce8d2da21612bb3.png"><br><br>  Penyedia dimuat.  Kami siap bergerak maju. <br>  Selanjutnya kita harus menjalankan <code>terraform get</code> - load modul yang diperlukan.  Mereka sekarang di mesin lokal saya.  Jadi Terraform akan mendapatkan semua modul secara lokal.  Secara umum, modul dapat disimpan di repositori mereka sendiri di GitHub atau di tempat lain.  Itu sebabnya saya berbicara tentang modul VPC.  Anda dapat memberi akses tim jaringan untuk membuat perubahan.  Dan ini adalah API untuk tim pengembangan untuk bekerja dengannya.  Sangat membantu. <br><br>  Langkah selanjutnya adalah membuat grafik. <br><br>  Mulai dengan <br><br> <code>terraform plan <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/852/ea8/854852ea82a25694dbef99af5832eb27.png"><br><br>  Terraform akan mengambil status lokal saat ini dan membandingkannya dengan akun AWS, yang menunjukkan perbedaan.  Dalam kasus kami, dia akan menciptakan 35 sumber daya baru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ce/d53/2cc/3ced532cc5cbe65758669980fda88f9e.png"><br><br>  Sekarang kami menerapkan perubahan: <br><br> <code>terraform apply <br></code> <br><br>  Anda tidak harus melakukan semua ini dari mesin lokal.  Ini hanya perintah, meneruskan variabel ke Terraform.  Anda dapat mengirimkan proses ini ke alat CI. <br>  Jika Anda ingin memindahkan ini ke CI, Anda harus menggunakan kondisi jarak jauh.  Saya ingin semua orang yang pernah menggunakan Terraform bekerja dengan negara terpencil.  Tolong jangan gunakan negara bagian. <br><br>  Salah satu teman saya mencatat bahwa bahkan setelah bertahun-tahun bekerja dengan Terraform, dia masih menemukan sesuatu yang baru.  Misalnya, jika Anda membuat instance AWS, Anda harus memberikannya dengan kata sandi, dan itu dapat menyimpannya di negara Anda.  Ketika saya bekerja di Hashicorp, kami berasumsi bahwa akan ada proses kolaboratif yang mengubah kata sandi ini.  Karena itu, jangan mencoba menyimpan semuanya secara lokal.  Dan kemudian Anda bisa memasukkan semua ini ke dalam alat CI. <br><br>  Jadi, infrastruktur dibuat untuk saya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/040/c1d/c55040c1d4544a4d7c53f77a494c2be7.png"><br><br>  Terraform dapat membuat grafik: <br><br> <code>terraform graph <br></code> <br><br>  Seperti yang saya katakan, dia sedang membangun pohon.  Bahkan, ini memberi Anda kesempatan untuk mengevaluasi apa yang terjadi di infrastruktur Anda.  Dia akan menunjukkan kepada Anda hubungan antara semua bagian yang berbeda - semua simpul dan tepi.  Karena koneksi memiliki arah, kita berbicara tentang grafik yang diarahkan. <br><br>  Grafik akan menjadi daftar JSON yang dapat disimpan dalam file PNG atau DOC. <br><br>  Kembali ke Terraform.  Kami benar-benar membuat grup penskalaan otomatis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/253/799/9fe253799368629b6c98d7472cbc3634.png"><br><br>  Grup penskalaan otomatis memiliki kapasitas 3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0dd/2a3/e47/0dd2a3e47ef49ba119c37c6ee1118fe9.png"><br><br>  Pertanyaan yang menarik: dapatkah kita menggunakan Vault untuk mengelola rahasia di Terraform?  Sayangnya, tidak.  Tidak ada sumber data Vault untuk membaca rahasia di Terraform.  Ada cara lain, seperti variabel lingkungan.  Dengan bantuan mereka, Anda tidak perlu memasukkan rahasia ke dalam kode, Anda dapat membacanya sebagai variabel lingkungan. <br><br>  Jadi, kami memiliki beberapa fasilitas infrastruktur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/2ef/61e/1072ef61ea789635cb6e9894005734b2.png"><br><br>  Saya memasukkan VPN sangat rahasia saya (jangan buka VPN saya). <br><br>  Yang paling penting di sini adalah bahwa kita memiliki tiga contoh aplikasi.  Benar, saya seharusnya mencatat versi aplikasi mana yang berjalan pada mereka.  Ini sangat penting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/009/bef/b7d/009befb7dcb30e11c9454e3b27f036cf.png"><br>  Semuanya benar-benar ada di belakang VPN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9f/5d3/e43/b9f5d3e436b981cfc21db8e42b782db5.png"><br><br>  Jika saya mengambil ini ( <code>application-elb-1069500747.eu-west-1.elb.amazonaws.com</code> ) dan menempelkannya ke bilah alamat browser, saya mendapatkan yang berikut ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/016/40e/203/01640e2034e1cd80ff454b5c6b74c386.png"><br><br>  Biarkan saya mengingatkan Anda bahwa saya terhubung ke VPN.  Jika saya keluar, alamat yang ditentukan tidak akan tersedia. <br>  Kami melihat versi 1.0.0.  Dan tidak peduli berapa banyak kita menyegarkan halaman, kita mendapatkan 1.0.0. <br>  Apa yang terjadi jika saya mengubah versi dari 1.0.0 ke 1.0.1 dalam kode? <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.1"</span></span>] }</code> </pre> <br>  Jelas, alat CI akan memastikan Anda membuat versi yang tepat. <br>  Saya perhatikan tidak ada pembaruan manual!  Kami tidak sempurna, kami membuat kesalahan, dan kami dapat menempatkan versi 1.0.6 bukannya 1.0.1 saat memperbarui secara manual. <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.6"</span></span>] }</code> </pre><br>  Tapi mari kita beralih ke versi kita (1.0.1). <br><br> <code>terraform plan <br></code> <br><br>  Status pembaruan Terraform: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/7f5/221/fb87f522107164e64498825e1e4e0562.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/8ec/61b/c398ec61bfdbd060b526417c56631b14.png"><br><br>  Jadi, pada saat ini dia mengatakan kepada saya bahwa dia akan mengubah versi dalam konfigurasi peluncuran.  Karena perubahan pada pengenal, itu akan memaksa restart konfigurasi, dan grup penskalaan otomatis akan berubah (ini diperlukan untuk mengaktifkan konfigurasi peluncuran baru). <br><br>  Ini tidak mengubah instance yang berjalan.  Ini sangat penting.  Anda dapat mengikuti proses ini dan mengujinya tanpa mengubah instance dalam produksi. <br><br>  Catatan: Anda harus selalu membuat konfigurasi peluncuran baru sebelum menghancurkan yang lama, jika tidak akan ada kesalahan. <br><br>  Mari kita terapkan perubahannya: <br><br> <code>terraform apply <br></code> <br><br>  Sekarang kembali ke AWS.  Ketika semua perubahan diterapkan, kami pergi ke grup penskalaan otomatis. <br>  Mari kita beralih ke konfigurasi AWS.  Kami melihat bahwa ada tiga contoh dengan satu konfigurasi peluncuran.  Mereka sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/365/ae7/49c/365ae749cd5c77ea0634247410b58da6.png"><br><br>  Amazon menjamin bahwa jika kita ingin menjalankan tiga contoh layanan, mereka memang akan diluncurkan.  Itu sebabnya kami membayar mereka uang. <br><br>  Mari kita beralih ke eksperimen. <br><br>  Konfigurasi peluncuran baru telah dibuat.  Karena itu, jika saya menghapus salah satu instance, sisanya tidak akan rusak.  Ini penting.  Namun, jika Anda menggunakan instance secara langsung, saat mengubah data pengguna, ini akan menghancurkan instance "live".  Tolong jangan lakukan ini. <br><br>  Jadi, hapus salah satu contoh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/373/05a/eb337305af7a4e537d2f5963661f909f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/244/711/a7c/244711a7c5beb5edd4863239e2997fc1.png"><br><br>  Apa yang akan terjadi pada grup penskalaan otomatis ketika dimatikan?  Sebuah instance baru akan muncul di tempatnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86d/1dd/8f5/86d1dd8f57f1af6e56ddf9054b777e91.png"><br><br>  Di sini Anda menemukan diri Anda dalam situasi yang menarik.  Mesin virtual akan diluncurkan dengan konfigurasi baru.  Artinya, dalam sistem Anda mungkin memiliki beberapa gambar yang berbeda (dengan konfigurasi yang berbeda).  Terkadang lebih baik untuk tidak segera menghapus konfigurasi startup yang lama agar dapat terhubung sesuai kebutuhan. <br><br>  Di sini semuanya menjadi lebih menarik.  Mengapa tidak melakukannya dengan skrip dan alat CI, dan tidak secara manual, seperti yang saya tunjukkan?  Ada beberapa alat yang bisa melakukan ini, seperti alat AWS yang hilang di GitHub. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/948/2b7/96d/9482b796d437daa84cf7c26dc85aa08f.png"><br><br>  Dan apa yang dilakukan alat ini?  Ini adalah skrip bash yang menelusuri semua instance dalam load balancer, menghancurkannya satu per satu, memastikan penciptaan yang baru di tempatnya. <br>  Jika saya kehilangan salah satu instance saya dengan versi 1.0.0 dan yang baru muncul - 1.1.1, saya ingin membunuh semua 1.0.0, mentransfer semuanya ke versi baru.  Karena saya selalu bergerak maju.  Biarkan saya mengingatkan Anda, saya tidak suka ketika server aplikasi hidup untuk waktu yang lama. <br><br>  Dalam salah satu proyek, setiap tujuh hari, saya memiliki skrip kontrol yang menghancurkan semua instance di akun saya.  Jadi server itu tidak lebih dari tujuh hari.  Hal lain (favorit saya) adalah menandai server sebagai "ternoda" menggunakan SSH dalam kotak dan menghancurkannya setiap jam menggunakan skrip - kami tidak ingin orang melakukannya secara manual. <br><br>  Skrip kontrol semacam itu memungkinkan Anda untuk selalu memiliki versi terbaru dengan bug tetap dan pembaruan keamanan. <br><br>  Anda dapat menggunakan skrip hanya dengan menjalankan: <br><br> <code>aws-ha-relesae.sh -a my-scaling-group <br></code> <br><br>  <code>-a</code> adalah grup penskalaan otomatis Anda.  Script akan melalui semua contoh grup penskalaan otomatis Anda dan menggantinya.  Anda dapat menjalankannya tidak hanya secara manual, tetapi juga dari alat CI. <br>  Anda dapat melakukan ini dalam QA atau dalam produksi.  Anda dapat melakukan ini bahkan di akun AWS lokal Anda.  Anda melakukan apa pun yang Anda inginkan, setiap kali menggunakan mekanisme yang sama. <br><br>  Kembali ke Amazon.  Kami memiliki contoh baru: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4b/1aa/079/f4b1aa079ec971f111abce895d28c771.png"><br><br>  Setelah memperbarui halaman di browser, tempat kami sebelumnya melihat versi 1.0.0, kami mendapatkan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/923/d78/ff4923d78d16d508c0e8bae753044c15.png"><br><br>  Hal yang menarik adalah bahwa sejak kami membuat skrip pembuatan AMI, kami dapat menguji pembuatan AMI. <br><br>  Ada beberapa alat hebat, seperti ServerScript atau Serverspec. <br><br>  Serverspec memungkinkan Anda membuat spesifikasi bergaya-Ruby untuk menguji bagaimana server aplikasi Anda terlihat.  Sebagai contoh, di bawah ini saya memberikan tes yang memeriksa apakah nginx diinstal pada server. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'spec_helper'</span></span> describe package(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_installed } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe service(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { sould be_enabled } it { sould be_running } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe port(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_listening } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Nginx harus diinstal dan dijalankan pada server dan mendengarkan pada port 80.  Anda dapat mengatakan bahwa pengguna X harus tersedia di server.  Dan Anda dapat menempatkan semua tes ini di tempatnya.  Jadi, ketika Anda membuat AMI, alat CI dapat memeriksa apakah AMI ini cocok untuk tujuan tertentu.  Anda akan tahu bahwa AMI siap untuk diproduksi. <br><br><h3>  Alih-alih sebuah kesimpulan </h3><br>  Mary Poppendieck mungkin adalah salah satu wanita paling menakjubkan yang pernah saya dengar.  Pada suatu waktu, dia berbicara tentang bagaimana pengembangan perangkat lunak lean telah berkembang selama bertahun-tahun.  Dan bagaimana ia dikaitkan dengan 3M di tahun 60-an, ketika perusahaan benar-benar terlibat dalam pengembangan lean. <br><br>  Dan dia mengajukan pertanyaan: berapa lama bagi organisasi Anda untuk menyebarkan perubahan yang terkait dengan satu baris kode?  Bisakah Anda membuat proses ini andal dan berulang? <br><br>  Biasanya, pertanyaan ini selalu menyangkut kode perangkat lunak.  Berapa lama saya akan memperbaiki satu kesalahan dalam aplikasi ini ketika digunakan untuk produksi?  Tetapi tidak ada alasan mengapa kita tidak dapat menggunakan pertanyaan yang sama untuk infrastruktur atau database. <br><br>  Saya bekerja untuk sebuah perusahaan bernama OpenTable.  Di dalamnya, kami menyebutnya durasi siklus.  Dan di OpenTable dia berusia tujuh minggu.  Dan ini relatif baik.  Saya tahu perusahaan yang membutuhkan waktu berbulan-bulan untuk mengirim kode untuk produksi.  Di OpenTable, kami meninjau proses selama empat tahun.  Ini memakan banyak waktu, karena organisasi ini besar - 200 orang.  Dan kami mengurangi waktu siklus menjadi tiga menit.  Ini dimungkinkan berkat pengukuran efek transformasi kami. <br><br>  Sekarang semuanya sudah ditulis.  Kami memiliki begitu banyak alat dan contoh, ada GitHub.  Karena itu, ambil ide dari konferensi seperti DevOops, terapkan dalam organisasi Anda.  Jangan mencoba menerapkan semuanya.  Ambil satu benda kecil dan jual.  Tunjukkan pada seseorang.  Dampak perubahan kecil dapat diukur, diukur, dan terus berjalan! <br><blockquote>  Paul Stack akan tiba di St. Petersburg pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOops 2018</a> dengan laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengujian sistem berkelanjutan dengan Kekacauan"</a> .  Paul akan berbicara tentang metodologi Chaos Engineering dan menunjukkan bagaimana menggunakan metodologi ini pada proyek nyata. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420661/">https://habr.com/ru/post/id420661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420651/index.html">Para ilmuwan menemukan bukti tentang preseden yang tidak menyenangkan terkait dengan perubahan iklim</a></li>
<li><a href="../id420653/index.html">Lima hal yang perlu Anda lakukan untuk melengkapi rumah Anda di Mars</a></li>
<li><a href="../id420655/index.html">Robot menyewa apartemen melalui Airbnb untuk belajar cara mengambil barang dengan lebih baik</a></li>
<li><a href="../id420657/index.html">Analisis: pada siapa uang Elon Musk akan dapat menarik Tesla dari bursa</a></li>
<li><a href="../id420659/index.html">Kampanye USB dari HRF (Yayasan Hak Asasi Manusia) â€œFlash Drives for Freedomâ€</a></li>
<li><a href="../id420663/index.html">Metrik sederhana dan cara menghemat waktu saat mencari masalah di infrastruktur</a></li>
<li><a href="../id420665/index.html">Membangun Aplikasi di .NET Core dan Kubernetes: Pengalaman Kami</a></li>
<li><a href="../id420667/index.html">Prinsip-prinsip Operasi Protokol EIGRP</a></li>
<li><a href="../id420669/index.html">Tinjauan Pasar Otomasi Perusahaan: Solusi untuk Konstruksi dan Manajemen Perusahaan Perumahan dan Utilitas</a></li>
<li><a href="../id420671/index.html">[Ekaterinburg, pengumuman] UralJS # 9 - tiga laporan tentang layanan mikro, pengujian, dan pencatatan kesalahan di bagian depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>