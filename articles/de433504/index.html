<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉ ü§≥üèΩ üí° So beenden Sie das Schreiben von Firmware f√ºr Mikrocontroller und beginnen zu leben üëäüèø üìé üë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Eugene und ich bin es leid, Firmware f√ºr Mikrocontroller zu schreiben. Wie ist das passiert und was soll man damit machen? Lassen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beenden Sie das Schreiben von Firmware f√ºr Mikrocontroller und beginnen zu leben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Hallo, mein Name ist Eugene und ich bin es leid, Firmware f√ºr Mikrocontroller zu schreiben.  Wie ist das passiert und was soll man damit machen? Lassen Sie es uns herausfinden. </p><a name="habracut"></a><br><p>  Nachdem Sie in C ++, Java, Python usw. mit gro√üer Programmierung gearbeitet haben, m√∂chten Sie nicht mehr zu den kleinen Mikrocontrollern mit starkem Bauch zur√ºckkehren.  Zu ihren mageren Werkzeugen und Bibliotheken.  Aber manchmal gibt es nichts zu tun, die Aufgaben von Echtzeit und Autonomie lassen keine Wahl.  Es gibt jedoch einige Arten von Aufgaben, die in diesem Bereich nur zu l√∂sen sind. </p><br><p>  Zum Beispiel ist das Testen von Ger√§ten, etwas Langweiligeres und Langweiligeres in der eingebetteten Programmierung, kaum vorstellbar.  Im Allgemeinen sowie praktische Werkzeuge daf√ºr.  Sie schreiben ... Sie blinken ... Sie blinken ... eine LED (manchmal meldet sich UART an).  Alle Stifte ohne spezielle Testwerkzeuge. </p><br><p>  Es ist auch bedr√ºckend, dass es f√ºr unsere kleinen Mikrocontroller keine instrumentellen Tests gibt.  Alles ist nur √ºber die Firmware und √ºber den Debugger zu testen. </p><br><p> Das Studium der Arbeit mit neuen Ger√§ten und Peripherieger√§ten erfordert viel Aufwand und Zeit.  Ein Fehler und das Programm m√ºssen jedes Mal neu kompiliert und erneut ausgef√ºhrt werden. </p><br><p>  F√ºr solche Experimente ist so etwas wie REPL besser geeignet, so dass Sie diese, zumindest trivialen, Dinge einfach und schmerzlos tun k√∂nnen: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \. </p><br><p>  Wie man dazu kommt, ist diese Artikelserie gewidmet. </p><br><p>  Und diesmal stie√ü ich auf ein Projekt, bei dem es notwendig war, ein ziemlich kompliziertes Ger√§t mit vielen aller Arten von Sensoren und anderen mir unbekannten Chips zu testen, bei dem viele Peripherieger√§te von MK und eine Reihe verschiedener Schnittstellen verwendet wurden.  Der besondere Spa√ü war, dass ich nicht die Firmware-Quellcodes f√ºr das Board hatte, sodass alle Tests von Grund auf neu geschrieben werden mussten, ohne die Betriebszeit aus dem Quellcode zu verwenden. </p><br><p>  Das Projekt versprach einen guten Toastmeister und die Wettbewerbe sind ungef√§hr zwei Monate lang interessant (und h√∂chstwahrscheinlich l√§nger). </p><br><p>  Okay, hier werden wir nicht weinen.  Man muss entweder wieder in die Wildnis von C und endloser Firmware eintauchen oder sich weigern oder sich etwas einfallen lassen, um diese Lektion zu erleichtern.  Am Ende sind Faulheit und Neugier der Motor des Fortschritts. </p><br><p>  Als ich OpenOCD das letzte Mal verstand, stie√ü ich auf einen so interessanten Punkt in der Dokumentation wie </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb ‚Äî         mww, mwh, mwb ‚Äî       </code> </pre> <br><p>  Interessant ...  Und es ist m√∂glich, Peripherieregister mit ihnen zu lesen und zu schreiben? .. es stellt sich heraus, dass dies m√∂glich ist, und au√üerdem k√∂nnen diese Befehle remote √ºber den TCL-Server ausgef√ºhrt werden, der beim Start von openOCD gestartet wird. </p><br><p>  Hier ist ein Beispiel f√ºr eine blinkende LED f√ºr stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  und eine √§hnliche Folge von openOCD-Befehlen </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  Und jetzt, wenn Sie √ºber das Ewige nachdenken und Firmware f√ºr MK in Betracht ziehen ... dann besteht der Hauptzweck dieser Programme darin, in die Chipregister zu schreiben;  Firmware, die nur etwas tut und nur mit dem Prozessorkern funktioniert, hat keinen praktischen Nutzen! </p><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text"><p>  Obwohl Sie nat√ºrlich die Krypta (= </p></div></div><br><p>  Viele werden sich mehr an die Arbeit mit Interrupts erinnern.  Aber sie sind nicht immer erforderlich, und in meinem Fall k√∂nnen Sie auf sie verzichten. </p><br><p>  Und so wird das Leben besser.  In der openOCD-Quelle finden Sie sogar ein interessantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel f√ºr die</a> Verwendung dieser Schnittstelle. </p><br><p>  Sehr guter Rohling auf Python. </p><br><p>  Es ist durchaus m√∂glich, Registeradressen aus Header-Dateien zu konvertieren und mit dem Schreiben in einer koscheren Skriptsprache zu beginnen.  Sie k√∂nnen bereits Champagner zubereiten, aber es schien mir nicht genug zu sein, da ich die Standard Peripherals Library oder die neue HAL verwenden m√∂chte, um mit Peripherieger√§ten zu arbeiten, anstatt mich mit Registern zu besch√§ftigen. </p><br><p>  Portieren von Bibliotheken nach Python ... in einem Albtraum werden wir es tun.  Sie m√ºssen diese Bibliotheken also in C oder ... C ++ verwenden.  Und bei den Profis k√∂nnen Sie fast alle Operatoren √ºberschreiben ... f√ºr ihre Klassen. </p><br><p>  Und die Basisadressen in den Header-Dateien werden durch Objekte ihrer Klassen ersetzt. </p><br><p>  Zum Beispiel in der Datei stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Ersetzen durch </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Aber Spiele mit Zeigern in der Bibliothek hacken diese Idee im Keim ... </p><br><p>  Hier ist ein Beispiel f√ºr eine stm32f10x_i2c.c-Datei: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ‚Ä¶.</code> </pre> <br><p>  Es ist also notwendig, Adressen zu Adressen abzufangen, die irgendwie anders sind.  Wie das geht, ist wahrscheinlich einen Blick auf Valgrind wert, nicht umsonst, dass er einen Memchecker hat.  Nun, er sollte wirklich wissen, wie man Adressen abf√§ngt. </p><br><p>  Mit Blick auf die Zukunft werde ich sagen, dass es besser ist, nicht dorthin zu schauen ... Ich habe es fast geschafft, Anrufe an Adressen abzufangen.  In fast allen F√§llen au√üer diesem </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  Es ist m√∂glich, eine Adresse abzufangen, aber es war nicht mehr m√∂glich, aufgezeichnete Daten abzufangen.  Nur der Name des internen Registers, in dem dieser Wert liegt, der aber nicht √ºber memcheck erreichbar ist. </p><br><p>  Tats√§chlich √ºberraschte mich Valgrind, in dem alten Monster wird libVEX verwendet, √ºber das ich im Internet keine Informationen gefunden habe.  Es ist gut, dass in den Header-Dateien eine kleine Dokumentation gefunden wurde. </p><br><p>  Dann gab es noch andere DBI-Tools. </p><br><p>  Frida, Dynamic RIO, noch mehr und schlie√ülich Pintool. </p><br><p>  PinTool hatte einige ziemlich gute Dokumentationen und Beispiele.  Obwohl ich immer noch nicht genug davon hatte, musste ich mit einigen Dingen experimentieren.  Das Tool erwies sich als sehr leistungsf√§hig, es st√∂rt nur den geschlossenen Code und die Beschr√§nkung nur auf die Intel-Plattform (obwohl dies in Zukunft umgangen werden kann). </p><br><p>  Wir m√ºssen also das Schreiben und Lesen an bestimmten Adressen abfangen.  Mal sehen, welche Anweisungen f√ºr diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://godbolt.org/z/nJS9ci verantwortlich sind</a> . </p><br><p>  F√ºr x64 ist dies ein MOV f√ºr beide Operationen. </p><br><p>  Und f√ºr x86 ist es MOV zum Schreiben und MOVZ zum Lesen. </p><br><p>  Hinweis: Es ist am besten, die Optimierung nicht zu aktivieren, da sonst m√∂glicherweise andere Anweisungen angezeigt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler √úberschrift</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  Beim Lesen von der Adresse rufen wir die Funktion loadAddr2Reg auf und l√∂schen die urspr√ºngliche Anweisung.  Auf dieser Grundlage sollte loadAddr2Reg den erforderlichen Wert an uns zur√ºckgeben. </p><br><p>  Mit einem Datensatz wird es immer schwieriger ... Die Argumente k√∂nnen unterschiedlicher Art sein und auch auf unterschiedliche Weise √ºbertragen werden, sodass Sie vor dem Befehl verschiedene Funktionen aufrufen m√ºssen.  Auf einer 32-Bit-Plattform werden multiMemAccessStore und auf 64 storeReg2Addr aufgerufen.  Und hier l√∂schen wir die Anweisung nicht vom Flie√üband.  Es gibt keine Probleme, es zu entfernen, aber in einigen F√§llen ist es nicht m√∂glich, seine Aktion nachzuahmen.  Das Programm st√ºrzt aus irgendeinem Grund manchmal in Sigfault ab.  F√ºr uns ist dies nicht kritisch, lassen Sie es sich selbst schreiben, die Hauptsache ist, dass es die M√∂glichkeit gibt, Argumente abzufangen. </p><br><p>  Als n√§chstes m√ºssen wir sehen, welche Adressen wir abfangen m√ºssen. Schauen Sie sich die Speicherzuordnung f√ºr unseren stm32f103C8T6-Chip an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="Bild"><br>  Wir sind an Adressen mit SRAM und PERIPH_BASE interessiert, d. H. Von 0x20000000 bis 0x20000000 + 128 * 1024 und von 0x40000000 bis 0x40030000.  Nun, oder besser gesagt, nicht ganz, da wir uns an die Aufnahmeanweisung erinnern, konnten wir sie nicht l√∂schen.  Daher f√§llt der Datensatz an diesen Adressen in Sigfault aus.  Dar√ºber hinaus ist es unwahrscheinlich, dass diese Adressen Daten aus unserem Programm enthalten, nicht dass dieser Chip einen anderen hat.  Deshalb m√ºssen wir sie definitiv irgendwo reparieren.  Sagen wir auf einer Art Array. </p><br><p>  Wir erstellen Arrays mit der erforderlichen Gr√∂√üe und ersetzen dann ihre Zeiger in den definierten Basisadressen. </p><br><p>  In unserem Programm stattdessen in den Schlagzeilen </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Tun Sie </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  und wobei pAddrSRAM und pAddrPERIPH Zeiger auf vorab zugewiesene Arrays sind. </p><br><p>  Jetzt muss unser PinTool-Client irgendwie vermitteln, wie wir die erforderlichen Adressen repariert haben. <br>  Das Einfachste, was mir so vorkam, war, eine Funktion abzufangen, die eine Array-Struktur aus diesem Format zur√ºckgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Zum Beispiel wird unser Chip so gef√ºllt sein </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  Es ist nicht schwierig, die Funktion abzufangen und die erforderlichen Werte daraus zu ziehen: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  Und lassen Sie unsere abgefangene Funktion so aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Was die nicht trivialste Arbeit ist, bleibt, den Client f√ºr OpenOCD zu machen. Im PinTool-Client wollte ich ihn nicht implementieren, also habe ich ihn zu einer separaten Anwendung gemacht, mit der unser PinTool-Client √ºber den Namen fifo kommuniziert. </p><br><p>  Somit ist das Schema der Schnittstellen und der Kommunikation wie folgt: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="Bild"><br>  Ein vereinfachter Workflow am Beispiel des Abfangens der Adresse 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="Bild"><br>  Werfen wir einen Blick darauf, was hier passiert: </p><br><p>  Der PinTool-Client wird gestartet, initialisiert unsere Interceptors und startet das Programm <br>  Das Programm startet, es muss die Adressen der Register auf einem Thread-Array adressieren, die Funktion getMemoryMap wird aufgerufen, die unser PinTool abf√§ngt.  Zum Beispiel hat eines der Register auf die Adresse 0x123 gespiegelt, wir werden es verfolgen <br>  Der PinTool-Client speichert die Werte von nicht zugeordneten Adressen <br>  √úbertragen Sie die Kontrolle zur√ºck in unser Programm <br>  Au√üerdem gibt es irgendwo eine Aufzeichnung unter unserer verfolgten Adresse 0x123.  Die StoreReg2Addr-Funktion verfolgt dies <br>  Und sendet die Schreibanforderung an den OpenOCD-Client <br>  Der Client gibt die analysierte Antwort zur√ºck.  Wenn alles in Ordnung ist, kehrt die Programmsteuerung zur√ºck <br>  Weiterhin erfolgt irgendwo im Programm das Lesen an der verfolgten Adresse 0x123. <br>  loadAddr2Reg verfolgt dies und sendet eine OpenOCD-Anfrage an den Client. <br>  Der OpenOCD-Client verarbeitet es und gibt eine Antwort zur√ºck <br>  Wenn alles in Ordnung ist, aber der Wert aus dem MK-Register an das Programm zur√ºckgegeben wird <br>  Das Programm wird fortgesetzt. <br>  Das ist alles f√ºr den Moment. Vollst√§ndige Quellcodes und Beispiele finden Sie in den folgenden Abschnitten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433504/">https://habr.com/ru/post/de433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433494/index.html">10 englische Redewendungen, die Sie nie kennen werden</a></li>
<li><a href="../de433496/index.html">Staatliche Unternehmen verpflichten sich, bis 2022 auf inl√§ndische Software umzusteigen</a></li>
<li><a href="../de433498/index.html">Sberbank - Sie haben ein "Paket" f√ºr mich, aber ich werde es nicht nehmen ...</a></li>
<li><a href="../de433500/index.html">Der Berkeley-Kurierroboter ist aufgrund des fehlenden Status des √úberwachungssystems ausgebrannt</a></li>
<li><a href="../de433502/index.html">Bluetooth Wireless Audio-Technologie: Was ist besser?</a></li>
<li><a href="../de433506/index.html">Die EU strebt das Recht an, gro√üe Haushaltsger√§te zu reparieren</a></li>
<li><a href="../de433508/index.html">Der Eigent√ºmer der MIPS-Architektur beabsichtigt, seinen Befehlssatz (ISA) im Jahr 2019 zu √∂ffnen</a></li>
<li><a href="../de433510/index.html">Interkultureller Unterschied in Spielen</a></li>
<li><a href="../de433512/index.html">Theorie des Gl√ºcks. Schwindelerregender Flug eines Sandwichs mit Butter</a></li>
<li><a href="../de433514/index.html">Do-it-yourself-H√∂lle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>