<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃 🤳🏽 💡 So beenden Sie das Schreiben von Firmware für Mikrocontroller und beginnen zu leben 👊🏿 📎 👩‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Eugene und ich bin es leid, Firmware für Mikrocontroller zu schreiben. Wie ist das passiert und was soll man damit machen? Lassen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beenden Sie das Schreiben von Firmware für Mikrocontroller und beginnen zu leben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Hallo, mein Name ist Eugene und ich bin es leid, Firmware für Mikrocontroller zu schreiben.  Wie ist das passiert und was soll man damit machen? Lassen Sie es uns herausfinden. </p><a name="habracut"></a><br><p>  Nachdem Sie in C ++, Java, Python usw. mit großer Programmierung gearbeitet haben, möchten Sie nicht mehr zu den kleinen Mikrocontrollern mit starkem Bauch zurückkehren.  Zu ihren mageren Werkzeugen und Bibliotheken.  Aber manchmal gibt es nichts zu tun, die Aufgaben von Echtzeit und Autonomie lassen keine Wahl.  Es gibt jedoch einige Arten von Aufgaben, die in diesem Bereich nur zu lösen sind. </p><br><p>  Zum Beispiel ist das Testen von Geräten, etwas Langweiligeres und Langweiligeres in der eingebetteten Programmierung, kaum vorstellbar.  Im Allgemeinen sowie praktische Werkzeuge dafür.  Sie schreiben ... Sie blinken ... Sie blinken ... eine LED (manchmal meldet sich UART an).  Alle Stifte ohne spezielle Testwerkzeuge. </p><br><p>  Es ist auch bedrückend, dass es für unsere kleinen Mikrocontroller keine instrumentellen Tests gibt.  Alles ist nur über die Firmware und über den Debugger zu testen. </p><br><p> Das Studium der Arbeit mit neuen Geräten und Peripheriegeräten erfordert viel Aufwand und Zeit.  Ein Fehler und das Programm müssen jedes Mal neu kompiliert und erneut ausgeführt werden. </p><br><p>  Für solche Experimente ist so etwas wie REPL besser geeignet, so dass Sie diese, zumindest trivialen, Dinge einfach und schmerzlos tun können: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \. </p><br><p>  Wie man dazu kommt, ist diese Artikelserie gewidmet. </p><br><p>  Und diesmal stieß ich auf ein Projekt, bei dem es notwendig war, ein ziemlich kompliziertes Gerät mit vielen aller Arten von Sensoren und anderen mir unbekannten Chips zu testen, bei dem viele Peripheriegeräte von MK und eine Reihe verschiedener Schnittstellen verwendet wurden.  Der besondere Spaß war, dass ich nicht die Firmware-Quellcodes für das Board hatte, sodass alle Tests von Grund auf neu geschrieben werden mussten, ohne die Betriebszeit aus dem Quellcode zu verwenden. </p><br><p>  Das Projekt versprach einen guten Toastmeister und die Wettbewerbe sind ungefähr zwei Monate lang interessant (und höchstwahrscheinlich länger). </p><br><p>  Okay, hier werden wir nicht weinen.  Man muss entweder wieder in die Wildnis von C und endloser Firmware eintauchen oder sich weigern oder sich etwas einfallen lassen, um diese Lektion zu erleichtern.  Am Ende sind Faulheit und Neugier der Motor des Fortschritts. </p><br><p>  Als ich OpenOCD das letzte Mal verstand, stieß ich auf einen so interessanten Punkt in der Dokumentation wie </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb —         mww, mwh, mwb —       </code> </pre> <br><p>  Interessant ...  Und es ist möglich, Peripherieregister mit ihnen zu lesen und zu schreiben? .. es stellt sich heraus, dass dies möglich ist, und außerdem können diese Befehle remote über den TCL-Server ausgeführt werden, der beim Start von openOCD gestartet wird. </p><br><p>  Hier ist ein Beispiel für eine blinkende LED für stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  und eine ähnliche Folge von openOCD-Befehlen </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  Und jetzt, wenn Sie über das Ewige nachdenken und Firmware für MK in Betracht ziehen ... dann besteht der Hauptzweck dieser Programme darin, in die Chipregister zu schreiben;  Firmware, die nur etwas tut und nur mit dem Prozessorkern funktioniert, hat keinen praktischen Nutzen! </p><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text"><p>  Obwohl Sie natürlich die Krypta (= </p></div></div><br><p>  Viele werden sich mehr an die Arbeit mit Interrupts erinnern.  Aber sie sind nicht immer erforderlich, und in meinem Fall können Sie auf sie verzichten. </p><br><p>  Und so wird das Leben besser.  In der openOCD-Quelle finden Sie sogar ein interessantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel für die</a> Verwendung dieser Schnittstelle. </p><br><p>  Sehr guter Rohling auf Python. </p><br><p>  Es ist durchaus möglich, Registeradressen aus Header-Dateien zu konvertieren und mit dem Schreiben in einer koscheren Skriptsprache zu beginnen.  Sie können bereits Champagner zubereiten, aber es schien mir nicht genug zu sein, da ich die Standard Peripherals Library oder die neue HAL verwenden möchte, um mit Peripheriegeräten zu arbeiten, anstatt mich mit Registern zu beschäftigen. </p><br><p>  Portieren von Bibliotheken nach Python ... in einem Albtraum werden wir es tun.  Sie müssen diese Bibliotheken also in C oder ... C ++ verwenden.  Und bei den Profis können Sie fast alle Operatoren überschreiben ... für ihre Klassen. </p><br><p>  Und die Basisadressen in den Header-Dateien werden durch Objekte ihrer Klassen ersetzt. </p><br><p>  Zum Beispiel in der Datei stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Ersetzen durch </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Aber Spiele mit Zeigern in der Bibliothek hacken diese Idee im Keim ... </p><br><p>  Hier ist ein Beispiel für eine stm32f10x_i2c.c-Datei: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; …. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ….</code> </pre> <br><p>  Es ist also notwendig, Adressen zu Adressen abzufangen, die irgendwie anders sind.  Wie das geht, ist wahrscheinlich einen Blick auf Valgrind wert, nicht umsonst, dass er einen Memchecker hat.  Nun, er sollte wirklich wissen, wie man Adressen abfängt. </p><br><p>  Mit Blick auf die Zukunft werde ich sagen, dass es besser ist, nicht dorthin zu schauen ... Ich habe es fast geschafft, Anrufe an Adressen abzufangen.  In fast allen Fällen außer diesem </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  Es ist möglich, eine Adresse abzufangen, aber es war nicht mehr möglich, aufgezeichnete Daten abzufangen.  Nur der Name des internen Registers, in dem dieser Wert liegt, der aber nicht über memcheck erreichbar ist. </p><br><p>  Tatsächlich überraschte mich Valgrind, in dem alten Monster wird libVEX verwendet, über das ich im Internet keine Informationen gefunden habe.  Es ist gut, dass in den Header-Dateien eine kleine Dokumentation gefunden wurde. </p><br><p>  Dann gab es noch andere DBI-Tools. </p><br><p>  Frida, Dynamic RIO, noch mehr und schließlich Pintool. </p><br><p>  PinTool hatte einige ziemlich gute Dokumentationen und Beispiele.  Obwohl ich immer noch nicht genug davon hatte, musste ich mit einigen Dingen experimentieren.  Das Tool erwies sich als sehr leistungsfähig, es stört nur den geschlossenen Code und die Beschränkung nur auf die Intel-Plattform (obwohl dies in Zukunft umgangen werden kann). </p><br><p>  Wir müssen also das Schreiben und Lesen an bestimmten Adressen abfangen.  Mal sehen, welche Anweisungen für diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://godbolt.org/z/nJS9ci verantwortlich sind</a> . </p><br><p>  Für x64 ist dies ein MOV für beide Operationen. </p><br><p>  Und für x86 ist es MOV zum Schreiben und MOVZ zum Lesen. </p><br><p>  Hinweis: Es ist am besten, die Optimierung nicht zu aktivieren, da sonst möglicherweise andere Anweisungen angezeigt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler Überschrift</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  Beim Lesen von der Adresse rufen wir die Funktion loadAddr2Reg auf und löschen die ursprüngliche Anweisung.  Auf dieser Grundlage sollte loadAddr2Reg den erforderlichen Wert an uns zurückgeben. </p><br><p>  Mit einem Datensatz wird es immer schwieriger ... Die Argumente können unterschiedlicher Art sein und auch auf unterschiedliche Weise übertragen werden, sodass Sie vor dem Befehl verschiedene Funktionen aufrufen müssen.  Auf einer 32-Bit-Plattform werden multiMemAccessStore und auf 64 storeReg2Addr aufgerufen.  Und hier löschen wir die Anweisung nicht vom Fließband.  Es gibt keine Probleme, es zu entfernen, aber in einigen Fällen ist es nicht möglich, seine Aktion nachzuahmen.  Das Programm stürzt aus irgendeinem Grund manchmal in Sigfault ab.  Für uns ist dies nicht kritisch, lassen Sie es sich selbst schreiben, die Hauptsache ist, dass es die Möglichkeit gibt, Argumente abzufangen. </p><br><p>  Als nächstes müssen wir sehen, welche Adressen wir abfangen müssen. Schauen Sie sich die Speicherzuordnung für unseren stm32f103C8T6-Chip an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="Bild"><br>  Wir sind an Adressen mit SRAM und PERIPH_BASE interessiert, d. H. Von 0x20000000 bis 0x20000000 + 128 * 1024 und von 0x40000000 bis 0x40030000.  Nun, oder besser gesagt, nicht ganz, da wir uns an die Aufnahmeanweisung erinnern, konnten wir sie nicht löschen.  Daher fällt der Datensatz an diesen Adressen in Sigfault aus.  Darüber hinaus ist es unwahrscheinlich, dass diese Adressen Daten aus unserem Programm enthalten, nicht dass dieser Chip einen anderen hat.  Deshalb müssen wir sie definitiv irgendwo reparieren.  Sagen wir auf einer Art Array. </p><br><p>  Wir erstellen Arrays mit der erforderlichen Größe und ersetzen dann ihre Zeiger in den definierten Basisadressen. </p><br><p>  In unserem Programm stattdessen in den Schlagzeilen </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Tun Sie </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  und wobei pAddrSRAM und pAddrPERIPH Zeiger auf vorab zugewiesene Arrays sind. </p><br><p>  Jetzt muss unser PinTool-Client irgendwie vermitteln, wie wir die erforderlichen Adressen repariert haben. <br>  Das Einfachste, was mir so vorkam, war, eine Funktion abzufangen, die eine Array-Struktur aus diesem Format zurückgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Zum Beispiel wird unser Chip so gefüllt sein </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  Es ist nicht schwierig, die Funktion abzufangen und die erforderlichen Werte daraus zu ziehen: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  Und lassen Sie unsere abgefangene Funktion so aussehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Was die nicht trivialste Arbeit ist, bleibt, den Client für OpenOCD zu machen. Im PinTool-Client wollte ich ihn nicht implementieren, also habe ich ihn zu einer separaten Anwendung gemacht, mit der unser PinTool-Client über den Namen fifo kommuniziert. </p><br><p>  Somit ist das Schema der Schnittstellen und der Kommunikation wie folgt: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="Bild"><br>  Ein vereinfachter Workflow am Beispiel des Abfangens der Adresse 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="Bild"><br>  Werfen wir einen Blick darauf, was hier passiert: </p><br><p>  Der PinTool-Client wird gestartet, initialisiert unsere Interceptors und startet das Programm <br>  Das Programm startet, es muss die Adressen der Register auf einem Thread-Array adressieren, die Funktion getMemoryMap wird aufgerufen, die unser PinTool abfängt.  Zum Beispiel hat eines der Register auf die Adresse 0x123 gespiegelt, wir werden es verfolgen <br>  Der PinTool-Client speichert die Werte von nicht zugeordneten Adressen <br>  Übertragen Sie die Kontrolle zurück in unser Programm <br>  Außerdem gibt es irgendwo eine Aufzeichnung unter unserer verfolgten Adresse 0x123.  Die StoreReg2Addr-Funktion verfolgt dies <br>  Und sendet die Schreibanforderung an den OpenOCD-Client <br>  Der Client gibt die analysierte Antwort zurück.  Wenn alles in Ordnung ist, kehrt die Programmsteuerung zurück <br>  Weiterhin erfolgt irgendwo im Programm das Lesen an der verfolgten Adresse 0x123. <br>  loadAddr2Reg verfolgt dies und sendet eine OpenOCD-Anfrage an den Client. <br>  Der OpenOCD-Client verarbeitet es und gibt eine Antwort zurück <br>  Wenn alles in Ordnung ist, aber der Wert aus dem MK-Register an das Programm zurückgegeben wird <br>  Das Programm wird fortgesetzt. <br>  Das ist alles für den Moment. Vollständige Quellcodes und Beispiele finden Sie in den folgenden Abschnitten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433504/">https://habr.com/ru/post/de433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433494/index.html">10 englische Redewendungen, die Sie nie kennen werden</a></li>
<li><a href="../de433496/index.html">Staatliche Unternehmen verpflichten sich, bis 2022 auf inländische Software umzusteigen</a></li>
<li><a href="../de433498/index.html">Sberbank - Sie haben ein "Paket" für mich, aber ich werde es nicht nehmen ...</a></li>
<li><a href="../de433500/index.html">Der Berkeley-Kurierroboter ist aufgrund des fehlenden Status des Überwachungssystems ausgebrannt</a></li>
<li><a href="../de433502/index.html">Bluetooth Wireless Audio-Technologie: Was ist besser?</a></li>
<li><a href="../de433506/index.html">Die EU strebt das Recht an, große Haushaltsgeräte zu reparieren</a></li>
<li><a href="../de433508/index.html">Der Eigentümer der MIPS-Architektur beabsichtigt, seinen Befehlssatz (ISA) im Jahr 2019 zu öffnen</a></li>
<li><a href="../de433510/index.html">Interkultureller Unterschied in Spielen</a></li>
<li><a href="../de433512/index.html">Theorie des Glücks. Schwindelerregender Flug eines Sandwichs mit Butter</a></li>
<li><a href="../de433514/index.html">Do-it-yourself-Hölle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>