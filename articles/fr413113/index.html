<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ç üë≤üèΩ üí∞ Prise en charge de la s√©rialisation JavaScript de classe JavaScript ‚úåüèΩ ‚ùé üë®‚Äçüë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 


 Actuellement, je d√©veloppe un √©diteur de sch√©ma Javascript, et au cours de ce travail, j'ai rencontr√© un probl√®me sur lequel cet article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge de la s√©rialisation JavaScript de classe JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog">  Prologue </h3><br><p>  Actuellement, je d√©veloppe un √©diteur de sch√©ma Javascript, et au cours de ce travail, j'ai rencontr√© un probl√®me sur lequel cet article se concentrera, √† savoir la s√©rialisation et la d√©s√©rialisation d'objets de donn√©es complexes. </p><br><p> Sans entrer dans les d√©tails du projet, je constate que selon mon id√©e, le sch√©ma est un tableau d'√©l√©ments (sommets) h√©rit√© de la classe de base.  En cons√©quence, chaque classe enfant impl√©mente sa propre logique.  De plus, les sommets contiennent des liens entre eux (fl√®ches), qui doivent √©galement √™tre pr√©serv√©s.  Th√©oriquement, les sommets peuvent se r√©f√©rer √† eux-m√™mes directement ou par le biais d'autres sommets.  Le standard JSON.stringify n'est pas en mesure de s√©rialiser un tel tableau, j'ai donc d√©cid√© de cr√©er mon propre s√©rialiseur qui r√©sout les deux probl√®mes d√©crits: </p><br><ol><li>  Possibilit√© d'enregistrer les informations de classe pendant la s√©rialisation et de les restaurer pendant la d√©s√©rialisation. </li><li>  La possibilit√© d'enregistrer et de restaurer des liens vers des objets, y compris  cyclique. </li></ol><br><p>  En savoir plus sur l'√©nonc√© du probl√®me et sa solution sous la coupe. </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Projet s√©rialiseur Github </h3><br><p>  Lien vers le projet github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> . <br>  Des exemples complexes se trouvent √©galement dans le dossier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test-src</a> . </p><br><p>  S√©rialiseur r√©cursif: <a href="">lien</a> . <br>  S√©rialiseur plat: <a href="">lien</a> . </p><br><h3 id="postanovka-zadachi">  √ânonc√© du probl√®me </h3><br><p>  Comme je l'ai d√©j√† not√©, la t√¢che initiale est de s√©rialiser des circuits arbitraires pour l'√©diteur.  Afin de ne pas perdre de temps √† d√©crire l'√©diteur, nous facilitons la t√¢che.  Supposons que nous voulons faire une description formelle d'un sch√©ma d'algorithme simple en utilisant les classes Javascript ES6, puis s√©rialiser et d√©s√©rialiser ce sch√©ma. </p><br><p>  Sur Internet, j'ai trouv√© une image appropri√©e de l'algorithme le plus simple pour d√©terminer le maximum de deux valeurs: </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="image"></p><br><p>  Il faut dire ici que je ne suis pas un d√©veloppeur Javascript, et mon langage "natif" est C #, donc l'approche pour r√©soudre le probl√®me est dict√©e par l'exp√©rience du d√©veloppement orient√© objet en C #.  En regardant ce diagramme, je vois les sommets des types suivants (les noms conditionnels et les r√¥les sp√©ciaux ne jouent pas): </p><br><ul><li>  D√©marrer le sommet (D√©marrer) </li><li>  Pic final (Terminer) </li><li>  Haut de l'√©quipe (commande) </li><li>  Sommet d'affectation (Let) </li><li>  Verification Verification Top (If) </li></ul><br><p>  Ces sommets ont quelques diff√©rences les uns par rapport aux autres dans leur ensemble de donn√©es ou leur s√©mantique, mais ils sont tous h√©rit√©s du sommet de base (Node).  Au m√™me endroit, dans la classe Node, le champ de liens est d√©crit, qui contient des liens vers d'autres sommets, et la m√©thode addLink permet d'ajouter ces liens.  Le code complet de toutes les classes peut √™tre trouv√© <a href="">ici</a> . </p><br><p>  √âcrivons le code qui collecte le circuit de l'image et essayons de s√©rialiser le r√©sultat. </p><br><div class="spoiler">  <b class="spoiler_title">Code de conception d'algorithme</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p>  Si nous s√©rialisons ce sch√©ma en utilisant JSON.stringify, nous obtenons quelque chose de terrible.  Je vais donner les premi√®res lignes du r√©sultat, dans lesquelles j'ai ajout√© mes commentaires: </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p>  Parce que  le premier sommet contenait un lien vers le second, et celui vers les suivants, puis √† la suite de sa s√©rialisation l'ensemble du circuit a √©t√© s√©rialis√©.  Ensuite, le deuxi√®me pic a √©t√© s√©rialis√© et tout ce qui en d√©pendait, etc.  Vous ne pouvez restaurer les liens d'origine √† partir de ce hachage que par des identificateurs, mais ils ne seront d'aucune utilit√© si l'un des sommets se r√©f√®re √† lui-m√™me directement ou via d'autres sommets.  Dans ce cas, le s√©rialiseur lancera <u>une erreur TypeError Uncaught: Conversioning en</u> erreur <u>JSON</u> .  Si ce n'est pas clair, voici l'exemple le plus simple qui g√©n√®re cette erreur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jsfiddle.net/L4guo86w/</a> . </p><br><p>  De plus, JSON ne contient aucune information sur les classes source, il n'y a donc aucun moyen de comprendre de quel type √©tait chaque sommet avant la s√©rialisation. </p><br><p>  Conscient de ces probl√®mes, je suis all√© en ligne et j'ai commenc√© √† chercher des solutions toutes faites.  Il y en avait beaucoup, mais la plupart √©taient tr√®s volumineux ou n√©cessitaient une description sp√©ciale des classes s√©rialisables, il a donc √©t√© d√©cid√© de faire votre propre v√©lo.  Et oui, j'adore les v√©los. </p><br><h3 id="koncepciya-serializatora">  Concept de s√©rialiseur </h3><br><p>  Cette section s'adresse √† ceux qui souhaitent participer √† la cr√©ation d'un algorithme de s√©rialisation avec moi, quoique virtuellement. </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh">  Enregistrement des informations sur le type de donn√©es </h4><br><p>  Un des probl√®mes avec Javascript est le manque de m√©tadonn√©es qui peuvent faire des merveilles dans des langages comme C # ou Java (attributs et r√©flexion).  En revanche, je n'ai pas besoin de s√©rialisation super complexe avec la possibilit√© de d√©finir une liste de champs s√©rialisables, de validation et autres puces.  Par cons√©quent, l'id√©e principale est d'ajouter des informations sur son type √† l'objet et de le s√©rialiser avec JSON.stringify ordinaire. </p><br><p>  Lors de la recherche de solutions, je suis tomb√© sur un article int√©ressant dont le titre se traduit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´6 mauvaises fa√ßons d'ajouter des informations de type dans JSON¬ª</a> .  En fait, les m√©thodes sont tr√®s bonnes, et j'ai choisi celle au num√©ro 5. Si vous √™tes trop paresseux pour lire l'article, mais je vous recommande fortement de le faire, alors je vais d√©crire bri√®vement cette m√©thode: lors de la s√©rialisation d'un objet, nous l'enveloppons dans un autre objet avec le seul un champ dont le nom est au format <code>"@&lt;type&gt;"</code> , et la valeur correspond aux donn√©es de l'objet.  Lors de la d√©s√©rialisation, nous extrayons le nom du type, recr√©ons l'objet √† partir du constructeur et lisons les donn√©es de ses champs. </p><br><p>  Si nous supprimons les liens de notre exemple ci-dessus, alors JSON.stringify standard s√©rialise les donn√©es comme ceci: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p>  Et notre s√©rialiseur l'enveloppera comme ceci: </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de s√©rialisation</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p>  Bien s√ªr, il y a un inconv√©nient: le s√©rialiseur doit conna√Ætre les types qu'il peut s√©rialiser et les objets eux-m√™mes ne doivent pas contenir de champs dont le nom commence par un chien.  Cependant, le deuxi√®me probl√®me est r√©solu en accord avec les d√©veloppeurs ou en rempla√ßant le symbole du chien par quelque chose d'autre, et le premier probl√®me est r√©solu dans une ligne de code (ci-dessous sera un exemple).  Nous savons exactement ce que nous allons s√©rialiser, non? </p><br><h4 id="reshenie-problemy-so-ssylkami">  R√©solution du probl√®me de liaison </h4><br><p>  Il est toujours plus simple en termes d'algorithme, mais plus difficile √† mettre en ≈ìuvre. </p><br><p>  Lors de la s√©rialisation des instances de classes enregistr√©es dans le s√©rialiseur, nous les stockons dans le cache et leur attribuons un num√©ro de s√©rie.  Si √† l'avenir nous rencontrons √† nouveau cette instance, alors dans la premi√®re d√©finition, nous ajouterons ce num√©ro (le nom du champ prendra la forme <code>"@&lt;type&gt;|&lt;index&gt;"</code> ), et au lieu de s√©rialisation, nous ins√©rerons le lien en tant qu'objet </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p>  Ainsi, lors de la d√©s√©rialisation, nous regardons quelle est exactement la valeur du champ.  S'il s'agit d'un nombre, nous extrayons l'objet du cache par ce nombre.  Sinon, c'est sa premi√®re d√©finition. </p><br><p>  Retournons le lien du premier sommet du sch√©ma au second et regardons le r√©sultat: </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de s√©rialisation</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p>  Cela ne semble pas tr√®s clair √† premi√®re vue, car  le deuxi√®me sommet est d'abord d√©fini √† l'int√©rieur du premier dans l'objet de communication Link, mais il est important que cette approche fonctionne.  De plus, j'ai cr√©√© la deuxi√®me version du s√©rialiseur, qui contourne l'arbre non pas en profondeur, mais en largeur, ce qui √©vite de telles "√©chelles". </p><br><h3 id="sozdanie-serializatora">  Cr√©er un s√©rialiseur </h3><br><p>  Cette section est destin√©e √† ceux qui souhaitent mettre en ≈ìuvre les id√©es d√©crites ci-dessus. </p><br><h4 id="zagotovka-serializatora">  S√©rialiseur vierge </h4><br><p>  Comme tout autre, notre s√©rialiseur aura deux m√©thodes principales: s√©rialiser et d√©s√©rialiser.  De plus, nous aurons besoin d'une m√©thode qui indique au s√©rialiseur les classes qu'il doit s√©rialiser (s'inscrire) et les classes qui ne doivent pas (ignorer).  Ce dernier est n√©cessaire afin de ne pas s√©rialiser les √©l√©ments DOM, les objets JQuery ou tout autre type de donn√©es qui ne peuvent pas √™tre s√©rialis√©s ou qui ne sont pas n√©cessaires pour √™tre s√©rialis√©s.  Par exemple, dans mon √©diteur, je stocke un √©l√©ment visuel correspondant √† un sommet ou un lien.  Il est cr√©√© lors de l'initialisation et, bien s√ªr, ne doit pas tomber dans la base de donn√©es. </p><br><div class="spoiler">  <b class="spoiler_title">Code shell du s√©rialiseur</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p>  Explications </p><br><p>  Pour enregistrer une classe, vous devez passer son constructeur √† la m√©thode register de deux mani√®res: </p><br><ol><li>  s'inscrire (MyClass) </li><li>  s'inscrire ('MyNamespace.MyClass', MyClass) </li></ol><br><p>  Dans le premier cas, le nom de la classe sera extrait du nom de la fonction constructeur (non pris en charge dans IE), dans le second, vous sp√©cifiez le nom vous-m√™me.  La deuxi√®me m√©thode est pr√©f√©rable, car  vous permet d'utiliser des espaces de noms, et le premier, de par sa conception, est con√ßu pour enregistrer les types Javascript int√©gr√©s avec une logique de s√©rialisation red√©finie. </p><br><p>  Pour notre exemple, l'initialisation du s√©rialiseur est la suivante: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  L'objet Schema contient des descriptions de toutes les classes de vertex, de sorte que le code d'enregistrement de classe tient sur une seule ligne. </p><br><h4 id="kontekst-serializacii-i-deserializacii">  Le contexte de la s√©rialisation et de la d√©s√©rialisation </h4><br><p>  Vous avez peut-√™tre remarqu√© les classes cryptiques SerializationContext et DeserializationContext.  Ce sont eux qui font tout le travail et sont n√©cessaires principalement pour s√©parer les donn√©es des diff√©rents processus de s√©rialisation / d√©s√©rialisation, car  pour chaque appel, ils doivent stocker des informations interm√©diaires - un cache d'objets s√©rialis√©s et un num√©ro de s√©rie pour la liaison. </p><br><h4 id="serializationcontext">  SerializationContext </h4><br><p>  Je vais analyser en d√©tail uniquement le s√©rialiseur r√©cursif, car  leur homologue "plat" est un peu plus compliqu√© et ne diff√®re que par son approche du traitement d'un arbre d'objets. </p><br><p>  Commen√ßons par le constructeur: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p>  Je <code>this.__proto__.__proto__ = ser;</code> d'expliquer la ligne myst√©rieuse de <code>this.__proto__.__proto__ = ser;</code> <br>  A l'entr√©e du constructeur, nous acceptons l'objet du s√©rialiseur lui-m√™me, et cette ligne en h√©rite notre classe.  Cela permet d'acc√©der aux donn√©es du s√©rialiseur par <code>this</code> biais. <br>  Par exemple, <code>this._ignore</code> fait r√©f√©rence √† une liste de classes ignor√©es du s√©rialiseur lui-m√™me (la "liste noire"), ce qui est tr√®s utile.  Sinon, nous aurions √† √©crire quelque chose comme <code>this._serializer._ignore</code> . </p><br><p>  M√©thode de s√©rialisation principale: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p>  Il convient de noter qu'il existe trois types de donn√©es de base que nous traitons: les tableaux, les objets et les valeurs simples.  Si le constructeur d'un objet est dans la "liste noire", alors cet objet n'est pas s√©rialis√©. </p><br><p>  S√©rialisation de la baie: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Vous pouvez √©crire plus court via la carte, mais ce n'est pas critique.  Une seule chose est importante: v√©rifier la valeur ind√©finie.  S'il y a une classe non s√©rialisable dans le tableau, sans cette v√©rification, elle tombera dans le tableau comme non d√©finie, ce qui n'est pas tr√®s bon.  Toujours dans mon impl√©mentation, les tableaux sont s√©rialis√©s sans cl√©s.  Th√©oriquement, vous pouvez affiner l'algorithme de s√©rialisation des tableaux associatifs, mais √† ces fins, je pr√©f√®re utiliser des objets.  De plus, JSON.stringify n'aime pas non plus les tableaux associatifs. </p><br><p>  S√©rialisation d'objets: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p>  √âvidemment, c'est la partie la plus difficile du s√©rialiseur, son c≈ìur.  Prenons-le √† part. </p><br><p>  Pour commencer, nous v√©rifions si le constructeur de classe est enregistr√© dans le s√©rialiseur.  Sinon, il s'agit d'un objet simple pour lequel la m√©thode utilitaire <code>serializeObjectInner</code> est appel√©e. </p><br><p>  Sinon, nous v√©rifions si l'objet est attribu√© √† un identifiant unique <strong>__uuid</strong> .  Il s'agit d'une simple variable de compteur commune √† tous les s√©rialiseurs et utilis√©e pour conserver la r√©f√©rence √† l'instance de classe dans le cache.  Vous pouvez vous en passer et stocker l'instance elle-m√™me sans cl√© dans le cache, mais ensuite pour v√©rifier si l'objet est stock√© dans le cache, vous devrez parcourir l'int√©gralit√© du cache, et ici il suffit de v√©rifier la cl√©.  Je pense que c'est plus rapide en termes d'impl√©mentation interne d'objets dans les navigateurs.  De plus, je ne intentionnellement pas s√©rialiser les champs commen√ßant par deux <strong>traits de</strong> soulignement, donc le champ <strong>__uuid</strong> ne tombera pas dans le json r√©sultant, comme les autres champs de classe priv√©e.  Si cela est inacceptable pour votre t√¢che, vous pouvez modifier cette logique. </p><br><p>  Ensuite, par la valeur de <strong>__uuid,</strong> nous recherchons un objet qui d√©crit l'instance de la classe dans le cache ( <strong>mis en cache</strong> ). </p><br><p>  Si un tel objet existe, la valeur a d√©j√† √©t√© s√©rialis√©e plus t√¥t.  Dans ce cas, nous attribuons un num√©ro de s√©rie √† l'objet, si cela n'a pas √©t√© fait auparavant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p>  Le code semble confus, et il peut √™tre simplifi√© en attribuant un num√©ro √† toutes les classes que nous s√©rialisons.  Mais pour d√©boguer et percevoir le r√©sultat, il est pr√©f√©rable que le num√©ro soit attribu√© uniquement aux classes auxquelles il existe des liens √† l'avenir. </p><br><p>  Lorsque le num√©ro est attribu√©, nous renvoyons le lien selon l'algorithme: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p>  Si l'objet est s√©rialis√© pour la premi√®re fois, nous cr√©ons une instance de son cache: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p>  Et puis s√©rialisez-le: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p>  Il y a une v√©rification de l'impl√©mentation de l'interface de s√©rialisation par la classe (qui sera discut√©e plus loin), ainsi que la construction d' <code>Object.keys(cached.ref)[0]</code> .  Le fait est que cached.ref stocke un lien vers l'objet wrapper <code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> , mais le nom du champ objet nous est inconnu, car  √† ce stade, nous ne savons pas encore si le nom contiendra le num√©ro d'objet (index).  Cette construction extrait simplement le premier et le seul champ de l'objet. </p><br><p>  Enfin, la m√©thode utilitaire de s√©rialisation des objets internes: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p>  Nous cr√©ons un nouvel objet et copions les champs de l'ancien dans celui-ci. </p><br><h4 id="deserializationcontext">  DeserializationContext </h4><br><p>  Le processus de d√©s√©rialisation fonctionne dans l'ordre inverse et n'a pas besoin de commentaires sp√©ciaux. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti">  Fonctionnalit√©s suppl√©mentaires </h3><br><h4 id="interfeys-serializacii">  Interface de s√©rialisation </h4><br><p>  Il n'y a pas de prise en charge d'interface en Javascript, mais nous pouvons convenir que si la classe impl√©mente les m√©thodes de s√©rialisation et de d√©s√©rialisation, ces m√©thodes seront utilis√©es pour la s√©rialisation / d√©s√©rialisation, respectivement. </p><br><p>  De plus, Javascript vous permet d'impl√©menter ces m√©thodes pour les types int√©gr√©s, par exemple, pour Date: </p><br><div class="spoiler">  <b class="spoiler_title">S√©rialiser la date au format ISO</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p>  L'essentiel est de ne pas oublier d'enregistrer le type Date: <code>serializer.register(Date);</code>  . </p><br><p>  R√©sultat: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p>  La seule limitation: le r√©sultat de la s√©rialisation ne doit pas √™tre un entier, car  dans ce cas, il sera interpr√©t√© comme une r√©f√©rence √† l'objet. </p><br><p>  De m√™me, vous pouvez s√©rialiser des classes simples en cha√Ænes.  Un exemple de s√©rialisation de la classe Color, qui d√©crit la couleur, √† la ligne <code>#rrggbb</code> est sur <a href="">github</a> . </p><br><h4 id="ploskiy-serializator">  S√©rialiseur plat </h4><br><p>  Sp√©cialement pour vous, chers lecteurs, j'ai √©crit la <a href="">deuxi√®me version du s√©rialiseur</a> , qui parcourt l'arbre des objets non pas r√©cursivement en profondeur, mais de mani√®re it√©rative en largeur en utilisant une file d'attente. </p><br><p>  Pour comparaison, je donnerai un exemple de s√©rialisation des deux premiers sommets de notre sch√©ma dans les deux cas. </p><br><div class="spoiler">  <b class="spoiler_title">S√©rialiseur r√©cursif (s√©rialisation en profondeur)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">S√©rialiseur plat (√† l'√©chelle de la s√©rialisation)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p>  Personnellement, j'aime encore plus la deuxi√®me option que la premi√®re, mais il ne faut pas oublier qu'en choisissant l'une des options, vous ne pouvez pas utiliser l'autre.  Tout est question de liens.  Notez que dans le s√©rialiseur plat, un lien vers le deuxi√®me sommet pr√©c√®de sa description. </p><br><h3 id="plyusy-i-minusy-serializatora">  Avantages et inconv√©nients du s√©rialiseur </h3><br><p>  Avantages: </p><br><ul><li>  Le code du s√©rialiseur est assez simple et compact (environ 300 lignes, dont la moiti√© sont des commentaires). </li><li>  Le s√©rialiseur est facile √† utiliser et ne n√©cessite pas de biblioth√®ques tierces. </li><li>  Il existe un support int√©gr√© pour l'interface de s√©rialisation pour la s√©rialisation arbitraire des classes. </li><li>  Le r√©sultat est agr√©ablement agr√©able √† l'≈ìil (√† mon humble avis). </li><li>  D√©velopper un s√©rialiseur / d√©s√©rialiseur similaire dans d'autres langues n'est pas un probl√®me.  Cela peut √™tre n√©cessaire si le r√©sultat de la s√©rialisation est trait√© au verso. </li></ul><br><p>  Inconv√©nients: </p><br><ul><li>  Le s√©rialiseur n√©cessite l'enregistrement de classes qu'il peut s√©rialiser. </li><li>  Il existe de l√©g√®res restrictions sur les noms de champ des objets. </li><li>  Le s√©rialiseur est √©crit noob en Javascript, il peut donc contenir des bugs et des erreurs. </li><li>  Les performances sur de grandes quantit√©s de donn√©es peuvent en souffrir. </li></ul><br><p>  Un inconv√©nient est √©galement que le code est √©crit en ES6.  Bien s√ªr, il est possible de convertir vers des versions ant√©rieures de Javascript, mais je n'ai pas v√©rifi√© la compatibilit√© du code r√©sultant avec diff√©rents navigateurs. </p><br><h3 id="drugie-moi-publikacii">  Mes autres publications </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Localisation de projets sur .NET avec un interpr√©teur de fonctions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Remplir des mod√®les de texte avec des donn√©es bas√©es sur un mod√®le.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation .NET √† l'aide de fonctions de bytecode dynamique (IL)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413113/">https://habr.com/ru/post/fr413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413103/index.html">3CX v15.5 Update 5 Int√©gration b√™ta et REST avec AmoCRM publi√©</a></li>
<li><a href="../fr413105/index.html">Notes du fournisseur IoT. Activation et s√©curit√© dans LoraWAN</a></li>
<li><a href="../fr413107/index.html">Traduction du wiki du projet Svelto.ECS. Cadre ECS pour Unity3D</a></li>
<li><a href="../fr413109/index.html">Comment cr√©er une plate-forme d'int√©gration de produits SaaS: exp√©rience de v√©rification d'affiches</a></li>
<li><a href="../fr413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../fr413117/index.html">Comment programmer en toute s√©curit√© dans bash</a></li>
<li><a href="../fr413119/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 317 (28 mai - 3 juin 2018)</a></li>
<li><a href="../fr413121/index.html">Visite photo du coworking √† Moscou #tceh</a></li>
<li><a href="../fr413123/index.html">JOIN dans les bases de donn√©es NoSQL</a></li>
<li><a href="../fr413125/index.html">La th√©rapie g√©nique donne aux petits patients atteints d'atrophie musculaire une chance de survivre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>