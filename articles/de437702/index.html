<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂ üë©üèø‚Äçü§ù‚Äçüë®üèª üÄÑÔ∏è Google Job Interview Parsing: Synonyme Abfragen üë®üèæ‚Äçüè´ üò£ üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist ein neuer Artikel aus einer Diskussion von Aufgaben aus Interviews in Google . Als ich dort arbeitete, bot ich Kandidaten solche Aufgaben an....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Job Interview Parsing: Synonyme Abfragen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Dies ist ein neuer Artikel aus einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion von Aufgaben aus Interviews in Google</a> .  Als ich dort arbeitete, bot ich Kandidaten solche Aufgaben an.  Dann gab es ein Leck und sie wurden verboten.  Aber die M√ºnze hat eine Kehrseite: Jetzt kann ich die L√∂sung frei erkl√§ren. <br><a name="habracut"></a><br>  Tolle Neuigkeiten f√ºr den Anfang: Ich habe Google verlassen!  Ich freue mich, Ihnen mitteilen zu k√∂nnen, dass ich jetzt als technischer Manager von Reddit in New York arbeite!  Diese Artikelserie wird jedoch weiterhin fortgesetzt. <br><br>  <i>Haftungsausschluss: Obwohl das Befragen von Kandidaten eine meiner beruflichen Aufgaben ist, teile ich in diesem Blog pers√∂nliche Beobachtungen, Geschichten und pers√∂nliche Meinungen.</i>  <i>Bitte betrachten Sie dies nicht als offizielle Erkl√§rung von Google, Alphabet, Reddit, einer anderen Person oder Organisation.</i> <br><br><h1>  Frage </h1><br>  Nach den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten beiden</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln</a> √ºber die Fortschritte des Pferdes beim W√§hlen einer Telefonnummer erhielt ich Kritik, dass dies kein realistisches Problem ist.  Egal wie n√ºtzlich es ist, die Denkf√§higkeiten des Kandidaten zu studieren, ich muss zugeben: Die Aufgabe ist wirklich ein wenig unrealistisch.  Obwohl ich einige Gedanken √ºber den Zusammenhang zwischen Interviewfragen und Realit√§t habe, werde ich sie mir vorerst √ºberlassen.  Seien Sie sicher, ich lese √ºberall Kommentare und habe etwas zu beantworten, aber nicht jetzt. <br><br>  Aber als die Aufgabe, das Pferd zu √ºbergeben, vor einigen Jahren verboten wurde, nahm ich mir Kritik zu Herzen und versuchte, sie durch eine Frage zu ersetzen, die f√ºr den Umfang von Google etwas relevanter ist.  Und was kann f√ºr Google relevanter sein als die Mechanik von Suchanfragen?  Also habe ich diese Frage gefunden und lange benutzt, bevor sie auch √∂ffentlich wurde und verboten wurde.  Nach wie vor werde ich die Frage formulieren, in ihre Erkl√§rung eintauchen und dann erz√§hlen, wie ich sie in Interviews verwendet habe und warum sie mir gef√§llt. <br><br>  Die Frage ist also. <br><br>  Stellen Sie sich vor, Sie verwalten eine beliebte Suchmaschine und sehen zwei Anfragen in den Protokollen: "Obamas Zustimmungsrate" und "Obamas Beliebtheitsgrad" (wenn ich mich richtig erinnere, sind dies echte Beispiele aus der Fragenbasis, obwohl sie jetzt etwas veraltet sind ...) .  Wir sehen unterschiedliche Abfragen, aber alle sind sich einig: Benutzer suchen im Wesentlichen nach denselben Informationen. Daher sollten Abfragen beim Z√§hlen der Anzahl der Abfragen, Anzeigen von Ergebnissen usw. als gleichwertig angesehen werden. <b>Wie stellen Sie fest, ob zwei Abfragen synonym sind?</b> <br><br>  Lassen Sie uns die Aufgabe formalisieren.  Angenommen, es gibt zwei S√§tze von Zeichenfolgenpaaren: Synonympaare und Abfragepaare. <br><br>  Im Folgenden finden Sie eine Beispieleingabe zur Veranschaulichung: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Es ist notwendig, eine Liste logischer Werte zu erstellen: Sind die Abfragen in jedem Paar synonym. <br><br><h1>  Alle neuen Fragen ... </h1><br>  Auf den ersten Blick ist dies eine einfache Aufgabe.  Aber je l√§nger Sie denken, desto schwieriger wird es.  Kann ein Wort mehrere Synonyme haben?  Ist die Wortreihenfolge wichtig?  Sind synonym Beziehungen transitiv, dh wenn A gleichbedeutend mit B ist und B gleichbedeutend mit C ist, ist A ein Synonym f√ºr C?  K√∂nnen Synonyme ein paar W√∂rter umfassen, wie ist "USA" ein Synonym f√ºr die Ausdr√ºcke "Vereinigte Staaten von Amerika" oder "Vereinigte Staaten"? <br><br>  Eine solche Mehrdeutigkeit erm√∂glicht es sofort, sich einem guten Kandidaten zu beweisen.  Das erste, was er tut, ist, solche Unklarheiten zu suchen und zu l√∂sen.  Jeder tut dies auf unterschiedliche Weise: Einige n√§hern sich dem Board und versuchen, bestimmte F√§lle manuell zu l√∂sen, w√§hrend andere die Frage betrachten und sofort die L√ºcken erkennen.  In jedem Fall ist es entscheidend, diese Probleme fr√ºhzeitig zu erkennen. <br><br>  Die Phase des "Verst√§ndnisses des Problems" ist von gro√üer Bedeutung.  Ich nenne Software Engineering gerne eine fraktale Disziplin.  Wie Fraktale zeigt die Approximation zus√§tzliche Komplexit√§t.  Sie denken, Sie verstehen das Problem und schauen es sich dann genauer an - und Sie sehen, dass Sie einige Feinheiten oder Details der Implementierung √ºbersehen haben, die verbessert werden k√∂nnen.  Oder eine andere Herangehensweise an das Problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Mandelbrot gesetzt</font></i> <br><br>  <b>Das Kaliber eines Ingenieurs h√§ngt weitgehend davon ab, wie tief er das Problem verstehen kann.</b>  Die Umwandlung einer vagen Erkl√§rung des Problems in einen detaillierten Satz von Anforderungen ist der erste Schritt in diesem Prozess. Durch gezieltes Understatement k√∂nnen Sie bewerten, wie gut der Kandidat f√ºr neue Situationen geeignet ist. <br><br>  <i>Wir lassen triviale Fragen wie ‚ÄûSind Gro√übuchstaben wichtig?‚Äú Abgesehen, die den Hauptalgorithmus nicht beeinflussen.</i>  <i>Ich gebe immer die einfachste Antwort auf diese Fragen (in diesem Fall ‚ÄûAngenommen, alle Buchstaben sind bereits vorverarbeitet und werden in Kleinbuchstaben umgewandelt‚Äú).</i> <br><br><h1>  Teil 1. (nicht ganz) ein einfacher Fall </h1><br>  Wenn Kandidaten Fragen stellen, beginne ich immer mit dem einfachsten Fall: Ein Wort kann mehrere Synonyme haben, die Reihenfolge der W√∂rter ist wichtig, Synonyme sind nicht transitiv.  Dies gibt der Suchmaschine eine recht eingeschr√§nkte Funktionalit√§t, verf√ºgt jedoch √ºber gen√ºgend Feinheiten f√ºr ein interessantes Interview. <br><br>  Eine allgemeine √úbersicht lautet wie folgt: Teilen Sie die Abfrage in W√∂rter auf (z. B. durch Leerzeichen) und vergleichen Sie die entsprechenden Paare, um nach identischen W√∂rtern und Synonymen zu suchen.  Optisch sieht es so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  Im Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Einfach, oder?  Algorithmisch ist es ziemlich einfach.  Keine dynamische Programmierung, Rekursion, komplexe Strukturen usw. Einfache Manipulation der Standardbibliothek und eines Algorithmus, der in linearer Zeit arbeitet, oder? <br><br>  Aber es gibt mehr Nuancen, als es auf den ersten Blick scheint.  Die schwierigste Komponente ist nat√ºrlich der Vergleich von Synonymen.  Obwohl die Komponente leicht zu verstehen und zu beschreiben ist, gibt es viele M√∂glichkeiten, einen Fehler zu machen.  Ich erz√§hle Ihnen von den h√§ufigsten Fehlern. <br><br>  Aus Gr√ºnden der Klarheit: Keine Fehler disqualifizieren einen Kandidaten.  Wenn das so ist, weise ich nur auf einen Fehler in der Implementierung hin, der behoben wird, und wir fahren fort.  Ein Interview ist jedoch in erster Linie ein Kampf gegen die Zeit.  Sie werden Fehler machen, bemerken und korrigieren, aber es braucht Zeit, die f√ºr einen anderen aufgewendet werden kann, um beispielsweise eine optimalere L√∂sung zu finden.  Fast jeder macht Fehler, das ist normal, aber Kandidaten, die sie kleiner machen, zeigen bessere Ergebnisse, einfach weil sie weniger Zeit damit verbringen, sie zu korrigieren. <br><br>  Deshalb mag ich dieses Problem.  Wenn der Schritt eines Ritters einen Einblick in das Verst√§ndnis des Algorithmus und dann (ich hoffe) eine einfache Implementierung erfordert, dann ist die L√∂sung viele Schritte in die richtige Richtung.  Jeder Schritt stellt ein winziges Hindernis dar, durch das der Kandidat entweder anmutig springen oder stolpern und sich erheben kann.  Dank Erfahrung und Intuition vermeiden gute Kandidaten diese kleinen Fallstricke - und erhalten eine detailliertere und korrektere L√∂sung, w√§hrend schw√§chere Zeit und Energie f√ºr Fehler aufwenden und normalerweise beim falschen Code bleiben. <br><br>  Bei jedem Interview sah ich eine andere Kombination aus Erfolg und Misserfolg. Dies sind die h√§ufigsten Fehler. <br><br><h4>  Zuf√§llige Leistungskiller </h4><br>  Erstens haben einige Kandidaten die Synonymerkennung implementiert, indem sie einfach die Liste der Synonyme durchlaufen haben: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  Auf den ersten Blick erscheint dies vern√ºnftig.  Bei n√§herer Betrachtung ist die Idee jedoch sehr, sehr schlecht.  F√ºr diejenigen unter Ihnen, die Python nicht kennen, ist das Schl√ºsselwort in syntaktischer Zucker f√ºr die Methode includes und funktioniert auf allen Standard-Python-Containern.  Dies ist ein Problem, da <code>synonym_words</code> eine Liste ist, die das Schl√ºsselwort in mithilfe der linearen Suche implementiert.  Python-Benutzer reagieren besonders empfindlich auf diesen Fehler, da die Sprache Typen verbirgt. C ++ - und Java-Benutzer haben jedoch manchmal √§hnliche Fehler gemacht. <br><br>  Im Laufe meiner Karriere habe ich nur einige Male mit linearem Suchcode geschrieben und jeweils auf einer Liste von nicht mehr als zwei Dutzend Elementen.  Und selbst in diesem Fall schrieb er einen langen Kommentar, in dem er erkl√§rte, warum er sich f√ºr einen scheinbar suboptimalen Ansatz entschieden hatte.  Ich vermute, dass einige Kandidaten es einfach verwendet haben, weil sie nicht wussten, wie das Schl√ºsselwort in in Listen in der Python-Standardbibliothek funktioniert.  Dies ist ein einfacher Fehler, nicht t√∂dlich, aber eine schlechte Kenntnis Ihrer Lieblingssprache ist nicht sehr gut. <br><br>  In der Praxis wird dieser Fehler leicht vermieden.  Vergessen Sie niemals Ihre Objekttypen, auch wenn Sie eine untypisierte Sprache wie Python verwenden!  Denken Sie zweitens daran, dass eine lineare Suche beginnt, wenn Sie das Schl√ºsselwort <i>in in</i> der Liste verwenden.  Wenn es keine Garantie gibt, dass diese Liste immer sehr klein bleibt, wird die Leistung beeintr√§chtigt. <br><br>  Damit der Kandidat zur Besinnung kommt, reicht es normalerweise aus, ihn daran zu erinnern, dass die Eingabestruktur eine Liste ist.  Es ist sehr wichtig zu beobachten, wie der Kandidat auf die Aufforderung reagiert.  Die besten Kandidaten versuchen sofort, die Synonyme irgendwie vorzuverarbeiten, was ein guter Anfang ist.  Dieser Ansatz ist jedoch nicht ohne Fallstricke ... <br><br><h4>  Verwenden Sie die richtige Datenstruktur </h4><br>  Aus dem obigen Code wird sofort klar, dass es zur Implementierung dieses Algorithmus in linearer Zeit notwendig ist, Synonyme schnell zu finden.  Und wenn wir √ºber schnelle Suchen sprechen, ist es immer eine Karte oder eine Reihe von Hashes. <br><br>  Es ist mir egal, ob der Kandidat eine Karte oder eine Reihe von Hashes ausw√§hlt.  Das Wichtigste ist, dass er es dort ablegt (verwenden Sie √ºbrigens niemals Diktat / Hashmap beim √úbergang zu <code>True</code> oder <code>False</code> ).  Die meisten Kandidaten w√§hlen eine Art Diktat / Hashmap.  Der h√§ufigste Fehler ist die unbewusste Annahme, dass jedes Wort nicht mehr als ein Synonym hat: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Ich bestrafe keine Kandidaten f√ºr diesen Fehler.  Die Aufgabe ist speziell formuliert, um sich nicht auf die Tatsache zu konzentrieren, dass W√∂rter mehrere Synonyme haben k√∂nnen, und einige Kandidaten sind einfach nicht auf eine solche Situation gesto√üen.  Beheben Sie am schnellsten einen Fehler, wenn ich darauf zeige.  Gute Kandidaten bemerken es fr√ºh und verbringen normalerweise nicht viel Zeit. <br><br>  Ein etwas schwerwiegenderes Problem ist das mangelnde Bewusstsein, dass sich die Beziehung der Synonyme in beide Richtungen ausbreitet.  Beachten Sie, dass dies im obigen Code ber√ºcksichtigt wird.  Es gibt jedoch Implementierungen mit einem Fehler: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Warum zwei Einf√ºgungen und doppelt so viel Speicher verwenden? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Fazit: √úberlegen Sie <i>immer, wie Sie den Code optimieren k√∂nnen</i> !  R√ºckblickend ist die Permutation der Suchfunktionen eine offensichtliche Optimierung, ansonsten k√∂nnen wir den Schluss ziehen, dass der Kandidat nicht √ºber Optimierungsoptionen nachgedacht hat.  Auch hier gebe ich gerne einen Hinweis, aber es ist besser, selbst zu raten. <br><br><h1>  Sortieren? </h1><br>  Einige intelligente Kandidaten m√∂chten die Liste der Synonyme sortieren und dann die bin√§re Suche verwenden.  Tats√§chlich hat dieser Ansatz einen wichtigen Vorteil: Er ben√∂tigt keinen zus√§tzlichen Platz, au√üer f√ºr die Liste der Synonyme (vorausgesetzt, die Liste darf ge√§ndert werden). <br><br>  Leider st√∂rt die Zeitkomplexit√§t: Das Sortieren einer Liste von Synonymen erfordert <code>Nlog(N)</code> und dann ein weiteres <code>log(N)</code> , um nach jedem Synonympaar zu suchen, w√§hrend die beschriebene Vorverarbeitungsl√∂sung in linearer und dann konstanter Zeit erfolgt.  Dar√ºber hinaus bin ich kategorisch dagegen, den Kandidaten zu zwingen, Sortierung und bin√§re Suche an der Tafel zu implementieren, weil: 1) die Sortieralgorithmen bekannt sind, daher kann der Kandidat sie meines Wissens ohne nachzudenken ausgeben;  2) Diese Algorithmen sind teuflisch schwer korrekt zu implementieren, und oft machen sogar die besten Kandidaten Fehler, die nichts √ºber ihre Programmierkenntnisse aussagen. <br><br>  Wann immer ein Kandidat eine solche L√∂sung vorschlug, war ich an der Ausf√ºhrungszeit des Programms interessiert und fragte, ob es eine bessere Option g√§be.  Zur Information: Wenn der Interviewer Sie fragt, ob es eine bessere Option gibt, lautet die Antwort fast immer Ja.  Wenn ich Ihnen diese Frage jemals stelle, wird die Antwort sicherlich die folgende sein. <br><br><h4>  Endlich L√∂sung </h4><br>  Am Ende bietet der Kandidat etwas Richtiges und einigerma√üen Optimales.  Hier ist eine Implementierung in linearer Zeit und linearem Raum f√ºr gegebene Bedingungen: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Ein paar kurze Anmerkungen: <br><br><ul><li>  Beachten Sie die Verwendung von <code>dict.get()</code> .  Sie k√∂nnen eine √úberpr√ºfung durchf√ºhren, um festzustellen, ob der Schl√ºssel im Diktat enthalten ist, und ihn dann abrufen. Dies ist jedoch ein komplizierter Ansatz, obwohl Sie auf diese Weise Ihr Wissen √ºber die Standardbibliothek zeigen. </li><li>  Ich pers√∂nlich bin kein Fan von Code mit h√§ufigem <code>continue</code> , und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige Styleguides verbieten oder empfehlen sie nicht</a> .  Ich selbst habe in der ersten Ausgabe dieses Codes die <code>continue</code> Anweisung vergessen, nachdem ich die L√§nge der Anfrage √ºberpr√ºft hatte.  Dies ist kein schlechter Ansatz. Sie m√ºssen nur wissen, dass er fehleranf√§llig ist. </li></ul><br><h1>  Teil 2: Immer h√§rter! </h1><br>  Gute Kandidaten haben nach der L√∂sung des Problems noch zehn bis f√ºnfzehn Minuten Zeit.  Gl√ºcklicherweise gibt es eine Reihe zus√§tzlicher Fragen, obwohl es unwahrscheinlich ist, dass wir in dieser Zeit viel Code schreiben werden.  Dies ist jedoch nicht erforderlich.  Ich m√∂chte zwei Dinge √ºber den Kandidaten wissen: Ist er in der Lage, Algorithmen zu entwickeln und kann er codieren?  Das Problem mit dem Zug des Ritters beantwortet zuerst die Frage nach der Entwicklung des Algorithmus und √ºberpr√ºft dann die Codierung. Hier erhalten wir die Antworten in umgekehrter Reihenfolge. <br><br>  Als der Kandidat den ersten Teil der Frage abgeschlossen hatte, hatte er das Problem bereits mit (√ºberraschend nicht trivialer) Codierung gel√∂st.  In dieser Phase kann ich zuversichtlich √ºber seine F√§higkeit sprechen, rudiment√§re Algorithmen zu entwickeln und Ideen in Code zu √ºbersetzen, sowie √ºber seine Bekanntschaft mit seiner Lieblingssprache und Standardbibliothek.  Jetzt wird das Gespr√§ch viel interessanter, weil die Programmieranforderungen gelockert werden k√∂nnen und wir uns mit den Algorithmen befassen werden. <br><br>  Zu diesem Zweck kehren wir zu den Hauptpostulaten des ersten Teils zur√ºck: Die Wortreihenfolge ist wichtig, Synonyme sind nicht transitiv und f√ºr jedes Wort k√∂nnen mehrere Synonyme vorhanden sein.  Im Verlauf des Interviews √§ndere ich jede dieser Einschr√§nkungen, und in dieser neuen Phase f√ºhren der Kandidat und ich eine rein algorithmische Diskussion.  Hier werde ich Codebeispiele geben, um meinen Standpunkt zu veranschaulichen, aber in einem echten Interview sprechen wir nur √ºber Algorithmen. <br><br>  Bevor ich anfange, erkl√§re ich meine Position: Alle nachfolgenden Aktionen in dieser Phase des Interviews sind haupts√§chlich ‚ÄûBonuspunkte‚Äú.  Mein pers√∂nlicher Ansatz ist es, Kandidaten zu identifizieren, die genau die erste Phase durchlaufen und f√ºr die Arbeit geeignet sind.  Die zweite Stufe wird ben√∂tigt, um das Beste hervorzuheben.  Die erste Bewertung ist bereits sehr stark und bedeutet, dass der Kandidat gut genug f√ºr das Unternehmen ist, und die zweite Bewertung besagt, dass der Kandidat ausgezeichnet ist und seine Einstellung ein gro√üer Sieg f√ºr uns sein wird. <br><br><h1>  Transitivit√§t: Naive Ans√§tze </h1><br>  Zun√§chst m√∂chte ich die Transitivit√§tsbeschr√§nkung entfernen. Wenn also die Paare A - B und B - C Synonyme sind, sind die W√∂rter A und C auch Synonyme.  Intelligente Kandidaten werden schnell verstehen, wie sie ihre vorherige L√∂sung anpassen k√∂nnen, obwohl mit der weiteren Beseitigung anderer Einschr√§nkungen die grundlegende Logik des Algorithmus nicht mehr funktioniert. <br><br>  Wie kann man es jedoch anpassen?  Ein √ºblicher Ansatz besteht darin, einen vollst√§ndigen Satz von Synonymen f√ºr jedes Wort basierend auf transitiven Beziehungen beizubehalten.  Jedes Mal, wenn wir ein Wort in eine Reihe von Synonymen einf√ºgen, f√ºgen wir es auch den entsprechenden Mengen f√ºr alle W√∂rter in dieser Menge hinzu: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Bitte beachten Sie, dass wir uns beim Erstellen des Codes bereits mit dieser L√∂sung befasst haben.</font></i> <br><br>  Diese L√∂sung funktioniert, ist aber alles andere als optimal.  Um die Gr√ºnde zu verstehen, sch√§tzen wir die r√§umliche Komplexit√§t dieser L√∂sung.  Jedes Synonym muss nicht nur zur Menge des Anfangsworts hinzugef√ºgt werden, sondern auch zu der Menge aller seiner Synonyme.  Wenn es ein Synonym gibt, wird ein Eintrag hinzugef√ºgt.  Wenn wir jedoch 50 Synonyme haben, m√ºssen Sie 50 Eintr√§ge hinzuf√ºgen.  In der Abbildung sieht es so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Beachten Sie, dass wir von drei Schl√ºsseln und sechs Datens√§tzen zu vier Schl√ºsseln und zw√∂lf Datens√§tzen gewechselt sind.  Ein Wort mit 50 Synonymen erfordert 50 Schl√ºssel und fast 2500 Eintr√§ge.  Der notwendige Raum f√ºr die Darstellung eines Wortes w√§chst quadratisch mit einer Zunahme der Synonyme, was ziemlich verschwenderisch ist. <br><br>  Es gibt andere L√∂sungen, aber ich werde nicht zu tief gehen, um den Artikel nicht aufzublasen.  Das interessanteste davon ist die Verwendung der Synonymdatenstruktur zum Erstellen eines gerichteten Graphen und anschlie√üend eine Breitensuche, um den Pfad zwischen zwei W√∂rtern zu finden.  Dies ist eine gro√üartige L√∂sung, aber die Suche wird linear in der Gr√∂√üe der Synonyme f√ºr das Wort.  Da wir diese Suche f√ºr jede Anforderung mehrmals durchf√ºhren, ist dieser Ansatz nicht optimal. <br><br><h1>  Transitivit√§t: Verwenden von disjunkten Mengen </h1><br>  Es stellt sich heraus, dass die Suche nach Synonymen dank einer Datenstruktur, die als disjunkte Mengen bezeichnet wird, f√ºr eine (fast) konstante Zeit m√∂glich ist.  Diese Struktur bietet etwas andere M√∂glichkeiten als ein regul√§rer Datensatz. <br><br>  Die √ºbliche Set-Struktur (Hashset, TreeSet) ist ein Container, mit dem Sie schnell feststellen k√∂nnen, ob sich ein Objekt innerhalb oder au√üerhalb befindet.  Disjunkte Mengen l√∂sen ein v√∂llig anderes Problem: Anstatt ein bestimmtes Element zu definieren, k√∂nnen Sie bestimmen, <i>ob zwei Elemente zu derselben Menge geh√∂ren</i> .  Dar√ºber hinaus tut die Struktur dies f√ºr eine blendend schnelle Zeit <code>O(a(n))</code> , wobei <code>a(n)</code> die inverse Ackerman-Funktion ist.  Wenn Sie keine fortgeschrittenen Algorithmen studiert haben, kennen Sie diese Funktion m√∂glicherweise nicht, die f√ºr alle vern√ºnftigen Eingaben tats√§chlich in konstanter Zeit ausgef√ºhrt wird. <br><br>  Auf hoher Ebene funktioniert der Algorithmus wie folgt.  Mengen werden durch B√§ume mit Eltern f√ºr jedes Element dargestellt.  Da jeder Baum eine Wurzel hat (ein Element, das sein eigenes √ºbergeordnetes Element ist), k√∂nnen wir feststellen, ob zwei Elemente zu derselben Menge geh√∂ren, indem wir ihre Eltern zur Wurzel zur√ºckverfolgen.  Wenn zwei Elemente eine Wurzel haben, geh√∂ren sie zu einer Menge.  Das Kombinieren von Mengen ist ebenfalls einfach: Finden Sie einfach die Wurzelelemente und machen Sie eines davon zur Wurzel des anderen. <br><br>  So weit so gut, aber bisher wurde keine blendende Geschwindigkeit gesehen.  Das Genie dieser Struktur liegt in einem Verfahren, das als <i>Komprimierung bezeichnet wird</i> .  Angenommen, Sie haben den folgenden Baum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Stellen Sie sich vor, Sie m√∂chten wissen, ob <i>schnell</i> und <i>voreilig</i> Synonyme sind.  Gehen Sie alle Eltern durch - und finden Sie die gleiche <i>schnelle</i> Wurzel.  Nehmen wir nun an, wir f√ºhren eine √§hnliche Pr√ºfung f√ºr die W√∂rter <i>schnell</i> und <i>schnell durch</i> .  Wieder gehen wir bis zur Wurzel und von <i>schnell</i> gehen wir den gleichen Weg.  Kann Doppelarbeit vermieden werden? <br><br>  Es stellt sich heraus, dass Sie k√∂nnen.  In gewisser Weise ist jedes Element in diesem Baum dazu bestimmt, zu <i>schnell</i> zu kommen.  Anstatt jedes Mal den gesamten Baum zu durchlaufen, sollten Sie das √ºbergeordnete Element f√ºr alle <i>schnellen</i> Nachkommen √§ndern, um den Weg zur Wurzel zu verk√ºrzen.  Dieser Prozess wird als Komprimierung bezeichnet und ist in disjunkten S√§tzen in die Stammsuchoperation eingebettet.  Zum Beispiel wird <i>die</i> Struktur nach der ersten Operation, bei der <i>schnell</i> und <i>hastig</i> verglichen wird, verstehen, dass es sich um Synonyme handelt, und den Baum wie folgt komprimieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">F√ºr alle W√∂rter zwischen schnell und schnell wurde der Elternteil aktualisiert, dasselbe geschah mit hastig</font></i> <br><br>  Jetzt werden alle nachfolgenden Aufrufe in konstanter Zeit ausgef√ºhrt, da jeder Knoten in diesem Baum auf <i>schnell zeigt</i> .  Es ist nicht sehr einfach, die zeitliche Komplexit√§t von Operationen zu bewerten: Tats√§chlich ist sie nicht konstant, da sie von der Tiefe der B√§ume abh√§ngt, sondern nahezu konstant, da die Struktur schnell optimiert wird.  Der Einfachheit halber nehmen wir an, dass die Zeit konstant ist. <br><br>  Mit diesem Konzept implementieren wir nicht verwandte Mengen f√ºr unser Problem: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dieser Struktur k√∂nnen Sie Synonyme vorverarbeiten und das Problem in linearer Zeit l√∂sen. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewertung und Notizen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir die Grenze dessen erreicht, was ein Kandidat in 40 bis 45 Minuten eines Interviews zeigen kann. </font><font style="vertical-align: inherit;">Allen Kandidaten, die mit dem Einf√ºhrungsteil fertig wurden und erhebliche Fortschritte bei der Beschreibung (nicht Implementierung) nicht verwandter Gruppen erzielt haben, habe ich die Bewertung ‚ÄûSehr empfehlenswert f√ºr die Besch√§ftigung‚Äú zugewiesen und ihnen gestattet, Fragen zu stellen. </font><font style="vertical-align: inherit;">Ich habe noch nie einen Kandidaten gesehen, der so weit gegangen ist und noch viel Zeit hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grunds√§tzlich gibt es immer noch Varianten des Transitivit√§tsproblems: Entfernen Sie beispielsweise die Einschr√§nkung der Wortreihenfolge oder mehrerer Synonyme f√ºr ein Wort. </font><font style="vertical-align: inherit;">Jede Entscheidung wird schwierig und erfreulich sein, aber ich werde sie f√ºr sp√§ter belassen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil dieser Aufgabe besteht darin, dass die Kandidaten Fehler machen k√∂nnen. </font><font style="vertical-align: inherit;">Die t√§gliche Softwareentwicklung besteht aus endlosen Zyklen der Analyse, Ausf√ºhrung und Verfeinerung. </font><font style="vertical-align: inherit;">Dieses Problem erm√∂glicht es den Kandidaten, ihre F√§higkeiten in jeder Phase unter Beweis zu stellen. </font><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie die F√§higkeiten, die erforderlich sind, um die maximale Punktzahl f√ºr dieses Problem zu erzielen:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysieren Sie die Aussage des Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und stellen Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fest, wo es nicht klar formuliert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist. Entwickeln Sie eine eindeutige Formulierung. </font><font style="vertical-align: inherit;">Fahren Sie fort, w√§hrend Sie sich l√∂sen und neue Fragen auftauchen. </font><font style="vertical-align: inherit;">F√ºhren Sie diese Vorg√§nge f√ºr maximale Effizienz so fr√ºh wie m√∂glich aus. Je weiter die Arbeit fortgeschritten ist, desto l√§nger dauert die Behebung des Fehlers.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   ‚Äî    ,          .        ‚Äî    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine dieser F√§higkeiten kann aus Lehrb√ºchern gelernt werden (mit der m√∂glichen Ausnahme von Datenstrukturen und Algorithmen). </font><font style="vertical-align: inherit;">Der einzige Weg, diese zu erwerben, ist eine regelm√§√üige und umfassende Praxis, die gut mit den Bed√ºrfnissen des Arbeitgebers √ºbereinstimmt: erfahrene Kandidaten, die in der Lage sind, ihr Wissen effektiv anzuwenden. </font><font style="vertical-align: inherit;">In den Interviews ging es darum, solche Leute zu finden, und die Aufgabe aus diesem Artikel hat mir lange Zeit gut geholfen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zukunftspl√§ne </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie verstehen k√∂nnen, wurde die Aufgabe schlie√ülich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der √ñffentlichkeit bekannt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Seitdem habe ich mehrere andere Fragen verwendet, abh√§ngig von den Fragen der vorherigen Interviewer und meiner Stimmung (eine Frage zu stellen ist immer langweilig). Ich benutze immer noch einige Fragen, also werde ich sie geheim halten, aber einige sind es nicht! Sie finden sie in den folgenden Artikeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In naher Zukunft plane ich zwei Artikel. Zun√§chst werde ich, wie oben versprochen, die L√∂sung der beiden verbleibenden Probleme f√ºr diese Aufgabe erl√§utern. Ich habe sie nie bei Interviews gefragt, aber sie sind an sich interessant. Dar√ºber hinaus werde ich meine Gedanken und meine pers√∂nliche Meinung zum Verfahren zur Suche nach Mitarbeitern in der IT mitteilen, was f√ºr mich jetzt besonders interessant ist, da ich Ingenieure f√ºr mein Team in Reddit suche.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mehr √ºber die Ver√∂ffentlichung neuer Artikel erfahren m√∂chten, folgen Sie mir wie immer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Ihnen dieser Artikel gefallen hat, vergessen Sie nicht, daf√ºr zu stimmen oder einen Kommentar zu hinterlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danke f√ºrs Lesen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Sie k√∂nnen den Code aller Artikel in untersuchen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit ihnen live spielen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dank meiner guten Freunde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437702/">https://habr.com/ru/post/de437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437686/index.html">Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschl√ºsselung</a></li>
<li><a href="../de437688/index.html">OpenSceneGraph: Grundlegende Programmiertechniken</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
<li><a href="../de437698/index.html">Patent√ºbersetzungsdienst der WIPO - meine Erfahrungen</a></li>
<li><a href="../de437704/index.html">Hervorragende Kenntnis des Lehrplans als Indikator f√ºr nicht die h√∂chste Intelligenz</a></li>
<li><a href="../de437706/index.html">Jahr mit Tesla</a></li>
<li><a href="../de437710/index.html">Beschr√§nkung der lokalen Benutzerrechte unter Linux auf ein Minimum</a></li>
<li><a href="../de437712/index.html">Raumstation Roskomnadzor</a></li>
<li><a href="../de437714/index.html">Wir zeichnen eine Cartoon-Explosion f√ºr 180 Zeilen nacktes C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>