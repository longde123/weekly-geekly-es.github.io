<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶 👩🏿‍🤝‍👨🏻 🀄️ Google Job Interview Parsing: Synonyme Abfragen 👨🏾‍🏫 😣 🏥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist ein neuer Artikel aus einer Diskussion von Aufgaben aus Interviews in Google . Als ich dort arbeitete, bot ich Kandidaten solche Aufgaben an....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Job Interview Parsing: Synonyme Abfragen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Dies ist ein neuer Artikel aus einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion von Aufgaben aus Interviews in Google</a> .  Als ich dort arbeitete, bot ich Kandidaten solche Aufgaben an.  Dann gab es ein Leck und sie wurden verboten.  Aber die Münze hat eine Kehrseite: Jetzt kann ich die Lösung frei erklären. <br><a name="habracut"></a><br>  Tolle Neuigkeiten für den Anfang: Ich habe Google verlassen!  Ich freue mich, Ihnen mitteilen zu können, dass ich jetzt als technischer Manager von Reddit in New York arbeite!  Diese Artikelserie wird jedoch weiterhin fortgesetzt. <br><br>  <i>Haftungsausschluss: Obwohl das Befragen von Kandidaten eine meiner beruflichen Aufgaben ist, teile ich in diesem Blog persönliche Beobachtungen, Geschichten und persönliche Meinungen.</i>  <i>Bitte betrachten Sie dies nicht als offizielle Erklärung von Google, Alphabet, Reddit, einer anderen Person oder Organisation.</i> <br><br><h1>  Frage </h1><br>  Nach den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten beiden</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln</a> über die Fortschritte des Pferdes beim Wählen einer Telefonnummer erhielt ich Kritik, dass dies kein realistisches Problem ist.  Egal wie nützlich es ist, die Denkfähigkeiten des Kandidaten zu studieren, ich muss zugeben: Die Aufgabe ist wirklich ein wenig unrealistisch.  Obwohl ich einige Gedanken über den Zusammenhang zwischen Interviewfragen und Realität habe, werde ich sie mir vorerst überlassen.  Seien Sie sicher, ich lese überall Kommentare und habe etwas zu beantworten, aber nicht jetzt. <br><br>  Aber als die Aufgabe, das Pferd zu übergeben, vor einigen Jahren verboten wurde, nahm ich mir Kritik zu Herzen und versuchte, sie durch eine Frage zu ersetzen, die für den Umfang von Google etwas relevanter ist.  Und was kann für Google relevanter sein als die Mechanik von Suchanfragen?  Also habe ich diese Frage gefunden und lange benutzt, bevor sie auch öffentlich wurde und verboten wurde.  Nach wie vor werde ich die Frage formulieren, in ihre Erklärung eintauchen und dann erzählen, wie ich sie in Interviews verwendet habe und warum sie mir gefällt. <br><br>  Die Frage ist also. <br><br>  Stellen Sie sich vor, Sie verwalten eine beliebte Suchmaschine und sehen zwei Anfragen in den Protokollen: "Obamas Zustimmungsrate" und "Obamas Beliebtheitsgrad" (wenn ich mich richtig erinnere, sind dies echte Beispiele aus der Fragenbasis, obwohl sie jetzt etwas veraltet sind ...) .  Wir sehen unterschiedliche Abfragen, aber alle sind sich einig: Benutzer suchen im Wesentlichen nach denselben Informationen. Daher sollten Abfragen beim Zählen der Anzahl der Abfragen, Anzeigen von Ergebnissen usw. als gleichwertig angesehen werden. <b>Wie stellen Sie fest, ob zwei Abfragen synonym sind?</b> <br><br>  Lassen Sie uns die Aufgabe formalisieren.  Angenommen, es gibt zwei Sätze von Zeichenfolgenpaaren: Synonympaare und Abfragepaare. <br><br>  Im Folgenden finden Sie eine Beispieleingabe zur Veranschaulichung: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Es ist notwendig, eine Liste logischer Werte zu erstellen: Sind die Abfragen in jedem Paar synonym. <br><br><h1>  Alle neuen Fragen ... </h1><br>  Auf den ersten Blick ist dies eine einfache Aufgabe.  Aber je länger Sie denken, desto schwieriger wird es.  Kann ein Wort mehrere Synonyme haben?  Ist die Wortreihenfolge wichtig?  Sind synonym Beziehungen transitiv, dh wenn A gleichbedeutend mit B ist und B gleichbedeutend mit C ist, ist A ein Synonym für C?  Können Synonyme ein paar Wörter umfassen, wie ist "USA" ein Synonym für die Ausdrücke "Vereinigte Staaten von Amerika" oder "Vereinigte Staaten"? <br><br>  Eine solche Mehrdeutigkeit ermöglicht es sofort, sich einem guten Kandidaten zu beweisen.  Das erste, was er tut, ist, solche Unklarheiten zu suchen und zu lösen.  Jeder tut dies auf unterschiedliche Weise: Einige nähern sich dem Board und versuchen, bestimmte Fälle manuell zu lösen, während andere die Frage betrachten und sofort die Lücken erkennen.  In jedem Fall ist es entscheidend, diese Probleme frühzeitig zu erkennen. <br><br>  Die Phase des "Verständnisses des Problems" ist von großer Bedeutung.  Ich nenne Software Engineering gerne eine fraktale Disziplin.  Wie Fraktale zeigt die Approximation zusätzliche Komplexität.  Sie denken, Sie verstehen das Problem und schauen es sich dann genauer an - und Sie sehen, dass Sie einige Feinheiten oder Details der Implementierung übersehen haben, die verbessert werden können.  Oder eine andere Herangehensweise an das Problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Mandelbrot gesetzt</font></i> <br><br>  <b>Das Kaliber eines Ingenieurs hängt weitgehend davon ab, wie tief er das Problem verstehen kann.</b>  Die Umwandlung einer vagen Erklärung des Problems in einen detaillierten Satz von Anforderungen ist der erste Schritt in diesem Prozess. Durch gezieltes Understatement können Sie bewerten, wie gut der Kandidat für neue Situationen geeignet ist. <br><br>  <i>Wir lassen triviale Fragen wie „Sind Großbuchstaben wichtig?“ Abgesehen, die den Hauptalgorithmus nicht beeinflussen.</i>  <i>Ich gebe immer die einfachste Antwort auf diese Fragen (in diesem Fall „Angenommen, alle Buchstaben sind bereits vorverarbeitet und werden in Kleinbuchstaben umgewandelt“).</i> <br><br><h1>  Teil 1. (nicht ganz) ein einfacher Fall </h1><br>  Wenn Kandidaten Fragen stellen, beginne ich immer mit dem einfachsten Fall: Ein Wort kann mehrere Synonyme haben, die Reihenfolge der Wörter ist wichtig, Synonyme sind nicht transitiv.  Dies gibt der Suchmaschine eine recht eingeschränkte Funktionalität, verfügt jedoch über genügend Feinheiten für ein interessantes Interview. <br><br>  Eine allgemeine Übersicht lautet wie folgt: Teilen Sie die Abfrage in Wörter auf (z. B. durch Leerzeichen) und vergleichen Sie die entsprechenden Paare, um nach identischen Wörtern und Synonymen zu suchen.  Optisch sieht es so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  Im Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Einfach, oder?  Algorithmisch ist es ziemlich einfach.  Keine dynamische Programmierung, Rekursion, komplexe Strukturen usw. Einfache Manipulation der Standardbibliothek und eines Algorithmus, der in linearer Zeit arbeitet, oder? <br><br>  Aber es gibt mehr Nuancen, als es auf den ersten Blick scheint.  Die schwierigste Komponente ist natürlich der Vergleich von Synonymen.  Obwohl die Komponente leicht zu verstehen und zu beschreiben ist, gibt es viele Möglichkeiten, einen Fehler zu machen.  Ich erzähle Ihnen von den häufigsten Fehlern. <br><br>  Aus Gründen der Klarheit: Keine Fehler disqualifizieren einen Kandidaten.  Wenn das so ist, weise ich nur auf einen Fehler in der Implementierung hin, der behoben wird, und wir fahren fort.  Ein Interview ist jedoch in erster Linie ein Kampf gegen die Zeit.  Sie werden Fehler machen, bemerken und korrigieren, aber es braucht Zeit, die für einen anderen aufgewendet werden kann, um beispielsweise eine optimalere Lösung zu finden.  Fast jeder macht Fehler, das ist normal, aber Kandidaten, die sie kleiner machen, zeigen bessere Ergebnisse, einfach weil sie weniger Zeit damit verbringen, sie zu korrigieren. <br><br>  Deshalb mag ich dieses Problem.  Wenn der Schritt eines Ritters einen Einblick in das Verständnis des Algorithmus und dann (ich hoffe) eine einfache Implementierung erfordert, dann ist die Lösung viele Schritte in die richtige Richtung.  Jeder Schritt stellt ein winziges Hindernis dar, durch das der Kandidat entweder anmutig springen oder stolpern und sich erheben kann.  Dank Erfahrung und Intuition vermeiden gute Kandidaten diese kleinen Fallstricke - und erhalten eine detailliertere und korrektere Lösung, während schwächere Zeit und Energie für Fehler aufwenden und normalerweise beim falschen Code bleiben. <br><br>  Bei jedem Interview sah ich eine andere Kombination aus Erfolg und Misserfolg. Dies sind die häufigsten Fehler. <br><br><h4>  Zufällige Leistungskiller </h4><br>  Erstens haben einige Kandidaten die Synonymerkennung implementiert, indem sie einfach die Liste der Synonyme durchlaufen haben: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  Auf den ersten Blick erscheint dies vernünftig.  Bei näherer Betrachtung ist die Idee jedoch sehr, sehr schlecht.  Für diejenigen unter Ihnen, die Python nicht kennen, ist das Schlüsselwort in syntaktischer Zucker für die Methode includes und funktioniert auf allen Standard-Python-Containern.  Dies ist ein Problem, da <code>synonym_words</code> eine Liste ist, die das Schlüsselwort in mithilfe der linearen Suche implementiert.  Python-Benutzer reagieren besonders empfindlich auf diesen Fehler, da die Sprache Typen verbirgt. C ++ - und Java-Benutzer haben jedoch manchmal ähnliche Fehler gemacht. <br><br>  Im Laufe meiner Karriere habe ich nur einige Male mit linearem Suchcode geschrieben und jeweils auf einer Liste von nicht mehr als zwei Dutzend Elementen.  Und selbst in diesem Fall schrieb er einen langen Kommentar, in dem er erklärte, warum er sich für einen scheinbar suboptimalen Ansatz entschieden hatte.  Ich vermute, dass einige Kandidaten es einfach verwendet haben, weil sie nicht wussten, wie das Schlüsselwort in in Listen in der Python-Standardbibliothek funktioniert.  Dies ist ein einfacher Fehler, nicht tödlich, aber eine schlechte Kenntnis Ihrer Lieblingssprache ist nicht sehr gut. <br><br>  In der Praxis wird dieser Fehler leicht vermieden.  Vergessen Sie niemals Ihre Objekttypen, auch wenn Sie eine untypisierte Sprache wie Python verwenden!  Denken Sie zweitens daran, dass eine lineare Suche beginnt, wenn Sie das Schlüsselwort <i>in in</i> der Liste verwenden.  Wenn es keine Garantie gibt, dass diese Liste immer sehr klein bleibt, wird die Leistung beeinträchtigt. <br><br>  Damit der Kandidat zur Besinnung kommt, reicht es normalerweise aus, ihn daran zu erinnern, dass die Eingabestruktur eine Liste ist.  Es ist sehr wichtig zu beobachten, wie der Kandidat auf die Aufforderung reagiert.  Die besten Kandidaten versuchen sofort, die Synonyme irgendwie vorzuverarbeiten, was ein guter Anfang ist.  Dieser Ansatz ist jedoch nicht ohne Fallstricke ... <br><br><h4>  Verwenden Sie die richtige Datenstruktur </h4><br>  Aus dem obigen Code wird sofort klar, dass es zur Implementierung dieses Algorithmus in linearer Zeit notwendig ist, Synonyme schnell zu finden.  Und wenn wir über schnelle Suchen sprechen, ist es immer eine Karte oder eine Reihe von Hashes. <br><br>  Es ist mir egal, ob der Kandidat eine Karte oder eine Reihe von Hashes auswählt.  Das Wichtigste ist, dass er es dort ablegt (verwenden Sie übrigens niemals Diktat / Hashmap beim Übergang zu <code>True</code> oder <code>False</code> ).  Die meisten Kandidaten wählen eine Art Diktat / Hashmap.  Der häufigste Fehler ist die unbewusste Annahme, dass jedes Wort nicht mehr als ein Synonym hat: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Ich bestrafe keine Kandidaten für diesen Fehler.  Die Aufgabe ist speziell formuliert, um sich nicht auf die Tatsache zu konzentrieren, dass Wörter mehrere Synonyme haben können, und einige Kandidaten sind einfach nicht auf eine solche Situation gestoßen.  Beheben Sie am schnellsten einen Fehler, wenn ich darauf zeige.  Gute Kandidaten bemerken es früh und verbringen normalerweise nicht viel Zeit. <br><br>  Ein etwas schwerwiegenderes Problem ist das mangelnde Bewusstsein, dass sich die Beziehung der Synonyme in beide Richtungen ausbreitet.  Beachten Sie, dass dies im obigen Code berücksichtigt wird.  Es gibt jedoch Implementierungen mit einem Fehler: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Warum zwei Einfügungen und doppelt so viel Speicher verwenden? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Fazit: Überlegen Sie <i>immer, wie Sie den Code optimieren können</i> !  Rückblickend ist die Permutation der Suchfunktionen eine offensichtliche Optimierung, ansonsten können wir den Schluss ziehen, dass der Kandidat nicht über Optimierungsoptionen nachgedacht hat.  Auch hier gebe ich gerne einen Hinweis, aber es ist besser, selbst zu raten. <br><br><h1>  Sortieren? </h1><br>  Einige intelligente Kandidaten möchten die Liste der Synonyme sortieren und dann die binäre Suche verwenden.  Tatsächlich hat dieser Ansatz einen wichtigen Vorteil: Er benötigt keinen zusätzlichen Platz, außer für die Liste der Synonyme (vorausgesetzt, die Liste darf geändert werden). <br><br>  Leider stört die Zeitkomplexität: Das Sortieren einer Liste von Synonymen erfordert <code>Nlog(N)</code> und dann ein weiteres <code>log(N)</code> , um nach jedem Synonympaar zu suchen, während die beschriebene Vorverarbeitungslösung in linearer und dann konstanter Zeit erfolgt.  Darüber hinaus bin ich kategorisch dagegen, den Kandidaten zu zwingen, Sortierung und binäre Suche an der Tafel zu implementieren, weil: 1) die Sortieralgorithmen bekannt sind, daher kann der Kandidat sie meines Wissens ohne nachzudenken ausgeben;  2) Diese Algorithmen sind teuflisch schwer korrekt zu implementieren, und oft machen sogar die besten Kandidaten Fehler, die nichts über ihre Programmierkenntnisse aussagen. <br><br>  Wann immer ein Kandidat eine solche Lösung vorschlug, war ich an der Ausführungszeit des Programms interessiert und fragte, ob es eine bessere Option gäbe.  Zur Information: Wenn der Interviewer Sie fragt, ob es eine bessere Option gibt, lautet die Antwort fast immer Ja.  Wenn ich Ihnen diese Frage jemals stelle, wird die Antwort sicherlich die folgende sein. <br><br><h4>  Endlich Lösung </h4><br>  Am Ende bietet der Kandidat etwas Richtiges und einigermaßen Optimales.  Hier ist eine Implementierung in linearer Zeit und linearem Raum für gegebene Bedingungen: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Ein paar kurze Anmerkungen: <br><br><ul><li>  Beachten Sie die Verwendung von <code>dict.get()</code> .  Sie können eine Überprüfung durchführen, um festzustellen, ob der Schlüssel im Diktat enthalten ist, und ihn dann abrufen. Dies ist jedoch ein komplizierter Ansatz, obwohl Sie auf diese Weise Ihr Wissen über die Standardbibliothek zeigen. </li><li>  Ich persönlich bin kein Fan von Code mit häufigem <code>continue</code> , und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige Styleguides verbieten oder empfehlen sie nicht</a> .  Ich selbst habe in der ersten Ausgabe dieses Codes die <code>continue</code> Anweisung vergessen, nachdem ich die Länge der Anfrage überprüft hatte.  Dies ist kein schlechter Ansatz. Sie müssen nur wissen, dass er fehleranfällig ist. </li></ul><br><h1>  Teil 2: Immer härter! </h1><br>  Gute Kandidaten haben nach der Lösung des Problems noch zehn bis fünfzehn Minuten Zeit.  Glücklicherweise gibt es eine Reihe zusätzlicher Fragen, obwohl es unwahrscheinlich ist, dass wir in dieser Zeit viel Code schreiben werden.  Dies ist jedoch nicht erforderlich.  Ich möchte zwei Dinge über den Kandidaten wissen: Ist er in der Lage, Algorithmen zu entwickeln und kann er codieren?  Das Problem mit dem Zug des Ritters beantwortet zuerst die Frage nach der Entwicklung des Algorithmus und überprüft dann die Codierung. Hier erhalten wir die Antworten in umgekehrter Reihenfolge. <br><br>  Als der Kandidat den ersten Teil der Frage abgeschlossen hatte, hatte er das Problem bereits mit (überraschend nicht trivialer) Codierung gelöst.  In dieser Phase kann ich zuversichtlich über seine Fähigkeit sprechen, rudimentäre Algorithmen zu entwickeln und Ideen in Code zu übersetzen, sowie über seine Bekanntschaft mit seiner Lieblingssprache und Standardbibliothek.  Jetzt wird das Gespräch viel interessanter, weil die Programmieranforderungen gelockert werden können und wir uns mit den Algorithmen befassen werden. <br><br>  Zu diesem Zweck kehren wir zu den Hauptpostulaten des ersten Teils zurück: Die Wortreihenfolge ist wichtig, Synonyme sind nicht transitiv und für jedes Wort können mehrere Synonyme vorhanden sein.  Im Verlauf des Interviews ändere ich jede dieser Einschränkungen, und in dieser neuen Phase führen der Kandidat und ich eine rein algorithmische Diskussion.  Hier werde ich Codebeispiele geben, um meinen Standpunkt zu veranschaulichen, aber in einem echten Interview sprechen wir nur über Algorithmen. <br><br>  Bevor ich anfange, erkläre ich meine Position: Alle nachfolgenden Aktionen in dieser Phase des Interviews sind hauptsächlich „Bonuspunkte“.  Mein persönlicher Ansatz ist es, Kandidaten zu identifizieren, die genau die erste Phase durchlaufen und für die Arbeit geeignet sind.  Die zweite Stufe wird benötigt, um das Beste hervorzuheben.  Die erste Bewertung ist bereits sehr stark und bedeutet, dass der Kandidat gut genug für das Unternehmen ist, und die zweite Bewertung besagt, dass der Kandidat ausgezeichnet ist und seine Einstellung ein großer Sieg für uns sein wird. <br><br><h1>  Transitivität: Naive Ansätze </h1><br>  Zunächst möchte ich die Transitivitätsbeschränkung entfernen. Wenn also die Paare A - B und B - C Synonyme sind, sind die Wörter A und C auch Synonyme.  Intelligente Kandidaten werden schnell verstehen, wie sie ihre vorherige Lösung anpassen können, obwohl mit der weiteren Beseitigung anderer Einschränkungen die grundlegende Logik des Algorithmus nicht mehr funktioniert. <br><br>  Wie kann man es jedoch anpassen?  Ein üblicher Ansatz besteht darin, einen vollständigen Satz von Synonymen für jedes Wort basierend auf transitiven Beziehungen beizubehalten.  Jedes Mal, wenn wir ein Wort in eine Reihe von Synonymen einfügen, fügen wir es auch den entsprechenden Mengen für alle Wörter in dieser Menge hinzu: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Bitte beachten Sie, dass wir uns beim Erstellen des Codes bereits mit dieser Lösung befasst haben.</font></i> <br><br>  Diese Lösung funktioniert, ist aber alles andere als optimal.  Um die Gründe zu verstehen, schätzen wir die räumliche Komplexität dieser Lösung.  Jedes Synonym muss nicht nur zur Menge des Anfangsworts hinzugefügt werden, sondern auch zu der Menge aller seiner Synonyme.  Wenn es ein Synonym gibt, wird ein Eintrag hinzugefügt.  Wenn wir jedoch 50 Synonyme haben, müssen Sie 50 Einträge hinzufügen.  In der Abbildung sieht es so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Beachten Sie, dass wir von drei Schlüsseln und sechs Datensätzen zu vier Schlüsseln und zwölf Datensätzen gewechselt sind.  Ein Wort mit 50 Synonymen erfordert 50 Schlüssel und fast 2500 Einträge.  Der notwendige Raum für die Darstellung eines Wortes wächst quadratisch mit einer Zunahme der Synonyme, was ziemlich verschwenderisch ist. <br><br>  Es gibt andere Lösungen, aber ich werde nicht zu tief gehen, um den Artikel nicht aufzublasen.  Das interessanteste davon ist die Verwendung der Synonymdatenstruktur zum Erstellen eines gerichteten Graphen und anschließend eine Breitensuche, um den Pfad zwischen zwei Wörtern zu finden.  Dies ist eine großartige Lösung, aber die Suche wird linear in der Größe der Synonyme für das Wort.  Da wir diese Suche für jede Anforderung mehrmals durchführen, ist dieser Ansatz nicht optimal. <br><br><h1>  Transitivität: Verwenden von disjunkten Mengen </h1><br>  Es stellt sich heraus, dass die Suche nach Synonymen dank einer Datenstruktur, die als disjunkte Mengen bezeichnet wird, für eine (fast) konstante Zeit möglich ist.  Diese Struktur bietet etwas andere Möglichkeiten als ein regulärer Datensatz. <br><br>  Die übliche Set-Struktur (Hashset, TreeSet) ist ein Container, mit dem Sie schnell feststellen können, ob sich ein Objekt innerhalb oder außerhalb befindet.  Disjunkte Mengen lösen ein völlig anderes Problem: Anstatt ein bestimmtes Element zu definieren, können Sie bestimmen, <i>ob zwei Elemente zu derselben Menge gehören</i> .  Darüber hinaus tut die Struktur dies für eine blendend schnelle Zeit <code>O(a(n))</code> , wobei <code>a(n)</code> die inverse Ackerman-Funktion ist.  Wenn Sie keine fortgeschrittenen Algorithmen studiert haben, kennen Sie diese Funktion möglicherweise nicht, die für alle vernünftigen Eingaben tatsächlich in konstanter Zeit ausgeführt wird. <br><br>  Auf hoher Ebene funktioniert der Algorithmus wie folgt.  Mengen werden durch Bäume mit Eltern für jedes Element dargestellt.  Da jeder Baum eine Wurzel hat (ein Element, das sein eigenes übergeordnetes Element ist), können wir feststellen, ob zwei Elemente zu derselben Menge gehören, indem wir ihre Eltern zur Wurzel zurückverfolgen.  Wenn zwei Elemente eine Wurzel haben, gehören sie zu einer Menge.  Das Kombinieren von Mengen ist ebenfalls einfach: Finden Sie einfach die Wurzelelemente und machen Sie eines davon zur Wurzel des anderen. <br><br>  So weit so gut, aber bisher wurde keine blendende Geschwindigkeit gesehen.  Das Genie dieser Struktur liegt in einem Verfahren, das als <i>Komprimierung bezeichnet wird</i> .  Angenommen, Sie haben den folgenden Baum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Stellen Sie sich vor, Sie möchten wissen, ob <i>schnell</i> und <i>voreilig</i> Synonyme sind.  Gehen Sie alle Eltern durch - und finden Sie die gleiche <i>schnelle</i> Wurzel.  Nehmen wir nun an, wir führen eine ähnliche Prüfung für die Wörter <i>schnell</i> und <i>schnell durch</i> .  Wieder gehen wir bis zur Wurzel und von <i>schnell</i> gehen wir den gleichen Weg.  Kann Doppelarbeit vermieden werden? <br><br>  Es stellt sich heraus, dass Sie können.  In gewisser Weise ist jedes Element in diesem Baum dazu bestimmt, zu <i>schnell</i> zu kommen.  Anstatt jedes Mal den gesamten Baum zu durchlaufen, sollten Sie das übergeordnete Element für alle <i>schnellen</i> Nachkommen ändern, um den Weg zur Wurzel zu verkürzen.  Dieser Prozess wird als Komprimierung bezeichnet und ist in disjunkten Sätzen in die Stammsuchoperation eingebettet.  Zum Beispiel wird <i>die</i> Struktur nach der ersten Operation, bei der <i>schnell</i> und <i>hastig</i> verglichen wird, verstehen, dass es sich um Synonyme handelt, und den Baum wie folgt komprimieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">Für alle Wörter zwischen schnell und schnell wurde der Elternteil aktualisiert, dasselbe geschah mit hastig</font></i> <br><br>  Jetzt werden alle nachfolgenden Aufrufe in konstanter Zeit ausgeführt, da jeder Knoten in diesem Baum auf <i>schnell zeigt</i> .  Es ist nicht sehr einfach, die zeitliche Komplexität von Operationen zu bewerten: Tatsächlich ist sie nicht konstant, da sie von der Tiefe der Bäume abhängt, sondern nahezu konstant, da die Struktur schnell optimiert wird.  Der Einfachheit halber nehmen wir an, dass die Zeit konstant ist. <br><br>  Mit diesem Konzept implementieren wir nicht verwandte Mengen für unser Problem: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit dieser Struktur können Sie Synonyme vorverarbeiten und das Problem in linearer Zeit lösen. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewertung und Notizen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir die Grenze dessen erreicht, was ein Kandidat in 40 bis 45 Minuten eines Interviews zeigen kann. </font><font style="vertical-align: inherit;">Allen Kandidaten, die mit dem Einführungsteil fertig wurden und erhebliche Fortschritte bei der Beschreibung (nicht Implementierung) nicht verwandter Gruppen erzielt haben, habe ich die Bewertung „Sehr empfehlenswert für die Beschäftigung“ zugewiesen und ihnen gestattet, Fragen zu stellen. </font><font style="vertical-align: inherit;">Ich habe noch nie einen Kandidaten gesehen, der so weit gegangen ist und noch viel Zeit hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundsätzlich gibt es immer noch Varianten des Transitivitätsproblems: Entfernen Sie beispielsweise die Einschränkung der Wortreihenfolge oder mehrerer Synonyme für ein Wort. </font><font style="vertical-align: inherit;">Jede Entscheidung wird schwierig und erfreulich sein, aber ich werde sie für später belassen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil dieser Aufgabe besteht darin, dass die Kandidaten Fehler machen können. </font><font style="vertical-align: inherit;">Die tägliche Softwareentwicklung besteht aus endlosen Zyklen der Analyse, Ausführung und Verfeinerung. </font><font style="vertical-align: inherit;">Dieses Problem ermöglicht es den Kandidaten, ihre Fähigkeiten in jeder Phase unter Beweis zu stellen. </font><font style="vertical-align: inherit;">Berücksichtigen Sie die Fähigkeiten, die erforderlich sind, um die maximale Punktzahl für dieses Problem zu erzielen:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysieren Sie die Aussage des Problems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und stellen Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fest, wo es nicht klar formuliert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist. Entwickeln Sie eine eindeutige Formulierung. </font><font style="vertical-align: inherit;">Fahren Sie fort, während Sie sich lösen und neue Fragen auftauchen. </font><font style="vertical-align: inherit;">Führen Sie diese Vorgänge für maximale Effizienz so früh wie möglich aus. Je weiter die Arbeit fortgeschritten ist, desto länger dauert die Behebung des Fehlers.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   —    ,          .        —    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine dieser Fähigkeiten kann aus Lehrbüchern gelernt werden (mit der möglichen Ausnahme von Datenstrukturen und Algorithmen). </font><font style="vertical-align: inherit;">Der einzige Weg, diese zu erwerben, ist eine regelmäßige und umfassende Praxis, die gut mit den Bedürfnissen des Arbeitgebers übereinstimmt: erfahrene Kandidaten, die in der Lage sind, ihr Wissen effektiv anzuwenden. </font><font style="vertical-align: inherit;">In den Interviews ging es darum, solche Leute zu finden, und die Aufgabe aus diesem Artikel hat mir lange Zeit gut geholfen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zukunftspläne </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie verstehen können, wurde die Aufgabe schließlich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Öffentlichkeit bekannt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Seitdem habe ich mehrere andere Fragen verwendet, abhängig von den Fragen der vorherigen Interviewer und meiner Stimmung (eine Frage zu stellen ist immer langweilig). Ich benutze immer noch einige Fragen, also werde ich sie geheim halten, aber einige sind es nicht! Sie finden sie in den folgenden Artikeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In naher Zukunft plane ich zwei Artikel. Zunächst werde ich, wie oben versprochen, die Lösung der beiden verbleibenden Probleme für diese Aufgabe erläutern. Ich habe sie nie bei Interviews gefragt, aber sie sind an sich interessant. Darüber hinaus werde ich meine Gedanken und meine persönliche Meinung zum Verfahren zur Suche nach Mitarbeitern in der IT mitteilen, was für mich jetzt besonders interessant ist, da ich Ingenieure für mein Team in Reddit suche.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mehr über die Veröffentlichung neuer Artikel erfahren möchten, folgen Sie mir wie immer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Ihnen dieser Artikel gefallen hat, vergessen Sie nicht, dafür zu stimmen oder einen Kommentar zu hinterlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danke fürs Lesen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Sie können den Code aller Artikel in untersuchen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit ihnen live spielen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dank meiner guten Freunde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437702/">https://habr.com/ru/post/de437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437686/index.html">Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschlüsselung</a></li>
<li><a href="../de437688/index.html">OpenSceneGraph: Grundlegende Programmiertechniken</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
<li><a href="../de437698/index.html">Patentübersetzungsdienst der WIPO - meine Erfahrungen</a></li>
<li><a href="../de437704/index.html">Hervorragende Kenntnis des Lehrplans als Indikator für nicht die höchste Intelligenz</a></li>
<li><a href="../de437706/index.html">Jahr mit Tesla</a></li>
<li><a href="../de437710/index.html">Beschränkung der lokalen Benutzerrechte unter Linux auf ein Minimum</a></li>
<li><a href="../de437712/index.html">Raumstation Roskomnadzor</a></li>
<li><a href="../de437714/index.html">Wir zeichnen eine Cartoon-Explosion für 180 Zeilen nacktes C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>