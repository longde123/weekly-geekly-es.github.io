<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”§ ğŸ›°ï¸ ğŸª Apa yang baru di CUBA 7 ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸˆ ğŸ‘¨ğŸ¿â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang baru di CUBA 7 


 Tiga tahun yang lalu kami mengumumkan versi utama kedua dari kerangka tersebut. CUBA 6 adalah versi pengubah permainan - l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang baru di CUBA 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/444558/"><h1 id="whats-new-in-cuba-7">  Apa yang baru di CUBA 7 </h1><br><p>  Tiga tahun yang lalu kami mengumumkan versi utama kedua dari kerangka tersebut.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA 6</a> adalah versi pengubah permainan - lisensi diubah dari proprietary menjadi Apache 2.0.  Hari-hari itu kami bahkan tidak bisa menebak di mana ia akan membawa kerangka kerja dalam jangka panjang.  Komunitas CUBA mulai tumbuh secara eksponensial, jadi kami telah belajar banyak cara yang mungkin (dan kadang-kadang tidak mungkin) tentang bagaimana pengembang menggunakan kerangka kerja.  Sekarang kami dengan senang hati mengumumkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA 7</a> , yang, kami harap, akan membuat pengembangan lebih koheren dan menyenangkan bagi semua anggota masyarakat dari mereka yang baru memulai perjalanan mereka di CUBA dan Jawa kepada pengembang perusahaan yang terampil dan pakar Jawa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d60/280/788/d602807880920f1c89cc34aa4c944f11.png" alt="kuba"></p><a name="habracut"></a><br><h2 id="development-tools">  Alat pengembangan </h2><br><p>  Jelas, sebagian besar dari kesuksesan CUBA kami berutang kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA Studio</a> .  Ini sangat menyederhanakan rutinitas perusahaan Java yang terlalu padat, di banyak tempat menghentikannya untuk membuat konfigurasi sepele pada desainer visual: tidak perlu tahu Persistence API atau Gradle atau bahkan Spring untuk mengembangkan aplikasi CRUD yang lengkap dan kaya fitur - Studio akan melakukannya untukmu </p><br><p>  Studio adalah aplikasi web yang terpisah dan fakta ini menyebabkan beberapa batasan signifikan: </p><br><ul><li>  Pertama-tama, Studio bukan IDE yang berfitur lengkap, sehingga pengembang harus beralih antara Studio dan IntelliJ IDEA atau Eclipse untuk mengembangkan logika bisnis dan mendapat manfaat dari navigasi yang mudah, penyelesaian kode dan hal-hal penting lainnya, yang menjengkelkan. </li><li>  Kedua, kesederhanaan ajaib ini dibangun di atas parsing dan generasi kode sumber besar.  Meningkatkan kemampuan pembuatan kode berarti bergerak menuju pengembangan IDE berfitur lengkap - suatu usaha yang terlalu ambisius. </li></ul><br><p>  Kami memutuskan untuk bersandar di bahu raksasa lain untuk mengatasi keterbatasan ini.  Studio digabung menjadi IntelliJ IDEA oleh JetBrains.  Sekarang Anda dapat menginstalnya sebagai plugin untuk IntelliJ IDEA Anda atau unduh sebagai bundel mandiri terpisah. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/91f/e64/eba91fe64a5025522853a054d2e6d720.png" alt="Kuba1"></p><br><p>  Ini membuka cakrawala baru: </p><br><ul><li>  Dukungan bahasa JVM lainnya (dan Kotlin di tempat pertama) </li><li>  Peningkatan penyebaran panas </li><li>  Navigasi intuitif melalui seluruh proyek </li><li>  Petunjuk yang lebih cerdas dan generator kode </li></ul><br><p>  Saat ini Studio baru sedang dalam pengembangan aktif: kami porting fitur dari versi lama.  Rencana jangka pendek juga untuk mengimplementasikan kembali desainer berbasis web menggunakan UI IntelliJ asli dan meningkatkan pengalaman navigasi proyek. </p><br><h2 id="stack-upgrade">  Upgrade tumpukan </h2><br><p>  Secara tradisional, tumpukan yang mendasarinya juga telah ditingkatkan secara besar-besaran, misalnya Java 8/11, Vaadin 8, Spring 5. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f9a/5f9/fb4f9a5f937e543e339dfba51e637f2e.png" alt="Kuba2"></p><br><p>  Secara default, proyek baru menggunakan Java 8, tetapi Anda dapat menentukan versi Java dengan menambahkan klausa berikut ke file build.gradle: </p><br><pre><code class="plaintext hljs">subprojects { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 }</code> </pre> <br><p>  Memutakhirkan ke Vaadin 8 adalah tantangan besar karena perubahan besar pada API pengikatan data Vaadin.  Untungnya, CUBA mengabstraksi pengembang dari Vaadin internal dengan membungkusnya ke dalam lapisan APInya sendiri.  Tim CUBA melakukan pekerjaan luar biasa dalam mengimplementasikan internal menjaga APInya sendiri tidak tersentuh.  Ini berarti kompatibilitas sepenuhnya disimpan dan Anda dapat mengambil manfaat dari Vaadin 8 segera setelah memigrasi proyek ke CUBA 7 tanpa refactoring apa pun. </p><br><p>  Daftar lengkap dependensi yang diperbarui tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan rilis</a> resmi. </p><br><h2 id="new-screens-api">  API Layar Baru </h2><br><p>  Bagian ini juga dapat dinamai "API layar pertama" - karena CUBA tidak pernah memiliki API yang dinyatakan secara resmi di tingkat klien web.  Itu berasal dari sejarah kerangka kerja dan asumsi-asumsi tertentu yang dibuat pada tahap pertama: </p><br><ul><li>  Pendekatan deklaratif-sentris - segala sesuatu yang dapat dideskripsikan secara deklaratif, harus dinyatakan dalam deskriptor layar dan tidak diberi kode pada pengontrolnya </li><li>  Layar standar (Browser dan Editor) menyediakan fungsionalitas umum yang konkret dan tidak perlu memodifikasinya </li></ul><br><p>  Sejak seribu anggota pertama bergabung dengan komunitas kami, kami menyadari betapa beragamnya persyaratan untuk layar CRUD "standar" - jauh melampaui serangkaian fitur yang awalnya dirancang.  Namun demikian, untuk waktu yang lama kami dapat menangani permintaan untuk perilaku khusus bahkan tanpa lapisan API - berkat asumsi tahap pertama lainnya - Open Inheritance.  Warisan Terbuka yang Efektif berarti bahwa Anda dapat mengganti metode umum atau terlindung dari kelas dasar untuk menyesuaikan perilakunya dengan apa yang Anda butuhkan.  Ini mungkin terdengar seperti obat untuk semua penyakit, tetapi pada kenyataannya itu tidak memberi Anda bahkan kontrak jangka pendek: bagaimana jika metode yang diganti akan diganti namanya, dihapus atau tidak pernah digunakan dalam versi kerangka kerja yang akan datang? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ed/043/150/4ed0431505177eab85281d6f583f4bc4.png" alt="cuba3"></p><br><p>  Jadi, sebagai tanggapan terhadap meningkatnya permintaan dari komunitas, kami memutuskan untuk memperkenalkan API layar baru.  API menyediakan titik ekstensi yang jelas dan jangka panjang tanpa sihir deklaratif tersembunyi, fleksibel, dan sangat mudah digunakan. </p><br><h3 id="screen-declaration">  Deklarasi layar </h3><br><p>  Dalam deklarasi layar CUBA 7 sangat sederhana: </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") // screen id public class NewScreen extends Screen { }</code> </pre> <br><p>  Dari contoh di atas kita dapat melihat bahwa pengenal layar didefinisikan secara eksplisit tepat di atas kelas controller.  Dengan kata lain, id layar dan kelas pengontrol sekarang secara unik berhubungan satu sama lain.  Jadi, kabar baiknya, sekarang layar dapat diatasi secara langsung oleh kelas pengontrolnya dengan cara yang aman: </p><br><pre> <code class="plaintext hljs">@Inject private ScreenBuilders screenBuilders; @Subscribe private void onBeforeClose(BeforeCloseEvent event) { screenBuilders.screen(this) .withScreenClass(SomeConfirmationScreen.class) .build() .show(); }</code> </pre> <br><p>  Deskriptor layar menjadi bagian pelengkap alih-alih wajib.  Layout dapat dibuat secara terprogram atau dideklarasikan sebagai deskriptor layar xml, yang ditentukan oleh penjelasan @UiDescriptor pada kelas controller.  Ini membuat pengontrol dan tata letak lebih mudah dibaca dan dipahami - pendekatan ini sangat mirip dengan yang digunakan dalam pengembangan Android. </p><br><p>  Sebelumnya, itu juga diperlukan untuk mendaftarkan deskriptor layar di file web-screens.xml dan menetapkan pengenal untuk itu.  Dalam CUBA 7 file ini disimpan karena alasan kompatibilitas, namun membuat layar dengan cara baru tidak memerlukan pendaftaran tersebut. </p><br><h3 id="screens-lifecycle">  Layar siklus hidup </h3><br><p>  API baru memperkenalkan acara siklus hidup layar yang jelas dan jelas: </p><br><ul><li>  Init </li><li>  Setelah itu </li><li>  Di depan </li><li>  Entah bagaimana </li><li>  Sebelum ditutup </li><li>  Setelah ditutup </li></ul><br><p>  Semua acara terkait layar di CUBA 7 dapat berlangganan sebagai berikut: </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") public class NewScreen extends Screen { @Subscribe private void onInit(InitEvent event) { } @Subscribe private void onBeforeShow(BeforeShowEvent event) { } }</code> </pre> <br><p>  Membandingkan API baru dengan pendekatan lama, Anda dapat melihat bahwa kami tidak mengesampingkan metode kait, yang secara tidak jelas disebut dalam hierarki kelas induk, tetapi mendefinisikan logika dalam poin yang sudah ditentukan sebelumnya dari siklus hidup layar. </p><br><h3 id="event-handling-and-functional-delegates">  Penanganan Acara dan Delegasi Fungsional </h3><br><p>  Pada bagian sebelumnya, kami belajar cara berlangganan acara siklus hidup, jadi, bagaimana dengan komponen lain?  Haruskah kita masih menyebarkan semua pendengar yang diperlukan pada inisialisasi layar seperti dalam versi 6.x?  API baru sangat seragam, jadi berlangganan ke acara lain benar-benar mirip dengan siklus hidup. </p><br><p>  Mari kita ambil contoh sederhana dengan dua elemen UI: tombol dan bidang mata uang, sehingga deskriptor xmlnya terlihat seperti: </p><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd" caption="msg://caption" messagesPack="com.company.demo.web"&gt; &lt;layout&gt; &lt;hbox spacing="true"&gt; &lt;currencyField id="currencyField" currency="$" currencyLabelPosition="LEFT"/&gt; &lt;button id="calcPriceBtn" caption="Calculate Price"/&gt; &lt;/hbox&gt; &lt;/layout&gt; &lt;/window&gt;</code> </pre> <br><p>  Dengan mengklik tombol, kami memanggil layanan middleware mengembalikan nomor, yang masuk ke bidang mata uang.  Bidang mata uang harus berubah gaya tergantung pada nilai harga. </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private PricingService pricingService; @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe("calcPriceBtn") private void onCalcPriceBtnClick(Button.ClickEvent event) { currencyField.setValue(pricingService.calculatePrice()); } @Subscribe("currencyField") private void onPriceChange(HasValue.ValueChangeEvent&lt;BigDecimal&gt; event) { BigDecimal price = pricingService.calculatePrice(); currencyField.setStyleName(getStyleNameByPrice(price)); } private String getStyleNameByPrice(BigDecimal price) { ... } }</code> </pre> <br><p>  Dalam contoh di atas kita dapat melihat dua pengendali acara: satu dipanggil ketika tombol diklik dan satu lagi dieksekusi ketika bidang mata uang mengubah nilainya - sesederhana itu. </p><br><p>  Sekarang, mari kita bayangkan bahwa kita perlu memvalidasi harga kita dan memeriksa apakah nilainya positif.  Cara mudah adalah menambahkan validator saat inisialisasi layar: </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe private void onInit(InitEvent event) { currencyField.addValidator(value -&gt; { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); }); } }</code> </pre> <br><p>  Dalam aplikasi dunia nyata, titik masuk layar biasanya dipenuhi dengan inisialisasi elemen layar semacam ini.  Untuk mengatasi masalah ini, CUBA memberikan penjelasan berguna <code>@Install</code> .  Mari kita lihat bagaimana ini dapat membantu dalam kasus kami: </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Install(to = "currencyField", subject = "validator") private void currencyFieldValidator(BigDecimal value) { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); } }</code> </pre> <br><p>  Bahkan kami mendelegasikan logika validasi dari bidang mata uang kami ke metode <em>currencyFieldValidator</em> di layar kami.  Ini mungkin terlihat agak rumit, namun, pengembang mengadopsi fitur ini secara mengejutkan cepat. </p><br><h3 id="screen-builders--notifications--dialogs">  Pembuat Layar / Pemberitahuan / Dialog </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/b4b/83a/d7bb4b83a2ac4b60988f0a7e59b91dae.png" alt="cuba4"></p><br><p>  CUBA 7 juga memperkenalkan serangkaian komponen yang berguna dengan API yang lancar: </p><br><ul><li><p>  <strong>ScreenBuilders</strong> menggabungkan pabrik yang fasih untuk menghasilkan pencarian standar, editor dan layar khusus.  Contoh di bawah ini menunjukkan bagaimana Anda dapat membuka satu layar dari yang lain.  Perhatikan, bahwa metode <em>build ()</em> mengembalikan instance layar dari tipe yang tepat, tanpa perlu membuangnya dengan tidak aman. </p><br><p>  CurrencyConversions currencyConversions = screenBuilders.screen (ini) <br>  .withScreenClass (CurrencyConversions.class) <br>  .withLaunchMode (OpenMode.DIALOG) <br>  .build (); <br>  currencyConversions.setBaseCurrency (Currency.EUR); <br>  currencyConversions.show (); </p><br></li><li><p>  Komponen <strong>layar</strong> memberikan abstraksi tingkat yang lebih rendah untuk membuat dan menampilkan layar daripada <em>ScreenBuilders</em> .  Ini juga menyediakan akses ke informasi tentang semua layar yang dibuka di aplikasi CUBA Anda ( <em>Layar # getOpenedScreens</em> ) jika Anda perlu mengulanginya. </p><br></li><li><p>  Komponen <strong>Notifikasi</strong> dan <strong>Dialog</strong> sama-sama memperkenalkan antarmuka self-explanatory yang nyaman.  Berikut adalah contoh untuk membuat dan menampilkan dialog dan pemberitahuan: </p><br><p>  dialogs.createOptionDialog () <br>  .withCaption ("Dialog pertamaku") <br>  .withMessage ("Apakah Anda ingin berterima kasih kepada tim CUBA?") <br>  .withActions ( <br>  DialogAction baru (DialogAction.Type.YES) .withHandler (e -&gt; <br>  notification.create () <br>  .withCaption ("Terima kasih!") <br>  .withDescription ("Kami menghargai semua anggota komunitas") <br>  .withPosition (Notifications.Position.MIDDLE_CENTER) <br>  .withHideDelayMs (3000) <br>  .show ()), <br>  DialogAction baru (DialogAction.Type.CANCEL) <br>  ) <br>  .show (); </p><br></li></ul><br><h3 id="data-binding">  Pengikatan data </h3><br><p>  CUBA memungkinkan pengembangan UI backoffice yang sangat cepat tidak hanya dengan menyediakan alat visual canggih dengan kemampuan generasi kode yang luas, tetapi juga oleh serangkaian komponen yang sadar data yang tersedia langsung di luar kotak.  Komponen semacam itu hanya perlu mengetahui data apa yang mereka kerjakan dan sisanya akan dikelola secara otomatis, misalnya daftar pencarian, bidang pemilih, berbagai kisi dengan operasi CRUD dan sebagainya. </p><br><p>  Sebelum versi 7 pengikatan data dilaksanakan melalui apa yang disebut sumber data - objek yang membungkus satu entitas atau kumpulan entitas untuk secara reaktif mengikatnya dengan komponen yang sadar data.  Pendekatan ini bekerja dengan sangat baik, namun, implementasi-bijaksana itu adalah monolit.  Arsitektur monolitik biasanya menyebabkan masalah dengan kustomisasi, sehingga dalam CUBA 7 batu padat ini dibagi menjadi 3 komponen data: </p><br><ul><li>  <strong>Pemuat data</strong> adalah penyedia data untuk wadah data.  Pemuat data tidak menyimpan data, mereka hanya meneruskan semua parameter kueri yang diperlukan ke penyimpanan data dan umpan data wadah dengan set data yang dihasilkan. </li><li>  <strong>Wadah data</strong> menjaga data yang dimuat (entitas tunggal atau sejumlah entitas) dan memberikannya kepada komponen yang sadar data secara reaktif: semua perubahan entitas yang dibungkus terkena komponen UI yang sesuai dan sebaliknya, semua perubahan dalam komponen UI akan mengarah pada perubahan terkait dalam wadah datanya. </li><li>  <strong>Konteks data</strong> adalah manajer modifikasi data yang kuat yang melacak perubahan dan melakukan semua entitas yang dimodifikasi.  Suatu entitas dapat digabungkan ke dalam konteks data, sehingga akan memberikan salinan entitas asli dengan perbedaan satu-satunya, tetapi sangat penting: semua modifikasi dari entitas yang dihasilkan dan semua entitas yang dirujuk (termasuk koleksi) akan dilacak, disimpan, dan berkomitmen sesuai. </li></ul><br><p>  Komponen data dapat dideklarasikan dalam deskriptor layar atau instantiated secara terprogram menggunakan pabrik khusus - <em>DataComponents</em> . </p><br><h3 id="miscellaneous">  Lain-lain </h3><br><p>  Ufff, bagian terpenting dari layar API baru dijelaskan, jadi izinkan saya mendaftar secara singkat fitur-fitur penting lainnya di tingkat klien web: </p><br><ul><li>  <strong>Riwayat URL dan Navigasi</strong> .  Fitur ini memecahkan masalah SPA yang sangat umum dengan tombol "kembali" di peramban web, menyediakan cara mudah untuk menetapkan rute ke layar aplikasi dan memungkinkan API untuk mencerminkan keadaan layar saat ini di URL-nya. </li><li>  <strong>Bentuk bukan FieldGroup</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FieldGroup</a> adalah komponen yang sadar data untuk menampilkan dan memodifikasi bidang satu entitas.  Itu menyimpulkan UI aktual yang ditunjukkan untuk bidang dalam runtime.  Dengan kata lain, jika Anda memiliki bidang <em>Tanggal</em> di entitas Anda itu akan ditampilkan sebagai <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DateField</a></em> .  Namun, jika Anda ingin mengoperasikan bidang ini secara terprogram, Anda harus menyuntikkan bidang ini ke pengontrol layar dan melemparkannya ke jenis yang tepat secara manual ( <em>DateField dalam contoh kami</em> ).  Kemudian kami mengubah jenis bidang kami ke yang lain dan aplikasi kami macet saat runtime ... Formulir mengatasi masalah ini dengan deklarasi jenis bidang eksplisit.  Temukan informasi lebih lanjut tentang komponen baru ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li><li>  <strong>Integrasi komponen JavaScript pihak ketiga</strong> sangat disederhanakan, ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk menyematkan komponen JavaScript khusus ke dalam aplikasi CUBA. </li><li>  Atribut <strong>HTML / CSS</strong> sekarang dapat dengan mudah didefinisikan langsung dari deskriptor layar xml atau diatur secara terprogram.  Temukan informasi lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br><h2 id="middleware-features">  Fitur Middleware </h2><br><p>  Blok sebelumnya tentang API layar baru lebih besar dari yang saya harapkan, jadi di bagian ini saya akan mencoba untuk menjadi rapi! </p><br><h3 id="entity-changed-event">  Entitas Berubah Peristiwa </h3><br><p>  Entity Changed Event adalah acara aplikasi Musim Semi yang dipecat ketika entitas Anda menuju penyimpanan data, dimasukkan secara fisik dan dalam satu inci komitmen.  Di sini Anda dapat memberikan beberapa cek tambahan (mis. Memeriksa ketersediaan produk dalam stok sebelum mengonfirmasi pesanan) dan memodifikasinya (mis., Menghitung ulang total) tepat sebelum itu akan terlihat untuk transaksi lain (tentu saja dengan tingkat isolasi yang sudah dilakukan).  Anda juga dapat menggunakan acara ini sebagai kesempatan terakhir untuk menghentikan transaksi yang tidak dilakukan dengan melemparkan pengecualian - yang mungkin berguna dalam beberapa kasus sudut. </p><br><p>  Ada juga cara untuk menangkap Peristiwa Berubah Entitas tepat setelah komit terjadi. </p><br><p>  Ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab</a> dokumentasi ini untuk melihat contoh. </p><br><h3 id="transactional-data-manager">  Manajer Data Transaksional </h3><br><p>  Saat mengembangkan aplikasi, kami biasanya beroperasi dengan entitas terpisah - yang tidak dikelola oleh transaksi apa pun.  Namun, bekerja dengan entitas terpisah tidak selalu mungkin, terutama ketika mencoba memenuhi persyaratan ACID - ini adalah kasus ketika Anda dapat menggunakan manajer data transaksional.  Itu terlihat sangat mirip dengan manajer data biasa, tetapi berbeda dalam aspek-aspek berikut: </p><br><ul><li>  Itu dapat bergabung dengan transaksi yang sudah ada (dalam kasus itu disebut dalam konteks transaksional) atau membuat transaksi sendiri. </li><li>  Tidak memiliki metode <em>komit</em> , tetapi ada metode save, yang tidak mengarah pada komit langsung, tetapi menunggu sampai transaksi terlampir akan dilakukan. </li></ul><br><p>  Temukan contoh menggunakannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h3 id="jpa-lifecycle-callbacks">  Callback Siklus Hidup JPA </h3><br><p>  Akhirnya, CUBA 7 mendukung panggilan balik siklus hidup JPA.  Untuk tidak mereplikasi informasi yang ditulis dengan baik tentang apa yang dapat digunakan untuk callback ini, izinkan saya berbagi saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> , yang sepenuhnya mencakup subjek. </p><br><h2 id="what-about-compatibility">  Bagaimana dengan kompatibilitas? </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d41/044/292/d410442925950409df8fdab04102dd95.png" alt="cuba5"></p><br><p>  Sebuah pertanyaan yang wajar untuk rilis besar apa pun, terutama ketika ada begitu banyak perubahan yang tampaknya menghancurkan!  Kami telah merancang semua fitur dan API baru ini dengan mengingat kompatibilitas ke belakang: </p><br><ul><li>  API layar lama didukung dalam CUBA 7 dan diimplementasikan melalui yang baru di bawah tenda :) </li><li>  Kami juga telah menyediakan adaptor untuk pengikatan data lama, yang tetap berfungsi untuk layar kuno. </li></ul><br><p>  Jadi, kabar baiknya, jalur migrasi dari versi 6 ke 7 seharusnya cukup mudah. </p><br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Kesimpulan tinjauan teknis ini saya ingin menyebutkan bahwa ada inovasi penting lainnya, terutama dengan lisensi: </p><br><ul><li>  Batas 10 entitas untuk Studio sekarang hilang </li><li>  Pelaporan, BPM, Bagan, dan Peta serta add-on pencarian teks lengkap sekarang gratis dan open source. </li><li>  Versi komersial Studio menghadirkan kenyamanan pengembangan ekstra dengan desainer visual untuk entitas, layar, menu, dan elemen platform lainnya, sementara versi gratisnya berfokus pada bekerja dengan kode </li><li>  Harap jangan mengatakan bahwa untuk 6.x dan versi yang lebih lama dari persyaratan lisensi Platform dan Studio tetap sama! </li></ul><br><p>  Akhirnya, izinkan saya berterima kasih kepada anggota masyarakat lagi atas semua dukungan dan umpan baliknya.  Saya harap Anda akan menyukai versi 7!  Daftar lengkap perubahan secara tradisional tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan rilis</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444558/">https://habr.com/ru/post/id444558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444548/index.html">Pengalaman pribadi: bagaimana kami terlibat dalam promosi startup Hispanik di Amerika Latin</a></li>
<li><a href="../id444550/index.html">Untuk pertanyaan pembagian</a></li>
<li><a href="../id444552/index.html">TDMS Fairway. Bekerja dengan keahlian</a></li>
<li><a href="../id444554/index.html">API tenang JSON sederhana di Elixir</a></li>
<li><a href="../id444556/index.html">Warna bulan dan matahari dari ruang angkasa di nilai RGB dan suhu warna</a></li>
<li><a href="../id444560/index.html">Kami mengundang Anda ke konferensi "Awan. Tren Mode â€26 Maret 2019</a></li>
<li><a href="../id444562/index.html">Modernisasi GHIDRA. Loader untuk rum Sega Mega Drive</a></li>
<li><a href="../id444564/index.html">Pengembangan Produk Digital dengan Model Mental</a></li>
<li><a href="../id444566/index.html">Sikorsky mengadakan demonstrasi helikopter tak berawak dengan seorang pria di dalamnya</a></li>
<li><a href="../id444568/index.html">10 bug teratas dari proyek C ++ ditemukan pada 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>