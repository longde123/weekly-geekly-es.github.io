<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîó üêµ ‚õΩÔ∏è Cara menulis kontrak pintar untuk ICO dalam 5 menit üà∑Ô∏è üçú üêπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Pada artikel ini saya akan memberi tahu Anda cara meluncurkan kontrak pengumpulan uang pintar untuk ICO Anda di Ethereum dalam 5 menit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menulis kontrak pintar untuk ICO dalam 5 menit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414493/"><img src="https://habrastorage.org/webt/rv/6d/_c/rv6d_cyxk3ix-su6le9q4lyqntc.png"><br><br>  Halo semuanya!  Pada artikel ini saya akan memberi tahu Anda cara meluncurkan kontrak pengumpulan uang pintar untuk ICO Anda di Ethereum dalam 5 menit dan beberapa perintah di terminal.  Esai ini berpotensi menghemat puluhan ribu dolar AS, karena setiap programmer - dan bukan programmer juga - akan dapat meluncurkan kontrak pintar yang diaudit dan aman (alih-alih membayar $ 15.000 - $ 75.000 untuk pengembangan).  Singkatnya, Anda dapat mengirim uang ke kontrak pintar ini dan menerima token ERC20 untuk itu.  Dapat dikatakan bahwa artikel ini adalah kumpulan dari semua pengalaman yang saya peroleh dengan meluncurkan ICO untuk proyek saya. <br><br>  Di Internet, ini dari Anda sudah penuh dengan artikel tentang kontrak pintar, tetapi segera setelah Anda mulai menulis satu, Anda menemukan fakta bahwa informasi tersebut diulang di mana-mana, dan tidak ada tutorial tentang cara menipu ERC20 Anda, atau sudah usang.  Ngomong-ngomong, agar artikel ini tetap relevan, saya akan mencoba menunjukkan tempat-tempat potensial di mana artikel itu menjadi usang (dan bagaimana cara memperbaikinya).  Ayo pergi! <br><a name="habracut"></a><br><h2>  Soliditas </h2><br>  Ini adalah nama bahasa utama yang dikembangkan tim kefir untuk meluncurkan kontrak cerdas.  Jika Anda seorang programmer, maka cukup periksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi bahasa</a> - itu tidak senonoh sederhana.  Omong-omong, mereka membuatnya sederhana sehingga lebih sulit untuk membuat kesalahan dalam menulis kontrak yang cerdas.  Jadi <b>benar-benar</b> programmer <b>mana pun</b> , setidaknya di tingkat junior, akan dapat mengetahuinya.  <b>Sama sekali tidak ada</b> gunanya membayar sejumlah besar uang kepada pengembang yang tahu soliditas - itu akan menjadi urutan lebih murah untuk melatih pengembang yang ada. <br><br><h2>  Kontrak yang cerdas </h2><br>  ... dan semua yang perlu Anda ketahui tentang mereka.  Lewati bagian ini jika Anda bukan seorang programmer.  Kontrak yang cerdas adalah sepotong kode.  Pada prinsipnya, ini adalah kelas dalam soliditas (OOP, ya), yang memiliki dua jenis fungsi: state-changing dan non-state-changing.  Nah, untuk menjalankan fungsi dalam kontrak pintar hanya dengan mengirim kefir untuk itu, Anda harus menandai fungsi ini <code>payable</code> . <br><br>  State adalah gudang data, blockchain, EPT.  Kontrak dapat mengubah blockchain (status, penyimpanan) - tetapi untuk mengubah blockchain Anda harus membayar kefir ke penambang.  Bagaimana mereka akan membagikan kefir tidak akan dianalisis dalam kerangka artikel ini.  Pembayaran kepada penambang untuk menjalankan kode yang diubah negara disebut Gas.  Jika seseorang dari luar melempar kefir ke alamat kontrak pintar dengan panggilan ke fungsi yang ditandai <code>payable</code> tetapi tidak ditandai <code>Constant</code> , <code>View</code> atau <code>Pure</code> , maka jumlah kefir yang diperlukan untuk pembayaran kepada penambang akan dikurangkan dari jumlah yang dikirim.  Biasanya, dalam token ERC20, ini adalah fungsi yang memberikan pengirim token untuk kefir atau mentransfer token dari satu pemegang token ke yang lain. <br><br>  Dan jika Anda menandai suatu fungsi dalam kontrak dengan kata <code>Constant</code> atau <code>View</code> (artinya sama, mereka hanya memungkinkan Anda membaca status) atau <code>Pure</code> (hal yang sama, Anda bahkan tidak membaca keadaan), maka Anda bahkan tidak perlu mengeluarkan kefir untuk fungsi ini!  Saya bahkan akan mengatakan lebih banyak bahwa fungsi-fungsi ini tidak perlu dipanggil oleh transaksi - setelah semua, klien yogurt dapat secara teoritis menjalankannya di rumah - dan tidak ada yang perlu tahu tentang ini lagi (lagi pula, tidak ada yang ditulis ke blockchain). <br><br>  Dan ada dua hal penting dalam soliditas: multiple inheritance dan function modifiers.  Anda juga perlu tahu tentang mereka. <br><br>  Kontrak pertama yang adil dapat diwarisi secara simultan dari beberapa kelas seperti <code>TimedCrowdsale</code> , <code>CappedCrowdsale</code> , <code>MintedCrowdsale</code> , <code>Ownable</code> - pada saat yang sama, fungsi konstruktor juga diluncurkan satu demi satu - tetapi saya akan menjelaskan ini nanti sebagai contoh. <br><br>  Yang kedua adalah kemampuan untuk membuat fungsi yang kemudian akan dimasukkan ke fungsi lain.  Ini seperti enkapsulasi sederhana, hanya sedikit lebih fleksibel - ini sebenarnya <b>adalah templat</b> fungsi.  Ketika Anda membuat pengubah, Anda menulis karakter khusus <code>_</code> mana Anda maksud kode fungsi menggunakan pengubah ini.  Artinya, pengubah bukan hanya fungsionalitas yang dienkapsulasi yang mengembalikan nilai;  ini adalah templat fungsi ketika kode dari pengubah secara harfiah dimasukkan ke dalam fungsi menggunakan pengubah ini. <br><br>  Mari kita lanjutkan berlatih. <br><br><h2>  Lingkungan memasak </h2><br>  Jika Anda tidak tahu apa itu Terminal, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini di sini</a> .  Jika Anda berada di windows, tentukan sendiri Terminal melalui WLS.  Jika Anda sudah terbiasa dengan Terminal, mari kita lanjutkan.  Juga, segera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tempatkan sendiri</a> Node.js - itu akan diperlukan untuk langkah selanjutnya.  Lebih baik untuk menginstal LTS, tetapi, pada kenyataannya, tidak ada bedanya yang mana dari versi modern dari node untuk menginstal. <br><br>  Hal pertama yang kami segera instal dan memulai proses sinkronisasi blok adalah <code>geth</code> .  Singkatnya, ini adalah utilitas yang ditulis dalam Go yang akan memungkinkan kita untuk menjalankan node eter pada komputer lokal dan terhubung ke jaringan tes dan nyata.  Anda dapat menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melalui installer</a> , tetapi saya sangat menyarankan Anda segera mendapatkan di Terminal, seperti dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Anda dapat memeriksa apakah standar <code>geth</code> Anda <code>geth</code> menjalankan perintah di Terminal: <br><br><pre> <code class="bash hljs">geth version</code> </pre> <br>  Jika Anda memuntahkan versi geth - semuanya dalam kerawang, lanjutkan tutorialnya.  Jika tidak - buruk, benar;  tampaknya Anda harus bercinta dengan Terminal dan sistem operasi Anda - tetapi ini bukan pertama kalinya bagi Anda untuk mengetahuinya.  Cara menginstal geth, jalankan perintah di Terminal: <br><br><pre> <code class="bash hljs">geth --testnet console</code> </pre> <br>  Ini akan memulai proses sinkronisasi simpul Anda dengan server uji, yang blok-bloknya dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Anda dapat memeriksa apakah Anda menyinkronkan dengan jaringan di konsol <code>geth</code> dengan <code>geth</code> : <br><br><pre> <code class="bash hljs">eth.blockNumber <span class="hljs-comment"><span class="hljs-comment">#  0 ‚Äî     eth.syncing #     false,    </span></span></code> </pre> <br>  Proses sinkronisasi membawa saya dari 1 hingga 4 jam - saat bagaimana.  Selain itu, selain memblokir sinkronisasi, Anda juga harus menunggu sinkronisasi keadaan - seringkali lebih lama dari memblokir sinkronisasi.  Anda juga dapat menggunakan <code>geth</code> <code>--light</code> flag <code>--light</code> - lalu sinkronisasi berlangsung dari beberapa detik hingga satu menit dan Anda masih dapat menggunakan kontrak. <br><br>  Oke, kami menginstal utilitas pertama - menempatkan yang berikutnya.  Kita perlu meletakkan analog <code>geth</code> , hanya simulasi blockchain yang sangat lokal - <code>testrpc</code> .  Ya, kami memiliki <b>3 blokir</b> : <br><br><ul><li>  <code>testrpc</code> - simulasi blockchain lokal;  cepat, tetapi palsu dan hanya disimpan di mesin Anda </li><li>  <code>geth --testnet</code> sudah menjadi blockchain nyata, tetapi Anda tidak akan kehilangan uang di mana Anda bisa mendapatkan kefir dan menguji semua <code>geth --testnet</code> - <code>geth --testnet</code> secara gratis </li><li>  geth - mainnet, main, blockchain nyata, kefir nyata;  semua dengan cara dewasa, kesalahan di sini adalah kerugian kefir nyata </li></ul><br>  Dengan demikian, kita akan memulai kontrak pengujian dengan <code>testrpc</code> , kemudian menginstalnya di <code>geth --testnet</code> , dan kemudian mengunduhnya langsung di <code>geth</code> . <br><br>  Kami <code>testrpc</code> dengan menjalankan perintah berikut: <br><br><pre> <code class="bash hljs">npm install -g ethereumjs-testrpc</code> </pre> <br>  Ya, atau langsung naik dengan truffle, karena sekarang <code>testrpc</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawah sayap truffle</a> dan disebut <code>ganache-cli</code> .  Meskipun iblis tahu, semuanya bekerja dengan <code>testrpc</code> dengan vanilla <code>testrpc</code> .  Dan jika berhasil, jangan menyentuhnya, karena saya diajarkan di akademi intergalaksi.  Anda juga dapat menjalankannya untuk memverifikasi instalasi dengan mendaftarkan <code>truffle</code> di konsol, tetapi test blockchain sudah disinkronkan dengan kami - jangan ganggu. <br><br>  Nah, sudah menemukan blockchain?  Sekarang ada node dan tes bahkan disinkronkan?  Kami menempatkan utilitas yang nyaman untuk bekerja dengan kontrak pintar di kefir - <code>truffle</code> , dengan perintah berikut: <br><br><pre> <code class="bash hljs">npm install -g truffle truffle version <span class="hljs-comment"><span class="hljs-comment">#  ,  ,  </span></span></code> </pre> <br>  Truffle adalah alat yang memungkinkan Anda untuk menjaga kontrak pintar dalam file yang berbeda, mengimpor file lain, dan juga mengkompilasi kode kontrak pintar Anda menjadi satu bytecode besar (tidak dapat dibaca oleh seseorang), itu secara otomatis menemukan <code>geth</code> berjalan secara lokal (uji dan nyata ) atau <code>testrpc</code> , sebarkan kontrak pintar Anda ke jaringan ini.  Selain itu, periksa kode kontrak pintar Anda untuk kesalahan dan transaksi yang baru saja diselesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga membantu debug</a> .  Masthead, singkatnya. <br><br>  Pada tahap ini Anda harus menginstal: <code>testrpc</code> , <code>testrpc</code> , <code>truffle</code> - jika ada yang hilang atau versi tidak dimuntahkan ke konsol atas permintaan, maka perbaiki ini;  jika tidak, Anda tidak akan berhasil. <br><br><blockquote>  Juga, saya melemparkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip bash</a> sederhana yang akan menginstal semuanya untuk Anda.  Disebut seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(curl -s https://raw.githubusercontent.com/backmeupplz/eth-installer/master/install.sh)</code> </pre> <br>  - tapi saya belum pernah mengujinya, jadi saya tidak yakin dengan kinerjanya.  Namun, saya akan senang menarik permintaan. </blockquote><br><h2>  Kontrak Figash </h2><br>  Semuanya telah ditemukan dan ditulis untuk Anda - itu bagus.  Bunting kecil akan tetap sama - tetapi saya akan mencoba meminimalkannya untuk Anda.  Kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontrak ERC20 yang sudah jadi dari OpenZeppelin</a> - sekarang ini adalah standar industri, mereka telah lulus audit, dan memang mereka semua menggunakan kode mereka.  Terima kasih banyak atas kontribusi Anda pada open source. <br><br>  Buat <code>cd</code> ke folder aman dan kemudian tulis: <br><br><pre> <code class="bash hljs">mkdir contract &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> contract</code> </pre> <br>  Dalam folder ini kita akan bekerja.  Buat rintisan di sini untuk kontrak pintar kami: <br><br><pre> <code class="bash hljs">truffle init</code> </pre> <br>  Tersandung, jelas.  Kami sekarang memiliki dua folder yang sangat penting di mana kami akan naik: <code>contracts</code> dan <code>migrations</code> .  Yang pertama adalah kode untuk kontrak kami, yang kedua adalah kode untuk truffle untuk mengetahui apa yang harus dilakukan ketika menggunakan kontrak ke blockchain. <br><br>  Selanjutnya, kita perlu mengambil kode kontrak pintar saat ini dari npm dan, pada kenyataannya, memulai proyek itu sendiri: <br><br><pre> <code class="bash hljs">npm init -y <span class="hljs-comment"><span class="hljs-comment">#     ( -y) npm install -E openzeppelin-solidity #       ( -E)</span></span></code> </pre> <br>  Nah, kode kontrak pintar dari OpenZeppelin ada di saku kita di folder <code>node_modules/openzeppelin-solidity/contracts</code> .  Sekarang kita pergi ke folder <code>contracts</code> utama, hapus semua file di sana dan tambahkan file <code>MyToken.sol</code> dan <code>MyCrowdsale.sol</code> - tentu saja, Anda akan memberi nama kontrak Anda secara berbeda.  Yang pertama akan menjadi kontrak untuk Token ERC20 kami, dan yang kedua akan menjadi kontrak ICO kami, yang akan menerima kefir dan mendistribusikan <code>MyToken</code> orang <code>MyToken</code> orang.  Artikel ini mungkin sudah usang, tetapi Anda selalu dapat melihat bagaimana OpenZeppelin menyarankan Anda membuat kontrak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam repositori mereka</a> .  Beginilah tampilan <code>MyToken.sol</code> : <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; // Main token smart contract contract MyToken is MintableToken { string public constant name = "My Token"; string public constant symbol = "MTKN"; uint8 public constant decimals = 18; }</span></span></code> </pre> <br>  Bagus - Anda memiliki kontrak pintar token Anda sendiri (cukup ganti nama dalam konstanta)!  Anda dapat melihat <code>MintableToken</code> warisan apa dari <code>MintableToken</code> - tetapi semuanya sesederhana mungkin di sana.  Ini adalah token yang dapat dikeluarkan (dari bahasa Inggris "Mint" - untuk mint), dan hanya pemilik yang memiliki hak untuk menerbitkannya, karena <code>MintableToken</code> juga diwarisi dari <code>Ownable</code> .  Selain itu, <code>MintableToken</code> juga mewarisi dari kelas token ERC20 yang ditulis oleh OpenZeppelin, di mana antarmuka ERC20 diimplementasikan: <br><br><pre> <code class="javascript hljs">contract ERC20Basic { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">totalSupply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address to, uint256 value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bool</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address indexed from, address indexed to, uint256 value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  Ya, di sini Anda memiliki seluruh antarmuka ERC20.  Apakah ini sulit?  Saya kira tidak.  Ini memberi Anda kesempatan untuk melihat berapa banyak token yang dikeluarkan, memeriksa saldo alamat, dan mentransfer token ke alamat lain dengan memuntahkan acara transfer untuk pelanggan kefir ringan di jaringan.  Dan semua ini Anda dapatkan gratis di <code>MyToken.sol</code> berkat karya OpenZeppelin - semuanya hebat. <br><br>  Dan sekarang mari kita beralih ke bagian utama ICO kita - kita harus menerima kefir dan membagikan <code>MyToken</code> !  <code>MyCrowdsale.sol</code> tampilan <code>MyCrowdsale.sol</code> Anda: <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; contract MyCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale { constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _cap, MintableToken _token, uint256 _goal ) public Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) RefundableCrowdsale(_goal) { //   ,  ,    // ,     require(_goal &lt;= _cap); } }</span></span></code> </pre><br>  Begitu-begitu-begitu, ada apa dengan kita?  Apa, bocah, kontrak pintar?  Penjualan token kami secara umum mewarisi tiga properti paling populer: memiliki token, yang tidak dapat dikumpulkan lagi;  topi lunak, tidak mengumpulkan ester mana yang dikembalikan;  waktu awal dan akhir penjualan token.  Faktanya, apa lagi yang dibutuhkan untuk kebahagiaan? <br><br>  Programmer, perhatikan bagaimana konstruktor dari beberapa kelas pewarisan disusun secara berurutan dan mendapatkan argumen dari konstruktor utama <code>MyCrowdsale</code> .  Kami juga memeriksa bahwa hardkey lebih tinggi dari softkey - Ales Gut!  Juga, jangan <code>MyCrowdsale</code> parameter yang <code>MyCrowdsale</code> di konstruktor <code>MyCrowdsale</code> - kami akan meneruskannya pada tahap penyebaran kontrak di truffle. <br><br>  Itu saja - Anda memiliki kontrak siap pakai token ERC20 Anda sendiri dan bahkan kontrak pintar ICO, yang dikonfigurasi sesuai dengan keinginan Anda dan memberikan token Anda untuk kefir.  Juga, didukung oleh semua dompet ERC20 - sebuah kesalahan besar!  Mari beralih ke tes dan penerapan manual. <br><br><h2>  Migrasi </h2><br>  Seperti yang saya katakan sebelumnya, kami akan menguji secara berurutan pada tiga jaringan blockchain, tetapi proses pengujian dengan pena akan selalu sama.  Mari kita mulai dengan <code>testrpc</code> , kemudian beralih ke <code>geth --testnet</code> dan lanjutkan <code>geth</code> .  Lampu utama Sou, kami baru saja menulis kodenya, mari kita coba kompilasi.  Dalam folder proyek, tulis: <br><br><pre> <code class="bash hljs">truffle compile</code> </pre> <br>  Jika semuanya dikompilasi tanpa masalah, maka Anda akan melihat <code>build</code> , yang akan berisi krakozyab untuk truffle sehingga itu bisa menyematkan bytecode kontrak pintar Anda di blockchain.  Sebelum menerapkan kontrak pintar, kami perlu memberi tahu truffle apa yang harus dilakukan.  Penyebaran truffle dari kontrak pintar disebut migrasi - yah, mari kita berpegang pada terminologi ini.  Buka <code>migrations/1_initial_migration.js</code> dan ubah dengan cara berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyToken.sol"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crowdsale = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyCrowdsale.sol"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deployer, network, accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openingTime = <span class="hljs-number"><span class="hljs-number">1514764800</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 15  2018 const closingTime = 1561939200; // 1  2019 const rate = new web3.BigNumber(1); // 1   1  const wallet = '0x281055afc982d96fab65b3a49cac8b878184cb16'; // - const cap = 200 * 1000000; //  const goal = 100 * 1000000; //  return deployer .then(() =&gt; { return deployer.deploy(token); }) .then(() =&gt; { return deployer.deploy( crowdsale, openingTime, closingTime, rate, wallet, cap, token.address, goal ); }) .then(() =&gt; { // Crowdsale    var tokenContract = web3.eth.contract(token.abi).at(token.address); web3.eth.defaultAccount = web3.eth.accounts[0]; tokenContract.transferOwnership(crowdsale.address); }); };</span></span></code> </pre> <br>  Ini adalah file yang sama yang akan digunakan oleh truffle untuk menyebarkan kontrak.  Jadi apa yang kita lakukan di sini?  Pertama, kami meminta kompilasi <code>MyToken</code> dan <code>MyCrowdsale</code> .  Setelah itu, kami menetapkan konstanta dengan semua argumen ICO kami - mengatur waktu mulai dan berakhir;  berapa banyak token yang akan diterima orang untuk 1 ve kefir (0,000000000000000001 et = 1 wei; menetapkan <code>decimals</code> menunjukkan berapa banyak pesanan yang diperlukan untuk mendapatkan 1 token yang baru Anda buat);  dompet, tempat kefir yang diperoleh dari penjualan akan datang;  topi keras dan topi lunak.  Harap perhatikan bahwa <code>openingTime</code> harus selalu setelah waktu blok saat ini di blockchain - jika tidak, kontrak pintar Anda tidak akan diblokir karena memeriksa kondisi di <code>TimedCrowdsale</code> .  Saya menginjak rake ini, dan transaksi yang gagal tidak dapat didebet sama sekali.  Ubah konstanta ini sesuai keinginan. <br><br>  Langkah selanjutnya adalah penyebaran kontrak pintar.  Tidak ada yang menarik di sini: kami memiliki objek penggunaan yang menyebarkan artefak kontrak pintar dan memberikan argumen di sana.  Perhatikan bahwa MyToken <code>MyToken</code> terlebih dahulu, dan hanya kemudian <code>MyCrowdsale</code> - dan alamat yang pertama dilewatkan di yang kedua sebagai argumen. <br><br>  Kemudian hal yang paling menarik adalah apa yang tidak mereka tulis di dokumentasi atau di buku.  Saat Anda membuat <code>MyToken</code> dari dompet, dompet ini menjadi pemilik <code>MyToken</code> di superclass yang Dapat <code>Ownable</code> - hal yang sama terjadi dengan <code>MyCrowdsale</code> .  Jika Anda menggali lebih dalam ke dalam <code>MintableToken</code> , Anda dapat melihat bahwa hanya <code>Owner</code> dapat mencetak koin!  Dan siapa pemilik <code>MyToken</code> ?  Itu benar: alamat yang membuatnya kesal.  Dan siapa yang akan mengirim permintaan untuk mencetak koin?  Benar: <code>MyCrowdsale</code> pintar <code>MyCrowdsale</code> .  Biarkan saya mengingatkan Anda bahwa alamat yang membuat <code>MyToken</code> dan <code>MyCrowdsale</code> adalah dua alamat yang berbeda. <br><br>  Oleh karena itu, kami menambahkan langkah penyebaran ketiga non-Ortodoks, di mana alamat yang telah melanggar kontrak ( <code>web3.eth.accounts[0]</code> ) menyebut fungsi <code>transferOwnership</code> <code>MyToken</code> kontrak <code>MyToken</code> <code>MyCrowdsale</code> memiliki <code>MyToken</code> dan dapat mencetak koin.  Dan <code>MyCrowdsale</code> masih di bawah kepemilikan <code>web3.eth.accounts[0]</code> - jadi semuanya dibundel. <br><br><blockquote>  Catatan tentang <code>web3.eth.accounts[0]</code> : ketika menggunakan kontrak pintar, pastikan geth atau testrpc memiliki dompet yang benar di <code>web3.eth.accounts[0]</code> - jangan kehilangan kunci pribadi untuk itu, meskipun ini tidak membahayakan Anda, tetapi tiba-tiba pemilik perlu melakukan sesuatu nanti, tetapi kuncinya sudah tidak ada lagi? </blockquote><blockquote>  Di <code>testrpc</code> , sebagai aturan, akun dibuat segera saat startup dan mereka segera dibuka;  namun, pada tes dan blockchain udara nyata, ada baiknya membuat akun melalui <code>personal.newAccount()</code> - kemudian mengisi kembali alamat ini melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Faucet</a> pada rantai blockchain tes atau kefir nyata pada blockchain nyata.  Jangan kehilangan kata sandi dan kunci pribadi Anda. </blockquote><blockquote>  Anda juga dapat menambahkan dompet yang ada ke akun Anda dengan menelepon <code>web3.personal.importRawKey('pvt_key', 'password')</code> , tetapi untuk ini Anda perlu memanggil <code>geth</code> dengan parameter tambahan <code>--rpcapi="db,eth,net,web3,personal,web3"</code> .  Saya pikir Anda akan mengetahuinya. </blockquote><br><h2>  Pengujian dan Penempatan </h2><br>  Ya, kontraknya sudah siap, migrasi ditulis, tetap hanya untuk digunakan dan diperiksa.  Baik <code>geth</code> (test dan real) dan <code>testrpc</code> dikelola dengan cara yang sama melalui <code>truffle console</code> - jadi saya akan menjelaskan metode verifikasi untuk <code>testrpc</code> dan hanya memberi tahu Anda cara mengaktifkan <code>geth</code> setelahnya.  Jadi, kami meluncurkan blockchain kefir lokal uji: <br><br><pre> <code class="bash hljs">testrpc</code> </pre> <br>  Um ... itu saja.  Anda mensimulasikan blockchain kefir secara lokal. <br><br><blockquote>  Dan untuk menyebarkan ke blockchain tes ether, bukannya perintah ini, Anda akan mendapatkan <code>geth --testnet --rpc</code> .  Dan untuk menggunakan blockchain eter yang sebenarnya, Anda cukup <code>geth --rpc</code> .  Bendera <code>--rpc</code> diperlukan agar truffle dapat terhubung.  Langkah-langkah penyebaran dan pengujian berikut kurang lebih sama untuk ketiga jenis blockchain.  Satu-satunya hal adalah bahwa setelah Anda menjalankan tes atau blockchain nyata melalui <code>geth</code> , itu akan mulai menyinkronkan blok - dan ini bisa memakan waktu hingga 4-5 jam pada koneksi internet yang baik.  Sebuah komentar tentang ini adalah di bagian paling awal artikel.  Sebelum menggunakan kontrak pintar, saya sarankan menunggu sinkronisasi penuh.  Juga, blockchain berbobot di wilayah 60-100 gigabyte, jadi siapkan ruang disk untuk ini. </blockquote><blockquote>  Selain itu, pastikan <code>web3.eth.accounts[0]</code> dikunci.  Anda biasanya dapat mendaftarkan <code>testrpc</code> di konsol, yang segera terbuka, atau di jendela Terminal terpisah di konsol, yang terbuka melalui <code>geth console</code> : <code>eth.unlockAccount(eth.accounts[0], ",    ", 24*3600)</code> - ini akan membuka kunci akun Anda, yang akan membuat kontrak pintar </blockquote><br>  Sekarang buka jendela Terminal baru ( <code>testrpc</code> tidak menutup <code>testrpc</code> - seharusnya berfungsi) dan menuliskannya di folder proyek: <br><br><pre> <code class="bash hljs">truffle migrate --reset</code> </pre> <br>  Perintah ajaib ini akan mengkompilasi kontrak pintar (yaitu, Anda tidak perlu menulis <code>truffle compile</code> setiap kali) dan menyebarkannya ke server mikro blockchain yang ditemukan terbuka secara lokal.  Perlu dicatat bahwa jika <code>testrpc</code> melakukan ini secara instan, maka test dan blockchains nyata akan memasukkan transaksi dalam blok berikutnya lebih lama.  Setelah itu, Anda harus memuntahkan sesuatu seperti ini di konsol: <br><br><pre> <code class="bash hljs">Using network <span class="hljs-string"><span class="hljs-string">'development'</span></span>. Running migration: 1_initial_migration.js Running step... Replacing MyToken... ... 0x86a7090b0a279f8befc95b38fa8bee6918df30928dda0a3c48416454e2082b65 MyToken: 0x2dc35f255e56f06bd2935f5a49a0033548d85477 Replacing MyCrowdsale... ... 0xf0aab5d550f363478ac426dc2aff570302a576282c6c2c4e91205a7a3dea5d72 MyCrowdsale: 0xaac611907f12d5ebe89648d6459c1c81eca78151 ... 0x459303aa0b79be2dc2c8041dd48493f2d0e109fac19588f50c0ac664f34c7e30 Saving artifacts...</code> </pre> <br>  Saya pikir Anda sudah menyadari bahwa konsol memberi Anda alamat kontrak pintar <code>MyToken</code> dan <code>MyCrowdsale</code> .  Itu saja!  Kontrak pintar tertanam dalam blockchain yang server mikronya Anda buka.  Tetap hanya untuk memverifikasi bahwa token benar-benar didistribusikan kepada pengguna yang mengirim kefir ke kontrak pintar <code>MyCrowdsale</code> .  Kami menulis yang berikut ini di Terminal untuk memasuki konsol truffle: <br><br><pre> <code class="bash hljs">truffle console</code> </pre> <br>  Kami menulis yang berikut ini di truffle sekarang (tidak ada komentar saja): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - t="0x2dc35f255e56f06bd2935f5a49a0033548d85477" //     MyToken ="0xaac611907f12d5ebe89648d6459c1c81eca78151" //     MyCrowdsale //   - token=MyToken.at(t) crowdsale=MyCrowdsale.at(c) //       account=web3.eth.accounts[0] // ,      token.balanceOf(account) //   0 //    - web3.eth.sendTransaction({from: account, to:c, value: web3.toWei(0.1, 'ether'), gas: 900000})</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika demikian, </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat segera memeriksa saldo dompet kami lagi, tetapi dalam kasus pengujian dan blockchain nyata, Anda harus menunggu sampai transaksi kami termasuk dalam blokir - biasanya ketika ini terjadi, truffle memberi Anda nomor transaksi. Apakah kamu sudah menunggu? Periksa lagi saldo kami di </font></font><code>MyToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      token.balanceOf(account) //    </span></span></code> </pre> <br>  Itu saja!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, uji kontrak Anda pada </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kemudian pada </font></font><code>geth --testnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kemudian gunakan pada </font></font><code>geth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi, Anda meluncurkan ICO Anda sendiri! Dan Anda tidak perlu menghabiskan puluhan kilogram untuk audit dan peluncuran. Untuk mengacaukan apa yang diberikan orang-orang dari OpenZeppelin kepada kami sebenarnya sangat sulit. Dan ketika Anda menggunakannya </font></font><code>truffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- inilah bagaimana perkembangan solidaritas umumnya berubah menjadi dongeng. Nah, kecuali untuk kasus-kasus ketika transaksi dibalik selama eksekusi dengan kontrak pintar - debutkan neraka mereka. Tetapi debugging kontrak pintar benar-benar layak untuk artikel terpisah.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih banyak telah membaca hingga akhir artikel ini! Jika saya berhasil menghemat waktu atau uang Anda, atau jika Anda mempelajari sesuatu yang baru dari artikel ini, maka saya akan sangat senang karenanya. Saya juga akan sangat berterima kasih jika Anda berbagi artikel ini dengan teman atau kenalan yang ingin melakukan ICO - hemat $ 75.000 untuk para programmer yang menyedot uang dari pasar crypto seperti parasit, menyalin-menempelkan 25 baris kode yang sama . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semoga sukses dalam mengembangkan kontrak pintar! Masih ada pertanyaan? Saya meminta Anda dalam komentar - Saya akan dengan senang hati menjawab semuanya dan mencoba membantu dengan masalah.</font></font><br><br><h2>  Bonus </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagaimana jika Anda ingin mengubah logika dengan mana harga pembelian token dipertimbangkan? </font><font style="vertical-align: inherit;">Tentu saja, Anda dapat mengubahnya dengan benar </font></font><code>rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau menggunakan salah satu kelas kontrak dari OpenZeppelin, tetapi bagaimana jika Anda menginginkan sesuatu yang lebih mesum? </font><font style="vertical-align: inherit;">Dalam kontrak pintar, Anda dapat mengganti fungsi </font></font><code>getTokenAmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getTokenAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256 _weiAmount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.timestamp &lt; <span class="hljs-number"><span class="hljs-number">1533081600</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// August 1st, 2018 rate = rate * 4; } else if (block.timestamp &lt; 1546300800) { // January 1st, 2019 rate = rate * 2; } return _weiAmount.mul(rate); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, ini dapat membuat harga token bergantung pada waktu pembelian - semakin jauh ke dalam hutan, semakin mahal tokennya. </font><font style="vertical-align: inherit;">Jangan takut untuk bereksperimen dan menulis ulang beberapa fitur kontrak pintar - itu menyenangkan!</font></font><br><br><img src="https://habrastorage.org/webt/3a/mp/lk/3amplkx2fhpeplqauietmgshkc8.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414493/">https://habr.com/ru/post/id414493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414481/index.html">Kuis PHP Jumat: beberapa petualangan programmer Brad, satu urutan aneh dan hadiah</a></li>
<li><a href="../id414483/index.html">Ketik Safe SQL di Kotlin</a></li>
<li><a href="../id414485/index.html">GNMT, kegagalan epik atau seluk-beluk terjemahan mesin</a></li>
<li><a href="../id414487/index.html">Perwakilan tipe brute-force yang langka: sejarah satu serangan</a></li>
<li><a href="../id414489/index.html">AS berencana untuk secara serius mengatasi masalah puing-puing luar angkasa</a></li>
<li><a href="../id414495/index.html">toString: Hebat dan Mengerikan</a></li>
<li><a href="../id414497/index.html">API UI Consulo dari ide ke prototipe</a></li>
<li><a href="../id414499/index.html">Laporan Club of Rome 2018, Bab 1.1.3: ‚ÄúDunia yang Kosong versus Perdamaian Penuh‚Äù</a></li>
<li><a href="../id414501/index.html">Laporan Club of Rome 2018, Bab 3.11: ‚ÄúReformasi Sektor Keuangan‚Äù</a></li>
<li><a href="../id414503/index.html">Intel NUC Hades Canyon dengan AMD Vega Graphics - VR or Not VR?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>