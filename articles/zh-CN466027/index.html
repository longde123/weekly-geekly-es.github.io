<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏳️ 🐟 🕰️ 《 Python之路》一书。 开发，扩展，测试和部署的黑带” 🔦 🦆 ⬛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，habrozhiteli！ Python路径使您可以磨练专业技能并尽可能多地了解最流行的编程语言的功能。 您将学习如何编写有效的代码，在最短的时间内创建最佳的程序并避免常见的错误。 现在是时候了解多线程计算和备注，获取API和数据库设计领域的专家意见，以及深入了解Python来加深对语言的了解的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>《 Python之路》一书。 开发，扩展，测试和部署的黑带”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466027/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/kq/of/aw/kqofawsaidazmnefdopvktmtxei.jpeg" align="left" alt="图片"></a> 嗨，habrozhiteli！  Python路径使您可以磨练专业技能并尽可能多地了解最流行的编程语言的功能。 您将学习如何编写有效的代码，在最短的时间内创建最佳的程序并避免常见的错误。 现在是时候了解多线程计算和备注，获取API和数据库设计领域的专家意见，以及深入了解Python来加深对语言的了解的时候了。 您必须启动一个项目，使用版本，组织自动测试并为特定任务选择编程样式。 然后，您将继续研究有效的函数声明，选择合适的数据结构和库，创建无故障的程序，程序包并在字节码级别上优化程序。 <br><a name="habracut"></a><br><h3> 摘录。 并行运行测试 </h3><br> 运行测试套件可能很耗时。 当测试套件需要几分钟的时间才能完成时，这在大型项目中很常见。 默认情况下，pytest按特定顺序顺序运行测试。 <br><br> 由于大多数计算机都具有多核处理器，因此，如果您将测试分开以在多核上运行，则可以加快速度。 <br><br> 为此，pytest有一个pytest-xdist插件，可以使用pip进行安装。 该插件使用––numprocesses（缩写为–n）参数扩展了pytest命令行，该参数将用作参数的内核数。 启动pytest –n 4将在四个并行进程中运行测试套件，从而在可用内核负载之间保持平衡。 <br><br> 由于内核数量可能会有所不同，因此插件也接受auto关键字作为值。 在这种情况下，可用内核数将自动返回。 <br><br><h3> 使用夹具创建测试中使用的对象 </h3><br> 在单元测试中，通常需要在运行测试之前和之后执行一组标准操作，并且这些说明涉及某些组件。 例如，您可能需要一个对象来表达应用程序配置的状态，并且必须在每次测试之前将其初始化，然后在执行后将其重置为初始值。 同样，如果测试依赖于临时文件，则必须在测试之前创建此文件，然后在测试之后删除。 这些组件称为<i>固定装置</i> 。 它们在测试之前已安装，并在执行后消失。 <br><br> 在pytest中，fixture被声明为简单函数。 夹具函数必须返回所需的对象，以便在测试使用它的位置时可以使用该对象。 <br><br> 这是一个简单的夹具示例： <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;some database connection&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> <br> 列表中包含数据库参数的任何测试都会自动使用数据库固定装置。  test_insert（）函数将接收database（）函数的结果作为第一个参数，并将在认为合适时使用此结果。 通过使用固定装置，您无需重复多次数据库初始化代码。 <br><br> 代码测试的另一个共同特征是在夹具操作后能够去除多余的东西。 例如，关闭数据库连接。 将夹具实现为生成器将添加用于清理已验证对象的功能（清单6.5）。 <br><br><blockquote><h4> 清单6.5。 清除已验证的对象 </h4><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> db = &lt;some database connection&gt; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db db.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> </blockquote> 由于我们使用了yield关键字并从数据库中生成了一个生成器，所以yield语句之后的代码仅在测试结束时执行。 该代码将在测试结束时关闭数据库连接。 <br><br> 对于每个测试，关闭数据库连接可能会导致不合理的计算能力浪费，因为其他测试可能会使用已经打开的连接。 在这种情况下，您可以将scope参数传递给灯具装饰器，并指定其范围： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture(scope=<span class="hljs-string"><span class="hljs-string">"module"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> db = &lt;some database connection&gt; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db db.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre> <br> 通过指定scope =“ module”参数，您可以为整个模块初始化一次固定装置，现在所有请求它的测试功能都可以使用开放式数据库连接。 <br><br> 您可以在测试之前或之后运行一些常规代码，将固定装置定义为与autouse关键字一起自动使用，而不是将它们指定为每个测试功能的参数。 使用True参数（即autouse关键字）对pytest.fixture（）函数进行具体化，可确保每次在声明了模块或类的测试中运行测试之前都调用Fixture。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.fixture(autouse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change_user_env</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> curuser = os.environ.get(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) os.environ[<span class="hljs-string"><span class="hljs-string">"USER"</span></span>] = <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.environ[<span class="hljs-string"><span class="hljs-string">"USER"</span></span>] = curuser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_user</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> os.getenv(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) == <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>&lt;/source     .  ,    :     ,      ,       . &lt;h3&gt;  &lt;/h3&gt;           ,    ,   ,         .          Gnocchi,    . Gnocchi      &lt;i&gt;storage API&lt;/i&gt;.    Python          .       ,      API   .        ,      (    storage API),  ,       .   ,   &lt;i&gt; &lt;/i&gt;,     ,        .  <span class="hljs-number"><span class="hljs-number">6.6</span></span>          ,    :    mysql,   —  postgresql. &lt;blockquote&gt;&lt;h4&gt; <span class="hljs-number"><span class="hljs-number">6.6</span></span>.      &lt;/h4&gt; &lt;source lang=<span class="hljs-string"><span class="hljs-string">"python"</span></span>&gt;<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> myapp @pytest.fixture(params=[<span class="hljs-string"><span class="hljs-string">"mysql"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgresql"</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> d = myapp.driver(request.param) d.start() <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> d d.stop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(database)</span></span></span><span class="hljs-function">:</span></span> database.insert(<span class="hljs-string"><span class="hljs-string">"somedata"</span></span>)</code> </pre> 驱动程序固定装置接收两个不同的值作为参数-应用程序支持的数据库驱动程序的名称。  test_insert运行两次：一次用于MySQL数据库，第二次用于PostgreSQL数据库。 这使得在不添加新代码行的情况下，轻松进行相同的测试，但具有不同的场景。 <br><br><h3> 虚拟对象的托管测试 </h3><br> 虚拟对象（或存根，模拟对象）是模仿真实应用程序对象行为的对象，但处于特殊的受控状态。 它们在创建能够全面描述测试条件的环境中最有用。 您可以用虚拟对象替换除测试对象以外的所有对象，并隔离它们，并创建代码测试环境。 <br><br> 一种用例是创建一个HTTP客户端。 创建HTTP服务器几乎是不可能的（或者说是极其困难的），在该服务器上可以为每个可能的值运行所有情况和方案。  HTTP客户端特别难以测试错误情况。 <br><br> 标准库有一个模拟命令来创建虚拟对象。 从Python 3.3开始，mock已与unittest.mock库集成。 因此，您可以使用下面的代码段在Python 3.3和更早版本之间提供向后兼容性： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ImportError: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock</code> </pre> <br> 模拟库非常易于使用。 可用于嘲笑对象的任何属性都是在运行时动态创建的。 可以为任何属性分配任何值。 在清单6.7中，模拟用于为dummy属性创建一个哑对象。 <br><blockquote><h4> 清单6.7。 访问mock.Mock属性 </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; m.some_attribute = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt;&gt;&gt; m.some_attribute <span class="hljs-string"><span class="hljs-string">"hello world"</span></span></code> </pre> </blockquote> 您还可以为可变对象动态创建一个方法，如清单6.8所示，在该方法中，您将创建一个始终返回42并将所需的内容作为参数的虚拟方法。 <br><blockquote><h4> 清单6.8 为嘲笑模拟对象创建方法 </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; m.some_method.return_value = <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; m.some_method() <span class="hljs-number"><span class="hljs-number">42</span></span> &gt;&gt;&gt; m.some_method(<span class="hljs-string"><span class="hljs-string">"with"</span></span>, <span class="hljs-string"><span class="hljs-string">"arguments"</span></span>) <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> </blockquote> 现在只有两行，并且mock.Mock对象现在具有some_method（）方法，该方法返回42。它接受任何类型的参数，而没有验证该参数是什么。 <br><br> 动态生成的方法也可能具有（故意）副作用。 为了不仅仅是返回值的样板方法，可以将它们定义为执行有用的代码。 <br><br> 清单6.9创建了一个具有副作用的虚拟方法-它显示字符串“ hello world”。 <br><blockquote><h4> 清单6.9。 创建带有副作用的模拟对象的方法 </h4><br><pre> <code class="python hljs"> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... print(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span> ... ❶ &gt;&gt;&gt; m.some_method.side_effect = print_hello &gt;&gt;&gt; m.some_method() hello world! <span class="hljs-number"><span class="hljs-number">43</span></span> ❷ &gt;&gt;&gt; m.some_method.call_count <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote> 我们将整个函数分配给some_method❶属性。 从技术上讲，由于您可以在虚拟对象中包括测试所需的任何代码，因此，这允许您在测试中实现更复杂的方案。 接下来，您需要将此对象传递给期望它的函数。 <br><br>  ❷call_count属性是一种检查方法被调用次数的简便方法。 <br><br> 模拟库使用“动作检查”模式：这意味着在测试后，您需要确保正确执行了由假人替换的动作。 清单6.10将assert（）方法应用于虚拟对象以执行这些检查。 <br><blockquote><h4> 清单6.10 通话验证方式 </h4><br><pre> <code class="python hljs"> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; m = mock.Mock() ❶ &gt;&gt;&gt; m.some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &lt;Mock name=<span class="hljs-string"><span class="hljs-string">'mock.some_method()'</span></span> id=<span class="hljs-string"><span class="hljs-string">'26144272'</span></span>&gt; ❷ &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, ❸mock.ANY) &gt;&gt;&gt; m.some_method.assert_called_once_with(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"/usr/lib/python2.7/dist-packages/mock.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">846</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assert_cal led_once_with <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assert_called_with(*args, **kwargs) File <span class="hljs-string"><span class="hljs-string">"/usr/lib/python2.7/dist-packages/mock.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">835</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assert_cal led_with <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AssertionError(msg) AssertionError: Expected call: some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>) Actual call: some_method(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>)</code> </pre> </blockquote> 我们通过调用❶方法创建了带有foo和bar参数作为测试的方法。 测试对伪对象的调用的一种简单方法是使用assert_drawn（）方法，例如assert_drawn_once_with（）❷。 对于这些方法，您需要在调用虚拟方法时传递希望使用的值。 如果传递的值与使用的值不同，则模拟程序会引发AssertionError异常。 如果您不知道可以传递什么参数，请使用mock.ANY作为❸的值。 它将替换传递给dummy方法的所有参数。 <br><br> 模拟库还可以用于替换外部模块中的函数，方法或对象。 在清单6.11中，我们用自己的伪函数替换了os.unlink（）函数。 <br><blockquote><h4> 清单6.11 使用嘲笑 </h4><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_os_unlink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOError(<span class="hljs-string"><span class="hljs-string">"Testing!"</span></span>) ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> mock.patch(<span class="hljs-string"><span class="hljs-string">'os.unlink'</span></span>, fake_os_unlink): ... os.unlink(<span class="hljs-string"><span class="hljs-string">'foobar'</span></span>) ... Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fake_os_unlink IOError: Testing!</code> </pre> </blockquote> 当用作上下文管理器时，mock.patch（）将目标函数替换为我们选择的目标函数。 这是必需的，以便在上下文中执行的代码使用更正的方法。 使用嘲笑（。）方法，您可以修改外部代码的任何部分，以使其能够测试应用程序的所有条件的方式工作（清单6.12）。 <br><blockquote><h4> 清单6.12 使用mock.patch（）测试许多行为 </h4><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhereIsPythonError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ❶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_python_still_a_programming_language</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r = requests.get(<span class="hljs-string"><span class="hljs-string">"http://python.org"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IOError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.status_code == <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Python is a programming language'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r.content <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> WhereIsPythonError(<span class="hljs-string"><span class="hljs-string">"Something bad happened"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_fake_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status_code, content)</span></span></span><span class="hljs-function">:</span></span> m = mock.Mock() m.status_code = status_code m.content = content <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fake_get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOError(<span class="hljs-string"><span class="hljs-string">"Unable to fetch url %s"</span></span> % url) ❷ @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get( <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">'Python is a programming language for sure'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_python_is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> is_python_still_a_programming_language() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get( <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">'Python is no more a programming language'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_python_is_not</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> is_python_still_a_programming_language() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, get_fake_get(<span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_bad_status_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> pytest.raises(WhereIsPythonError): is_python_still_a_programming_language() @mock.patch(<span class="hljs-string"><span class="hljs-string">'requests.get'</span></span>, raise_get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_ioerror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> pytest.raises(WhereIsPythonError): is_python_still_a_programming_language()</code> </pre> </blockquote><br><br> 清单6.12实现了一个测试用例，该用例查找<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">python.org上</a> <i>的编程语言</i>字符串来查找<i>Python的</i>所有实例。 在测试中不会在所选网页上找不到任何给定的行的选项。 要获得否定的结果，您需要更改页面，但这不能完成。 但是，在模拟的帮助下，您可以使用技巧来更改请求的行为，以使其返回带有虚拟页面的虚拟响应，该页面不包含给定的字符串。 这将允许您测试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">python.org</a>不包含给定字符串的否定情况，并确保程序正确处理了这种情况。 <br><br> 本示例使用了mock.patch（）装饰器版本。 虚拟对象的行为不会改变，并且在测试功能的上下文中设置示例更加容易。 <br><br> 使用虚拟对象将帮助模拟任何问题：服务器返回404错误，I / O错误或网络延迟错误。 我们可以确保代码在每种情况下都返回正确的值或引发正确的异常，从而保证了代码的预期行为。 <br><br><h3> 确定涵盖范围的未经测试的代码 </h3><br> 覆盖率工具是对单元测试的一个重要补充[代码覆盖率是测试中使用的一种度量。 显示在测试过程中执行的程序源代码的百分比<i>。</i>  ]，查找未测试的代码段。 它使用代码分析和跟踪工具来识别已执行的行。 在单元测试中，它可以揭示代码的哪些部分被重用，哪些部分根本没有使用。 创建测试是必要的，并且能够找出您忘记用测试覆盖的代码的哪一部分，使此过程更加有趣。 <br><br> 通过pip安装coverage模块，以便可以在您的外壳中使用它。 <br><br><blockquote><h4> 注意 </h4><br> 如果通过操作系统的安装程序安装了该模块，则该命令也可以称为python-coverage。 例如Debian OS。 </blockquote><br><br> 离线使用覆盖非常简单。 它显示了程序中永远不会启动并变成“死重”的部分-这样的代码，您必须在不更改程序功能的情况下将其删除。 本章前面讨论的所有测试工具都与coverage集成在一起。 <br><br> 使用pytest时，请通过pip install pytest-pycov安装pytest-cov插件，并添加一些开关以生成未测试代码的详细输出（清单6.13）。 <br><blockquote><h4> 清单6.13 使用pytest和coverage </h4><br><pre> <code class="python hljs">$ pytest --cov=gnocchiclient gnocchiclient/tests/unit ---------- coverage: platform darwin, python <span class="hljs-number"><span class="hljs-number">3.6</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>-final<span class="hljs-number"><span class="hljs-number">-0</span></span> ----------- Name Stmts Miss Branch BrPart Cover --------------------------- gnocchiclient/__init__.py <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>% gnocchiclient/auth.py <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">49</span></span>% gnocchiclient/benchmark.py <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>% --snip-- --------------------------- TOTAL <span class="hljs-number"><span class="hljs-number">2040</span></span> <span class="hljs-number"><span class="hljs-number">1868</span></span> <span class="hljs-number"><span class="hljs-number">424</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>% === passed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">5.00</span></span> seconds ===</code> </pre> </blockquote>  --cov选项可在测试结束时启用覆盖率报告的输出。 您必须将软件包名称作为参数传递，以便插件正确过滤报告。 输出将包含尚未执行的代码行，这意味着它们尚未经过测试。 剩下的就是打开编辑器并为此代码编写测试。 <br><br>  Coverage模块甚至更好-它使您可以生成HTML格式的清晰报告。 只需添加-cov-report-html，HTML页面将出现在运行命令的<i>htmlcov</i>目录中。 每个页面将显示源代码的哪些部分正在运行或未运行。 <br><br> 如果您想走得更远，请使用–-cover-fail-under-COVER_MIN_PERCENTAGE，如果未覆盖最低百分比的代码，这将导致测试套件失败。 尽管覆盖率很大是一个不错的目标，并且测试工具可用于获取有关测试覆盖率状态的信息，但该百分比本身并不是很有用。 图6.1显示了覆盖率报告示例，其中显示了覆盖率百分比。 <br><br> 例如，用100％的测试覆盖代码是一个值得的目标，但这并不一定意味着代码已经过全面测试。 该值仅表示程序中所有代码行均已满足，但并不表示所有条件均已测试。 <br><br> 值得使用覆盖率信息来扩展测试套件并为未运行的代码创建它们。 这样可以简化项目支持并提高整体代码质量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d_/af/vl/d_afvlajlx_9ctds7yfu7ef_2ds.png" alt="图片"></div><br><br><h3> 关于作者 </h3><br>  <i>Julien Danju</i>入侵免费软件已有20年之久，并且已经开发Python程序已有近12年的时间。 他目前领导基于OpenStack的分布式云平台的设计团队，该平台拥有现有的最大的Python开源数据库，大约有两百五十万行代码。 在开发云服务之前，Julien创建了窗口管理器并为许多项目的开发做出了贡献，例如Debian和GNU Emacs。 <br><br><h3> 关于科学编辑 </h3><br>  <i>Mike Driscoll</i>从事Python编程已有十多年了。 很长一段时间，他在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">The Mouse vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python</a> 。 撰写多本Python书籍：Python 101，Python访谈和ReportLab：使用Python进行PDF处理。 您可以在Twitter和GitHub上找到Mike：@driscollis。 <br><br>  »这本书的更多信息可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在出版商的网站上找到</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘录</a> <br><br> 小贩优惠券25％优惠-Python <br><br> 支付纸质版本的书后，就会通过电子邮件发送电子书。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466027/">https://habr.com/ru/post/zh-CN466027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466001/index.html">“流动的”风水，否则我们会正确入睡（咖啡，蟑螂和哈布雷的不宽容）</a></li>
<li><a href="../zh-CN466015/index.html">有关计算中的三角学的更多信息</a></li>
<li><a href="../zh-CN466017/index.html">Livy-Hadoop Spark Air Airflow Python链中缺少的链接</a></li>
<li><a href="../zh-CN466019/index.html">ABBYY Mobile Web Capture：在智能手机的浏览器中直接显示高质量的文档照片</a></li>
<li><a href="../zh-CN466021/index.html">我是如何教Yandex.Alice谈论性玩具的</a></li>
<li><a href="../zh-CN466029/index.html">如何将量子计算机变成完美的随机数生成器</a></li>
<li><a href="../zh-CN466031/index.html">DeepMind的史诗任务，旨在解决最复杂的科学问题</a></li>
<li><a href="../zh-CN466033/index.html">如何让团队参与寻找创意并获得比创意更多的东西</a></li>
<li><a href="../zh-CN466039/index.html">用于电子商务的PHP库：与ATOL和Payture一起使用，解析GS1代码和其他任务</a></li>
<li><a href="../zh-CN466041/index.html">Facebook开发者圈的第一个离线活动：莫斯科社区-启动活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>