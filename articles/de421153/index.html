<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèø üêï üßôüèø 24-Kern-CPU, aber ich kann keine E-Mail eingeben (Teil 2) üñêüèª ü•Å ü§æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel habe ich versprochen, einige Details, die ich w√§hrend der Untersuchung ausgelassen habe, detaillierter zu enth√ºllen [Google ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>24-Kern-CPU, aber ich kann keine E-Mail eingeben (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421153/"> In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel habe</a> ich versprochen, einige Details, die ich w√§hrend der Untersuchung ausgelassen habe, detaillierter zu enth√ºllen [Google Mail h√§ngt in Chrome unter Windows - ca.  Per.], Einschlie√ülich Seitentabellen, Sperren, WMI und des vmmap-Fehlers.  Jetzt f√ºlle ich diese L√ºcken zusammen mit aktualisierten Codebeispielen aus.  Aber skizzieren Sie zun√§chst kurz die Essenz. <br><br>  Der Punkt war, dass ein Prozess, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Control Flow Guard</a> (CFG) unterst√ºtzt, ausf√ºhrbaren Speicher zuweist und gleichzeitig CFG-Speicher zuweist, den Windows niemals freigibt.  Wenn Sie weiterhin ausf√ºhrbaren Speicher <i>an verschiedenen Adressen</i> zuweisen und freigeben, sammelt der Prozess daher eine beliebige Menge an CFG-Speicher.  Der Chrome-Browser f√ºhrt dies aus, was zu einem nahezu unbegrenzten Speicherverlust f√ºhrt und auf einigen Computern einfriert. <br><br>  Es ist zu beachten, dass Einfrierungen schwer zu vermeiden sind, wenn VirtualAlloc mehr als eine Million Mal langsamer als gew√∂hnlich ausgef√ºhrt wird. <br><a name="habracut"></a><br>  Zus√§tzlich zu CFG gibt es einen weiteren verschwendeten Speicher, obwohl es nicht so viel ist, wie vmmap behauptet. <br><br><h1>  CFG und Seiten </h1><br>  Sowohl der Programmspeicher als auch der CFG-Speicher werden letztendlich mit 4-Kilobyte-Seiten belegt (dazu sp√§ter mehr).  Da 4 KB CFG-Speicher 256 KB Programmspeicher beschreiben k√∂nnen (dazu sp√§ter mehr), bedeutet dies, dass Sie eine 4 KB CFG-Seite erhalten, wenn Sie einen 256 KB gro√üen Speicherblock ausw√§hlen, der auf 256 KB ausgerichtet ist.  Wenn Sie einen ausf√ºhrbaren 4-KB-Block zuweisen, erhalten Sie weiterhin eine 4-KB-CFG-Seite, die jedoch gr√∂√ütenteils nicht verwendet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/0c2/e19/f100c2e19331ea5b1e313961be362c80.png" align="right">  Alles ist komplizierter, wenn der ausf√ºhrbare Speicher freigegeben wird.  Wenn Sie die VirtualFree-Funktion f√ºr einen Block ausf√ºhrbaren Speichers verwenden, der kein Vielfaches von 256 KB ist oder nicht auf 256 KB ausgerichtet ist, sollte das Betriebssystem eine Analyse durchf√ºhren und sicherstellen, dass ein anderer ausf√ºhrbarer Speicher keine CFG-Seite verwendet.  Die Autoren von CFG haben beschlossen, sich nicht darum zu k√ºmmern - und den zugewiesenen CFG-Speicher einfach f√ºr immer zu verlassen.  Es ist sehr ungl√ºcklich.  Dies bedeutet, dass wenn mein Testprogramm 1 Gigabyte ausgerichteten ausf√ºhrbaren Speicher zuweist und dann freigibt, 16 MB CFG-Speicher √ºbrig bleiben. <br><br>  In der Praxis stellt sich heraus, dass, wenn die Chrome JavaScript-Engine 128 MB ausgerichteten ausf√ºhrbaren Speicher zuweist und dann freigibt (nicht alles wurde verwendet, aber der gesamte Bereich zugewiesen und sofort freigegeben wurde), bis zu 2 MB CFG-Speicher zugewiesen bleiben, obwohl es trivial ist, ihn vollst√§ndig freizugeben .  Da Chrome wiederholt Speicher an zuf√§lligen Adressen zuweist und freigibt, f√ºhrt dies zu dem oben beschriebenen Problem. <br><br><h1>  Zus√§tzlicher Speicherverlust </h1><br>  In jedem modernen Betriebssystem erh√§lt jeder Prozess seinen eigenen Adressraum f√ºr den virtuellen Speicher, sodass das Betriebssystem Prozesse isoliert und den Speicher sch√ºtzt.  Dies erfolgt mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer Speicherverwaltungseinheit</a> (MMU) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seitentabellen</a> .  Der Speicher ist in 4 KB Seiten unterteilt.  Dies ist die Mindestmenge an Speicher, die Ihnen das Betriebssystem zur Verf√ºgung stellt.  Jede Seite wird durch einen 8-Byte-Datensatz in der Seitentabelle angezeigt, und die Datens√§tze selbst werden auf 4-KB-Seiten gespeichert.  Jede von ihnen verweist auf maximal 512 verschiedene Speicherseiten, daher ben√∂tigen wir eine Hierarchie von Seitentabellen.  F√ºr einen 48-Bit-Adressraum in einem 64-Bit-Betriebssystem lautet das System wie folgt: <br><br><ul><li>  Eine Level 1-Tabelle umfasst 256 TB (48 Bit) und zeigt auf 512 verschiedene Tabellen der Level 2-Seite </li><li>  Jede Tabelle der Ebene 2 umfasst 512 GB und verweist auf 512 Tabellen der Ebene 3 </li><li>  Jede Tabelle der Ebene 3 umfasst 1 GB und zeigt auf 512 Tabellen der Ebene 4 </li><li>  Jede Tabelle der Ebene 4 umfasst 2 MB und verweist auf 512 physische Seiten </li></ul><br>  Die MMU indiziert die Tabelle der 1. Ebene in den ersten 9 (von 48) Bits der Adresse, die Tabellen der 2. Ebene in den n√§chsten 9 Bits und die verbleibenden Ebenen erhalten 9 Bits, dh nur 36 Bits.  Die verbleibenden 12 Bits werden verwendet, um 4 Kilobyte-Seiten aus einer Tabelle der 4. Ebene zu indizieren.  Gut, gut. <br><br>  Wenn Sie sofort alle Ebenen der Tabellen ausf√ºllen, ben√∂tigen Sie mehr als 512 GB RAM, damit diese nach Bedarf ausgef√ºllt werden.  Dies bedeutet, dass das Betriebssystem beim Zuweisen einer Speicherseite einige Seitentabellen ausw√§hlt - von null bis drei, je nachdem, ob sich die zugewiesenen Adressen in einem zuvor nicht verwendeten Bereich von 2 MB, einem zuvor nicht verwendeten Bereich von 1 GB oder einem zuvor nicht verwendeten Bereich von 512 GB befinden (Tabelle mit Seiten der Ebene 1) f√§llt immer auf). <br><br>  Kurz gesagt, das Zuweisen zu zuf√§lligen Adressen ist viel teurer als das Zuweisen zu Adressen in der N√§he, da im ersten Fall Seitentabellen nicht gemeinsam genutzt werden k√∂nnen.  CFG-Lecks sind selten. Als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vmmap 412.480</a> KB verwendeter Seitentabellen in Chrome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigte</a> , ging ich davon aus, dass die Zahlen korrekt waren.  Hier ist ein Screenshot von vmmap mit dem Speicherlayout chrome.exe aus dem vorherigen Artikel, jedoch mit der Zeile Seitentabelle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08b/7b7/b4d/08b7b7b4dda4d0b54b3017b5eb80c7ab.png"><br><br>  Aber etwas schien nicht zu stimmen.  Ich habe beschlossen, meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VirtualScan-</a> Tool einen Seitentabellensimulator hinzuzuf√ºgen.  Es wird berechnet, wie viele Seiten mit Seitentabellen w√§hrend des Scanvorgangs f√ºr den gesamten zugewiesenen Speicher ben√∂tigt werden.  Sie m√ºssen nur den zugewiesenen Speicher scannen und dem Z√§hler jeweils ein Vielfaches von 2 MB, 1 GB oder 512 GB hinzuf√ºgen. <br><br>  Es wurde schnell festgestellt, dass die Simulatorergebnisse vmmap f√ºr normale Prozesse entsprechen, jedoch nicht f√ºr Prozesse mit einer gro√üen Menge an CFG-Speicher.  Die Differenz entspricht ungef√§hr dem zugewiesenen CFG-Speicher.  F√ºr den obigen Prozess, bei dem vmmap √ºber 402,8 MB (412.480 KB) Seitentabellen spricht, zeigt mein Tool 67,7 MB an. <br><br><pre>  Scan-Zeit, Festgeschrieben, Seitentabellen, Festgeschriebene Bl√∂cke
 Gesamt: 41,763 s, 1457,7 MiB, 67,7 MiB, 32112, 98 Codebl√∂cke
 CFG: 41,759 s, 353,3 MiB, 59,2 MiB, 24866 </pre><br><br>  Ich habe den vmmap-Fehler durch Ausf√ºhren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VAllocStress sichergestellt</a> , wodurch Windows in den Standardeinstellungen 2 Gigabyte CFG-Speicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuweist</a> .  vmmap gab an, 2 Gigabyte Seitentabellen zugewiesen zu haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/e6e/33f/89ce6e33f668a6de32abc6a0231bd3e1.png"><br><br>  Und als ich den Vorgang √ºber den Task-Manager abgeschlossen habe, hat vmmap gezeigt, dass die Menge des zugewiesenen Speichers nur um 2 Gigabyte abgenommen hat.  Vmmap ist also falsch, meine Berechnungen mit Seitentabellen sind korrekt, und nach einer fruchtbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion auf Twitter habe</a> ich einen Bericht √ºber den vmmap-Fehler gesendet, der behoben werden sollte.  Der CFG-Speicher belegt immer noch viele Seitentabelleneintr√§ge (59,2 MB im obigen Beispiel), aber nicht so viel, wie vmmap sagt, und nach dem Korrigieren wird √ºberhaupt nichts verbraucht. <br><br><h1>  Was ist CFG und CFG? </h1><br>  Ich m√∂chte ein wenig zur√ºcktreten und genauer erkl√§ren, was CFG ist. <br><br>  CFG steht f√ºr Control Flow Guard.  Dies ist eine Methode zum Schutz vor Exploits durch Umschreiben von Funktionszeigern.  Wenn CFG aktiviert ist, √ºberpr√ºfen der Compiler und das Betriebssystem gemeinsam die G√ºltigkeit des Verzweigungsziels.  Zun√§chst wird das entsprechende CFG-Steuerbyte aus dem f√ºr 2 TB reservierten CFG-Bereich geladen.  Der 64-Bit-Prozess in Windows verwaltet den 128-TB-Adressraum. Wenn Sie also die Adresse durch 64 teilen, k√∂nnen Sie das entsprechende CFG-Byte f√ºr dieses Objekt finden. <br><br> <code>uint8_t cfg_byte = cfg_base[size_t(target_addr) / 64];</code> <br> <br>  Wir haben jetzt ein Byte, das beschreiben soll, welche Adressen im 64-Byte-Bereich g√ºltige Verzweigungsziele sind.  Zu diesem Zweck behandelt das CFG das Byte als vier Zwei-Bit-Werte, von denen jeder einem 16-Byte-Bereich entspricht.  Diese Zwei-Bit-Zahl (deren Wert zwischen null und drei liegt) wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie folgt interpretiert</a> : <br><br><ul><li>  0 - Alle Ziele in diesem 16-Byte-Block sind ung√ºltige Ziele indirekter Zweige </li><li>  1 - Die Startadresse in diesem 16-Byte-Block ist das g√ºltige Ziel der indirekten Verzweigung </li><li>  2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbunden mit "unterdr√ºckten" CFG-Anrufen</a> ;  Adresse ist m√∂glicherweise ung√ºltig </li><li>  3 - Nicht ausgerichtete Adressen in diesem 16-Byte-Block sind g√ºltige Ziele einer indirekten Verzweigung, jedoch ist eine 16-Byte-ausgerichtete Adresse m√∂glicherweise ung√ºltig </li></ul><br>  Wenn das Ziel des indirekten Zweigs ung√ºltig ist, wird der Prozess beendet und der Exploit verhindert.  Hurra! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/1af/827/a081af827b3df7b40e8b8530b7cbd1a4.png"><br><br>  Daraus k√∂nnen wir schlie√üen, dass f√ºr maximale Sicherheit die indirekten Ziele der Verzweigung auf 16 Bytes ausgerichtet sein sollten, und wir k√∂nnen verstehen, warum der CFG-Speicher f√ºr den Prozess ungef√§hr 1/64 des Programmspeichers betr√§gt. <br><br><blockquote>  Tats√§chlich l√§dt CFG jeweils 32 Bit, dies sind jedoch Implementierungsdetails.  Viele Quellen beschreiben den CFG-Speicher als 8-Byte-Einzelbit und nicht als 16-Byte-Doppelbit.  Meine Erkl√§rung ist besser. </blockquote><br><h1>  Deshalb ist alles schlecht </h1><br>  Google Mail h√§ngt aus zwei Gr√ºnden.  Erstens ist das Scannen des CFG-Speichers unter Windows 10 16299 oder fr√ºher <i>schmerzhaft</i> langsam.  Ich habe gesehen, wie das Scannen des Adressraums eines Prozesses 40 Sekunden oder l√§nger dauert, und buchst√§blich 99,99% dieser Zeit wird der reservierte CFG-Speicher gescannt, obwohl er nur etwa 75% der festen Speicherbl√∂cke ausmacht.  Ich wei√ü nicht, warum das Scannen so langsam war, aber sie haben es in Windows 10 17134 behoben. Daher ist es nicht sinnvoll, das Problem genauer zu untersuchen. <br><br>  Langsames Scannen verursachte eine Verlangsamung, da Google Mail eine CFG-Redundanz w√ºnschte und WMI die Sperre f√ºr die Dauer des Scans hielt.  Die Speicherreservierungssperre wurde jedoch w√§hrend des gesamten Scans nicht gehalten.  In meinem Beispiel gibt es ungef√§hr 49.000 Bl√∂cke im CFG-Bereich, und die <i>NtQueryVirtualMemory-</i> Funktion, die die Sperre empf√§ngt und <i>aufhebt</i> , wurde f√ºr jeden von ihnen einmal aufgerufen.  Daher wurde die Sperre ~ 49.000 Mal erhalten und freigegeben und jedes Mal f√ºr weniger als 1 Millisekunde gehalten. <br><br>  Obwohl die Sperre 49.000 Mal freigegeben wurde, konnte der Chrome-Prozess sie aus irgendeinem Grund nicht erhalten.  Das ist nicht fair! <br><br>  Das ist die Essenz des Problems.  Wie ich letztes Mal schrieb: <br><br><blockquote>  Dies liegt daran, dass Windows-Sperren von Natur aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unfair sind.</a> Wenn der Thread die Sperre aufhebt und sie dann sofort erneut anfordert, kann er sie f√ºr immer erhalten. </blockquote><br>  Faires Sperren bedeutet, dass zwei konkurrierende Threads es nacheinander erhalten.  Dies bedeutet jedoch viele teure Kontextwechsel, sodass das Schloss lange Zeit nicht verwendet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/713/348/9de/7133489de2c1eca7dc2b2c91b08e1871.png"><br><br>  Unfaire Schl√∂sser sind billiger und lassen Threads nicht in der Schlange stehen.  Sie erfassen nur das Schloss, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joe Duffys Artikel erw√§hnt</a> .  Er schreibt auch: <br><br><blockquote>  Die Einf√ºhrung unfairer Schl√∂sser kann zweifellos zu Hunger f√ºhren.  Statistisch gesehen ist die Zeit in parallelen Systemen jedoch tendenziell so variabel, dass jeder Thread aus probabilistischer Sicht letztendlich eine Umdrehung zur Ausf√ºhrung erh√§lt. </blockquote><br>  Wie kann ich die Aussage von Joe aus dem Jahr 2006 √ºber die Seltenheit des Hungers mit meiner Erfahrung zu einem 100% wiederholbaren und lang anhaltenden Problem in Beziehung setzen?  Ich denke, der Hauptgrund ist das, was 2006 passiert ist.  Intel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat Core Duo ver√∂ffentlicht</a> , und Multi-Core-Computer sind allgegenw√§rtig. <br><br>  Immerhin stellt sich heraus, dass dieses Hungerproblem nur bei einem Multi-Core-System auftritt!  In einem solchen System hebt der WMI-Thread die Sperre auf, signalisiert dem Chrome-Thread, dass er aufwacht, und f√§hrt fort.  Da der WMI-Stream bereits ausgef√ºhrt wird, hat er ein "Handicap" vor dem Chrome-Stream, sodass er <i>NtQueryVirtualMemory</i> problemlos erneut aufrufen und die Sperre erneut erhalten kann, bevor Chrome die M√∂glichkeit dazu hat. <br><br>  In einem Single-Core-System kann nat√ºrlich immer nur ein Thread gleichzeitig arbeiten.  In der Regel erh√∂ht Windows die Priorit√§t eines neuen Threads. Wenn Sie die Priorit√§t erh√∂hen, ist der neue Chrome-Thread bereit, wenn die Sperre aufgehoben wird, und wird <i>dem</i> WMI-Thread sofort <i>voraus</i> .  Dies gibt dem Chrome-Thread viel Zeit, um aufzuwachen und eine Sperre zu erhalten, und es kommt nie zu Hunger. <br><br>  Verstehst du  In einem Multi-Core-System wirkt sich eine Priorit√§tserh√∂hung in den meisten F√§llen nicht auf den WMI-Stream aus, da er auf einem anderen Kernel ausgef√ºhrt wird! <br><br>  Dies bedeutet, dass ein System mit zus√§tzlichen Kernen <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">langsamer reagieren</a></i> kann als ein System mit derselben Arbeitslast und weniger Kernen.  Eine andere Schlussfolgerung ist merkw√ºrdig: Wenn mein Computer stark ausgelastet w√§re - Threads mit der entsprechenden Priorit√§t, die auf allen Prozessorkernen arbeiten -, k√∂nnten H√§nge vermieden werden (versuchen Sie nicht, dies zu Hause zu wiederholen). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ungerechte Schl√∂sser</a> erh√∂hen somit die Produktivit√§t, k√∂nnen jedoch zu Hunger f√ºhren.  Ich vermute, dass die L√∂sung das sein kann, was ich "manchmal faire" Schl√∂sser nenne.  Sagen wir, 99% der Zeit werden sie unfair sein, aber in 1% geben Sie die Sperre f√ºr einen anderen Prozess.  Dies wird die Vorteile der Produktivit√§t mit mehr bewahren und das Problem des Hungers vermeiden.  Bisher waren Sperren in Windows fair verteilt, und Sie k√∂nnen wahrscheinlich teilweise darauf zur√ºckkommen, um das perfekte Gleichgewicht zu finden.  Haftungsausschluss: Ich bin kein Experte f√ºr Sperren oder ein OS-Ingenieur, aber ich bin daran interessiert, Gedanken dar√ºber zu h√∂ren, und zumindest bin ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht der erste, der so etwas anbietet</a> . <br><br>  Linus Torvalds hat k√ºrzlich die Bedeutung fairer Schl√∂sser erkannt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Vielleicht ist es auch Zeit f√ºr eine √Ñnderung unter Windows. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassend</a> : Das Sperren f√ºr einige Sekunden ist nicht gut, es begrenzt die Parallelit√§t.  Auf Multi-Core-Systemen mit unfairen Sperren verh√§lt sich das Entfernen und sofortige erneute Empfangen der Sperre <i>genau so</i> - andere Threads k√∂nnen nicht funktionieren. <br><br><h1>  Fast ein Misserfolg mit ETW </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/a68/740/d69a68740eb8df0f6962d53db91190b7.png" align="right">  Bei all diesen Nachforschungen habe ich mich auf die ETW-Ablaufverfolgung verlassen, daher hatte ich ein wenig Angst, als sich zu Beginn der Untersuchung herausstellte, dass Windows Performance Analyzer (WPA) keine Chrome-Zeichen laden konnte.  Ich bin mir sicher, dass letzte Woche buchst√§blich alles funktioniert hat.  Was ist passiert ... <br><br>  Es kam vor, dass Chrome M68 herauskam und mit lld-link anstelle des VC ++ - Linkers verkn√ºpft wurde.  Wenn Sie <i>dumpbin ausf√ºhren</i> und die Debugging-Informationen <i>anzeigen</i> , sehen Sie: <br><br> <code>C:\b\c\b\win64_clang\src\out\Release_x64\./initialexe/chrome.exe.pdb</code> <br> <br>  Nun, wahrscheinlich mag WPA diese Schr√§gstriche nicht.  Aber es macht immer noch keinen Sinn, weil ich den Linker in lld-link ge√§ndert habe und ich erinnere mich, dass ich WPA zuvor getestet habe, also was ist passiert ... <br><br>  Es stellte sich heraus, dass der Grund in der neuen WPA-Version 17134 lag. Ich habe das lld-Link-Layout getestet - und es hat in WPA 16229 gut funktioniert. Was f√ºr ein Zufall!  Der neue Linker und der neue WPA waren nicht kompatibel. <br><br>  Ich habe die alte Version von WPA installiert, um die Untersuchung fortzusetzen (xcopy von einem Computer mit der alten Version) und einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lld-link-Fehler</a> gemeldet, den die Entwickler schnell behoben haben.  Jetzt k√∂nnen Sie zu WPA 17134 zur√ºckkehren, wenn der M69 mit einem festen Linker zusammengebaut ist. <br><br><h1>  Wmi </h1><br>  Der WMI-Freeze-Trigger ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Management Instrumentation-Snap-In</a> , und ich bin nicht gut darin.  Ich habe festgestellt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2014 oder fr√ºher</a> jemand auf das Problem einer signifikanten CPU-Auslastung in <i>WmiPrvSE.exe</i> in <i>perfproc! GetProcessVaData gesto√üen ist</i> , aber er hat nicht gen√ºgend Informationen <i>bereitgestellt</i> , um die Ursachen des Fehlers zu verstehen.  Irgendwann habe ich einen Fehler gemacht und versucht herauszufinden, welche verr√ºckte WMI-Anfrage Google Mail f√ºr ein paar Sekunden h√§ngen lassen k√∂nnte.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Experten</a> mit der Untersuchung verbunden und viel Zeit damit verbracht, diese magische Abfrage zu finden.  Ich habe <i>Microsoft-Windows-WMI-</i> Aktivit√§tsaktivit√§ten in ETW-Traces aufgezeichnet, mit PowerShell experimentiert, um alle Win32_Perf-Abfragen zu finden, und mich auf ein paar weitere Umwege verlaufen, die zu langweilig sind, um sie zu diskutieren.  Am Ende stellte ich fest, dass ein Google Mail-Hang diesen Z√§hler <i>Win32_PerfRawData_PerfProc_ProcessAddressSpace_Costly verursachte</i> , der durch eine einzeilige PowerShell ausgel√∂st wurde: <br><br><pre> <code class="hljs pgsql">measure-command {<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-WmiObject -Query ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Win32_PerfFormattedData_PerfProc_ProcessAddressSpace_Costly‚Äù}</code> </pre> <br>  Ich wurde dann <i>noch</i> verwirrter wegen des Namens des Z√§hlers ("Liebes"? Wirklich?) Und weil dieser Z√§hler aufgrund von Faktoren erscheint und verschwindet, die ich nicht verstehe. <br><br>  Aber die Details von WMI spielen keine Rolle.  WMI hat nichts falsch gemacht - nicht wirklich - es hat nur den Speicher gescannt.  Das Schreiben eines eigenen Scan-Codes erwies sich als viel n√ºtzlicher bei der Untersuchung des Problems. <br><br><h1>  √Ñrger f√ºr Microsoft </h1><br>  Chrome hat einen Patch ver√∂ffentlicht, der Rest ist f√ºr Microsoft. <br><br><ol><li>  <s>Beschleunigen</s> Sie das <s>Scannen von CFG-Regionen</s> - OK, fertig </li><li>  Geben Sie CFG-Speicher frei, wenn ausf√ºhrbarer Speicher freigegeben wird - zumindest bei einer Ausrichtung von 256 KB ist dies <i>einfach</i> </li><li>  Stellen Sie sich ein Flag vor, mit dem ausf√ºhrbarer Speicher ohne CFG-Speicher zugewiesen werden kann, oder verwenden Sie zu diesem Zweck PAGE_TARGETS_INVALID.  Beachten Sie, dass im Handbuch <i>Windows Internals Part 1 7th Edition angegeben ist</i> , dass Sie [CFG] -Seiten mit mindestens einem gesetzten Bit {1, X} ausw√§hlen sollten. Wenn Windows 10 dies implementiert, wird das Flag PAGE_TARGETS_INVALID (das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">derzeit von der Engine verwendet wird) verwendet v8</a> ) vermeidet die Speicherzuweisung </li><li>  Korrektur der Berechnung von Seitentabellen in vmmap f√ºr Prozesse mit einer gro√üen Anzahl von CFG-Zuordnungen </li></ol><br><h1>  Code-Updates </h1><br>  Ich habe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codebeispiele</a> aktualisiert, insbesondere VAllocStress.  Es sind 20 Zeilen enthalten, um zu demonstrieren, wie eine CFG-Reservierung f√ºr einen Prozess gefunden wird.  Ich habe auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Testcode</i></a> hinzugef√ºgt, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>SetProcessValidCallTargets verwendet</i></a> , um den Wert der CFG-Bits zu √ºberpr√ºfen und die Tricks zu demonstrieren, die zum erfolgreichen Aufrufen erforderlich sind (Hinweis: Das Aufrufen √ºber GetProcAddress verst√∂√üt wahrscheinlich gegen CFG!) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421153/">https://habr.com/ru/post/de421153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421139/index.html">Frontend Conf - k√ºmmert sich um den Benutzer</a></li>
<li><a href="../de421141/index.html">Mutationsanalyse oder wie man Tests testet</a></li>
<li><a href="../de421143/index.html">Aurora Labs S-Titanium Pro Mini-Metall-3D-Drucker</a></li>
<li><a href="../de421147/index.html">Monster nach den Ferien: AMD Threadripper 2990WX 32-Core und 2950X 16-Core</a></li>
<li><a href="../de421149/index.html">Ein paar Worte zu Farbverl√§ufen</a></li>
<li><a href="../de421155/index.html">3D-Druck im Jahr 2018: das Interessanteste in der Branche</a></li>
<li><a href="../de421157/index.html">Facebook wird MRT mit KI erforschen</a></li>
<li><a href="../de421159/index.html">Wie finde ich einen Business Mentor / Mentor?</a></li>
<li><a href="../de421161/index.html">Informationssicherheit bei bargeldlosen Bankzahlungen. Teil 7 - Grundlegendes Bedrohungsmodell</a></li>
<li><a href="../de421163/index.html">Gibt es eine Excel-Alternative zu Budgetierung und Business Intelligence?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>