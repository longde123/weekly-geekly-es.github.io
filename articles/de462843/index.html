<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛢️ 🙎🏾 👰🏿 Einschränkungen von 8-Bit-Spielen und deren genaue Wiederherstellung in Unity 🤳🏿 ✡️ ✂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retro-Spiele mit einfacher Mechanik und Pixelgrafiken können bei erfahrenen Spielern warme Erinnerungen hervorrufen und sind gleichzeitig für ein jüng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einschränkungen von 8-Bit-Spielen und deren genaue Wiederherstellung in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462843/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/d1d/acb/2a7d1dacbe9050c41e0fe50ca79e789e.png" alt="Bild"></div><br>  Retro-Spiele mit einfacher Mechanik und Pixelgrafiken können bei erfahrenen Spielern warme Erinnerungen hervorrufen und sind gleichzeitig für ein jüngeres Publikum gut zugänglich.  Heutzutage werden viele Spiele als Retro bezeichnet, aber Aufwand und Planung sind erforderlich, um einen nostalgischen Stil zu kreieren.  Deshalb haben wir die Jungs von Mega Cat Studios eingeladen, uns bei der Diskussion dieses Themas zu helfen.  In diesem Beitrag behandeln wir alles, was Sie zum Erstellen authentischer Grafiken im NES-Spielstil benötigen, einschließlich wichtiger Unity-Optionen, Grafikstrukturen und Farbpaletten. <br><br><h2>  Erstellen Sie authentische Kunst im NES-Stil </h2><br>  Zunächst werden die Grundlagen zum Erstellen von Grafiken für Spiele behandelt, die den Einschränkungen des klassischen Nintendo Entertainment Systems entsprechen.  Diese Konsolengeneration unterwirft Künstlern, die ihre authentischen Grafiken reproduzieren möchten, ernsthafte Einschränkungen.  Dies sind Einschränkungen hinsichtlich der verwendeten Paletten sowie der Größe und Anzahl der Objekte auf dem Bildschirm.  Darüber hinaus ist zu beachten, dass die Auflösung dieser Konsole 256 × 240 Pixel beträgt. <br><br><h3>  Paletten </h3><br>  Bei der Erstellung von NES-kompatiblen Grafiken muss der Künstler viele Einschränkungen berücksichtigen.  Erstens ist die wichtigste dieser Einschränkungen die Verwendung von Farbpaletten im Bild.  NES ist insofern einzigartig, als alle möglichen Farben der Palette mit der Konsole „verbunden“ sind.  NES wählt aus, welche Farben im Bild verwendet werden sollen, indem Wertesätze an die NES-GPU gesendet werden. Danach gibt die GPU die Farben zurück, die diesen Werten entsprechen.  Das Folgende ist ein Bild der NES-Farbpalette: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/4f9/0fd/10e4f90fdf5bb0ac7832dd5f4ab7d4a9.png"></div><br>  Diese Farben können nicht geändert werden, da sie Teil der Konsole selbst sind.  Alle NES-Spiele verwenden Kombinationen dieser Farben, aus denen die Bilder bestehen. <br><a name="habracut"></a><br><h3>  Unterpaletten </h3><br>  Um in Spielen verwendete Kombinationen zu erstellen, werden Unterpaletten erstellt, die an Sprites oder Hintergrundbilder im Spiel angehängt werden.  NES teilt die Palette in Unterpaletten auf, die Sprites und Hintergründen zugewiesen werden können.  Jede Unterpalette enthält eine gemeinsame Farbe, die in allen Unterpaletten verwendet wird, und drei eindeutige Farben.  Es können vier Unterpaletten für Hintergründe und vier Unterpaletten für Sprites geladen werden.  Bei Sprites wird die Gesamtfarbe am Anfang jeder Unterpalette als transparent betrachtet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/59a/330/33759a330bb3449bdf5a33c8ad1f671f.png"></div><br>  Hier ist ein Beispiel für eine Reihe von Unterpaletten, die im Spiel verwendet werden.  Der obere Teil zeigt die Hintergrund-Unterpaletten, der untere Teil zeigt die Sprite-Unterpaletten.  In diesem Beispiel ist Schwarz die in allen Unterpaletten verwendete gemeinsame Farbe.  Da die Gesamtfarbe in Sprites als transparent betrachtet wird, wird in den Unterpaletten für Sprites eine zweite schwarze Farbe benötigt, die als sichtbare Farbe verwendet wird. <br><br><h3>  Unterpaletten zuweisen </h3><br>  Die Einschränkungen für die Verwendung von Paletten werden noch strenger, wenn der Künstler fortfährt, wie die Paletten im Spiel verwendet werden.  Um dies zu erklären, müssen Sie mehr darüber sprechen, wie Retro-Konsolen Grafiken speichern und anzeigen.  Die Grafiken einer Retro-Konsole werden im Spiel als 8 × 8-Pixel-Kacheln gespeichert.  Dank dessen können Künstler Platz sparen, indem sie Kacheln für verschiedene Objekte wiederverwenden.  (Zum Beispiel können Teile der Straße wiederverwendet werden, indem eine Klippe oder ein Gebäude daraus erstellt wird.)  Es ist auch wichtig, dass die Farbinformationen nicht in den Grafiken gespeichert werden.  Alle Kacheln werden in einer monochromen Palette gespeichert.  Dank dessen können Sie, wenn eine Kachel im Spiel angezeigt wird, ihr eine Unterpalette zuweisen und sie gleichzeitig mit verschiedenen Unterpaletten auf dem Bildschirm anzeigen.  Dies ist wichtig, wenn Sie Retro-Konsolengrafiken auf modernen Plattformen neu erstellen, da dies die Zuordnung von Paletten zu Grafiken beeinflusst. <br><br>  NES weist Sprites und Hintergründen unterschiedliche Paletten zu.  Sie weist Sprit-Paletten taylovo zu.  Dies bedeutet, dass jeder 8 × 8-Kachel im Sprite eine von vier Sprite-Unterpaletten zugeordnet werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/e7a/d58/d0ae7ad5802681f0f3fd700f52307279.png" width="1200" height="600"></div><br>  Dieser Ninja-Charakter verwendet zwei Unterpaletten, um die Farbtiefe zu erhöhen.  Rechts sehen Sie, dass es in separate 8 × 8-Kacheln unterteilt ist.  In solch einer geteilten Form fällt auf, dass das helle Türkis und das dunkle Rot, die in Schwert und Stirnband verwendet werden, für diese Fliesen einzigartig sind und die dunkelvioletten und schwarzen Konturen in den verbleibenden drei Fliesen verwendet werden. <br><br>  Hintergründe unterliegen viel strengeren Einschränkungen.  Hintergrundpaletten sind 16 × 16 Fragmenten zugeordnet.  Die Hintergrundunterpalettenbindungen des gesamten Bildschirms werden als Attributtabellen (Attributtabellen) bezeichnet.  Gerade aufgrund dieser Tabellen verwenden die meisten Retro-Bilder aktiv sich wiederholende Kachelsegmente.  Solche Segmente bestehen normalerweise aus 16 × 16 Kacheln, weshalb sie in Attributtabellen platziert werden.  Trotz der Tatsache, dass dies durch Hardwareeinschränkungen verursacht wurde, wurden solche 16 × 16-Hintergrundkacheln zum bestimmenden Merkmal von Retro-Grafiken und sind jetzt für ihre Rekonstruktion in modernen Spielen absolut notwendig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/fb6/dfb/f7dfb6dfb062288789f2d76c2055758f.png" width="1200" height="600"></div><br>  <i>Hier ist ein Beispiel für den Hintergrund einer schönen Stadt im Stil eines Rollenspiels, das unter Berücksichtigung dieser Einschränkungen erstellt wurde.</i>  <i>Das Bild rechts zeigt, dass es gut in Blöcke von 16 × 16 Pixel unterteilt ist und für jeden Block Paletten festgelegt sind.</i>  <i>Um Platz zu sparen, bestehen Elemente wie Dachziegel, Gras und Ziegel auf der Brücke aus sich wiederholenden Segmenten dieser Blöcke.</i>  <i>Die Dachziegel kleiner Gebäude verwenden dieselben Ziegel, ihnen werden jedoch unterschiedliche Unterpaletten zugewiesen, wodurch sie ein einzigartiges Erscheinungsbild erhalten.</i> <br><br><h2>  Sprite-Overlay </h2><br>  Obwohl Künstler für jede 8 × 8-Sprite-Kachel unterschiedliche Unterpaletten verwenden können, kann es vorkommen, dass dem Sprite eine größere Farbtiefe verliehen werden muss.  In diesem Fall können Sie Sprite-Overlay verwenden.  Das Überlagern von Sprites ist die Aufteilung eines Sprites in zwei separate Sprites und das Übereinanderlegen.  Auf diese Weise können Künstler die Bedingung umgehen, eine Unterpalette pro 8 × 8-Kachel zu verwenden.  Dank dessen können Künstler tatsächlich die Anzahl der Farben verdoppeln, die in einem 8 × 8-Bereich verwendet werden können.  Der einzige schwerwiegende Nachteil dieses Ansatzes sind die Einschränkungen beim Sprite-Rendering.  NES kann jeweils nur 64 8 × 8-Sprite-Kacheln und nur acht Sprite-Kacheln in einer horizontalen Linie anzeigen.  Wenn diese Grenze erreicht ist, werden nicht alle anderen Kacheln auf dem Bildschirm gerendert.  Deshalb beginnen sie in vielen Spielen für NES mit einer großen Anzahl von Sprites auf dem Bildschirm zu flackern.  In diesem Fall können Sie alle Sprites nur in abwechselnden Frames anzeigen.  Solche Einschränkungen müssen bei der Überlagerung von Sprite-Ebenen berücksichtigt werden, da dies nicht nur die Anzahl der Farben, sondern auch die Anzahl der Sprite-Kacheln in einer horizontalen Linie verdoppelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/5be/239/3865be2393a5aabf1aa3fa534ee3f7d4.png" width="1600" height="503"></div><br>  <i>Hier ist ein Beispiel für Sprite Layering in Aktion.</i>  <i>Die ursprüngliche dreifarbige Version des Geisterpiraten-Sprites ist links abgebildet.</i>  <i>Der Künstler teilte es in zwei Teile - Körper / Hut und Gesicht / Hände - und ordnete ihnen dann verschiedene Paletten zu.</i>  <i>Rechts ist das Ergebnis der Überlagerung zweier Elemente.</i> <br><br>  Um die Einschränkungen der Attributtabelle zu umgehen, können Sie Sprite-Layer mithilfe des Hintergrunds implementieren.  Dieser Trick wird normalerweise für statische Bilder wie Plotbildschirme und Charakterporträts verwendet, wodurch sie eine viel größere Farbtiefe erhalten.  Um dies zu realisieren, muss der Künstler einen Teil des Bildes als Hintergrund zeichnen und dann Sprites darauf auftragen, um die verbleibenden Teile auszufüllen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/d4f/9aa/eddd4f9aadcc18eb50358c94dea42022.png" width="1407" height="600"></div><br>  <i>Im Porträt eines Geisterpiraten werden auch Schichten von Sprites verwendet, um ihm eine größere Tiefe zu verleihen.</i>  <i>Sein grüner Schädel wird als Sprite auf dem Bildschirm dargestellt, und sein Kragen und sein Hut sind Teil des Hintergrunds.</i>  <i>Dadurch kann der Künstler mehr Farben im 16 × 16-Segment verwenden, um die Einschränkungen der Attributtabelle vollständig zu umgehen.</i> <br><br><h2>  Grafikbanken </h2><br>  Um eine weitere wichtige Einschränkung von NES zu erklären, müssen wir zunächst darauf zurückkommen, dass Grafiken in Kacheln gespeichert sind.  Grafikkacheln werden auf Seiten mit 256 Kacheln gespeichert, und Kacheln von diesen Seiten können nicht an verschiedenen Stellen in VRAM geladen werden, sodass es im laufenden Betrieb schwierig wird, Kacheln von verschiedenen Seiten zu kombinieren und zu mischen.  Der VRAM der NES-Konsole kann 512 solcher Kacheln gleichzeitig anzeigen.  Außerdem teilt sie Kacheln für Sprites und Hintergründe in zwei Hälften.  Dies bedeutet, dass die Konsole gleichzeitig nur 256 Sprite-Kacheln und 256 Hintergrundkacheln anzeigen kann.  Wenn ein Künstler eine Vielzahl von Sprites und Hintergrundelementen anzeigen möchte, behindert ihn eine solche Einschränkung erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/f33/d7c/257f33d7c769a4ed014dd36c4c7d4f7e.png" width="513" height="256"></div><br>  <i>Hier ist eine grafische Darstellung der Hintergrund- und Sprite-Kacheln des in VRAM geladenen Spiels.</i>  <i>Die Konsole speichert Hintergründe und Sprites auf separaten Seiten.</i> <br><br>  Um diese Einschränkung zu umgehen, verwendet NES eine Funktion, mit der ein Künstler jede Seite in Teilseiten aufteilen kann, die als Bänke bezeichnet werden.  Obwohl NES einzelne Kacheln nicht von verschiedenen Punkten der Grafikdaten laden kann, kann es daher separate Teile der Seite zu unterschiedlichen Zeiten laden.  In den meisten Spielen sind solche Banken 1 KB und 2 KB groß.  Eine 1-KB-Bank entspricht einer vierten Seite oder 64 Kacheln, und eine 2-KB-Bank entspricht einer halben Seite oder 128 Kacheln.  Der Künstler muss entscheiden, ob er jeden Bankentyp für Elemente von Sprites oder Hintergründen reservieren möchte, da beide Typen verwendet werden müssen.  Dies bedeutet, dass es unmöglich ist, 1-KB-Bänke für Sprites und Hintergründe zu haben.  Eine Seite sollte 1-KB-Bänke und die andere 2-KB-Bänke verwenden.  In der Regel verwenden die meisten Spiele 1-KB-Bänke für Sprites und 2 KB für Hintergründe, da Hintergrundkachelsätze normalerweise statischer sind und weniger Variabilität und Ersetzen im laufenden Betrieb erfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fc/bb1/484/0fcbb14842a7d9fce566d032a6ab4664.png" width="513" height="256"></div><br>  <i>Das Dosenbild, das wir oben gesehen haben.</i>  <i>Die linke Seite zeigt Hintergründe, die 2-KB-Bänke verwenden, dh in zwei Hälften geteilt sind, und die rechte Seite zeigt Sprites, die in 1-KB-Bänke unterteilt sind.</i>  <i>Jede Bank kann im laufenden Betrieb frei ausgetauscht werden.</i> <br><br>  Die Nützlichkeit von 1K-Banken für Sprites ist ziemlich wichtig.  Wenn das Sprite eines Charakters eine große Anzahl von Animationen enthält, die nicht auf eine Seite passen, und gleichzeitig andere Sprites geladen werden müssen, können einzelne Aktionen in 1-KB-Bänke heruntergeladen und dann durch diese ersetzt werden, je nachdem, was auf dem Bildschirm geschieht.  Es erhöht auch die Variabilität von Sprites, die in einem Bereich des Spiels verwendet werden können.  Wenn ein Spieler beispielsweise auf Spielebene sechs Arten von Feinden treffen muss, aber nur der Spieler und drei andere Arten von Sprites auf der Sprite-Seite platziert sind, kann das Spiel eine der feindlichen Banken durch eine neue Art von Feind ersetzen, wenn eine Art von Feind vom Bildschirm verschwindet. <br><br>  Einer der wenigen schwerwiegenden Nachteile der Verwendung von Bänken mit 1 KB für Sprites und 2 KB für Hintergründe ist die Art und Weise, wie die NES-Konsole Hintergrundanimationen verarbeitet.  Um ein Hintergrundelement eines Spiels für NES zu animieren, muss ein Künstler doppelte Bänke animierter Hintergrundelemente erstellen.  Jede neue doppelte Bank enthält den nächsten Animationsrahmen für jedes der animierten Elemente.  Diese Bänke ersetzen sich gegenseitig und erzeugen Animationen.  Wenn ein Künstler halbseitige Bänke als Hintergrund verwendet, kann das Speichern all dieser doppelten Bänke viel Platz beanspruchen.  Eine Möglichkeit, diese Einschränkung zu umgehen, besteht darin, alle animierten Hintergrundelemente für das gesamte Spiel in einer Bank zu platzieren.  Aber dann steht der Künstler vor einer weiteren Einschränkung: Er hat nur noch 128 Kacheln für die statischen Elemente jedes Hintergrunds.  Jeder Künstler entscheidet selbst, welche Aufbewahrungsmethode für ihn am besten geeignet ist. <br><br><h2>  Layer Tricks </h2><br>  Viele Spiele dieser Zeit verwendeten Tricks, um Effekte wie das Scrollen des Parallaxenhintergrunds zu erzielen, aber sie stellen auch Künstler und Designer vor eine Herausforderung.  Spätere 16-Bit-Konsolen unterstützten mehrere Hintergrundebenen, NES verfügte jedoch nicht über diese Funktion.  Alle Hintergründe waren ein einziges flaches Bild.  Um ein Gefühl von Tiefe und Schichtung zu erzeugen, wurden verschiedene Programmtricks verwendet.  Um beispielsweise ein Parallaxen-Scrollen zu erstellen, können Entwickler ein Register festlegen, das darüber informiert, wann eine bestimmte horizontale Linie (als Scanlinie bezeichnet) auf dem Bildschirm gezeichnet wurde. <br><br>  Dann könnten sie dieses Register verwenden, um die Geschwindigkeit und Richtung des Bildlaufs auf dem Bildschirm zu steuern.  Dank dessen können Sie eine horizontale Linie des Hintergrunds erstellen, die mit einer anderen Geschwindigkeit als der Rest des Hintergrunds scrollt.  Für Künstler und Designer bestand der Trick darin, zu berücksichtigen, dass der Hintergrund immer noch ein flaches Bild ist.  Wenn sich in diesem Bereich eine Plattform oder ein anderes Element befindet, das sich vor einem sich langsam bewegenden Hintergrund befinden sollte, wird auch langsamer gescrollt als der Rest des Bildes.  Dies bedeutet, dass Designer die Hintergrundelemente in der Szene so anordnen mussten, dass der Effekt nicht verzerrt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/36f/7c2/acc36f7c2bab225e5b5f27c283dd68bf.png" width="512" height="448"></div><br>  <i>In diesem Beispiel kann der rot hervorgehobene Bereich zur Simulation der Tiefe langsamer als der Rest des Hintergrunds gescrollt werden.</i>  <i>Die Benutzeroberfläche am oberen Bildschirmrand scrollt nicht, obwohl sie auch Teil eines flachen Hintergrundbilds ist.</i> <br><br>  Es gibt noch einen Trick, mit dem Künstler eines der Hintergrundelemente nach vorne „bewegen“ können.  Bei NES könnten Entwickler die Sprite-Priorität auf weniger als Null setzen.  In diesem Fall wird das Sprite unter allen undurchsichtigen Pixeln des Hintergrunds angezeigt.  Die Sprite-Prioritäten können auch im laufenden Betrieb geändert und umgeschaltet werden, wodurch einzelne Elemente bei Bedarf die Priorität des Sprites ändern können. <br><br><h2>  Unity-Workflows für das ultimative Retro-Feeling </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><strong>Laden Sie ein Beispielprojekt herunter und arbeiten Sie mit uns zusammen!</strong></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Die Mega Cat Studios</a> aus Pittsburgh, PA, haben die Entwicklung von Retro-Spielen zu einer Kunstform gemacht.  Einige ihrer Spiele können sogar auf Kassetten gekauft und auf Retro-Konsolen wie Sega Genesis gespielt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a93/80b/8a0/a9380b8a014bf276ad8196fb84cb4cd0.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f22/0f2/b85/f220f2b85387769849b6aa8267659804.gif" width="690" height="388"></div><br>  <i>Kleine Medusa und Kaffeekrise</i> <br><br>  Die jüngsten Änderungen in den Unity-Workflows haben die Engine zu einer Umgebung gemacht, die sich sehr gut für die Erstellung von Retro-Spielen eignet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">2D Tilemap</a> wurde verbessert und unterstützt jetzt Kachelkarten aus rechteckigen, sechseckigen und isometrischen Kacheln!  Darüber hinaus können Sie die neue Komponente Pixel Perfect Camera verwenden, um ganzheitliche pixelweise Bewegungs- und Grafikeffekte zu erzielen.  Sie können sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">den Nachbearbeitungsstapel verwenden</a> , um alle Arten von schönen Bildschirm-Retro-Effekten hinzuzufügen.  Bevor Sie dies alles tun, müssen Sie die Assets jedoch korrekt importieren und konfigurieren. <br><br><h2>  Vorbereitung von Sprite-Assets </h2><br>  Damit Assets klar und pixelig sind, müssen sie zuerst korrekt konfiguriert werden.  Wählen Sie im Projektfenster jedes der verwendeten Assets aus und ändern Sie die folgenden Parameter im Inspektor: <br><br><ul><li>  Ändern Sie den Filtermodus auf "Punkt". </li><li>  Komprimierungsänderung auf "Keine" </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/d21/a9b/727d21a9bc405de801852b22ac9cb612.png"></div><br>  Andere Filtermodi führen zu einer leichten Unschärfe des Bildes, was den angestrebten klaren Pixelstil verletzt.  Bei Verwendung der Komprimierung werden Bilddaten komprimiert, was zu einer leichten Verringerung der Genauigkeit führt.  Dies ist wichtig zu berücksichtigen, da einige Pixel aufgrund der Komprimierung ihre Farbe ändern können und möglicherweise die gesamte Farbpalette ändern. <br><br>  Je kleiner die Größe und Anzahl der Farben im Sprite ist, desto stärker wirkt sich die Komprimierung darauf aus.  Hier ist ein Beispiel für den Vergleich der normalen Komprimierung (Standard) und der fehlenden Komprimierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b82/2f0/b63/b822f0b63afa445828adbaf9d8095290.png" width="650" height="324"></div><br>  <i>Normale Komprimierung / Bild ohne Komprimierung - sieht genauso aus wie das Original</i> <br><br>  Ein weiterer zu berücksichtigender Aspekt ist der Parameter Max. Größe des Bildes im Inspektor.  Wenn das Sprite-Bild auf einer Achse größer als die Eigenschaft Max Size ist (standardmäßig 2048), wird es automatisch an die maximale Größe angepasst.  Dies führt normalerweise zu einem Qualitätsverlust und das Bild sieht verschwommen aus.  Da einige Plattformen entlang keiner Achse Texturen unterstützen können, die größer als 2048 sind, ist es am besten, innerhalb dieses Bereichs zu bleiben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/503/968/7cb/5039687cbe1e4e34c623abe9ff91f5f8.png" width="650" height="324"></div><br>  <i>Die maximale Größe beträgt 2048 / Und jetzt beträgt die maximale Größe 4096</i> <br><br>  Das obige Bild zeigt ein Sprite aus einem Sprite-Blatt (Sprite-Blatt) mit einer Einzelachsengröße von 2208 und einer maximalen Größe von 2048. Wie Sie sehen, konnten wir durch Erhöhen der Eigenschaft Max Size auf 4096 die richtige Bildgröße ohne Qualitätsverlust sicherstellen. <br><br>  Wenn Sie ein Sprite oder Sprite-Blatt vorbereiten, müssen Sie den Parameter für den Pivot-Unit-Modus auf Pixel anstatt auf Normalisiert setzen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/9fb/7ed/3de9fb7ed5bc8fbee3860d62ecdb31f8.png"></div><br>  Aus diesem Grund wird der Drehpunkt des Bildes auf der Basis von Pixeln und nicht in einem glatten Intervall von 0 bis 1 entlang jeder Bildachse bestimmt.  Wenn der Ankerpunkt des Sprites nicht genau mit dem Pixel ausgerichtet ist, verlieren wir die Position des Sprites aufgrund der Pixelgenauigkeit.  Ankerpunkte für Sprites können im Sprite-Editor festgelegt werden, der im Inspektor geöffnet wird, wenn das Sprite-Asset ausgewählt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/577/1dc/8755771dcb7cfec8e19b4e66a1bc7151.png"></div><br><h2>  Installieren des Pixel Perfect 2D-Pakets </h2><br>  Nachdem wir die Assets vorbereitet haben, können wir das Kamerapixel perfekt machen.  Das pixelgenaue Ergebnis sieht klar und deutlich aus.  Anzeichen von ungenauer Pixelkunst werden zu Unschärfe (Verzerrung) und zur Rechteckigkeit einiger Pixel. <br><br>  Ein 2D Pixel Perfect-Paket kann mit dem Package Manager der Unity Engine importiert werden.  Klicken Sie in der Symbolleiste auf das Menü Fenster und wählen Sie dann Paketmanager.  Klicken Sie im neuen Fenster auf Erweitert und aktivieren Sie das Kontrollkästchen Vorschau-Pakete anzeigen.  Wählen Sie links in der Liste 2D Pixel Perfect aus, und klicken Sie dann oben rechts im Fenster auf Installieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/2e2/f13/2c82e2f13a4d262ae24a269a316b3283.png"></div><br>  Das ist alles.  Jetzt können Sie mit der pixelgenauen Kamerakomponente beginnen. <br><br><h2>  Hohe Pixelgenauigkeit </h2><br>  Die Komponente Pixel Perfect Camera wird zur Kamerakomponente der Unity-Engine hinzugefügt und ergänzt diese.  Um es hinzuzufügen, gehen Sie zur Hauptkamera und fügen Sie die Komponente Pixel Perfect Camera hinzu.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Komponente Pixel Perfect Camera nicht im Menü enthalten ist, führen Sie die obigen Schritte aus, um sie in das Projekt zu importieren. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/181/ee6/43a181ee66528de132ae3cc3391cf699.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns nun die verfügbaren Optionen untersuchen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/90d/9f4/dc890d9f4960a724e5368e5ee954894c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst empfehle ich, "Im Bearbeitungsmodus ausführen" zu aktivieren und das Seitenverhältnis im Spielfenster auf "Freier Aspekt" zu setzen, damit Sie das Spielfenster frei ändern können. </font><font style="vertical-align: inherit;">Die Komponente zeigt nützliche Nachrichten im Spielfenster an, die angeben, ob die Anzeige in der aktuellen Auflösung pixelgenau ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/548/fae/889/548fae8890f6f4d1a6ddf9ba3b7bb8dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können Sie jeden Parameter durchgehen und sehen, wie er sich auf das Erscheinungsbild des Spiels auswirkt. </font></font><br><br><ul><li> <b>Assets Pixels Per Unit</b> —      ,        .     ,       ,        (pixels per unit, PPU),        .          ,     16  16 ,     PPU 16 —           1.      PPU. </li><li> <b>Reference Resolution</b> —    .      .    -,      . , Sega Genesis   320×224.     Sega Genesis     320×224. ,    16:9   320×180  398×224 (      ). </li><li> <b>Upscale Render Texture</b> —                 .         ,   ,     -     .  «Upscale Render Texture»         . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/288/eec/3d9288eec3429b321dbabda98d541e37.png" width="650" height="195"></div><br> <i>1.  ( ) 2.  Upscale Render Texture (   45 ,   ,        ) 3.  Upscale Render Texture (  45 ,   ,     ,         .)</i> <br><br><ul><li> <b>Pixel Snapping</b> (     Upscale Render Texture) —       (sprite renderer)        ,        PPU. ,          transform .    -      ,     -    . <br><ul><li>  Ein Beispiel: </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/491/d2f/9ff491d2f7a076c35ea64ae165fd164d.png" width="1280" height="1000"></div><br> <i> Pixel Snapping .     (0, 0),    —  (1.075, 0).    . ,       .  Pixel Snapping .    —   (0, 0),    (1.075, 0).      .</i> <br><br><ul><li> <strong>Crop Frame (X  Y)</strong> —       ,      ,    ,      . </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stretch Fill</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - immer verfügbar, wenn Sie x und y für Crop Frame aktivieren. </font><font style="vertical-align: inherit;">Diese Option bewirkt, dass die Kamera das Spielfenster so skaliert, dass es auf den Bildschirm passt, während das Seitenverhältnis beibehalten wird. </font><font style="vertical-align: inherit;">Da die Skalierung nicht nur für ganzzahlige Vielfache der Referenzauflösung durchgeführt wird, geht in allen anderen Fällen die Pixelgenauigkeit verloren. </font><font style="vertical-align: inherit;">Der Vorteil dieses Parameters besteht jedoch darin, dass trotz des Verlusts der Pixelgenauigkeit bei vielen Auflösungen keine schwarzen Balken an den Rändern vorhanden sind und der Bildschirm vollständig gefüllt ist. </font><font style="vertical-align: inherit;">Obwohl Dehnungsfüllung häufig Unschärfe verursacht, wird keine normale Warnung angezeigt.</font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/034/ad1/859034ad1cc5f30911ff04808bea27c1.png" width="312" height="302"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charakter und Hintergrund, verschwommene Stretchfüllung</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Perfect Camera Empfehlungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie eine pixelgenaue Anzeige mit einem Raster am Raster benötigen, empfehle ich Folgendes: </font></font><br><br><ul><li>   ,         ( 320×180). </li><li>    Upscale Render Texture <br><ul><li>   ,     ,   90, 180  270       ,      . </li><li> Upscale Render Texture       - ;     .        ,    Pixel Perfect Camera  Run in Edit Mode  ,       .     -     ,       - . </li></ul></li><li>    Pixel Snapping <ul><li>        .       ,     . </li></ul></li><li>  Crop Frame X / Y,   Upscale Render Texture <ul><li>      -   upscale render texture,   X / Y  -      ,          . </li></ul></li><li>  Stretch Fill </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir empfehlen, die Kamera so einzurichten, dass sie für ein Bildschirmverhältnis von 16: 9 einschließlich Referenzauflösung optimiert ist, sofern dies möglich ist. Zum Zeitpunkt des Schreibens spielen die meisten Spieler auf Monitoren mit einem Seitenverhältnis von 16: 9 und einer Auflösung von 1920 × 1080. Beispielsweise hat die Referenzauflösung von 320 × 180 ein Verhältnis von 16: 9, und daher gibt es bei einer Auflösung von 1920 × 1080 und anderen Auflösungen, die ein Vielfaches von 320 × 180 sind, beispielsweise 1280 × 720, keine schwarzen Ränder an den Rändern des Bildschirms.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Unity-Symbolleiste können Sie zu Bearbeiten&gt; Projekteinstellungen&gt; Player gehen und die vom Spiel unterstützten Seitenverhältnisse begrenzen. Wenn Sie feststellen, dass eine bestimmte Konfiguration in dem von Ihnen benötigten Verhältnis gut aussieht, aber nicht gut in einzelne Verhältnisse passt, können Sie diese Verhältnisse hier deaktivieren. Beachten Sie jedoch, dass nicht alle Benutzer einen Bildschirm haben, der mit Ihren Einschränkungen gut kompatibel ist. Dies wird daher nicht empfohlen. Verwenden Sie stattdessen das Zuschneiden, damit diese Benutzer schwarze Ränder anzeigen und das Spiel nicht mit einer Auflösung startet, die nicht zu ihrem Bildschirm passt.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie versuchen, ein Projekt zu erstellen, das für eine Retro-Konsole authentisch ist, müssen Sie viele technische Aspekte berücksichtigen, an die in der modernen Entwicklung niemand denkt. </font><font style="vertical-align: inherit;">Aufgrund der Art der Bildwiedergabe und des geringen Speicherbedarfs älterer Maschinen mussten Designer kreativ denken und Hardwareeinschränkungen umgehen. </font><font style="vertical-align: inherit;">In der Neuzeit müssen wir diese Einschränkungen und Techniken kennen, um das Aussehen und Design von Spielen dieser Zeit genau wiederzugeben. </font><font style="vertical-align: inherit;">Im nächsten Beitrag werden wir uns mit den Designbeschränkungen der Ära der 16-Bit-Spiele sowie dem Unity-Workflow befassen, der erforderlich ist, um den tatsächlichen Stil des „alten Fernsehgeräts“ wiederherzustellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462843/">https://habr.com/ru/post/de462843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462827/index.html">Leben und Erfolg von Larry Ellison, Gründer von Oracle</a></li>
<li><a href="../de462831/index.html">Fahren Sie mit der Web 3.0 Wave</a></li>
<li><a href="../de462833/index.html">Das Buch "Predictive Modeling in der Praxis"</a></li>
<li><a href="../de462835/index.html">Unity Auto-Layout und Stile: Unsere neue Pipeline und Tools für die Benutzeroberfläche</a></li>
<li><a href="../de462837/index.html">Black-Box-Test</a></li>
<li><a href="../de462845/index.html">Massage für Ihr Gehirn: Sprechen Sie über ASMR</a></li>
<li><a href="../de462847/index.html">Hewlett Packard Enterprise-Webinare von August bis Oktober 2019</a></li>
<li><a href="../de462849/index.html">Irgendwas mit Inode</a></li>
<li><a href="../de462851/index.html">Wir bieten einen Cloud-Service für die Verwaltung von Verbrauchsmaterialien (Angular + Firebase).</a></li>
<li><a href="../de462853/index.html">Aktualisieren von Statistiken zu sekundären Replikaten der Verfügbarkeitsgruppe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>