<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¢Ô∏è üôéüèæ üë∞üèø Einschr√§nkungen von 8-Bit-Spielen und deren genaue Wiederherstellung in Unity ü§≥üèø ‚ú°Ô∏è ‚úÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retro-Spiele mit einfacher Mechanik und Pixelgrafiken k√∂nnen bei erfahrenen Spielern warme Erinnerungen hervorrufen und sind gleichzeitig f√ºr ein j√ºng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einschr√§nkungen von 8-Bit-Spielen und deren genaue Wiederherstellung in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462843/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/d1d/acb/2a7d1dacbe9050c41e0fe50ca79e789e.png" alt="Bild"></div><br>  Retro-Spiele mit einfacher Mechanik und Pixelgrafiken k√∂nnen bei erfahrenen Spielern warme Erinnerungen hervorrufen und sind gleichzeitig f√ºr ein j√ºngeres Publikum gut zug√§nglich.  Heutzutage werden viele Spiele als Retro bezeichnet, aber Aufwand und Planung sind erforderlich, um einen nostalgischen Stil zu kreieren.  Deshalb haben wir die Jungs von Mega Cat Studios eingeladen, uns bei der Diskussion dieses Themas zu helfen.  In diesem Beitrag behandeln wir alles, was Sie zum Erstellen authentischer Grafiken im NES-Spielstil ben√∂tigen, einschlie√ülich wichtiger Unity-Optionen, Grafikstrukturen und Farbpaletten. <br><br><h2>  Erstellen Sie authentische Kunst im NES-Stil </h2><br>  Zun√§chst werden die Grundlagen zum Erstellen von Grafiken f√ºr Spiele behandelt, die den Einschr√§nkungen des klassischen Nintendo Entertainment Systems entsprechen.  Diese Konsolengeneration unterwirft K√ºnstlern, die ihre authentischen Grafiken reproduzieren m√∂chten, ernsthafte Einschr√§nkungen.  Dies sind Einschr√§nkungen hinsichtlich der verwendeten Paletten sowie der Gr√∂√üe und Anzahl der Objekte auf dem Bildschirm.  Dar√ºber hinaus ist zu beachten, dass die Aufl√∂sung dieser Konsole 256 √ó 240 Pixel betr√§gt. <br><br><h3>  Paletten </h3><br>  Bei der Erstellung von NES-kompatiblen Grafiken muss der K√ºnstler viele Einschr√§nkungen ber√ºcksichtigen.  Erstens ist die wichtigste dieser Einschr√§nkungen die Verwendung von Farbpaletten im Bild.  NES ist insofern einzigartig, als alle m√∂glichen Farben der Palette mit der Konsole ‚Äûverbunden‚Äú sind.  NES w√§hlt aus, welche Farben im Bild verwendet werden sollen, indem Wertes√§tze an die NES-GPU gesendet werden. Danach gibt die GPU die Farben zur√ºck, die diesen Werten entsprechen.  Das Folgende ist ein Bild der NES-Farbpalette: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/4f9/0fd/10e4f90fdf5bb0ac7832dd5f4ab7d4a9.png"></div><br>  Diese Farben k√∂nnen nicht ge√§ndert werden, da sie Teil der Konsole selbst sind.  Alle NES-Spiele verwenden Kombinationen dieser Farben, aus denen die Bilder bestehen. <br><a name="habracut"></a><br><h3>  Unterpaletten </h3><br>  Um in Spielen verwendete Kombinationen zu erstellen, werden Unterpaletten erstellt, die an Sprites oder Hintergrundbilder im Spiel angeh√§ngt werden.  NES teilt die Palette in Unterpaletten auf, die Sprites und Hintergr√ºnden zugewiesen werden k√∂nnen.  Jede Unterpalette enth√§lt eine gemeinsame Farbe, die in allen Unterpaletten verwendet wird, und drei eindeutige Farben.  Es k√∂nnen vier Unterpaletten f√ºr Hintergr√ºnde und vier Unterpaletten f√ºr Sprites geladen werden.  Bei Sprites wird die Gesamtfarbe am Anfang jeder Unterpalette als transparent betrachtet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/59a/330/33759a330bb3449bdf5a33c8ad1f671f.png"></div><br>  Hier ist ein Beispiel f√ºr eine Reihe von Unterpaletten, die im Spiel verwendet werden.  Der obere Teil zeigt die Hintergrund-Unterpaletten, der untere Teil zeigt die Sprite-Unterpaletten.  In diesem Beispiel ist Schwarz die in allen Unterpaletten verwendete gemeinsame Farbe.  Da die Gesamtfarbe in Sprites als transparent betrachtet wird, wird in den Unterpaletten f√ºr Sprites eine zweite schwarze Farbe ben√∂tigt, die als sichtbare Farbe verwendet wird. <br><br><h3>  Unterpaletten zuweisen </h3><br>  Die Einschr√§nkungen f√ºr die Verwendung von Paletten werden noch strenger, wenn der K√ºnstler fortf√§hrt, wie die Paletten im Spiel verwendet werden.  Um dies zu erkl√§ren, m√ºssen Sie mehr dar√ºber sprechen, wie Retro-Konsolen Grafiken speichern und anzeigen.  Die Grafiken einer Retro-Konsole werden im Spiel als 8 √ó 8-Pixel-Kacheln gespeichert.  Dank dessen k√∂nnen K√ºnstler Platz sparen, indem sie Kacheln f√ºr verschiedene Objekte wiederverwenden.  (Zum Beispiel k√∂nnen Teile der Stra√üe wiederverwendet werden, indem eine Klippe oder ein Geb√§ude daraus erstellt wird.)  Es ist auch wichtig, dass die Farbinformationen nicht in den Grafiken gespeichert werden.  Alle Kacheln werden in einer monochromen Palette gespeichert.  Dank dessen k√∂nnen Sie, wenn eine Kachel im Spiel angezeigt wird, ihr eine Unterpalette zuweisen und sie gleichzeitig mit verschiedenen Unterpaletten auf dem Bildschirm anzeigen.  Dies ist wichtig, wenn Sie Retro-Konsolengrafiken auf modernen Plattformen neu erstellen, da dies die Zuordnung von Paletten zu Grafiken beeinflusst. <br><br>  NES weist Sprites und Hintergr√ºnden unterschiedliche Paletten zu.  Sie weist Sprit-Paletten taylovo zu.  Dies bedeutet, dass jeder 8 √ó 8-Kachel im Sprite eine von vier Sprite-Unterpaletten zugeordnet werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/e7a/d58/d0ae7ad5802681f0f3fd700f52307279.png" width="1200" height="600"></div><br>  Dieser Ninja-Charakter verwendet zwei Unterpaletten, um die Farbtiefe zu erh√∂hen.  Rechts sehen Sie, dass es in separate 8 √ó 8-Kacheln unterteilt ist.  In solch einer geteilten Form f√§llt auf, dass das helle T√ºrkis und das dunkle Rot, die in Schwert und Stirnband verwendet werden, f√ºr diese Fliesen einzigartig sind und die dunkelvioletten und schwarzen Konturen in den verbleibenden drei Fliesen verwendet werden. <br><br>  Hintergr√ºnde unterliegen viel strengeren Einschr√§nkungen.  Hintergrundpaletten sind 16 √ó 16 Fragmenten zugeordnet.  Die Hintergrundunterpalettenbindungen des gesamten Bildschirms werden als Attributtabellen (Attributtabellen) bezeichnet.  Gerade aufgrund dieser Tabellen verwenden die meisten Retro-Bilder aktiv sich wiederholende Kachelsegmente.  Solche Segmente bestehen normalerweise aus 16 √ó 16 Kacheln, weshalb sie in Attributtabellen platziert werden.  Trotz der Tatsache, dass dies durch Hardwareeinschr√§nkungen verursacht wurde, wurden solche 16 √ó 16-Hintergrundkacheln zum bestimmenden Merkmal von Retro-Grafiken und sind jetzt f√ºr ihre Rekonstruktion in modernen Spielen absolut notwendig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/fb6/dfb/f7dfb6dfb062288789f2d76c2055758f.png" width="1200" height="600"></div><br>  <i>Hier ist ein Beispiel f√ºr den Hintergrund einer sch√∂nen Stadt im Stil eines Rollenspiels, das unter Ber√ºcksichtigung dieser Einschr√§nkungen erstellt wurde.</i>  <i>Das Bild rechts zeigt, dass es gut in Bl√∂cke von 16 √ó 16 Pixel unterteilt ist und f√ºr jeden Block Paletten festgelegt sind.</i>  <i>Um Platz zu sparen, bestehen Elemente wie Dachziegel, Gras und Ziegel auf der Br√ºcke aus sich wiederholenden Segmenten dieser Bl√∂cke.</i>  <i>Die Dachziegel kleiner Geb√§ude verwenden dieselben Ziegel, ihnen werden jedoch unterschiedliche Unterpaletten zugewiesen, wodurch sie ein einzigartiges Erscheinungsbild erhalten.</i> <br><br><h2>  Sprite-Overlay </h2><br>  Obwohl K√ºnstler f√ºr jede 8 √ó 8-Sprite-Kachel unterschiedliche Unterpaletten verwenden k√∂nnen, kann es vorkommen, dass dem Sprite eine gr√∂√üere Farbtiefe verliehen werden muss.  In diesem Fall k√∂nnen Sie Sprite-Overlay verwenden.  Das √úberlagern von Sprites ist die Aufteilung eines Sprites in zwei separate Sprites und das √úbereinanderlegen.  Auf diese Weise k√∂nnen K√ºnstler die Bedingung umgehen, eine Unterpalette pro 8 √ó 8-Kachel zu verwenden.  Dank dessen k√∂nnen K√ºnstler tats√§chlich die Anzahl der Farben verdoppeln, die in einem 8 √ó 8-Bereich verwendet werden k√∂nnen.  Der einzige schwerwiegende Nachteil dieses Ansatzes sind die Einschr√§nkungen beim Sprite-Rendering.  NES kann jeweils nur 64 8 √ó 8-Sprite-Kacheln und nur acht Sprite-Kacheln in einer horizontalen Linie anzeigen.  Wenn diese Grenze erreicht ist, werden nicht alle anderen Kacheln auf dem Bildschirm gerendert.  Deshalb beginnen sie in vielen Spielen f√ºr NES mit einer gro√üen Anzahl von Sprites auf dem Bildschirm zu flackern.  In diesem Fall k√∂nnen Sie alle Sprites nur in abwechselnden Frames anzeigen.  Solche Einschr√§nkungen m√ºssen bei der √úberlagerung von Sprite-Ebenen ber√ºcksichtigt werden, da dies nicht nur die Anzahl der Farben, sondern auch die Anzahl der Sprite-Kacheln in einer horizontalen Linie verdoppelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/5be/239/3865be2393a5aabf1aa3fa534ee3f7d4.png" width="1600" height="503"></div><br>  <i>Hier ist ein Beispiel f√ºr Sprite Layering in Aktion.</i>  <i>Die urspr√ºngliche dreifarbige Version des Geisterpiraten-Sprites ist links abgebildet.</i>  <i>Der K√ºnstler teilte es in zwei Teile - K√∂rper / Hut und Gesicht / H√§nde - und ordnete ihnen dann verschiedene Paletten zu.</i>  <i>Rechts ist das Ergebnis der √úberlagerung zweier Elemente.</i> <br><br>  Um die Einschr√§nkungen der Attributtabelle zu umgehen, k√∂nnen Sie Sprite-Layer mithilfe des Hintergrunds implementieren.  Dieser Trick wird normalerweise f√ºr statische Bilder wie Plotbildschirme und Charakterportr√§ts verwendet, wodurch sie eine viel gr√∂√üere Farbtiefe erhalten.  Um dies zu realisieren, muss der K√ºnstler einen Teil des Bildes als Hintergrund zeichnen und dann Sprites darauf auftragen, um die verbleibenden Teile auszuf√ºllen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/d4f/9aa/eddd4f9aadcc18eb50358c94dea42022.png" width="1407" height="600"></div><br>  <i>Im Portr√§t eines Geisterpiraten werden auch Schichten von Sprites verwendet, um ihm eine gr√∂√üere Tiefe zu verleihen.</i>  <i>Sein gr√ºner Sch√§del wird als Sprite auf dem Bildschirm dargestellt, und sein Kragen und sein Hut sind Teil des Hintergrunds.</i>  <i>Dadurch kann der K√ºnstler mehr Farben im 16 √ó 16-Segment verwenden, um die Einschr√§nkungen der Attributtabelle vollst√§ndig zu umgehen.</i> <br><br><h2>  Grafikbanken </h2><br>  Um eine weitere wichtige Einschr√§nkung von NES zu erkl√§ren, m√ºssen wir zun√§chst darauf zur√ºckkommen, dass Grafiken in Kacheln gespeichert sind.  Grafikkacheln werden auf Seiten mit 256 Kacheln gespeichert, und Kacheln von diesen Seiten k√∂nnen nicht an verschiedenen Stellen in VRAM geladen werden, sodass es im laufenden Betrieb schwierig wird, Kacheln von verschiedenen Seiten zu kombinieren und zu mischen.  Der VRAM der NES-Konsole kann 512 solcher Kacheln gleichzeitig anzeigen.  Au√üerdem teilt sie Kacheln f√ºr Sprites und Hintergr√ºnde in zwei H√§lften.  Dies bedeutet, dass die Konsole gleichzeitig nur 256 Sprite-Kacheln und 256 Hintergrundkacheln anzeigen kann.  Wenn ein K√ºnstler eine Vielzahl von Sprites und Hintergrundelementen anzeigen m√∂chte, behindert ihn eine solche Einschr√§nkung erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/f33/d7c/257f33d7c769a4ed014dd36c4c7d4f7e.png" width="513" height="256"></div><br>  <i>Hier ist eine grafische Darstellung der Hintergrund- und Sprite-Kacheln des in VRAM geladenen Spiels.</i>  <i>Die Konsole speichert Hintergr√ºnde und Sprites auf separaten Seiten.</i> <br><br>  Um diese Einschr√§nkung zu umgehen, verwendet NES eine Funktion, mit der ein K√ºnstler jede Seite in Teilseiten aufteilen kann, die als B√§nke bezeichnet werden.  Obwohl NES einzelne Kacheln nicht von verschiedenen Punkten der Grafikdaten laden kann, kann es daher separate Teile der Seite zu unterschiedlichen Zeiten laden.  In den meisten Spielen sind solche Banken 1 KB und 2 KB gro√ü.  Eine 1-KB-Bank entspricht einer vierten Seite oder 64 Kacheln, und eine 2-KB-Bank entspricht einer halben Seite oder 128 Kacheln.  Der K√ºnstler muss entscheiden, ob er jeden Bankentyp f√ºr Elemente von Sprites oder Hintergr√ºnden reservieren m√∂chte, da beide Typen verwendet werden m√ºssen.  Dies bedeutet, dass es unm√∂glich ist, 1-KB-B√§nke f√ºr Sprites und Hintergr√ºnde zu haben.  Eine Seite sollte 1-KB-B√§nke und die andere 2-KB-B√§nke verwenden.  In der Regel verwenden die meisten Spiele 1-KB-B√§nke f√ºr Sprites und 2 KB f√ºr Hintergr√ºnde, da Hintergrundkachels√§tze normalerweise statischer sind und weniger Variabilit√§t und Ersetzen im laufenden Betrieb erfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fc/bb1/484/0fcbb14842a7d9fce566d032a6ab4664.png" width="513" height="256"></div><br>  <i>Das Dosenbild, das wir oben gesehen haben.</i>  <i>Die linke Seite zeigt Hintergr√ºnde, die 2-KB-B√§nke verwenden, dh in zwei H√§lften geteilt sind, und die rechte Seite zeigt Sprites, die in 1-KB-B√§nke unterteilt sind.</i>  <i>Jede Bank kann im laufenden Betrieb frei ausgetauscht werden.</i> <br><br>  Die N√ºtzlichkeit von 1K-Banken f√ºr Sprites ist ziemlich wichtig.  Wenn das Sprite eines Charakters eine gro√üe Anzahl von Animationen enth√§lt, die nicht auf eine Seite passen, und gleichzeitig andere Sprites geladen werden m√ºssen, k√∂nnen einzelne Aktionen in 1-KB-B√§nke heruntergeladen und dann durch diese ersetzt werden, je nachdem, was auf dem Bildschirm geschieht.  Es erh√∂ht auch die Variabilit√§t von Sprites, die in einem Bereich des Spiels verwendet werden k√∂nnen.  Wenn ein Spieler beispielsweise auf Spielebene sechs Arten von Feinden treffen muss, aber nur der Spieler und drei andere Arten von Sprites auf der Sprite-Seite platziert sind, kann das Spiel eine der feindlichen Banken durch eine neue Art von Feind ersetzen, wenn eine Art von Feind vom Bildschirm verschwindet. <br><br>  Einer der wenigen schwerwiegenden Nachteile der Verwendung von B√§nken mit 1 KB f√ºr Sprites und 2 KB f√ºr Hintergr√ºnde ist die Art und Weise, wie die NES-Konsole Hintergrundanimationen verarbeitet.  Um ein Hintergrundelement eines Spiels f√ºr NES zu animieren, muss ein K√ºnstler doppelte B√§nke animierter Hintergrundelemente erstellen.  Jede neue doppelte Bank enth√§lt den n√§chsten Animationsrahmen f√ºr jedes der animierten Elemente.  Diese B√§nke ersetzen sich gegenseitig und erzeugen Animationen.  Wenn ein K√ºnstler halbseitige B√§nke als Hintergrund verwendet, kann das Speichern all dieser doppelten B√§nke viel Platz beanspruchen.  Eine M√∂glichkeit, diese Einschr√§nkung zu umgehen, besteht darin, alle animierten Hintergrundelemente f√ºr das gesamte Spiel in einer Bank zu platzieren.  Aber dann steht der K√ºnstler vor einer weiteren Einschr√§nkung: Er hat nur noch 128 Kacheln f√ºr die statischen Elemente jedes Hintergrunds.  Jeder K√ºnstler entscheidet selbst, welche Aufbewahrungsmethode f√ºr ihn am besten geeignet ist. <br><br><h2>  Layer Tricks </h2><br>  Viele Spiele dieser Zeit verwendeten Tricks, um Effekte wie das Scrollen des Parallaxenhintergrunds zu erzielen, aber sie stellen auch K√ºnstler und Designer vor eine Herausforderung.  Sp√§tere 16-Bit-Konsolen unterst√ºtzten mehrere Hintergrundebenen, NES verf√ºgte jedoch nicht √ºber diese Funktion.  Alle Hintergr√ºnde waren ein einziges flaches Bild.  Um ein Gef√ºhl von Tiefe und Schichtung zu erzeugen, wurden verschiedene Programmtricks verwendet.  Um beispielsweise ein Parallaxen-Scrollen zu erstellen, k√∂nnen Entwickler ein Register festlegen, das dar√ºber informiert, wann eine bestimmte horizontale Linie (als Scanlinie bezeichnet) auf dem Bildschirm gezeichnet wurde. <br><br>  Dann k√∂nnten sie dieses Register verwenden, um die Geschwindigkeit und Richtung des Bildlaufs auf dem Bildschirm zu steuern.  Dank dessen k√∂nnen Sie eine horizontale Linie des Hintergrunds erstellen, die mit einer anderen Geschwindigkeit als der Rest des Hintergrunds scrollt.  F√ºr K√ºnstler und Designer bestand der Trick darin, zu ber√ºcksichtigen, dass der Hintergrund immer noch ein flaches Bild ist.  Wenn sich in diesem Bereich eine Plattform oder ein anderes Element befindet, das sich vor einem sich langsam bewegenden Hintergrund befinden sollte, wird auch langsamer gescrollt als der Rest des Bildes.  Dies bedeutet, dass Designer die Hintergrundelemente in der Szene so anordnen mussten, dass der Effekt nicht verzerrt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/36f/7c2/acc36f7c2bab225e5b5f27c283dd68bf.png" width="512" height="448"></div><br>  <i>In diesem Beispiel kann der rot hervorgehobene Bereich zur Simulation der Tiefe langsamer als der Rest des Hintergrunds gescrollt werden.</i>  <i>Die Benutzeroberfl√§che am oberen Bildschirmrand scrollt nicht, obwohl sie auch Teil eines flachen Hintergrundbilds ist.</i> <br><br>  Es gibt noch einen Trick, mit dem K√ºnstler eines der Hintergrundelemente nach vorne ‚Äûbewegen‚Äú k√∂nnen.  Bei NES k√∂nnten Entwickler die Sprite-Priorit√§t auf weniger als Null setzen.  In diesem Fall wird das Sprite unter allen undurchsichtigen Pixeln des Hintergrunds angezeigt.  Die Sprite-Priorit√§ten k√∂nnen auch im laufenden Betrieb ge√§ndert und umgeschaltet werden, wodurch einzelne Elemente bei Bedarf die Priorit√§t des Sprites √§ndern k√∂nnen. <br><br><h2>  Unity-Workflows f√ºr das ultimative Retro-Feeling </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><strong>Laden Sie ein Beispielprojekt herunter und arbeiten Sie mit uns zusammen!</strong></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Die Mega Cat Studios</a> aus Pittsburgh, PA, haben die Entwicklung von Retro-Spielen zu einer Kunstform gemacht.  Einige ihrer Spiele k√∂nnen sogar auf Kassetten gekauft und auf Retro-Konsolen wie Sega Genesis gespielt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a93/80b/8a0/a9380b8a014bf276ad8196fb84cb4cd0.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f22/0f2/b85/f220f2b85387769849b6aa8267659804.gif" width="690" height="388"></div><br>  <i>Kleine Medusa und Kaffeekrise</i> <br><br>  Die j√ºngsten √Ñnderungen in den Unity-Workflows haben die Engine zu einer Umgebung gemacht, die sich sehr gut f√ºr die Erstellung von Retro-Spielen eignet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">2D Tilemap</a> wurde verbessert und unterst√ºtzt jetzt Kachelkarten aus rechteckigen, sechseckigen und isometrischen Kacheln!  Dar√ºber hinaus k√∂nnen Sie die neue Komponente Pixel Perfect Camera verwenden, um ganzheitliche pixelweise Bewegungs- und Grafikeffekte zu erzielen.  Sie k√∂nnen sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">den Nachbearbeitungsstapel verwenden</a> , um alle Arten von sch√∂nen Bildschirm-Retro-Effekten hinzuzuf√ºgen.  Bevor Sie dies alles tun, m√ºssen Sie die Assets jedoch korrekt importieren und konfigurieren. <br><br><h2>  Vorbereitung von Sprite-Assets </h2><br>  Damit Assets klar und pixelig sind, m√ºssen sie zuerst korrekt konfiguriert werden.  W√§hlen Sie im Projektfenster jedes der verwendeten Assets aus und √§ndern Sie die folgenden Parameter im Inspektor: <br><br><ul><li>  √Ñndern Sie den Filtermodus auf "Punkt". </li><li>  Komprimierungs√§nderung auf "Keine" </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/d21/a9b/727d21a9bc405de801852b22ac9cb612.png"></div><br>  Andere Filtermodi f√ºhren zu einer leichten Unsch√§rfe des Bildes, was den angestrebten klaren Pixelstil verletzt.  Bei Verwendung der Komprimierung werden Bilddaten komprimiert, was zu einer leichten Verringerung der Genauigkeit f√ºhrt.  Dies ist wichtig zu ber√ºcksichtigen, da einige Pixel aufgrund der Komprimierung ihre Farbe √§ndern k√∂nnen und m√∂glicherweise die gesamte Farbpalette √§ndern. <br><br>  Je kleiner die Gr√∂√üe und Anzahl der Farben im Sprite ist, desto st√§rker wirkt sich die Komprimierung darauf aus.  Hier ist ein Beispiel f√ºr den Vergleich der normalen Komprimierung (Standard) und der fehlenden Komprimierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b82/2f0/b63/b822f0b63afa445828adbaf9d8095290.png" width="650" height="324"></div><br>  <i>Normale Komprimierung / Bild ohne Komprimierung - sieht genauso aus wie das Original</i> <br><br>  Ein weiterer zu ber√ºcksichtigender Aspekt ist der Parameter Max. Gr√∂√üe des Bildes im Inspektor.  Wenn das Sprite-Bild auf einer Achse gr√∂√üer als die Eigenschaft Max Size ist (standardm√§√üig 2048), wird es automatisch an die maximale Gr√∂√üe angepasst.  Dies f√ºhrt normalerweise zu einem Qualit√§tsverlust und das Bild sieht verschwommen aus.  Da einige Plattformen entlang keiner Achse Texturen unterst√ºtzen k√∂nnen, die gr√∂√üer als 2048 sind, ist es am besten, innerhalb dieses Bereichs zu bleiben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/503/968/7cb/5039687cbe1e4e34c623abe9ff91f5f8.png" width="650" height="324"></div><br>  <i>Die maximale Gr√∂√üe betr√§gt 2048 / Und jetzt betr√§gt die maximale Gr√∂√üe 4096</i> <br><br>  Das obige Bild zeigt ein Sprite aus einem Sprite-Blatt (Sprite-Blatt) mit einer Einzelachsengr√∂√üe von 2208 und einer maximalen Gr√∂√üe von 2048. Wie Sie sehen, konnten wir durch Erh√∂hen der Eigenschaft Max Size auf 4096 die richtige Bildgr√∂√üe ohne Qualit√§tsverlust sicherstellen. <br><br>  Wenn Sie ein Sprite oder Sprite-Blatt vorbereiten, m√ºssen Sie den Parameter f√ºr den Pivot-Unit-Modus auf Pixel anstatt auf Normalisiert setzen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/9fb/7ed/3de9fb7ed5bc8fbee3860d62ecdb31f8.png"></div><br>  Aus diesem Grund wird der Drehpunkt des Bildes auf der Basis von Pixeln und nicht in einem glatten Intervall von 0 bis 1 entlang jeder Bildachse bestimmt.  Wenn der Ankerpunkt des Sprites nicht genau mit dem Pixel ausgerichtet ist, verlieren wir die Position des Sprites aufgrund der Pixelgenauigkeit.  Ankerpunkte f√ºr Sprites k√∂nnen im Sprite-Editor festgelegt werden, der im Inspektor ge√∂ffnet wird, wenn das Sprite-Asset ausgew√§hlt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/577/1dc/8755771dcb7cfec8e19b4e66a1bc7151.png"></div><br><h2>  Installieren des Pixel Perfect 2D-Pakets </h2><br>  Nachdem wir die Assets vorbereitet haben, k√∂nnen wir das Kamerapixel perfekt machen.  Das pixelgenaue Ergebnis sieht klar und deutlich aus.  Anzeichen von ungenauer Pixelkunst werden zu Unsch√§rfe (Verzerrung) und zur Rechteckigkeit einiger Pixel. <br><br>  Ein 2D Pixel Perfect-Paket kann mit dem Package Manager der Unity Engine importiert werden.  Klicken Sie in der Symbolleiste auf das Men√º Fenster und w√§hlen Sie dann Paketmanager.  Klicken Sie im neuen Fenster auf Erweitert und aktivieren Sie das Kontrollk√§stchen Vorschau-Pakete anzeigen.  W√§hlen Sie links in der Liste 2D Pixel Perfect aus, und klicken Sie dann oben rechts im Fenster auf Installieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/2e2/f13/2c82e2f13a4d262ae24a269a316b3283.png"></div><br>  Das ist alles.  Jetzt k√∂nnen Sie mit der pixelgenauen Kamerakomponente beginnen. <br><br><h2>  Hohe Pixelgenauigkeit </h2><br>  Die Komponente Pixel Perfect Camera wird zur Kamerakomponente der Unity-Engine hinzugef√ºgt und erg√§nzt diese.  Um es hinzuzuf√ºgen, gehen Sie zur Hauptkamera und f√ºgen Sie die Komponente Pixel Perfect Camera hinzu.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Komponente Pixel Perfect Camera nicht im Men√º enthalten ist, f√ºhren Sie die obigen Schritte aus, um sie in das Projekt zu importieren. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/181/ee6/43a181ee66528de132ae3cc3391cf699.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns nun die verf√ºgbaren Optionen untersuchen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/90d/9f4/dc890d9f4960a724e5368e5ee954894c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst empfehle ich, "Im Bearbeitungsmodus ausf√ºhren" zu aktivieren und das Seitenverh√§ltnis im Spielfenster auf "Freier Aspekt" zu setzen, damit Sie das Spielfenster frei √§ndern k√∂nnen. </font><font style="vertical-align: inherit;">Die Komponente zeigt n√ºtzliche Nachrichten im Spielfenster an, die angeben, ob die Anzeige in der aktuellen Aufl√∂sung pixelgenau ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/548/fae/889/548fae8890f6f4d1a6ddf9ba3b7bb8dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen Sie jeden Parameter durchgehen und sehen, wie er sich auf das Erscheinungsbild des Spiels auswirkt. </font></font><br><br><ul><li> <b>Assets Pixels Per Unit</b> ‚Äî      ,        .     ,       ,        (pixels per unit, PPU),        .          ,     16  16 ,     PPU 16 ‚Äî           1.      PPU. </li><li> <b>Reference Resolution</b> ‚Äî    .      .    -,      . , Sega Genesis   320√ó224.     Sega Genesis     320√ó224. ,    16:9   320√ó180  398√ó224 (      ). </li><li> <b>Upscale Render Texture</b> ‚Äî                 .         ,   ,     -     .  ¬´Upscale Render Texture¬ª         . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/288/eec/3d9288eec3429b321dbabda98d541e37.png" width="650" height="195"></div><br> <i>1.  ( ) 2.  Upscale Render Texture (   45 ,   ,        ) 3.  Upscale Render Texture (  45 ,   ,     ,         .)</i> <br><br><ul><li> <b>Pixel Snapping</b> (     Upscale Render Texture) ‚Äî       (sprite renderer)        ,        PPU. ,          transform .    -      ,     -    . <br><ul><li>  Ein Beispiel: </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/491/d2f/9ff491d2f7a076c35ea64ae165fd164d.png" width="1280" height="1000"></div><br> <i> Pixel Snapping .     (0, 0),    ‚Äî  (1.075, 0).    . ,       .  Pixel Snapping .    ‚Äî   (0, 0),    (1.075, 0).      .</i> <br><br><ul><li> <strong>Crop Frame (X  Y)</strong> ‚Äî       ,      ,    ,      . </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stretch Fill</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - immer verf√ºgbar, wenn Sie x und y f√ºr Crop Frame aktivieren. </font><font style="vertical-align: inherit;">Diese Option bewirkt, dass die Kamera das Spielfenster so skaliert, dass es auf den Bildschirm passt, w√§hrend das Seitenverh√§ltnis beibehalten wird. </font><font style="vertical-align: inherit;">Da die Skalierung nicht nur f√ºr ganzzahlige Vielfache der Referenzaufl√∂sung durchgef√ºhrt wird, geht in allen anderen F√§llen die Pixelgenauigkeit verloren. </font><font style="vertical-align: inherit;">Der Vorteil dieses Parameters besteht jedoch darin, dass trotz des Verlusts der Pixelgenauigkeit bei vielen Aufl√∂sungen keine schwarzen Balken an den R√§ndern vorhanden sind und der Bildschirm vollst√§ndig gef√ºllt ist. </font><font style="vertical-align: inherit;">Obwohl Dehnungsf√ºllung h√§ufig Unsch√§rfe verursacht, wird keine normale Warnung angezeigt.</font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/034/ad1/859034ad1cc5f30911ff04808bea27c1.png" width="312" height="302"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charakter und Hintergrund, verschwommene Stretchf√ºllung</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Perfect Camera Empfehlungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie eine pixelgenaue Anzeige mit einem Raster am Raster ben√∂tigen, empfehle ich Folgendes: </font></font><br><br><ul><li>   ,         ( 320√ó180). </li><li>    Upscale Render Texture <br><ul><li>   ,     ,   90, 180  270       ,      . </li><li> Upscale Render Texture       - ;     .        ,    Pixel Perfect Camera  Run in Edit Mode  ,       .     -     ,       - . </li></ul></li><li>    Pixel Snapping <ul><li>        .       ,     . </li></ul></li><li>  Crop Frame X / Y,   Upscale Render Texture <ul><li>      -   upscale render texture,   X / Y  -      ,          . </li></ul></li><li>  Stretch Fill </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir empfehlen, die Kamera so einzurichten, dass sie f√ºr ein Bildschirmverh√§ltnis von 16: 9 einschlie√ülich Referenzaufl√∂sung optimiert ist, sofern dies m√∂glich ist. Zum Zeitpunkt des Schreibens spielen die meisten Spieler auf Monitoren mit einem Seitenverh√§ltnis von 16: 9 und einer Aufl√∂sung von 1920 √ó 1080. Beispielsweise hat die Referenzaufl√∂sung von 320 √ó 180 ein Verh√§ltnis von 16: 9, und daher gibt es bei einer Aufl√∂sung von 1920 √ó 1080 und anderen Aufl√∂sungen, die ein Vielfaches von 320 √ó 180 sind, beispielsweise 1280 √ó 720, keine schwarzen R√§nder an den R√§ndern des Bildschirms.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Unity-Symbolleiste k√∂nnen Sie zu Bearbeiten&gt; Projekteinstellungen&gt; Player gehen und die vom Spiel unterst√ºtzten Seitenverh√§ltnisse begrenzen. Wenn Sie feststellen, dass eine bestimmte Konfiguration in dem von Ihnen ben√∂tigten Verh√§ltnis gut aussieht, aber nicht gut in einzelne Verh√§ltnisse passt, k√∂nnen Sie diese Verh√§ltnisse hier deaktivieren. Beachten Sie jedoch, dass nicht alle Benutzer einen Bildschirm haben, der mit Ihren Einschr√§nkungen gut kompatibel ist. Dies wird daher nicht empfohlen. Verwenden Sie stattdessen das Zuschneiden, damit diese Benutzer schwarze R√§nder anzeigen und das Spiel nicht mit einer Aufl√∂sung startet, die nicht zu ihrem Bildschirm passt.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie versuchen, ein Projekt zu erstellen, das f√ºr eine Retro-Konsole authentisch ist, m√ºssen Sie viele technische Aspekte ber√ºcksichtigen, an die in der modernen Entwicklung niemand denkt. </font><font style="vertical-align: inherit;">Aufgrund der Art der Bildwiedergabe und des geringen Speicherbedarfs √§lterer Maschinen mussten Designer kreativ denken und Hardwareeinschr√§nkungen umgehen. </font><font style="vertical-align: inherit;">In der Neuzeit m√ºssen wir diese Einschr√§nkungen und Techniken kennen, um das Aussehen und Design von Spielen dieser Zeit genau wiederzugeben. </font><font style="vertical-align: inherit;">Im n√§chsten Beitrag werden wir uns mit den Designbeschr√§nkungen der √Ñra der 16-Bit-Spiele sowie dem Unity-Workflow befassen, der erforderlich ist, um den tats√§chlichen Stil des ‚Äûalten Fernsehger√§ts‚Äú wiederherzustellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462843/">https://habr.com/ru/post/de462843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462827/index.html">Leben und Erfolg von Larry Ellison, Gr√ºnder von Oracle</a></li>
<li><a href="../de462831/index.html">Fahren Sie mit der Web 3.0 Wave</a></li>
<li><a href="../de462833/index.html">Das Buch "Predictive Modeling in der Praxis"</a></li>
<li><a href="../de462835/index.html">Unity Auto-Layout und Stile: Unsere neue Pipeline und Tools f√ºr die Benutzeroberfl√§che</a></li>
<li><a href="../de462837/index.html">Black-Box-Test</a></li>
<li><a href="../de462845/index.html">Massage f√ºr Ihr Gehirn: Sprechen Sie √ºber ASMR</a></li>
<li><a href="../de462847/index.html">Hewlett Packard Enterprise-Webinare von August bis Oktober 2019</a></li>
<li><a href="../de462849/index.html">Irgendwas mit Inode</a></li>
<li><a href="../de462851/index.html">Wir bieten einen Cloud-Service f√ºr die Verwaltung von Verbrauchsmaterialien (Angular + Firebase).</a></li>
<li><a href="../de462853/index.html">Aktualisieren von Statistiken zu sekund√§ren Replikaten der Verf√ºgbarkeitsgruppe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>