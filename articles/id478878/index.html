<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõí ‚úçüèª üç∞ Sepotong kode paling populer dalam sejarah StackOverflow memiliki bug! üëâ üß• ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebuah studi baru-baru ini, "Menggunakan dan menghubungkan potongan kode Stack Overflow dalam proyek GitHub," tiba-tiba menemukan bahwa sebagian besar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sepotong kode paling populer dalam sejarah StackOverflow memiliki bug!</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478878/">  Sebuah studi baru-baru ini, <a href="https://doi.org/10.1007/s10664-018-9650-5" rel="nofollow">"Menggunakan dan menghubungkan potongan kode Stack Overflow dalam proyek GitHub,"</a> tiba-tiba menemukan bahwa sebagian besar waktu dalam proyek sumber terbuka, <a href="https://stackoverflow.com/a/3758880/276052" rel="nofollow">jawaban</a> saya ditulis hampir sepuluh tahun yang lalu.  Ironisnya, ada bug. <br><br><h2>  Sekali waktu ... </h2><br>  Kembali pada tahun 2010, saya duduk di kantor saya dan melakukan omong kosong: Saya <a href="https://en.wikipedia.org/wiki/Code_golf" rel="nofollow">menyukai golf kode</a> dan <a href="https://en.wikipedia.org/wiki/Code_golf" rel="nofollow">menambahkan</a> peringkat ke Stack Overflow. <br><br>  Pertanyaan berikut ini menarik perhatian saya: bagaimana cara menampilkan jumlah byte dalam format yang dapat dibaca?  Artinya, bagaimana mengkonversi sesuatu seperti 123456789 byte menjadi "123,5 MB". <br><br> <a href="https://stackoverflow.com/q/3758606/276052" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/7ca/00b/1f7/7ca00b1f7d4f57f0f8afa4ed9554797a.png"></a> <br>  <i><font color="gray">Antarmuka 2010 yang bagus, terima kasih The Wayback Machine</font></i> <br><a name="habracut"></a><br>  Secara implisit, hasilnya adalah angka antara 1 dan 999.9 dengan unit yang sesuai. <br><br>  Sudah ada satu jawaban dengan satu lingkaran.  Idenya sederhana: periksa semua derajat dari unit terbesar (EB = 10 <sup>18</sup> byte) ke terkecil (B = 1 byte) dan terapkan yang pertama, yang kurang dari jumlah byte.  Dalam kode pseudo, tampilannya seperti ini: <br><br><pre><code class="plaintext hljs">suffixes = [ "EB", "PB", "TB", "GB", "MB", "kB", "B" ] magnitudes = [ 10^18, 10^15, 10^12, 10^9, 10^6, 10^3, 10^0 ] i = 0 while (i &lt; magnitudes.length &amp;&amp; magnitudes[i] &gt; byteCount) i++ printf("%.1f %s", byteCount / magnitudes[i], suffixes[i])</code> </pre> <br>  Biasanya, dengan jawaban yang benar dengan peringkat positif, sulit untuk mengejarnya.  Di Stack Overflow, ini disebut <a href="https://meta.stackexchange.com/questions/9731/fastest-gun-in-the-west-problem" rel="nofollow">masalah penembak tercepat di Barat</a> .  Tetapi di sini jawabannya memiliki beberapa kekurangan, jadi saya masih berharap untuk mengatasinya.  Setidaknya kode dengan loop dapat sangat dikurangi. <br><br><h2>  Nah ini aljabar, semuanya sederhana! </h2><br>  Kemudian saya sadar.  Awalannya adalah kilo-, mega-, giga-, ... - tidak lebih dari derajat 1000 (atau 1024 dalam standar IEC), sehingga awalan yang benar dapat ditentukan menggunakan logaritma, dan bukan siklusnya. <br><br>  Berdasarkan ide ini, saya menerbitkan yang berikut: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">humanReadableByteCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> si)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unit = si ? <span class="hljs-number"><span class="hljs-number">1000</span></span> : <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytes &lt; unit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes + <span class="hljs-string"><span class="hljs-string">" B"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exp = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (Math.log(bytes) / Math.log(unit)); String pre = (si ? <span class="hljs-string"><span class="hljs-string">"kMGTPE"</span></span> : <span class="hljs-string"><span class="hljs-string">"KMGTPE"</span></span>).charAt(exp-<span class="hljs-number"><span class="hljs-number">1</span></span>) + (si ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-string"><span class="hljs-string">"i"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String.format(<span class="hljs-string"><span class="hljs-string">"%.1f %sB"</span></span>, bytes / Math.pow(unit, exp), pre); }</code> </pre> <br>  Tentu saja, ini tidak terlalu mudah dibaca, dan log / pow lebih rendah efisiensinya daripada opsi lain.  Tapi tidak ada loop dan hampir tidak ada percabangan, jadi hasilnya cukup indah, menurut saya. <br><br><blockquote>  <b>Matematika itu sederhana</b> .  Jumlah byte dinyatakan sebagai byteCount = 1000 <sup>s</sup> , di mana <i>s</i> mewakili derajat (dalam notasi biner, basisnya adalah 1024.) Solusi <i>s</i> memberikan <i>s</i> = log <sub>1000</sub> (byteCount). <br><br>  Tidak ada log ekspresi sederhana <sub>1000</sub> di API, tetapi kami dapat mengungkapkannya dalam bentuk logaritma natural sebagai berikut s = log (byteCount) / log (1000).  Lalu kami mengonversi <i>s</i> ke int, jadi jika, misalnya, kami memiliki lebih dari satu megabita (tetapi tidak satu gigabita penuh), maka MB akan digunakan sebagai unit pengukuran. <br><br>  Ternyata jika <i>s</i> = 1, maka dimensinya adalah kilobyte, jika <i>s</i> = 2 - megabita dan seterusnya.  Bagilah byteCount dengan 1000 <sup>s</sup> dan tampar huruf yang sesuai ke dalam awalan. </blockquote><br>  Yang tersisa hanyalah menunggu dan melihat bagaimana masyarakat memahami jawabannya.  Saya tidak dapat berpikir bahwa potongan kode ini akan menjadi yang paling banyak beredar dalam sejarah Stack Overflow. <br><br><h2>  Studi Atribusi </h2><br>  Maju cepat ke 2018.  Mahasiswa pascasarjana Sebastian Baltes menerbitkan sebuah artikel di jurnal ilmiah <i>Empirical Software Engineering</i> berjudul <a href="https://doi.org/10.1007/s10664-018-9650-5" rel="nofollow">"Menggunakan dan Mengaitkan Potongan Kode Stack Overflow dalam Proyek GitHub"</a> .  Topik penelitiannya adalah seberapa besar lisensi Stack Overflow CC BY-SA 3.0 dihormati, yaitu, yang penulis tunjukkan ke tautan Stack Overflow sebagai sumber kode. <br><br>  Untuk analisis, potongan kode diekstraksi dari <a href="https://archive.org/details/stackexchange" rel="nofollow">dump Stack Overflow</a> dan dipetakan ke kode di repositori GitHub publik.  Kutipan dari abstrak: <br><br><blockquote>  <i>Kami menyajikan hasil studi empiris skala besar yang menganalisis penggunaan dan atribusi fragmen non-sepele kode Java dari jawaban SO dalam proyek GitHub (GH) publik.</i> </blockquote><br>  (Spoiler: tidak, sebagian besar programmer tidak mematuhi persyaratan lisensi). <br><br>  Artikel memiliki tabel seperti itu: <br><br><img src="https://habrastorage.org/webt/d_/jb/az/d_jbazgu5cmhwyw__yxdxkzdhwy.png"><br><br>  Jawaban di atas dengan pengidentifikasi <a href="https://stackoverflow.com/a/3758880/276052" rel="nofollow">3758880</a> ternyata menjadi jawaban yang saya posting delapan tahun lalu.  Saat ini, ia memiliki lebih dari seratus ribu pandangan dan lebih dari seribu plus. <br><br>  Pencarian cepat di GitHub benar-benar menghasilkan ribuan repositori dengan kode <code>humanReadableByteCount</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/3de/bc6/c4c3debc6c290c209b90c2dca5be46ab.png"><br><br>  Cari fragmen ini di repositori Anda: <br><br><pre> <code class="bash hljs">$ git grep humanReadableByteCount</code> </pre> <br><blockquote>  <b>Sebuah cerita lucu</b> , ketika saya mengetahui tentang penelitian ini. <br><br>  Sebastian menemukan kecocokan dalam repositori OpenJDK tanpa atribusi apa pun, dan lisensi OpenJDK tidak kompatibel dengan CC BY-SA 3.0.  Pada <a href="http://mail.openjdk.java.net/pipermail/jdk9-dev/2016-December/005327.html" rel="nofollow">milis jdk9-dev,</a> ia bertanya: apakah kode Stack Overflow disalin dari OpenJDK atau sebaliknya? <br><br>  Yang lucu adalah saya hanya bekerja di Oracle, dalam proyek OpenJDK, jadi mantan kolega dan teman saya menulis yang berikut ini: <br><br>  <i>Hai</i> <i><br><br></i>  <i>Mengapa tidak bertanya kepada penulis postingan ini langsung di SO (aioobe)?</i>  <i>Dia adalah anggota OpenJDK dan bekerja di Oracle ketika kode ini muncul di repositori sumber OpenJDK.</i> <br><br>  Oracle menangani masalah ini dengan sangat serius.  Saya tahu bahwa beberapa manajer merasa lega ketika mereka membaca jawaban ini dan menemukan "pelakunya". <br><br>  Lalu Sebastian menulis kepada saya untuk mengklarifikasi situasi, yang saya lakukan: kode ini ditambahkan <i>sebelum</i> saya bergabung dengan Oracle dan saya tidak ada hubungannya dengan komit.  Lebih baik tidak bercanda dengan Oracle.  Beberapa hari setelah <a href="https://bugs.openjdk.java.net/browse/JDK-8170860" rel="nofollow">tiket dibuka,</a> kode <a href="http://hg.openjdk.java.net/jdk9/jdk9/hotspot/rev/b552b596203f" rel="nofollow">ini dihapus</a> . </blockquote><br><h2>  Bug </h2><br>  Saya yakin Anda sudah memikirkan hal itu.  Apa jenis kesalahan dalam kode? <br><br>  Sekali lagi: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">humanReadableByteCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> si)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unit = si ? <span class="hljs-number"><span class="hljs-number">1000</span></span> : <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytes &lt; unit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes + <span class="hljs-string"><span class="hljs-string">" B"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exp = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (Math.log(bytes) / Math.log(unit)); String pre = (si ? <span class="hljs-string"><span class="hljs-string">"kMGTPE"</span></span> : <span class="hljs-string"><span class="hljs-string">"KMGTPE"</span></span>).charAt(exp-<span class="hljs-number"><span class="hljs-number">1</span></span>) + (si ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-string"><span class="hljs-string">"i"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String.format(<span class="hljs-string"><span class="hljs-string">"%.1f %sB"</span></span>, bytes / Math.pow(unit, exp), pre); }</code> </pre> <br>  Apa saja pilihannya? <br><br>  Setelah exabytes (10 <sup>18</sup> ) adalah zettabytes (10 <sup>21</sup> ).  Mungkin jumlah yang sangat besar akan melampaui kMGTPE?  Tidak.  Nilai maksimum adalah 2 <sup>63</sup> -1 ‚âà 9,2 √ó 10 <sup>18</sup> , jadi tidak ada nilai yang akan melampaui exabytes. <br><br>  Mungkin kebingungan antara unit SI dan sistem biner?  Tidak.  Ada kebingungan dalam versi pertama jawaban, tetapi itu diperbaiki cukup cepat. <br><br>  Mungkin exp berakhir dengan zeroing, menyebabkan charAt (exp-1) macet?  Tidak juga.  Pernyataan if pertama mencakup kasus ini.  Nilai exp akan selalu minimal 1. <br><br>  Mungkin beberapa kesalahan pembulatan yang aneh dalam ekstradisi?  Yah, akhirnya ... <br><br><h2>  Banyak sembilan </h2><br>  Solusinya bekerja sampai mendekati 1 MB.  Ketika <code>"1000,0 kB"</code> byte ditentukan sebagai input, hasilnya (dalam mode SI) adalah <code>"1000,0 kB"</code> .  Meskipun 999.999 lebih dekat ke 1000 √ó 1000 <sup>1</sup> daripada ke 999.9 √ó 1000 <sup>1</sup> , 1000 penanda dilarang oleh spesifikasi.  Hasil yang benar adalah <code>"1.0 MB"</code> . <br><br>  Dalam pembelaan saya, saya dapat mengatakan bahwa pada saat penulisan, kesalahan semacam itu ada di semua 22 jawaban yang dipublikasikan, termasuk Apache Commons dan perpustakaan Android. <br><br>  Bagaimana cara memperbaikinya?  Pertama-tama, kami mencatat bahwa eksponen (exp) harus berubah dari 'k' ke 'M' segera setelah jumlah byte lebih dekat ke 1 √ó 1.000 <sup>2</sup> (1 MB) daripada ke 999.9 √ó 1000 <sup>1</sup> (999.9 k )  Ini terjadi pada 999.950. Demikian juga, kita harus beralih dari 'M' ke 'G' ketika kita melewati 999.950.000 dan seterusnya. <br><br>  Kami menghitung ambang ini dan meningkatkan <code>exp</code> jika <code>bytes</code> lebih besar: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytes &gt;= Math.pow(unit, exp) * (unit - <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) exp++;</code> </pre> <br>  Dengan perubahan ini, kode berfungsi dengan baik hingga jumlah byte mendekati 1 EB. <br><br><h2>  Lebih banyak Nines </h2><br>  Saat menghitung 999 949 999 999 999 999 999, kodenya memberikan <code>1000.0 PB</code> , dan hasil yang benar adalah <code>999.9 PB</code> .  Secara matematis, kodenya akurat, jadi apa yang terjadi di sini? <br><br>  Sekarang kita dihadapkan pada kendala <code>double</code> . <br><br><blockquote><h4>  Pengantar aritmatika floating point </h4><br>  Menurut spesifikasi IEEE 754, nilai floating point mendekati nol memiliki representasi yang sangat padat, sedangkan nilai besar memiliki representasi yang sangat jarang.  Bahkan, setengah dari semua nilai adalah antara -1 dan 1, dan ketika datang ke angka besar, nilai ukuran <code>Long.MAX_VALUE</code> tidak berarti apa-apa.  Dalam arti harfiah. <br><br><pre> <code class="plaintext hljs">double l1 = Double.MAX_VALUE; double l2 = l1 - Long.MAX_VALUE; System.err.println(l1 == l2); // prints true</code> </pre> <br>  Lihat <a href="https://programming.guide/bits-of-a-floating-point-value.html" rel="nofollow">"Bit Poin Mengambang" untuk</a> detailnya. </blockquote><br>  Masalahnya diwakili oleh dua perhitungan: <br><br><ul><li>  Divisi dalam <code>String.format</code> dan <br></li><li>  Ambang ekspansi <code>exp</code> </li></ul><br>  Kita bisa beralih ke <code>BigDecimal</code> , tapi itu membosankan.  Selain itu, masalah juga muncul di sini, karena API standar tidak memiliki logaritma untuk <code>BigDecimal</code> . <br><br><h4>  Mengurangi nilai antara </h4><br>  Untuk mengatasi masalah pertama, kita dapat mengurangi nilai <code>bytes</code> ke rentang yang diinginkan, di mana akurasi lebih baik, dan menyesuaikan <code>exp</code> .  Bagaimanapun, hasil akhir dibulatkan, jadi tidak masalah bahwa kita membuang angka yang paling tidak signifikan. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { bytes /= unit; exp--; }</code> </pre> <br><h4>  Pengaturan bit paling tidak signifikan </h4><br>  Untuk menyelesaikan masalah kedua <i>,</i> bit paling <i>tidak penting penting bagi</i> kami (99994999 ... 9 dan 99995000 ... 0 harus memiliki derajat yang berbeda), jadi kami harus menemukan solusi yang berbeda. <br><br>  Pertama, perhatikan bahwa ada 12 nilai ambang yang berbeda (6 untuk setiap mode), dan hanya satu yang mengarah ke kesalahan.  Hasil yang salah dapat diidentifikasi secara unik karena berakhir pada D00 <sub>16</sub> .  Jadi Anda bisa memperbaikinya secara langsung. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> th = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (Math.pow(unit, exp) * (unit - <span class="hljs-number"><span class="hljs-number">0.05</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp &lt; <span class="hljs-number"><span class="hljs-number">6</span></span> &amp;&amp; bytes &gt;= th - ((th &amp; <span class="hljs-number"><span class="hljs-number">0xFFF</span></span>) == <span class="hljs-number"><span class="hljs-number">0xD00</span></span> ? <span class="hljs-number"><span class="hljs-number">52</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>)) exp++;</code> </pre> <br>  Karena kami bergantung pada pola bit tertentu dalam hasil floating point, kami menggunakan pengubah ff ketat untuk memastikan bahwa kode bekerja secara independen dari perangkat keras. <br><br><h2>  Nilai input negatif </h2><br>  Tidak jelas dalam keadaan apa sejumlah byte negatif mungkin masuk akal, tetapi karena Java tidak memiliki <code>long</code> tidak ditandatangani, yang terbaik adalah menangani opsi ini.  Saat ini, input seperti <code>-10000 B</code> menghasilkan <code>-10000 B</code> <br><br>  Mari kita menulis <code>absBytes</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> absBytes = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);</code> </pre> <br>  Ekspresi ini sangat verbose karena <code>-Long.MIN_VALUE == Long.MIN_VALUE</code> .  Sekarang kita melakukan semua perhitungan <code>exp</code> menggunakan <code>absBytes</code> bukan <code>bytes</code> . <br><br><h2>  Versi final </h2><br>  Ini adalah versi terakhir dari kode, disingkat dan diringkas dalam semangat versi aslinya: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// From: https://programming.guide/the-worlds-most-copied-so-snippet.html public static strictfp String humanReadableByteCount(long bytes, boolean si) { int unit = si ? 1000 : 1024; long absBytes = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes); if (absBytes &lt; unit) return bytes + " B"; int exp = (int) (Math.log(absBytes) / Math.log(unit)); long th = (long) (Math.pow(unit, exp) * (unit - 0.05)); if (exp &lt; 6 &amp;&amp; absBytes &gt;= th - ((th &amp; 0xfff) == 0xd00 ? 52 : 0)) exp++; String pre = (si ? "kMGTPE" : "KMGTPE").charAt(exp - 1) + (si ? "" : "i"); if (exp &gt; 4) { bytes /= unit; exp -= 1; } return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre); }</span></span></code> </pre> <br>  Perhatikan bahwa ini dimulai sebagai upaya untuk menghindari loop dan percabangan yang berlebihan.  Tetapi setelah menghaluskan semua situasi perbatasan, kode tersebut menjadi lebih mudah dibaca daripada versi aslinya.  Secara pribadi, saya tidak akan menyalin fragmen ini dalam produksi. <br><br>  Untuk versi terbaru dari kualitas produksi, lihat artikel terpisah: <a href="https://programming.guide/java/formatting-byte-size-to-human-readable-format.html" rel="nofollow">"Memformat ukuran byte dalam format yang dapat dibaca</a> . <a href="https://programming.guide/java/formatting-byte-size-to-human-readable-format.html" rel="nofollow">"</a> <br><br><h2>  Temuan Kunci </h2><br><ul><li>  Mungkin ada kesalahan dalam jawaban untuk Stack Overflow, bahkan jika mereka memiliki ribuan nilai tambah. <br></li><li>  Periksa semua kasus batas, <i>terutama</i> dalam kode dengan Stack Overflow. <br></li><li>  Aritmatika titik mengambang rumit. <br></li><li>  Pastikan untuk menyertakan atribusi yang benar saat menyalin kode.  Seseorang mungkin membawa Anda ke air bersih. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478878/">https://habr.com/ru/post/id478878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478856/index.html">SD-WAN - tren dan perkiraan terkini untuk tahun 2020</a></li>
<li><a href="../id478858/index.html">Membandingkan Sesi Pembuatan Profil di Admin XHProf</a></li>
<li><a href="../id478862/index.html">Bagaimana pengujian frontend diatur di Yandex.Market dan mengapa kami menolak rilis mingguan</a></li>
<li><a href="../id478866/index.html">Meet Space - Produk Baru dari JetBrains</a></li>
<li><a href="../id478872/index.html">DIY: cara kami mengotomatiskan pemantauan gudang</a></li>
<li><a href="../id478884/index.html">Cara menyiapkan RTSP di situs pada tahun 2020, atau mengapa babi hutan tidak punya waktu untuk melarikan diri</a></li>
<li><a href="../id478886/index.html">Komponen Sudut dengan Konten Inline</a></li>
<li><a href="../id478888/index.html">Beberapa pemikiran tentang modular css dan masalah dukungan kode</a></li>
<li><a href="../id478890/index.html">Di mana paket saya? AI akan memfasilitasi tugas pengiriman</a></li>
<li><a href="../id478892/index.html">Menjadi sukarelawan sebagai cara hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>