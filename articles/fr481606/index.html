<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 👨🏻‍🎨 👨🏾‍🤝‍👨🏻 Abonnement statique à l'aide du modèle Observer à l'aide de C ++ et du microcontrôleur Cortex M4 🔖 🔁 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne santé à tous! 


 À la veille de la nouvelle année, je veux continuer à parler de l'utilisation de C ++ sur les microcontrôleurs, cette fois, je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abonnement statique à l'aide du modèle Observer à l'aide de C ++ et du microcontrôleur Cortex M4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481606/"><p><img src="https://habrastorage.org/webt/kq/jo/qx/kqjoqxpr1itcdx-_kq4luowkpqe.jpeg"></p><br><p>  Bonne santé à tous! </p><br><p>  À la veille de la nouvelle année, je veux continuer à parler de l'utilisation de C ++ sur les microcontrôleurs, cette fois, je vais essayer de parler de l'utilisation du modèle Observer (mais ci-après je l'appellerai Publisher-Subscriber ou juste un abonné, un jeu de mots), ainsi que la mise en œuvre d'un abonnement statique à C ++ 17 et les avantages de cette approche dans certaines applications. </p><a name="habracut"></a><br><h2 id="vvedenie">  Présentation </h2><br><p> Template Subscriber est l'un des modèles les plus courants utilisés dans le développement de logiciels.  Avec lui, par exemple, ils font le traitement des clics sur les boutons dans Windows Form.  Quoi qu'il en soit, à n'importe quel endroit où vous devez en quelque sorte répondre aux changements des paramètres du système, que ce soit des changements dans les fichiers ou la mise à jour de la valeur mesurée du capteur, il est temps <del>  sans réfléchir </del>  utilisez le modèle Abonné. </p><br><p>  L'avantage du modèle est que nous libérons la connaissance de l'éditeur et de l'abonné sans être lié à des objets spécifiques.  Nous pouvons signer n'importe qui à n'importe qui, sans affecter la mise en œuvre des objets Publisher et Subscriber. </p><br><h2 id="nachalnye-usloviya">  Conditions initiales </h2><br><p>  Avant de nous familiariser avec le modèle, convenons d'abord que nous voulons développer un logiciel fiable dans lequel: </p><br><ul><li>  n'utilisez pas d'allocation de mémoire dynamique </li><li>  minimiser le travail avec des pointeurs </li><li>  nous utilisons autant de constantes que possible pour que personne ne change autant que possible </li><li>  mais en même temps, nous utilisons aussi peu de constantes que possible situées dans la RAM </li></ul><br><p>  Voyons maintenant l'implémentation standard du modèle Subscriber. </p><br><h2 id="standartnaya-realizaciya">  Implémentation standard </h2><br><p>  Supposons que nous ayons un bouton, et lorsque vous cliquez sur le bouton, nous devons clignoter les LED, mais combien d'entre elles seront inconnues jusqu'à présent, et en effet, vous devrez peut-être clignoter non pas avec des LED, mais avec un projecteur sur le navire pour transmettre des messages en code Morse.  Il est important que nous ne sachions pas qui sera abonné.  Malheureusement, je n'ai pas de projecteur sous la main, donc tous les exemples de l'article dans un souci de simplicité et une meilleure compréhension sont faits avec des LED. </p><br><p>  Ainsi, lorsque vous appuyez sur le bouton, vous devez informer la LED de cette pression.  À son tour, après avoir appris à appuyer sur la LED devrait passer à l'état opposé. <br>  L'implémentation standard en UML est la suivante ... </p><br><p><img src="https://habrastorage.org/webt/zu/8g/ro/zu8gro30gxgngc8w36oesxy9w2i.png"></p><br><p> Ici, la classe <code>ButtonController</code> est chargée d'interroger le bouton et d'informer les abonnés du clic, et <code>Led</code> dans ce cas est l'abonné.  Ces deux classes sont découplées via les <code>ISubsriber</code> <code>IPublisher</code> et <code>ISubsriber</code> et aucune des classes ne connaît l'autre.  Ainsi, tout objet héritant de l'interface <code>ISubscriber</code> peut s'abonner à un événement de <code>ButtonController</code> . </p><br><p>  Étant donné que l'allocation dynamique de mémoire est interdite, j'ai déclaré un tableau de 3 éléments pour l'abonnement.  C'est-à-dire  maximum peut être de 3 abonnés.  Ainsi, dans une première approximation, la méthode de notification des abonnés de la classe <code>ButttonsController</code> peut sembler </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          HandleEvent() for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } } ;</span></span></code> </pre> <br><p>  Tout le sel se trouve dans la méthode <code>Notify()</code> de la classe <code>Publisher</code> .  Dans cette méthode, nous passons en revue la liste des abonnés et appelons <code>HandleEvent()</code> sur chacun d'entre eux, et c'est cool, car chaque abonné implémente cette méthode à sa manière et peut y faire <del>  tout </del>  tout ce que votre cœur désire (en fait, vous devez être prudent, sinon le diable sait ce que l'abonné y fait, vous pouvez appeler sa méthode, par exemple, à partir d'une interruption et vous devez être vigilant pour empêcher les abonnés de faire des choses longues et mauvaises) </p><br><p>  Dans notre cas, la LED est autorisée à faire n'importe quoi, elle fait donc la commutation de son état: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Led</span></span></span><span class="hljs-class">:</span></span> ISubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Port::ODR::Toggle(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  Toggle() ; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Implémentation complète de toutes les classes</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ISubscriber { virtual void HandleEvent() = 0; } ; struct IPublisher { virtual void Notify() const = 0; virtual void Subscribe(ISubscriber* subscriber) = 0; } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { static void Toggle() { Port::ODR::Toggle(1 &lt;&lt; pinNum); } void HandleEvent() override { Toggle() ; } }; struct ButtonController : IPublisher { void Run() { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } void Subscribe(ISubscriber* subscriber) override { if (index &lt; pSubscribers.size()) { pSubscribers[index] = subscriber ; index ++ ; } //   3   ...   } private: std::array&lt;ISubscriber*, 3&gt; pSubscribers ; std::size_t index = 0U ; } ;</span></span></code> </pre></div></div><br><p>  Comment un abonnement peut-il apparaître dans le code?  Et donc: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; ButtonController buttonController ; //  3  buttonController.Subscribe(&amp;Led1) ; buttonController.Subscribe(&amp;Led2) ; buttonController.Subscribe(&amp;Led3) ; //       buttonController.Run() ; }</span></span></code> </pre> <br><p>  La bonne nouvelle est que nous pouvons signer n'importe quel objet et le moment de sa création n'a pas d'importance pour nous.  Il peut s'agir d'un objet global, statique ou local.  D'une part, c'est bien, mais d'autre part, pourquoi devons-nous nous abonner à l'exécution dans ce code.  En effet, en effet, ici l'adresse des objets <code>Led1</code> , <code>Led2</code> , <code>Led3</code> est connue au stade de la compilation.  Alors, pourquoi ne pouvez-vous pas vous abonner au stade de la compilation et conserver un ensemble de pointeurs vers les abonnés en ROM? </p><br><p>  De plus, il existe un risque d'erreurs potentielles, par exemple, combien se sont demandé ce qui se passerait lors de l'appel de la méthode <code>Subsribe()</code> si elle était appelée à partir de plusieurs threads?  Nous sommes limités à seulement 3 abonnés, et que se passe-t-il si nous signons 4 LED? </p><br><p>  Dans la plupart des cas, nous avons besoin de cet abonnement une fois dans la vie lors de l'initialisation, nous enregistrons simplement des pointeurs vers les abonnés et c'est tout.  Le pointeur conservera à vie l'adresse de ces abonnés.  Et le jour est inévitable quand il peut être ruiné <del>  en raison de l'épidémie de supernova </del>  (bien sûr, si l'on considère une période de temps assez longue).  Mais dans tous les cas, la probabilité de défaillance de la RAM est beaucoup plus élevée que la ROM et il n'est pas recommandé de stocker des données permanentes dans la RAM. </p><br><p>  Eh bien, la mauvaise nouvelle est qu'une telle solution architecturale prend beaucoup d'espace dans la ROM et la RAM.  Au cas où, nous écrivons combien de ROM et de RAM cette solution prend: </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  données rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  488 </td><td>  64 </td><td>  21 </td></tr></tbody></table></div><br><p>  C'est-à-dire  au total 552 octets en ROM et 21 octets en RAM - disons pas tellement pour appuyer sur un bouton et faire clignoter trois LED. </p><br><p>  Eh bien, afin de vous protéger de tels problèmes et de réduire la consommation de ressources du contrôleur, considérons l'option avec un abonnement statique. </p><br><h2 id="staticheskaya-podpiska">  Abonnement statique </h2><br><p>  Afin de rendre l'abonnement statique, vous pouvez utiliser plusieurs approches.  Je vais les nommer comme ceci: </p><br><ul><li>  La méthode traditionnelle est la même approche, mais en utilisant le constructeur constexpr et en définissant la liste des abonnés à travers elle. </li><li><del>  Non conventionnel </del>  Utilisation de modèles - transférez la liste des abonnés via les paramètres du modèle.  (ici, un modèle est une définition du domaine de la métaprogrammation, pas des modèles de conception) </li></ul><br><h3 id="tradicionnyy-podhod-k-staticheskoy-podpiske">  L'approche traditionnelle de l'abonnement statique </h3><br><p>  Essayons de nous abonner au stade de la compilation.  Pour ce faire, nous peaufinons un peu notre architecture: </p><br><p><img src="https://habrastorage.org/webt/lr/_k/gy/lr_kgyobfgkebxpz9gfyqiod34u.png"></p><br><p>  L'image n'est pas très différente de l'original, mais il existe plusieurs différences: la méthode <code>Subscribe()</code> a été supprimée et maintenant l'abonnement sera effectué directement dans le constructeur.  Le constructeur doit accepter un nombre variable d'arguments, et pour pouvoir signer statiquement au stade de la compilation, ce sera <code>constexpr</code> .  Un tableau d'abonnés y sera initialisé et cette initialisation peut se faire au moment de la compilation: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*... args)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;ISubscriber <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt; result = {args...} ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; size) { pSubscribers[index] = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;ISubscriber*&gt;(it); } index ++ ; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-number"><span class="hljs-number">3U</span></span>; ISubscriber* pSubscribers[size] ; } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Code complet pour une telle implémentation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPublisher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { constexpr Led() { } static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const override { Toggle() ; } }; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ButtonController : IPublisher { template&lt;typename... Args&gt; constexpr ButtonController(Args const*... args): pSubscribers() { std::initializer_list&lt;ISubscriber const*&gt; result = {args...} ; std::size_t index = 0U; for(auto it: result) { if (index &lt; size) { pSubscribers[index] = const_cast&lt;ISubscriber*&gt;(it); } index ++ ; } } void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } private: static constexpr std::size_t size = 3U; ISubscriber* pSubscribers[size] ; } ;</span></span></code> </pre></div></div><br><p>  Désormais, l'abonnement peut être effectué au moment de la compilation: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController buttonController(&amp;Led1, &amp;Led2, &amp;Led3) ; buttonController.Run() ; return 0 ; } ;</span></span></code> </pre> <br><p>  Ici, l'objet <code>buttonController</code> complètement situé dans la ROM avec un tableau de pointeurs vers les abonnés: </p><br><blockquote>  main :: buttonController 0x800'1f04 0x10 Données main.o [1] </blockquote><p>  Tout ne semble rien, sauf que nous sommes à nouveau limités à seulement 3 abonnés.  Et la classe d'éditeur doit avoir un constructeur constexpr et en général être complètement constante afin de garantir un pointeur vers les abonnés dans la ROM, sinon, même avec des adresses d'abonnés connues, notre objet, avec tout le contenu, ira à nouveau en RAM. </p><br><p>  Parmi les autres inconvénients - puisque les fonctions virtuelles sont toujours utilisées, les tables de fonctions virtuelles peu à peu notre ROM.  Et la ressource est, bien que abordable, mais pas infinie.  Dans la plupart des applications, il est possible de marteler dessus et de prendre un microcontrôleur plus grand, mais il arrive souvent que chaque octet compte, en particulier lorsqu'il s'agit de produits fabriqués par centaines de milliers, tels que des capteurs physiques physiques. </p><br><p>  Voyons comment les choses se passent avec la mémoire dans cette solution: </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  données rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  172 </td><td>  76 </td><td>  0 </td></tr></tbody></table></div><br><p>  Et bien que le résultat soit «étonnant»: la consommation totale de RAM est de 0 octet, et la ROM est de 248 octets, ce qui est deux fois moins que dans la première solution, il estime qu'il existe encore un potentiel d'amélioration.  Sur ces 248 octets, environ 50 occupent simplement les tables de méthodes virtuelles. </p><br><p>  <u>Une petite digression:</u> <br>  Une étape dans la taille de la ROM de 256 ko pour les microcontrôleurs modernes est la norme (par exemple, le microcontrôleur TI Cortex M4 a 256 ko de ROM, et la prochaine version est déjà 512 ko).  Et ce ne sera pas très bien quand, en raison de 50 octets supplémentaires, nous devons prendre un contrôleur avec une ROM de 256 Ko plus grande et plus chère, par conséquent, l'abandon des fonctions virtuelles peut économiser ... jusqu'à 50 cents (la différence entre le microcontrôleur dans la ROM de 256 et 512 Ko est d'environ 50-60 cents). </p><br><p>  Cela semble ridicule pour 1 microcontrôleur, mais sur un lot de 400 000 appareils par an, vous pouvez économiser 200 000 $.  Déjà pas si drôle, mais vu quel genre de rat.  ils peuvent récompenser l'offre avec un diplôme et une carte-cadeau pour 3000 roubles, il n'y a absolument aucun doute sur la justesse de refuser les fonctions virtuelles et d'économiser 50 octets supplémentaires en ROM. </p><br><h3 id="netradicionnyy-podhod">  Approche non conventionnelle </h3><br><p>  Voyons comment vous pouvez faire de même sans fonctions virtuelles et économisez encore plus de ROM. </p><br><p>  Voyons d'abord comment cela pourrait être: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; //   ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Notre tâche consiste à découpler les deux objets Publisher ( <code>ButtonController</code> ) et Subscriber ( <code>Led</code> ) l'un de l'autre afin qu'ils ne se connaissent pas, mais en même temps <code>ButtonController</code> pourrait avertir <code>Led</code> . </p><br><p>  Vous pouvez déclarer la classe <code>ButtonController</code> une manière ou d'une autre. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;&amp; subscriber1, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&amp; subscriber2, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;&amp; subscriber3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ subscriber1.HandleEvent() ; subscriber2.HandleEvent() ; subscriber3.HandleEvent() ; } ... } ;</code> </pre> <br><p>  Mais vous comprenez, ici nous sommes attachés à des types spécifiques et nous devrons refaire la définition de la classe <code>BbuttonController</code> chaque fois dans un nouveau projet.  Et je voudrais simplement prendre et utiliser <code>ButtonController</code> dans le nouveau projet sans <code>ButtonController</code> . </p><br><p>  C ++ 17 vient à la rescousse, où vous ne pouvez pas spécifier le type, mais demandez au compilateur de déduire le type pour vous - c'est exactement ce dont vous avez besoin.  On peut, tout comme dans l'approche traditionnelle, libérer la connaissance de l'Editeur et de l'Abonné, alors que le nombre d'abonnés est pratiquement illimité. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; } ... } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Fonctionnement de la fonction pass (..)</b> <div class="spoiler_text"><p>  La méthode <code>Notify()</code> a un appel à la fonction <code>pass()</code> ; elle est utilisée pour développer les paramètres du modèle avec un nombre variable d'arguments </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; }</code> </pre> <br><p>  L'implémentation de la fonction <code>pass()</code> est tout simplement inimaginable, c'est juste une fonction qui prend un nombre variable d'arguments: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Comment la fonction <code>HandleEvent()</code> développe-t-elle en plusieurs appels pour chacun des abonnés? </p><br><p>  Puisque la fonction <code>pass()</code> accepte plusieurs arguments de n'importe quel type, vous pouvez lui passer plusieurs arguments de type <code>bool</code> , par exemple, vous pouvez appeler la fonction <code>pass(true, true, true)</code> .  Dans ce cas, bien sûr, rien ne se passera, mais nous n'en avons pas besoin. </p><br><p>  La ligne <code>(subscribers.HandleEvent() , true)</code> utilise l'opérateur "," (virgule), qui exécute les deux opérandes (de gauche à droite) et renvoie la valeur du deuxième opérateur, c'est-à-dire ici <code>subscribers.HandleEvent()</code> sera exécuté en premier, puis <code>true</code> à la fonction <code>pass()</code> sera défini sur <code>true</code> . </p><br><p>  Eh bien, "..." est une entrée standard pour développer un nombre variable d'arguments.  Pour notre cas, les actions du compilateur peuvent être décrites très schématiquement comme suit: </p><br><pre> <code class="cpp hljs">pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; -&gt; pass((Led1.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led1.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led2.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led3.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ;</code> </pre> </div></div><br><p>  Au lieu de liens, vous pouvez utiliser des pointeurs: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> ... } ;</code> </pre> <br><p>  <strong>Addition:</strong> En fait, merci à <a href="https://habr.com/ru/users/vamireh/" class="user_link">vamireh</a> qui a <a href="https://habr.com/ru/post/481606/">souligné</a> que toutes ces danses sont avec <del>  tambourin </del>  <code>pass</code> fonction <code>pass</code> en C ++ 17 n'est pas nécessaire.  Étant donné que l'opérateur "," la virgule est prise en charge dans l'expression fold (qui a été introduite dans la norme C ++ 17), le code est encore simplifié: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ((subscribers.HandleEvent()), ...) ; } } ;</code> </pre> <br><p>  Sur le plan architectural, cela semble très simple en général: </p><br><p><img src="https://habrastorage.org/webt/hx/di/jj/hxdijj1xdfvncxtdsr04a1qp_ve.png"></p><br><p>  J'ai ajouté une autre classe LCD ici, mais purement par exemple, pour montrer que maintenant peu importe le type et le nombre d'abonnés, l'essentiel est qu'il implémente la méthode <code>HandleEvent()</code> . </p><br><p>  Et tout le code en général est également plus facile maintenant: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led { static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const { Toggle() ; } }; template &lt;auto&amp; ... subscribers&gt; struct ButtonController { void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const { ((subscribers.HandleEvent()), ...) ; } } ; int main() { //  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  L'appel <code>Notify()</code> de la méthode <code>Run()</code> dégénère en un simple appel séquentiel </p><br><pre> <code class="cpp hljs">Led1.HandleEvent() ; Led2.HandleEvent() ; Led3.HandleEvent() ;</code> </pre> <br><p>  Et la mémoire ici? </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  données rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  186 </td><td>  4 </td><td>  0 </td></tr></tbody></table></div><br><p>  ROM total 190 octets et 0 octets de RAM.  Maintenant la commande, elle est presque 3 fois plus petite que la version standard, alors qu'elle effectue exactement la même chose. </p><br><p>  Ainsi, si vous avez les adresses des abonnés connues à l'avance dans la candidature et que vous suivez les conditions définies au début de l'article </p><br><div class="spoiler">  <b class="spoiler_title">Conditions au début de l'article</b> <div class="spoiler_text"><ul><li>  n'utilisez pas d'allocation de mémoire dynamique </li><li>  minimiser le travail avec des pointeurs </li><li>  nous utilisons autant de constantes que possible pour que personne ne change autant que possible </li><li>  mais en même temps, nous utilisons aussi peu de constantes que possible situées dans la RAM </li></ul></div></div><br><p>  En toute confiance, vous pouvez utiliser une telle implémentation du modèle Publisher-Subscriber pour réduire les lignes de code et économiser des ressources, et là vous regardez et vous pouvez réclamer non seulement une carte-cadeau, mais aussi un bonus basé sur les résultats de l'année. </p><br><p>  L' <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">exemple de</a> test <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">sous IAR 8.40.2 se trouve ici</a> </p><br><p>  Tout à venir!  Et bonne chance pour la nouvelle année! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481606/">https://habr.com/ru/post/fr481606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481594/index.html">Développement d'un «générateur de tension simple» selon GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../fr481596/index.html">Analyse des paramètres ELK 7.5 pour l'analyse des journaux Mikrotik</a></li>
<li><a href="../fr481598/index.html">Une petite contribution à la lutte contre les plateformes de zoo Avalonia UI</a></li>
<li><a href="../fr481600/index.html">Moteur Wiki Bonsai Family: Résultats 2019</a></li>
<li><a href="../fr481604/index.html">Comment les développeurs de Chelyabinsk durs créent des jeux pour Google Play et les réseaux sociaux</a></li>
<li><a href="../fr481610/index.html">PostgreSQL Antipatterns: mise à jour d'une grande table en charge</a></li>
<li><a href="../fr481612/index.html">Notre petite contribution à la lutte d'Avalonia UI pour moins de plateformes</a></li>
<li><a href="../fr481616/index.html">Dôme géodésique. À propos de l'appareil et mon expérience des calculs</a></li>
<li><a href="../fr481618/index.html">MVP dans Unity ou comment simplifier la vie</a></li>
<li><a href="../fr481620/index.html">Juniper SRX et Cisco ASA: nouvelle série</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>