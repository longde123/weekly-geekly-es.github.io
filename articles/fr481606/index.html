<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêô üë®üèª‚Äçüé® üë®üèæ‚Äçü§ù‚Äçüë®üèª Abonnement statique √† l'aide du mod√®le Observer √† l'aide de C ++ et du microcontr√¥leur Cortex M4 üîñ üîÅ üèÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne sant√© √† tous! 


 √Ä la veille de la nouvelle ann√©e, je veux continuer √† parler de l'utilisation de C ++ sur les microcontr√¥leurs, cette fois, je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abonnement statique √† l'aide du mod√®le Observer √† l'aide de C ++ et du microcontr√¥leur Cortex M4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481606/"><p><img src="https://habrastorage.org/webt/kq/jo/qx/kqjoqxpr1itcdx-_kq4luowkpqe.jpeg"></p><br><p>  Bonne sant√© √† tous! </p><br><p>  √Ä la veille de la nouvelle ann√©e, je veux continuer √† parler de l'utilisation de C ++ sur les microcontr√¥leurs, cette fois, je vais essayer de parler de l'utilisation du mod√®le Observer (mais ci-apr√®s je l'appellerai Publisher-Subscriber ou juste un abonn√©, un jeu de mots), ainsi que la mise en ≈ìuvre d'un abonnement statique √† C ++ 17 et les avantages de cette approche dans certaines applications. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p> Template Subscriber est l'un des mod√®les les plus courants utilis√©s dans le d√©veloppement de logiciels.  Avec lui, par exemple, ils font le traitement des clics sur les boutons dans Windows Form.  Quoi qu'il en soit, √† n'importe quel endroit o√π vous devez en quelque sorte r√©pondre aux changements des param√®tres du syst√®me, que ce soit des changements dans les fichiers ou la mise √† jour de la valeur mesur√©e du capteur, il est temps <del>  sans r√©fl√©chir </del>  utilisez le mod√®le Abonn√©. </p><br><p>  L'avantage du mod√®le est que nous lib√©rons la connaissance de l'√©diteur et de l'abonn√© sans √™tre li√© √† des objets sp√©cifiques.  Nous pouvons signer n'importe qui √† n'importe qui, sans affecter la mise en ≈ìuvre des objets Publisher et Subscriber. </p><br><h2 id="nachalnye-usloviya">  Conditions initiales </h2><br><p>  Avant de nous familiariser avec le mod√®le, convenons d'abord que nous voulons d√©velopper un logiciel fiable dans lequel: </p><br><ul><li>  n'utilisez pas d'allocation de m√©moire dynamique </li><li>  minimiser le travail avec des pointeurs </li><li>  nous utilisons autant de constantes que possible pour que personne ne change autant que possible </li><li>  mais en m√™me temps, nous utilisons aussi peu de constantes que possible situ√©es dans la RAM </li></ul><br><p>  Voyons maintenant l'impl√©mentation standard du mod√®le Subscriber. </p><br><h2 id="standartnaya-realizaciya">  Impl√©mentation standard </h2><br><p>  Supposons que nous ayons un bouton, et lorsque vous cliquez sur le bouton, nous devons clignoter les LED, mais combien d'entre elles seront inconnues jusqu'√† pr√©sent, et en effet, vous devrez peut-√™tre clignoter non pas avec des LED, mais avec un projecteur sur le navire pour transmettre des messages en code Morse.  Il est important que nous ne sachions pas qui sera abonn√©.  Malheureusement, je n'ai pas de projecteur sous la main, donc tous les exemples de l'article dans un souci de simplicit√© et une meilleure compr√©hension sont faits avec des LED. </p><br><p>  Ainsi, lorsque vous appuyez sur le bouton, vous devez informer la LED de cette pression.  √Ä son tour, apr√®s avoir appris √† appuyer sur la LED devrait passer √† l'√©tat oppos√©. <br>  L'impl√©mentation standard en UML est la suivante ... </p><br><p><img src="https://habrastorage.org/webt/zu/8g/ro/zu8gro30gxgngc8w36oesxy9w2i.png"></p><br><p> Ici, la classe <code>ButtonController</code> est charg√©e d'interroger le bouton et d'informer les abonn√©s du clic, et <code>Led</code> dans ce cas est l'abonn√©.  Ces deux classes sont d√©coupl√©es via les <code>ISubsriber</code> <code>IPublisher</code> et <code>ISubsriber</code> et aucune des classes ne conna√Æt l'autre.  Ainsi, tout objet h√©ritant de l'interface <code>ISubscriber</code> peut s'abonner √† un √©v√©nement de <code>ButtonController</code> . </p><br><p>  √âtant donn√© que l'allocation dynamique de m√©moire est interdite, j'ai d√©clar√© un tableau de 3 √©l√©ments pour l'abonnement.  C'est-√†-dire  maximum peut √™tre de 3 abonn√©s.  Ainsi, dans une premi√®re approximation, la m√©thode de notification des abonn√©s de la classe <code>ButttonsController</code> peut sembler </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          HandleEvent() for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } } ;</span></span></code> </pre> <br><p>  Tout le sel se trouve dans la m√©thode <code>Notify()</code> de la classe <code>Publisher</code> .  Dans cette m√©thode, nous passons en revue la liste des abonn√©s et appelons <code>HandleEvent()</code> sur chacun d'entre eux, et c'est cool, car chaque abonn√© impl√©mente cette m√©thode √† sa mani√®re et peut y faire <del>  tout </del>  tout ce que votre c≈ìur d√©sire (en fait, vous devez √™tre prudent, sinon le diable sait ce que l'abonn√© y fait, vous pouvez appeler sa m√©thode, par exemple, √† partir d'une interruption et vous devez √™tre vigilant pour emp√™cher les abonn√©s de faire des choses longues et mauvaises) </p><br><p>  Dans notre cas, la LED est autoris√©e √† faire n'importe quoi, elle fait donc la commutation de son √©tat: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Led</span></span></span><span class="hljs-class">:</span></span> ISubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Port::ODR::Toggle(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  Toggle() ; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation compl√®te de toutes les classes</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ISubscriber { virtual void HandleEvent() = 0; } ; struct IPublisher { virtual void Notify() const = 0; virtual void Subscribe(ISubscriber* subscriber) = 0; } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { static void Toggle() { Port::ODR::Toggle(1 &lt;&lt; pinNum); } void HandleEvent() override { Toggle() ; } }; struct ButtonController : IPublisher { void Run() { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } void Subscribe(ISubscriber* subscriber) override { if (index &lt; pSubscribers.size()) { pSubscribers[index] = subscriber ; index ++ ; } //   3   ...   } private: std::array&lt;ISubscriber*, 3&gt; pSubscribers ; std::size_t index = 0U ; } ;</span></span></code> </pre></div></div><br><p>  Comment un abonnement peut-il appara√Ætre dans le code?  Et donc: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; ButtonController buttonController ; //  3  buttonController.Subscribe(&amp;Led1) ; buttonController.Subscribe(&amp;Led2) ; buttonController.Subscribe(&amp;Led3) ; //       buttonController.Run() ; }</span></span></code> </pre> <br><p>  La bonne nouvelle est que nous pouvons signer n'importe quel objet et le moment de sa cr√©ation n'a pas d'importance pour nous.  Il peut s'agir d'un objet global, statique ou local.  D'une part, c'est bien, mais d'autre part, pourquoi devons-nous nous abonner √† l'ex√©cution dans ce code.  En effet, en effet, ici l'adresse des objets <code>Led1</code> , <code>Led2</code> , <code>Led3</code> est connue au stade de la compilation.  Alors, pourquoi ne pouvez-vous pas vous abonner au stade de la compilation et conserver un ensemble de pointeurs vers les abonn√©s en ROM? </p><br><p>  De plus, il existe un risque d'erreurs potentielles, par exemple, combien se sont demand√© ce qui se passerait lors de l'appel de la m√©thode <code>Subsribe()</code> si elle √©tait appel√©e √† partir de plusieurs threads?  Nous sommes limit√©s √† seulement 3 abonn√©s, et que se passe-t-il si nous signons 4 LED? </p><br><p>  Dans la plupart des cas, nous avons besoin de cet abonnement une fois dans la vie lors de l'initialisation, nous enregistrons simplement des pointeurs vers les abonn√©s et c'est tout.  Le pointeur conservera √† vie l'adresse de ces abonn√©s.  Et le jour est in√©vitable quand il peut √™tre ruin√© <del>  en raison de l'√©pid√©mie de supernova </del>  (bien s√ªr, si l'on consid√®re une p√©riode de temps assez longue).  Mais dans tous les cas, la probabilit√© de d√©faillance de la RAM est beaucoup plus √©lev√©e que la ROM et il n'est pas recommand√© de stocker des donn√©es permanentes dans la RAM. </p><br><p>  Eh bien, la mauvaise nouvelle est qu'une telle solution architecturale prend beaucoup d'espace dans la ROM et la RAM.  Au cas o√π, nous √©crivons combien de ROM et de RAM cette solution prend: </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  donn√©es rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  488 </td><td>  64 </td><td>  21 </td></tr></tbody></table></div><br><p>  C'est-√†-dire  au total 552 octets en ROM et 21 octets en RAM - disons pas tellement pour appuyer sur un bouton et faire clignoter trois LED. </p><br><p>  Eh bien, afin de vous prot√©ger de tels probl√®mes et de r√©duire la consommation de ressources du contr√¥leur, consid√©rons l'option avec un abonnement statique. </p><br><h2 id="staticheskaya-podpiska">  Abonnement statique </h2><br><p>  Afin de rendre l'abonnement statique, vous pouvez utiliser plusieurs approches.  Je vais les nommer comme ceci: </p><br><ul><li>  La m√©thode traditionnelle est la m√™me approche, mais en utilisant le constructeur constexpr et en d√©finissant la liste des abonn√©s √† travers elle. </li><li><del>  Non conventionnel </del>  Utilisation de mod√®les - transf√©rez la liste des abonn√©s via les param√®tres du mod√®le.  (ici, un mod√®le est une d√©finition du domaine de la m√©taprogrammation, pas des mod√®les de conception) </li></ul><br><h3 id="tradicionnyy-podhod-k-staticheskoy-podpiske">  L'approche traditionnelle de l'abonnement statique </h3><br><p>  Essayons de nous abonner au stade de la compilation.  Pour ce faire, nous peaufinons un peu notre architecture: </p><br><p><img src="https://habrastorage.org/webt/lr/_k/gy/lr_kgyobfgkebxpz9gfyqiod34u.png"></p><br><p>  L'image n'est pas tr√®s diff√©rente de l'original, mais il existe plusieurs diff√©rences: la m√©thode <code>Subscribe()</code> a √©t√© supprim√©e et maintenant l'abonnement sera effectu√© directement dans le constructeur.  Le constructeur doit accepter un nombre variable d'arguments, et pour pouvoir signer statiquement au stade de la compilation, ce sera <code>constexpr</code> .  Un tableau d'abonn√©s y sera initialis√© et cette initialisation peut se faire au moment de la compilation: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*... args)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;ISubscriber <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt; result = {args...} ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; size) { pSubscribers[index] = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;ISubscriber*&gt;(it); } index ++ ; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-number"><span class="hljs-number">3U</span></span>; ISubscriber* pSubscribers[size] ; } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Code complet pour une telle impl√©mentation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPublisher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { constexpr Led() { } static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const override { Toggle() ; } }; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ButtonController : IPublisher { template&lt;typename... Args&gt; constexpr ButtonController(Args const*... args): pSubscribers() { std::initializer_list&lt;ISubscriber const*&gt; result = {args...} ; std::size_t index = 0U; for(auto it: result) { if (index &lt; size) { pSubscribers[index] = const_cast&lt;ISubscriber*&gt;(it); } index ++ ; } } void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } private: static constexpr std::size_t size = 3U; ISubscriber* pSubscribers[size] ; } ;</span></span></code> </pre></div></div><br><p>  D√©sormais, l'abonnement peut √™tre effectu√© au moment de la compilation: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController buttonController(&amp;Led1, &amp;Led2, &amp;Led3) ; buttonController.Run() ; return 0 ; } ;</span></span></code> </pre> <br><p>  Ici, l'objet <code>buttonController</code> compl√®tement situ√© dans la ROM avec un tableau de pointeurs vers les abonn√©s: </p><br><blockquote>  main :: buttonController 0x800'1f04 0x10 Donn√©es main.o [1] </blockquote><p>  Tout ne semble rien, sauf que nous sommes √† nouveau limit√©s √† seulement 3 abonn√©s.  Et la classe d'√©diteur doit avoir un constructeur constexpr et en g√©n√©ral √™tre compl√®tement constante afin de garantir un pointeur vers les abonn√©s dans la ROM, sinon, m√™me avec des adresses d'abonn√©s connues, notre objet, avec tout le contenu, ira √† nouveau en RAM. </p><br><p>  Parmi les autres inconv√©nients - puisque les fonctions virtuelles sont toujours utilis√©es, les tables de fonctions virtuelles peu √† peu notre ROM.  Et la ressource est, bien que abordable, mais pas infinie.  Dans la plupart des applications, il est possible de marteler dessus et de prendre un microcontr√¥leur plus grand, mais il arrive souvent que chaque octet compte, en particulier lorsqu'il s'agit de produits fabriqu√©s par centaines de milliers, tels que des capteurs physiques physiques. </p><br><p>  Voyons comment les choses se passent avec la m√©moire dans cette solution: </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  donn√©es rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  172 </td><td>  76 </td><td>  0 </td></tr></tbody></table></div><br><p>  Et bien que le r√©sultat soit ¬´√©tonnant¬ª: la consommation totale de RAM est de 0 octet, et la ROM est de 248 octets, ce qui est deux fois moins que dans la premi√®re solution, il estime qu'il existe encore un potentiel d'am√©lioration.  Sur ces 248 octets, environ 50 occupent simplement les tables de m√©thodes virtuelles. </p><br><p>  <u>Une petite digression:</u> <br>  Une √©tape dans la taille de la ROM de 256 ko pour les microcontr√¥leurs modernes est la norme (par exemple, le microcontr√¥leur TI Cortex M4 a 256 ko de ROM, et la prochaine version est d√©j√† 512 ko).  Et ce ne sera pas tr√®s bien quand, en raison de 50 octets suppl√©mentaires, nous devons prendre un contr√¥leur avec une ROM de 256 Ko plus grande et plus ch√®re, par cons√©quent, l'abandon des fonctions virtuelles peut √©conomiser ... jusqu'√† 50 cents (la diff√©rence entre le microcontr√¥leur dans la ROM de 256 et 512 Ko est d'environ 50-60 cents). </p><br><p>  Cela semble ridicule pour 1 microcontr√¥leur, mais sur un lot de 400 000 appareils par an, vous pouvez √©conomiser 200 000 $.  D√©j√† pas si dr√¥le, mais vu quel genre de rat.  ils peuvent r√©compenser l'offre avec un dipl√¥me et une carte-cadeau pour 3000 roubles, il n'y a absolument aucun doute sur la justesse de refuser les fonctions virtuelles et d'√©conomiser 50 octets suppl√©mentaires en ROM. </p><br><h3 id="netradicionnyy-podhod">  Approche non conventionnelle </h3><br><p>  Voyons comment vous pouvez faire de m√™me sans fonctions virtuelles et √©conomisez encore plus de ROM. </p><br><p>  Voyons d'abord comment cela pourrait √™tre: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; //   ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Notre t√¢che consiste √† d√©coupler les deux objets Publisher ( <code>ButtonController</code> ) et Subscriber ( <code>Led</code> ) l'un de l'autre afin qu'ils ne se connaissent pas, mais en m√™me temps <code>ButtonController</code> pourrait avertir <code>Led</code> . </p><br><p>  Vous pouvez d√©clarer la classe <code>ButtonController</code> une mani√®re ou d'une autre. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;&amp; subscriber1, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&amp; subscriber2, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;&amp; subscriber3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ subscriber1.HandleEvent() ; subscriber2.HandleEvent() ; subscriber3.HandleEvent() ; } ... } ;</code> </pre> <br><p>  Mais vous comprenez, ici nous sommes attach√©s √† des types sp√©cifiques et nous devrons refaire la d√©finition de la classe <code>BbuttonController</code> chaque fois dans un nouveau projet.  Et je voudrais simplement prendre et utiliser <code>ButtonController</code> dans le nouveau projet sans <code>ButtonController</code> . </p><br><p>  C ++ 17 vient √† la rescousse, o√π vous ne pouvez pas sp√©cifier le type, mais demandez au compilateur de d√©duire le type pour vous - c'est exactement ce dont vous avez besoin.  On peut, tout comme dans l'approche traditionnelle, lib√©rer la connaissance de l'Editeur et de l'Abonn√©, alors que le nombre d'abonn√©s est pratiquement illimit√©. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; } ... } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Fonctionnement de la fonction pass (..)</b> <div class="spoiler_text"><p>  La m√©thode <code>Notify()</code> a un appel √† la fonction <code>pass()</code> ; elle est utilis√©e pour d√©velopper les param√®tres du mod√®le avec un nombre variable d'arguments </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; }</code> </pre> <br><p>  L'impl√©mentation de la fonction <code>pass()</code> est tout simplement inimaginable, c'est juste une fonction qui prend un nombre variable d'arguments: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Comment la fonction <code>HandleEvent()</code> d√©veloppe-t-elle en plusieurs appels pour chacun des abonn√©s? </p><br><p>  Puisque la fonction <code>pass()</code> accepte plusieurs arguments de n'importe quel type, vous pouvez lui passer plusieurs arguments de type <code>bool</code> , par exemple, vous pouvez appeler la fonction <code>pass(true, true, true)</code> .  Dans ce cas, bien s√ªr, rien ne se passera, mais nous n'en avons pas besoin. </p><br><p>  La ligne <code>(subscribers.HandleEvent() , true)</code> utilise l'op√©rateur "," (virgule), qui ex√©cute les deux op√©randes (de gauche √† droite) et renvoie la valeur du deuxi√®me op√©rateur, c'est-√†-dire ici <code>subscribers.HandleEvent()</code> sera ex√©cut√© en premier, puis <code>true</code> √† la fonction <code>pass()</code> sera d√©fini sur <code>true</code> . </p><br><p>  Eh bien, "..." est une entr√©e standard pour d√©velopper un nombre variable d'arguments.  Pour notre cas, les actions du compilateur peuvent √™tre d√©crites tr√®s sch√©matiquement comme suit: </p><br><pre> <code class="cpp hljs">pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; -&gt; pass((Led1.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led1.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led2.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led3.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ;</code> </pre> </div></div><br><p>  Au lieu de liens, vous pouvez utiliser des pointeurs: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> ... } ;</code> </pre> <br><p>  <strong>Addition:</strong> En fait, merci √† <a href="https://habr.com/ru/users/vamireh/" class="user_link">vamireh</a> qui a <a href="https://habr.com/ru/post/481606/">soulign√©</a> que toutes ces danses sont avec <del>  tambourin </del>  <code>pass</code> fonction <code>pass</code> en C ++ 17 n'est pas n√©cessaire.  √âtant donn√© que l'op√©rateur "," la virgule est prise en charge dans l'expression fold (qui a √©t√© introduite dans la norme C ++ 17), le code est encore simplifi√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ((subscribers.HandleEvent()), ...) ; } } ;</code> </pre> <br><p>  Sur le plan architectural, cela semble tr√®s simple en g√©n√©ral: </p><br><p><img src="https://habrastorage.org/webt/hx/di/jj/hxdijj1xdfvncxtdsr04a1qp_ve.png"></p><br><p>  J'ai ajout√© une autre classe LCD ici, mais purement par exemple, pour montrer que maintenant peu importe le type et le nombre d'abonn√©s, l'essentiel est qu'il impl√©mente la m√©thode <code>HandleEvent()</code> . </p><br><p>  Et tout le code en g√©n√©ral est √©galement plus facile maintenant: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led { static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const { Toggle() ; } }; template &lt;auto&amp; ... subscribers&gt; struct ButtonController { void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const { ((subscribers.HandleEvent()), ...) ; } } ; int main() { //  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  L'appel <code>Notify()</code> de la m√©thode <code>Run()</code> d√©g√©n√®re en un simple appel s√©quentiel </p><br><pre> <code class="cpp hljs">Led1.HandleEvent() ; Led2.HandleEvent() ; Led3.HandleEvent() ;</code> </pre> <br><p>  Et la m√©moire ici? </p><br><div class="scrollable-table"><table><thead><tr><th>  Module </th><th>  code ro </th><th>  ro data </th><th>  donn√©es rw </th></tr></thead><tbody><tr><td>  main.o </td><td>  186 </td><td>  4 </td><td>  0 </td></tr></tbody></table></div><br><p>  ROM total 190 octets et 0 octets de RAM.  Maintenant la commande, elle est presque 3 fois plus petite que la version standard, alors qu'elle effectue exactement la m√™me chose. </p><br><p>  Ainsi, si vous avez les adresses des abonn√©s connues √† l'avance dans la candidature et que vous suivez les conditions d√©finies au d√©but de l'article </p><br><div class="spoiler">  <b class="spoiler_title">Conditions au d√©but de l'article</b> <div class="spoiler_text"><ul><li>  n'utilisez pas d'allocation de m√©moire dynamique </li><li>  minimiser le travail avec des pointeurs </li><li>  nous utilisons autant de constantes que possible pour que personne ne change autant que possible </li><li>  mais en m√™me temps, nous utilisons aussi peu de constantes que possible situ√©es dans la RAM </li></ul></div></div><br><p>  En toute confiance, vous pouvez utiliser une telle impl√©mentation du mod√®le Publisher-Subscriber pour r√©duire les lignes de code et √©conomiser des ressources, et l√† vous regardez et vous pouvez r√©clamer non seulement une carte-cadeau, mais aussi un bonus bas√© sur les r√©sultats de l'ann√©e. </p><br><p>  L' <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">exemple de</a> test <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">sous IAR 8.40.2 se trouve ici</a> </p><br><p>  Tout √† venir!  Et bonne chance pour la nouvelle ann√©e! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481606/">https://habr.com/ru/post/fr481606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481594/index.html">D√©veloppement d'un ¬´g√©n√©rateur de tension simple¬ª selon GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../fr481596/index.html">Analyse des param√®tres ELK 7.5 pour l'analyse des journaux Mikrotik</a></li>
<li><a href="../fr481598/index.html">Une petite contribution √† la lutte contre les plateformes de zoo Avalonia UI</a></li>
<li><a href="../fr481600/index.html">Moteur Wiki Bonsai Family: R√©sultats 2019</a></li>
<li><a href="../fr481604/index.html">Comment les d√©veloppeurs de Chelyabinsk durs cr√©ent des jeux pour Google Play et les r√©seaux sociaux</a></li>
<li><a href="../fr481610/index.html">PostgreSQL Antipatterns: mise √† jour d'une grande table en charge</a></li>
<li><a href="../fr481612/index.html">Notre petite contribution √† la lutte d'Avalonia UI pour moins de plateformes</a></li>
<li><a href="../fr481616/index.html">D√¥me g√©od√©sique. √Ä propos de l'appareil et mon exp√©rience des calculs</a></li>
<li><a href="../fr481618/index.html">MVP dans Unity ou comment simplifier la vie</a></li>
<li><a href="../fr481620/index.html">Juniper SRX et Cisco ASA: nouvelle s√©rie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>