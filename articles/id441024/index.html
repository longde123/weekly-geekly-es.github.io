<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò™Ô∏è üë¶üèΩ ‚ú°Ô∏è Kami menulis perayap untuk satu atau dua 1.0 ü§ó ü•ï ü§∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perayap web (atau laba-laba web) adalah bagian penting dari mesin pencari untuk merayapi halaman web untuk memasukkan informasi tentang mereka ke dala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis perayap untuk satu atau dua 1.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/441024/">  <b>Perayap</b> web (atau laba-laba web) adalah bagian penting dari mesin pencari untuk merayapi halaman web untuk memasukkan informasi tentang mereka ke dalam basis data, terutama untuk pengindeksan lebih lanjut.  Mesin pencari (Google, Yandex, Bing), serta produk SEO (SEMrush, MOZ, ahrefs) dan tidak hanya memiliki hal seperti itu.  Dan hal ini cukup menarik: baik dari segi kasus potensial dan penggunaan, dan untuk implementasi teknis. <br><br><img src="https://habrastorage.org/webt/vw/pi/-9/vwpi-9jp8-dypdtmlh58qqa1nm0.jpeg"><br><br>  Dengan artikel ini, kita akan mulai membuat <s>sepeda</s> crawler Anda <b>secara iteratif</b> , menganalisis banyak fitur dan menemui jebakan rapat.  Dari fungsi rekursif sederhana hingga layanan yang skalabel dan dapat diperluas.  Pasti menarik! <br><a name="habracut"></a><br><h3>  Intro </h3><br>  Iteratif - itu berarti bahwa pada akhir setiap rilis, versi "siap pakai" produk yang siap pakai diharapkan dengan batasan, fitur, dan antarmuka yang disepakati. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.js</a> dan <b>JavaScript</b> dipilih sebagai platform dan bahasa, karena sederhana dan tidak sinkron.  Tentu saja, untuk pengembangan industri, pilihan basis teknologi harus didasarkan pada persyaratan bisnis, harapan, dan sumber daya.  Sebagai demonstrasi dan prototipe, platform ini sama sekali bukan apa-apa (IMHO). <br><br><blockquote>  Ini adalah crawler saya.  Ada banyak perayap seperti itu, tetapi ini adalah milikku. <br>  Perayap saya adalah sahabat saya. <br></blockquote><br>  Implementasi crawler adalah tugas yang cukup populer dan dapat ditemukan bahkan pada wawancara teknis.  Sebenarnya ada banyak solusi siap pakai ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Nutch</a> ) dan tulisan sendiri untuk kondisi yang berbeda dan dalam banyak bahasa.  Karena itu, setiap komentar dari pengalaman pribadi dalam pengembangan atau penggunaan dipersilahkan dan akan menarik. <br><br><h3>  Pernyataan masalah </h3><br>  Tugas untuk implementasi pertama (awal) dari crawler <s>tyap-blooper kami</s> adalah sebagai berikut: <br><br><blockquote>  <b>One-Two Crawler 1.0</b> <br>  Tulis skrip perayap yang melewati tautan <i>&lt;a href /&gt;</i> internal situs kecil (hingga 100 halaman).  Akibatnya, berikan daftar URL halaman dengan kode yang diterima dan peta tautannya.  Aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">robots.txt</a> dan atribut tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rel = nofollow</a> diabaikan. </blockquote><br>  <b>Perhatian!</b>  Mengabaikan aturan <i>robots.txt</i> adalah ide yang buruk karena alasan yang jelas.  Kami akan menebus kelalaian ini di masa depan.  Sementara itu, tambahkan parameter batas yang membatasi jumlah halaman yang akan dirayapi sehingga tidak menghentikan DoS dan coba situs eksperimental (lebih baik menggunakan "situs hamster" pribadi Anda untuk eksperimen). <br><br><h3>  Implementasi </h3><br>  Untuk yang tidak sabar, <a href="">berikut adalah sumber</a> solusi ini. <br><br><ol><li>  Klien HTTP (S) </li><li>  Opsi jawaban </li><li>  Ekstraksi Tautan </li><li>  Persiapan tautan dan penyaringan </li><li>  Normalisasi URL </li><li>  Algoritma fungsi utama </li><li>  Hasil kembali </li></ol><br><h4>  1. Klien HTTP (S) </h4><br>  Hal pertama yang perlu kita lakukan adalah mengirimkan permintaan dan menerima tanggapan melalui HTTP dan HTTPS.  Di node.js ada dua klien yang cocok untuk ini.  Tentu saja, Anda dapat mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan klien yang sudah jadi</a> , tetapi untuk tugas kami itu sangat berlebihan: kita hanya perlu mengirim permintaan GET dan mendapatkan respons dengan tubuh dan header. <br><br>  API kedua klien yang kami butuhkan identik, kami akan membuat peta: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clients = { <span class="hljs-string"><span class="hljs-string">'http:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>), <span class="hljs-string"><span class="hljs-string">'https:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) };</code> </pre> <br>  Kami menyatakan <i>pengambilan</i> fungsi sederhana, satu-satunya parameter yang akan menjadi URL <b>absolut</b> dari string sumber daya web yang diinginkan.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul url,</a> kami akan mengurai string yang dihasilkan menjadi objek URL.  Objek ini memiliki bidang dengan protokol (dengan titik dua), dimana kami akan memilih klien yang sesuai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstURL = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = clients[dstURL.protocol]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Could not select a client for '</span></span> + dstURL.protocol); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Selanjutnya, gunakan klien yang dipilih dan bungkus hasil dari fungsi <i>ambil</i> dalam janji: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... let req = client.get(dstURL.href, res =&gt; { // do something with the response }); req.on('error', err =&gt; reject('Failed on the request: ' + err.message)); req.end(); }); }</span></span></code> </pre><br><br>  Sekarang kita dapat menerima respons secara tidak sinkron, tetapi untuk saat ini kita tidak melakukan apa-apa dengannya. <br><br><h4>  2. Opsi Jawaban </h4><br>  Untuk menjelajah situs, cukup memproses 3 opsi jawaban: <br><br><ol><li>  <b>OK</b> - Kode Status 2xx diterima.  Diperlukan untuk menyimpan badan tanggapan sebagai hasil untuk pemrosesan lebih lanjut - mengekstraksi tautan baru. </li><li>  <b>REDIRECT</b> - Kode Status 3xx diterima.  Ini adalah pengalihan ke halaman lain.  Dalam hal ini, kita akan membutuhkan tajuk respons <i>lokasi</i> , dari mana kita akan mengambil satu tautan "keluar". </li><li>  <b>NO_DATA</b> - Semua kasus lainnya: 4xx / 5xx dan 3xx tanpa header <i>Lokasi</i> .  Tidak ada tempat untuk melangkah lebih jauh ke perayap kami. </li></ol><br>  Fungsi <i>ambil</i> akan menyelesaikan respons yang diproses yang menunjukkan jenisnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ft = { <span class="hljs-string"><span class="hljs-string">'OK'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// code (2xx), content 'REDIRECT': 2, // code (3xx), location 'NO_DATA': 3 // code };</span></span></code> </pre><br>  Implementasi strategi menghasilkan hasil dalam tradisi terbaik <i>jika-yang lain</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = res.statusCode; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> codeGroup = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(code / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK if (codeGroup === 2) { let body = []; res.setEncoding('utf8'); res.on('data', chunk =&gt; body.push(chunk)); res.on('end', () =&gt; resolve({ code, content: body.join(''), type: ft.OK })); } // REDIRECT else if (codeGroup === 3 &amp;&amp; res.headers.location) { resolve({ code, location: res.headers.location, type: ft.REDIRECT }); } // NO_DATA (others) else { resolve({ code, type: ft.NO_DATA }); }</span></span></code> </pre><br>  Fungsi <i>ambil</i> siap digunakan: <a href="">seluruh kode fungsi</a> . <br><br><h4>  3. Ekstraksi tautan </h4><br>  Sekarang, tergantung pada varian jawaban yang diterima, Anda harus dapat mengekstrak tautan dari data hasil <i>pengambilan</i> untuk perayapan lebih lanjut.  Untuk melakukan ini, kita mendefinisikan fungsi <i>ekstrak</i> , yang mengambil objek hasil sebagai input dan mengembalikan array tautan baru. <br><br>  Jika tipe hasil adalah REDIRECT, maka fungsi akan mengembalikan array dengan satu referensi tunggal dari bidang <i>lokasi</i> .  Jika NO_DATA, maka array kosong.  Jika OK, maka kita perlu menghubungkan parser untuk <i>konten</i> teks yang disajikan untuk pencarian. <br><br>  Untuk tugas pencarian, <i>&lt;a href /&gt;,</i> Anda juga dapat menulis ekspresi reguler.  Tetapi solusi ini tidak berskala sama sekali, karena di masa depan kita setidaknya akan memperhatikan atribut ( <i>rel</i> ) tautan lainnya, sebagai maksimum, kita akan memikirkan <i>img</i> , <i>tautan</i> , <i>skrip</i> , <i>audio / video</i> ( <i>sumber</i> ) dan sumber daya lainnya.  Jauh lebih menjanjikan dan lebih mudah untuk mem-parsing teks dokumen dan membangun pohon node-nya untuk mem-bypass penyeleksi yang biasa. <br><br>  Kami akan menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSDOM</a> populer untuk bekerja dengan DOM di node.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { JSDOM } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jsdom'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSDOM(fetched.content).window.document; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(elements) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.getAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> href === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> href.trim()) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre><br>  Kami mendapatkan semua elemen <i>A</i> dari dokumen, dan kemudian semua nilai yang disaring dari atribut <i>href</i> , jika tidak baris kosong. <br><br><h4>  4. Persiapan dan penyaringan tautan </h4><br>  Sebagai hasil dari ekstraktor, kami memiliki serangkaian tautan (URL) dan dua masalah: 1) URL dapat bersifat relatif dan 2) URL dapat mengarah ke sumber daya eksternal (kami hanya membutuhkan yang internal sekarang). <br><br>  Masalah pertama akan dibantu oleh fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">url.resolve</a> , yang menyelesaikan URL halaman arahan relatif terhadap URL halaman sumber. <br><br>  Untuk mengatasi masalah kedua, kami menulis fungsi utilitas sederhana <i>diScope</i> yang memeriksa host halaman arahan terhadap host URL dasar dari perayapan saat ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLowerHost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst)).hostname.toLowerCase(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstHost = getLowerHost(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> baseHost = getLowerHost(base); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = dstHost.indexOf(baseHost); <span class="hljs-comment"><span class="hljs-comment">// the same domain or has subdomains return i === 0 || dstHost[i - 1] === '.'; }</span></span></code> </pre><br>  Fungsi mencari substring ( <i>baseHost</i> ) dengan karakter sebelumnya diperiksa jika substring ditemukan: karena <i>wwwexample.com</i> dan <i>example.com</i> adalah domain yang berbeda.  Akibatnya, kami tidak meninggalkan domain yang diberikan, tetapi memotong subdomainnya. <br><br>  Kami memperbaiki fungsi <i>ekstrak</i> dengan menambahkan "absolutisasi" dan memfilter tautan yang dihasilkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fetched, src, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extractRaw(fetched) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> url.resolve(src, href)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function"> =&gt;</span></span> /^https?\:\/\<span class="hljs-comment"><span class="hljs-comment">//i.test(dst)) .filter(dst =&gt; inScope(dst, base)); }</span></span></code> </pre><br>  Di sini <i>diambil</i> adalah hasil dari fungsi <i>pengambilan</i> , <i>src</i> adalah URL dari halaman sumber, <i>basis</i> adalah URL dasar dari perayapan.  Di bagian keluaran, kami mendapatkan daftar tautan internal (URL) yang sudah absolut untuk diproses lebih lanjut.  Seluruh kode fungsi dapat <a href="">dilihat di sini</a> . <br><br><h4>  5. Normalisasi URL </h4><br>  Setelah bertemu dengan URL apa pun lagi, tidak perlu mengirim permintaan lain untuk sumber daya, karena data telah diterima (atau koneksi lain masih terbuka dan menunggu jawaban).  Tetapi tidak selalu cukup untuk membandingkan string dari dua URL untuk memahami hal ini.  Normalisasi adalah prosedur yang diperlukan untuk menentukan kesetaraan dari URL yang berbeda secara sintaksis. <br><br>  Proses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">normalisasi</a> adalah serangkaian transformasi yang diterapkan pada URL sumber dan komponennya.  Berikut ini beberapa di antaranya: <br><br><ul><li>  Skema dan host tidak peka terhadap huruf besar-kecil, sehingga harus dikonversi menjadi lebih rendah. </li><li>  Semua persentase (seperti "% 3A") harus dalam huruf kapital. </li><li>  Port default (80 untuk HTTP) dapat dihapus. </li><li>  Fragmen ( <i>#</i> ) tidak pernah terlihat oleh server dan juga dapat dihapus. </li></ul><br>  Anda selalu dapat mengambil sesuatu yang sudah jadi (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">normalize-url</a> ) atau menulis fungsi sederhana Anda sendiri yang mencakup kasus paling penting dan umum: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-comment"><span class="hljs-comment">// ignore userinfo (auth property) let origin = dstUrl.protocol + '//' + dstUrl.hostname; // ignore http(s) standart ports if (dstUrl.port &amp;&amp; (!/^https?\:/i.test(dstUrl.protocol) || ![80, 8080, 443].includes(+dstUrl.port))) { origin += ':' + dstUrl.port; } // ignore fragment (hash property) let path = dstUrl.pathname + dstUrl.search; // convert origin to lower case return origin.toLowerCase() // and capitalize letters in escape sequences + path.replace(/%([0-9a-f]{2})/ig, (_, es) =&gt; '%' + es.toUpperCase()); }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Untuk jaga-jaga, format objek URL</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zs/te/jr/zstejr_mjpparhgrr4aar6ma7nq.png"><br></div></div><br>  Ya, tidak ada penyortiran parameter kueri, mengabaikan tag utm, memproses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">_escaped_fragment_</a> dan hal-hal lain, yang kami (benar-benar) tidak perlu sama sekali. <br><br>  Selanjutnya, kita akan membuat cache lokal dari URL yang dinormalisasi yang diminta oleh kerangka kerja Crawl.  Sebelum mengirim permintaan berikutnya, kami menormalkan URL yang diterima, dan jika tidak ada dalam cache, tambahkan dan baru kemudian kirimkan permintaan baru. <br><br><h4>  6. Algoritma fungsi utama </h4><br>  Komponen utama (primitif) dari solusi sudah siap, sekarang saatnya untuk mulai mengumpulkan semuanya.  Untuk memulainya, mari kita tentukan tanda tangan dari fungsi <i>crawl</i> : pada input, URL awal dan batas halaman.  Fungsi mengembalikan janji yang resolusinya memberikan hasil akumulasi;  tulis ke file <i>output</i> : <br><br><pre> <code class="javascript hljs">crawl(start, limit).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { fs.writeFile(output, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result), <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, err =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; }); });</code> </pre><br>  Alur kerja rekursif paling sederhana dari fungsi crawl dapat dijelaskan dalam langkah-langkah: <br><br><blockquote>  1. Inisialisasi cache dan objek hasil <br>  2. JIKA URL halaman arahan (via <b>normalisasi</b> ) tidak ada dalam cache, MAKA <br>  - 2.1.  JIKA <i>batas</i> tercapai, END (tunggu hasil) <br>  - 2.2.  Tambahkan URL ke Cache <br>  - 2.3.  Simpan tautan antara sumber dan halaman arahan di hasil <br>  - 2.4.  Kirim permintaan tidak sinkron per halaman ( <b>ambil</b> ) <br>  - 2.5.  JIKA permintaan berhasil, MAKA <br>  - - 2.5.1.  Ekstrak tautan baru dari hasil ( <b>ekstrak</b> ) <br>  - - 2.5.2.  Untuk setiap tautan baru, jalankan algoritma 2-3 <br>  - 2.6.  ELSE menandai halaman sebagai kesalahan <br>  - 2.7.  Simpan data halaman untuk dihasilkan <br>  - 2.8.  JIKA ini adalah halaman terakhir, Bawa hasilnya <br>  3. ELSE menyimpan tautan antara sumber dan halaman arahan dalam hasil <br></blockquote><br>  <b>Ya, algoritma ini akan mengalami perubahan besar di masa depan.</b>  Sekarang, solusi rekursif digunakan dengan sengaja di dahi, sehingga nanti lebih baik untuk "merasakan" perbedaan dalam implementasi.  Benda kerja untuk implementasi fungsi terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crawl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// initialize cache &amp; result return new Promise((resolve, reject) =&gt; { function curl(src, dst) { // check dst in the cache &amp; pages limit // save the link (src -&gt; dst) to the result fetch(dst).then(fetched =&gt; { extract(fetched, dst, start).forEach(ln =&gt; curl(dst, ln)); }).finally(() =&gt; { // save the page's data to the result // check completion and resolve the result }); } curl(null, start); }); }</span></span></code> </pre><br>  Pencapaian batas halaman diperiksa oleh penghitung permintaan sederhana.  Penghitung kedua - jumlah permintaan aktif pada suatu waktu - akan berfungsi sebagai ujian kesiapan untuk memberikan hasilnya (ketika nilainya berubah menjadi nol).  Jika fungsi <i>ambil</i> tidak bisa mendapatkan halaman berikutnya, maka atur Kode Status untuk itu sebagai nol. <br><br>  Anda dapat (secara opsional) <a href="">membiasakan diri</a> dengan kode implementasi di <a href="">sini</a> , tetapi sebelum itu Anda harus mempertimbangkan format hasil yang dikembalikan. <br><br><h4>  7. Hasil yang dikembalikan </h4><br>  Kami akan memperkenalkan pengidentifikasi <i>id</i> unik dengan kenaikan sederhana untuk halaman yang disurvei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-comment"><span class="hljs-comment">// ... let dstNorm = normalize(dst); if (dstNorm in cache === false) { cache[dstNorm] = ++id; // ... }</span></span></code> </pre><br>  Untuk hasilnya, kita akan membuat array <i>halaman</i> yang akan kita tambahkan objek dengan data pada halaman: <i>id</i> {number}, <i>url</i> {string} dan <i>kode</i> {number | null} (ini sekarang cukup).  Kami juga membuat larik <i>tautan</i> untuk tautan antar halaman dalam bentuk objek: <i>dari</i> ( <i>id</i> halaman sumber), <i>ke</i> ( <i>id</i> halaman arahan). <br><br>  Untuk tujuan informasi, sebelum menyelesaikan hasilnya, kami mengurutkan daftar halaman dalam urutan <i>id yang</i> naik (setelah semua, jawaban akan datang dalam urutan apa pun), kami melengkapi hasilnya dengan jumlah halaman <i>hitungan yang</i> dipindai dan bendera untuk mencapai batas <i>sirip yang</i> ditentukan: <br><br><pre> <code class="javascript hljs">resolve({ <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: pages.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2</span></span></span><span class="hljs-function">) =&gt;</span></span> p1.id - p2.id), <span class="hljs-attr"><span class="hljs-attr">links</span></span>: links.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l1, l2</span></span></span><span class="hljs-function">) =&gt;</span></span> l1.from - l2.from || l1.to - l2.to), count, <span class="hljs-attr"><span class="hljs-attr">fin</span></span>: count &lt; limit });</code> </pre><br><h3>  Contoh penggunaan </h3><br>  Script perayap yang selesai memiliki sinopsis berikut: <br><br><pre> <code class="plaintext hljs">node crawl-cli.js --start="&lt;URL&gt;" [--output="&lt;filename&gt;"] [--limit=&lt;int&gt;]</code> </pre><br>  Melengkapi pencatatan poin-poin utama dari proses, kita akan melihat gambar seperti itu pada saat startup: <br><br><pre> <code class="plaintext hljs">$ node crawl-cli.js --start="https://google.com" --limit=20 [2019-02-26T19:32:10.087Z] Start crawl "https://google.com" with limit 20 [2019-02-26T19:32:10.089Z] Request (#1) "https://google.com/" [2019-02-26T19:32:10.721Z] Fetched (#1) "https://google.com/" with code 301 [2019-02-26T19:32:10.727Z] Request (#2) "https://www.google.com/" [2019-02-26T19:32:11.583Z] Fetched (#2) "https://www.google.com/" with code 200 [2019-02-26T19:32:11.720Z] Request (#3) "https://play.google.com/?hl=ru&amp;tab=w8" [2019-02-26T19:32:11.721Z] Request (#4) "https://mail.google.com/mail/?tab=wm" [2019-02-26T19:32:11.721Z] Request (#5) "https://drive.google.com/?tab=wo" ... [2019-02-26T19:32:12.929Z] Fetched (#11) "https://www.google.com/advanced_search?hl=ru&amp;authuser=0" with code 200 [2019-02-26T19:32:13.382Z] Fetched (#19) "https://translate.google.com/" with code 200 [2019-02-26T19:32:13.782Z] Fetched (#14) "https://plus.google.com/108954345031389568444" with code 200 [2019-02-26T19:32:14.087Z] Finish crawl "https://google.com" on count 20 [2019-02-26T19:32:14.087Z] Save the result in "result.json"</code> </pre><br>  Dan inilah hasilnya dalam format JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"pages"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">301</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://play.google.com/?hl=ru&amp;tab=w8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://mail.google.com/mail/?tab=wm"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://drive.google.com/?tab=wo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://translate.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://calendar.google.com/calendar?tab=wc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fin"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br><br>  Apa yang bisa dilakukan dengan ini?  Minimal, daftar halaman Anda dapat menemukan semua halaman situs yang rusak.  Dan memiliki informasi tentang tautan internal, Anda dapat mendeteksi rantai panjang (dan loop tertutup) pengalihan atau menemukan halaman yang paling penting dengan massa referensi. <br><br><h3>  Pengumuman 2.0 </h3><br>  Kami telah memperoleh varian crawler crawler paling sederhana, yang mem-bypass halaman satu situs.  Kode sumber <a href="">ada di sini</a> .  Ada juga contoh dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unit test</a> untuk beberapa fungsi. <br><br>  Sekarang ini adalah pengirim permintaan tanpa basa-basi dan langkah selanjutnya yang masuk akal adalah mengajarinya sopan santun.  Ini akan tentang header <i>User-agent</i> , aturan <i>robots.txt</i> , arahan <i>keterlambatan perayapan</i> , dan banyak lagi.  Dari sudut pandang implementasi, ini pertama-tama mengantri pesan dan kemudian melayani beban yang lebih besar.  <i>Jika, tentu saja, materi ini akan menarik!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441024/">https://habr.com/ru/post/id441024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441012/index.html">Fakta menarik tentang sejarah program bulan China dan misi luar angkasa Chang'e-4</a></li>
<li><a href="../id441014/index.html">Rendering stereo anggaran rendah dalam beberapa baris kode (stereogram, anaglyph, stereoscope)</a></li>
<li><a href="../id441018/index.html">Pengembangan program dan spesifikasi alat Mekanika NanoCAD</a></li>
<li><a href="../id441020/index.html">Bagaimana VTB sampai pada satu pengetahuan</a></li>
<li><a href="../id441022/index.html">Kesalahan umum penumpang kereta api dan maskapai penerbangan</a></li>
<li><a href="../id441026/index.html">VMware NSX untuk yang terkecil. Bagian 2. Mengkonfigurasi Firewall dan NAT</a></li>
<li><a href="../id441028/index.html">Bagaimana para peneliti menemukan database MongoDB dan Elasticsearch yang terbuka</a></li>
<li><a href="../id441030/index.html">Mendeteksi Serangan Web dengan Autoencoder Seq2Seq</a></li>
<li><a href="../id441032/index.html">KeeBee Membuat keyboard USB Anda sendiri dari awal</a></li>
<li><a href="../id441034/index.html">6 poin pertumbuhan konversi atau cara meningkatkan kepercayaan menggunakan telepon di situs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>