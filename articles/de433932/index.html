<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔬 🤰🏼 😴 Wir schießen in den Fuß und verarbeiten die Eingabedaten 👩‍🚀 👩‍❤️‍💋‍👨 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Link im heutigen Artikel unterscheidet sich vom üblichen. Dies ist nicht ein Projekt, für das der Quellcode analysiert wurde, sondern eine Reihe v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schießen in den Fuß und verarbeiten die Eingabedaten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/433932/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/iw/l-/jhiwl-y02cm4bhppsrj9flbpqsi.png"></div><br>  Der Link im heutigen Artikel unterscheidet sich vom üblichen.  Dies ist nicht ein Projekt, für das der Quellcode analysiert wurde, sondern eine Reihe von Antworten derselben Diagnoseregel in mehreren verschiedenen Projekten.  Was ist das Interesse hier?  Die Tatsache, dass einige der betrachteten Codefragmente Fehler enthalten, die bei der Arbeit mit der Anwendung reproduzierbar sind, während andere insgesamt Schwachstellen (CVE) enthalten.  Darüber hinaus werden wir am Ende des Artikels ein wenig über das Thema Sicherheitsmängel diskutieren. <br><a name="habracut"></a><br><h2>  Kurzes Vorwort </h2><br>  Alle Fehler, die heute im Artikel berücksichtigt werden, haben ein ähnliches Muster: <br><br><ul><li>  Das Programm empfängt Daten vom <i>Standard-</i> Stream. </li><li>  Es wird geprüft, ob Daten erfolgreich gelesen wurden. </li><li>  Wenn die Daten erfolgreich gelesen wurden, wird das Übertragszeichen aus der Zeile entfernt. </li></ul><br>  Alle Fragmente, die berücksichtigt werden, enthalten jedoch Fehler und sind anfällig für manipulierte Eingaben.  Da Daten von einem Benutzer empfangen werden, der gegen die Logik der Anwendungsausführung verstoßen kann, bestand die große Versuchung, etwas zu beschädigen.  Was ich getan habe. <br><br>  Alle folgenden Probleme wurden vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">statischen Analysator PVS-Studio entdeckt</a> , der nicht nur nach C, C ++, sondern auch nach C #, Java nach Fehlern im Code sucht. <br><br>  Natürlich ist es gut, ein Problem mit einem statischen Analysegerät zu finden, aber das Finden und Reproduzieren ist ein völlig anderes Vergnügen.  :) :) <br><br><h2>  Freischalter </h2><br>  Das erste verdächtige Codefragment wurde im Code des Moduls <i>fs_cli.exe gefunden</i> , das Teil des FreeSWITCH-Distributionskits ist: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_gets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cnt)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(command_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(command_buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) != command_buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } command_buf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(command_buf)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove endline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> Nicht aktivierte fehlerhafte Daten werden im Index 'strlen (command_buf)' verwendet. <br><br>  Der Analysator warnt vor einem verdächtigen Aufruf des Arrays <i>command_buf</i> per Index.  Es wird als verdächtig angesehen, da nicht überprüfte externe Daten als Index verwendet werden.  Extern - weil sie über die Funktion <i>fgets</i> aus dem <i>Standard-</i> Stream abgerufen werden.  Nicht überprüft - da vor der Verwendung keine Überprüfung durchgeführt wurde.  Der Ausdruck <i>fgets (command_buf, ....)! = Command_buf</i> zählt nicht, da wir auf diese Weise nur die Tatsache überprüfen, dass die Daten empfangen werden, nicht aber deren Inhalt. <br><br>  Das Problem mit diesem Code ist, dass unter bestimmten Bedingungen '\ 0' außerhalb des Arrays geschrieben wird, was zu undefiniertem Verhalten führt.  Geben Sie dazu einfach eine Zeichenfolge mit der Länge Null ein (eine Zeichenfolge mit der Länge Null aus Sicht der C-Sprache, dh eine Zeichenfolge, in der das erste Zeichen '\ 0' lautet). <br><br>  Lassen Sie uns abschätzen, was passiert, wenn Sie eine Zeichenfolge mit der Länge Null an die Eingabe übergeben: <br><br><ul><li>  <i>fgets (command_buf, ....)</i> -&gt; <i>command_buf</i> ; </li><li>  <i>fgets (....)! = command_buf</i> -&gt; <i>false</i> ( <i>dann wird der</i> Zweig der <i>if-Anweisung</i> ignoriert); </li><li>  <i>strlen (command_buf)</i> -&gt; <i>0</i> ; </li><li>  <i>command_buf [strlen (command_buf) - 1]</i> -&gt; <i>command_buf [-1]</i> . </li></ul><br>  Ups! <br><br>  Interessant ist hier, dass diese Analysatorwarnung "mit den Händen gefühlt" werden kann.  Um das Problem zu wiederholen, benötigen Sie: <br><br><ul><li>  Bringen Sie das Programm zu dieser Funktion. </li><li>  <i>Passen Sie</i> den Eingang so an, dass der Aufruf von <i>getchar ()</i> einen negativen Wert zurückgibt. </li><li>  <i>Übergeben Sie</i> für die Funktion <i>fgets</i> eine Zeile mit einem Terminal Null am Anfang, die erfolgreich gelesen werden soll. </li></ul><br>  Ich stöberte ein wenig in der Quelle und stellte eine bestimmte Sequenz für die Reproduktion des Problems zusammen: <br><br><ul><li>  Führen Sie <i>fs_cli.exe</i> im <i>Stapelmodus</i> aus ( <i>fs_cli.exe -b</i> ).  Ich <i>stelle</i> fest, dass die Verbindung <i>fs_cli.exe</i> zum Server erfolgreich sein muss, um weitere Schritte <i>ausführen</i> zu können.  Dazu reicht es beispielsweise aus, <i>FreeSwitchConsole.exe lokal</i> als Administrator <i>auszuführen</i> . </li><li>  Wir führen die Eingabe so aus, dass der Aufruf von <i>getchar ()</i> einen negativen Wert zurückgibt. </li><li>  Geben Sie am Anfang eine Zeile mit einem Terminal Null ein (z. B. '\ 0Oooops'). </li><li>  .... </li><li>  GEWINN! </li></ul><br>  Das Folgende ist eine Videowiedergabe des Problems: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jSYJirPIK8E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Ncftp </h2><br>  Ein ähnliches Problem wurde im NcFTP-Projekt entdeckt, das jedoch bereits an zwei Stellen aufgetreten ist.  Da der Code ähnlich aussieht, sollten Sie nur einen problematischen Ort berücksichtigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NcFTPConfirmResumeDownloadProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(newname, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) newname[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; newname[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> Nicht aktivierte fehlerhafte Daten werden im Index 'strlen (neuer Name)' verwendet. <br><br>  Im Gegensatz zum Beispiel von FreeSWITCH ist der Code hier schlechter geschrieben und anfälliger für Probleme.  Das Schreiben von '\ 0' erfolgt beispielsweise unabhängig davon, ob der <i>Lesevorgang</i> mit <i>fgets</i> erfolgreich <i>war</i> oder nicht.  Das heißt, es gibt noch mehr Möglichkeiten, die normale Ausführungslogik zu brechen.  Gehen wir auf bewährte Weise durch Linien mit der Länge Null. <br><br>  Das reproduzierte Problem ist etwas komplizierter als bei FreeSWITCH.  Die Reihenfolge der Schritte wird nachfolgend beschrieben: <br><br><ul><li>  Starten und Herstellen einer Verbindung mit dem Server, von dem Sie die Datei herunterladen können.  Zum Beispiel habe ich <i>speedtest.tele2.net verwendet</i> (am Ende sieht der Befehl zum Starten der Anwendung folgendermaßen aus: <i>ncftp.exe <a href="">speedtest.tele2.net</a></i> ); </li><li>  Herunterladen einer Datei vom Server.  Lokal sollte bereits eine Datei mit demselben Namen, aber unterschiedlichen Eigenschaften vorhanden sein.  Sie können beispielsweise eine Datei vom Server herunterladen, ändern und versuchen, den Download-Befehl erneut auszuführen (z. B. <i>512 KB. Zip</i> ). </li><li>  Beantworten Sie die Frage zur Auswahl einer Aktion mit einer Zeile, die mit dem Zeichen 'N' beginnt (z. B. <i>Jetzt haben wir Spaß</i> ). </li><li>  Geben Sie '\ 0' (oder etwas interessanteres) ein. </li><li>  .... </li><li>  GEWINN! </li></ul><br>  Die Reproduktion des Problems wird auch auf Video aufgezeichnet: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8DBQjvPQ7tk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Openldap </h2><br>  Im OpenLDAP-Projekt (genauer gesagt in einem der zugehörigen Dienstprogramme) traten sie auf den gleichen Rechen wie in FreeSWITCH.  Ein Versuch, ein Zeilenumbruchzeichen zu löschen, erfolgt nur, wenn die Zeile erfolgreich gelesen wurde, es besteht jedoch auch kein Schutz gegen Zeilen mit der Länge Null. <br><br>  Code-Snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[ <span class="hljs-number"><span class="hljs-number">4096</span></span> ]; FILE *fp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { fp = <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( fp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc == <span class="hljs-number"><span class="hljs-number">0</span></span> || contoper) &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove trailing newline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *buf != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> ) { rc = dodelete( ld, buf ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( rc != <span class="hljs-number"><span class="hljs-number">0</span></span> ) retval = rc; } } } .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> Ungeprüfte fehlerhafte Daten werden im Index 'strlen (buf)' verwendet. <br><br>  Wir werfen den Überschuss weg, damit die Essenz des Problems offensichtlicher wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (.... &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  Dieser Code ist besser als NcFTP, aber immer noch anfällig.  Wenn auf Anforderung eine Zeichenfolge mit der Länge Null an die Eingabe übergeben werden soll: <br><br><ul><li>  <i>fgets (buf, ....)</i> -&gt; <i>buf</i> ; </li><li>  <i>fgets (....)! = NULL</i> -&gt; <i>true</i> (der Körper der <i>while-Schleife</i> beginnt auszuführen); </li><li>  <i>strlen (buf) - 1</i> -&gt; <i>0 - 1</i> -&gt; <i>-1</i> ; </li><li>  <i>buf [-1] = '\ 0'</i> . </li></ul><br><h2>  libidn </h2><br>  Trotz der Tatsache, dass die oben diskutierten Fehler sehr interessant sind (sie werden stabil reproduziert und können "berührt" werden (außer dass ich das OpenLDAP-Problem nicht erreichen konnte)), können sie nicht als Schwachstellen bezeichnet werden, schon allein deshalb Problemen werden keine CVE-Kennungen zugewiesen. <br><br>  Einige echte Sicherheitslücken weisen jedoch das gleiche Problemmuster auf.  Die beiden folgenden Codefragmente gelten für das libidn-Projekt. <br><br>  Code-Snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets (readbuf, BUFSIZ, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> Nicht aktivierte fehlerhafte Daten werden im Index 'strlen (readbuf)' verwendet. <br><br>  Die Situation ist ähnlich, mit der Ausnahme, dass im Gegensatz zu den vorherigen Beispielen, in denen die Aufzeichnung mit dem Index <i>-1 durchgeführt wurde</i> , hier gelesen wird.  Dies ist jedoch immer noch undefiniertes Verhalten.  Diesem Fehler wurde eine eigene CVE-Kennung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zugewiesen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE-2015-8948</a> ). <br><br>  Nachdem ein Problem festgestellt wurde, wurde dieser Code wie folgt geändert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getline (&amp;line, &amp;linelen, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  Ein bisschen überrascht?  Es passiert.  Neue Sicherheitsanfälligkeit, entsprechende CVE-Kennung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE-2016-6262</a> . <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nicht aktivierte fehlerhafte</a> Daten werden im Index 'strlen (line)' verwendet. <br><br>  Bei einem anderen Versuch wurde das Problem behoben, indem die Länge der Eingabezeichenfolge überprüft wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>;</code> </pre> <br>  Werfen wir einen Blick auf die Daten.  Das Commit 'Closing' CVE-2015-8948 - 08/10/2015.  Commit Closing CVE-2016-62-62 - 14.01.2016.  Das heißt, der Unterschied zwischen den oben genannten Korrekturen beträgt <i>5 Monate</i> !  Hier erinnern Sie sich an einen solchen Vorteil der statischen Analyse wie das Erkennen von Fehlern in den frühen Phasen des Codeschreibens ... <br><br><h2>  Statische Analyse und Sicherheit </h2><br>  Es wird keine weiteren Codebeispiele geben, sondern Statistiken und Argumente.  In diesem Abschnitt stimmt die Meinung des Autors möglicherweise nicht viel mehr mit der Meinung des Lesers überein als zuvor in diesem Artikel. <br><br>  <b>Hinweis</b>  Ich empfehle Ihnen, einen weiteren Artikel zu einem ähnlichen Thema zu lesen: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie kann PVS-Studio beim Auffinden von Sicherheitslücken helfen?</a> ".  Es gibt interessante Beispiele für Sicherheitslücken, die wie einfache Fehler aussehen.  Darüber hinaus habe ich in diesem Artikel ein wenig über die Terminologie gesprochen und warum statische Analysen ein Muss sind, wenn Sie sich Gedanken über das Sicherheitsthema machen. <br><br>  Schauen wir uns die Statistiken zur Anzahl der in den letzten 10 Jahren entdeckten Sicherheitslücken an, um die Situation zu bewerten.  Ich habe die Daten von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE Details-</a> Website übernommen. <br><br><p><img src="https://habrastorage.org/webt/lu/au/2i/luau2ik1aoqytidzblkeqjy8vhs.png" alt="Bild 2"></p><br><br>  Eine interessante Situation zeichnet sich ab.  Bis 2014 hat die Anzahl der erfassten CVEs die Marke von 6.000 Einheiten nicht überschritten und ist ab - sie ist nicht darunter gefallen.  Am interessantesten ist hier natürlich die Statistik für 2017 - der absolute Spitzenreiter (14.714 Einheiten).  Das laufende Jahr 2018 ist noch nicht zu Ende, bricht aber bereits Rekorde - 15.310 Einheiten. <br><br>  Bedeutet dies, dass jede neue Software wie ein Sieb voller Löcher ist?  Ich glaube nicht und hier ist der Grund: <br><br><ul><li>  Erhöhtes Interesse am Thema Schwachstellen.  Selbst wenn Sie dem Thema Sicherheit nicht sehr nahe stehen, sind Sie sicherlich wiederholt auf Artikel, Notizen, Berichte und Videos zum Thema Sicherheit gestoßen.  Mit anderen Worten, es entstand eine Art „Hype“.  Ist es schlecht  Wahrscheinlich nicht.  Am Ende kommt es darauf an, dass Entwickler sich mehr um die Anwendungssicherheit sorgen, was gut ist. </li><li>  Eine Zunahme der Anzahl der entwickelten Anwendungen.  Mehr Code - es ist wahrscheinlicher, dass eine Sicherheitsanfälligkeit auftritt, durch die die Statistiken wieder aufgefüllt werden. </li><li>  Verbesserte Tools zur Suche nach Sicherheitslücken und zur Sicherung der Codequalität.  Mehr Nachfrage -&gt; mehr Angebot.  Analysatoren, Fuzzers und andere Tools werden immer weiter entwickelt, was denjenigen in die Hände spielt, die nach Schwachstellen suchen möchten (unabhängig davon, auf welcher Seite der Barrikaden sie sich befinden). </li></ul><br>  Der aufkommende Trend kann daher nicht ausschließlich als negativ bezeichnet werden. Die Verlage sind mehr besorgt über die Informationssicherheit, die Tools zur Problemfindung werden verbessert, und all dies ist zweifellos positiv. <br><br>  Bedeutet dies, dass Sie sich entspannen und nicht „baden“ können?  Ich denke nicht.  Wenn Sie sich Gedanken über das Sicherheitsthema Ihrer Anwendungen machen, sollten Sie so viele Sicherheitsmaßnahmen wie möglich ergreifen.  Dies gilt insbesondere dann, wenn der Quellcode gemeinfrei ist, da: <br><br><ul><li>  anfälliger für die Einbettung externer Schwachstellen; </li><li>  anfälliger für "Nachforschungen" durch jene "Herren", die an Lücken in Ihrer Anwendung interessiert sind, um sie auszunutzen.  Obwohl Gratulanten in diesem Fall in der Lage sein werden, Ihnen mehr zu helfen. </li></ul><br>  Ich möchte nicht sagen, dass Sie Ihre Projekte nicht unter Open Source übersetzen müssen.  Beachten Sie einfach die entsprechenden Qualitäts- / Sicherheitskontrollen. <br><br>  Ist die statische Analyse eine zusätzliche Maßnahme?  Ja  Die statische Analyse erkennt potenzielle Schwachstellen, die in Zukunft möglicherweise auftreten werden. <br><br>  Es scheint mir (ich gebe zu, dass ich mich irre), dass viele Schwachstellen als ein ziemlich hochrangiges Phänomen betrachten.  Ja und nein.  Codeprobleme, die wie einfache Programmierfehler erscheinen, können ebenfalls schwerwiegende Sicherheitslücken sein.  Wiederum finden Sie einige Beispiele für solche Sicherheitslücken im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor erwähnten Artikel</a> .  Unterschätzen Sie nicht die "einfachen" Fehler. <br><br><h2>  Fazit </h2><br>  Vergessen Sie nicht, dass die Eingabedaten eine Länge von Null haben können, und dies muss ebenfalls berücksichtigt werden. <br><br>  Schlussfolgerungen darüber, ob der ganze Hype mit Schwachstellen nur ein Hype ist oder ob das Problem besteht, machen Sie es selbst. <br><br>  Ich für meinen Teil, es sei denn, ich schlage vor, Ihr Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio anzuprobieren</a> , falls Sie dies noch nicht getan haben. <br><br>  Alles Gute! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Sergey Vasiliev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schießen Sie sich beim Umgang mit Eingabedaten in den Fuß</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433932/">https://habr.com/ru/post/de433932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433918/index.html">Warum ist das Web so kompliziert?</a></li>
<li><a href="../de433920/index.html">Der chinesische Polysilicium-Riese erhöht die Kapazität</a></li>
<li><a href="../de433922/index.html">Kubernetes Intensive: Support Jobs</a></li>
<li><a href="../de433926/index.html">Javascript-Frameworks: Trends 2019</a></li>
<li><a href="../de433930/index.html">Separate Profile für Freiberufler und Kunden</a></li>
<li><a href="../de433934/index.html">SAFe oder Scaled Agile Framework</a></li>
<li><a href="../de433936/index.html">Auf der Suche nach einem Hightech-Geschenk für ein Kind? Denken Sie an einen Spielplatz, nicht an einen Laufstall</a></li>
<li><a href="../de433938/index.html">Wie Yandex und Google das Jahr zusammenfassen</a></li>
<li><a href="../de433940/index.html">Wie viel kostet Review im AppStore?</a></li>
<li><a href="../de433944/index.html">Verheerende Ausnahmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>