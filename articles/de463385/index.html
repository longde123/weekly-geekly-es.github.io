<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíö üëßüèº üõãÔ∏è Noch einmal zum Prinzip der Lisk-Substitution oder zur Semantik der Vererbung in OOP üê™ üìª üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vererbung ist eine der S√§ulen von OOP. Vererbung wird verwendet, um allgemeinen Code wiederzuverwenden. Allgemeiner Code ist jedoch nicht immer f√ºr di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal zum Prinzip der Lisk-Substitution oder zur Semantik der Vererbung in OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463385/"> <b>Vererbung ist eine der S√§ulen von OOP.</b>  Vererbung wird verwendet, um allgemeinen Code wiederzuverwenden.  Allgemeiner Code ist jedoch nicht immer f√ºr die Wiederverwendung erforderlich, und Vererbung ist nicht immer der beste Weg, um Code wiederzuverwenden.  Es stellt sich oft heraus, dass es einen √§hnlichen Code in zwei verschiedenen Codeteilen (Klassen) gibt, aber die Anforderungen f√ºr sie sind unterschiedlich, d.h.  Klassen erben tats√§chlich voneinander und sind es m√∂glicherweise nicht wert. <br><a name="habracut"></a><br>  Verwenden Sie zur Veranschaulichung dieses Problems normalerweise das Beispiel zum Erben der Square-Klasse von der Rectangle-Klasse oder umgekehrt. <br><br>  Lassen Sie uns eine Rechteckklasse haben: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._width * self._height ...</code> </pre> <br>  Jetzt wollten wir die Square-Klasse schreiben, aber um den Fl√§chenberechnungscode wiederzuverwenden, erscheint es logisch, das Square vom Rechteck zu erben: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._width = height self._height = height</code> </pre><br>  Es scheint, dass der Code der Klassen Square und Rectangle konsistent ist.  Es scheint, dass Square die mathematischen Eigenschaften des Quadrats beibeh√§lt, d.h.  und ein Rechteck.  Das hei√üt, wir k√∂nnen quadratische Objekte anstelle von Rechteck √ºbergeben. <br><br>  Wenn wir dies tun, k√∂nnen wir das <i>Verhalten</i> der Rectangle-Klasse verletzen: <br><br>  Zum Beispiel gibt es einen Client-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect)</span></span></span><span class="hljs-function">:</span></span> rect.set_height(<span class="hljs-number"><span class="hljs-number">10</span></span>) rect.set_width(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> rect.get_area() == <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre><br>  Wenn Sie dieser Funktion eine Instanz der Square-Klasse als Argument √ºbergeben, verh√§lt sich die Funktion anders.  Dies ist eine Vertragsverletzung f√ºr das Verhalten der Rectangle-Klasse, da Aktionen mit einem Objekt der Basisklasse genau das gleiche Ergebnis liefern sollten wie mit dem Objekt der untergeordneten Klasse. <br><br>  Wenn die Quadratklasse ein Nachkomme der Rechteckklasse ist, wenn wir mit dem Quadrat arbeiten und die Methoden des Rechtecks ‚Äã‚Äãausf√ºhren, sollten wir nicht einmal bemerken, dass es kein Rechteck ist. <br><br>  Sie k√∂nnen dieses Problem beispielsweise folgenderma√üen beheben: <br><br><ol><li>  Machen Sie eine Zusicherung, die genau zur Klasse passt, oder machen Sie eine, wenn dies f√ºr verschiedene Klassen unterschiedlich funktioniert </li><li>  Machen Sie in Square die Methode set_size () und √ºberschreiben Sie die Methoden set_height und set_width, sodass sie Ausnahmen ausl√∂sen <br>  etc etc. </li></ol><br>  Solcher Code und solche Klassen funktionieren in dem Sinne, dass der Code funktioniert. <br><br>  Eine andere Frage ist, dass der Clientcode, der die Square-Klasse oder die Rectangle-Klasse verwendet, entweder √ºber die Basisklasse und ihr Verhalten oder √ºber die untergeordnete Klasse und ihr Verhalten Bescheid wissen muss. <br><br>  Im Laufe der Zeit k√∂nnen wir das bekommen: <br><br><ul><li>  Die untergeordnete Klasse √ºberschreibt die meisten Methoden </li><li>  Durch Refactoring oder Hinzuf√ºgen von Methoden zur Basisklasse wird der Code mithilfe von Nachkommen besch√§digt </li><li>  In dem Code, der die Objekte der Basisklasse verwendet, gibt es ifs, die nach der Klasse des Objekts suchen, und das Verhalten f√ºr Nachkommen und die Basisklasse ist unterschiedlich </li></ul><br>  Es stellt sich heraus, dass der f√ºr die Basisklasse geschriebene Clientcode von der Implementierung der Basisklasse und der untergeordneten Klasse abh√§ngt.  Das erschwert die Entwicklung im Laufe der Zeit erheblich.  Und OOP wurde nur erstellt, damit Sie die Basisklasse und die Nachkommenklasse unabh√§ngig voneinander bearbeiten k√∂nnen. <br><br>  In den 80er Jahren des letzten Jahrhunderts haben wir festgestellt, dass die Klassenvererbung f√ºr die Wiederverwendung von Code gut funktioniert. Wir m√ºssen sicher sein, dass die untergeordnete Klasse anstelle der Basisklasse verwendet werden kann.  Das hei√üt,  Vererbungssemantik - dies sollte nicht nur und weniger Daten als Verhalten sein.  Erben sollten das Verhalten der Basisklasse nicht "brechen". <br><br>  Tats√§chlich ist dies das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Lisk-Substitution</a> oder das Prinzip der Bestimmung eines Subtyps basierend auf dem Verhalten starker Klassen: <b>Wenn Sie mindestens einen aussagekr√§ftigen Code schreiben k√∂nnen, in dem das Ersetzen eines Basisklassenobjekts durch ein untergeordnetes Klassenobjekt ihn besch√§digt, lohnt es sich nicht erben sie voneinander.</b>  Wir sollten das Verhalten der Basisklasse in Nachkommen erweitern und nicht wesentlich √§ndern.  Funktionen, die die Basisklasse verwenden, sollten in der Lage sein, Unterklassenobjekte zu verwenden, ohne es zu wissen.  Tats√§chlich ist dies die Semantik der Vererbung in OOP. <br><br>  Im realen Industriekodex wird dringend empfohlen, diesem Prinzip zu folgen und die beschriebene Vererbungssemantik einzuhalten.  Und mit diesem Prinzip gibt es mehrere Feinheiten. <br><br>  <b>Das Prinzip sollte nicht mit Abstraktionen der Dom√§nenebene zufrieden sein, sondern mit Code-Abstraktionen - Klassen.</b>  Aus geometrischer Sicht ist ein Quadrat ein Rechteck.  Aus Sicht der Klassenvererbungshierarchie h√§ngt es von dem Verhalten ab, das wir von diesen Klassen ben√∂tigen, ob die Klasse eines Quadrats der Erbe des Klassenrechtecks ‚Äã‚Äãist.  Kommt darauf an, wie und in welchen Situationen wir diesen Code verwenden. <br><br>  Wenn die Rectangle-Klasse nur zwei Methoden hat - Berechnen der Fl√§che und Rendern ohne die M√∂glichkeit des Neuzeichnens und √Ñnderns der Gr√∂√üe -, erf√ºllt Square mit einem √ºberschriebenen Konstruktor in diesem Fall das Lisky-Prinzip des Ersetzens. <br><br>  Das hei√üt,  solche Klassen erf√ºllen das Substitutionsprinzip: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Dies ist zwar nat√ºrlich kein sehr guter Code und wahrscheinlich sogar das Gegenmuster des Klassendesigns, aber aus formaler Sicht erf√ºllt es das Liskov-Prinzip. <br><br>  Ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> .  Ein Set ist ein Subtyp eines Multisets.  Dies ist das Verh√§ltnis der Dom√§nenabstraktionen.  Der Code kann jedoch so geschrieben werden, dass wir die Set-Klasse von Bag erben und das Substitutionsprinzip verletzt wird, oder wir k√∂nnen so schreiben, dass das Prinzip eingehalten wird.  Mit der gleichen Fachdom√§nensemantik. <br><br>  Im Allgemeinen kann die Vererbung von Klassen als Implementierung der Beziehung ‚ÄûIS‚Äú betrachtet werden, jedoch nicht zwischen den Entit√§ten des Themenbereichs, sondern zwischen Klassen.  Ob die untergeordnete Klasse ein Subtyp der Basisklasse ist, h√§ngt davon ab, welche Einschr√§nkungen und Klassenverhaltensvertr√§ge der Clientcode verwendet (und im Prinzip verwenden kann). <br><br>  <b>Einschr√§nkungen, Invarianten und ein Basisklassenvertrag sind nicht im Code festgelegt, sondern in den K√∂pfen der Entwickler, die den Code bearbeiten und lesen.</b>  Was ‚Äûbricht‚Äú, was den ‚ÄûVertrag‚Äú bricht, wird nicht durch den Code bestimmt, sondern durch die Semantik der Klasse im Kopf des Entwicklers. <br><br>  Jeder Code, der f√ºr ein Objekt einer Basisklasse von Bedeutung ist, sollte nicht besch√§digt werden, wenn wir ihn durch ein Objekt einer untergeordneten Klasse ersetzen.  Sinnvoller Code ist jeder Client-Code, der ein Objekt einer Basisklasse (und deren Nachkommen) im Rahmen der Semantik und Einschr√§nkungen der Basisklasse verwendet. <br><br>  Es ist √§u√üerst wichtig zu verstehen, dass die Einschr√§nkungen der Abstraktion, die in der Basisklasse implementiert ist, normalerweise nicht im Programmcode enthalten sind.  Diese Einschr√§nkungen werden vom Entwickler verstanden, bekannt und unterst√ºtzt.  Es √ºberwacht die Konsistenz von Abstraktion und Code.  Damit der Code ausdr√ºckt, was er bedeutet. <br><br>  Ein Rechteck verf√ºgt beispielsweise √ºber eine andere Methode, die eine Ansicht in json zur√ºckgibt <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"height"</span></span>: self.height, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: self.width}</code> </pre><br>  Und in Square definieren wir es neu: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"size"</span></span>: self.height}</code> </pre><br>  Wenn wir den Grundvertrag f√ºr das Verhalten der Rectangle-Klasse to_json als H√∂he und Breite betrachten, dann den Code <br><br><pre> <code class="python hljs">r = rect.to_dict() log(r[<span class="hljs-string"><span class="hljs-string">'height'</span></span>], r[<span class="hljs-string"><span class="hljs-string">'width'</span></span>])</code> </pre><br>  ist f√ºr ein Objekt der Basisklasse Rectangle von Bedeutung.  Wenn ein Objekt einer Basisklasse durch eine Klasse ersetzt wird, √§ndert der Square-Erbencode sein Verhalten und verst√∂√üt gegen den Vertrag und damit gegen das Prinzip der Lisk-Substitution. <br><br>  Wenn wir glauben, dass der Grundvertrag f√ºr das Verhalten der Rectangle-Klasse lautet, dass to_dict ein W√∂rterbuch zur√ºckgibt, das serialisiert werden kann, ohne auf bestimmte Felder zu legen, ist eine solche to_dict-Methode in Ordnung. <br><br>  Dies ist √ºbrigens ein gutes Beispiel, das den Mythos zerst√∂rt, dass Unver√§nderlichkeit vor einer Verletzung des Prinzips bewahrt. <br><br>  Formal ist jedes √úberschreiben einer Methode in einer untergeordneten Klasse gef√§hrlich, ebenso wie √Ñnderungen an der Logik in der Basisklasse.  Beispielsweise passen sich die untergeordneten Klassen h√§ufig an das ‚Äûfalsche‚Äú Verhalten der Basisklasse an, und wenn der Fehler in der Basisklasse behoben ist, brechen sie ab. <br><br>  Es ist m√∂glich, alle Vertragsbedingungen und Invarianten so weit wie m√∂glich auf den Code zu √ºbertragen, aber im Allgemeinen liegt die Verhaltenssemantik dennoch au√üerhalb des Codes - im Problembereich und wird vom Entwickler unterst√ºtzt.  Das Beispiel zu to_dict ist ein Beispiel, in dem der Vertrag im Code beschrieben werden kann. Beispielsweise kann jedoch nicht √ºberpr√ºft werden, ob die Methode get_hash einen Hash mit allen Eigenschaften des Hash und nicht nur eine Zeile zur√ºckgibt. <br><br>  Wenn ein Entwickler Code verwendet, der von anderen Entwicklern geschrieben wurde, kann er die Semantik einer Klasse nur direkt anhand von Code, Methodennamen, Dokumentation und Kommentaren verstehen.  In jedem Fall ist die Semantik jedoch h√§ufig eine menschliche Dom√§ne und daher fehlerhaft.  Die wichtigste Konsequenz: Nur durch Code - syntaktisch - ist es unm√∂glich, die Einhaltung des Liskov-Prinzips zu √ºberpr√ºfen, und Sie m√ºssen sich auf (oft) vage Semantik verlassen.  Es gibt keine formalen (mathematischen) Mittel f√ºr eine √ºberpr√ºfbare und garantierte Methode zur √úberpr√ºfung einer starken Verhaltenstypisierung. <br><br>  Daher werden h√§ufig anstelle des Liskov-Prinzips formale Regeln f√ºr Vor- und Nachbedingungen aus der Vertragsprogrammierung verwendet: <br><br><ul><li>  Voraussetzungen in einer Unterklasse k√∂nnen nicht gest√§rkt werden - eine Unterklasse sollte nicht mehr als die Basisklasse erfordern </li><li>  Die Nachbedingungen der Unterklasse k√∂nnen nicht gelockert werden - die Unterklasse sollte nicht weniger als die Basisklasse liefern (versprechen) </li><li>  Invarianten der Basisklasse m√ºssen in der Nachkommenklasse erhalten bleiben. </li></ul><br>  Beispielsweise k√∂nnen wir in einer Nachkommenklassenmethode keinen erforderlichen Parameter hinzuf√ºgen, der nicht in der Basisklasse enthalten war, da auf diese Weise die Voraussetzungen gest√§rkt werden.  Oder wir k√∂nnen keine Ausnahmen in der √ºberschriebenen Methode ausl√∂sen, weil  die Invarianten der Basisklasse verletzen.  Usw. <br><br>  <b>Was z√§hlt, ist nicht das aktuelle Verhalten der Klasse, sondern welche Klassen√§nderungen die Verantwortung oder Semantik der Klasse implizieren.</b> <b><br></b> <br>  Der Code wird st√§ndig korrigiert und ge√§ndert.  Wenn der Code jetzt das Substitutionsprinzip erf√ºllt, bedeutet dies nicht, dass die √Ñnderungen im Code dies nicht √§ndern. <br><br>  Angenommen, es gibt einen Entwickler der Rectangle-Bibliotheksklasse und einen Anwendungsentwickler, der Square von Rectangle erbt.  In dem Moment, als der Anwendungsentwickler Square von Rectangle erbte - alles war in Ordnung, erf√ºllten die Klassen das Prinzip der Substitution. <br><br>  Und irgendwann f√ºgte der f√ºr die Bibliothek zust√§ndige Entwickler der Rectangle-Basisklasse eine Umformungs- oder set_width / set_height-Methode hinzu.  Aus seiner Sicht ist gerade eine Erweiterung der Basisklasse passiert.  Tats√§chlich gab es jedoch eine √Ñnderung in der Semantik und den Vertr√§gen, auf die sich die Nachkommenklasse st√ºtzte.  Jetzt erf√ºllen Klassen nicht mehr das Prinzip. <br><br>  Im Allgemeinen k√∂nnen beim Erben in OOP √Ñnderungen in der Basisklasse, die wie eine Erweiterung der Schnittstelle aussehen - eine andere Methode oder ein anderes Feld wird hinzugef√ºgt, fr√ºhere ‚Äûnat√ºrliche‚Äú Vertr√§ge verletzen und dadurch tats√§chlich die Semantik oder Verantwortlichkeiten √§ndern.  Daher ist das Hinzuf√ºgen einer Methode zur Basisklasse gef√§hrlich.  Sie k√∂nnen den Vertrag versehentlich versehentlich √§ndern. <br><br>  Aus praktischer Sicht ist es im Beispiel mit einem Rechteck und einer Klasse wichtig, ob es jetzt eine Umformungs- oder eine set_width / set_height-Methode gibt.  Aus praktischer Sicht ist es wichtig, wie hoch die Wahrscheinlichkeit solcher √Ñnderungen im Bibliothekscode ist.  Bedeutet die Semantik oder die Grenzen der Klassenverantwortung solche √Ñnderungen?  Wenn dies impliziert ist, ist die Wahrscheinlichkeit eines Fehlers und / oder eines weiteren Umgestaltungsbedarfs erheblich erh√∂ht.  Und wenn es auch nur eine kleine M√∂glichkeit gibt, ist es wahrscheinlich besser, solche Klassen nicht voneinander zu erben. <br><br>  <b>Das Verwalten von Subtypdefinitionen basierend auf dem Verhalten ist selbst f√ºr einfache Klassen mit klarer Semantik schwierig, ganz</b> zu schweigen von Unternehmen mit komplexer Gesch√§ftslogik.  Trotz der Tatsache, dass die Basisklasse und die Erbenklasse unterschiedliche Codeteile sind, m√ºssen Sie f√ºr sie die Schnittstellen und die Verantwortung sorgf√§ltig und sorgf√§ltig durchdenken.  Und selbst bei einer geringf√ºgigen √Ñnderung der Semantik der Klasse - die in keiner Weise vermieden werden kann - m√ºssen wir den Code verwandter Klassen √ºberpr√ºfen und pr√ºfen, ob der neue Vertrag oder die neue Invariante gegen das verst√∂√üt, was bereits geschrieben (!) Und verwendet wurde.  Bei fast jeder √Ñnderung in der Hierarchie der Verzweigungsklassen m√ºssen wir viele andere Codes suchen und √ºberpr√ºfen. <br><br>  Dies ist einer der Gr√ºnde, warum manche Menschen die klassische Vererbung in OOP nicht wirklich m√∂gen.  Und deshalb bevorzugen sie oft die Zusammensetzung von Klassen, die Vererbung von Schnittstellen usw. usw.  anstelle der klassischen Vererbung von Verhalten. <br><br>  Fairerweise gibt es einige Regeln, die h√∂chstwahrscheinlich nicht gegen das Substitutionsprinzip versto√üen.  Sie k√∂nnen sich so gut wie m√∂glich sch√ºtzen, wenn Sie alle gef√§hrlichen Strukturen verbieten.  Zum Beispiel hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oleg</a> f√ºr C ++ dar√ºber geschrieben.  Im Allgemeinen verwandeln solche Regeln Klassen jedoch nicht in Klassen im klassischen Sinne. <br><br>  Mit administrativen Methoden ist die Aufgabe auch nicht sehr gut gel√∂st.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier k√∂nnen</a> Sie lesen, wie Onkel Martin in C ++ war und wie es nicht funktionierte. <br><br>  <b>Aber im realen Industriekodex wird ziemlich oft das Liskov-Prinzip verletzt, und das ist nicht be√§ngstigend</b> .  Es ist schwierig, dem Prinzip zu folgen, weil  1) Die Verantwortung und Semantik einer Klasse sind oft nicht explizit und werden nicht im Code ausgedr√ºckt. 2) Die Verantwortung einer Klasse kann sich √§ndern - sowohl in der Basisklasse als auch in der Nachkommenklasse.  Dies f√ºhrt jedoch nicht immer zu wirklich schrecklichen Konsequenzen.  Die h√§ufigste, einfachste und grundlegendste Verletzung besteht darin, dass eine √ºberschriebene Methode das Verhalten √§ndert.  Wie zum Beispiel hier: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.status = CLOSED ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectTask</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status == STARTED: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Cannot close a started Project Task"</span></span>) ...</code> </pre><br>  Die Methode close von ProjectTask l√∂st eine Ausnahme aus, wenn die Objekte der Task-Klasse einwandfrei funktionieren.  Im Allgemeinen f√ºhrt die Neudefinition von Methoden einer Basisklasse sehr oft zu einer Verletzung des Substitutionsprinzips, wird jedoch nicht zum Problem. <br><br>  In diesem Fall sieht der Entwickler die Vererbung NICHT als Implementierung der IS-Beziehung, sondern lediglich als M√∂glichkeit, den Code wiederzuverwenden.  Das hei√üt,  Eine Unterklasse ist nur eine Unterklasse, kein Untertyp.  In diesem Fall ist es aus pragmatischer und praktischer Sicht wichtiger - aber wie hoch ist die Wahrscheinlichkeit, dass Client-Code vorhanden ist oder bereits vorhanden ist, der unterschiedliche Semantiken der Methoden der Nachkommenklasse und der Basisklasse feststellt? <br><br>  Gibt es viel Code, der ein Objekt einer Basisklasse erwartet, an den wir aber das Objekt der untergeordneten Klasse √ºbergeben?  F√ºr viele Aufgaben wird ein solcher Code √ºberhaupt nicht existieren. <br><br>  Wann f√ºhrt eine LSP-Verletzung zu gro√üen Problemen?  Wenn aufgrund von Verhaltensunterschieden der Client-Code mit √Ñnderungen in der Nachkommenklasse neu geschrieben werden muss und umgekehrt.  Dies ist insbesondere dann ein Problem, wenn dieser Clientcode ein Bibliothekscode ist, der nicht ge√§ndert werden kann.  Wenn die Wiederverwendung des Codes in Zukunft keine Abh√§ngigkeiten zwischen dem Clientcode und dem Klassencode mehr erzeugen kann, kann ein solcher Code trotz der Verletzung des Liskov-Substitutionsprinzips keine gro√üen Probleme verursachen. <br><br>  Im Allgemeinen kann die Vererbung w√§hrend der Entwicklung aus zwei Perspektiven betrachtet werden: Unterklassen sind Untertypen mit allen Einschr√§nkungen der Vertragsprogrammierung und des Lisk-Prinzips, und Unterklassen sind eine M√∂glichkeit, Code mit all seinen potenziellen Problemen wiederzuverwenden.  Das hei√üt,  Sie k√∂nnen entweder Klassenverantwortlichkeiten und -vertr√§ge denken und entwerfen und sich nicht um den Clientcode k√ºmmern.  Denken Sie entweder dar√ºber nach, was clientseitiger Code sein k√∂nnte, wie Klassen verwendet werden, und seien Sie auf potenzielle Probleme vorbereitet, aber in geringerem Ma√üe ist es wichtig, das Substitutionsprinzip einzuhalten.  Die Entscheidung liegt wie √ºblich beim Entwickler. Das Wichtigste ist, dass die Wahl in einer bestimmten Situation bewusst ist und dass ein Verst√§ndnis daf√ºr besteht, welche Vor-, Nachteile und Fallstricke mit dieser oder jener L√∂sung einhergehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463385/">https://habr.com/ru/post/de463385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463367/index.html">Maschinelles Lernen und Theorie der Zw√§nge</a></li>
<li><a href="../de463369/index.html">√úber Dienstleistungen f√ºr Arzttermine</a></li>
<li><a href="../de463371/index.html">IT au√üerhalb von Moskau</a></li>
<li><a href="../de463373/index.html">UX Design Portfolio: Best Practices</a></li>
<li><a href="../de463375/index.html">Wein unter Windows 10. Es funktioniert</a></li>
<li><a href="../de463387/index.html">Pfad QA K√§mpfer</a></li>
<li><a href="../de463389/index.html">Personalisieren Sie es: Wie wir mit QIWI-Empfehlungen arbeiten</a></li>
<li><a href="../de463391/index.html">Wie man jeden heiratet (ein-, zwei- und dreigeschlechtliche Ehe) aus mathematischer Sicht und warum M√§nner immer gewinnen</a></li>
<li><a href="../de463393/index.html">Ist Ihr Unternehmen eine Familie oder eine Sportmannschaft?</a></li>
<li><a href="../de463397/index.html">Devisenmarkt und Financial Engineering im Mittelalter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>