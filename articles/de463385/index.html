<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 👧🏼 🛋️ Noch einmal zum Prinzip der Lisk-Substitution oder zur Semantik der Vererbung in OOP 🐪 📻 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vererbung ist eine der Säulen von OOP. Vererbung wird verwendet, um allgemeinen Code wiederzuverwenden. Allgemeiner Code ist jedoch nicht immer für di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal zum Prinzip der Lisk-Substitution oder zur Semantik der Vererbung in OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463385/"> <b>Vererbung ist eine der Säulen von OOP.</b>  Vererbung wird verwendet, um allgemeinen Code wiederzuverwenden.  Allgemeiner Code ist jedoch nicht immer für die Wiederverwendung erforderlich, und Vererbung ist nicht immer der beste Weg, um Code wiederzuverwenden.  Es stellt sich oft heraus, dass es einen ähnlichen Code in zwei verschiedenen Codeteilen (Klassen) gibt, aber die Anforderungen für sie sind unterschiedlich, d.h.  Klassen erben tatsächlich voneinander und sind es möglicherweise nicht wert. <br><a name="habracut"></a><br>  Verwenden Sie zur Veranschaulichung dieses Problems normalerweise das Beispiel zum Erben der Square-Klasse von der Rectangle-Klasse oder umgekehrt. <br><br>  Lassen Sie uns eine Rechteckklasse haben: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._width * self._height ...</code> </pre> <br>  Jetzt wollten wir die Square-Klasse schreiben, aber um den Flächenberechnungscode wiederzuverwenden, erscheint es logisch, das Square vom Rechteck zu erben: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._width = height self._height = height</code> </pre><br>  Es scheint, dass der Code der Klassen Square und Rectangle konsistent ist.  Es scheint, dass Square die mathematischen Eigenschaften des Quadrats beibehält, d.h.  und ein Rechteck.  Das heißt, wir können quadratische Objekte anstelle von Rechteck übergeben. <br><br>  Wenn wir dies tun, können wir das <i>Verhalten</i> der Rectangle-Klasse verletzen: <br><br>  Zum Beispiel gibt es einen Client-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect)</span></span></span><span class="hljs-function">:</span></span> rect.set_height(<span class="hljs-number"><span class="hljs-number">10</span></span>) rect.set_width(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> rect.get_area() == <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre><br>  Wenn Sie dieser Funktion eine Instanz der Square-Klasse als Argument übergeben, verhält sich die Funktion anders.  Dies ist eine Vertragsverletzung für das Verhalten der Rectangle-Klasse, da Aktionen mit einem Objekt der Basisklasse genau das gleiche Ergebnis liefern sollten wie mit dem Objekt der untergeordneten Klasse. <br><br>  Wenn die Quadratklasse ein Nachkomme der Rechteckklasse ist, wenn wir mit dem Quadrat arbeiten und die Methoden des Rechtecks ​​ausführen, sollten wir nicht einmal bemerken, dass es kein Rechteck ist. <br><br>  Sie können dieses Problem beispielsweise folgendermaßen beheben: <br><br><ol><li>  Machen Sie eine Zusicherung, die genau zur Klasse passt, oder machen Sie eine, wenn dies für verschiedene Klassen unterschiedlich funktioniert </li><li>  Machen Sie in Square die Methode set_size () und überschreiben Sie die Methoden set_height und set_width, sodass sie Ausnahmen auslösen <br>  etc etc. </li></ol><br>  Solcher Code und solche Klassen funktionieren in dem Sinne, dass der Code funktioniert. <br><br>  Eine andere Frage ist, dass der Clientcode, der die Square-Klasse oder die Rectangle-Klasse verwendet, entweder über die Basisklasse und ihr Verhalten oder über die untergeordnete Klasse und ihr Verhalten Bescheid wissen muss. <br><br>  Im Laufe der Zeit können wir das bekommen: <br><br><ul><li>  Die untergeordnete Klasse überschreibt die meisten Methoden </li><li>  Durch Refactoring oder Hinzufügen von Methoden zur Basisklasse wird der Code mithilfe von Nachkommen beschädigt </li><li>  In dem Code, der die Objekte der Basisklasse verwendet, gibt es ifs, die nach der Klasse des Objekts suchen, und das Verhalten für Nachkommen und die Basisklasse ist unterschiedlich </li></ul><br>  Es stellt sich heraus, dass der für die Basisklasse geschriebene Clientcode von der Implementierung der Basisklasse und der untergeordneten Klasse abhängt.  Das erschwert die Entwicklung im Laufe der Zeit erheblich.  Und OOP wurde nur erstellt, damit Sie die Basisklasse und die Nachkommenklasse unabhängig voneinander bearbeiten können. <br><br>  In den 80er Jahren des letzten Jahrhunderts haben wir festgestellt, dass die Klassenvererbung für die Wiederverwendung von Code gut funktioniert. Wir müssen sicher sein, dass die untergeordnete Klasse anstelle der Basisklasse verwendet werden kann.  Das heißt,  Vererbungssemantik - dies sollte nicht nur und weniger Daten als Verhalten sein.  Erben sollten das Verhalten der Basisklasse nicht "brechen". <br><br>  Tatsächlich ist dies das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Lisk-Substitution</a> oder das Prinzip der Bestimmung eines Subtyps basierend auf dem Verhalten starker Klassen: <b>Wenn Sie mindestens einen aussagekräftigen Code schreiben können, in dem das Ersetzen eines Basisklassenobjekts durch ein untergeordnetes Klassenobjekt ihn beschädigt, lohnt es sich nicht erben sie voneinander.</b>  Wir sollten das Verhalten der Basisklasse in Nachkommen erweitern und nicht wesentlich ändern.  Funktionen, die die Basisklasse verwenden, sollten in der Lage sein, Unterklassenobjekte zu verwenden, ohne es zu wissen.  Tatsächlich ist dies die Semantik der Vererbung in OOP. <br><br>  Im realen Industriekodex wird dringend empfohlen, diesem Prinzip zu folgen und die beschriebene Vererbungssemantik einzuhalten.  Und mit diesem Prinzip gibt es mehrere Feinheiten. <br><br>  <b>Das Prinzip sollte nicht mit Abstraktionen der Domänenebene zufrieden sein, sondern mit Code-Abstraktionen - Klassen.</b>  Aus geometrischer Sicht ist ein Quadrat ein Rechteck.  Aus Sicht der Klassenvererbungshierarchie hängt es von dem Verhalten ab, das wir von diesen Klassen benötigen, ob die Klasse eines Quadrats der Erbe des Klassenrechtecks ​​ist.  Kommt darauf an, wie und in welchen Situationen wir diesen Code verwenden. <br><br>  Wenn die Rectangle-Klasse nur zwei Methoden hat - Berechnen der Fläche und Rendern ohne die Möglichkeit des Neuzeichnens und Änderns der Größe -, erfüllt Square mit einem überschriebenen Konstruktor in diesem Fall das Lisky-Prinzip des Ersetzens. <br><br>  Das heißt,  solche Klassen erfüllen das Substitutionsprinzip: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Dies ist zwar natürlich kein sehr guter Code und wahrscheinlich sogar das Gegenmuster des Klassendesigns, aber aus formaler Sicht erfüllt es das Liskov-Prinzip. <br><br>  Ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> .  Ein Set ist ein Subtyp eines Multisets.  Dies ist das Verhältnis der Domänenabstraktionen.  Der Code kann jedoch so geschrieben werden, dass wir die Set-Klasse von Bag erben und das Substitutionsprinzip verletzt wird, oder wir können so schreiben, dass das Prinzip eingehalten wird.  Mit der gleichen Fachdomänensemantik. <br><br>  Im Allgemeinen kann die Vererbung von Klassen als Implementierung der Beziehung „IS“ betrachtet werden, jedoch nicht zwischen den Entitäten des Themenbereichs, sondern zwischen Klassen.  Ob die untergeordnete Klasse ein Subtyp der Basisklasse ist, hängt davon ab, welche Einschränkungen und Klassenverhaltensverträge der Clientcode verwendet (und im Prinzip verwenden kann). <br><br>  <b>Einschränkungen, Invarianten und ein Basisklassenvertrag sind nicht im Code festgelegt, sondern in den Köpfen der Entwickler, die den Code bearbeiten und lesen.</b>  Was „bricht“, was den „Vertrag“ bricht, wird nicht durch den Code bestimmt, sondern durch die Semantik der Klasse im Kopf des Entwicklers. <br><br>  Jeder Code, der für ein Objekt einer Basisklasse von Bedeutung ist, sollte nicht beschädigt werden, wenn wir ihn durch ein Objekt einer untergeordneten Klasse ersetzen.  Sinnvoller Code ist jeder Client-Code, der ein Objekt einer Basisklasse (und deren Nachkommen) im Rahmen der Semantik und Einschränkungen der Basisklasse verwendet. <br><br>  Es ist äußerst wichtig zu verstehen, dass die Einschränkungen der Abstraktion, die in der Basisklasse implementiert ist, normalerweise nicht im Programmcode enthalten sind.  Diese Einschränkungen werden vom Entwickler verstanden, bekannt und unterstützt.  Es überwacht die Konsistenz von Abstraktion und Code.  Damit der Code ausdrückt, was er bedeutet. <br><br>  Ein Rechteck verfügt beispielsweise über eine andere Methode, die eine Ansicht in json zurückgibt <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"height"</span></span>: self.height, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: self.width}</code> </pre><br>  Und in Square definieren wir es neu: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"size"</span></span>: self.height}</code> </pre><br>  Wenn wir den Grundvertrag für das Verhalten der Rectangle-Klasse to_json als Höhe und Breite betrachten, dann den Code <br><br><pre> <code class="python hljs">r = rect.to_dict() log(r[<span class="hljs-string"><span class="hljs-string">'height'</span></span>], r[<span class="hljs-string"><span class="hljs-string">'width'</span></span>])</code> </pre><br>  ist für ein Objekt der Basisklasse Rectangle von Bedeutung.  Wenn ein Objekt einer Basisklasse durch eine Klasse ersetzt wird, ändert der Square-Erbencode sein Verhalten und verstößt gegen den Vertrag und damit gegen das Prinzip der Lisk-Substitution. <br><br>  Wenn wir glauben, dass der Grundvertrag für das Verhalten der Rectangle-Klasse lautet, dass to_dict ein Wörterbuch zurückgibt, das serialisiert werden kann, ohne auf bestimmte Felder zu legen, ist eine solche to_dict-Methode in Ordnung. <br><br>  Dies ist übrigens ein gutes Beispiel, das den Mythos zerstört, dass Unveränderlichkeit vor einer Verletzung des Prinzips bewahrt. <br><br>  Formal ist jedes Überschreiben einer Methode in einer untergeordneten Klasse gefährlich, ebenso wie Änderungen an der Logik in der Basisklasse.  Beispielsweise passen sich die untergeordneten Klassen häufig an das „falsche“ Verhalten der Basisklasse an, und wenn der Fehler in der Basisklasse behoben ist, brechen sie ab. <br><br>  Es ist möglich, alle Vertragsbedingungen und Invarianten so weit wie möglich auf den Code zu übertragen, aber im Allgemeinen liegt die Verhaltenssemantik dennoch außerhalb des Codes - im Problembereich und wird vom Entwickler unterstützt.  Das Beispiel zu to_dict ist ein Beispiel, in dem der Vertrag im Code beschrieben werden kann. Beispielsweise kann jedoch nicht überprüft werden, ob die Methode get_hash einen Hash mit allen Eigenschaften des Hash und nicht nur eine Zeile zurückgibt. <br><br>  Wenn ein Entwickler Code verwendet, der von anderen Entwicklern geschrieben wurde, kann er die Semantik einer Klasse nur direkt anhand von Code, Methodennamen, Dokumentation und Kommentaren verstehen.  In jedem Fall ist die Semantik jedoch häufig eine menschliche Domäne und daher fehlerhaft.  Die wichtigste Konsequenz: Nur durch Code - syntaktisch - ist es unmöglich, die Einhaltung des Liskov-Prinzips zu überprüfen, und Sie müssen sich auf (oft) vage Semantik verlassen.  Es gibt keine formalen (mathematischen) Mittel für eine überprüfbare und garantierte Methode zur Überprüfung einer starken Verhaltenstypisierung. <br><br>  Daher werden häufig anstelle des Liskov-Prinzips formale Regeln für Vor- und Nachbedingungen aus der Vertragsprogrammierung verwendet: <br><br><ul><li>  Voraussetzungen in einer Unterklasse können nicht gestärkt werden - eine Unterklasse sollte nicht mehr als die Basisklasse erfordern </li><li>  Die Nachbedingungen der Unterklasse können nicht gelockert werden - die Unterklasse sollte nicht weniger als die Basisklasse liefern (versprechen) </li><li>  Invarianten der Basisklasse müssen in der Nachkommenklasse erhalten bleiben. </li></ul><br>  Beispielsweise können wir in einer Nachkommenklassenmethode keinen erforderlichen Parameter hinzufügen, der nicht in der Basisklasse enthalten war, da auf diese Weise die Voraussetzungen gestärkt werden.  Oder wir können keine Ausnahmen in der überschriebenen Methode auslösen, weil  die Invarianten der Basisklasse verletzen.  Usw. <br><br>  <b>Was zählt, ist nicht das aktuelle Verhalten der Klasse, sondern welche Klassenänderungen die Verantwortung oder Semantik der Klasse implizieren.</b> <b><br></b> <br>  Der Code wird ständig korrigiert und geändert.  Wenn der Code jetzt das Substitutionsprinzip erfüllt, bedeutet dies nicht, dass die Änderungen im Code dies nicht ändern. <br><br>  Angenommen, es gibt einen Entwickler der Rectangle-Bibliotheksklasse und einen Anwendungsentwickler, der Square von Rectangle erbt.  In dem Moment, als der Anwendungsentwickler Square von Rectangle erbte - alles war in Ordnung, erfüllten die Klassen das Prinzip der Substitution. <br><br>  Und irgendwann fügte der für die Bibliothek zuständige Entwickler der Rectangle-Basisklasse eine Umformungs- oder set_width / set_height-Methode hinzu.  Aus seiner Sicht ist gerade eine Erweiterung der Basisklasse passiert.  Tatsächlich gab es jedoch eine Änderung in der Semantik und den Verträgen, auf die sich die Nachkommenklasse stützte.  Jetzt erfüllen Klassen nicht mehr das Prinzip. <br><br>  Im Allgemeinen können beim Erben in OOP Änderungen in der Basisklasse, die wie eine Erweiterung der Schnittstelle aussehen - eine andere Methode oder ein anderes Feld wird hinzugefügt, frühere „natürliche“ Verträge verletzen und dadurch tatsächlich die Semantik oder Verantwortlichkeiten ändern.  Daher ist das Hinzufügen einer Methode zur Basisklasse gefährlich.  Sie können den Vertrag versehentlich versehentlich ändern. <br><br>  Aus praktischer Sicht ist es im Beispiel mit einem Rechteck und einer Klasse wichtig, ob es jetzt eine Umformungs- oder eine set_width / set_height-Methode gibt.  Aus praktischer Sicht ist es wichtig, wie hoch die Wahrscheinlichkeit solcher Änderungen im Bibliothekscode ist.  Bedeutet die Semantik oder die Grenzen der Klassenverantwortung solche Änderungen?  Wenn dies impliziert ist, ist die Wahrscheinlichkeit eines Fehlers und / oder eines weiteren Umgestaltungsbedarfs erheblich erhöht.  Und wenn es auch nur eine kleine Möglichkeit gibt, ist es wahrscheinlich besser, solche Klassen nicht voneinander zu erben. <br><br>  <b>Das Verwalten von Subtypdefinitionen basierend auf dem Verhalten ist selbst für einfache Klassen mit klarer Semantik schwierig, ganz</b> zu schweigen von Unternehmen mit komplexer Geschäftslogik.  Trotz der Tatsache, dass die Basisklasse und die Erbenklasse unterschiedliche Codeteile sind, müssen Sie für sie die Schnittstellen und die Verantwortung sorgfältig und sorgfältig durchdenken.  Und selbst bei einer geringfügigen Änderung der Semantik der Klasse - die in keiner Weise vermieden werden kann - müssen wir den Code verwandter Klassen überprüfen und prüfen, ob der neue Vertrag oder die neue Invariante gegen das verstößt, was bereits geschrieben (!) Und verwendet wurde.  Bei fast jeder Änderung in der Hierarchie der Verzweigungsklassen müssen wir viele andere Codes suchen und überprüfen. <br><br>  Dies ist einer der Gründe, warum manche Menschen die klassische Vererbung in OOP nicht wirklich mögen.  Und deshalb bevorzugen sie oft die Zusammensetzung von Klassen, die Vererbung von Schnittstellen usw. usw.  anstelle der klassischen Vererbung von Verhalten. <br><br>  Fairerweise gibt es einige Regeln, die höchstwahrscheinlich nicht gegen das Substitutionsprinzip verstoßen.  Sie können sich so gut wie möglich schützen, wenn Sie alle gefährlichen Strukturen verbieten.  Zum Beispiel hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oleg</a> für C ++ darüber geschrieben.  Im Allgemeinen verwandeln solche Regeln Klassen jedoch nicht in Klassen im klassischen Sinne. <br><br>  Mit administrativen Methoden ist die Aufgabe auch nicht sehr gut gelöst.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie lesen, wie Onkel Martin in C ++ war und wie es nicht funktionierte. <br><br>  <b>Aber im realen Industriekodex wird ziemlich oft das Liskov-Prinzip verletzt, und das ist nicht beängstigend</b> .  Es ist schwierig, dem Prinzip zu folgen, weil  1) Die Verantwortung und Semantik einer Klasse sind oft nicht explizit und werden nicht im Code ausgedrückt. 2) Die Verantwortung einer Klasse kann sich ändern - sowohl in der Basisklasse als auch in der Nachkommenklasse.  Dies führt jedoch nicht immer zu wirklich schrecklichen Konsequenzen.  Die häufigste, einfachste und grundlegendste Verletzung besteht darin, dass eine überschriebene Methode das Verhalten ändert.  Wie zum Beispiel hier: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.status = CLOSED ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectTask</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status == STARTED: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Cannot close a started Project Task"</span></span>) ...</code> </pre><br>  Die Methode close von ProjectTask löst eine Ausnahme aus, wenn die Objekte der Task-Klasse einwandfrei funktionieren.  Im Allgemeinen führt die Neudefinition von Methoden einer Basisklasse sehr oft zu einer Verletzung des Substitutionsprinzips, wird jedoch nicht zum Problem. <br><br>  In diesem Fall sieht der Entwickler die Vererbung NICHT als Implementierung der IS-Beziehung, sondern lediglich als Möglichkeit, den Code wiederzuverwenden.  Das heißt,  Eine Unterklasse ist nur eine Unterklasse, kein Untertyp.  In diesem Fall ist es aus pragmatischer und praktischer Sicht wichtiger - aber wie hoch ist die Wahrscheinlichkeit, dass Client-Code vorhanden ist oder bereits vorhanden ist, der unterschiedliche Semantiken der Methoden der Nachkommenklasse und der Basisklasse feststellt? <br><br>  Gibt es viel Code, der ein Objekt einer Basisklasse erwartet, an den wir aber das Objekt der untergeordneten Klasse übergeben?  Für viele Aufgaben wird ein solcher Code überhaupt nicht existieren. <br><br>  Wann führt eine LSP-Verletzung zu großen Problemen?  Wenn aufgrund von Verhaltensunterschieden der Client-Code mit Änderungen in der Nachkommenklasse neu geschrieben werden muss und umgekehrt.  Dies ist insbesondere dann ein Problem, wenn dieser Clientcode ein Bibliothekscode ist, der nicht geändert werden kann.  Wenn die Wiederverwendung des Codes in Zukunft keine Abhängigkeiten zwischen dem Clientcode und dem Klassencode mehr erzeugen kann, kann ein solcher Code trotz der Verletzung des Liskov-Substitutionsprinzips keine großen Probleme verursachen. <br><br>  Im Allgemeinen kann die Vererbung während der Entwicklung aus zwei Perspektiven betrachtet werden: Unterklassen sind Untertypen mit allen Einschränkungen der Vertragsprogrammierung und des Lisk-Prinzips, und Unterklassen sind eine Möglichkeit, Code mit all seinen potenziellen Problemen wiederzuverwenden.  Das heißt,  Sie können entweder Klassenverantwortlichkeiten und -verträge denken und entwerfen und sich nicht um den Clientcode kümmern.  Denken Sie entweder darüber nach, was clientseitiger Code sein könnte, wie Klassen verwendet werden, und seien Sie auf potenzielle Probleme vorbereitet, aber in geringerem Maße ist es wichtig, das Substitutionsprinzip einzuhalten.  Die Entscheidung liegt wie üblich beim Entwickler. Das Wichtigste ist, dass die Wahl in einer bestimmten Situation bewusst ist und dass ein Verständnis dafür besteht, welche Vor-, Nachteile und Fallstricke mit dieser oder jener Lösung einhergehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463385/">https://habr.com/ru/post/de463385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463367/index.html">Maschinelles Lernen und Theorie der Zwänge</a></li>
<li><a href="../de463369/index.html">Über Dienstleistungen für Arzttermine</a></li>
<li><a href="../de463371/index.html">IT außerhalb von Moskau</a></li>
<li><a href="../de463373/index.html">UX Design Portfolio: Best Practices</a></li>
<li><a href="../de463375/index.html">Wein unter Windows 10. Es funktioniert</a></li>
<li><a href="../de463387/index.html">Pfad QA Kämpfer</a></li>
<li><a href="../de463389/index.html">Personalisieren Sie es: Wie wir mit QIWI-Empfehlungen arbeiten</a></li>
<li><a href="../de463391/index.html">Wie man jeden heiratet (ein-, zwei- und dreigeschlechtliche Ehe) aus mathematischer Sicht und warum Männer immer gewinnen</a></li>
<li><a href="../de463393/index.html">Ist Ihr Unternehmen eine Familie oder eine Sportmannschaft?</a></li>
<li><a href="../de463397/index.html">Devisenmarkt und Financial Engineering im Mittelalter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>