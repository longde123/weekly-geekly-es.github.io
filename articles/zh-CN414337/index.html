<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴 ♒️ 👼🏿 Ramda风格思维：不变性与对象 💕 👎🏿 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.第一步 
 2.结合功能 
 3.部分使用（咖喱） 
 4.声明式编程 
 5.典型符号 
 6.不变性与对象 
 7.不变性和数组 
 8.镜片 
 9.结论 


 这篇文章是关于函数式编程的一系列文章的第六部分，该文章称为Ramda样式思维。 


 在第五部分中，我们讨论了以无意义表示法...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ramda风格思维：不变性与对象</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414337/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.第一步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.结合功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.部分使用（咖喱）</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.声明式编程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.典型符号</a> <br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.不变性与对象</a></strong> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.不变性和数组</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.镜片</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9.结论</a> </p><br><p> 这篇文章是关于函数式编程的一系列文章的第六部分，该文章称为Ramda样式思维。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分中，</a>我们讨论了以无意义表示法编写函数的方法，其中未明确指定带有函数数据的主参数。 </p><br><p> 那时，我们无法以一种毫无意义的方式重写所有函数，因为我们没有为此所需的某些工具。 现在该学习它们了。 <a name="habracut"></a></p><br>
<h2 id="chtenie-svoystv-obekta"> 读取对象属性 </h2><br><p> 让我们再次看一下在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分中</a>研究的具有投票权的人的定义示例： </p><br><pre><code class="plaintext hljs">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; person.age &gt;= 18 const isCitizen = either(wasBornInCountry, wasNaturalized) const isEligibleToVote = both(isOver18, isCitizen)</code> </pre> <br><p> 如您所见，我们使<code>isCitizen</code>和<code>isEligibleToVote</code> ，但是我们不能使用前三个功能来做到这一点。 </p><br><p> 正如我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a>中学到的，我们可以通过使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">equals</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gte</a>使我们的函数更具声明性。 让我们从这个开始： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; gte(person.age, 18)</code> </pre> <br><p> 为了使这些函数毫无意义，我们需要一种构造函数的方法，以便在表达式的末尾应用<code>person</code>变量。 问题在于，我们需要访问人的属性，现在我们知道执行此操作的唯一方法-这势在必行。 </p><br><h2 id="prop"> 道具 </h2><br><p> 幸运的是，Ramda再次帮助了我们。 它提供了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">prop</a>函数来访问对象的属性。 </p><br><p> 使用<code>prop</code> ，我们可以将<code>prop('birthCountry', person)</code>重写为<code>prop('birthCountry', person)</code> 。 让我们做吧： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(prop('birthCountry', person), OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p> 哇，现在看起来好多了。 但是，让我们继续进行重构。 让我们更改传递给<code>equals</code>的参数的顺序，以使<code>prop</code>在最后。  <code>equals</code>以完全相反的方式工作，因此我们不会破坏任何东西： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY, prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p> 接下来，让我们使用currying， <code>equals</code>和<code>gte</code>的自然属性，以便创建新的函数， <code>prop</code>调用的结果将应用于这些函数： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(__, 18)(prop('age', person))</code> </pre> <br><p> 它看起来仍然是最糟糕的选择，但让我们继续。 让我们为所有<code>prop</code>调用再次使用<code>prop</code> ： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry')(person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate')(person)) const isOver18 = person =&gt; gte(__, 18)(prop('age')(person))</code> </pre> <br><p> 再次，不知何故。 但是现在我们看到了一种熟悉的模式。 我们所有的函数都具有相同的图像<code>f(g(person))</code> ，从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a>我们知道，这等效于<code>compose(f, g)(person)</code> 。 </p><br><p> 让我们将此优势应用到我们的代码中： </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; compose(equals(OUR_COUNTRY), prop('birthCountry'))(person) const wasNaturalized = person =&gt; compose(Boolean, prop('naturalizationDate'))(person) const isOver18 = person =&gt; compose(gte(__, 18), prop('age'))(person)</code> </pre> <br><p> 现在我们得到了一些东西。 我们所有的函数看起来像<code>person =&gt; f(person)</code> 。 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分</a>我们已经知道我们可以使这些功能毫无意义。 </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry')) const wasNaturalized = compose(Boolean, prop('naturalizationDate')) const isOver18 = compose(gte(__, 18), prop('age'))</code> </pre> <br><p> 开始时，我们的方法做两件事并不明显。 他们转向对象的属性，并用其值准备了一些操作。 这种重构为毫无意义的样式使得这一点非常明确。 </p><br><p> 让我们看一下Ramda提供的用于处理对象的其他一些工具。 </p><br><h2 id="pick"> 挑选 </h2><br><p> 在<code>prop</code>读取对象的一个​​属性并返回其值的情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pick</a>从该对象读取许多属性，并仅与它们一起返回一个新对象。 </p><br><p> 例如，如果我们只需要人员的姓名和年份，则可以使用<code>pick(['name','age'], person)</code> 。 </p><br><h2 id="has"> 有 </h2><br><p> 如果我们只是想知道我们的对象具有一个属性，而不读取其值，则可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">has</a>函数检查其属性，以及使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hasIn</a>检查原型链： <code>has('name', person)</code> 。 </p><br><h2 id="path"> 路径 </h2><br><p> 在<code>prop</code>对象属性的地方， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">路径</a>更深入嵌套对象。 例如，我们想从更深的结构中提取邮政编码： <code>path(['address','zipCode'], person)</code> 。 </p><br><p> 请注意， <code>path</code>比<code>prop</code>更宽容。 如果路径中的任何内容（包括原始参数）为<code>null</code>或<code>undefined</code> ，则<code>path</code>将返回<code>undefined</code> ，而<code>prop</code>在这种情况下将导致错误。 </p><br><h2 id="propor--pathor"> 属性/路径或 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">propOr</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pathOr</a>类似于<code>prop</code>和<code>path</code>结合了<code>defaultTo</code> 。 它们使您能够为在所研究的对象中找不到的属性或路径指定默认值。 </p><br><p> 例如，当我们不知道人的名字时，我们可以提供一个占位符： <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> 。 注意与<code>prop</code>不同的是，如果<code>person</code>为<code>null</code>或<code>undefined</code> ， <code>propOr</code>不会导致错误; 相反，它将返回默认值。 </p><br><h2 id="keys--values"> 键/值 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">键</a>返回一个包含对象所有已知属性的所有名称的数组。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">值</a>将返回这些属性的值。 将这些功能与集合的迭代功能结合使用时，这些功能会很有用，我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中已经</a>了解了这些功能。 </p><br><h2 id="dobavlenie-obnovlenie-i-udalenie-svoystv"> 添加，更新和删除属性 </h2><br><p> 现在，我们有许多用于以声明式读取对象的工具，但是进行更改又如何呢？ </p><br><p> 由于不变性对我们很重要，因此我们不想直接修改对象。 相反，我们要返回以所需方式更改的新对象。 </p><br><p>  Ramda再次为我们提供了许多好处。 </p><br><h2 id="assoc--assocpath">  assoc / assocPath </h2><br><p> 当我们以命令式风格进行编程时，我们可以通过赋值运算符设置或更改人员的姓名： <code>person.name = 'New name'</code> 。 </p><br><p> 在功能不变的世界中，我们可以改用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">assoc</a> ： <code>const updatedPerson = assoc('name', 'newName', person)</code> 。 </p><br><p>  <code>assoc</code>返回具有添加或更新的属性值的新对象，而原始对象保持不变。 </p><br><p> 我们还可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">assocPath</a>来更新附加属性： <code>const updatedPerson = assocPath(['address', 'zipCode'], '97504', person)</code> 。 </p><br><h2 id="dissoc--dissocpath--omit">  dissoc / dissocPath /省略 </h2><br><p> 删除属性呢？ 势在必行，我们可能想说一下<code>delete person.age</code> 。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ramda中</a> ，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dissoc</a> ：`const UpdatedPerson = dissoc（'age'，person） </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dissocPath</a>大致相同，但适用于更深的对象结构： <code>dissocPath(['address', 'zipCode'], person)</code> 。 </p><br><p> 我们还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">omit</a> ，它可以一次删除多个属性： <code>const updatedPerson = omit(['age', 'birthCountry'], person)</code> 。 </p><br><p> 请注意， <code>pick</code>和<code>omit</code>有些相似，并且可以很好地互补。 它们对于白名单（使用<code>pick</code>只保存某些属性集）和黑名单（通过使用<code>omit</code>摆脱某些属性）非常方便。 </p><br><h2 id="transformaciya-obektov"> 对象转换 </h2><br><p> 现在我们已经足够了解以声明性和不可变样式处理对象。 让我们编写一个<code>celebrateBirthday</code>函数，以更新该人生日的年龄。 </p><br><pre> <code class="plaintext hljs">const nextAge = compose(inc, prop('age')) const celebrateBirthday = person =&gt; assoc('age', nextAge(person), person)</code> </pre> <br><p> 这是非常常见的模式。 就像我们在此处所做的那样，我们确实希望通过将函数应用于旧值来更改值，而不是使用新值更新属性。 </p><br><p> 我不知道拥有一种我们早已学过的工具，以较少的重复性和较不严格的样式编写此书的好方法。 </p><br><p>  Ramda再次为我们节省了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演进</a>功能。  <code>evolve</code>接受一个对象，并允许您为我们要更改的属性指定转换函数。 让我们来<code>celebrateBirthday</code> ： </p><br><pre> <code class="plaintext hljs">const celebrateBirthday = evolve({ age: inc })</code> </pre> <br><p> 这段代码说，我们将通过创建具有相同属性和值的新对象来转换指定的对象（由于强力样式而不会显示），但是<code>age</code>属性将通过将<code>inc</code>应用于<code>age</code>属性的原始值来获得。 </p><br><p>  <code>evolve</code>可以一次转换许多属性，甚至可以在多层嵌套中进行转换。 使用指定形式的转换函数，对象的转换可以具有与可变对象相同的图像，并且<code>evolve</code>将在结构之间递归传递。 </p><br><p> 请注意， <code>evolve</code>不会添加新属性。 如果为正在处理的对象中未发生的属性指定转换，则<code>evolve</code>只会忽略它。 </p><br><p> 我发现， <code>evolve</code>迅速成为我应用程序中的主力军。 </p><br><h2 id="sliyanie-obektov"> 合并物件 </h2><br><p> 有时您需要将两个对象组合在一起。 典型的情况是，当您有一个使用命名选项的函数，并且想要将它们与默认选项结合在一起时。  Ramda为此提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合并</a>功能。 </p><br><pre> <code class="plaintext hljs">function f(a, b, options = {}) { const defaultOptions = { value: 42, local: true } const finalOptions = merge(defaultOptions, options) }</code> </pre> <br><p>  <code>merge</code>返回一个新对象，其中包含两个对象的所有属性和值。 如果两个对象具有相同的属性，则将获取第二个参数的值。 </p><br><p> 该规则与第二个论点的胜利使使用<code>merge</code>作为独立工具具有意义，但在输送机情况下意义不大。 在这种情况下，您通常需要为对象准备一系列转换，而这样的转换之一就是一些新属性值的并集。 在这种情况下，您将希望第一个参数获胜，而不是第二个。 </p><br><p> 尝试仅在管道中使用<code>merge(newValues)</code>不会给出我们想要的结果。 </p><br><p> 对于这种情况，我通常创建自己的实用程序<code>reverseMerge</code> 。 它可以写成<code>const reverseMerge = flip(merge)</code> 。  <code>flip</code>调用交换适用于该函数的前两个参数。 </p><br><p>  <code>merge</code>执行表面合并。 如果对象组合在一起时具有其值为子对象的属性，则这些子对象不会合并。 <del>  Ramda目前不具备深度合并功能 </del>  （ <em>我要翻译</em>的<em>原始文章已经有关于此主题的过时信息。如今， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ramda</a>具有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mergeDeepLeft</a> ，用于递归深度合并对象的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mergeDeepRight</a>以及其他用于合并的方法</em> ）。 </p><br><p> 请注意， <code>merge</code>仅接受两个参数。 如果要将多个对象组合为一个，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mergeAll</a> ，它采用一组对象进行组合。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 今天，我们有了一套出色的工具，用于以声明性和不变的方式处理对象。 现在我们可以读取，添加，更新，删除和转换对象中的属性，而无需更改原始对象。 而且，我们可以采用一种轻松实现彼此组合功能的风格来完成所有这些事情。 </p><br><h2 id="dalee"> 下一个 </h2><br><p> 现在我们可以使用不可变样式的对象，但是数组呢？  “免疫和阵列”将告诉我们如何处理它们。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414337/">https://habr.com/ru/post/zh-CN414337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414325/index.html">问伊森：也许缺失的反物质隐藏在黑洞中？</a></li>
<li><a href="../zh-CN414327/index.html">什么是抑郁症？为什么它会更频繁地发生？</a></li>
<li><a href="../zh-CN414329/index.html">“幸存者”究竟在为什么做准备？</a></li>
<li><a href="../zh-CN414331/index.html">科学家会找到没有出现在地球上的生命吗？</a></li>
<li><a href="../zh-CN414335/index.html">背景 Roskomnadzor，你是什么？</a></li>
<li><a href="../zh-CN414339/index.html">莫斯科联合办公新地点#tceh的精彩照片之旅</a></li>
<li><a href="../zh-CN414341/index.html">＃256移动开发人员的有趣材料摘要（6月3日至12日）</a></li>
<li><a href="../zh-CN414343/index.html">Google神经机器翻译</a></li>
<li><a href="../zh-CN414345/index.html">反向开发时间开关VL-76-S</a></li>
<li><a href="../zh-CN414347/index.html">被动侵略：它如何破坏我们的工作生活以及如何应对</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>