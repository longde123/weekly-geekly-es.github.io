<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‡ğŸ¾ ğŸ¤¹ğŸ½ ğŸ”£ Disk Cache Pohon Komputasi Malas ğŸ¿ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ™ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konsep komputasi malas hampir tidak layak dibicarakan secara rinci. Gagasan untuk melakukan hal yang sama lebih jarang, terutama jika itu panjang dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Disk Cache Pohon Komputasi Malas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422937/"><p>  Konsep komputasi malas hampir tidak layak dibicarakan secara rinci.  Gagasan untuk melakukan hal yang sama lebih jarang, terutama jika itu panjang dan sulit, sama tuanya dengan dunia.  Karena langsung to the point. </p><br><p>  Menurut penulis teks ini, seorang pemberi penjelasan yang normal harus: </p><br><ol><li>  Simpan penghitungan antara panggilan program. </li><li>  Lacak perubahan di pohon perhitungan. </li><li>  Memiliki sintaksis yang cukup transparan. </li></ol><br><p><img src="https://habrastorage.org/webt/de/dw/ec/dedwectoekaqhwzkercd2dgnk1u.jpeg" alt="Pohon malas"></p><a name="habracut"></a><br><h2 id="koncepciya">  Konsep </h2><br><p>  Dalam rangka: </p><br><ol><li> Simpan penghitungan antara panggilan program: <br>  Memang, jika kita memanggil skrip yang sama beberapa puluh ratusan kali sehari, mengapa kita harus menghitung ulang hal yang sama setiap kali skrip dipanggil, jika memungkinkan untuk menyimpan objek hasil dalam file.  Lebih baik menarik objek dari disk, tetapi ... kita harus yakin akan relevansinya.  Tiba-tiba skrip ditulis ulang dan objek yang disimpan kedaluwarsa.  Berdasarkan hal ini, kita tidak bisa hanya memuat objek berdasarkan keberadaan file.  Poin kedua mengikuti dari ini. </li><li>  Lacak perubahan di pohon perhitungan: <br>  Kebutuhan untuk memperbarui objek harus dihitung berdasarkan data tentang argumen fungsi yang menghasilkannya.  Jadi kami akan memastikan bahwa objek yang dimuat valid.  Memang, untuk fungsi murni, nilai kembali hanya bergantung pada argumen.  Ini berarti bahwa sementara kami menyimpan hasil dari fungsi murni dan memantau perubahan argumen, kami bisa tenang tentang relevansi cache.  Pada saat yang sama, jika objek yang dihitung bergantung pada objek cache lainnya (malas), yang pada gilirannya tergantung pada objek lain, Anda perlu mengetahui perubahan-perubahan pada objek-objek ini dengan tepat, memperbarui tepat waktu node rantai yang tidak lagi relevan.  Di sisi lain, alangkah baiknya untuk memperhitungkan bahwa kita tidak selalu perlu memuat data dari seluruh rantai perhitungan.  Seringkali, hanya memuat objek hasil akhir sudah cukup. </li><li>  Memiliki sintaksis yang cukup transparan: <br>  Poin ini jelas.  Jika untuk menulis ulang skrip ke perhitungan malas perlu mengubah seluruh kode, ini adalah solusi begitu-begitu.  Perubahan harus dilakukan seminimal mungkin. </li></ol><br><p>  Garis pemikiran ini mengarah pada solusi teknis, ditata dalam python oleh perpustakaan evalcache (tautan di akhir artikel). </p><br><h2 id="sintaksicheskoe-reshenie-i-mehanizm-raboty">  Solusi sintaksis dan mekanisme kerja </h2><br><div class="spoiler">  <b class="spoiler_title">Contoh sederhana</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> evalcache <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shelve lazy = evalcache.Lazy(cache = shelve.open(<span class="hljs-string"><span class="hljs-string">".cache"</span></span>), algo = hashlib.sha256) @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * a a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = sqr(<span class="hljs-number"><span class="hljs-number">2</span></span>) c = lazy(<span class="hljs-number"><span class="hljs-number">3</span></span>) lazyresult = summ(a, b, c) result = lazyresult.unlazy() print(lazyresult) <span class="hljs-comment"><span class="hljs-comment">#f8a871cd8c85850f6bf2ec96b223de2d302dd7f38c749867c2851deb0b24315c print(result) #8</span></span></code> </pre> </div></div><br><p>  Bagaimana cara kerjanya? </p><br><p>  Hal pertama yang menarik perhatian Anda di sini adalah penciptaan dekorator malas.  Solusi sintaksis semacam itu cukup standar untuk Python python.  Dekorator malas melewati objek cache di mana lenificator akan menyimpan hasil perhitungan.  Persyaratan antarmuka seperti dict ditumpangkan pada jenis cache.  Dengan kata lain, kita dapat men-cache semua yang mengimplementasikan antarmuka yang sama dengan tipe dict.  Untuk menunjukkan dalam contoh di atas, kami menggunakan kamus dari perpustakaan rak. </p><br><p>  Dekorator juga mengirim protokol hash, yang akan ia gunakan untuk membuat kunci hash objek dan beberapa opsi tambahan (izin tulis, izin baca, hasil debug), yang dapat ditemukan dalam dokumentasi atau kode. </p><br><p>  Dekorator dapat diterapkan untuk fungsi dan objek dari jenis lain.  Pada saat ini, objek malas dibangun atas dasar mereka dengan kunci hash yang dihitung berdasarkan representasi (atau menggunakan fungsi hash yang didefinisikan secara khusus untuk jenis fungsi ini). </p><br><p>  Fitur utama dari perpustakaan adalah bahwa objek malas dapat menghasilkan objek malas lainnya, dan hash orang tua (atau orang tua) akan dicampur menjadi kunci hash keturunan.  Untuk objek yang malas, diizinkan untuk menggunakan operasi mengambil atribut, menggunakan panggilan ( <code>__call__</code> ) objek, dan menggunakan operator. </p><br><p>  Saat melewati skrip, pada kenyataannya, tidak ada perhitungan yang dilakukan.  Untuk b, kuadratnya tidak dihitung, dan untuk lazyresult, jumlah argumen tidak dipertimbangkan.  Sebagai gantinya, pohon operasi dibangun dan kunci hash objek malas dihitung. </p><br><p>  Perhitungan nyata (jika hasilnya sebelumnya tidak dimasukkan ke dalam cache) akan dilakukan hanya di baris: <code>result = lazyresult.unlazy()</code> </p><br><p>  Jika objek sebelumnya dihitung, itu akan diambil dari file. <br>  Anda dapat memvisualisasikan pohon build: </p><br><div class="spoiler">  <b class="spoiler_title">Membangun visualisasi pohon</b> <div class="spoiler_text"><pre> <code class="python hljs">evalcache.print_tree(lazyresult) ... generic: &lt;function summ at <span class="hljs-number"><span class="hljs-number">0x7f1cfc0d5048</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">1</span></span> generic: &lt;function sqr at <span class="hljs-number"><span class="hljs-number">0x7f1cf9af29d8</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">2</span></span> ------- <span class="hljs-number"><span class="hljs-number">3</span></span> -------</code> </pre> </div></div><br><p>  Karena hash objek dibangun berdasarkan data pada argumen yang menghasilkan objek-objek ini, ketika argumen berubah, hash objek berubah dan disertai hash seluruh rantai tergantung padanya.  Ini memungkinkan Anda untuk tetap memperbarui data cache dengan membuat pembaruan tepat waktu. </p><br><p>  Objek malas berbaris di pohon.  Jika kita melakukan operasi yang tidak benar pada salah satu objek, persis seperti banyak objek akan dimuat dan dihitung seperlunya untuk mendapatkan hasil yang valid.  Idealnya, objek yang diperlukan hanya akan memuat.  Dalam hal ini, algoritma tidak akan menarik objek membentuk ke dalam memori. </p><br><h2 id="v-deystvii">  Beraksi </h2><br><p>  Di atas adalah contoh sederhana yang menunjukkan sintaks tetapi tidak menunjukkan kekuatan komputasi dari pendekatan. <br>  Berikut adalah contoh yang sedikit lebih dekat dengan kehidupan nyata (digunakan oleh sympy). </p><br><div class="spoiler">  <b class="spoiler_title">Contoh menggunakan sympy dan numpy</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3.5 from sympy import * import numpy as np import math import evalcache lazy = evalcache.Lazy(evalcache.DirCache(".evalcache"), diag = True) pj1, psi, y0, gamma, gr= symbols("pj1 psi y0 gamma gr") ###################### Construct sympy expression ##################### F = 2500 xright = 625 re = 625 y0 = 1650 gr = 2*math.pi / 360 #gamma = pi / 2 xj1q = xright + re * (1 - cos(psi)) yj1q = (xright + re) * tan(psi) - re * sin(psi) #+ y0 pj1 = sqrt(xj1q**2 + yj1q**2) pj2 = pj1 + y0 * sin(psi) zj2 = (pj2**2)/4/F asqrt = sqrt(pj2**2 + 4*F**2) xp2 = 2*F / asqrt yp2 = pj2 / asqrt xp3 = yp2 yp3 = -xp2 xmpsi = 1295 gmpsi = 106 * gr aepsi = 600 bepsi = 125 b = 0.5*(1-cos(pi * gamma / gmpsi)) p1 = ( (gamma * xmpsi / gmpsi * xp2) * (1-b) + (aepsi * xp2 * sin(gamma) + bepsi * yp2 * (1-cos(gamma)))*b + pj1 ) ####################################################################### #First lazy node. Simplify is long operation. #Sympy has very good representations for expressions print("Expression:", repr(p1)) print() p1 = lazy(simplify)(p1) ######################################################################################### ## Really don't need to lazify fast operations Na = 200 angles = [t * 2 * math.pi / 360 / Na * 106 for t in range(0,Na+1)] N = int(200) a = (np.arange(0,N+1) - N/2) * 90/360*2*math.pi/N ######################################################################################### @lazy def genarray(angles, a, p1): points = [] for i in range(0, len(angles)): ex = p1.subs(gamma, angles[i]) func = lambdify(psi, ex, 'numpy') # returns a numpy-ready function rads = func(a) xs = rads*np.cos(a) ys = rads*np.sin(a) arr = np.column_stack((xs,ys,[i*2]*len(xs))) points.append(arr) return points #Second lazy node. arr = genarray(angles, a, p1).unlazy() print("\nResult list:", arr.__class__, len(arr))</span></span></code> </pre> </div></div><br><p>  Operasi untuk menyederhanakan ekspresi simbolik sangat mahal dan benar-benar meminta lenifikasi.  Pembangunan lebih lanjut dari array besar bahkan lebih lama, tetapi berkat lenifikasi, hasilnya akan ditarik dari cache.  Harap perhatikan bahwa jika ada koefisien yang diubah di bagian atas skrip tempat ekspresi sympy dihasilkan, hasilnya akan dihitung ulang karena kunci hash objek malas akan berubah (berkat pernyataan <code>__repr__</code> keren). </p><br><p>  Cukup sering, situasi terjadi ketika seorang peneliti melakukan eksperimen komputasi pada objek yang dihasilkan lama.  Ini dapat menggunakan beberapa skrip untuk memisahkan pembuatan dan penggunaan objek, yang dapat menyebabkan masalah dengan pembaruan data yang tidak tepat waktu.  Pendekatan yang diusulkan dapat memfasilitasi kasus ini. </p><br><h2 id="radi-chego-vsyo-zatevalos">  Tentang apa semua ini? </h2><br><p>  evalcache adalah bagian dari proyek zencad.  Ini adalah skrip skrip kecil, menginspirasi dan mengeksploitasi ide yang sama dengan openscad.  Tidak seperti openscad yang berorientasi mesh, zencad yang berjalan pada inti opencascade menggunakan representasi brep dari objek, dan skrip ditulis dengan python. </p><br><p>  Operasi geometris sering dilakukan untuk waktu yang lama.  Kerugian dari sistem skrip cad adalah bahwa setiap kali Anda menjalankan skrip, produk tersebut benar-benar diceritakan kembali.  Selain itu, dengan pertumbuhan dan komplikasi model, biaya overhead tidak tumbuh secara linear.  Ini mengarah pada fakta bahwa Anda dapat bekerja dengan nyaman hanya dengan model yang sangat kecil. </p><br><p>  Tugas evalcache adalah merapikan masalah ini.  Di zencad, semua operasi dinyatakan malas. </p><br><p>  Contoh: </p><br><div class="spoiler">  <b class="spoiler_title">Contoh membangun model</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 #coding: utf-8 from zencad import * xgate = 14.65 ygate = 11.6 zgate = 11 t = (xgate - 11.7) / 2 ear_r = 8.6/2 ear_w = 7.8 - ear_r ear_z = 3 hx_h = 2.0 bx = xgate + ear_w by = 2 bz = ear_z+1 gate = ( box(xgate, ygate, t).up(zgate - t) + box(t, ygate, zgate) + box(t, ygate, zgate).right(xgate - t) ) gate = gate.fillet(1, [5, 23,29, 76]) gate = gate.left(xgate/2) ear = (box(ear_w, ear_r * 2, ear_z) + cylinder(r = ear_r, h = ear_z).forw(ear_r).right(ear_w)).right(xgate/2 - t) hx = linear_extrude( ngon(r = 2.5, n = 6).rotateZ(deg(90)).forw(ear_r), hx_h ).up(ear_z - hx_h).right(xgate/2 -t + ear_w) m = ( gate + ear + ear.mirrorYZ() - hx - hx.mirrorYZ() - box(xgate-2*t, ygate, zgate, center = True).forw(ygate/2) - box(bx, by, bz, center = True).forw(ear_r).up(bz/2) - cylinder(r = 2/2, h = 100, center = True).right(xgate/2-t+ear_w).forw(ear_r) - cylinder(r = 2/2, h = 100, center = True).left(xgate/2-t+ear_w).forw(ear_r) ) display(m) show()</span></span></code> </pre> <br><p>  Script ini menghasilkan model berikut: <br><img src="https://habrastorage.org/webt/np/4i/go/np4igo9nth8jdmuplhz6pd2o9mg.png"><br>  Perhatikan bahwa tidak ada panggilan evalcache di skrip.  Kuncinya adalah bahwa lenifikasi tertanam di perpustakaan zencad itu sendiri dan bahkan tidak terlihat pada pandangan pertama, meskipun semua pekerjaan di sini bekerja dengan benda-benda malas, dan perhitungan langsung dilakukan hanya dalam fungsi 'tampilan'.  Tentu saja, jika beberapa parameter model diubah, model akan dihitung ulang dari tempat di mana kunci hash pertama berubah. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Model Komputasi Besar</b> <div class="spoiler_text"><p>  Ini adalah contoh lain.  Kali ini kami akan membatasi diri pada gambar: <br><img src="https://habrastorage.org/webt/go/3f/zu/go3fzuma_btpyqlvqsb8zxnc6qc.png"><br>  Perhitungan permukaan berulir bukanlah tugas yang mudah.  Di komputer saya, baut seperti itu dibangun di atas urutan sepuluh detik ... Mengedit model dengan ulir jauh lebih menyenangkan menggunakan caching. </p><br><p>  Dan sekarang ini adalah keajaiban: <br><img src="https://habrastorage.org/webt/ux/qs/kc/uxqskci0b_u_3cfdghkpdliygou.png"><br>  Melintasi permukaan berulir adalah tugas komputasi yang kompleks.  Nilai praktis, bagaimanapun, tidak lain adalah memeriksa matematika.  Perhitungannya membutuhkan satu setengah menit.  Tujuan yang layak untuk lenifikasi. </p></div></div><br><h2 id="problemy">  Masalahnya </h2><br><p>  Cache mungkin tidak berfungsi sebagaimana dimaksud. <br>  Kesalahan cache dapat dibagi menjadi <strong>false positif</strong> dan <strong>false negatif</strong> . </p><br><h3 id="lozhnootricatelnye-oshibki">  Kesalahan Negatif Palsu </h3><br><p>  Kesalahan negatif palsu adalah situasi di mana hasil perhitungan ada dalam cache, tetapi sistem tidak menemukannya. <br>  Ini terjadi jika algoritma kunci hash yang digunakan oleh evalcache untuk beberapa alasan menghasilkan kunci yang berbeda untuk perhitungan ulang.  Jika fungsi hash tidak diganti untuk objek dari tipe yang di-cache, evalcache menggunakan <code>__repr__</code> objek untuk membangun kunci. <br>  Kesalahan terjadi, misalnya, jika kelas yang disewa tidak menimpa <code>object.__repr__</code> standar <code>object.__repr__</code> , yang berubah dari awal hingga awal.  Atau, jika <code>__repr__</code> ditimpa, entah bagaimana tergantung pada tidak signifikannya perhitungan data yang berubah (seperti alamat objek atau cap waktu). </p><br><p>  Buruk: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#        -  __repr__.</span></span></code> </pre> <br><p>  Baik: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A({})"</span></span>.format(self.i) A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#     .</span></span></code> </pre> <br><p>  Kesalahan negatif palsu mengarah pada fakta bahwa lenifikasi tidak berfungsi.  Objek akan dihitung ulang pada setiap eksekusi skrip baru. </p><br><h3 id="lozhnopolozhitelnye-oshibki">  Kesalahan positif palsu </h3><br><p>  Ini adalah jenis kesalahan yang lebih kejam, karena mengarah ke kesalahan dalam objek akhir perhitungan: <br>  Itu bisa terjadi karena dua alasan. </p><br><ul><li>  Luar biasa: <br>  Tabrakan kunci hash terjadi di cache.  Untuk algoritma sha256 memiliki ruang 115792089237316195423570985008687907853269984665640564039457584007913129639936 kemungkinan kunci, kemungkinan tabrakan diabaikan. </li><li>  Mungkin: <br>  Representasi objek (atau fungsi hash yang ditimpa) tidak sepenuhnya menggambarkannya, atau bertepatan dengan representasi objek tipe lain. </li></ul><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) A_lazy = lazy(A) B_lazy = lazy(B) a = A_lazy().unlazy() b = B_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#.     B,        A.</span></span></code> </pre> <br><p>  Kedua masalah terkait dengan objek <code>__repr__</code> tidak kompatibel.  Jika karena alasan tertentu tidak mungkin untuk menimpa tipe objek <code>__repr__</code> , perpustakaan memungkinkan Anda untuk mengatur fungsi hash khusus untuk tipe pengguna. </p><br><h2 id="ob-analogah">  Tentang analog </h2><br><p>  Ada banyak pustaka lenifikasi yang pada dasarnya menganggap cukup untuk menjalankan perhitungan tidak lebih dari sekali per panggilan skrip. </p><br><p>  Ada banyak pustaka caching disk yang, atas permintaan Anda, akan menyimpan objek dengan kunci yang diperlukan untuk Anda. </p><br><p>  Tapi saya masih tidak bisa menemukan perpustakaan yang memungkinkan hasil caching di pohon eksekusi.  Jika ada, tolong, tidak aman. </p><br><p>  Referensi: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Pypi</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422937/">https://habr.com/ru/post/id422937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422923/index.html">Bagaimana menandai hari programmer tanpa menghias ficus kantor dengan nol dan satu</a></li>
<li><a href="../id422925/index.html">Wawancara dengan RubyRussia Conference Speaker Godfrey Chan</a></li>
<li><a href="../id422929/index.html">Yandex Mail [tidak] tidak tersedia selama sekitar satu jam pada waktu 12:16 waktu Moskow</a></li>
<li><a href="../id422931/index.html">Kami melihat alat untuk memonitor aplikasi yang didistribusikan</a></li>
<li><a href="../id422935/index.html">2GIS ada di ujung jari Anda. Bagaimana kami menambahkan peta ke Apple Watch</a></li>
<li><a href="../id422939/index.html">Buku "Kali Linux dari pengembang"</a></li>
<li><a href="../id422941/index.html">"Tiga di atas kapal, kemiskinan dan anjing," atau bagaimana Antiplagiarisme mencari parafrase</a></li>
<li><a href="../id422943/index.html">Sedikit tentang pertambangan industri</a></li>
<li><a href="../id422945/index.html">27 September, Moskow - Mitap QIWI SERVER PARTY 3.0</a></li>
<li><a href="../id422947/index.html">Cara mengatur pengarsipan cadangan Veeam di Microsoft Azure Blob Storage menggunakan StarWind VTL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>