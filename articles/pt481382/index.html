<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± üö∂üèæ üõå Aplica√ß√µes nativas do Windows e Acronis Active Restore üïµüèΩ üóùÔ∏è üë®‚Äçüë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje continuamos a hist√≥ria de como n√≥s, juntamente com a equipe da Universidade de Innopolis, estamos desenvolvendo a tecnologia Active Restore para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplica√ß√µes nativas do Windows e Acronis Active Restore</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/481382/">  Hoje continuamos a hist√≥ria de como n√≥s, juntamente com a equipe da Universidade de Innopolis, estamos desenvolvendo a tecnologia Active Restore para permitir que o usu√°rio comece a trabalhar em sua m√°quina o mais r√°pido poss√≠vel ap√≥s uma falha.  Falaremos sobre aplicativos nativos do Windows, incluindo os recursos de sua cria√ß√£o e lan√ßamento.  Sob o corte - um pouco sobre o nosso projeto, bem como um guia pr√°tico sobre como escrever aplicativos nativos. <br><br><img src="https://habrastorage.org/webt/rc/bv/yl/rcbvylee_0ylshzywkrdlip0c9o.jpeg"><br><a name="habracut"></a><br>  Nas postagens anteriores, j√° falamos sobre o que √© o <a href="https://habr.com/ru/company/acronis/blog/477658/">Active Restore</a> e como os alunos do Innopolis desenvolvem o <a href="https://habr.com/ru/company/acronis/blog/479524/">servi√ßo</a> .  Hoje, quero me concentrar em aplicativos nativos, no n√≠vel em que queremos ‚Äúenterrar‚Äù nosso servi√ßo de recupera√ß√£o ativo.  Se tudo der certo, podemos: <br><br><ul><li>  Muito antes para iniciar o pr√≥prio servi√ßo </li><li>  Muito antes de entrar em contato com a nuvem na qual o backup est√° </li><li>  √â muito mais cedo para entender em que modo o sistema est√° - inicializa√ß√£o ou recupera√ß√£o normal </li><li>  Para restaurar muito menos arquivos com anteced√™ncia </li><li>  Permita que o usu√°rio comece ainda mais r√°pido. </li></ul><br><h3>  O que √© um aplicativo nativo em geral? </h3><br>  Para responder a essa pergunta, vejamos a sequ√™ncia de chamadas que o sistema faz, por exemplo, se um programador em seu aplicativo tentar criar um arquivo. <br><br><img src="https://habrastorage.org/webt/gb/d_/a7/gbd_a7c7l1d-6dlo4zh-fygf5dm.jpeg"><br>  <i>Pavel Yosifovich - Programa√ß√£o do Kernel do Windows (2019)</i> <br><br>  O programador usa a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> , declarada no arquivo de cabe√ßalho fileapi.h e implementada no Kernel32.dll.  No entanto, essa fun√ß√£o em si n√£o cria um arquivo, apenas verifica os argumentos na entrada e chama a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">NtCreateFile</a> (o prefixo Nt indica apenas que a fun√ß√£o √© nativa).  Esta fun√ß√£o √© declarada no arquivo de cabe√ßalho winternl.h e √© implementada no ntdll.dll.  Ela se prepara para pular para o espa√ßo nuclear, ap√≥s o que faz uma chamada de sistema para criar um arquivo.  Nesse caso, o Kernel32 √© apenas um inv√≥lucro para o Ntdll.  Uma das raz√µes pelas quais isso √© feito, a Microsoft tem, portanto, a capacidade de alterar as fun√ß√µes do mundo nativo, mas n√£o toca nas interfaces padr√£o.  A Microsoft n√£o recomenda a chamada direta de fun√ß√µes nativas e n√£o documenta a maioria delas.  A prop√≥sito, recursos n√£o documentados podem ser encontrados <a href="http://undocumented.ntinternals.net/">aqui</a> . <br><br>  A principal vantagem dos aplicativos nativos √© que o ntdll √© carregado no sistema muito antes do kernel32.  Isso √© l√≥gico, porque o kernel32 requer que o ntdll funcione.  Como resultado, os aplicativos que usam fun√ß√µes nativas podem come√ßar a trabalhar muito mais cedo. <br><br>  Portanto, os Aplicativos Nativos do Windows s√£o programas que podem ser executados em um est√°gio inicial na inicializa√ß√£o do Windows.  Eles usam apenas fun√ß√µes do ntdll.  Um exemplo desse aplicativo: <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/autochk">autochk,</a> que executa o <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chkdsk">utilit√°rio chkdisk</a> para verificar se h√° erros no disco antes de iniciar os servi√ßos principais.  √â nesse n√≠vel que queremos ver nossa Restaura√ß√£o Ativa. <br><br><h3>  Do que precisamos? </h3><br><ul><li> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit), agora tamb√©m conhecido como WDK 7 (Windows Driver Kit). </li><li>  M√°quina virtual (por exemplo, Windows 7 x64) </li><li>  N√£o necessariamente, mas os arquivos de cabe√ßalho podem ser baixados <a href="https://github.com/arizvisa/ndk">aqui.</a> </li></ul><br><h3>  O que est√° no c√≥digo? </h3><br>  Vamos praticar um pouco e, por exemplo, escreveremos um pequeno aplicativo que: <br><br><ol><li>  Exibe uma mensagem na tela. </li><li>  Aloca um pouco de mem√≥ria </li><li>  Aguardando entrada do teclado </li><li>  Libera mem√≥ria ocupada </li></ol><br>  Em aplicativos nativos, o ponto de entrada n√£o √© o principal ou o dom√≠nio principal, mas a fun√ß√£o NtProcessStartup, pois na verdade iniciamos diretamente o novo processo no sistema. <br><br>  Vamos come√ßar exibindo a mensagem na tela.  Para fazer isso, temos uma fun√ß√£o nativa <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FError%252FNtDisplayString.html">NtDisplayString</a> , que leva como argumento um ponteiro para um objeto da estrutura UNICODE_STRING.  RtlInitUnicodeString nos ajudar√° a inicializ√°-lo.  Como resultado, para exibir texto na tela, podemos escrever uma fun√ß√£o t√£o pequena: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//usage: WriteLn(L"Here is my text\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); }</span></span></code> </pre> <br>  Como apenas as fun√ß√µes do ntdll est√£o dispon√≠veis e simplesmente n√£o existem outras bibliotecas na mem√≥ria, definitivamente teremos problemas com a aloca√ß√£o de mem√≥ria.  O novo operador ainda n√£o existe (porque √© proveniente de um mundo C ++ de n√≠vel muito alto), tamb√©m n√£o h√° fun√ß√£o malloc (ele precisa de bibliotecas C em tempo de execu√ß√£o).  Obviamente, voc√™ pode usar apenas a pilha.  Por√©m, se precisarmos alocar mem√≥ria dinamicamente, teremos que fazer isso no heap (ou seja, heap).  Portanto, vamos criar um monte para n√≥s mesmos e tiraremos mem√≥ria quando precisarmos. <br><br>  A fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap √©</a> adequada para esta tarefa.  Al√©m disso, usando RtlAllocateHeap e RtlFreeHeap, ocuparemos e liberaremos mem√≥ria quando precisarmos. <br><br><pre> <code class="cpp hljs">PVOID memory = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PVOID buffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ULONG bufferSize = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory);</span></span></code> </pre> <br>  Vamos continuar aguardando a entrada do teclado. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //... HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } }</span></span></code> </pre> <br>  Tudo o que precisamos fazer √© usar o <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FFile%252FNtReadFile.html">NtReadFile</a> em um dispositivo aberto e aguardar at√© o teclado retornar um clique para n√≥s.  Caso a tecla ESC seja pressionada, continuaremos a trabalhar.  Para abrir o dispositivo, precisamos chamar a fun√ß√£o NtCreateFile (voc√™ precisar√° abrir \ Device \ KeyboardClass0).  Tamb√©m chamaremos <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">NtCreateEvent</a> para inicializar o objeto a aguardar.  Declararemos independentemente a estrutura KEYBOARD_INPUT_DATA que representa os dados do teclado.  Isso facilitar√° nosso trabalho. <br><br>  O aplicativo nativo termina com uma chamada para a fun√ß√£o <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">NtTerminateProcess</a> , porque acabamos de matar nosso pr√≥prio processo. <br><br>  Todo o c√≥digo do nosso pequeno aplicativo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntifs.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// \WinDDK\7600.16385.1\inc\ddk #include "ntdef.h" //------------------------------------ // Following function definitions can be found in native development kit // but I am too lazy to include `em so I declare it here //------------------------------------ NTSYSAPI NTSTATUS NTAPI NtTerminateProcess( IN HANDLE ProcessHandle OPTIONAL, IN NTSTATUS ExitStatus ); NTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); NTSTATUS NtWaitForSingleObject( IN HANDLE Handle, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout ); NTSYSAPI NTSTATUS NTAPI NtCreateEvent( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState ); // https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //---------------------------------------------------------- // Our code goes here //---------------------------------------------------------- // usage: WriteLn(L"Hello Native World!\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); } void NtProcessStartup(void* StartupArgument) { // it is important to declare all variables at the beginning HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; PVOID memory = NULL; PVOID buffer = NULL; ULONG bufferSize = 42; //use it if debugger connected to break //DbgBreakPoint(); WriteLn(L"Hello Native World!\n"); // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); WriteLn(L"Keyboard ready\n"); // create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); WriteLn(L"Heap ready\n"); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); WriteLn(L"Buffer allocated\n"); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory); WriteLn(L"Heap destroyed\n"); WriteLn(L"Press ESC to continue...\n"); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } } NtTerminateProcess(NtCurrentProcess(), 0); }</span></span></span></span></code> </pre> <br>  <b>PS:</b> Podemos usar facilmente a fun√ß√£o DbgBreakPoint () no c√≥digo para parar no depurador.  √â verdade que voc√™ precisar√° conectar o WinDbg √† m√°quina virtual para depura√ß√£o do kernel.  Instru√ß√µes sobre como fazer isso podem ser encontradas <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">aqui</a> ou apenas use o <a href="http://sysprogs.com/legacy/virtualkd/">VirtualKD</a> . <br><br><h3>  Compila√ß√£o e montagem </h3><br>  A maneira mais f√°cil de criar um aplicativo nativo √© usar o <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit).  Precisamos exatamente da s√©tima vers√£o antiga, pois as vers√µes posteriores t√™m uma abordagem ligeiramente diferente e trabalham em estreita colabora√ß√£o com o Visual Studio.  Se usarmos o DDK, nosso projeto precisar√° apenas de Makefile e fontes. <br><br>  <i>Makefile</i> <br><pre> <code class="bash hljs">!INCLUDE $(NTMAKEENV)\makefile.def</code> </pre> <br>  <i>fontes:</i> <br><pre> <code class="bash hljs">TARGETNAME = MyNative TARGETTYPE = PROGRAM UMTYPE = nt BUFFER_OVERFLOW_CHECKS = 0 MINWIN_SDK_LIB_PATH = $(SDK_LIB_PATH) SOURCES = source.c INCLUDES = $(DDK_INC_PATH); \ C:\WinDDK\7600.16385.1\ndk; TARGETLIBS = $(DDK_LIB_PATH)\ntdll.lib \ $(DDK_LIB_PATH)\nt.lib USE_NTDLL = 1</code> </pre> <br>  Seu Makefile ser√° exatamente o mesmo, mas vamos nos concentrar nas fontes com mais detalhes.  Este arquivo cont√©m as fontes do seu programa (arquivos .c), op√ß√µes de compila√ß√£o e outros par√¢metros. <br><br><ul><li>  TARGETNAME - o nome do arquivo execut√°vel, que deve ser o resultado. </li><li>  TARGETTYPE - tipo de arquivo execut√°vel, pode ser um driver (.sys); o valor do campo deve ser DRIVER, se a biblioteca (.lib), o valor √© LIBRARY.  No nosso caso, precisamos de um arquivo execut√°vel (.exe), portanto, definimos o valor como PROGRAM. </li><li>  UMTYPE - valores poss√≠veis para este campo: console para um aplicativo de console, janelas para operar no modo de janela.  Mas precisamos especificar nt para obter o aplicativo nativo. </li><li>  BUFFER_OVERFLOW_CHECKS - verificando se h√° excesso de buffer na pilha, infelizmente n√£o √© o nosso caso, desative-o. </li><li>  MINWIN_SDK_LIB_PATH - esse valor refere-se √† vari√°vel SDK_LIB_PATH, n√£o se preocupe por n√£o ter declarado essa vari√°vel de sistema; no momento em que executarmos a compila√ß√£o verificada no DDK, essa vari√°vel ser√° declarada e apontar√° para as bibliotecas necess√°rias. </li><li>  FONTES - uma lista das fontes do seu programa. </li><li>  INCLUI - arquivos de cabe√ßalho necess√°rios para montagem.  Eles geralmente indicam o caminho para os arquivos que acompanham o DDK, mas voc√™ pode opcionalmente especificar outros. </li><li>  TARGETLIBS - uma lista de bibliotecas que precisam ser vinculadas. </li><li>  USE_NTDLL √© um campo obrigat√≥rio que deve ser definido na posi√ß√£o 1. Por raz√µes √≥bvias. </li><li>  USER_C_FLAGS - qualquer sinalizador que voc√™ possa usar nas diretivas de pr√©-processador ao preparar o c√≥digo do aplicativo. </li></ul><br>  Portanto, para compilar, precisamos executar x86 (ou x64) Checked Build, alterar o diret√≥rio de trabalho para a pasta do projeto e executar o comando Build.  O resultado na captura de tela mostra que reunimos um arquivo execut√°vel. <br><br><img src="https://habrastorage.org/webt/9a/aj/hp/9aajhpa858ohtthlkjnenl1nnic.jpeg" alt="Construir"><br><br>  Este arquivo n√£o pode ser executado de maneira simples, o sistema jura e nos envia para pensar sobre seu comportamento com o seguinte erro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ev/zu/zwevzuxrc6zc8fvgye_msqa0k6y.jpeg" alt="Erro"></div><br><br><h3>  Como executar um aplicativo nativo? </h3><br>  No in√≠cio do autochk, a sequ√™ncia de inicializa√ß√£o dos programas √© determinada pelo valor da chave do registro: <br><br><pre> <code class="bash hljs">HKLM\System\CurrentControlSet\Control\Session Manager\BootExecute</code> </pre> <br>  O gerenciador de sess√µes executa os programas dessa lista, um por um.  O pr√≥prio gerenciador de sess√µes procura por arquivos execut√°veis ‚Äã‚Äãno diret√≥rio system32.  O formato do valor da chave do Registro √© o seguinte: <br><br><pre> <code class="bash hljs">autocheck autochk *MyNative</code> </pre> <br>  O valor deve estar no formato hexadecimal e n√£o no ASCII usual; portanto, a chave apresentada acima ter√° o formato: <br><br><pre> <code class="bash hljs">61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Para converter o nome, voc√™ pode usar um servi√ßo online, por exemplo, <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">este</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ii/ky/sn/iikysns0tim-qpz91mbazv4uepa.jpeg"></div><br>  Acontece que, para executar o aplicativo nativo, precisamos: <br><br><ol><li>  Copiar arquivo execut√°vel para a pasta system32 </li><li>  Adicione uma chave ao registro </li><li>  Reiniciar a m√°quina </li></ol><br>  Por conveni√™ncia, aqui est√° um script pronto para instalar um aplicativo nativo: <br><br>  <i>install.bat</i> <br><br><pre> <code class="bash hljs">@<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> off copy MyNative.exe %systemroot%\system32\. regedit /s add.reg <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Native Example Installed pause</code> </pre> <br>  <i>add.reg</i> <br><br><pre> <code class="bash hljs">REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager] <span class="hljs-string"><span class="hljs-string">"BootExecute"</span></span>=hex(7):61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Ap√≥s a instala√ß√£o e reinicializa√ß√£o, mesmo antes da tela de sele√ß√£o do usu√°rio aparecer, temos a seguinte imagem: <br><br><img src="https://habrastorage.org/webt/yi/5p/7_/yi5p7_4vygq1wttxg_edlw-keqi.jpeg" alt="resultado"><br><br><h3>  Sum√°rio </h3><br>  Usando o exemplo de um aplicativo t√£o pequeno, garantimos que √© poss√≠vel executar o aplicativo no n√≠vel nativo do Windows.  Al√©m disso, os funcion√°rios da Universidade de Innopolis continuar√£o construindo um servi√ßo que iniciar√° o processo de intera√ß√£o com o motorista muito mais cedo do que na vers√£o anterior do nosso projeto.  E com o advento do shell win32, ser√° l√≥gico transferir o controle para um servi√ßo completo que j√° foi desenvolvido (mais sobre isso <a href="https://habr.com/ru/company/acronis/blog/479524/">aqui</a> ). <br><br>  No pr√≥ximo artigo, abordaremos outro componente do servi√ßo Active Restore, ou seja, o driver UEFI.  Assine o nosso blog para n√£o perder a pr√≥xima postagem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481382/">https://habr.com/ru/post/pt481382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481370/index.html">Greta Tunberg est√° certa? Aeronaves VS trens</a></li>
<li><a href="../pt481372/index.html">√Årvore bin√°ria index√°vel</a></li>
<li><a href="../pt481374/index.html">Habr Weekly # 32 / Rambler deu as costas, manipula√ß√µes no trabalho, como proteger um projeto de estima√ß√£o, gadgets tiram selfies em sil√™ncio</a></li>
<li><a href="../pt481376/index.html">An√°lise das li√ß√µes ensinadas √† comunidade pela situa√ß√£o NGINX</a></li>
<li><a href="../pt481378/index.html">Como otimizar o desenvolvimento de aplicativos</a></li>
<li><a href="../pt481386/index.html">Pontilhamento: Sinal ruidoso para melhor√°-lo</a></li>
<li><a href="../pt481388/index.html">Como as trocas de criptomoedas criam suas blockchains desafiando o DeFi</a></li>
<li><a href="../pt481390/index.html">Not√≠cias do mundo do OpenStreetMap n¬∫ 490 (03/12/2019 - 09/12/2019)</a></li>
<li><a href="../pt481392/index.html">Como escrevi uma criptomoeda centralizada em PHP. (Parte 1 - Resumos b√°sicos + In√≠cio r√°pido)</a></li>
<li><a href="../pt481394/index.html">Recriar em um novo jogo o que amamos pelos velhos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>