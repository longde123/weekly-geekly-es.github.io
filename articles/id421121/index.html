<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 🥣 👨🏾 Streaming video melalui browser dengan latensi sangat rendah (dan WebRTC!) 🎞️ 👌🏽 ⤵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sementara pengadopsi awal pertama mencoba konferensi video baru kami (hingga 100 orang!) Dalam proyek mereka, kami terus berbicara tentang hal-hal men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Streaming video melalui browser dengan latensi sangat rendah (dan WebRTC!)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/421121/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/hu/kv/oahukvx05phesrj7ttv_qg9o3pq.gif"></div><br>  Sementara pengadopsi awal pertama mencoba konferensi video baru kami (hingga 100 orang!) Dalam proyek mereka, kami terus berbicara tentang hal-hal menarik dari dunia transmisi suara dan video dengan browser.  Kami juga akan berbicara tentang konferensi video, tetapi nanti - ketika massa kritis pengguna menumpuk dan statistik menarik dikumpulkan.  Dan sekarang saya telah menerjemahkan dan mengadaptasi untuk kita kisah Dr.  Alex tentang tempat protokol yang berbeda saat mentransmisikan video dengan latensi rendah.  Cerita ini pada dasarnya adalah tanggapan terhadap artikel lain, dan penulis, bersama dengan cerita tersebut, menunjukkan kesalahan dan ketidakakuratan yang dibuat oleh rekan-rekannya di bengkel tersebut. <br><a name="habracut"></a><br><h2>  Data jaringan: alarm secara terpisah, video secara terpisah </h2><br>  Dalam sistem modern, jika Anda melihat video di browser, maka aliran video dan alarm kemungkinan besar akan diproses oleh server yang berbeda.  Jika semuanya jelas dengan video, maka "server alarm" menyediakan dua hal: "penemuan" dan "jabat tangan".  Yang pertama, "penemuan", adalah pilihan metode transfer data: alamat IP, server perantara (jika perlu).  "Jabat Tangan" - tentang negosiasi antara peserta dalam transmisi video dan suara: codec, resolusi, kecepatan bingkai, kualitas.  Menariknya, dalam Flash kuno, pensinyalan dan transmisi media tidak dipisahkan seperti di VoxIP atau WebRTC dan disediakan oleh satu protokol: RTMP. <br><br><h2>  Perbedaan antara protokol pensinyalan dan transport pensinyalan </h2><br>  Protokol pensinyalan mendefinisikan bahasa yang dengannya browser dan peserta lain dalam transmisi video akan menyetujui penemuan dan jabat tangan.  Itu bisa SIP untuk penemuan di VoIP atau WebRTC, dan itu adalah dengan penawaran / jawaban untuk jabat tangan.  Dahulu kala, Flash menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTMP / AMF</a> .  Dan jika diinginkan, untuk WebRTC, Anda dapat menggunakan bukan SIP, tetapi JSEP yang tidak biasa. <br><br>  Protokol pensinyalan pensinyalan dari tumpukan yang sama, tetapi lebih rendah: ini adalah bagaimana paket protokol pensinyalan akan ditransmisikan secara fisik.  Secara tradisional, untuk Flash + SIP, TCP atau UDP digunakan, tetapi sekarang dalam bundel WebRTC + SIP, WebSockets semakin banyak ditemukan.  Protokol transport WebSockets menempati ceruk TCP di browser tempat Anda tidak dapat menggunakan soket "murni" TCP dan UDP. <br><br>  Tumpukan pensinyalan penuh sekarang populer diuraikan dengan frasa seperti "SIP di atas soket web", "JSEP di atas soket web", usang "SIP di atas TCP / UDP" atau "bagian RTMP" kuno. <br><br><h2>  Programmer Anglicism: Media Codec </h2><br>  Sebagian besar protokol streaming video terikat pada satu atau lebih codec.  Video yang diterima dari kamera diproses bingkai demi bingkai.  Dan masalah jaringan, seperti berkurangnya bandwidth, hilangnya paket, atau penundaan di antara keduanya, diselesaikan dengan pengaturan codec untuk setiap frame.  Untuk mempelajari masalah jaringan tepat waktu, kami menggunakan mekanisme protokol transportasi (RTP / RTCP) dan mekanisme estimasi bandwidth (REMB, Transport-CC, TIMBR).  Salah satu masalah mendasar dengan video Flash adalah RTMP tidak dapat melakukan keduanya, sehingga video berhenti diputar saat bandwidth saluran turun. <br><br><h2>  Anglicism lain: Protokol Streaming Media </h2><br>  Menentukan bagaimana membagi aliran video ke dalam paket-paket kecil yang dikirim melalui jaringan oleh protokol transport.  Biasanya, protokol streaming masih menyediakan mekanisme untuk menangani masalah jaringan: kehilangan dan penundaan paket.  Buffer Jitter, transmisi ulang (RTC), redundansi (RED) dan Forward Error Correction (FEC). <br><br><h2>  Protokol Transfer Media </h2><br>  Setelah video yang diterima dari kamera dibagi menjadi beberapa paket kecil, mereka harus ditransmisikan melalui jaringan.  Protokol transport yang digunakan untuk ini mirip dengan yang signaling, tetapi karena “payload” sangat berbeda, beberapa protokol lebih baik daripada yang lain.  Sebagai contoh, TCP menyediakan jangkauan paket, tetapi itu tidak menambah nilai ke stack, karena mekanisme yang serupa (RTX / RED / FEC) sudah ada dalam protokol streaming.  Tetapi keterlambatan pengiriman kembali ke TCP adalah cacat yang jelas tidak dimiliki UDP.  Tetapi ada praktik memblokir UDP sebagai "protokol untuk torrent." <br><br>  Pilihan port protokol dan jaringan sebelumnya diputuskan oleh "hardcoding", tetapi sekarang kami menggunakan protokol seperti ICE di WebRTC, yang memungkinkan kami untuk menyetujui port dan mengangkut di setiap koneksi tertentu.  Dalam waktu dekat, dimungkinkan untuk menggunakan protokol QUIC (kompatibel dengan UDP), yang secara aktif dibahas oleh IETF dan memiliki keunggulan dibandingkan TCP dan UDP dalam kecepatan dan keandalan.  Terakhir, kita dapat menyebutkan protokol streaming media seperti MPEG-DASH dan HLS, yang menggunakan HTTP sebagai transportasi dan akan mendapat manfaat dari pengenalan HTTP / 2.0. <br><br><h2>  Keamanan Transmisi Media </h2><br>  Beberapa mesin melindungi data selama transmisi melalui jaringan: baik media itu sendiri, atau paket-paket lapisan transport.  Proses ini termasuk transfer kunci enkripsi, yang digunakan protokol terpisah: SDES dalam VoIP dan DTLS di WebRTC.  Yang terakhir ini memiliki keunggulan, karena selain data, ia juga melindungi pengiriman kunci enkripsi. <br><br><h2>  Apa yang menggangguku tentang semua ini </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/od/pd/xx/odpdxx5jrsjgoo8xu22boycell4.png"></div><br>  Beberapa pengembang, seperti penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , menempatkan protokol WebSocket dan QUIC murni pada tingkat yang sama dengan WebRTC, Flash, atau HLS.  Bagi saya, pengelompokan seperti itu terlihat aneh, karena tiga protokol terakhir adalah cerita tentang streaming media.  Pengkodean dan pengemasan dilakukan sebelum menggunakan WebSocket atau QUIC.  Referensi Google implementasi WebRTC (libwebrtc / chrome) dan Microsoft ORTC menggunakan QUIC sebagai protokol transport. <br><br>  Yang sama mengejutkannya adalah kurangnya penyebutan HTTP / 2.0 sebagai optimisasi untuk protokol berbasis HTTP seperti HLS dan MPEG-DASH.  Dan CMAF yang disebutkan tidak lebih dari format file untuk HLS dan MPEG-DASH, tetapi bukan pengganti mereka sama sekali. <br><br>  Akhirnya, SRT hanyalah protokol transportasi.  Dia, tentu saja, menambahkan sejumlah chip dibandingkan dengan yang berbasis pada file HLS dan MPEG-DASH, tetapi semua chip ini sudah pada tingkat tumpukan yang berbeda dan diimplementasikan dalam RTMP atau WebRTC.  SRT juga berbagi penyandian aliran media dan statistik, yang tidak memungkinkan codec untuk menyimpan informasi ini sedekat mungkin satu sama lain.  Keputusan seperti itu dapat mempengaruhi kemampuan untuk mengadaptasi video yang ditransfer ke bandwidth jaringan yang berubah. <br><br>  Protokol berbasis file, seperti HLS, mengkodekan beberapa stream dan memilih yang diperlukan untuk beradaptasi dengan lebar saluran.  WebRTC memungkinkan Anda untuk menyesuaikan penyandian setiap frame secara real time: itu jauh lebih cepat daripada memilih aliran lain di HLS, yang membutuhkan penghitungan hingga 10 detik dari data yang sudah dikirim. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421121/">https://habr.com/ru/post/id421121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421109/index.html">(Diperbarui) Intel melarang penerbitan tolok ukur untuk pembaruan mikrokode</a></li>
<li><a href="../id421111/index.html">Sistem desain dalam Figma. Tampak pada antarmuka melalui komponen</a></li>
<li><a href="../id421113/index.html">Memperkenalkan DJI Mavic 2 Pro / Zoom</a></li>
<li><a href="../id421115/index.html">Konteks dalam aplikasi Android</a></li>
<li><a href="../id421119/index.html">Pengembangan SmartTV menyapu bawah air</a></li>
<li><a href="../id421123/index.html">Intisari acara TI untuk bulan September</a></li>
<li><a href="../id421125/index.html">Kami mengelompokkan 600 juta pengguna secara real time setiap hari</a></li>
<li><a href="../id421127/index.html">Webinar Skillbox Friday: Desain & Pengembang</a></li>
<li><a href="../id421129/index.html">Cara mengurangi ulasan kode dari dua minggu menjadi beberapa jam. Pengalaman tim Yandex.Market</a></li>
<li><a href="../id421131/index.html">Kerentanan Penting Server 1Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>