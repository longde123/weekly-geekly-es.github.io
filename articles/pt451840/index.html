<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚋 🌄 👩🏻‍🍳 Teste de desempenho do aplicativo Flutter 👨🏿‍🏭 🚰 🤝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A estrutura do Flutter funciona bem e rápido por padrão, mas isso significa que você não precisa pensar em desempenho? Não. É absolutamente real escre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de desempenho do aplicativo Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451840/"><p>  A estrutura do Flutter funciona bem e rápido por padrão, mas isso significa que você não precisa pensar em desempenho?  Não.  É absolutamente real escrever aplicativos Flutter que serão lentos.  Por outro lado, você também pode usar a estrutura ao máximo e tornar seus aplicativos não apenas rápidos, mas também eficientes, consumindo menos tempo do processador e da bateria. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bb9/950/aa7/bb9950aa7d75e64e402d3ffdd8958c97.png"></p><br><p> <em>É isso que queremos ver: um resultado estatisticamente significativo da comparação de duas versões do seu aplicativo por alguma métrica significativa.</em>  <em>Leia para descobrir como.</em> </p><a name="habracut"></a><br><p>  Existem algumas diretrizes gerais para otimizar o desempenho no Flutter: </p><br><ul><li>  Envolva o menor número possível de widgets ao atualizar o estado. </li><li>  Atualize o status somente quando necessário. </li><li> Execute tarefas computacionalmente intensivas de seus métodos de <code>build</code> e, idealmente, do isolado principal. </li></ul><br><p>  A triste verdade é que, para muitas perguntas sobre como otimizar o desempenho, a resposta será "que sorte".  Essa otimização específica vale o esforço e o custo de manutenção desse widget específico?  Essa abordagem em particular faz sentido nessa situação em particular? </p><br><p>  A única resposta útil para essas perguntas é teste e medição.  Quantifique como cada escolha afeta o desempenho e tome decisões com base nesses dados. </p><br><p>  A boa notícia é que o Flutter fornece ótimas ferramentas de perfil de desempenho, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dart DevTools</a> (atualmente na versão de pré-visualização), que inclui o Flutter Inspector, ou você pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flutter Inspector</a> diretamente do Android Studio (com o plug-in Flutter instalado).  Você tem um <code>Flutter Driver</code> para testar seu aplicativo e o <code>Profile mode</code> para salvar informações de desempenho. </p><br><p>  A má notícia é que os smartphones modernos são muito inteligentes. </p><br><h1 id="problema-s-regulyatorami">  O problema com reguladores </h1><br><p>  A quantificação do desempenho do aplicativo Flutter é especialmente difícil para os controladores iOS e Android.  Esses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daemons no</a> nível do sistema controlam a velocidade dos processadores central e gráfico, dependendo da carga.  Obviamente, isso é bom, pois fornece uma operação suave com menos consumo de bateria. </p><br><p>  A desvantagem é que você pode tornar seu aplicativo muito mais rápido aumentando a quantidade de trabalho que ele executa. </p><br><p>  Abaixo, você pode ver como a adição de um ciclo de chamadas de impressão sem sentido ao aplicativo fez o regulador alternar a CPU para uma frequência aumentada, o que tornou o aplicativo muito mais rápido e seu desempenho mais previsível. <br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/5e4/b29/0bd5e4b299bc338e4a65aba9f0a91bda.png"></p><br><p>  <em>O problema com os reguladores: por padrão, você não pode confiar nos seus números.</em>  <em>Neste diagrama de amplitude, temos execuções separadas no eixo x (marcado pela hora exata em que foram iniciadas) e tempo de construção no eixo Y. Como você pode ver, quando introduzimos algumas instruções de impressão completamente desnecessárias, isso leva ao fato de que o tempo de construção diminui. mas não para cima.</em> </p><br><p>  Nesta experiência, o pior código resultou em um tempo de construção mais rápido (veja acima), um tempo de rasterização mais rápido e uma taxa de quadros mais alta.  Quando um código objetivamente pior leva a melhores indicadores de desempenho, você não pode confiar nesses indicadores como um guia (recomendação). </p><br><p>  Este é apenas um exemplo de como o teste de desempenho de aplicativos para dispositivos móveis pode ser pouco intuitivo e complexo. </p><br><p>  Abaixo, compartilho algumas das dicas que reuni enquanto trabalhava no aplicativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Developer Quest</a> do Flutter para Google I / O. </p><br><h1 id="obschie-sovety">  Dicas gerais </h1><br><ul><li>  Não meça o desempenho no modo de depuração ( <code>DEBUG mode</code> ).  Avalie o desempenho apenas no <code>Profile mode</code> perfil. </li><li>  Meça em um dispositivo real, não no iOS Simulator ou Android Emulator.  Os emuladores de software são ótimos para o desenvolvimento, mas têm características de desempenho diferentes das reais.  O Flutter não permitirá que você trabalhe no modo de criação de perfil em um dispositivo simulado, porque não faz sentido.  Os dados coletados dessa maneira não são aplicáveis ​​ao desempenho real. </li><li>  Idealmente, use exatamente o mesmo dispositivo físico.  Torne-o seu dispositivo de teste de desempenho dedicado e nunca use-o para mais nada. </li><li>  Explore o Flutter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Performance Profiling Tools</a> . </li></ul><br><h1 id="cpugpu-regulyatory">  Reguladores de CPU / GPU </h1><br><p>  Conforme discutido acima, os sistemas operacionais modernos alteram a frequência de cada processador e GPU à sua disposição, de acordo com a carga e algumas outras heurísticas.  (Por exemplo, tocar na tela geralmente aumenta a velocidade do seu telefone Android.) </p><br><p>  No Android, você pode desativar esses controles.  Chamamos esse processo de "trava de escala". </p><br><ul><li>  Crie um script que desabilite os controles no seu dispositivo para testar o desempenho.  Você pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Skia</a> para se inspirar.  Você também pode conferir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API da CPU Unix</a> . </li><li>  Você pode querer algo menos versátil e mais leve se não fizer tanto trabalho de teste quanto o Skia.  Confira o script do shell no Developer Quest para ver para onde ir.  Por exemplo, a próxima parte do script define a CPU para o controlador do espaço do usuário (o único controlador que não altera a frequência do processador). <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash GOV="userspace" echo "Setting CPU governor to: ${GOV}" adb shell "echo ${GOV} &gt; /sys/devices/system/cpu/cpu${CPU_NO}/cpufreq/scaling_governor" ACTUAL_GOV=`adb shell "cat /sys/devices/system/cpu/cpu${CPU_NO}/cpufreq/scaling_governor"` echo "- result: ${ACTUAL_GOV}"</span></span></code> </pre> </li><li>  Seu objetivo aqui não é simular o desempenho real (os usuários não desligam os reguladores em seus dispositivos), mas ter indicadores de desempenho comparáveis ​​entre as execuções. </li><li>  No final, você precisa experimentar e adaptar o shell script ao dispositivo que você usará.  Isso funciona, mas até você fazer isso, seus dados de desempenho o enganarão. </li></ul><br><p><img src="https://habrastorage.org/webt/x4/fw/o5/x4fwo5lyzfo7osrcbjgpfjd7whi.gif"></p><br><p>  <em>Uma versão anterior do Developer Quest, testada com o Flutter Driver na minha área de trabalho.</em> </p><br><h1 id="flutter-driver">  Driver de vibração </h1><br><p>  O Driver Flutter permite que você teste automaticamente seu aplicativo.  Leia a seção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Performance Profiling”</a> no flutter.dev para descobrir como usá-lo ao criar seu perfil no aplicativo. </p><br><ul><li>  Para testar o desempenho, não teste manualmente seu aplicativo.  Sempre use o driver Flutter para obter dados realmente indicativos. </li><li>  Escreva seu código do Flutter Driver para que ele verifique o que você realmente deseja medir.  Se você precisar de desempenho geral do aplicativo, tente passar por todas as partes do aplicativo e faça o que o usuário faria. </li><li>  Se o seu aplicativo tiver um elemento aleatório ( <code>Random</code> , eventos de rede etc.), crie "simulação" para essas situações.  As execuções de teste devem ser o mais próximas possível. </li><li>  Se desejar, você pode adicionar eventos personalizados à linha do tempo usando os <code>startSync()</code> e <code>finishSync()</code> da classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Timeline</a> .  Isso pode ser útil se você estiver interessado no desempenho de uma função específica.  Coloque <code>startSync()</code> no início e <code>finishSync()</code> no final. </li><li>  Salve o resumo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">writeSummaryToFile</a> ) e, mais importante, a linha do tempo bruta ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">writeTimelineToFile</a> ). </li><li>  Teste cada versão do seu aplicativo várias vezes.  No Developer Quest, passei 100 partidas.  (Quando você mede coisas barulhentas, como usar a métrica p99, pode precisar de muito mais execuções.) Para sistemas baseados em POSIX, isso significa simplesmente fazer algo como o seguinte: <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code> <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code>  <code>for i in {1..100}; do flutter drive --target=test_driver/perf.dart --profile; done</code> . <br><img src="https://habrastorage.org/getpro/habr/post_images/add/92b/950/add92b950ec34ce95edb9095a57186a3.png"></li></ul><br><p>  <em>Ferramenta de linha do tempo do Chrome para verificar os resultados de criação de perfil no Flutter.</em> </p><br><h1 id="timeline">  Linha do tempo </h1><br><p>  Linha do tempo é a saída bruta de seus resultados de criação de perfil.  Flutter grava essas informações em um arquivo JSON, que pode ser baixado no <code>chrome://tracing</code> . </p><br><ul><li>  Entenda como abrir a linha do tempo completa no Chrome.  Você simplesmente abre o <code>chrome://tracing</code> no navegador Chrome, clique em "Carregar" e selecione o arquivo JSON.  Você pode ler mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste pequeno guia</a> .  (Também há <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma ferramenta de linha do tempo do Flutter</a> que está atualmente na visualização de tecnologia. Eu não a usei porque o projeto Developer Quest foi lançado antes das ferramentas do Flutter estarem prontas.) </li><li>  Use as teclas WSAD para navegar na linha do tempo em <code>chrome://tracing</code> e 1234 para alterar os modos de operação. </li><li>  Ao configurar o teste de desempenho pela primeira vez, considere executar o Flutter Driver com a ferramenta Systrace Android.  Isso fornece uma idéia melhor do que realmente está acontecendo no dispositivo, incluindo informações sobre o dimensionamento da frequência do processador.  Não meça o aplicativo inteiro com o Systrace, pois isso tornará tudo mais lento e menos previsível. </li><li>  Como executar o Android Systrace com Flutter Driver?  Primeiro, inicie o Android Systrace com <code>/path/to/your/android/sdk/platform-tools/systrace/systrace.py --atrace-categories=gfx,input,view,webview,wm,am,sm,audio,video,camera,hal,app,res,dalvik,rs,bionic,power,pm,ss,database,network,adb,pdx,sched,irq,freq,idle,disk,load,workq,memreclaim,regulators,binder_driver,binder_lock</code> .  Em seguida, <code>flutter run test_driver/perf.dart --profile --trace-systrace</code> aplicativo <code>flutter run test_driver/perf.dart --profile --trace-systrace</code> .  Por fim, execute a <code>flutter drive --driver=test_driver/perf_test.dart --use-existing-app=http://127.0.0.1:NNNNN/</code> Flutter Driver <code>flutter drive --driver=test_driver/perf_test.dart --use-existing-app=http://127.0.0.1:NNNNN/</code> (em que NNNNN é a porta que fornece o aplicativo de vibração acima). </li></ul><br><h1 id="metriki">  Métricas </h1><br><p>  É melhor analisar o maior número de métricas possível, mas decidi que algumas são mais úteis que outras. </p><br><ul><li><p>  O tempo de construção e o tempo de rasterização (métricas fornecidas por padrão usando o <code>TimelineSummary</code> ) são úteis apenas para testes de desempenho realmente difíceis, que não incluem muito mais do que a criação de uma interface com o usuário. </p><br></li><li><p>  Não considere <code>TimelineSummary.frameCount</code> como uma maneira de calcular quadros por segundo (FPS).  As ferramentas de perfil de vibração não fornecem informações reais sobre taxa de quadros.  <code>TimelineSummary</code> fornece o método <code>countFrames()</code> , mas conta apenas o número de montagens de quadros concluídas.  Um aplicativo bem otimizado que limita reconstruções desnecessárias (atualizações) terá FPS mais baixo do que um aplicativo não otimizado que reconstrói com freqüência. </p><br></li><li><p>  Pessoalmente, obtenho os dados mais úteis medindo o tempo total do processador gasto executando o código Dart.  Isso conta o código executado nos métodos de <code>build</code> e fora deles.  Supondo que você execute testes de criação de perfil em um dispositivo com bloqueio de escala, o tempo total da CPU pode ser considerado uma boa aproximação de quanto mais / menos bateria seu aplicativo consumirá. <br><img src="https://habrastorage.org/getpro/habr/post_images/bca/5e4/cf8/bca5e4cf8e41dc0fbb7a314de92ef507.png"></p><br></li><li><p>  A maneira mais fácil de descobrir o tempo total do processador gasto na execução do código Dart é estimar o número de eventos <code>MessageLoop:FlushTasks</code> na linha do tempo.  Para Developer Quest, escrevi <a href="">uma ferramenta Dart</a> para extraí-los. </p><br></li><li><p>  Para encontrar lixo (lixo) (ou seja, quadros perdidos), procure extremos.  Por exemplo, para um caso específico do Developer Quest e o dispositivo em que testamos, é útil examinar o tempo de construção do 95º percentil.  (O tempo de construção do percentil 90 foi muito semelhante, mesmo se você comparar o código com níveis completamente diferentes de desempenho, e os números do percentil 99 forem geralmente barulhentos. Seu desempenho pode variar.) <br><img src="https://habrastorage.org/getpro/habr/post_images/496/e74/50c/496e7450c256ea47b319c66b7faea88d.png"></p><br></li><li><p>  Como mencionado acima, teste cada versão do seu aplicativo várias (talvez 100) vezes.  Em seguida, use dados médios ou percentuais com campos de erro.  Melhor ainda, use gráficos de extensão. </p><br></li></ul><br><h1 id="rezultaty">  Resultados </h1><br><p>  Após o ajuste, você pode comparar com confiança e realizar experimentos.  Abaixo, você pode ver a resposta para um dilema comum: “essa otimização dos custos de manutenção vale a pena?” <br><img src="https://habrastorage.org/getpro/habr/post_images/6e7/2c7/0e0/6e72c70e0077c95ce8d68abe26d886f5.png"></p><br><p>  Penso que, <em>neste</em> caso em <em>particular</em> , a resposta é sim.  Graças a apenas algumas linhas de código, cada passagem automatizada de nosso aplicativo leva em média 12% menos tempo de CPU. </p><br><p>  Mas - e esta é a principal mensagem deste artigo - as medidas de outra otimização podem mostrar algo completamente diferente.  É tentador, mas errado, tentar extrapolar amplamente uma medição de desempenho. </p><br><p>  Em outras palavras: "que sorte".  E nós temos que aturar isso. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451840/">https://habr.com/ru/post/pt451840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451826/index.html">Aumentando a imprudência de marketing: casos comprovados</a></li>
<li><a href="../pt451828/index.html">O principal segredo do Google I / O 2019, que não pode ser encontrado na Internet</a></li>
<li><a href="../pt451830/index.html">Brevemente com a implementação do AES 128 BCE</a></li>
<li><a href="../pt451832/index.html">Como entender quando os proxies estão: verificação de locais físicos dos proxies da rede usando o algoritmo de geolocalização ativo</a></li>
<li><a href="../pt451834/index.html">Acidentes graves em data centers: causas e efeitos</a></li>
<li><a href="../pt451842/index.html">Sobre encontrar-se</a></li>
<li><a href="../pt451848/index.html">Automatizando vamos criptografar o gerenciamento de certificados SSL usando o desafio DNS-01 e a AWS</a></li>
<li><a href="../pt451852/index.html">Execução remota de código arbitrário no RDP</a></li>
<li><a href="../pt451854/index.html">Entrevista - 10 perguntas sobre Swift. Parte 1</a></li>
<li><a href="../pt451856/index.html">Instale o openmeetings 5.0.0-M1. Conferências WEB sem Flash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>