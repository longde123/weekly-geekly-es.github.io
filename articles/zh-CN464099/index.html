<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛂 📭 🖋️ VKScript语言分析：JavaScript，是吗？ ↘️ 🔩 🚨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 



 VKScript 不是 JavaScript。 这种语言的语义从根本上不同于JavaScript的语义。 见结论 。 
 什么是VKScript？ 



 VKScript是VKontakte execute API方法中使用的一种类似于JavaScript的脚本编程语言，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VKScript语言分析：JavaScript，是吗？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464099/"><h1>  TL; DR </h1><br><hr><br><p>  VKScript <b>不是</b> JavaScript。 这种语言的语义从根本上不同于JavaScript的语义。 见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> 。 </p><br><a name="habracut"></a><h1> 什么是VKScript？ </h1><br><hr><br><p> <b>VKScript</b>是VKontakte <code>execute</code> API方法中使用的一种类似于JavaScript的脚本编程语言，它使客户能够准确下载所需的信息。 本质上，VKScript是Facebook用于相同目的的GraphQL的类似物。 </p><br><p> 比较GraphQL和VKScript： </p><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  GraphQL </th><th>  VK脚本 </th></tr><tr><td> 实作 </td><td> 许多采用不同编程语言的开源实现 </td><td>  VK API内唯一的实现 </td></tr><tr><td> 基于 </td><td> 全新的语言 </td><td>  Java脚本 </td></tr><tr><td> 可能性 </td><td> 数据请求，有限过滤； 查询参数不能使用先前查询的结果 </td><td> 客户自行决定对数据进行的任何后处理；  API请求以方法的形式表示，可以使用先前请求中的任何数据 </td></tr></tbody></table></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VK API文档</a> （唯一的官方语言文档）中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法页面上</a>的VKScript描述： </p><br><blockquote><div class="scrollable-table"><table><tbody><tr><th> 代号 </th><td>  <b>VKScript中的</b>算法代码-一种类似于<b>JavaScript</b>或<b>ActionScript</b>的格式<i>（假定与<b>ECMAScript</b>兼容）</i> 。 该算法应以命令<b>return％expression％结束</b> 。 运算符必须用分号分隔。 <br> 弦 </td></tr></tbody></table></div><br><p> 支持以下内容： </p><br><ul><li> 算术运算 </li><li> 逻辑运算 </li><li> 创建数组和列表（[X，Y]） </li><li>  <b>parseInt</b>和<b>parseDouble</b> </li><li> 串联（+） </li><li>  <b>如果</b>构造 </li><li> 按参数（@。）进行数组过滤 </li><li>  <b>API</b>方法调用， <b>长度</b>参数 </li><li> 使用<b>while</b>语句循环 </li><li>  Javascript方法： <b>slice</b> ， <b>push</b> ， <b>pop</b> ， <b>shift</b> ， <b>unshift</b> ， <b>splice</b> ， <b>substr</b> ， <b>split</b> </li><li>  <b>删除</b>运算符 </li><li> 分配给数组元素，例如：row.user.action =“ test”; </li><li> 数组或字符串中的搜索为<b>indexOf</b> ，例如：“ 123” .indexOf（2）= 1，[1、2、3] .indexOf（3）=2。如果未找到该元素，则返回-1。 </li></ul><br><p> 当前不支持函数创建。 </p><br></blockquote><br><p> 引用的文档指出“已计划ECMAScript兼容性”。 但是是这样吗？ 让我们尝试从内部了解这种语言的工作方式。 </p><br><br><h1> 目录内容 </h1><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VKScript虚拟机</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VKScript对象的语义</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ol><br><a name="vm"></a><h1>  VKScript虚拟机 </h1><br><hr><br><p> 在没有本地副本的情况下如何分析程序？ 没错-将请求发送到公共端点并分析答案。 例如，让我们尝试执行以下代码： </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p> 我们收到<code>Runtime error occurred during code invocation: Too many operations</code>的<code>Runtime error occurred during code invocation: Too many operations</code> 。 这表明在执行该语言时，所执行的操作数是有限制的。 让我们尝试设置确切的极限值： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>Runtime error occurred during code invocation: Too many operations</code> 。 </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>{"response": null}</code> -代码成功执行。 </li></ul><br><p> 因此，操作次数的限制约为1000个“空闲”周期。 但是，与此同时，很明显，这种循环很可能不是“单一”的操作。 让我们尝试找到一个不会被编译器分成几个较小的操作的操作。 </p><br><p> 此类操作最明显的候选者是所谓的空语句（ <code>;</code> ）。 但是，在将代码添加到<code>i &lt; 999</code> 50个字符之后<code>;</code>  ，不超过限制。 这意味着要么空语句由编译器抛出并且不浪费操作，要么循环的一次迭代需要50个以上的操作（很可能不是这样）。 </p><br><p> 之后想到的下一件事<code>;</code>  -计算一些简单的表达式（例如： <code>1;</code> ）。 让我们尝试将其中一些表达式添加到我们的代码中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1; //       "Too many operations"</span></span></code> </pre> <br><p> 因此，2个操作<code>1;</code> 花费的手术多于50次<code>;</code>  。 这证实了以下假设：空语句不会浪费指令。 </p><br><p> 让我们尝试减少循环的迭代次数，并增加<code>1;</code>  。 容易注意到，每次迭代有5个额外的<code>1;</code> 因此，循环的一次迭代所花的运算量比一个运算<code>1;</code>多5倍<code>1;</code>  。 </p><br><p> 但是，有没有更简单的操作？ 例如，添加一元运算符<code>~</code>不需要计算其他表达式，并且运算本身在处理器上执行。 逻辑上假设将此操作添加到表达式中会使操作总数增加1。 </p><br><p> 将此运算符添加到我们的代码中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p> 是的，我们可以添加一个这样的运算符，再添加一个表达式<code>1;</code>  -不再。 因此， <code>1;</code> 确实不是单一运营商。 </p><br><p> 与运算符<code>1;</code>类似<code>1;</code>  ，我们将减少循环的迭代次数并添加<code>~</code>运算符。 一次迭代等于10个unit运算<code>~</code> ，因此，表达式<code>1;</code> 花费2次操作。 </p><br><p> 请注意，该限制约为1000次迭代，即大约10,000次单个操作。 我们假设该限制恰好是10,000次操作。 </p><br><br><h2> 测量代码中的操作数 </h2><br><hr><br><p> 请注意，现在我们可以测量任何代码中的操作数。 为此，请在循环后添加此代码，并添加/删除迭代， <code>~</code>运算符或最后一行，直到“ <code>Too many operations</code>错误消失。 </p><br><p> 一些测量结果： </p><br><div class="scrollable-table"><table><tbody><tr><th> 代号 </th><th> 操作次数 </th></tr><tr><td> <code>1;</code> </td> <td>  2 </td></tr><tr><td> <code>~1;</code> </td> <td>  3 </td></tr><tr><td> <code>1+1;</code> </td> <td>  4 </td></tr><tr><td> <code>1+1+1;</code> </td> <td>  6 </td></tr><tr><td> <code>(true?1:1);</code> </td> <td>  5 </td></tr><tr><td> <code>(false?1:1);</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;</code> </td> <td>  2 </td></tr><tr><td> <code>if(1)1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;else 1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(1)1;else 1;</code> </td> <td>  5 </td></tr><tr><td> <code>while(0);</code> </td> <td>  2 </td></tr><tr><td> <code>i=1;</code> </td> <td>  3 </td></tr><tr><td> <code>i=i+1;</code> </td> <td>  5 </td></tr><tr><td> <code>var j = 1;</code> </td> <td>  1个 </td></tr><tr><td> <code>var j = 0;while(j &lt; 1)j=j+1;</code> </td> <td>  15 </td></tr></tbody></table></div><br><br><h2> 确定虚拟机的类型 </h2><br><hr><br><p> 首先，您需要了解VKScript解释器的工作方式。 有两种或多或少的合理选择： </p><br><ul><li> 解释器递归地遍历语法树并在每个节点上执行操作。 </li><li> 编译器将语法树转换为解释器执行的指令序列。 </li></ul><br><p> 很容易理解，VKScript使用了第二个选项。 考虑一下表达式<code>(true?1:1);</code>  （5个操作）和<code>(false?1:1);</code>  （4次操作）。 在顺序执行指令的情况下，通过“绕过”错误的选项的转换来解释附加操作，在递归AST旁路的情况下，两个选项对于解释器都是等效的。 如果/否则，在不同条件下会观察到类似的效果。 </p><br><p> 另外，对<code>i = 1;</code>也是值得关注的<code>i = 1;</code>  （3个运算），并且<code>var j = 1;</code>  （1次操作）。 创建一个新变量仅花费1个操作，而分配给一个现有变量则花费3个操作？ 创建变量需要花费1次操作（并且很可能是恒定的加载操作），这一事实说明了两点： </p><br><ul><li> 创建新变量时，没有为该变量显式分配内存。 </li><li> 创建新变量时，该值不会加载到存储单元中。 这意味着将在计算表达式值的位置分配用于新变量的空间，然后将其视为已分配的内存。 这建议使用堆栈机。 </li></ul><br><p> 使用堆栈还可以解释表达式<code>var j = 1;</code> 比表达式<code>1;</code>运行更快<code>1;</code>  ：最后一个表达式花费额外的指令从堆栈中删除计算值。 </p><br><br><h2> 确定确切的极限值 </h2><br><p> 注意循环<code>var j=0;while(j &lt; 1)j=j+1;</code>  （15个操作）是用于测量的循环的一小部分副本： </p><br><div class="scrollable-table"><table><tbody><tr><th> 代号 </th><th> 操作次数 </th></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 + 998 * 10 = 9995 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  （限制） </td><td>  9998 </td></tr></tbody></table></div><br><p> 停什么 是否有9998条指令的限制？ 我们显然缺少了一些东西... </p><br><p> 请注意， <code>return 1;</code>码为<code>return 1;</code> 根据0条指令的测量结果执行。 这很容易解释：编译器在代码的末尾添加了一个隐式的<code>return null;</code>  ，并且在添加返回值时失败。 假设限制为10000，我们得出的结论是该操作<code>return null;</code> 需要2条指令（可能这类似于<code>push null; return;</code> ）。 </p><br><br><h2> 嵌套代码块 </h2><br><hr><br><p> 让我们进行更多测量： </p><br><div class="scrollable-table"><table><tbody><tr><th> 代号 </th><th> 操作次数 </th></tr><tr><td> <code>{};</code> </td> <td>  0 </td></tr><tr><td> <code>{var j = 1;};</code> </td> <td>  2 </td></tr><tr><td> <code>{var j = 1, k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>{var j = 1; var k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>var j = 1; var j = 1;</code> </td> <td>  4 </td></tr><tr><td> <code>{var j = 1;}; var j = 1;</code> </td> <td>  3 </td></tr></tbody></table></div><br><p> 让我们注意以下事实： </p><br><ul><li> 将变量添加到块中需要执行一项额外的操作。 </li><li> 当“再次声明变量”时，第二个声明作为常规分配完成。 </li><li> 但是同时，从外部看不到块内部的变量（请参见最后一个示例）。 </li></ul><br><p> 很容易理解，花了额外的操作从堆栈中删除块中声明的局部变量。 因此，当没有局部变量时，不需要删除任何内容。 </p><br><br><h1> 对象，方法，API调用 </h1><br><hr><br><div class="scrollable-table"><table><tbody><tr><th> 代号 </th><th> 操作次数 </th></tr><tr><td> <code>"";</code> </td> <td>  2 </td></tr><tr><td> <code>"abcdef";</code> </td> <td>  2 </td></tr><tr><td> <code>{};</code> </td> <td>  2 </td></tr><tr><td> <code>[];</code> </td> <td>  2 </td></tr><tr><td> <code>[1, 2, 3];</code> </td> <td>  5 </td></tr><tr><td> <code>{a: 1, b: 2, c: 3};</code> </td> <td>  5 </td></tr><tr><td> <code>API.users.isAppUser(1);</code> </td> <td>  3 </td></tr><tr><td> <code>"".substr(0, 0);</code> </td> <td>  6 </td></tr><tr><td> <code>var j={};jx=1;</code> </td> <td>  6 </td></tr><tr><td> <code>var j={x:1};delete jx;</code> </td> <td>  6 </td></tr></tbody></table></div><br><p> 让我们分析结果。 您可能会注意到，创建一个字符串和一个空数组/对象需要2次操作，加载数字也一样。 创建非空数组或对象时，将添加花费在加载数组/对象元素上的操作。 这表明在一个操作中直接创建对象。 同时，不浪费时间下载属性名称；因此，下载属性名称是创建对象的操作的一部分。 </p><br><p> 使用API​​方法调用，一切也很平常-加载一个单元，实际调用该方法， <code>pop</code>结果（您会注意到方法名称是作为一个整体处理的，而不是作为属性来处理的）。 但是最后三个示例看起来很有趣。 </p><br><ul><li> <code>"".substr(0, 0);</code>  -加载字符串，加载零，加载零， <code>pop</code>结果。 由于某种原因，有2条关于调用方法的指令（出于某种原因，请参见下文）。 </li><li> <code>var j={};jx=1;</code>  -创建对象，加载对象，加载单元，分配后<code>pop</code>单元。 同样，有2条分配说明。 </li><li> <code>var j={x:1};delete jx;</code>  -加载单元，创建对象，加载对象，删除。 每个删除操作有3条指令。 </li></ul><br><br><a name="semantics"></a><br><h1>  VKScript对象的语义 </h1><br><h2> 数字 </h2><br><hr><br><p> 回到原始问题：VKScript是JavaScript或另一种语言的子集吗？ 让我们做一个简单的测试： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> + <span class="hljs-number"><span class="hljs-number">2000000000</span></span>;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-number"><span class="hljs-number">-1294967296</span></span>};</code> </pre> <br><p> 我们可以看到，尽管JavaScript没有这样的整数，但整数加法仍会导致溢出。 也很容易验证除以0会导致错误，并且不返回<code>Infinity</code> 。 </p><br><br><h2> 对象 </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {};</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p> 停什么 我们返回<i>一个对象</i>并得到一个<i>数组</i> ？ 是的，是的。 在VKScript中，数组和对象用相同的类型表示，特别是，一个空对象和一个空数组是相同的。 在这种情况下，对象的<code>length</code>属性起作用并返回属性的数量。 </p><br><p> 有趣的是，如果在对象上调用列表方法，它们的行为如何？ </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  <code>pop</code>方法返回最后声明的属性，但这是合乎逻辑的。 更改属性的顺序： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p> 显然，VKScript中的对象会记住分配属性的顺序。 让我们尝试使用数字属性： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p> 现在，让我们看一下推送的工作原理： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(<span class="hljs-string"><span class="hljs-string">'d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p> 如您所见，push方法对数字键进行排序，并在最后一个数字键之后添加一个新值。 在这种情况下不填充“孔”。 </p><br><p> 现在尝试结合这两种方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(a.pop()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p> 如我们所见，该元素尚未从数组中删除。 但是，如果我们将<code>push</code>和<code>pop</code>放在不同的行中，该错误将消失。 我们需要更深入！ </p><br><br><h2> 对象存储 </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = x; xy = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p> 事实证明，与JavaScript不同，VKScript中的对象是按值存储的。 现在我们看到了字符串<code>a.push(a.pop());</code>的奇怪行为<code>a.push(a.pop());</code>  -显然，数组的旧值保存在堆栈中，以后从那里获取。 </p><br><p> 但是，如果方法修改了该数据，该如何存储在对象中呢？ 显然，调用该方法时的“额外”指令是专门为将更改写回到对象而设计的。 </p><br><br><h2> 数组方法 </h2><br><hr><br><div class="scrollable-table"><table><tbody><tr><th> 方法 </th><th> 动作片 </th></tr><tr><td> <code>push</code> </td> <td><ul><li> 按值对数字键排序 </li><li> 取最大数字键，加一个 </li><li> 将参数写入数组 </li><li> 将非数字键添加到数组的末尾 </li></ul></td></tr><tr><td> <code>pop</code> </td> <td> 从数组中删除最后一个元素（不必使用数字键）并返回。 </td></tr><tr><td> 其余的 </td><td><ul><li> 按值对数字键进行排序，删除数组中的“孔” </li><li> 执行适当的JavaScript操作 </li><li> 将非数字键添加到数组的末尾 </li></ul><br><p> 使用切片方法时，不会保存更改 </p><br></td></tr></tbody></table></div><br><a name="summary"></a><h1> 结论 </h1><br><hr><br><p>  VKScript不是JavaScript。 与JavaScript不同，JavaScript中的对象是按值存储的，而不是按引用存储的，它们具有完全不同的语义。 但是，将VKScript用于预期目的时，差异并不明显。 </p><br><br><h1>  PS运算符语义 </h1><br><hr><br><p> 提到了通过<code>+</code>组合对象的注释。 在这方面，我决定添加有关操作员工作的信息。 </p><br><div class="scrollable-table"><table><tbody><tr><th> 操作员 </th><th> 动作 </th></tr><tr><td>  + </td><td><ul><li> 如果两个参数都是对象，请创建第一个对象的副本，然后将第二个对象的键（并替换）添加到该对象。 </li><li> 如果两个参数都是数字，则添加为数字。 </li><li> 否则，两个操作数都将转换为字符串并添加为字符串。 </li></ul></td></tr><tr><td> 其他算术运算符 </td><td> 两个操作数都强制转换为数字，并执行相应的操作。 对于位运算，操作数还强制转换为<code>int</code> 。 </td></tr><tr><td> 比较运算符 </td><td> 如果比较两个字符串或两个数字，则直接比较它们。 如果将字符串和数字进行比较，并且该字符串是该数字的正确表示法，则该字符串将强制转换为数字。 否则，将返回“ <code>Comparing values of different or unsupported types</code>错误。 </td></tr><tr><td> 转换为字符串 </td><td> 数字和字符串如JavaScript中所示。 对象按键顺序以逗号分隔的值列表形式列出。  <code>false</code>和<code>null</code>强制转换为<code>""</code> ， <code>true</code>强制转换为<code>"1"</code> 。 </td></tr><tr><td> 投放到 </td><td> 如果参数是一个有效数字符号的字符串，则返回数字。 否则， <code>Numeric arguments expected</code>返回<code>Numeric arguments expected</code>错误。 </td></tr></tbody></table></div><br><p> 对于数字操作（位除外），如果操作数为<code>int</code>和<code>double</code> ，则将<code>int</code> <code>double</code>为<code>double</code> 。 如果两个操作数均为<code>int</code> ，则对有符号的32位整数执行操作（带有溢出）。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464099/">https://habr.com/ru/post/zh-CN464099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464089/index.html">在Spring上下文中自动化HTTP请求</a></li>
<li><a href="../zh-CN464091/index.html">适用于移动311开发人员的有趣材料的摘要（8月12日至18日）</a></li>
<li><a href="../zh-CN464093/index.html">数字商品：如果客户一年内来提货，该怎么办？</a></li>
<li><a href="../zh-CN464095/index.html">Dart和Flutter中的Getter和Setter</a></li>
<li><a href="../zh-CN464097/index.html">智慧的演变：为何机器人需要情感</a></li>
<li><a href="../zh-CN464103/index.html">OpenUNB国家物联网标准草案：关键审查</a></li>
<li><a href="../zh-CN464105/index.html">带有Docker Compose的本机Commento服务器</a></li>
<li><a href="../zh-CN464107/index.html">8月19日至25日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN464109/index.html">太空超音速降落伞</a></li>
<li><a href="../zh-CN464111/index.html">Natas网站。 旨在利用Web漏洞的CTF平台的通过</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>