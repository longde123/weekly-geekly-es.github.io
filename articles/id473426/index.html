<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 ⤴️ 🌌 Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 1. Organisasi 🐅 ⬇️ 🕰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan artikel ini, kami membuka serangkaian publikasi tentang bagaimana kami mengotomatiskan proses pengujian manual sistem informasi besar di salah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 1. Organisasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/473426/">  Dengan artikel ini, kami membuka serangkaian publikasi tentang bagaimana kami mengotomatiskan proses pengujian manual sistem informasi besar di salah satu proyek utama LANIT dan apa yang dihasilkannya. <br><br>  <i>Bagian pertama - organisasi dan manajerial - harus bermanfaat terutama bagi mereka yang bertanggung jawab untuk pengujian otomatisasi dan membuat sistem seperti itu secara keseluruhan.</i>  <i>Manajer proyek, pemimpin kelompok dan pemilik layanan pengujian fungsional dan otomatis, <b>semua yang peduli dengan pertanyaan "bagaimana membangun pengujian 2-end ujung-ujung sistem TI mereka", akan menemukan di sini rencana dan metodologi yang konkret.</b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/664/45f/8f366445ff952429d3a43ff7911ef34d.jpg"></div>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a></i> <br><a name="habracut"></a><br><h1>  Bagian 1 - Organisasi dan manajerial.  Kenapa kita perlu otomatisasi.  Organisasi proses pengembangan dan manajemen.  Organisasi penggunaan </h1><br>  Awalnya, pada awalnya ada sistem informasi yang besar dan kompleks (kami akan menyebutnya "Sistem") dengan berbagai skenario bisnis yang kompleks, panjang dan saling berhubungan.  Semua skrip diuji sebagai E2E melalui antarmuka web secara eksklusif dalam mode manual (ada lebih dari satu setengah ribu skenario semacam itu dari prioritas paling kritis saja).  Selain itu, semua skenario ini harus diselesaikan setidaknya satu kali selama regresi setiap rilis baru atau perbaikan terbaru sebelum pembaruan penempatan berikutnya untuk produk. <br><br>  Pada saat tertentu, ketika mengklik mouse sepenuhnya dalam mode manual, kami memutuskan untuk mengotomatiskan semuanya.  Yang dilakukan melalui pengembangan layanan terpisah berdasarkan java + selenium + selenide + selenoid, yang selanjutnya disebut <b>"kerangka pengujian"</b> atau hanya - <b>"Autotests"</b> . <br><br>  Secara historis, kode kerangka kerja pengujian dikembangkan oleh dua tim.  Pertama, tim pertama menciptakan prototipe dengan beberapa lusin skenario.  Kemudian tim kedua selama satu tahun menskalakan prototipe baik dalam luasnya (jumlah tes) dan mendalam (pengkodean dan pola implementasi yang khas diperkenalkan). <br><br>  Saya adalah tim dan ketua tim dari tim kedua, yang mengadopsi kerangka kerja prototipe untuk penskalaan (pada Mei 2018). <br><br>  Pada saat penulisan ini, tugas yang ditetapkan setahun yang lalu telah selesai dan tim proyek diberikan <u><b>layanan</b></u> otomatisasi yang stabil.  Bukan sia-sia saya menekankan <u><b>layanan</b></u> , karena pada awalnya tugas itu tidak ditetapkan sebagai mengembangkan aplikasi, tetapi sebagai menyediakan layanan-layanan untuk pengujian otomatisasi ke grup "pengujian fungsional".  Dan fitur ini selanjutnya sangat memengaruhi organisasi pengembangan dan arsitektur kerangka pengujian. <br><br><blockquote><h2>  Ringkasan </h2><br>  Sekitar 1.500 skenario pengujian diotomatiskan: dalam setiap pengujian, dari 200 hingga 2000 operasi pengguna. <br><br>  Total kapasitas layanan ini hingga 60 browser yang bekerja secara bersamaan, dan ini bukan batasnya (jumlahnya dapat ditingkatkan 5 kali karena mesin virtual). <br>  Total durasi regresi lengkap tidak lebih dari 3 jam, dan tes PreQA kurang dari satu jam. <br><br>  Berbagai fitur telah diimplementasikan: <br><br><ul><li>  penggunaan lokal (eksekusi real-time) dan jarak jauh (melalui paket Bamboo); </li><li>  membatasi komposisi tes yang berjalan dengan filter; </li><li>  laporan terperinci dengan hasil dari setiap langkah skenario pengujian (melalui kerangka kerja Allure); </li><li>  mengunduh dan mengunggah file dari / ke browser, diikuti dengan memeriksa hasil pemrosesan mereka dalam hal format dan isi file; </li><li>  akuntansi dan kontrol sifat asinkron dari antarmuka sudut.  Termasuk kontrol permintaan yang digantung (permintaan yang tertunda) antara layanan Angular dan REST; </li><li>  kontrol log browser; </li><li>  rekaman uji video; </li><li>  menghapus snapshot halaman pada titik "jatuh" dari tes; </li><li>  transmisi acara dalam ELK; </li><li>  lebih banyak tentang hal-hal kecil ... </li></ul><br></blockquote><br><h1>  Mengapa semua ini dibutuhkan? </h1><br>  Pada awalnya, tujuan dari sistem itu cukup sederhana dan jelas. <br><br>  Bayangkan Anda memiliki sistem registri besar untuk mengelola berbagai dokumen dan siklus hidupnya, yang menyediakan beberapa ratus proses bisnis.  Selain itu, ada jutaan orang, pemasok - puluhan ribu, layanan - ribuan, dokumen kompleks, termasuk kerangka kerja dan templat, dan menyediakan proses bisnis disediakan dalam ratusan cara berbeda ... <br><br>  Semua ini berubah menjadi satu setengah ribu skenario pengujian, dan ini hanya prioritas tertinggi dan hanya positif. <br><br>  Dalam proses otomatisasi, berbagai nuansa terungkap yang membutuhkan penggunaan berbagai solusi. <br><br>  Misalnya, satu skrip dapat berisi hingga ratusan operasi terpisah, termasuk yang menarik seperti: "Unduh file EXCEL dengan data dan verifikasi bahwa sistem memproses setiap catatan dari file" (untuk menyelesaikan masalah ini, diperlukan beberapa langkah untuk menyiapkan data dan kemudian memeriksa hasil pemuatan ke dalam Sistem)  Dan sekarang mari kita tambahkan batasan pada penggunaan kembali data uji: data uji untuk penyelesaian sebagian besar skenario uji harus "segar" dan sebelumnya tidak digunakan dalam skenario yang sama (selama pengujian, keadaan data dalam Sistem berubah, sehingga tidak dapat digunakan kembali untuk cek yang sama). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/0a7/ccc/2420a7ccc161bb7ee6537a73cd6bd33a.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  Pada titik tertentu, pengujian manual terhadap Sistem sebagai bagian dari regresi tidak lagi tampak hemat biaya dan cukup cepat, dan mereka memutuskan untuk mengotomatiskannya melalui antarmuka pengguna web. <br><br>  Dengan kata lain, kelompok pengujian fungsional membuka "halaman", memilih "kelompok uji", menekan tombol "jalankan" (kami menggunakan Bambu).  Kemudian Autotests (selanjutnya disebut Autotests. Tentukan produk yang dibuat untuk pengujian secara umum) secara otomatis meniru tindakan pengguna dalam Sistem melalui browser ("tekan" tombol yang diperlukan, masukkan nilai di bidang, dll.), Setelah selesai, tampilkan laporan terperinci pada semua langkah-langkah dan tindakan serta hasil verifikasi yang diselesaikan (korespondensi dari reaksi yang diharapkan dari Sistem dengan perilaku aktualnya). <br><br>  Total, tujuan Autotests adalah otomatisasi pengujian E2E manual.  Ini adalah sistem "eksternal" yang tidak mengambil bagian dalam proses pengembangan sistem yang sedang diuji dan sama sekali tidak terhubung dengan unit atau tes integrasi yang digunakan oleh pengembang. <br><br><h2>  Tujuan </h2><br>  Itu perlu untuk secara signifikan mengurangi biaya tenaga kerja melakukan pengujian End-2-End dan meningkatkan kecepatan regresi lengkap dan berkurang dalam hal volume. <br><br><div class="spoiler">  <b class="spoiler_title">Tujuan tambahan</b> <div class="spoiler_text"><ul><li>  untuk memastikan kecepatan tinggi pengembangan autotest dengan tingkat otonomi yang tinggi (kebutuhan untuk pengisian awal dengan data uji dudukan Sistem / pengaturan Autotest untuk berjalan di setiap tegakan harus diminimalkan); </li><li>  mengoptimalkan pengeluaran (waktu dan keuangan) untuk komunikasi antara otomatisasi, pengujian fungsional dan tim pengembangan sistem; </li><li>  meminimalkan risiko ketidaksesuaian antara autotest yang benar-benar diterapkan dan harapan awal dari tim pengujian fungsional (tim pengujian fungsional harus tanpa syarat mempercayai hasil dari AutoTests). </li></ul></div></div><br><h2>  Tugasnya </h2><br>  Tugas utama pengembangan diformulasikan dengan sangat sederhana - untuk mengotomatisasi selama 6 bulan ke depan 1000 skenario pengujian dengan prioritas tertinggi. <br><br>  Jumlah tindakan uji dasar yang diperkirakan berkisar antara 100 hingga 300, yang memberi kami sekitar 200 ribu metode uji dengan 10-20 baris kode, tanpa memperhitungkan kelas umum dan tambahan pembantu, penyedia data, dan model data. <br><br>  Dengan demikian, ternyata, dengan mempertimbangkan batasan waktu (130 hari kerja), perlu untuk melakukan setidaknya 10 tes per hari dan pada saat yang sama memastikan relevansi tes mandiri yang diterapkan dengan mempertimbangkan perubahan yang terjadi dalam Sistem (Sistem secara aktif berkembang). <br><br>  Menurut perkiraan para ahli, tenaga kerja yang dibutuhkan untuk mengembangkan satu autotest adalah 4-8 jam.  Jadi kami memiliki tim yang terdiri dari 5 orang setidaknya (pada kenyataannya, di puncak pengembangan autotests, tim memiliki lebih dari 10 insinyur otomasi). <br><br>  Tugas-tugas yang perlu diselesaikan juga bisa dimengerti. <br><br><ul><li>  <b>Konfigurasikan proses dan perintah:</b> </li><li>  mendefinisikan proses interaksi dengan pelanggan (kelompok pengujian fungsional), memperbaiki format deskripsi kasus pengujian sebagai input ke tim otomasi; </li><li>  mengatur proses pengembangan dan pemeliharaan; </li><li>  membentuk tim. <br></li><li>  <b>Kembangkan autotest dengan fitur berikut:</b> </li><li>  secara otomatis mengklik tombol di browser dengan pemeriksaan pendahuluan untuk keberadaan elemen dan informasi yang diperlukan pada halaman; </li><li>  menyediakan pekerjaan dengan elemen kompleks seperti Yandex.Map; </li><li>  untuk memastikan pemuatan file yang dihasilkan secara otomatis ke dalam Sistem, untuk memastikan pengunduhan file dari Sistem dengan verifikasi format dan kontennya. </li><li>  Berikan catatan dari tangkapan layar browser, video dan log internal. </li><li>  Untuk memberikan kemampuan untuk berintegrasi dengan sistem eksternal seperti server surat, sistem pelacakan tugas (JIRA) untuk memeriksa proses integrasi antara Sistem yang diuji dan sistem eksternal. </li><li>  Berikan laporan yang terdokumentasi tentang semua tindakan yang diambil, termasuk tampilan nilai yang dimasukkan dan diverifikasi, serta semua investasi yang diperlukan. </li><li>  Lakukan tes dalam volume yang diperlukan dalam mode paralel. </li><li>  Menyebarkan autotest di infrastruktur yang ada. </li><li>  Sempurnakan skrip uji yang sudah otomatis dari konsep target konsonan (kecepatan perbaikan - sekitar 50 tes per minggu sprint). </li></ul><br>  Seperti yang saya sebutkan dalam pendahuluan, pada awalnya kami memiliki prototipe MVP yang bekerja diimplementasikan oleh tim lain, yang harus ditingkatkan dari 20 tes menjadi 1000, menambahkan fitur baru di sepanjang jalan, dan memastikan skalabilitas yang dapat diterima dan fleksibilitas untuk membuat perubahan. <br><br>  Kehadiran prototipe yang berfungsi juga di pintu masuk memberi kami tumpukan teknologi, yang meliputi: Java SE8, JUnit4, Selenium + Selenide + Selenoid, Bambu sebagai "pelari" pengujian dan "pembangun" laporan Allure.  Karena prototipe bekerja dengan baik dan menyediakan fungsionalitas dasar yang diperlukan, kami memutuskan untuk tidak mengubah tumpukan teknologi, tetapi untuk fokus pada pengembangan skalabilitas solusi, meningkatkan stabilitas dan mengembangkan fitur yang diperlukan yang hilang. <br><br>  Pada dasarnya, semuanya terlihat layak dan optimis.  Selain itu, kami benar-benar mengatasi tugas pada waktu tertentu. <br><br>  Berikut ini menjelaskan aspek teknologi dan proses individu dalam mengembangkan AutoTests. <br><br><h1>  Deskripsi Autotests.  Cerita dan Fitur Pengguna </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/e52/429/345e524291244a67e411a344257eafa8.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  Autotests mengimplementasikan rangkaian cerita pengguna berikut ini dalam konteks penggunaannya oleh kelompok pengujian: <br><br><ul><li>  otomasi uji manual; </li><li>  regresi penuh otomatis; </li><li>  kontrol kualitas rakitan dalam rantai CI \ CD. </li></ul><br>  Rincian implementasi dan keputusan arsitektur akan dibahas dalam <b>Bagian 2 - Teknis.</b>  <b>Arsitektur dan tumpukan teknis.</b>  <b>Detail implementasi dan kejutan teknis</b> . <br><br><h2>  Pengujian otomatis dan manual (Kisah pengguna) </h2><br>  Sebagai seorang penguji, saya ingin melakukan tes target E2E, yang akan dilakukan tanpa partisipasi langsung saya (dalam mode otomatis) dan akan memberi saya laporan terperinci dalam konteks langkah-langkah yang diambil, termasuk data yang dimasukkan dan hasil yang diperoleh, serta: <br><br><ul><li>  Seharusnya dimungkinkan untuk memilih tegakan target yang berbeda sebelum memulai tes; </li><li>  harus dapat mengelola komposisi tes berjalan dari semua yang diterapkan; </li><li>  di akhir tes, Anda perlu mendapatkan video tes dari layar browser; </li><li>  saat tes mogok, Anda perlu mendapatkan tangkapan layar dari jendela browser aktif. </li></ul><br><h2>  Regresi penuh otomatis </h2><br>  Sebagai grup pengujian, saya ingin melakukan semua tes setiap malam di bangku tes tertentu dalam mode otomatis, termasuk semua fitur "Pengujian manual otomatis". <br><br><h2>  Kontrol kualitas perakitan dalam rantai CI \ CD </h2><br>  Sebagai kelompok pengujian, saya ingin melakukan pengujian otomatis pembaruan yang disebarkan Sistem pada preQA-stand khusus sebelum memperbarui target tahap uji fungsi fungsional, yang kemudian digunakan untuk pengujian fungsional. <br><br><h1>  Menerapkan fitur dasar </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/92c/432/34792c43244275202d123378b2b6b72e.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  Berikut adalah sekilas fungsi-fungsi utama AutoTests yang diimplementasikan, yang ternyata sangat penting atau hanya berguna.  Rincian implementasi beberapa fungsi menarik akan ada di bagian kedua artikel. <br><br><h2>  Penggunaan lokal dan jarak jauh </h2><br>  Fungsi ini menawarkan dua opsi untuk menjalankan Autotests - lokal dan jarak jauh. <br><br>  Dalam mode lokal, tester menjalankan autotest yang diperlukan di tempat kerjanya dan pada saat yang sama dapat mengamati apa yang terjadi di browser.  Peluncuran dilakukan melalui "segitiga hijau" di IntelliJ IIDEA -).  Fungsi ini sangat berguna pada awal proyek untuk debugging dan demonstrasi, tetapi sekarang hanya digunakan oleh pengembang autotest. <br><br>  Dalam mode jarak jauh, tester memulai autotest menggunakan antarmuka paket Bamboo dengan parameter komposisi tes yang berjalan, dudukan dan beberapa parameter lainnya. <br><br>  <i>Fungsi ini diimplementasikan menggunakan variabel lingkungan MODE = REMOTE | LOCAL, tergantung pada mana browser web lokal atau jarak jauh diinisialisasi di cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selenoid</a> .</i> <br><br><h2>  Membatasi komposisi tes yang berjalan dengan filter </h2><br>  Fungsi ini memungkinkan untuk membatasi komposisi pengujian yang berjalan dalam mode penggunaan jarak jauh untuk kenyamanan pengguna dan untuk mengurangi waktu pengujian.  Filtrasi dua tahap digunakan.  Langkah pertama memblokir pelaksanaan tes berdasarkan variabel FILTER_BLOCK dan digunakan terutama untuk mengecualikan kelompok besar tes dari berjalan.  Langkah kedua "melompati" hanya tes yang cocok dengan variabel FILTER. <br><br>  Nilai filter ditentukan sebagai satu set ekspresi reguler REGEXP1, ..., REGEXPN, diterapkan oleh prinsip "OR". <br><br>  Ketika memulai dalam mode manual, tester diminta untuk menetapkan variabel lingkungan khusus sebagai daftar ekspresi reguler yang berlaku untuk anotasi @ Filter (nilai String) khusus, yang menjelaskan semua metode pengujian di kelas uji.  Untuk setiap pengujian, anotasi ini unik dan dibuat berdasarkan serangkaian tag yang dipisahkan oleh garis bawah.  Kami menggunakan templat minimum berikut SUBSYSTEM_FUNCTION_TEST-ID_ {DEFAULT}, di mana tag DEFAULT untuk tes yang termasuk dalam regresi malam otomatis. <br><br>  <i>Fungsi ini diimplementasikan melalui ekstensi kustom dari kelas org.junit.runners.BlockJUnit4ClassRunner (detail akan diberikan di Bagian 2-1 dari kelanjutan artikel ini)</i> <br><br><h2>  Mendokumentasikan laporan dengan hasil untuk semua langkah </h2><br>  Hasil tes ditampilkan untuk semua tindakan uji (langkah) dengan semua informasi yang diperlukan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia</a> di Allure Framework.  Untuk daftar mereka tidak masuk akal.  Ada informasi yang cukup baik di situs web resmi dan di Internet secara keseluruhan.  Tidak ada kejutan menggunakan Allure Framework, dan secara umum saya merekomendasikannya untuk digunakan. <br><br>  Fungsi utama yang digunakan adalah: <br><br><ul><li>  tampilan setiap langkah uji (nama langkah sesuai dengan namanya dalam spesifikasi tes - skrip uji); </li><li>  menampilkan parameter langkah dalam bentuk yang dapat dibaca manusia (melalui implementasi yang diperlukan dari metode toString dari semua nilai yang dikirimkan); </li><li>  Melampirkan tangkapan layar, video, dan berbagai file tambahan ke laporan; </li><li>  klasifikasi pengujian berdasarkan jenis dan subsistem, serta penghubungan autotest dengan spesifikasi pengujian dalam sistem manajemen tautan pengujian. Tautan Uji melalui penggunaan anotasi khusus. </li></ul><br><h2>  Unduh dan unggah file dari / ke browser dengan verifikasi dan analisis selanjutnya </h2><br>  Bekerja dengan file adalah aspek yang sangat penting dari skrip pengujian.  Itu perlu untuk menyediakan kedua unggah berbagai file, dan unduh. <br><br>  <b>Mengunduh file</b> tersirat, pertama-tama, memuat file EXCEL yang dihasilkan secara dinamis ke dalam Sistem sesuai dengan konteks eksekusi skrip pengujian.  Pengunduhan diimplementasikan menggunakan metode standar yang disediakan oleh alat selenium. <br><br>  <b>Mengunggah file</b> menyiratkan mengunduh file dengan menekan tombol "di browser ke direktori lokal dengan" transfer "file ini ke server tempat AutoTests dijalankan (server di mana agen Bambu jarak jauh diinstal).  Selanjutnya, file ini diuraikan dan dianalisis dalam hal format dan konten.  Jenis file utama adalah file EXCEL dan PDF. <br><br>  Implementasi fungsi ini ternyata menjadi tugas yang tidak sepele, terutama karena kurangnya kemampuan penanganan file standar: saat ini, fungsi hanya diterapkan untuk browser Chrome melalui halaman layanan "chrome: // unduhan /". <br><br>  Saya akan memberi tahu Anda secara rinci tentang detail implementasi di bagian kedua. <br><br><h2>  Akuntansi dan kontrol sifat asinkron antarmuka Angular.  Kontrol permintaan yang tertunda antara layanan Angular dan REST </h2><br>  Karena objek pengujian kami didasarkan pada Angular, kami harus belajar untuk "bertarung" dengan sifat asinkron dari frontend dan timeout. <br><br>  Secara umum, selain org.openqa.selenium.support.ui.FluentWait, kami menggunakan metode menunggu yang dirancang khusus yang memeriksa melalui Javascript untuk interaksi "tidak lengkap" dengan layanan REST front-end, dan berdasarkan batas waktu dinamis ini, tes mendapatkan informasi apakah akan mengikuti lalu tunggu sebentar. <br><br>  Dari sudut pandang fungsionalitas, kami dapat secara signifikan mengurangi waktu yang dibutuhkan untuk menyelesaikan tes karena penolakan terhadap harapan statis di mana tidak ada cara yang berbeda untuk menentukan penyelesaian operasi.  Selain itu, ini memungkinkan kami untuk menentukan layanan REST "menggantung" dengan masalah kinerja.  Misalnya, mereka menangkap layanan REST yang jumlah catatannya ditampilkan pada halaman diatur ke 10.000 elemen. <br><br>  Informasi tentang layanan REST "beku" dengan semua parameter panggilannya, yang karenanya uji "jatuh" karena alasan infrastruktur, ditambahkan ke hasil tes yang dijatuhkan, dan juga disiarkan sebagai acara di ELK.  Ini memungkinkan Anda untuk segera mentransfer masalah yang diidentifikasi ke tim pengembangan Sistem yang sesuai. <br><br><h2>  Kontrol Log Peramban </h2><br>  Fungsi kontrol log browser ditambahkan untuk mengontrol kesalahan pada halaman tingkat SEVERE untuk menerima informasi tambahan untuk tes yang dibatalkan, misalnya, untuk memantau kesalahan seperti "... Gagal memuat sumber daya: server merespons dengan status 500 (Kesalahan Server Internal)". <br><br>  Komposisi kesalahan pemrosesan halaman di browser diterapkan pada setiap hasil pengujian, dan juga diturunkan sebagai peristiwa dalam ELK. <br><br><h2>  Rekaman video tes dan menghapus snapshot halaman pada titik "jatuh" tes </h2><br>  Fungsi diimplementasikan untuk kenyamanan diagnosa dan penguraian tes yang dijatuhkan. <br><br>  Rekaman video diaktifkan secara terpisah untuk mode uji coba jarak jauh yang dipilih.  Video dilampirkan sebagai lampiran pada hasil dalam laporan Allure. <br>  Tangkapan layar diambil secara otomatis saat pengujian macet, dan hasilnya juga diterapkan ke laporan Allure. <br><br><h2>  Melewati acara ke ELK </h2><br>  Fungsi pengiriman peristiwa ke ELK diimplementasikan untuk memungkinkan analisis statistik dari perilaku umum AutoTests dan stabilitas objek uji.  Saat ini, acara telah dikirim untuk menyelesaikan tes dengan hasil dan durasi, serta kesalahan browser tingkat SEVERE dan memperbaiki layanan REST "beku". <br><br><h1>  Organisasi Pembangunan </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ee/a24/368/2eea243683bc7a87f0453db38b6c7947.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br><h2>  Tim pengembangan </h2><br>  Jadi, kami membutuhkan setidaknya 5 pengembang.  Tambahkan orang lain untuk mengkompensasi ketidakhadiran yang tidak direncanakan.  Kami mendapatkan 6. Plus seorang pemimpin tim, yang bertanggung jawab atas fungsionalitas lintas sektor dan tinjauan kode. <br><br>  Dengan demikian, perlu untuk mengambil 6 pengembang Java (pada kenyataannya, di puncak pengembangan autotests, tim melebihi 10 insinyur otomasi). <br><br>  Mengingat keadaan umum pasar dan tumpukan teknologi yang cukup sederhana, tim ini dibentuk terutama oleh pekerja magang, sebagian besar dari mereka baru saja lulus dari universitas atau berada di tahun terakhir mereka.  Bahkan, kami mencari orang-orang dengan pengetahuan dasar tentang Jawa.  Preferensi diberikan kepada spesialis pengujian manual yang ingin menjadi programmer, dan untuk memotivasi kandidat dengan beberapa pengalaman pengembangan (tidak penting) yang di masa depan ingin menjadi programmer. <br><br>             ,           (    <b> 2 – .    .     </b> ). <br><br>    ,           ,             .        CodeRush .    . <br><br><h2>   </h2><br>       . ,    , «»        . <br><br>           () .    code review   merge request ( GitLab).   code review   «»    (  )       . <br><br>     –           .           /   ,         . <br><br> ode review   , ,      ()   -   ,    . ode review  . <br><br>     code review         ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08f/c89/1c7/08fc891c7ccd91d6e6c2235c06149a69.jpg" align="left" width="300">  :     ,      ,      ,     ,         .        ,     ,    ,    / . <br><br>      « »,      -   -.         -. <br><br>                   ,               .    sprint retrospective event. <br><br><h2>     </h2><br>         - ( )    ,      stakeholder  . <br><br>        –    .   ,            ,          .   ,      -    .       . <br><br>        - ( ,      . .),          .     () ,       « » / « » ( ,      ,            ). <br><br>  -             -   ( :    -  – ,   - ,   — ,    ).  ,       -       /  :    « -      (  )». <br><br>      -  ,     - (-)      - («» ).     «» -          -  «     X» ( ,       -). <br><br><h2>   </h2><br>     ,    .      master,    -. -   -         code review. <br><br>     ,        –     ,        . <br><br> : <br><br> <b>(+)</b>        ; <br> <b>(+)</b>              ; <br> <b>(+)</b>  «»      ; <br> <b>(-)</b>      (); <br> <b>(-)</b>       hotfix . <br><br>       . <br><br> <b></b> <br><br><ul><li>      MASTER. </li><li>  . </li><li>      FEATURE . </li><li>           ,   «   »  rebase. </li><li> <b>     Gitlab   merge request    .  merge request- :</b> </li><li>  —       «Jira»; </li><li>  —       Bamboo. </li></ul><br> <b>GateKeeper ( )</b> <br><br><ul><li>         Bamboo. </li><li>          . </li><li>  (merge) FEATURE  DEVELOP,            . </li><li>    . </li></ul><br><hr><br> <i><b>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">kotalesssk</a> . <br><br>    1,      , .         2.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian kedua - yang teknis - difokuskan terutama pada para pemimpin kelompok otomasi pengujian end-2-end UI dan otomatisasi pengujian terkemuka. </font><font style="vertical-align: inherit;">Di sini mereka akan menemukan resep spesifik untuk organisasi arsitektural kode dan penyebaran, yang mendukung pengembangan paralel-massal kelompok besar pengujian dalam menghadapi variabilitas spesifikasi pengujian yang konstan. </font><font style="vertical-align: inherit;">Selain itu, Anda dapat menemukan di bagian kedua daftar lengkap fungsi yang diperlukan untuk pengujian UI dengan beberapa detail implementasi. </font><font style="vertical-align: inherit;">Dan daftar kejutan yang mungkin Anda temui juga.</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473426/">https://habr.com/ru/post/id473426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473412/index.html">Membuat plugin untuk Clang Static Analyzer untuk mencari bilangan bulat bilangan bulat</a></li>
<li><a href="../id473416/index.html">Program Konferensi ZeroNights 2019</a></li>
<li><a href="../id473418/index.html">OSCP - Keamanan Ofensif</a></li>
<li><a href="../id473420/index.html">Kami membuka musim pertemuan PHP di Nizhny Novgorod pada 2 November</a></li>
<li><a href="../id473424/index.html">ARM mengumumkan solusi grafis Mali-G57 Valhall dan Mali-D37, neuroprosesor Ethos-N57 dan N37</a></li>
<li><a href="../id473428/index.html">RCS menggantikan SMS. Kemajuan yang ditunggu-tunggu, atau satu langkah maju dua mundur?</a></li>
<li><a href="../id473430/index.html">FAQ tentang pekerjaan asisten pengemudi</a></li>
<li><a href="../id473432/index.html">Tiga laporan Saint TeamLead Conf terbaik</a></li>
<li><a href="../id473434/index.html">Suatu pendekatan sistematis dalam nada pirus ketika naik ke kapal Juni</a></li>
<li><a href="../id473436/index.html">Transformasi Manajemen sebagai kompetensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>