<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜 🧞 🎴 Sidecar用于代码拆分 🔮 🧒🏿 🤱🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="代码拆分。 代码拆分无处不在。 但是，为什么呢？ 只是因为现在有太多的javascript ，并且并非所有的JavaScript都在同一时间使用。 


 JS是一件很沉重的事情。 不适用于您的iPhone Xs或全新的i9笔记本电脑，但适用于数百万（可能是数十亿） 速度较慢的设备所有者。 或者，至...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sidecar用于代码拆分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p> 代码拆分。 代码拆分无处不在。 但是，为什么呢？ 只是因为现在有<strong>太多的javascript</strong> ，并且并非所有<strong>的JavaScript</strong>都在同一时间使用。 </p><br><p>  JS是一件很<em>沉重的</em>事情。 不适用于您的iPhone Xs或全新的i9笔记本电脑，但适用于数百万（可能是数十亿） <em>速度较慢的</em>设备所有者。 或者，至少对于您的手表。 </p><br><p> 所以-JS不好，但是如果我们<strong>禁用它</strong> ，会发生<strong>什么</strong> -问题将消失……对于某些站点，对于基于React的站点，它会“随站点”消失。 但是无论如何-有些站点可以在没有JS的情况下运行...我们应该向他们学习一些东西... </p><a name="habracut"></a><br><h1 id="code-splitting"> 代码拆分 </h1><br><p> 今天，我们有两种方法，可以使它变得更好或不使它变得更糟： </p><br><h2 id="1-write-less-code">  1.写更少的代码 </h2><br><p>那是你最好的事情。 尽管<code>React Hooks</code>可以让您减少一些代码，而<code>Svelte</code>解决方案却可以使您生成的代码<em>比平时</em>少，但这并不是一件容易的事。 </p><br><p> 它不仅与代码有关，而且与<em>功能</em>有关-要使代码“紧凑”，就必须使其“紧凑”。 如果应用程序包做很多事情（并以20种语言提供），则无法保持它很小。 </p><br><p> 有写<em>简短</em>代码的方法，有写相反的实现的方法- <em>血腥的企业</em> 。 而且，您都知道，两者都是合法的。 </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p> 但是主要的问题-代码本身。 一个简单的react应用程序可以轻松绕过“推荐”的250kb。 您可能需要花费一个月的时间对其进行优化，然后将其缩小。  “小型”优化已得到充分证明，并且非常有用-只需获得具有<code>size-limit</code> <code>bundle-analyzer</code>并恢复其形状即可。 <br> 有许多库在为每个字节而战，试图将您限制在自己的范围内<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-preact</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">storeon</a> ，仅举几例。 </p><br><p> 但是我们的应用程序超出了200kb。 接近<strong>100Mb</strong> 。 删除千字节毫无意义。 即使删除兆字节也没有任何意义。 </p><br><blockquote> 片刻之后，将您的应用程序缩小是不可能的。 随着时间的推移，它将变得更大。 </blockquote><br><h2 id="2-ship-less-code">  2.减少代码 </h2><br><p> 或者， <code>code split</code> 。 换句话说- <strong>投降</strong> 。 拿起100mb的捆绑包，然后用它制作20个5mb的捆绑包。 老实说-这是处理应用程序的唯一可能的方法-如果应用程序很大，请从中创建一堆较小的应用程序。 </p><br><p> 但是，您现在应该知道一件事：无论您选择什么选项，它都是实现细节，而我们正在寻找更可靠的东西。 </p><br><h1 id="the-truth-about-code-splitting"> 关于代码拆分的真相 </h1><br><p> 关于代码拆分的真相是，它的本质是<strong>TIME SEPARATION</strong> 。 您不仅在<em>拆分</em>代码，还以一种在单个时间点<strong>使用</strong>尽可能少的方式<em>拆分</em>代码。 </p><br><p> 只是不要立即发布您不需要的代码。 摆脱它。 </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p> 说起来容易，很难做。 我有一些繁重但没有充分拆分的应用程序，其中任何页面的加载量占所有内容的50％。 有时， <code>code splitting</code>会变成<code>code separation</code> ，我的意思是-您可以将代码移到不同的块中，但仍然可以全部使用。  Recal说： <em>“现在就不要发布您不需要的代码”</em> ，-我<em>需要</em> 50％的代码，这才是真正的问题。 </p><br><blockquote> 有时仅在此处添加<code>import</code>是不够的。 直到不是<strong>时间</strong>分隔，而只有<strong>空间</strong>分隔-完全没有关系。 </blockquote><p> 有3种常见的代码拆分方式： </p><br><ol><li> 只是动态<code>import</code> 。 这些天很少使用。 更多有关跟踪<em>状态的</em>问题。 </li><li>  <code>Lazy</code>组件，当您可以推迟渲染和加载React组件时。 这些天，大约90％的“反应代码拆分”。 </li><li>  <em>懒惰</em> <code>Library</code> ，实际上是<code>.1</code> ，但是您将通过React渲染道具获得库代码。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-imported-component</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">loadable-components中实现</a> 。 很有用，但并不广为人知。 </li></ol><br><h2 id="component-level-code-splitting"> 组件级代码拆分 </h2><br><p> 这是最受欢迎的。 作为按路由的代码拆分或按组件的代码拆分。 做到这一点并保持良好的<em>感知结果</em>并非易事。 死于<code>Flash of Loading Content</code> 。 </p><br><p> 好的技术是： </p><br><ul><li> 并行加载<code>js chunk</code>和路由<code>data</code> 。 </li><li> 使用<code>skeleton</code>在页面加载之前显示类似于页面的内容（例如Facebook）。 </li><li>  <code>prefetch</code>块，甚至可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">guess-js</a>进行更好的预测。 </li><li> 使用一些延迟，加载指示符， <code>animations</code>和<code>Suspense</code> （以供将来使用）来缓和过渡。 </li></ul><br><p> 而且，这一切都与<em>感知</em>性能有关。 </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote> 来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://blog.angularindepth.com/">具有Ghost Elements的改进UX的</a>图像 </blockquote><br><h1 id="that-doesnt-sound-good"> 听起来不好 </h1><br><p> 您知道，我可以称自己为代码拆分专家-但是我有自己的失败经历。 </p><br><p> 有时我可能无法减小捆绑包的大小。 有时，只要<code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> ，我就可能无法提高结果的性能<code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *。 这就是所谓的<strong>波涛</strong> 。 </p><br><ul><li> 无需SSR或预渲染。 目前，正确的SSR可以改变游戏规则。 </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p> 上周我遇到了两个失败： </p><br><ul><li> 只要我的图书馆更好，但我却在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个图书馆比较中</a>迷失了，但比另一个图书馆大得多。 我未能执行<strong>“ 1.编写更少的代码”</strong> 。 </li><li> 优化一个由我妻子在React中制作的小型网站。 它使用的是基于路由的组件拆分，但是<code>header</code>和<code>footer</code>保留在主包中，以使过渡更加“可以接受”。 仅几件事，彼此<strong>紧紧耦合</strong>在一起，使捆绑包的一面飙升到320kb（在gzip之前）。 没有什么重要的事情，也没有什么我能真正去除的。  <strong>死亡减少一千</strong> 。 我未能<strong>交付更少的代码</strong> 。 </li></ul><br><blockquote>  React-Dom是20％，core-js是10％，react-router，jsLingui，react-powerplug ...自己代码的20％...我们已经完成了。 </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution"> 解决方案 </h2><br><p> 我已经开始考虑如何解决我的问题，以及为什么<em>常见的解决方案</em>无法在我的用例中正常工作。 </p><br><blockquote> 我做了什么 我列出了所有关键位置，没有这些应用程序将根本无法工作，并试图理解为什么我拥有其余的位置。 </blockquote><p> 这真是一个惊喜。 但是我的问题是在CSS中。 在原始CSS过渡中。 </p><br><p> 这是代码 </p><br><ul><li>  <em>控制</em>变量<code>componentControl</code>最终将设置为<code>DisplayData</code>应该显示的内容。 </li><li> 一旦设置了值<code>DisplayData</code>变为可见，更改<code>className</code> ，从而触发花式过渡。 同时<code>FocusLock</code>激活，使<code>DisplayData</code>成为<strong>模态</strong> 。 <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p> 我想对这一部分进行整体编码，但是由于两个原因，我无法做到这一点： </p><br><ol><li> 一旦需要，信息应该立即可见，没有任何延迟。 业务需求。 </li><li> 信息“ chrome”应该存在之前，才能进行属性句柄转换。 </li></ol><br><p> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSSTransitionGroup</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">recondition</a>可以部分解决此问题。 但是，您知道，固定<em>一个代码再</em>添加<em>另一个代码</em>听起来很奇怪，即使实际上<em>足够了</em> 。 我的意思是添加更多的代码可以帮助删除更多的代码。 但是...但是... </p><br><blockquote> 应该有更好的方法！ </blockquote><p>  TL; DR-这里有两个关键点： </p><br><ul><li>  <code>DisplayData</code>必须被<strong>挂载</strong> ，并且先于DOM存在。 </li><li>  <code>FocusLock</code>也应该事先存在，而不是导致<code>DisplayData</code>重新安装，但是一开始就<strong>不需要动脑筋</strong> 。 </li></ul><br><hr><br><p> 因此，让我们改变思维模式 </p><br><h1 id="batman-and-robin"> 蝙蝠侠和罗宾 </h1><br><p> 假设我们的代码是蝙蝠侠和罗宾。 蝙蝠侠可以应付大多数坏人，但是当他无法应付时，他的搭档罗宾（Robin）便应命了。 </p><br><blockquote> 蝙蝠侠再次参加战斗，罗宾将在稍后到达。 </blockquote><p> 这是蝙蝠侠： </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p> 这是他的搭档罗宾（Robin）:: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p> 蝙蝠侠和罗宾可以<em>组队</em> ，但实际上他们是两个不同的人。 </p><br><p> 并且不要忘记-我们仍在谈论<strong>代码拆分</strong> 。 而且，就代码拆分而言，搭档在哪里？ 罗宾在哪里？ </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote> 放在小车里 罗宾在一辆<strong>杂物车里</strong>等着。 </blockquote><br><h1 id="sidecar"> 边车 </h1><br><ul><li>  <code>Batman</code>是您的客户必须尽快看到的所有视觉材料。 理想的瞬间。 </li><li>  <code>Robin</code>是所有逻辑和花哨的交互式功能，可能在第二秒才可用，但不是一开始就可用。 </li></ul><br><p> 最好将其称为并行分支中存在代码分支的<strong>垂直代码拆分</strong> ，而不是将常见的<strong>将</strong>代码分支<em>剪切</em> <strong>掉的水平代码拆分</strong> 。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">某些地区</a> ，此三重奏被称为<code>replace reducer</code>或其他延迟加载Redux逻辑和副作用的方法。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他一些国家</a> ，这被称为<code>"3 Phased" code splitting</code> 。 </p><br><blockquote> 这只是关注点的另一种分离，仅适用于您可以推迟加载组件的某些部分而不是另一部分的情况。 </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="第三阶段"></p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用React，GraphQL和Relay构建新的facebook.com中的</a>图像，其中<code>importForInteractions</code>或<code>importAfter</code> <strong>是<code>sidecar</code></strong> 。 </blockquote><p> 而且有一个<strong>有趣的</strong>发现-虽然<code>Batman</code>对客户来说更有价值，但只要有客户<em>看到</em>的东西，他就始终处于健康状态……而<code>Robin</code>可能有点<em>超重</em> ，并且需要更多字节生活。 </p><br><p> 结果-蝙蝠侠独自一人​​对客户来说是可以承受的-他以较低的成本提供了更多的价值。 你是我的英雄蝙蝠！ </p><br><h2 id="what-could-be-moved-to-a-sidecar"> 可以移动到边车上的东西： </h2><br><ul><li> 大多数<code>useEffect</code> ， <code>componentDidMount</code>和朋友。 </li><li> 像所有<em>模态</em>效果一样 即<code>focus</code>和<code>scroll</code>锁定。 您可能首先显示模态，然后<strong>才</strong>使模<em>态</em>模<em>态</em> ，即“锁定”客户的注意力。 </li><li> 表格 将所有逻辑和验证移至边车，并阻止表单提交，直到加载该逻辑。 客户可能会开始填写表格，而不知道这只是<code>Batman</code> 。 </li><li> 一些动画。 就我而言，这是一个完整的<code>react-spring</code> 。 </li><li> 一些视觉的东西。 类似于“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义”滚动条</a> ，它可能会在一秒钟后显示精美的滚动条。 </li></ul><br><p> 另外，请不要忘记-卸载到Sidecar的每段代码，也卸载了已删除的代码所使用的core-js poly-和ponyfills之类的东西。 </p><br><p> 代码拆分比今天的应用程序更智能。 我们必须意识到有两种<em>代码</em>可以拆分：1）视觉方面2）交互方面。 稍后可能会出现后者。  <code>Sidecar</code>可以无缝地拆分两个任务，从而使您<em>感觉到所有内容的加载速度都更快</em> 。 而且会的。 </p><br><h2 id="the-oldest-way-to-code-split"> 最早的代码拆分方法 </h2><br><p> 虽然尚不清楚何时以及什么是<code>sidecar</code> ，但我将给出一个简单的解释： </p><br><blockquote>  <code>Sidecar</code>是<strong>您的全部脚本</strong> 。  Sidecar是我们在今天得到的所有前端东西之前进行<em>代码拆分</em>的方式。 </blockquote><p> 我说的是服务器端渲染（ <strong>SSR</strong> ）或只是纯<strong>HTML</strong> ，我们都习惯了昨天。 当包含HTML和逻辑的页面分别存在于可嵌入的外部脚本中（关注点分离）时， <code>Sidecar</code>使事情变得像以前一样容易。 </p><br><p> 我们有HTML，CSS，内联的脚本以及提取到<code>.js</code>文件中的其余脚本。 </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code>是<code>Batman</code> ，而外部脚本是<code>Robin</code> ，并且该网站能够在没有Robin的情况下正常运行，并且说实话，在没有Batman的情况下（他将在双腿断断续续的情况下继续战斗）。 那只是昨天，许多“非现代而酷”的网站今天都一样。 </p><br><hr><br><p> 如果您的应用程序支持SSR，请尝试<strong>禁用js</strong>并使其在没有它的情况下正常工作。 然后，很明显可以将什么移动到边车上。 <br> 如果您的应用程序是仅客户端SPA，请尝试想象一下，如果存在SSR，它将如何工作。 </p><br><blockquote> 例如，用React编写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-theurge.com</a>功能全面， <strong>无需启用任何js</strong> 。 </blockquote><p> 您可能需要将很多事情转移到边车上。 例如： </p><br><ul><li> 评论。 只要可能需要更多的代码（包括WYSIWYG编辑器）（最初不需要），您就可以附带<code>display</code>注释的代码，但不<code>answer</code> 。 最好延迟<em>评论框</em> ，甚至只是将代码隐藏在动画后面，而不是延迟整个页面。 </li><li> 视频播放器。 投放没有“控件”的“视频”。 一秒钟后加载它们，他们的客户可能会尝试与之交互。 </li><li> 图片库，如<code>slick</code> 。  <strong>绘制</strong>它并不是什么大问题，但要赋予动画和管理难度就更大了。 很明显，什么可以转移到边车上。 </li></ul><br><blockquote> 只需考虑对您的应用程序必不可少的内容，而对于应用程序而言则不尽相同... </blockquote><br><h1 id="implementation-details"> 实施细节 </h1><br><h2 id="di-component-code-splitting">  （DI）组件代码拆分 </h2><br><p>  <code>sidecar</code>的最简单形式很容易实现-只需将所有内容移动到子组件，您就可以使用“旧”方式对代码进行拆分。 这几乎是Smart和Dumb组件之间的分离，但是这次Smart并不是在说Dumb一个-恰恰相反。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p> 这也需要将<em>初始化</em>代码移至哑巴代码，但您仍然可以对代码中<em>最重的</em>部分进行代码拆分。 </p><br><blockquote> 您现在可以看到<code>parallel</code>或<code>vertical</code>代码拆分模式吗？ </blockquote><br><h2 id="usesidecar"> 使用Sidecar </h2><br><p> 我已经在这里提到过， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用React，GraphQL和Relay构建New facebook.com</a>的概念是<code>loadAfter</code>或<code>importForInteractivity</code> ，这与sidecar概念非常相似。 </p><br><p> 同时，我不建议您创建诸如<code>useSidecar</code>类的东西，只要您可能有意尝试在其中使用<code>hooks</code> ，但是以这种形式进行代码拆分会破坏<em>钩子规则</em> 。 </p><br><p> 请选择一种更具声明性的组件方式。 而且，您可以在<code>SideCar</code>组件内使用<code>hooks</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching"> 预取 </h2><br><p> 别忘了-您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加载优先级提示</a>来预加载或预取<code>sidecar</code> ，并使它的运输更加透明和不可见。 </p><br><p> 重要事项-预取脚本将通过<strong>网络</strong>加载它，但除非实际需要，否则不执行（并花费CPU）。 </p><br><h2 id="ssr"> 固态继电器 </h2><br><p> 与<em>常规</em>代码拆分不同，SSR不需要采取特殊操作。  <code>Sidecar</code>可能不是SSR流程的一部分，并且在<code>hydration</code>步骤之前不需要。 可以“按设计”将其推迟。 </p><br><p> 因此-可以随时使用<code>React.lazy</code> （理想<strong>情况下没有</strong> <code>Suspense</code> ，这里不需要任何故障回复（加载）指示符）或任何其他库，但如果没有SSR支持，最好在SSR过程中<em>跳过</em> Sidecar块。 </p><br><h1 id="the-bad-parts"> 不良部位 </h1><br><p> 但是这个想法有一些坏处 </p><br><h2 id="batman-is-not-a-production-name"> 蝙蝠侠不是产品名称 </h2><br><p> 虽然<code>Batman</code> / <code>Robin</code> <code>Batman</code> / <code>Robin</code>可能是一个好主意，而<code>maincar</code>本身就是该技术的完美搭配-这款主<code>sidecar</code>并没有“好”的名字。 没有主车这样的东西，显然<code>Batman</code> ， <code>Lonely Wolf</code> ， <code>Solitude</code> ， <code>Driver</code>和<code>Solo</code>不会被用来命名非人车零件。 </p><br><p>  Facebook已经使用了<code>display</code>和<code>interactivity</code> ，这对于我们所有人来说可能是最好的选择。 </p><br><blockquote> 如果您对我有个好名字-请将其保留在评论中 </blockquote><br><h2 id="tree-shaking"> 摇树 </h2><br><p> 从<em>捆绑器的</em>角度来看，更多的是关注点的分离。 假设您有<code>Batman</code>和<code>Robin</code> 。 还有<code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p> 然后，您可以尝试拆分<em>组件</em>代码以实现Sidecar </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p> 简而言之-上面的代码可以工作，但不能做“工作”。 </p><br><ul><li> 如果您仅使用<code>stuff.js</code> <code>batman</code> -摇树只会保留它。 </li><li> 如果您仅使用<code>stuff.js</code> <code>robin</code> -摇树只会保留它。 </li><li>  <strong>但是，</strong>如果您同时使用这两者，即使它们使用的是不同的块-两者都将捆绑在<strong>第一次</strong>出现的<code>stuff.js</code> ，即<strong>主捆绑</strong> 。 </li></ul><br><blockquote> 树摇不是代码拆分友好的。 您必须按文件分开关注点。 </blockquote><br><h2 id="un-import"> 取消导入 </h2><br><p> 每个人都忘记的另一件事是javascript的成本。 在jQuery时代（ <code>jsonp</code>有效载荷时代）非常普遍，它用于加载脚本（带有<code>json</code>有效载荷），获取有效载荷并<strong>删除</strong>脚本。 </p><br><blockquote> 如今，我们都<code>import</code>脚本，即使不再需要它也将永远被导入。 </blockquote><p> 就像我之前说过的-JS太多了，迟早要进行<em>连续导航，</em>您将全部加载。 我们应该找到一种方法，取消导入不再需要的块，清除所有内部缓存并释放内存以使Web更加可靠，并且不使用内存不足异常破坏应用程序。 </p><br><p>  <code>un-import</code>的能力（webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以做到</a> ） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也许</a>是我们坚持使用<em>基于组件的</em> API的原因之一，只要它使我们能够处理<code>unmount</code> 。 </p><br><p> 到目前为止，ESM模块标准与此类内容无关，也与缓存控制无关，也没有与导入操作相反的内容。 </p><br><h2 id="creating-a-sidecar-enabled-library"> 创建支持sidecar的库 </h2><br><p> 到目前为止，只有一种方法可以创建启用了<code>sidecar</code>库： </p><br><ul><li> 将您的组件分成几部分 </li><li> 通过<code>index</code>公开<code>main</code>部分和<code>connected</code>部分（不破坏API） </li><li> 通过单独的入口点暴露<code>sidecar</code> 。 </li><li> 在目标代码中-导入<code>main</code>零件和<code>sidecar</code> -摇树应该切断<code>connected</code>零件。 </li></ul><br><p> 这个时间树摇动应该正常工作，唯一的问题-是如何命名<code>main</code>部分。 </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p> 简而言之，可以通过较小的比较来表示更改 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p> 理论上， <code>dynamic import</code>可以在node_modules内部使用，从而使<em>组装过程</em>更加透明。 </p><br><blockquote> 无论如何-它只不过是<code>children</code> / <code>slot</code>模式，在React中很常见。 </blockquote><br><h1 id="the-future"> 未来 </h1><br><p>  <code>Facebook</code>证明了这个想法是正确的。 如果您还没有看过该视频，请立即进行操作。 我只是从不同角度解释了相同的想法（并在F8会议召开的一周前开始撰写本文）。 </p><br><p> 现在，它需要对您的代码库进行一些代码更改。 它需要更明确地分离关注点才能真正将它们分离，并且让代码不是水平而是垂直拆分，以交付<em>更少的</em>代码以提供<em>更大的</em>用户体验。 </p><br><p> 除了老式SSR之外， <code>Sidecar</code>可能是处理BIG代码库的唯一方法。 当您拥有大量代码时，这是最后机会发布少量代码。 </p><br><blockquote> 它可以使BIG应用程序更小，而SMALL应用程序更小。 </blockquote><p>  10年前，中型网站已在300毫秒内“准备就绪”，并在几毫秒后才<em>真正</em>准备就绪。 今天，秒数甚至超过10秒是常见数字。 真可惜 </p><br><p> 让我们暂停一下，思考-我们如何解决问题，并使UX再次出色... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall"> 总的来说 </h1><br><ul><li> 组件代码拆分是功能最强大的工具，它使您能够<em>完全</em>拆分某些内容，但要付出一定的代价-您可能不会显示任何内容，除非是空白页或一段时间。 那是一个水平的分离。 </li><li> 库代码拆分可能会在组件拆分不起作用时提供帮助。 那是一个水平的分离。 </li><li> 卸载到Sidecar上的代码将使图片更完整，并可以使您提供更好的用户体验。 但也需要一些工程上的努力。 这是垂直分隔。 </li></ul><br><p>  <strong>让我们来讨论一下</strong> 。 </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve"> 别说了 那么您尝试解决的问题呢？ </h2><br><p> 好吧，那只是第一部分。  <strong>我们现在正处于最后阶段</strong> ，写下该提议的第二部分还需要几个星期。 同时...上车！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450942/">https://habr.com/ru/post/zh-CN450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450926/index.html">three.js，nw.js上的3D游戏</a></li>
<li><a href="../zh-CN450928/index.html">数据中心如何节省假期</a></li>
<li><a href="../zh-CN450930/index.html">我们如何开发＃bigdataX5以及大数据需要谁</a></li>
<li><a href="../zh-CN450938/index.html">下诺夫哥罗德Linux Install Fest 05.19 2019年5月18日</a></li>
<li><a href="../zh-CN450940/index.html">Vivaldi 2.5-有吸引力的大宇宙</a></li>
<li><a href="../zh-CN450946/index.html">LPC810上的磁盘手机</a></li>
<li><a href="../zh-CN450948/index.html">MU-MIMO：实现算法之一</a></li>
<li><a href="../zh-CN450950/index.html">Dart Streams基础知识</a></li>
<li><a href="../zh-CN450952/index.html">中等指数和反银行</a></li>
<li><a href="../zh-CN450954/index.html">我们如何学习在Docker中利用Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>