<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎨 ◼️ 🛣️ Beschleunigen von JavaScript mithilfe des Datentyps Set 🔩 🚌 👌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, ist zuversichtlich, dass viele JavaScript-Entwickler hauptsächlich Datentypen w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschleunigen von JavaScript mithilfe des Datentyps Set</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/447578/"> Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, ist zuversichtlich, dass viele JavaScript-Entwickler hauptsächlich Datentypen wie <code>Number</code> , <code>String</code> , <code>Object</code> , <code>Array</code> und <code>Boolean</code> .  In den meisten Fällen ist dies ausreichend.  Wenn Sie den Code jedoch so schnell und skalierbar wie möglich gestalten müssen, ist die Verwendung dieser Datentypen nicht immer gerechtfertigt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/o4/ib/r_/o4ibr_dcy23melkuz-4r3ijjhr0.jpeg"></a> <br><br>  In diesem Artikel werden wir darüber sprechen, wie mithilfe des Datentyps <code>Set</code> , der die Möglichkeit bietet, mit Sammlungen eindeutiger Werte zu arbeiten, Code schneller wird.  Dies gilt insbesondere für den Code von Großprojekten.  Die <code>Array</code> und <code>Set</code> haben viele Gemeinsamkeiten, aber die Verwendung des Datentyps <code>Set</code> kann dem Programmierer solche Funktionen bieten, die sich bei der Ausführung von Programmen deutlich manifestieren, die der <code>Array</code> Typ nicht hat. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist der Unterschied zwischen den Datentypen Array und Set?</font> </h2><br>  Das Hauptmerkmal des <code>Array</code> Datentyps (wir werden Objekte dieses Typs "Arrays" nennen) ist, dass Arrays indizierte Wertesammlungen sind.  Dies bedeutet, dass Daten in Arrays mithilfe von Indizes gespeichert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [A, B, C, D]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr.indexOf(A)); <span class="hljs-comment"><span class="hljs-comment">// : 0 console.log(arr.indexOf(C)); // : 2</span></span></code> </pre> <br>  Im Gegensatz zu Arrays sind Objekte vom Typ <code>Set</code> (wir nennen sie "Sammlungen") Sammlungen, die Daten im Schlüssel- / Wertformat enthalten.  Anstatt Indizes zu verwenden, speichern Sammlungen Elemente mithilfe von Schlüsseln.  In der Sammlung gespeicherte Elemente können in der Reihenfolge sortiert werden, in der sie der Sammlung hinzugefügt wurden, während die Sammlung nicht dieselben Elemente speichern kann.  Mit anderen Worten, alle Elemente der Sammlung müssen eindeutig sein. <br><br><h2>  <font color="#3AC1EF">Was sind die Hauptstärken der Kollektionen?</font> </h2><br>  Wenn Sie Sammlungen und Arrays vergleichen, können Sie einige Vorteile gegenüber Sammlungen gegenüber Arrays feststellen, insbesondere in Situationen, in denen die Programmleistung wichtig ist: <br><br><ul><li>  Nach Artikeln suchen.  Die Array-Methoden <code>indexOf()</code> und <code>indexOf()</code> , mit denen nach Elementen <code>indexOf()</code> und <code>indexOf()</code> wird, ob ein Element ein Element enthält, arbeiten langsam. </li><li>  Elemente entfernen.  Ein Element kann basierend auf seinem Wert in der Sammlung gelöscht werden.  In einem Array besteht das Äquivalent einer solchen Aktion darin, die <code>splice()</code> -Methode zu verwenden, die auf dem Index des Elements basiert.  Wie bei der Elementsuche ist das Entfernen von Elementen mithilfe von Indizes ein langsamer Vorgang. </li><li>  Fügen Sie einen Artikel ein.  Das Hinzufügen eines Elements zur Sammlung ist viel schneller als die Verwendung von Methoden wie <code>push()</code> und <code>unshift()</code> in einem Array. </li><li>  Arbeiten Sie mit dem <code>NaN</code> Wert.  Die <code>indexOf()</code> -Methode kann nicht zum <code>indexOf()</code> des <code>NaN</code> Werts in einem Array verwendet werden. Mit der <code>has()</code> -Sammlungsmethode können Sie feststellen, ob <code>NaN</code> darin enthalten ist. </li><li>  Doppelte Elemente entfernen.  <code>Set</code> Objekte speichern nur eindeutige Werte.  Wenn Sie vermeiden möchten, doppelte Elemente in einer Datenstruktur zu speichern, ist dies ihr wesentlicher Vorteil gegenüber Arrays.  Wenn Sie mit Arrays arbeiten, um doppelte Elemente zu entfernen, müssen Sie zusätzlichen Code schreiben. </li></ul><br>  Eine vollständige Liste der integrierten Methoden für Objekte vom Typ <code>Set</code> finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Zur zeitlichen Komplexität von Algorithmen</font> </h2><br>  Die Methoden, mit denen Arrays nach Elementen suchen, haben eine lineare Zeitkomplexität - O (N).  Mit anderen Worten ist die Elementsuchzeit proportional zur Größe des Arrays. <br><br>  Im Gegensatz zu Arrays weisen die von Sammlungen zum Suchen, Löschen und Hinzufügen von Elementen verwendeten Methoden eine zeitliche Komplexität von O (1) auf.  Dies bedeutet, dass die Größe der Sammlung praktisch keinen Einfluss auf die Arbeitszeit solcher Methoden hat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> können Sie mehr über die zeitliche Komplexität der Algorithmen lesen. <br><br><h2>  <font color="#3AC1EF">Wie viel schneller sind Sammlungen als Arrays?</font> </h2><br>  Obwohl die Leistungsindikatoren von JavaScript-Code stark von einer Vielzahl von Faktoren beeinflusst werden, hängen sie insbesondere vom System ab, auf dem der Code ausgeführt wird, von der verwendeten Codelaufzeit und von der Größe der verarbeiteten Daten. Ich hoffe, dass die Ergebnisse meiner Tests Ihnen die Möglichkeit geben, Arrays und Sammlungen zu vergleichen aus praktischer Sicht und verstehen, wie Sammlungen schneller als Arrays sind.  Nun werden wir drei einfache Tests betrachten und ihre Ergebnisse analysieren. <br><br><h3>  <font color="#3AC1EF">PreparationTestvorbereitung</font> </h3><br>  Bevor Sie Tests durchführen, erstellen wir ein Array mit einer Million Elementen und derselben Sammlung.  Der Einfachheit halber verwenden wir einen Zyklus, dessen erster Zählerwert 0 und dessen letzter - 999999 ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [], set = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(), n = <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { arr.push(i); set.add(i); }</code> </pre> <br><h3>  <font color="#3AC1EF">▍Test Nr. 1: Überprüfen, ob ein Element in einem Array und in einer Sammlung vorhanden ist</font> </h3><br>  Zuerst werden wir prüfen, ob das Element <code>123123</code> im Array und in der Sammlung vorhanden ist, wobei wir im Voraus wissen, dass ein solches Element in diesen Datenstrukturen vorhanden ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); result = arr.indexOf(<span class="hljs-number"><span class="hljs-number">123123</span></span>) !== <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>); result = set.has(<span class="hljs-number"><span class="hljs-number">123123</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>);</code> </pre> <br>  Hier sind die Ergebnisse dieses Tests: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>: <span class="hljs-number"><span class="hljs-number">0.173</span></span>ms <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>: <span class="hljs-number"><span class="hljs-number">0.023</span></span>ms</code> </pre> <br>  Die Sammlung ist 7,54-mal schneller als das Array. <br><br><h3>  <font color="#3AC1EF">▍Test Nr. 2: Einfügen eines Elements</font> </h3><br>  Versuchen wir nun, Arrays und Sammlungen Elemente hinzuzufügen. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); arr.push(n); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>); set.add(n); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>);</code> </pre> <br>  Folgendes ist passiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>: <span class="hljs-number"><span class="hljs-number">0.018</span></span>ms <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>: <span class="hljs-number"><span class="hljs-number">0.003</span></span>ms</code> </pre> <br>  Die Sammlung ist 6,73-mal schneller als das Array. <br><br><h3>  <font color="#3AC1EF">▍Test 3: Löschen Sie ein Element</font> </h3><br>  Entfernen wir nun das Element aus jeder Datenstruktur (z. B. das im vorherigen Test hinzugefügte).  Arrays verfügen nicht über eine integrierte Methode zum Löschen von Elementen. Daher erstellen wir eine Hilfsfunktion, um unseren Code in gutem Zustand zu halten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> deleteFromArr = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = arr.indexOf(item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index !== <span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; arr.splice(index, <span class="hljs-number"><span class="hljs-number">1</span></span>); };</code> </pre> <br>  Und hier ist der Testcode: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); deleteFromArr(arr, n); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Array'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>); set.delete(n); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'Set'</span></span>);</code> </pre> <br>  Das Ergebnis ist folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>: <span class="hljs-number"><span class="hljs-number">1.122</span></span>ms <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>: <span class="hljs-number"><span class="hljs-number">0.015</span></span>ms</code> </pre> <br>  In diesem Fall war die Sammlung 74,13-mal schneller als das Array! <br><br>  Im Allgemeinen kann festgestellt werden, dass die Codeleistung durch die Verwendung von Sammlungen anstelle von Arrays erheblich gesteigert werden kann.  Betrachten Sie einige praktische Beispiele. <br><br><h2>  <font color="#3AC1EF">Beispiel 1: Entfernen doppelter Werte aus einem Array</font> </h2><br>  Wenn Sie doppelte Werte schnell aus einem Array entfernen müssen, können Sie sie in eine Sammlung konvertieren.  Dies ist vielleicht der einfachste Weg, um doppelte Werte loszuwerden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duplicateCollection = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//       let uniqueCollection = new Set(duplicateCollection); console.log(uniqueCollection) // : Set(4) {"A", "B", "C", "D"} //        let uniqueCollection = [...new Set(duplicateCollection)]; console.log(uniqueCollection) // : ["A", "B", "C", "D"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Beispiel 2: Interviewaufgabe bei Google</font> </h2><br>  In einem meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Materialien habe</a> ich vier Möglichkeiten zur Beantwortung der von einem Interviewer von Google gestellten Frage untersucht.  Das Interview wurde mit C ++ geführt, aber wenn JavaScript anstelle dieser Sprache verwendet würde, würde die <code>Set</code> Datenstruktur notwendigerweise zur Lösung des Problems verwendet. <br><br>  Wenn Sie die Antwort auf diese Frage besser verstehen möchten, lesen Sie den obigen Artikel.  Hier zeige ich nur eine fertige Lösung. <br><br><h3>  <font color="#3AC1EF">▍ Aufgabe</font> </h3><br>  Gegeben ein unsortiertes Array von ganzen Zahlen und einen <code>sum</code> .  Schreiben Sie eine Funktion, die <code>true</code> zurückgibt <code>true</code> wenn wir durch Hinzufügen von zwei Elementen dieses Arrays den <code>sum</code> .  Wenn das Array keine solchen Elemente enthält, sollte die Funktion <code>false</code> . <br><br>  Es stellt sich zum Beispiel heraus, dass die Funktion <code>true</code> sollte, wenn wir ein Array <code>[3, 5, 1, 4]</code> und der <code>sum</code> <code>9</code> ist, da <code>4+5=9</code> . <br><br><h3>  <font color="#3AC1EF">▍Lösung</font> </h3><br>  Sie können dieses Problem mit der folgenden Idee lösen: Sie müssen das Array durchlaufen und die sortierte <code>Set</code> Datenstruktur erstellen, in die Werte hinzugefügt werden, die die gefundenen Werte zum <code>sum</code> ergänzen. <br><br>  Lassen Sie uns diese Idee am Beispiel des obigen Arrays analysieren.  Wenn wir <code>3</code> treffen, können wir die Nummer <code>6</code> zur Sammlung hinzufügen, da wir wissen, dass wir zwei Zahlen finden müssen, die insgesamt <code>9</code> .  Jedes Mal, wenn wir auf einen neuen Wert aus dem Array stoßen, können wir die Sammlung überprüfen und feststellen, ob sie vorhanden ist.  Wenn wir die Nummer <code>5</code> treffen, werden wir der Sammlung <code>4</code> hinzufügen.  Und wenn wir endlich die Nummer <code>4</code> , finden wir sie in der Sammlung und können <code>true</code> . <br><br>  So könnte eine Lösung für dieses Problem aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchValues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); searchValues.add(val - arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, length = arr.length; i &lt; length; i++) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchVal = val - arr[i];   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchValues.has(arr[i])) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     searchValues.add(searchVal);   } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Und hier ist eine präzisere Lösung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, sum</span></span></span><span class="hljs-function">) =&gt;</span></span> arr.some((<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function"> =&gt;</span></span> n =&gt; set.has(n) || !set.add(sum - n))(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>));</code> </pre> <br>  Da die zeitliche Komplexität der <code>Set.prototype.has()</code> -Methode O (1) ist, können Sie mithilfe der <code>Set</code> Datenstruktur zum Speichern von Zahlen, die die im Array gefundenen Zahlen zu einem bestimmten Wert ergänzen, eine Lösung in linearer Zeit (O (N)) finden. <br><br>  Wenn die Lösung von der Methode <code>Array.prototype.indexOf()</code> oder von der Methode <code>Array.prototype.includes()</code> , deren zeitliche Komplexität jeweils O (N) beträgt, wäre die Gesamtzeitkomplexität des Algorithmus O (N <sup>2</sup> ).  Infolgedessen würde er viel langsamer werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wenn Sie den Datentyp <code>Set</code> noch nicht in JavaScript gefunden haben, hoffen wir, dass Sie ihn jetzt, wenn Sie eine Vorstellung davon haben, in Ihren Projekten mit Nutzen verwenden können. <br><br>  <b>Liebe Leser!</b>  Wie würden Sie die <code>Set</code> Datenstruktur in Ihrem Code anwenden? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/b4/fn/f5/b4fnf52x9i3mn80tttdafqtvkfe.jpeg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447578/">https://habr.com/ru/post/de447578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447568/index.html">Interview mit dem Astronauten Alexander Laveikin über Weltraumkino, Überladungen von 20 Einheiten und sanfte Landung</a></li>
<li><a href="../de447570/index.html">GoLand 2019.1: Codeleistungsanalyse, Smart Step Into, Refactoring der Extraktschnittstelle, Nilness Analyzer und mehr</a></li>
<li><a href="../de447572/index.html">Energie, Wärme und Wasser: Teil zwei</a></li>
<li><a href="../de447574/index.html">Hinweise für Freiberufler: Entwicklung der First React Native-Anwendung</a></li>
<li><a href="../de447576/index.html">Verantwortliche JavaScript-Entwicklung Teil 1</a></li>
<li><a href="../de447580/index.html">Bedrohungsjagd oder wie man sich gegen 5% Bedrohungen verteidigt</a></li>
<li><a href="../de447582/index.html">Rusatom: 3D-Metalldruck in Russland</a></li>
<li><a href="../de447584/index.html">Anatomie des "Space Data Center". Himmelhoher Server: Schauen Sie unter die Haube</a></li>
<li><a href="../de447586/index.html">Erweiterte String-Interpolation in Swift 5.0</a></li>
<li><a href="../de447588/index.html">So stabilisieren Sie die Anwendung mit zwei Arten von Komponententests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>