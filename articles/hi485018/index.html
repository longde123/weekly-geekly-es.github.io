<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ЁЯУ╡ ЁЯОУ ЁЯжА рдпреВрдирд┐рдЯреА LWRP рдореЗрдВ рдХреЛрдб рдХреЗ рд╕рд╛рде рд╢реЗрдбрд░реНрд╕ рд▓рд┐рдЦрдирд╛ тЫ╣я╕П ЁЯеХ ЁЯПШя╕П</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="рдкрд░рд┐рдЪрдп 
 рд╣реЗрд▓реЛ, рд╣реИрдмрд░ред рдЖрдЬ рдореИрдВ рдереЛрдбрд╝реА рдмрд╛рдд рдХрд░рдирд╛ рдЪрд╛рд╣рддрд╛ рд╣реВрдВ рдХрд┐ рдЖрдк рдХреИрд╕реЗ рдЬрд▓реНрджреА рдФрд░ рджрд░реНрдж рд░рд╣рд┐рдд (рд▓рдЧрднрдЧ) рд▓рд╛рдЗрдЯрд╡реЗрдЯ рд░реЗрдВрдбрд░рд┐рдВрдЧ рдкрд╛рдЗрдкрд▓рд╛рдЗрди (LWRP) рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ рдПрдХрддрд╛ рдореЗрдВ рдХреНрд▓рд╛рд╕...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>рдпреВрдирд┐рдЯреА LWRP рдореЗрдВ рдХреЛрдб рдХреЗ рд╕рд╛рде рд╢реЗрдбрд░реНрд╕ рд▓рд┐рдЦрдирд╛</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485018/"><h2>  рдкрд░рд┐рдЪрдп </h2><br>  рд╣реЗрд▓реЛ, рд╣реИрдмрд░ред  рдЖрдЬ рдореИрдВ рдереЛрдбрд╝реА рдмрд╛рдд рдХрд░рдирд╛ рдЪрд╛рд╣рддрд╛ рд╣реВрдВ рдХрд┐ рдЖрдк рдХреИрд╕реЗ рдЬрд▓реНрджреА рдФрд░ рджрд░реНрдж рд░рд╣рд┐рдд (рд▓рдЧрднрдЧ) <b>рд▓рд╛рдЗрдЯрд╡реЗрдЯ рд░реЗрдВрдбрд░рд┐рдВрдЧ рдкрд╛рдЗрдкрд▓рд╛рдЗрди (LWRP)</b> рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ рдПрдХрддрд╛ рдореЗрдВ рдХреНрд▓рд╛рд╕рд┐рдХ <b>рдЯреЗрдХреНрд╕реНрдЯ</b> <b>рд╢реЗрдбреНрд╕</b> рд▓рд┐рдЦрдирд╛ рд╢реБрд░реВ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ - <b>рд╕реНрдХреНрд░рд┐рдкреНрдЯрд┐рдВрдЧ рд░реЗрдВрдбрд░рд┐рдВрдЧ рдкрд╛рдЗрдкрд▓рд╛рдЗрди (SRP)</b> рдкрд╛рдЗрдкрд▓рд╛рдЗрди рдХреЗ рдЙрджрд╛рд╣рд░рдгреЛрдВ рдореЗрдВ рд╕реЗ рдПрдХред <br><br><h4>  рд▓реЗрдХрд┐рди Shader рдЧреНрд░рд╛рдл рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдХреНрдпрд╛? </h4><br>  <b>Shader Graph</b> рдкреНрд░реЛрдЯреЛрдЯрд╛рдЗрдк рдпрд╛ рд╕рд░рд▓ рдкреНрд░рднрд╛рд╡ рд▓рд┐рдЦрдиреЗ рдХреЗ рд▓рд┐рдП рдПрдХ рд╕реБрд╡рд┐рдзрд╛рдЬрдирдХ рдФрд░ рддреНрд╡рд░рд┐рдд рдЙрдкрдХрд░рдг рд╣реИред  рд╣рд╛рд▓рд╛рдВрдХрд┐, рдХрднреА-рдХрднреА, рдХреБрдЫ рдЬрдЯрд┐рд▓ рдФрд░ рдЬрдЯрд┐рд▓ рд▓рд┐рдЦрдирд╛ рдЖрд╡рд╢реНрдпрдХ рд╣реИ, рдФрд░ рдлрд┐рд░ - рдиреЛрдбреНрд╕, рдХрд╕реНрдЯрдо рдлрд╝рдВрдХреНрд╢рди, рдЙрдк-рдЧреНрд░рд╛рдлрд╝ рдХреА рд╕рдВрдЦреНрдпрд╛ рдЕрд╡рд┐рд╢реНрд╡рд╕рдиреАрдп рд░реВрдк рд╕реЗ рдмрдврд╝ рд░рд╣реА рд╣реИ, рдпрд╣реА рд╡рдЬрд╣ рд╣реИ рдХрд┐ рдпрд╣рд╛рдВ рддрдХ тАЛтАЛрдХрд┐ рд╕рдмрд╕реЗ рдЕрдиреБрднрд╡реА рдЧреНрд░рд╛рдлрд┐рдХреНрд╕ рдкреНрд░реЛрдЧреНрд░рд╛рдорд░ рднреА рдЗрд╕ рдкреВрд░реЗ рдЧрдбрд╝рдмрдбрд╝ рдореЗрдВ рднреНрд░рдорд┐рдд рд╣реЛрдиреЗ рд▓рдЧрддреЗ рд╣реИрдВред  рд╣рдо рд╕рднреА рд╕рдордЭрддреЗ рд╣реИрдВ рдХрд┐ рд╕реНрд╡рдЪрд╛рд▓рд┐рдд рд░реВрдк рд╕реЗ рдЙрддреНрдкрдиреНрди рдХреЛрдб рдПрдХ рдкреНрд░рд╛рдердорд┐рдХрддрд╛ рдореИрдиреНрдпреБрдЕрд▓ рд░реВрдк рд╕реЗ рд▓рд┐рдЦреЗ рдЬрд╛рдиреЗ рд╕реЗ рдмреЗрд╣рддрд░ рдирд╣реАрдВ рд╣реЛ рд╕рдХрддреА рд╣реИ - рдЖрдкрдХреЛ рдЙрджрд╛рд╣рд░рдгреЛрдВ рдХреЗ рд▓рд┐рдП рдмрд╣реБрдд рджреВрд░ рдЬрд╛рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдирд╣реАрдВ рд╣реИ, рдХреНрдпреЛрдВрдХрд┐ рдиреЛрдбреНрд╕ рдХреЗ рд▓реЗрдЖрдЙрдЯ рдореЗрдВ рдХреЛрдИ рднреА рддреНрд░реБрдЯрд┐ рдЗрд╕ рддрдереНрдп рдХреЛ рдЬрдиреНрдо рджреЗ рд╕рдХрддреА рд╣реИ рдХрд┐ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдЬреНрдЮрд╛рдд рд╢реАрд░реНрд╖ рдкрд░рд┐рдгрд╛рдо рд╢рд╛рд░реНрдЯреЗрдХреНрдЯрд░ рдореЗрдВ рдмрд╛рд░-рдмрд╛рд░ рдЦрдВрдб рдореЗрдВ рдЧрд┐рдирд╛ рдЬрд╛рдПрдЧрд╛ред  рдРрд╕реЗ рд▓реЛрдЧ рд╣реИрдВ рдЬреЛ рдиреЛрдбреНрд╕ рдХреЗ рдмрдЬрд╛рдп <b>рдХреЛрдб рдХреЗ</b> рд╕рд╛рде рдХрд╛рдо рдХрд░рдиреЗ рдореЗрдВ рдЕрдзрд┐рдХ рд╕рд╣рдЬ рд╣реИрдВред  рдХрд╛рд░рдг рдЕрд▓рдЧ рд╣реЛ рд╕рдХрддреЗ рд╣реИрдВ, рд▓реЗрдХрд┐рди рд╕рд╛рд░ рдПрдХ рд╣реА рд╣реИ - рдиреЛрдбреНрд╕ рдХреЗ рд╕рд╛рде рдиреАрдЪреЗ, рд▓рдВрдмреЗ рд╕рдордп рддрдХ рдХреЛрдб рд░рд╣рддреЗ рд╣реИрдВ! <br><br> <a href="https://ibb.co/yBwCvZz" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/b24/96d/bc6/b2496dbc64e311b3f6e51a4edfc87078.png" alt="2020-01-19-17-07-35"></a> <br><a name="habracut"></a><br><h4>  рд╕рдорд╕реНрдпрд╛рдУрдВ </h4><br>  рддреЛ, LWRP рдХреЗ рддрд╣рдд рдПрдХ рдирд┐рдпрдорд┐рдд рдкрд╛рда shader рд▓рд┐рдЦрдиреЗ рдФрд░ рдмреИрдардиреЗ рдореЗрдВ рдХреНрдпрд╛ рд╕рдорд╕реНрдпрд╛ рд╣реИ?  рдФрд░ рд╕рдорд╕реНрдпрд╛ рдпрд╣ рд╣реИ рдХрд┐ LWRP рдореЗрдВ рд╕рднреА рдХреЗ рдкрд╕рдВрджреАрджрд╛ <b>рд╕реНрдЯреИрдВрдбрд░реНрдб рд╕рд░рдлреЗрд╕</b> рд╢реЗрдбреНрд╕ рд╕рдорд░реНрдерд┐рдд рдирд╣реАрдВ рд╣реИрдВред <br>  рдЗрд╕рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рдХреА рдХреЛрд╢рд┐рд╢ рдХрд░рддреЗ рд╕рдордп, рд╣рдореЗрдВ рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдорд┐рд▓рддреЗ рд╣реИрдВ: <br><br> <a href="https://ibb.co/M8g31xz" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/f7a/a25/c7df7aa255f2fa81a2a95ef88ef249e2.png" alt="2020-01-19-17-16-16"></a> <br><br><div class="spoiler">  <b class="spoiler_title">рд╢реЗрдбрд░ рдХреЛрдб</b> <div class="spoiler_text"><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Custom/NewSurfaceShader"</span></span> { Properties { _Color (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Glossiness (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">// Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D _MainTex; struct Input { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing_options assumeuniformscaling UNITY_INSTANCING_BUFFER_START(Props) // put more per-instance properties here UNITY_INSTANCING_BUFFER_END(Props) void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</span></span></code> </pre> <br></div></div><br>  рдлрд┐рд░ рджрд┐рдорд╛рдЧ рдореЗрдВ рдпрд╣ рдЖрддрд╛ рд╣реИ рдХрд┐ рдирд┐рдпрдорд┐рдд рдРрд▓рд┐рдЯ рд╢реЗрдбрд░ рдХреЛ рд╡рд░реНрдЯреЗрдХреНрд╕ рдФрд░ рдлреНрд░реЗрдЧреНрдореЗрдВрдЯ рдкрд╛рд░реНрдЯ рдХреЗ рд╕рд╛рде рд▓рд┐рдЦрдиреЗ рдХреА рдХреЛрд╢рд┐рд╢ рдХрд░реЗрдВред  рдФрд░ рд╕реМрднрд╛рдЧреНрдп рд╕реЗ, рд╕рдм рдХреБрдЫ рдХрд╛рдо рдХрд░рддрд╛ рд╣реИ: <br><br> <a href="https://ibb.co/28bLgkd" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/8bf/559/bd1/8bf559bd19494ef9fd18364c2983b494.png" alt="2020-01-19-17-22-46"></a> <br><br><div class="spoiler">  <b class="spoiler_title">рд╢реЗрдбрд░ рдХреЛрдб</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Unlit/NewUnlitShader"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag <span class="hljs-comment"><span class="hljs-comment">// make fog work #pragma multi_compile_fog #include "UnityCG.cginc" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) float4 vertex : SV_POSITION; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); // apply fog UNITY_APPLY_FOG(i.fogCoord, col); return col; } ENDCG } } }</span></span></code> </pre> <br></div></div><br>  рд╣рд╛рд▓рд╛рдВрдХрд┐, рдЖрдк рдХреИрд╕реЗ рджреБрдЦреА рдирд╣реАрдВ рд╣реЛ рд╕рдХрддреЗ рд╣реИрдВ - рд╣рдо рдмрд┐рдирд╛ рд░реЛрд╢рдиреА, рдЫрд╛рдпрд╛, рд▓рд╛рдЗрдЯрдореИрдк рдФрд░ рдкреНрдпрд╛рд░реЗ <b>рдкреАрдмреАрдЖрд░ рдХреЗ</b> рдмрд┐рдирд╛ рдХрд┐рдирд╛рд░реЗ рдкрд░ рдирдЧреНрди рд░рд╣рдиреЗ рдХреЗ рд▓рд┐рдП рд▓рдЧ рд░рд╣реЗ рдереЗ, рдЬрд┐рд╕рдХреЗ рдмрд┐рдирд╛ рдЬреАрд╡рди рдореАрдард╛ рдирд╣реАрдВ рдерд╛ред <br>  рдмреЗрд╢рдХ, рдЖрдк рд╣рд╛рде рд╕реЗ рд╕рдм рдХреБрдЫ рд▓рд┐рдЦ рд╕рдХрддреЗ рд╣реИрдВ: <br>  <i>рд╡рд╣рд╛рдБ рдкреНрд░рдХрд╛рд╢ рд╣реЛ!</i> <br><br> <a href="https://ibb.co/b7xn2DT" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/46f/3b4/dc7/46f3b4dc795e2ad51508942405c3854f.png" alt="2020-01-19-17-55-56"></a> <br><br><div class="spoiler">  <b class="spoiler_title">рд╢реЗрдбрд░ рдХреЛрдб</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/Simple Lit"</span></span> { Properties { _MainTex(<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span> = <span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag <span class="hljs-comment"><span class="hljs-comment">// make fog work #pragma multi_compile_fog #include "UnityCG.cginc" #include "UnityLightingCommon.cginc" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal : NORMAL; }; struct v2f { float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) float4 vertex : SV_POSITION; fixed4 diffuse : COLOR0; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert(appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); half3 worldNormal = UnityObjectToWorldNormal(v.normal); half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz)); o.diffuse = nl * _LightColor0; return o; } fixed4 frag(v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); // apply fog UNITY_APPLY_FOG(i.fogCoord, col); col *= i.diffuse; return col; } ENDCG } } }</span></span></code> </pre> <br></div></div><br>  рдХрд╛рдо рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рд╕рдм рдХреБрдЫ рд▓рдЧрддрд╛ рд╣реИ, рд▓реЗрдХрд┐рди рдпрд╣ рд╕рд┐рд░реНрдл рдкреНрд░рдХрд╛рд╢ рдлреИрд▓рд╛рдирд╛ рд╣реИред  рдЖрдЧреЗ рдХреНрдпрд╛ рдХрд░рдирд╛ рд╣реИ?  рдЖрдк рд╣рд╛рде рд╕реЗ рд╕рдм рдХреБрдЫ рд╡рд╛рдкрд╕ рдХрд░рдирд╛ рдЬрд╛рд░реА рд░рдЦ рд╕рдХрддреЗ рд╣реИрдВ, рд▓реЗрдХрд┐рди рдпрд╣ рд▓рдВрдмрд╛ рдФрд░ рдиреАрд░рд╕ рд╣реИ, рдФрд░ рдкреАрдмреАрдЖрд░ рдХреЛ рдХрд┐рд╕реА рднреА рддрд░рд╣ рд╕реЗ рд╡рд╛рдкрд╕ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИ, рдФрд░ рд╣рдо рд╕рднреА рдПрд▓рдбрдмреНрд▓реНрдпреВрдЖрд░рдкреА рдЪрд┐рдкреНрд╕ рдЦреЛ рджреЗрддреЗ рд╣реИрдВред  рдЗрд╕рд▓рд┐рдП, рд╣рдорд╛рд░реЗ рдкрд╛рд╕ рдПрдХ рдЬрд╛рджреВ рдХреЗ рд╕реНрдЯреНрд░реЛрдХ рдХреЗ рд╕рд╛рде рд╕рдм рдХреБрдЫ рд╡рд╛рдкрд╕ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдПрд▓рдбрдмреНрд▓реНрдпреВрдЖрд░рдкреА рдХреЛ рдЪреБрдирдиреЗ рдХреЗ рдЕрд▓рд╛рд╡рд╛ рдХреЛрдИ рд╡рд┐рдХрд▓реНрдк рдирд╣реАрдВ рд╣реИред <br><br><h4>  рдирд┐рд░реНрдгрдп </h4><br>  рддреЛ, рдЬреИрд╕рд╛ рдХрд┐ рдЖрдк рдЬрд╛рдирддреЗ рд╣реИрдВ, LWRP <i>рдлреЙрд░рд╡рд░реНрдб-рд░реЗрдВрдбрд░рд░</i> рдХреЗ рдЖрдзрд╛рд░ рдкрд░ рдмрдирд╛рдпрд╛ рдЧрдпрд╛ рд╣реИ, рдЬрд┐рд╕рдХрд╛ рдЕрд░реНрде рд╣реИ рдХрд┐ рдЗрд╕рдХрд╛ рдЕрдкрдирд╛ LitForwardPass рд╣реИ, рдЬрд┐рд╕реЗ рдХрд╣реАрдВ рди рдХрд╣реАрдВ рд╡рд░реНрдгрд┐рдд рдХрд┐рдпрд╛ рдЬрд╛рдирд╛ рдЪрд╛рд╣рд┐рдПред  рдЬрд╛рд╣рд┐рд░ рд╣реИ, рдХрд╣реАрдВ рди рдХрд╣реАрдВ рдПрдХ CGInclude рд╣реИ рдЬрд┐рд╕рдореЗрдВ рдпрд╣ рд╕рдм рд╡рд░реНрдгрд┐рдд рд╣реИред  рдпрд╣ рд╡рд╣ рдЬрдЧрд╣ рд╣реИ рдЬрд╣рд╛рдВ рд╣рдо рдПрдХ рдордЬреЗрджрд╛рд░ рд╕рд╛рд╣рд╕рд┐рдХ рдкрд░ рд╕реЗрдЯ рдХрд░рддреЗ рд╣реИрдВ: <br><blockquote>  <i>% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render- рдкрд╛рдЗрдкрд▓рд╛рдЗрди-рд▓рд╛рдЗрдЯрд╡реЗрдЯ @ (LWRP рд╕рдВрд╕реНрдХрд░рдг) \</i> </blockquote><br>  рдЕрд╕рд▓ рдореЗрдВ, рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдкрддреЗ рдкрд░ рдЖрдиреЗ рдФрд░ <i>рд╢реЗрдбрд░реНрд╕</i> рдлрд╝реЛрд▓реНрдбрд░ рдореЗрдВ рдЬрд╛рдиреЗ рд╕реЗ, рд╣рдо рдПрдХ рджрд┐рд▓рдЪрд╕реНрдк shader рдкрд╛ рд╕рдХрддреЗ рд╣реИрдВ, рдЬрд┐рд╕реЗ <b>Lit.shader</b> рдХрд╣рд╛ рдЬрд╛рддрд╛ рд╣реИред  рд╡рд╛рд╕реНрддрд╡ рдореЗрдВ, рд╣рдо рдХрд╣ рд╕рдХрддреЗ рд╣реИрдВ рдХрд┐ рд╣рдорд╛рд░реА рдЦреЛрдЬ рдЦрддреНрдо рд╣реЛ рдЧрдИ рд╣реИ, рдпрд╣рд╛рдВ рдпрд╣ рд╣реИ - рдкреНрд░рддрд┐рд╖реНрдард┐рдд рдЫрд╛рдпрд╛рджрд╛рд░ред  рдЕрдВрджрд░ рдЬрд╛ рд░рд╣реЗ рд╣реИрдВ - рд╣рдо рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рд╕рд╛рдордЧреНрд░реА рдкрд╛рддреЗ рд╣реИрдВ: <br><br><div class="spoiler">  <b class="spoiler_title">Lit.shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Lightweight Render Pipeline/Lit"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture] _BaseMap("Albedo", 2D) = "white" {} _Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 _Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 _GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 _SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 _MetallicGlossMap("Metallic", 2D) = "white" {} _SpecColor("Specular", Color) = (0.2, 0.2, 0.2) _SpecGlossMap("Specular", 2D) = "white" {} [ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 _BumpScale("Scale", Float) = 1.0 _BumpMap("Normal Map", 2D) = "bump" {} _OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 _OcclusionMap("Occlusion", 2D) = "white" {} _EmissionColor("Color", Color) = (0,0,0) _EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 _ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "LitInput.hlsl" #include "LitForwardPass.hlsl" ENDHLSL } Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/ShadowCasterPass.hlsl" ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/DepthOnlyPass.hlsl" ENDHLSL } // This pass it not used during regular rendering, only for lightmap baking. Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitMetaPass.hlsl" ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShader" }</span></span></code> </pre><br></div></div><br><br>  рдпрд╣ рдХреЗрд╡рд▓ рд╕рдВрдкрд╛рджрди рдореЗрдВ рдЖрд╕рд╛рдиреА рдХреЗ рд▓рд┐рдП рдЗрд╕рдХрд╛ рд╡рд┐рд╕реНрддрд╛рд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдмрдиреА рд╣реБрдИ рд╣реИ, рдЬрд┐рд╕рдореЗрдВ рд╢рд╛рдорд┐рд▓-рдПрд╕ рд╕реЗ рдЫреБрдЯрдХрд╛рд░рд╛ рдорд┐рд▓ рд░рд╣рд╛ рд╣реИред  рдареАрдХ рд╣реИ, рдЕрдкрдиреЗ рддрд░реАрдХреЗ рд╕реЗ рдереЛрдбрд╝рд╛ рд╕рдВрд╢реЛрдзрд┐рдд рдХрд░реЗрдВред <br><br>  рд╣рдореЗрдВ рдРрд╕рд╛ рдХреБрдЫ рдорд┐рд▓рддрд╛ рд╣реИ: <br><br> <a href="https://ibb.co/LpxG3cD" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/f1f/add/a94/f1fadda94d14fcd9cd518f99c7489ce8.png" alt="2020-01-19-18-28-13"></a> <br><br><div class="spoiler">  <b class="spoiler_title">рдЕрдВрддрд┐рдо uber shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/LWRP/Dissolve + Vertex Offset"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor][HideInInspector] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture][HideInInspector] _BaseMap("Albedo", 2D) = "white" {} [HideInInspector]_Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 [HideInInspector]_Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 [HideInInspector]_GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 [HideInInspector]_SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma][HideInInspector] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 [HideInInspector]_MetallicGlossMap("Metallic", 2D) = "white" {} [HideInInspector]_SpecColor("Specular", Color) = (0.2, 0.2, 0.2) [HideInInspector]_SpecGlossMap("Specular", 2D) = "white" {} [HideInInspector][ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [HideInInspector][ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 [HideInInspector]_BumpScale("Scale", Float) = 1.0 [HideInInspector]_BumpMap("Normal Map", 2D) = "bump" {} [HideInInspector]_OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 [HideInInspector]_OcclusionMap("Occlusion", 2D) = "white" {} [HDR][HideInInspector]_EmissionColor("Color", Color) = (0,0,0) [HideInInspector]_EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 [HideInInspector]_ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 //    _DissolveMap("Dissolve Map", 2D) = "white" {} _DissolveFactor("Dissolve Factor", Range(0, 1)) = 0.0 _DissolveWidth("Dissolve Width", Range(0, 1)) = 0.0 [HDR]_DissolveColor("Color", Color) = (1,1,0) } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/SurfaceInput.hlsl" #ifdef _SPECULAR_SETUP #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_SpecGlossMap, sampler_SpecGlossMap, uv) #else #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, uv) #endif struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; float2 lightmapUV : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 1); #ifdef _ADDITIONAL_LIGHTS float3 positionWS : TEXCOORD2; #endif #ifdef _NORMALMAP half4 normalWS : TEXCOORD3; // xyz: normal, w: viewDir.x half4 tangentWS : TEXCOORD4; // xyz: tangent, w: viewDir.y half4 bitangentWS : TEXCOORD5; // xyz: bitangent, w: viewDir.z #else half3 normalWS : TEXCOORD3; half3 viewDirWS : TEXCOORD4; #endif half4 fogFactorAndVertexLight : TEXCOORD6; // x: fogFactor, yzw: vertex light #ifdef _MAIN_LIGHT_SHADOWS float4 shadowCoord : TEXCOORD7; #endif float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO float3 uvDissolve : TEXCOORD8; }; CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor; CBUFFER_END TEXTURE2D(_OcclusionMap); SAMPLER(sampler_OcclusionMap); TEXTURE2D(_MetallicGlossMap); SAMPLER(sampler_MetallicGlossMap); TEXTURE2D(_SpecGlossMap); SAMPLER(sampler_SpecGlossMap); TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); half4 SampleMetallicSpecGloss(float2 uv, half albedoAlpha) { half4 specGloss; #ifdef _METALLICSPECGLOSSMAP specGloss = SAMPLE_METALLICSPECULAR(uv); #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a *= _Smoothness; #endif #else // _METALLICSPECGLOSSMAP #if _SPECULAR_SETUP specGloss.rgb = _SpecColor.rgb; #else specGloss.rgb = _Metallic.rrr; #endif #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a = _Smoothness; #endif #endif return specGloss; } half SampleOcclusion(float2 uv) { #ifdef _OCCLUSIONMAP // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Controls things like these by exposing SHADER_QUALITY levels (low, medium, high) #if defined(SHADER_API_GLES) return SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; #else half occ = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; return LerpWhiteTo(occ, _OcclusionStrength); #endif #else return 1.0; #endif } inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData) { half4 albedoAlpha = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); // half4 albedoAlpha = SampleAlbedoAlpha(uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)); outSurfaceData.alpha = Alpha(albedoAlpha.a, _BaseColor, _Cutoff); half4 specGloss = SampleMetallicSpecGloss(uv, albedoAlpha.a); outSurfaceData.albedo = albedoAlpha.rgb * _BaseColor.rgb; #if _SPECULAR_SETUP outSurfaceData.metallic = 1.0h; outSurfaceData.specular = specGloss.rgb; #else outSurfaceData.metallic = specGloss.r; outSurfaceData.specular = half3(0.0h, 0.0h, 0.0h); #endif outSurfaceData.smoothness = specGloss.a; outSurfaceData.normalTS = SampleNormal(uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap), _BumpScale); outSurfaceData.occlusion = SampleOcclusion(uv); outSurfaceData.emission = SampleEmission(uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap)); // outSurfaceData.emission = _EmissionColor.rgb * SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, uv); } void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData) { inputData = (InputData)0; #ifdef _ADDITIONAL_LIGHTS inputData.positionWS = input.positionWS; #endif #ifdef _NORMALMAP half3 viewDirWS = half3(input.normalWS.w, input.tangentWS.w, input.bitangentWS.w); inputData.normalWS = TransformTangentToWorld(normalTS, half3x3(input.tangentWS.xyz, input.bitangentWS.xyz, input.normalWS.xyz)); #else half3 viewDirWS = input.viewDirWS; inputData.normalWS = input.normalWS; #endif inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS); viewDirWS = SafeNormalize(viewDirWS); inputData.viewDirectionWS = viewDirWS; #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) inputData.shadowCoord = input.shadowCoord; #else inputData.shadowCoord = float4(0, 0, 0, 0); #endif inputData.fogCoord = input.fogFactorAndVertexLight.x; inputData.vertexLighting = input.fogFactorAndVertexLight.yzw; inputData.bakedGI = SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS); } /////////////////////////////////////////////////////////////////////////////// // Vertex and Fragment functions // /////////////////////////////////////////////////////////////////////////////// //Standard (Physically Based) shader Varyings LitPassVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS); half3 viewDirWS = GetCameraPositionWS() - vertexInput.positionWS; half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS); half fogFactor = ComputeFogFactor(vertexInput.positionCS.z); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); #ifdef _NORMALMAP output.normalWS = half4(normalInput.normalWS, viewDirWS.x); output.tangentWS = half4(normalInput.tangentWS, viewDirWS.y); output.bitangentWS = half4(normalInput.bitangentWS, viewDirWS.z); #else output.normalWS = NormalizeNormalPerVertex(normalInput.normalWS); output.viewDirWS = viewDirWS; #endif OUTPUT_LIGHTMAP_UV(input.lightmapUV, unity_LightmapST, output.lightmapUV); OUTPUT_SH(output.normalWS.xyz, output.vertexSH); output.fogFactorAndVertexLight = half4(fogFactor, vertexLight); #ifdef _ADDITIONAL_LIGHTS output.positionWS = vertexInput.positionWS; #endif #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) output.shadowCoord = GetShadowCoord(vertexInput); #endif output.positionCS = vertexInput.positionCS; return output; } // Used in Standard (Physically Based) shader half4 LitPassFragment(Varyings input) : SV_Target { input.uv += _Time.x * 10; UNITY_SETUP_INSTANCE_ID(input); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); InputData inputData; InitializeInputData(input, surfaceData.normalTS, inputData); float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; surfaceData.emission *= outline * _DissolveColor; half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); color *= lerp(1, _DissolveColor, outline); color.rgb = MixFog(color.rgb, inputData.fogCoord); return color; } ENDHLSL } // Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl" float3 _LightDirection; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; CBUFFER_START(UnityPerMaterial) float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float4 GetShadowPositionHClip(Attributes input) { float3 positionWS = TransformObjectToWorld(input.positionOS.xyz); float3 normalWS = TransformObjectToWorldNormal(input.normalOS); float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection)); #if UNITY_REVERSED_Z positionCS.z = min(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #else positionCS.z = max(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #endif return positionCS; } Varyings ShadowPassVertex(Attributes input) { Varyings output; input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); UNITY_SETUP_INSTANCE_ID(input); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = GetShadowPositionHClip(input); return output; } half4 ShadowPassFragment(Varyings input) : SV_TARGET { float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #ifndef LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED #define LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED struct Attributes { float4 position : POSITION; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; Varyings DepthOnlyVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.position.xyz += normalize(input.position.xyz) * sin(input.position.x) * sin(_Time.x * 100); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = TransformObjectToHClip(input.position.xyz); return output; } half4 DepthOnlyFragment(Varyings input) : SV_TARGET { UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } #endif ENDHLSL } // Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl" #ifndef LIGHTWEIGHT_LIT_META_PASS_INCLUDED #define LIGHTWEIGHT_LIT_META_PASS_INCLUDED Varyings LightweightVertexMeta(Attributes input) { Varyings output; output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST); output.uv = TRANSFORM_TEX(input.uv0, _BaseMap); return output; } half4 LightweightFragmentMeta(Varyings input) : SV_Target { SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); BRDFData brdfData; InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData); MetaInput metaInput; metaInput.Albedo = brdfData.diffuse + brdfData.specular * brdfData.roughness * 0.5; metaInput.SpecularColor = surfaceData.specular; metaInput.Emission = surfaceData.emission; return MetaFragment(metaInput); } #endif ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor" }</span></span></code> </pre><br></div></div><br>  рд╕рдмрд╕реЗ рдкрд╣рд▓реЗ, рдЖрдкрдХреЛ рдпрд╣ рдкрддрд╛ рд▓рдЧрд╛рдиреЗ рдХреА рдЬрд╝рд░реВрд░рдд рд╣реИ рдХрд┐ рдкрд░рд┐рдгрд╛рдореА рд╢реЗрдбрд░ рдореЗрдВ рдХреНрдпрд╛ рд╣реИред  рд╕рдмрд╕реЗ рдкрд╣рд▓реЗ, рд╣рдо рд▓рд╛рдЗрди рдореЗрдВ рд░реБрдЪрд┐ рд░рдЦрддреЗ рд╣реИрдВ: <br><br><pre> <code class="cpp hljs">CustomEditor <span class="hljs-string"><span class="hljs-string">"UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor"</span></span></code> </pre> <br>  рдЬреЛ, рдЬреИрд╕рд╛ рдХрд┐ рд╣рдо рдпрд╛рдж рдХрд░рддреЗ рд╣реИрдВ, рдореВрд▓ рдореЗрдВ рдирд┐рдореНрдирд╛рдиреБрд╕рд╛рд░ рдерд╛: <br><br><pre> <code class="cpp hljs">CustomEditor <span class="hljs-string"><span class="hljs-string">"UnityEditor.Rendering.LWRP.ShaderGUI.LitShader"</span></span></code> </pre> <br>  рддреЛ рдпрд╣ рдХреНрдпрд╛ рд╣реИ рдФрд░ рдХреНрдпреЛрдВ рд╣реИ?  рдЗрд╕ рдкреНрд░рд╢реНрди рдХрд╛ рдЙрддреНрддрд░ рдХрд╛рдлреА рд╕рд░рд▓ рд╣реИ - рдпрджрд┐ рдЖрдк рдмрд╛рд░реАрдХреА рд╕реЗ рджреЗрдЦрддреЗ рд╣реИрдВ, рддреЛ рд╢реЗрдбрд░ рдХреЗ рдкрд╛рд╕ рд╡рд┐рднрд┐рдиреНрди рдкреНрд░рдХрд╛рд░ рдХреЗ рдбрд┐рдлрд╛рдЗрдирд░реНрд╕ рдХреА рдПрдХ рдмрдбрд╝реА рд╕рдВрдЦреНрдпрд╛ рд╣реЛрддреА рд╣реИ, рдЬреЛ рдЕрдЬреАрдм рддрд░рд╣ рд╕реЗ рдкрд░реНрдпрд╛рдкреНрдд рд╣реЛрддреЗ рд╣реИрдВ, рдЙрдиреНрд╣реЗрдВ рд╕рдХреНрд░рд┐рдп рдФрд░ рдирд┐рд╖реНрдХреНрд░рд┐рдп рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИ, рдФрд░ рдпрд╣, рдПрдХ рдкрд▓ рдХреЗ рд▓рд┐рдП, рдХреЛрдб рд╕реЗ рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИ, рдпрд╣реА рдХрд╛рд░рдг рд╣реИ рдХрд┐ рд╣рдореЗрдВ рдПрдХ рдХрд╕реНрдЯрдо рдирд┐рд░реАрдХреНрд╖рдХ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реИред  рдЗрд╕рдХреЗ рдЕрд▓рд╛рд╡рд╛, рд╣рдорд╛рд░реЗ рдХрд╕реНрдЯрдо рдЗрдВрд╕реНрдкреЗрдХреНрдЯрд░ рдХреЛ рд╣рдореЗрдВ рди рдХреЗрд╡рд▓ рдЕрдВрддрд░реНрдирд┐рд╣рд┐рдд рд╕рдВрдкрддреНрддрд┐рдпреЛрдВ рдХреЛ рд╕рдВрдкрд╛рджрд┐рдд рдХрд░рдиреЗ рдХрд╛ рдореМрдХрд╛ рджреЗрдирд╛ рдЪрд╛рд╣рд┐рдП, рдмрд▓реНрдХрд┐ рдпрд╣ рднреА рдХрд┐ рд╣рдореЗрдВ рдЕрдкрдиреЗ рд╢реЗрдб рдореЗрдВ рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛ рд╕рдХрддреА рд╣реИред<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдореВрд▓ shader рдореЗрдВ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдПрдХ рдХрд╕реНрдЯрдо рдЗрдВрд╕реНрдкреЗрдХреНрдЯрд░ рд╣реИ, рдЗрд╕рд▓рд┐рдП рд╣рдо рдирд┐рд╢реНрдЪрд┐рдд рд░реВрдк рд╕реЗ рдЗрд╕реЗ рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдкрде рдХреЗ рд╕рд╛рде рдвреВрдВрдв рдХрд░ рдкреЗрдЯ рднрд░рддреЗ рд╣реИрдВ: </font></font><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render-pipelines.lightweight@6.9.2 \ Editor \ ShaderGUI \ Shaders \</font></font></i> </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╡рд╛рд╕реНрддрд╡ рдореЗрдВ, рд╣рдо LitShader.cs рдлрд╝рд╛рдЗрд▓ рдореЗрдВ рд░реБрдЪрд┐ рд░рдЦрддреЗ рд╣реИрдВ, рдЬреЛ рдХрд┐ рдмреЗрд╕рд╢реЗрдпрд░рдЧреВрдИ рд╕реЗ рд╡рд┐рд░рд╛рд╕рдд рдореЗрдВ рдорд┐рд▓реА рд╣реИ: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LitShader</span></span> : <span class="hljs-title"><span class="hljs-title">BaseShaderGUI</span></span> { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдореБрдЦреНрдп рдмреИрдЪ рдмрд┐рд▓реНрдХреБрд▓ BaseShaderGUI.cs рдореЗрдВ рд╣реЛрддрд╛ рд╣реИ, рдЬреЛ рдлрд╝реЛрд▓реНрдбрд░ рдореЗрдВ рдПрдХ рд╕реНрддрд░ рдЕрдзрд┐рдХ рдкрд╛рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИ: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseShaderGUI</span></span> : <span class="hljs-title"><span class="hljs-title">ShaderGUI</span></span> { ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╣рдо рдЗрди рд▓рд┐рдкрд┐рдпреЛрдВ рдХреЛ рд▓реЗрддреЗ рд╣реИрдВ рдФрд░ рдЙрдиреНрд╣реЗрдВ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╕рдВрдкрд╛рджрдХ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдлрд╝реЛрд▓реНрдбрд░ рдореЗрдВ рдлреЗрдВрдХ рджреЗрддреЗ рд╣реИрдВ </font><font style="vertical-align: inherit;">(рдпрджрд┐ рдХреЛрдИ рдирд╣реАрдВ рд╣реИ, рддреЛ рдЙрдиреНрд╣реЗрдВ рдмрдирд╛рдПрдВ, рдЕрдиреНрдпрдерд╛ рдкрд░рд┐рдпреЛрдЬрдирд╛ рдХреЗ рдирд┐рд░реНрдорд╛рдг рдХреЗ рджреМрд░рд╛рди рд╕реНрд╡рд╛рднрд╛рд╡рд┐рдХ рд░реВрдк рд╕реЗ рддреНрд░реБрдЯрд┐рдпрд╛рдВ рджрд┐рдЦрд╛рдИ рджреЗрдВрдЧреА, рдХреНрдпреЛрдВрдХрд┐ рдпреВрдирд┐рдЯреА рдПрдбрд┐рдЯрд░ рдирд╛рдо рдмрд┐рд▓реНрдб рдореЗрдВ рд╢рд╛рдорд┐рд▓ рдирд╣реАрдВ рд╣реИ)ред </font><font style="vertical-align: inherit;">рдмреЗрд╢рдХ, рд╣рдорд╛рд░реЗ рд╕рд┐рд░ рдкрд░ рдПрдХ рд╣рдЬрд╛рд░ рдПрдХ рдЧрд▓рддреА рд╣реИ, рдЬреЛ рдЯрд╛рдЗрдк internel рд╕рд╛рде рдЬреБрдбрд╝реЗ рд░рд╣реЗ рд╣реИрдВ рдЧрд┐рд░ рдЬрд╛рддрд╛ рд╣реИ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SavedBool</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╣реИ, рдЬреЛ рдПрдХ рдзрд╛рд░рд╛рд╡рд╛рд╣рд┐рдХ рдЦрд┐рдбрд╝рдХреА рдкреНрд░рдХрд╛рд░ bool рдЪрд░ рд╕рдВрдкрд╛рджрдХ рд╣реИред </font><font style="vertical-align: inherit;">рдпрд╣ рд╕рд╛рдордЧреНрд░реА рдХреЗ рддрд╣ рд╡рд░реНрдЧреЛрдВ рдХреА рд╕реНрдерд┐рддрд┐ рдХреЛ рдмрдирд╛рдП рд░рдЦрдиреЗ рдХреЗ рд▓рд┐рдП рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИред </font><font style="vertical-align: inherit;">рджрд░рдЕрд╕рд▓, рд╕реБрдзрд╛рд░ рдХреЗ рд▓рд┐рдП рд╣рдо рд╕рд░рд▓ рд╣реЗрд░рдлреЗрд░ рдХрд░рддреЗ рд╣реИрдВред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдмрджрд▓рдиреЗ рдХреЗ рд▓рд┐рдП:</font></font><br><br><pre> <code class="cs hljs">SavedBool m_SurfaceOptionsFoldout; SavedBool m_SurfaceInputsFoldout; SavedBool m_AdvancedFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП: </font></font><br><br><pre> <code class="cs hljs">AnimatedValues.AnimBool m_SurfaceOptionsFoldout; AnimatedValues.AnimBool m_SurfaceInputsFoldout; AnimatedValues.AnimBool m_AdvancedFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдФрд░ рдЕрддрд┐рд░рд┐рдХреНрдд рдХрд╕реНрдЯрдо рдЧреБрдгреЛрдВ рдХреЗ рд▓рд┐рдП рдПрдХ рдФрд░ рдЪрд░ рдЬреЛрдбрд╝реЗрдВ: </font></font><br><br><pre> <code class="cs hljs">AnimatedValues.AnimBool m_OtherFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдЖрдкрдХреЛ рд╣рдорд╛рд░реЗ рдХрд╕реНрдЯрдо рдорд╛рдкрджрдВрдбреЛрдВ рдХреЗ рд╕рд╛рде рдЕрдиреБрднрд╛рдЧ рдХрд╛ рдирд╛рдо рдФрд░ рд╡рд┐рд╡рд░рдг рднреА рдЬреЛрдбрд╝рдирд╛ рд╣реЛрдЧрд╛, рд╕реНрдХреНрд░рд┐рдкреНрдЯ рдХреЗ рдЕрдВрджрд░ рд╕реНрдерд╛рдкрд┐рдд рдкрд░рдВрдкрд░рд╛рдУрдВ рдХрд╛ рдЕрд╡рд▓реЛрдХрди рдХрд░рдирд╛: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Styles</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Catergories ... public static readonly GUIContent OtherOptions = new GUIContent("Your own options", "You own custom options"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЦреИрд░, рдЕрдм рдереЛрдбрд╝рд╛ рдЯреНрд░рд┐рдХ рдХрд░рддреЗ рд╣реИрдВред </font><font style="vertical-align: inherit;">рдЬреИрд╕рд╛ рдХрд┐ рдЖрдк рджреЗрдЦ рд╕рдХрддреЗ рд╣реИрдВ, рд╕рднреА рдорд╛рдирдХ рдЧреБрдгреЛрдВ рдХреЗ рд▓рд┐рдП рдореИрдВрдиреЗ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HideInInspector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╡рд┐рд╢реЗрд╖рддрд╛ рдирд┐рд░реНрдзрд╛рд░рд┐рдд рдХреА рд╣реИ </font><font style="vertical-align: inherit;">, рдЬреЛ рд╕реАрдзреЗ рд╕рдВрдХреЗрдд рджреЗрддрд╛ рд╣реИ рдХрд┐ рдпрд╣ рд╕рдВрдкрддреНрддрд┐ рдирд┐рд░реАрдХреНрд╖рдХ рдореЗрдВ рдЫрд┐рдкреА рд╣реЛрдЧреАред </font><font style="vertical-align: inherit;">рд╣рд╛рд▓рд╛рдВрдХрд┐, рдпрд╣ рдХреЗрд╡рд▓ рд╕рд╛рдордЧреНрд░реА рдХреЗ рдорд╛рдирдХ рдирд┐рд░реАрдХреНрд╖рдХ рдХреЗ рд▓рд┐рдП рдкреНрд░рд╛рд╕рдВрдЧрд┐рдХ рд╣реИ, рд▓реЗрдХрд┐рди рдХреМрди рд╕рд╛? </font><font style="vertical-align: inherit;">рдпрд╣ рд╕рд╣реА рд╣реИ, рдХрд╕реНрдЯрдо! </font><font style="vertical-align: inherit;">рдЗрд╕рдХрд╛ рдорддрд▓рдм рдпрд╣ рд╣реИ рдХрд┐ рд╣рдорд╛рд░реЗ рд╕рднреА рдЕрдВрддрд░реНрдирд┐рд╣рд┐рдд рдЧреБрдг рдХрд┐рд╕реА рднреА рддрд░рд╣ рд╕реЗ рдкреНрд░рджрд╛рди рдХрд┐рдП рдЬрд╛рддреЗ рд╣реИрдВред </font><font style="vertical-align: inherit;">рддреЛ рдЖрдЗрдП рдЙрдиреНрд╣реЗрдВ рдЫрд┐рдкрд╛рддреЗ рд╣реИрдВ:</font></font><br><br><pre> <code class="cpp hljs">... [MainColor][HideInInspector] _BaseColor(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [MainTexture][HideInInspector] _BaseMap(<span class="hljs-string"><span class="hljs-string">"Albedo"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} [HideInInspector]_Cutoff(<span class="hljs-string"><span class="hljs-string">"Alpha Cutoff"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> [HideInInspector]_Smoothness(<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> [HideInInspector]_GlossMapScale(<span class="hljs-string"><span class="hljs-string">"Smoothness Scale"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> [HideInInspector]_SmoothnessTextureChannel(<span class="hljs-string"><span class="hljs-string">"Smoothness texture channel"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдФрд░ рдХрд╕реНрдЯрдо рд╕рдВрдкрд╛рджрдХ рдХреЗ рдХреЛрдб рдХреЗ рдЕрдВрджрд░, рд╣рдо рдмрд╕ рдорд╛рдирдХ рдирд┐рд░реАрдХреНрд╖рдХ рдХреЗ рдкреНрд░рддрд┐рдкрд╛рджрди рдХрд╣рддреЗ рд╣реИрдВ: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { ... m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = EditorGUILayout.BeginFoldoutHeaderGroup(m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, Styles.OtherOptions); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnGUI(materialEditorIn, properties); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдкрд░рд┐рдгрд╛рдо рд╕реНрдкрд╖реНрдЯ рд╣реИ: </font><font style="vertical-align: inherit;">рдФрд░ рдпрд╣рд╛рдБ рджреЛрдиреЛрдВ рд▓рд┐рдкрд┐рдпреЛрдВ рдХреЗ рд▓рд┐рдП рдХреЛрдб рд╣реИ:</font></font><br><br> <a href="https://ibb.co/wz3FT1X" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/81e/d13/4b6/81ed134b69e689252cc2325dd59bc24b.png" alt="2020-01-19-22-58-23"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BaseShaderEditor.cs</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UnityEditor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseShaderEditor</span></span> : <span class="hljs-title"><span class="hljs-title">ShaderGUI</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> EnumsAndClasses public enum SurfaceType { Opaque, Transparent } public enum BlendMode { Alpha, // Old school alpha-blending mode, fresnel does not affect amount of transparency Premultiply, // Physically plausible transparency mode, implemented as alpha pre-multiply Additive, Multiply } public enum SmoothnessSource { BaseAlpha, SpecularAlpha } public enum RenderFace { Front = 2, Back = 1, Both = 0 } protected class Styles { // Catergories public static readonly GUIContent SurfaceOptions = new GUIContent("Surface Options", "Controls how LWRP renders the Material on a screen."); public static readonly GUIContent SurfaceInputs = new GUIContent("Surface Inputs", "These settings describe the look and feel of the surface itself."); public static readonly GUIContent AdvancedLabel = new GUIContent("Advanced", "These settings affect behind-the-scenes rendering and underlying calculations."); public static readonly GUIContent surfaceType = new GUIContent("Surface Type", "Select a surface type for your texture. Choose between Opaque or Transparent."); public static readonly GUIContent blendingMode = new GUIContent("Blending Mode", "Controls how the color of the Transparent surface blends with the Material color in the background."); public static readonly GUIContent cullingText = new GUIContent("Render Face", "Specifies which faces to cull from your geometry. Front culls front faces. Back culls backfaces. None means that both sides are rendered."); public static readonly GUIContent alphaClipText = new GUIContent("Alpha Clipping", "Makes your Material act like a Cutout shader. Use this to create a transparent effect with hard edges between opaque and transparent areas."); public static readonly GUIContent alphaClipThresholdText = new GUIContent("Threshold", "Sets where the Alpha Clipping starts. The higher the value is, the brighter the effect is when clipping starts."); public static readonly GUIContent receiveShadowText = new GUIContent("Receive Shadows", "When enabled, other GameObjects can cast shadows onto this GameObject."); public static readonly GUIContent baseMap = new GUIContent("Base Map", "Specifies the base Material and/or Color of the surface. If you've selected Transparent or Alpha Clipping under Surface Options, your Material uses the Texture's alpha channel or color."); public static readonly GUIContent emissionMap = new GUIContent("Emission Map", "Sets a Texture map to use for emission. You can also select a color with the color picker. Colors are multiplied over the Texture."); public static readonly GUIContent normalMapText = new GUIContent("Normal Map", "Assigns a tangent-space normal map."); public static readonly GUIContent bumpScaleNotSupported = new GUIContent("Bump scale is not supported on mobile platforms"); public static readonly GUIContent fixNormalNow = new GUIContent("Fix now", "Converts the assigned texture to be a normal map format."); public static readonly GUIContent queueSlider = new GUIContent("Priority", "Determines the chronological rendering order for a Material. High values are rendered first."); public static readonly GUIContent OtherOptions = new GUIContent("Your own options", "You own custom options"); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Variables protected MaterialEditor materialEditor { get; set; } protected MaterialProperty surfaceTypeProp { get; set; } protected MaterialProperty blendModeProp { get; set; } protected MaterialProperty cullingProp { get; set; } protected MaterialProperty alphaClipProp { get; set; } protected MaterialProperty alphaCutoffProp { get; set; } protected MaterialProperty receiveShadowsProp { get; set; } // Common Surface Input properties protected MaterialProperty baseMapProp { get; set; } protected MaterialProperty baseColorProp { get; set; } protected MaterialProperty emissionMapProp { get; set; } protected MaterialProperty emissionColorProp { get; set; } protected MaterialProperty queueOffsetProp { get; set; } public bool m_FirstTimeApply = true; private const string k_KeyPrefix = "LightweightRP:Material:UI_State:"; private string m_HeaderStateKey = null; // Header foldout states AnimatedValues.AnimBool m_SurfaceOptionsFoldout; AnimatedValues.AnimBool m_SurfaceInputsFoldout; AnimatedValues.AnimBool m_AdvancedFoldout; AnimatedValues.AnimBool m_OtherFoldout; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> private const int queueOffsetRange = 50; //////////////////////////////////// // General Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> GeneralFunctions public abstract void MaterialChanged(Material material); public virtual void FindProperties(MaterialProperty[] properties) { surfaceTypeProp = FindProperty("_Surface", properties); blendModeProp = FindProperty("_Blend", properties); cullingProp = FindProperty("_Cull", properties); alphaClipProp = FindProperty("_AlphaClip", properties); alphaCutoffProp = FindProperty("_Cutoff", properties); receiveShadowsProp = FindProperty("_ReceiveShadows", properties, false); baseMapProp = FindProperty("_BaseMap", properties, false); baseColorProp = FindProperty("_BaseColor", properties, false); emissionMapProp = FindProperty("_EmissionMap", properties, false); emissionColorProp = FindProperty("_EmissionColor", properties, false); queueOffsetProp = FindProperty("_QueueOffset", properties, false); } public override void OnGUI(MaterialEditor materialEditorIn, MaterialProperty[] properties) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (materialEditorIn == null) throw new ArgumentNullException("materialEditorIn"); FindProperties(properties); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly materialEditor = materialEditorIn; Material material = materialEditor.target as Material; // Make sure that needed setup (ie keywords/renderqueue) are set up </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we're switching some existing // material to a lightweight shader. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_FirstTimeApply) { OnOpenGUI(material, materialEditorIn); m_FirstTimeApply = false; } ShaderPropertiesGUI(material); m_OtherFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_OtherFoldout.value, Styles.OtherOptions); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_OtherFoldout.value) { base.OnGUI(materialEditorIn, properties); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } public virtual void OnOpenGUI(Material material, MaterialEditor materialEditor) { // Foldout states m_HeaderStateKey = k_KeyPrefix + material.shader.name; // Create key string for editor prefs m_SurfaceOptionsFoldout = new AnimatedValues.AnimBool(true); m_SurfaceInputsFoldout = new AnimatedValues.AnimBool(true); m_AdvancedFoldout = new AnimatedValues.AnimBool(true); m_OtherFoldout = new AnimatedValues.AnimBool(true); foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } public void ShaderPropertiesGUI(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material == null) throw new ArgumentNullException("material"); EditorGUI.BeginChangeCheck(); m_SurfaceOptionsFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_SurfaceOptionsFoldout.value, Styles.SurfaceOptions); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_SurfaceOptionsFoldout.value) { DrawSurfaceOptions(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); m_SurfaceInputsFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_SurfaceInputsFoldout.value, Styles.SurfaceInputs); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_SurfaceInputsFoldout.value) { DrawSurfaceInputs(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); m_AdvancedFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_AdvancedFoldout.value, Styles.AdvancedLabel); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_AdvancedFoldout.value) { DrawAdvancedOptions(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); DrawAdditionalFoldouts(material); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Drawing Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> DrawingFunctions public virtual void DrawSurfaceOptions(Material material) { DoPopup(Styles.surfaceType, surfaceTypeProp, Enum.GetNames(typeof(SurfaceType))); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((SurfaceType)material.GetFloat("_Surface") == SurfaceType.Transparent) DoPopup(Styles.blendingMode, blendModeProp, Enum.GetNames(typeof(BlendMode))); EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = cullingProp.hasMixedValue; var culling = (RenderFace)cullingProp.floatValue; culling = (RenderFace)EditorGUILayout.EnumPopup(Styles.cullingText, culling); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(Styles.cullingText.text); cullingProp.floatValue = (float)culling; material.doubleSidedGI = (RenderFace)cullingProp.floatValue != RenderFace.Front; } EditorGUI.showMixedValue = false; EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = alphaClipProp.hasMixedValue; var alphaClipEnabled = EditorGUILayout.Toggle(Styles.alphaClipText, alphaClipProp.floatValue == 1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) alphaClipProp.floatValue = alphaClipEnabled ? 1 : 0; EditorGUI.showMixedValue = false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClipProp.floatValue == 1) materialEditor.ShaderProperty(alphaCutoffProp, Styles.alphaClipThresholdText, 1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (receiveShadowsProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = receiveShadowsProp.hasMixedValue; var receiveShadows = EditorGUILayout.Toggle(Styles.receiveShadowText, receiveShadowsProp.floatValue == 1.0f); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) receiveShadowsProp.floatValue = receiveShadows ? 1.0f : 0.0f; EditorGUI.showMixedValue = false; } } public virtual void DrawSurfaceInputs(Material material) { DrawBaseProperties(material); } public virtual void DrawAdvancedOptions(Material material) { materialEditor.EnableInstancingField(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (queueOffsetProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = queueOffsetProp.hasMixedValue; var queue = EditorGUILayout.IntSlider(Styles.queueSlider, (int)queueOffsetProp.floatValue, -queueOffsetRange, queueOffsetRange); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) queueOffsetProp.floatValue = queue; EditorGUI.showMixedValue = false; } } public virtual void DrawAdditionalFoldouts(Material material) { } public virtual void DrawBaseProperties(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (baseMapProp != null &amp;&amp; baseColorProp != null) // Draw the baseMap, most shader will have at least a baseMap { materialEditor.TexturePropertySingleLine(Styles.baseMap, baseMapProp, baseColorProp); // TODO Temporary fix for lightmapping, to be replaced with attribute tag. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_MainTex")) { material.SetTexture("_MainTex", baseMapProp.textureValue); var baseMapTiling = baseMapProp.textureScaleAndOffset; material.SetTextureScale("_MainTex", new Vector2(baseMapTiling.x, baseMapTiling.y)); material.SetTextureOffset("_MainTex", new Vector2(baseMapTiling.z, baseMapTiling.w)); } } } protected virtual void DrawEmissionProperties(Material material, bool keyword) { var emissive = true; var hadEmissionTexture = emissionMapProp.textureValue != null; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!keyword) { materialEditor.TexturePropertyWithHDRColor(Styles.emissionMap, emissionMapProp, emissionColorProp, false); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { // Emission for GI? emissive = materialEditor.EmissionEnabledProperty(); EditorGUI.BeginDisabledGroup(!emissive); { // Texture and HDR color controls materialEditor.TexturePropertyWithHDRColor(Styles.emissionMap, emissionMapProp, emissionColorProp, false); } EditorGUI.EndDisabledGroup(); } // If texture was assigned and color was black set color to white var brightness = emissionColorProp.colorValue.maxColorComponent; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (emissionMapProp.textureValue != null &amp;&amp; !hadEmissionTexture &amp;&amp; brightness &lt;= 0f) emissionColorProp.colorValue = Color.white; // LW does not support RealtimeEmissive. We set it to bake emissive and handle the emissive is black right. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (emissive) { material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.BakedEmissive; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (brightness &lt;= 0f) material.globalIlluminationFlags |= MaterialGlobalIlluminationFlags.EmissiveIsBlack; } } public static void DrawNormalArea(MaterialEditor materialEditor, MaterialProperty bumpMap, MaterialProperty bumpMapScale = null) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bumpMapScale != null) { materialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap, bumpMap.textureValue != null ? bumpMapScale : null); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bumpMapScale.floatValue != 1 &amp;&amp; UnityEditorInternal.InternalEditorUtility.IsMobilePlatform( EditorUserBuildSettings.activeBuildTarget)) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (materialEditor.HelpBoxWithButton(Styles.bumpScaleNotSupported, Styles.fixNormalNow)) bumpMapScale.floatValue = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { materialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap); } } protected static void DrawTileOffset(MaterialEditor materialEditor, MaterialProperty textureProp) { materialEditor.TextureScaleOffsetProperty(textureProp); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Material Data Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> MaterialDataFunctions public static void SetMaterialKeywords(Material material, Action&lt;Material&gt; shadingModelFunc = null, Action&lt;Material&gt; shaderFunc = null) { // Clear all keywords for fresh start material.shaderKeywords = null; // Setup blending - consistent across all LWRP shaders SetupMaterialBlendMode(material); // Receive Shadows </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_ReceiveShadows")) CoreUtils.SetKeyword(material, "_RECEIVE_SHADOWS_OFF", material.GetFloat("_ReceiveShadows") == 0.0f); // Emission </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_EmissionColor")) MaterialEditor.FixupEmissiveFlag(material); bool shouldEmissionBeEnabled = (material.globalIlluminationFlags &amp; MaterialGlobalIlluminationFlags.EmissiveIsBlack) == 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_EmissionEnabled") &amp;&amp; !shouldEmissionBeEnabled) shouldEmissionBeEnabled = material.GetFloat("_EmissionEnabled") &gt;= 0.5f; CoreUtils.SetKeyword(material, "_EMISSION", shouldEmissionBeEnabled); // Normal Map </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_BumpMap")) CoreUtils.SetKeyword(material, "_NORMALMAP", material.GetTexture("_BumpMap")); // Shader specific keyword functions shadingModelFunc?.Invoke(material); shaderFunc?.Invoke(material); } public static void SetupMaterialBlendMode(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material == null) throw new ArgumentNullException("material"); bool alphaClip = material.GetFloat("_AlphaClip") == 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClip) { material.EnableKeyword("_ALPHATEST_ON"); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { material.DisableKeyword("_ALPHATEST_ON"); } var queueOffset = 0; // queueOffsetRange; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_QueueOffset")) queueOffset = queueOffsetRange - (int)material.GetFloat("_QueueOffset"); SurfaceType surfaceType = (SurfaceType)material.GetFloat("_Surface"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (surfaceType == SurfaceType.Opaque) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClip) { material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest; material.SetOverrideTag("RenderType", "TransparentCutout"); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Geometry; material.SetOverrideTag("RenderType", "Opaque"); } material.renderQueue += queueOffset; material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero); material.SetInt("_ZWrite", 1); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); material.SetShaderPassEnabled("ShadowCaster", true); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { BlendMode blendMode = (BlendMode)material.GetFloat("_Blend"); var queue = (int)UnityEngine.Rendering.RenderQueue.Transparent; // Specific Transparent Mode Settings switch (blendMode) { case BlendMode.Alpha: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Premultiply: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha); material.EnableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Additive: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.One); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Multiply: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.DstColor); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); material.EnableKeyword("_ALPHAMODULATE_ON"); break; } // General Transparent Material Settings material.SetOverrideTag("RenderType", "Transparent"); material.SetInt("_ZWrite", 0); material.renderQueue = queue + queueOffset; material.SetShaderPassEnabled("ShadowCaster", false); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Helper Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HelperFunctions public static void TwoFloatSingleLine(GUIContent title, MaterialProperty prop1, GUIContent prop1Label, MaterialProperty prop2, GUIContent prop2Label, MaterialEditor materialEditor, float labelWidth = 30f) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = prop1.hasMixedValue || prop2.hasMixedValue; Rect rect = EditorGUILayout.GetControlRect(); EditorGUI.PrefixLabel(rect, title); var indent = EditorGUI.indentLevel; var preLabelWidth = EditorGUIUtility.labelWidth; EditorGUI.indentLevel = 0; EditorGUIUtility.labelWidth = labelWidth; Rect propRect1 = new Rect(rect.x + preLabelWidth, rect.y, (rect.width - preLabelWidth) * 0.5f, EditorGUIUtility.singleLineHeight); var prop1val = EditorGUI.FloatField(propRect1, prop1Label, prop1.floatValue); Rect propRect2 = new Rect(propRect1.x + propRect1.width, rect.y, propRect1.width, EditorGUIUtility.singleLineHeight); var prop2val = EditorGUI.FloatField(propRect2, prop2Label, prop2.floatValue); EditorGUI.indentLevel = indent; EditorGUIUtility.labelWidth = preLabelWidth; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(title.text); prop1.floatValue = prop1val; prop2.floatValue = prop2val; } EditorGUI.showMixedValue = false; } public void DoPopup(GUIContent label, MaterialProperty property, string[] options) { DoPopup(label, property, options, materialEditor); } public static void DoPopup(GUIContent label, MaterialProperty property, string[] options, MaterialEditor materialEditor) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (property == null) throw new ArgumentNullException("property"); EditorGUI.showMixedValue = property.hasMixedValue; var mode = property.floatValue; EditorGUI.BeginChangeCheck(); mode = EditorGUILayout.Popup(label, (int)mode, options); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(label.text); property.floatValue = mode; } EditorGUI.showMixedValue = false; } // Helper to show texture and color properties public static Rect TextureColorProps(MaterialEditor materialEditor, GUIContent label, MaterialProperty textureProp, MaterialProperty colorProp, bool hdr = false) { Rect rect = EditorGUILayout.GetControlRect(); EditorGUI.showMixedValue = textureProp.hasMixedValue; materialEditor.TexturePropertyMiniThumbnail(rect, textureProp, label.text, label.tooltip); EditorGUI.showMixedValue = false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (colorProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = colorProp.hasMixedValue; int indentLevel = EditorGUI.indentLevel; EditorGUI.indentLevel = 0; Rect rectAfterLabel = new Rect(rect.x + EditorGUIUtility.labelWidth, rect.y, EditorGUIUtility.fieldWidth, EditorGUIUtility.singleLineHeight); var col = EditorGUI.ColorField(rectAfterLabel, GUIContent.none, colorProp.colorValue, true, false, hdr); EditorGUI.indentLevel = indentLevel; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(colorProp.displayName); colorProp.colorValue = col; } EditorGUI.showMixedValue = false; } return rect; } // Copied from shaderGUI as it is a protected function in an abstract class, unavailable to others public new static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties) { return FindProperty(propertyName, properties, true); } // Copied from shaderGUI as it is a protected function in an abstract class, unavailable to others public new static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties, bool propertyIsMandatory) { for (int index = 0; index &lt; properties.Length; ++index) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (properties[index] != null &amp;&amp; properties[index].name == propertyName) return properties[index]; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (propertyIsMandatory) throw new ArgumentException("Could not find MaterialProperty: '" + propertyName + "', Num properties: " + (object)properties.Length); return null; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LitShaderEditor.cs</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor.Rendering.LWRP; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UnityEditor.Rendering.LWRP.ShaderGUI</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LitShaderEditor</span></span> : <span class="hljs-title"><span class="hljs-title">BaseShaderEditor</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Properties private LitGUI.LitProperties litProperties; // collect properties from the material properties public override void FindProperties(MaterialProperty[] properties) { base.FindProperties(properties); litProperties = new LitGUI.LitProperties(properties); } // material changed check public override void MaterialChanged(Material material) { if (material == null) throw new ArgumentNullException("material"); SetMaterialKeywords(material, LitGUI.SetMaterialKeywords); } // material main surface options public override void DrawSurfaceOptions(Material material) { if (material == null) throw new ArgumentNullException("material"); // Use default labelWidth EditorGUIUtility.labelWidth = 0f; // Detect any changes to the material EditorGUI.BeginChangeCheck(); if (litProperties.workflowMode != null) { DoPopup(LitGUI.Styles.workflowModeText, litProperties.workflowMode, Enum.GetNames(typeof(LitGUI.WorkflowMode))); } if (EditorGUI.EndChangeCheck()) { foreach (var obj in blendModeProp.targets) MaterialChanged((Material)obj); } base.DrawSurfaceOptions(material); } // material main surface inputs public override void DrawSurfaceInputs(Material material) { base.DrawSurfaceInputs(material); LitGUI.Inputs(litProperties, materialEditor, material); DrawEmissionProperties(material, true); DrawTileOffset(materialEditor, baseMapProp); } // material main advanced options public override void DrawAdvancedOptions(Material material) { if (litProperties.reflections != null &amp;&amp; litProperties.highlights != null) { EditorGUI.BeginChangeCheck(); { materialEditor.ShaderProperty(litProperties.highlights, LitGUI.Styles.highlightsText); materialEditor.ShaderProperty(litProperties.reflections, LitGUI.Styles.reflectionsText); EditorGUI.BeginChangeCheck(); } } base.DrawAdvancedOptions(material); } public override void AssignNewShaderToMaterial(Material material, Shader oldShader, Shader newShader) { if (material == null) throw new ArgumentNullException("material"); // _Emission property is lost after assigning Standard shader to the material // thus transfer it before assigning the new shader if (material.HasProperty("_Emission")) { material.SetColor("_EmissionColor", material.GetColor("_Emission")); } base.AssignNewShaderToMaterial(material, oldShader, newShader); if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/")) { SetupMaterialBlendMode(material); return; } SurfaceType surfaceType = SurfaceType.Opaque; BlendMode blendMode = BlendMode.Alpha; if (oldShader.name.Contains("/Transparent/Cutout/")) { surfaceType = SurfaceType.Opaque; material.SetFloat("_AlphaClip", 1); } else if (oldShader.name.Contains("/Transparent/")) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> legacy shaders did not provide physically based transparency // therefore Fade mode surfaceType = SurfaceType.Transparent; blendMode = BlendMode.Alpha; } material.SetFloat("_Surface", (float)surfaceType); material.SetFloat("_Blend", (float)blendMode); if (oldShader.name.Equals("Standard (Specular setup)")) { material.SetFloat("_WorkflowMode", (float)LitGUI.WorkflowMode.Specular); Texture texture = material.GetTexture("_SpecGlossMap"); if (texture != null) material.SetTexture("_MetallicSpecGlossMap", texture); } else { material.SetFloat("_WorkflowMode", (float)LitGUI.WorkflowMode.Metallic); Texture texture = material.GetTexture("_MetallicGlossMap"); if (texture != null) material.SetTexture("_MetallicSpecGlossMap", texture); } MaterialChanged(material); } } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЕрдм рдЖрдЗрдП рдЫрд╛рдпрд╛рдХрд╛рд░ рдХреЗ рдЗрдирд╕рд╛рдЗрдб рдХреЛ рджреЗрдЦреЗрдВред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдкрд╣рд▓реА рдмрд╛рдд рдЬрд┐рд╕ рдкрд░ рдЖрдк рдзреНрдпрд╛рди рджреЗрддреЗ рд╣реИрдВ, рд╡рд╣ рдпрд╣ рд╣реИ рдХрд┐ рд╢реЗрдбрд░ рдореЗрдВ рдХреЗрд╡рд▓ рдкрд╛рдБрдЪ рдкрд╛рд╕ рд╣реИрдВред </font><font style="vertical-align: inherit;">рдЖрдЗрдП рд╣рдо рдЙрди рдкрд░ рдереЛрдбрд╝рд╛ рдзреНрдпрд╛рди рджреЗрдВ:</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдлреЙрд░рд╡рд░реНрдбрд▓рд┐рдЯ:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдлреЙрд░рд╡рд░реНрдб рдкрд╛рд╕, рдпрд╣рд╛рдВ рд╣рдо рдкреНрд░рдХрд╛рд╢, рдкреАрдмреАрдЖрд░ рдФрд░ рдХреЛрд╣рд░реЗ рдкрд░ рд╡рд┐рдЪрд╛рд░ рдХрд░рддреЗ рд╣реИрдВред</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╢реИрдбреЛрдХрд╛рд╕реНрдЯрд░:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдпрд╣рд╛рдВ </font><b><font style="vertical-align: inherit;">рдкрд░рдЫрд╛рдЗрдпреЛрдВ</font></b><font style="vertical-align: inherit;"> рдХреА рдЧрдгрдирд╛ рд╣реИред</font></font></li><li> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЧрд╣рд░рд╛рдИ </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> рдЧрд╣рд░рд╛рдИ (рдЬреЗрдб-рдмрдлрд░)ред</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдореЗрдЯрд╛:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдмреЗрдХреНрдб рд▓рд╛рдЗрдЯ (lightmaps)ред</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд▓рд╛рдЗрдЯрд╡реЗрдЯ 2 рдбреА:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╕реНрдкреНрд░рд╛рдЗрдЯреНрд╕ рдФрд░ рдпреВрдЖрдИред</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЗрд╕рдХреЗ рдЕрд▓рд╛рд╡рд╛, рдПрдХрддрд╛ рдХреЗ рдкрд╛рд╕ рдХрдИ рдЕрд▓рдЧ-рдЕрд▓рдЧ рд╢реЗрдбрд░ рдХрдВрдкрд╛рдЗрд▓рд░ рдФрд░ рдХреНрд░реЙрд╕ рдХрдВрдкрд╛рдЗрд▓рд░ рд╣реИрдВред </font><font style="vertical-align: inherit;">SRP рдХреЛ HLSLcc рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИред </font><font style="vertical-align: inherit;">рдРрд╕реЗ рдкреНрд▓реЗрдЯрдлрд╝реЙрд░реНрдо рдкрд░ рдЬреЛ OpenGL ES рдЧреНрд░рд╛рдлрд╝рд┐рдХреНрд╕ API (рдЬреИрд╕реЗ Android) рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рддрд╛ рд╣реИ, HLSLcc рдбрд┐рдлрд╝реЙрд▓реНрдЯ рд░реВрдк рд╕реЗ рдЙрдкрдпреЛрдЧ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЗрд╕рд▓рд┐рдП, рд╣рдо рдЗрд╕реЗ рдХрдиреЗрдХреНрдЯ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдордЬрдмреВрд░ рдХрд░рддреЗ рд╣реИрдВ:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> prefer_hlslcc gles</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд▓реЗрдХрд┐рди DirectX 9 рд╕рдорд░реНрдерд┐рдд рдирд╣реАрдВ рд╣реИ, рдЗрд╕рд▓рд┐рдП рдЗрд╕реЗ рдЬрдмрд░рди рдЕрдХреНрд╖рдо рдХрд░реЗрдВ: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> exclude_renderers d3d11_9x</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдХреЛрдб рд▓рд┐рдЦрдиреЗ рдХреЗ рд╕рдВрджрд░реНрдн рдореЗрдВ, рдХреБрдЫ рднреА рдирд╣реАрдВ рдмрджрд▓рд╛ рд╣реИ, рд╕рд┐рд╡рд╛рдп рдЗрд╕рдХреЗ рдХрд┐ рдЕрдм рд╣рдо рд╕реАрдЬреА рдореЗрдВ рдирд╣реАрдВ, рдмрд▓реНрдХрд┐ рд╢реБрджреНрдз рдПрдЪрдПрд▓рдПрд╕рдПрд▓ рдореЗрдВ рд▓рд┐рдЦ рд░рд╣реЗ рд╣реИрдВ, рдФрд░ рдЗрд╕рд▓рд┐рдП рдЕрдм рд╢реЗрдбрд░ рдкреНрд░реЛрдЧреНрд░рд╛рдо рдХрд╛ рд╢рд░реАрд░ рдЗрд╕ рддрд░рд╣ рджрд┐рдЦреЗрдЧрд╛:</font></font><br><br><pre> <code class="cpp hljs">HLSLPROGRAM ... ENDHLSL</code> </pre> <br>   -       <b>_Time</b> , <b>_ScreenParams</b>  <b>_WorldSpaceCameraPos</b> .    ,     <i>UnityCG.cginc</i>   .        , ,  <b>UnityObjectToClipPos(POSITION)</b>  <b>TransformWorldToHClip(POSITION)</b> ,     тАФ  <b>UNITY_APPLY_FOG(fogCoord, color)</b>    <b>MixFog(color, fogCoord)</b> . <br><br> ,           Core.hlsl: <br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render- рдкрд╛рдЗрдкрд▓рд╛рдЗрдиреЛрдВред рд▓рд╛рдЗрдЯрд╡реЗрдЯ @ (LWRP рд╕рдВрд╕реНрдХрд░рдг) \ ShaderLibrary \ Core.hlsl</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╣рдо рдЙрдкрд▓рдмреНрдз рд╕реБрд╡рд┐рдзрд╛рдУрдВ рдХреА рдкреВрд░реА рд╕реВрдЪреА рдкрд╛ рд╕рдХрддреЗ рд╣реИрдВред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЗрд╕рдХреЗ рдЕрд▓рд╛рд╡рд╛ рдЙрд▓реНрд▓реЗрдЦ рдХреЗ рд▓рд╛рдпрдХ рд▓рдЧрд╛рддрд╛рд░ рдмрдлрд╝рд░реНрд╕ (CBUFFER) рдФрд░ UnityPerMaterial рд╣реИрдВред </font><font style="vertical-align: inherit;">рд▓рдЧрд╛рддрд╛рд░ рдмрдлрд╝рд░реНрд╕ рдХрд╛ рдЙрдкрдпреЛрдЧ рдбреЗрдЯрд╛ рдХреЛ рд╕реНрдЯреЛрд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ, рдЬреЛ рдХрд┐ GPU рдкрд░ рдХреНрд░рдорд╢рдГ рдмрджрд▓ рджрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ, рдХреНрд░рдорд╢рдГ рдЗрдиреНрд╣реЗрдВ shader рд╡реЗрд░рд┐рдПрдмрд▓реНрд╕ рдХреЛ рд╕реНрдЯреЛрд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЙрдкрдпреЛрдЧ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИред </font><font style="vertical-align: inherit;">рдРрд╕рд╛ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП, рдмрд╕ рдореИрдХреНрд░реЛрдЬрд╝ </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBUFFER_START</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдФрд░ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBUFFER_END рдХреЛ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдХреЙрд▓ рдХрд░реЗрдВ </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; CBUFFER_END</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╡реИрд╢реНрд╡рд┐рдХ рдЪрд░ рдпрд╛ рд╡рд┐рднрд┐рдиреНрди рдкреИрд░рд╛рдореАрдЯреНрд░рд┐рдХ рд╕реЗрдЯ рдЕрдк (рдХреЛрдб рдпрд╛ рдПрдиреАрдореЗрд╢рди рд╕реЗ, рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП) рдХреА рдШреЛрд╖рдгрд╛ рдкреБрд░рд╛рдиреЗ рдврдВрдЧ рд╕реЗ рдПрдХ shader рдХрд╛рд░реНрдпрдХреНрд░рдо рдХреЗ рд╢рд░реАрд░ рдХреЗ рдЕрдВрджрд░ рдЬрдЧрд╣ рд▓реЗрддрд╛ рд╣реИред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LWRP рджреЛ рдкреНрд░рдХрд╛рд░ рдХреЗ рдирд┐рд░рдВрддрд░ рдмрдлрд╝рд░реНрд╕ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рддрд╛ рд╣реИ - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityPerObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдФрд░ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityPerMaterial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ред рдЗрди рдмрдлрд╝рд░реНрд╕ рдХреЛ рдПрдХ рдмрд╛рд░ рдмрд╛рдБрдз рджрд┐рдпрд╛ рдЬрд╛рддрд╛ рд╣реИ рддрд╛рдХрд┐ рдЗрдиреНрд╣реЗрдВ рд░реЗрдВрдбрд░рд┐рдВрдЧ рдХреЗ рджреМрд░рд╛рди рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХреЗред рдореЛрдЯреЗ рддреМрд░ рдкрд░, рдЗрд╕рдХрд╛ рдорддрд▓рдм рд╣реИ рдХрд┐ рдбреНрд░рд╛рдЗрдВрдЧ рдХреЗ рджреМрд░рд╛рди, рдирд┐рд░рдВрддрд░ рдмрдлрд╝рд░реНрд╕ рдХреЛ рдлрд┐рд░ рд╕реЗ рдкреНрд░рдмрд▓рд┐рдд рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛ рдпрд╛ рд╕рд╛рдордЧреНрд░реА рдХреЗ рд▓рд┐рдП рд╕реЗрдЯрдкрд╛рд╕ рдХреЛ рдирд╣реАрдВ рдмреБрд▓рд╛рдпрд╛ рдЬрд╛рдПрдЧрд╛ред рдпрд╣ рдлрд╛рдпрджреЗрдордВрдж рд╣реИ рдЬрдм рдХрдИ рд╢реЗрдбреНрд╕ рдПрдХ рд╣реА рдирд┐рд░рдВрддрд░ рдмрдлрд░ рд╕рд╛рдЭрд╛ рдХрд░рддреЗ рд╣реИрдВ, рдХреНрдпреЛрдВрдХрд┐ LWRP рдЗрд╕рдХреЗ рд▓рд┐рдП рд╡рд┐рднрд┐рдиреНрди рд╕рд╛рдордЧреНрд░рд┐рдпреЛрдВ рдХреЛ рдкреИрдХреЗрдЬ рдХрд░ рд╕рдХрддрд╛ рд╣реИред</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╡рд╛рд╕реНрддрд╡ рдореЗрдВ, рдпрджрд┐ рдЖрдк рдзреНрдпрд╛рди рд╕реЗ рд╢реИрдбрд░ рдХреА рд╕рдВрд░рдЪрдирд╛ рдХрд╛ рдЕрдзреНрдпрдпрди рдХрд░рддреЗ рд╣реИрдВ, рддреЛ рдЖрдк рдкрд╛ рд╕рдХрддреЗ рд╣реИрдВ рдХрд┐ рдЬреНрдпрд╛рджрд╛рддрд░ рдорд╛рдирдХ рдбреЗрдЯрд╛ рд╣рд░ рдЬрдЧрд╣ рдирд┐рд░рдВрддрд░ рдмрдлрд░ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рддрд╛ рд╣реИред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЕрдзрд┐рдХ рд╡рд┐рд╕реНрддрд╛рд░ рд╕реЗ, рд╕рднреА рдорддрднреЗрджреЛрдВ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ, рд▓реЗрдХрд┐рди рдЕрдВрдЧреНрд░реЗрдЬреА рдореЗрдВ, рдЖрдк </font></font><a href="https://github.com/johnsietsma/ExtendingLWRP/wiki/LWRPShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдпрд╣рд╛рдВ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдкрдврд╝ рд╕рдХрддреЗ рд╣реИрдВ </font><font style="vertical-align: inherit;">ред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╡реИрд╕реЗ, рдЕрдЧрд░ рдЖрдк рд╕рд░рдлреЗрд╕рдбрд╛рдЯрд╛ рдХреЛ рдХрд░реАрдм рд╕реЗ рджреЗрдЦрддреЗ рд╣реИрдВ:</font></font><br><pre> <code class="cpp hljs">SurfaceData surfaceData;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЖрдк рдкрд╛ рд╕рдХрддреЗ рд╣реИрдВ рдХрд┐ рдпрд╣ </font><b><font style="vertical-align: inherit;">ShaderGraph</font></b><font style="vertical-align: inherit;"> рд╕реЗ </font><font style="vertical-align: inherit;">рдкреЛрд╖рд┐рдд </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PBR рдорд╛рд╕реНрдЯрд░</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╣реИ </font><font style="vertical-align: inherit;">ред</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><h4>  рдЙрджрд╛рд╣рд░рдг </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рддреЛ, рдЕрдм рд╣рдорд╛рд░реЗ рд╣рд╛рде рдкреВрд░реА рддрд░рд╣ рд╕реЗ рдЕрдЫреВрддреЗ рд╣реИрдВ, рдЬрд┐рд╕рдХрд╛ рдорддрд▓рдм рд╣реИ рдХрд┐ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдПрдХ рдмреИрдЪреЗрдирд▓ рдХреА рд╡реНрдпрд╡рд╕реНрдерд╛ рдХрд░рдиреЗ </font><font style="vertical-align: inherit;">рдХрд╛ рд╕рдордп рдЖ </font><font style="vertical-align: inherit;">рдЧрдпрд╛ рд╣реИ! </font><font style="vertical-align: inherit;">рдЖрдЗрдП </font><font style="vertical-align: inherit;">рдПрдХ </font><font style="vertical-align: inherit;">рдЙрджрд╛рд╣рд░рдг рдХреЗ </font><font style="vertical-align: inherit;">рд░реВрдк рдореЗрдВ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╡рд░реНрдЯреЗрдХреНрд╕ рд╡рд┐рд╕реНрдерд╛рдкрди</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдФрд░ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рднрдВрдЧ рдкреНрд░рднрд╛рд╡</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдЬреЛрдбрд╝реЗрдВ </font><font style="vertical-align: inherit;">, рдФрд░ рдмрд╛рдХреА рдиреГрддреНрдп рдХрд░реЗрдВред </font><font style="vertical-align: inherit;">рдпрд╣ рдмрд╣реБрдд рд╕реБрд╡рд┐рдзрд╛рдЬрдирдХ рд╣реИ рдХрд┐ рд╕рднреА рдкрд╛рд╕ рд╣рдорд╛рд░реА рдЖрдВрдЦреЛрдВ рдХреЗ рд╕рд╛рдордиреЗ рд╣реИрдВ рдФрд░ рд╣рдо рд╕рдм рдХреБрдЫ рдмрдбрд╝реЗ рдкреИрдорд╛рдиреЗ рдкрд░ рд╕рдВрдкрд╛рджрд┐рдд рдХрд░ рд╕рдХрддреЗ рд╣реИрдВред </font><font style="vertical-align: inherit;">рдЧреБрдгреЛрдВ рдХрд╛ рд╡рд░реНрдгрди рдХрд░рддреЗ рд╣реИрдВ:</font></font><br><br> <a href="https://gifyu.com/image/q2wn" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/01d/ed6/8dd01ded67bfb91cc0e7e4f505276524.gif" alt="LVRP_TextShaders_2020-01-20_21-08-42.gif"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">Properties { ... _DissolveMap(<span class="hljs-string"><span class="hljs-string">"Dissolve Map"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _DissolveFactor(<span class="hljs-string"><span class="hljs-string">"Dissolve Factor"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> _DissolveWidth(<span class="hljs-string"><span class="hljs-string">"Dissolve Width"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [HDR]_DissolveColor(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЬреЛ рдирд┐рд╕реНрд╕рдВрджреЗрд╣ рдирд┐рд░реАрдХреНрд╖рдХ рдореЗрдВ рд╣рдорд╛рд░реЗ рдЕрдкрдиреЗ рдФрд░ рдкреНрд░рд┐рдп рдЯреИрдм рдореЗрдВ рджрд┐рдЦрд╛рдИ рджреЗрдЧрд╛: </font><font style="vertical-align: inherit;">рдЪрд░ рдЬреЛрдбрд╝реЗрдВ:</font></font><br> <a href="https://gifyu.com/image/q23C" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/b11/b16/3eab11b16256aa0099e07e6172ba9557.png" alt="2020-01-20_22-55-14.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">CBUFFER_START(UnityPerMaterial) ... float4 _DissolveMap_ST; <span class="hljs-comment"><span class="hljs-comment">//    _DissolveMap CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╕рдмрд╕реЗ рдкрд╣рд▓реЗ, рд╢рд░рд╛рдмреА рд╢рд░рд╛рдмреА рдХреЛ рдЬреНрдпрд╛рдорд┐рддрд┐ рднреЗрдЬреЗрдВ: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LitPassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.positionOS.xyz += normalize(input.positionOS.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.positionOS.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдлрд┐рд░ рдЫрд╛рдпрд╛: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowPassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.positionOS.xyz += normalize(input.positionOS.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.positionOS.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдЧрд╣рд░рд╛рдИ: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DepthOnlyVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.position.xyz += normalize(input.position.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.position.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдЦреИрд░, рдЕрдм рд╕рдордп рдФрд░ рдЖрдВрджреЛрд▓рди рднрдВрдЧ: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LitPassFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Varyings input)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// UV   input.uv += _Time.x * 10; //     Dissolve  float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; //  bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; //    surfaceData.emission *= outline * _DissolveColor; //,    PBR-  half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); //      color *= lerp(1, _DissolveColor, outline); ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЖрдк рдЫрд╛рдпрд╛ рдореЗрдВ рднреА рднрдВрдЧ рдХреЛ рд▓рд╛ рд╕рдХрддреЗ рд╣реИрдВ, рдлрд┐рд░ рдХрд▓рд╛рдИ рдХреА рдПрдХ рдЭрд┐рд▓рдорд┐рд▓рд╛рд╣рдЯ рдХреЗ рд╕рд╛рде рд╣рдорд╛рд░реЗ рдкрд╛рд╕ рд╕рд╣реА рдЫрд╛рдпрд╛ рд╣реЛрдЧреА, рдЬреЛ рдХрд┐ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╢реЗрдбрд░ рдЧреНрд░рд╛рдл</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдореЗрдВ рдкреНрд░рд╛рдкреНрдд </font><font style="vertical-align: inherit;">рдХрд░рдирд╛ рдХрд╛рдлреА рдХрдард┐рди </font><font style="vertical-align: inherit;">рд╣реИ </font><font style="vertical-align: inherit;">, рдФрд░ рдпрд╣рд╛рдВ рдХреЛрдб рдХреА рдХреБрдЫ рдкрдВрдХреНрддрд┐рдпрд╛рдВ рд╣реИрдВред</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowPassFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Varyings input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ ... float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask.r &gt; _DissolveFactor) discard; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рдЦреИрд░, рдЕрдВрддрд┐рдо shader рдХреЛрдб: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SimpleDissolve</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/LWRP/Dissolve + Vertex Offset"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor][HideInInspector] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture][HideInInspector] _BaseMap("Albedo", 2D) = "white" {} [HideInInspector]_Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 [HideInInspector]_Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 [HideInInspector]_GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 [HideInInspector]_SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma][HideInInspector] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 [HideInInspector]_MetallicGlossMap("Metallic", 2D) = "white" {} [HideInInspector]_SpecColor("Specular", Color) = (0.2, 0.2, 0.2) [HideInInspector]_SpecGlossMap("Specular", 2D) = "white" {} [HideInInspector][ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [HideInInspector][ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 [HideInInspector]_BumpScale("Scale", Float) = 1.0 [HideInInspector]_BumpMap("Normal Map", 2D) = "bump" {} [HideInInspector]_OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 [HideInInspector]_OcclusionMap("Occlusion", 2D) = "white" {} [HDR][HideInInspector]_EmissionColor("Color", Color) = (0,0,0) [HideInInspector]_EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 [HideInInspector]_ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 // _DissolveMap("Dissolve Map", 2D) = "white" {} _DissolveFactor("Dissolve Factor", Range(0, 1)) = 0.0 _DissolveWidth("Dissolve Width", Range(0, 1)) = 0.0 [HDR]_DissolveColor("Color", Color) = (1,1,0) } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/SurfaceInput.hlsl" #ifdef _SPECULAR_SETUP #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_SpecGlossMap, sampler_SpecGlossMap, uv) #else #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, uv) #endif struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; float2 lightmapUV : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 1); #ifdef _ADDITIONAL_LIGHTS float3 positionWS : TEXCOORD2; #endif #ifdef _NORMALMAP half4 normalWS : TEXCOORD3; // xyz: normal, w: viewDir.x half4 tangentWS : TEXCOORD4; // xyz: tangent, w: viewDir.y half4 bitangentWS : TEXCOORD5; // xyz: bitangent, w: viewDir.z #else half3 normalWS : TEXCOORD3; half3 viewDirWS : TEXCOORD4; #endif half4 fogFactorAndVertexLight : TEXCOORD6; // x: fogFactor, yzw: vertex light #ifdef _MAIN_LIGHT_SHADOWS float4 shadowCoord : TEXCOORD7; #endif float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO float3 uvDissolve : TEXCOORD8; }; CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; float4 _DissolveMap_ST; //    _DissolveMap CBUFFER_END TEXTURE2D(_OcclusionMap); SAMPLER(sampler_OcclusionMap); TEXTURE2D(_MetallicGlossMap); SAMPLER(sampler_MetallicGlossMap); TEXTURE2D(_SpecGlossMap); SAMPLER(sampler_SpecGlossMap); TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor; half4 SampleMetallicSpecGloss(float2 uv, half albedoAlpha) { half4 specGloss; #ifdef _METALLICSPECGLOSSMAP specGloss = SAMPLE_METALLICSPECULAR(uv); #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a *= _Smoothness; #endif #else // _METALLICSPECGLOSSMAP #if _SPECULAR_SETUP specGloss.rgb = _SpecColor.rgb; #else specGloss.rgb = _Metallic.rrr; #endif #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a = _Smoothness; #endif #endif return specGloss; } half SampleOcclusion(float2 uv) { #ifdef _OCCLUSIONMAP // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Controls things like these by exposing SHADER_QUALITY levels (low, medium, high) #if defined(SHADER_API_GLES) return SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; #else half occ = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; return LerpWhiteTo(occ, _OcclusionStrength); #endif #else return 1.0; #endif } inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData) { half4 albedoAlpha = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); // half4 albedoAlpha = SampleAlbedoAlpha(uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)); outSurfaceData.alpha = Alpha(albedoAlpha.a, _BaseColor, _Cutoff); half4 specGloss = SampleMetallicSpecGloss(uv, albedoAlpha.a); outSurfaceData.albedo = albedoAlpha.rgb * _BaseColor.rgb; #if _SPECULAR_SETUP outSurfaceData.metallic = 1.0h; outSurfaceData.specular = specGloss.rgb; #else outSurfaceData.metallic = specGloss.r; outSurfaceData.specular = half3(0.0h, 0.0h, 0.0h); #endif outSurfaceData.smoothness = specGloss.a; outSurfaceData.normalTS = SampleNormal(uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap), _BumpScale); outSurfaceData.occlusion = SampleOcclusion(uv); outSurfaceData.emission = SampleEmission(uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap)); // outSurfaceData.emission = _EmissionColor.rgb * SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, uv); } void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData) { inputData = (InputData)0; #ifdef _ADDITIONAL_LIGHTS inputData.positionWS = input.positionWS; #endif #ifdef _NORMALMAP half3 viewDirWS = half3(input.normalWS.w, input.tangentWS.w, input.bitangentWS.w); inputData.normalWS = TransformTangentToWorld(normalTS, half3x3(input.tangentWS.xyz, input.bitangentWS.xyz, input.normalWS.xyz)); #else half3 viewDirWS = input.viewDirWS; inputData.normalWS = input.normalWS; #endif inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS); viewDirWS = SafeNormalize(viewDirWS); inputData.viewDirectionWS = viewDirWS; #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) inputData.shadowCoord = input.shadowCoord; #else inputData.shadowCoord = float4(0, 0, 0, 0); #endif inputData.fogCoord = input.fogFactorAndVertexLight.x; inputData.vertexLighting = input.fogFactorAndVertexLight.yzw; inputData.bakedGI = SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS); } /////////////////////////////////////////////////////////////////////////////// // Vertex and Fragment functions // /////////////////////////////////////////////////////////////////////////////// //Standard (Physically Based) shader Varyings LitPassVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.positionOS.xyz += sin(input.positionOS.x) * sin(_Time.x * 100); VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS); half3 viewDirWS = GetCameraPositionWS() - vertexInput.positionWS; half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS); half fogFactor = ComputeFogFactor(vertexInput.positionCS.z); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); #ifdef _NORMALMAP output.normalWS = half4(normalInput.normalWS, viewDirWS.x); output.tangentWS = half4(normalInput.tangentWS, viewDirWS.y); output.bitangentWS = half4(normalInput.bitangentWS, viewDirWS.z); #else output.normalWS = NormalizeNormalPerVertex(normalInput.normalWS); output.viewDirWS = viewDirWS; #endif OUTPUT_LIGHTMAP_UV(input.lightmapUV, unity_LightmapST, output.lightmapUV); OUTPUT_SH(output.normalWS.xyz, output.vertexSH); output.fogFactorAndVertexLight = half4(fogFactor, vertexLight); #ifdef _ADDITIONAL_LIGHTS output.positionWS = vertexInput.positionWS; #endif #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) output.shadowCoord = GetShadowCoord(vertexInput); #endif output.positionCS = vertexInput.positionCS; return output; } // Used in Standard (Physically Based) shader half4 LitPassFragment(Varyings input) : SV_Target { input.uv += _Time.x * 10; UNITY_SETUP_INSTANCE_ID(input); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); InputData inputData; InitializeInputData(input, surfaceData.normalTS, inputData); float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; surfaceData.emission *= outline * _DissolveColor; half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); color *= lerp(1, _DissolveColor, outline); color.rgb = MixFog(color.rgb, inputData.fogCoord); return color; } ENDHLSL } // Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl" float3 _LightDirection; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; CBUFFER_START(UnityPerMaterial) float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float4 GetShadowPositionHClip(Attributes input) { float3 positionWS = TransformObjectToWorld(input.positionOS.xyz); float3 normalWS = TransformObjectToWorldNormal(input.normalOS); float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection)); #if UNITY_REVERSED_Z positionCS.z = min(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #else positionCS.z = max(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #endif return positionCS; } Varyings ShadowPassVertex(Attributes input) { Varyings output; input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); UNITY_SETUP_INSTANCE_ID(input); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = GetShadowPositionHClip(input); return output; } half4 ShadowPassFragment(Varyings input) : SV_TARGET { float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #ifndef LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED #define LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED struct Attributes { float4 position : POSITION; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; Varyings DepthOnlyVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.position.xyz += normalize(input.position.xyz) * sin(input.position.x) * sin(_Time.x * 100); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = TransformObjectToHClip(input.position.xyz); return output; } half4 DepthOnlyFragment(Varyings input) : SV_TARGET { UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } #endif ENDHLSL } // Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl" #ifndef LIGHTWEIGHT_LIT_META_PASS_INCLUDED #define LIGHTWEIGHT_LIT_META_PASS_INCLUDED Varyings LightweightVertexMeta(Attributes input) { Varyings output; output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST); output.uv = TRANSFORM_TEX(input.uv0, _BaseMap); return output; } half4 LightweightFragmentMeta(Varyings input) : SV_Target { SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); BRDFData brdfData; InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData); MetaInput metaInput; metaInput.Albedo = brdfData.diffuse + brdfData.specular * brdfData.roughness * 0.5; metaInput.SpecularColor = surfaceData.specular; metaInput.Emission = surfaceData.emission; return MetaFragment(metaInput); } #endif ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor" }</span></span></code> </pre></div></div><br><h4>  рдирд┐рд╖реНрдХрд░реНрд╖ </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЦреИрд░, рдпрд╣рд╛рдБ рдпрд╣ рд╕реНрдЯреЙрдХ рд▓реЗрдиреЗ рдХрд╛ рд╕рдордп рд╣реИред </font><font style="vertical-align: inherit;">рдЬреИрд╕рд╛ рдХрд┐ рдпрд╣ рд╕реНрдкрд╖реНрдЯ рд╣реЛ рдЧрдпрд╛ рд╣реИ, LWRP рдореЗрдВ рдХреЛрдб рдХреЗ рд╕рд╛рде рд╢реЗрдб рд▓рд┐рдЦрдирд╛ рд╕рдВрднрд╡ рдФрд░ рдпрд╣рд╛рдВ рддрдХ тАЛтАЛрдХрд┐ рдЖрд╡рд╢реНрдпрдХ рд╣реИ, рдХреНрдпреЛрдВрдХрд┐ рдпрд╣ рдЖрдкрдХреЗ рд╣рд╛рдереЛрдВ рдХреЛ рдмрд╣реБрдд рдореБрдХреНрдд рдХрд░рддрд╛ рд╣реИ, рдмреИрд╕рд╛рдЦреА рдХреЗ рдмрд┐рдирд╛ рд╢рд╛рдВрдд рдЪреАрдЬреЛрдВ рдХреЛ рд▓рд┐рдЦрдиреЗ рдореЗрдВ рдорджрдж рдХрд░рддрд╛ рд╣реИ, рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдЖрдкрдХрд╛ рдкреНрд░рдХрд╛рд╢ рд╡реНрдпрд╡рд╕реНрдерд╛ред </font><font style="vertical-align: inherit;">рдмреЗрд╢рдХ, рдпрд╣ рд╕реБрд╡рд┐рдзрд╛рдЬрдирдХ рдФрд░ рдкрд░рд┐рдЪрд┐рдд </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд╕реНрдЯреИрдВрдбрд░реНрдб рд╕рд░рдлреЗрд╕ рд╢реЗрдбрд░ рдХреЗ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> рд╕рд╛рде рддреБрд▓рдирд╛ рдирд╣реАрдВ рдХреА рдЬрд╛ рд╕рдХрддреА рд╣реИ </font><font style="vertical-align: inherit;">, рд▓реЗрдХрд┐рди рд╢рд╛рдпрдж рдХрд┐рд╕реА рджрд┐рди рдореБрдЭреЗ рдПрд▓рдбрдмреНрд▓реНрдпреВрдЖрд░рдкреА рдФрд░ рдПрдЪрдбреАрдЖрд░рдкреА рдХреЗ рд▓рд┐рдП рдПрдХ рд╣реА рд╕реБрд╡рд┐рдзрд╛рдЬрдирдХ рдПрдирд╛рд▓реЙрдЧ рд▓рд┐рдЦрдиреЗ рдХреЗ рд▓рд┐рдП рд╣рд╛рде рдорд┐рд▓реЗрдВрдЧреЗ, рд▓реЗрдХрд┐рди рдХреБрдЫ рдФрд░ рд╕рдордп рдХреЗ рдмрд╛рд░реЗ рдореЗрдВред </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рдЙрдкрдпреЛрдЧреА рд▓рд┐рдВрдХ: </font></font><br><br> <a href="https://github.com/TheProxor/LWRP_TextShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рд▓реЗрдЦ рдХреА рд╕рднреА рд╕рд╛рдордЧреНрд░рд┐рдпреЛрдВ рдХреЗ рд╕рд╛рде рднрдВрдбрд╛рд░ рд╕рд╛рдордЧреНрд░реА рдХреА </font></font></a> <br> <a href="https://github.com/johnsietsma/ExtendingLWRP/wiki/LWRPShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">рддреИрдпрд╛рд░реА рдХреЗ рджреМрд░рд╛рди рдпрд╣ рдкрд╛рдпрд╛ рдЧрдпрд╛, рдЕрдиреМрдкрдЪрд╛рд░рд┐рдХ рдкреНрд░рд▓реЗрдЦрди </font></font></a> <br> <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.lightweight%406.9/api/UnityEngine.Experimental.Rendering.LWRP.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LWRP рдкреНрд░рд▓реЗрдЦрди</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/hi485018/">https://habr.com/ru/post/hi485018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi485008/index.html">рд╕рдВрдкрддреНрддрд┐ рдХреЗ рд░реИрдкрд░реЛрдВ рдХреЛ рд╕реНрд╡рд┐рдлреНрдЯ рдХрд░реЗрдВ</a></li>
<li><a href="../hi485010/index.html">рд░реЛ рдордд, рд▓рдбрд╝рдХреА! Habr├й рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдкрддреНрд░ рдкрд░ vc.ru рдХреЗ рд╕рд╛рде рд▓реЗрдЦрдХ рдХреЛ рдЙрддреНрддрд░ рджреЗрдВ</a></li>
<li><a href="../hi485012/index.html">рдХреЛрдб рд╣реИрдВрдбрд▓рд┐рдВрдЧ рдХреЛ рд╕рд░рд▓ рдмрдирд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдЬрд╛рд╡рд╛рд╕реНрдХреНрд░рд┐рдкреНрдЯ рдФрд░ рд░рд┐рдПрдХреНрдЯрдЬ рдореЗрдВ рдХрдВрдЯреНрд░реЛрд▓ рдЗрдирд╡рд░реНрд╕рди рдХрд╛ рдЙрдкрдпреЛрдЧ рдХреИрд╕реЗ рдХрд░реЗрдВ</a></li>
<li><a href="../hi485014/index.html">рдХреНрдпрд╛ рдореБрдЭреЗ рд╕рд╛рдХреНрд╖рд╛рддреНрдХрд╛рд░ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рд╢рд┐рдХрд╛рдпрдд рдХрд░рдиреА рдЪрд╛рд╣рд┐рдП?</a></li>
<li><a href="../hi485016/index.html">рдЪрдпрдирд┐рдд рдбреЗрдЯрд╛рдмреЗрд╕ рдореЗрдВ рдкреНрд░рдмрдВрдзрд┐рдд рдбреЗрдЯрд╛рдмреЗрд╕: рдмреАрдЯрд╛ рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ</a></li>
<li><a href="../hi485022/index.html">Playme рд╕рд┐рдЧреНрдорд╛: рдХрд╛рд░реНрдпрд╛рддреНрдордХ рдФрд░ рд╕рд╕реНрддреА DVR</a></li>
<li><a href="../hi485024/index.html">GraalVM рд╕рдВрдХрд▓рдХ рдЕрдиреБрдХреВрд▓рди рдХреЗ рд╣реБрдб рдХреЗ рдиреАрдЪреЗ рдХреНрдпрд╛ рд╣реИ?</a></li>
<li><a href="../hi485026/index.html">рдЖрдИрдЯреА рдкреЗрд╢реЗрд╡рд░реЛрдВ рдХреЗ рд▓рд┐рдП рдЬреЙрд░реНрдЬрд┐рдпрд╛ рдХреЗ рдЕрд╡рд╕рд░</a></li>
<li><a href="../hi485028/index.html">рд╕реАрдЖрд░рдПрдо 2020</a></li>
<li><a href="../hi485030/index.html">рд╢реАрд░реНрд╖ 8 IEO рд╢реБрд▓реНрдХ рдФрд░ рдЕрдм рдЙрдирдХрд╛ рдкреВрдВрдЬреАрдХрд░рдг</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>