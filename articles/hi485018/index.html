<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìµ üéì ü¶Ä ‡§Ø‡•Ç‡§®‡§ø‡§ü‡•Ä LWRP ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∂‡•á‡§°‡§∞‡•ç‡§∏ ‡§≤‡§ø‡§ñ‡§®‡§æ ‚õπÔ∏è ü•ï üèòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‡§™‡§∞‡§ø‡§ö‡§Ø 
 ‡§π‡•á‡§≤‡•ã, ‡§π‡•à‡§¨‡§∞‡•§ ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§•‡•ã‡§°‡§º‡•Ä ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡§æ ‡§π‡•Ç‡§Ç ‡§ï‡§ø ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§î‡§∞ ‡§¶‡§∞‡•ç‡§¶ ‡§∞‡§π‡§ø‡§§ (‡§≤‡§ó‡§≠‡§ó) ‡§≤‡§æ‡§á‡§ü‡§µ‡•á‡§ü ‡§∞‡•á‡§Ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§® (LWRP) ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§è‡§ï‡§§‡§æ ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§≤‡§æ‡§∏...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>‡§Ø‡•Ç‡§®‡§ø‡§ü‡•Ä LWRP ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∂‡•á‡§°‡§∞‡•ç‡§∏ ‡§≤‡§ø‡§ñ‡§®‡§æ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485018/"><h2>  ‡§™‡§∞‡§ø‡§ö‡§Ø </h2><br>  ‡§π‡•á‡§≤‡•ã, ‡§π‡•à‡§¨‡§∞‡•§  ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§•‡•ã‡§°‡§º‡•Ä ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡§æ ‡§π‡•Ç‡§Ç ‡§ï‡§ø ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§î‡§∞ ‡§¶‡§∞‡•ç‡§¶ ‡§∞‡§π‡§ø‡§§ (‡§≤‡§ó‡§≠‡§ó) <b>‡§≤‡§æ‡§á‡§ü‡§µ‡•á‡§ü ‡§∞‡•á‡§Ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§® (LWRP)</b> ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§ï‡•á ‡§è‡§ï‡§§‡§æ ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§≤‡§æ‡§∏‡§ø‡§ï <b>‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü</b> <b>‡§∂‡•á‡§°‡•ç‡§∏</b> ‡§≤‡§ø‡§ñ‡§®‡§æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç - <b>‡§∏‡•ç‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§ü‡§ø‡§Ç‡§ó ‡§∞‡•á‡§Ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§® (SRP)</b> ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§® ‡§ï‡•á ‡§â‡§¶‡§æ‡§π‡§∞‡§£‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡•á ‡§è‡§ï‡•§ <br><br><h4>  ‡§≤‡•á‡§ï‡§ø‡§® Shader ‡§ó‡•ç‡§∞‡§æ‡§´ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ? </h4><br>  <b>Shader Graph</b> ‡§™‡•ç‡§∞‡•ã‡§ü‡•ã‡§ü‡§æ‡§á‡§™ ‡§Ø‡§æ ‡§∏‡§∞‡§≤ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§≤‡§ø‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ‡§ú‡§®‡§ï ‡§î‡§∞ ‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§â‡§™‡§ï‡§∞‡§£ ‡§π‡•à‡•§  ‡§π‡§æ‡§≤‡§æ‡§Ç‡§ï‡§ø, ‡§ï‡§≠‡•Ä-‡§ï‡§≠‡•Ä, ‡§ï‡•Å‡§õ ‡§ú‡§ü‡§ø‡§≤ ‡§î‡§∞ ‡§ú‡§ü‡§ø‡§≤ ‡§≤‡§ø‡§ñ‡§®‡§æ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§π‡•à, ‡§î‡§∞ ‡§´‡§ø‡§∞ - ‡§®‡•ã‡§°‡•ç‡§∏, ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§®, ‡§â‡§™-‡§ó‡•ç‡§∞‡§æ‡§´‡§º ‡§ï‡•Ä ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§Ö‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§¨‡§¢‡§º ‡§∞‡§π‡•Ä ‡§π‡•à, ‡§Ø‡§π‡•Ä ‡§µ‡§ú‡§π ‡§π‡•à ‡§ï‡§ø ‡§Ø‡§π‡§æ‡§Ç ‡§§‡§ï ‚Äã‚Äã‡§ï‡§ø ‡§∏‡§¨‡§∏‡•á ‡§Ö‡§®‡•Å‡§≠‡§µ‡•Ä ‡§ó‡•ç‡§∞‡§æ‡§´‡§ø‡§ï‡•ç‡§∏ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ‡§∞ ‡§≠‡•Ä ‡§á‡§∏ ‡§™‡•Ç‡§∞‡•á ‡§ó‡§°‡§º‡§¨‡§°‡§º ‡§Æ‡•á‡§Ç ‡§≠‡•ç‡§∞‡§Æ‡§ø‡§§ ‡§π‡•ã‡§®‡•á ‡§≤‡§ó‡§§‡•á ‡§π‡•à‡§Ç‡•§  ‡§π‡§Æ ‡§∏‡§≠‡•Ä ‡§∏‡§Æ‡§ù‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§ï‡•ã‡§° ‡§è‡§ï ‡§™‡•ç‡§∞‡§æ‡§•‡§Æ‡§ø‡§ï‡§§‡§æ ‡§Æ‡•à‡§®‡•ç‡§Ø‡•Å‡§Ö‡§≤ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§≤‡§ø‡§ñ‡•á ‡§ú‡§æ‡§®‡•á ‡§∏‡•á ‡§¨‡•á‡§π‡§§‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à - ‡§Ü‡§™‡§ï‡•ã ‡§â‡§¶‡§æ‡§π‡§∞‡§£‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§π‡•Å‡§§ ‡§¶‡•Ç‡§∞ ‡§ú‡§æ‡§®‡•á ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§®‡•ã‡§°‡•ç‡§∏ ‡§ï‡•á ‡§≤‡•á‡§Ü‡§â‡§ü ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§á‡§∏ ‡§§‡§•‡•ç‡§Ø ‡§ï‡•ã ‡§ú‡§®‡•ç‡§Æ ‡§¶‡•á ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à ‡§ï‡§ø ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ú‡•ç‡§û‡§æ‡§§ ‡§∂‡•Ä‡§∞‡•ç‡§∑ ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§∂‡§æ‡§∞‡•ç‡§ü‡•á‡§ï‡•ç‡§ü‡§∞ ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§∞-‡§¨‡§æ‡§∞ ‡§ñ‡§Ç‡§° ‡§Æ‡•á‡§Ç ‡§ó‡§ø‡§®‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ‡•§  ‡§ê‡§∏‡•á ‡§≤‡•ã‡§ó ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§®‡•ã‡§°‡•ç‡§∏ ‡§ï‡•á ‡§¨‡§ú‡§æ‡§Ø <b>‡§ï‡•ã‡§° ‡§ï‡•á</b> ‡§∏‡§æ‡§• ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Ö‡§ß‡§ø‡§ï ‡§∏‡§π‡§ú ‡§π‡•à‡§Ç‡•§  ‡§ï‡§æ‡§∞‡§£ ‡§Ö‡§≤‡§ó ‡§π‡•ã ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§≤‡•á‡§ï‡§ø‡§® ‡§∏‡§æ‡§∞ ‡§è‡§ï ‡§π‡•Ä ‡§π‡•à - ‡§®‡•ã‡§°‡•ç‡§∏ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§®‡•Ä‡§ö‡•á, ‡§≤‡§Ç‡§¨‡•á ‡§∏‡§Æ‡§Ø ‡§§‡§ï ‡§ï‡•ã‡§° ‡§∞‡§π‡§§‡•á ‡§π‡•à‡§Ç! <br><br> <a href="https://ibb.co/yBwCvZz" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/b24/96d/bc6/b2496dbc64e311b3f6e51a4edfc87078.png" alt="2020-01-19-17-07-35"></a> <br><a name="habracut"></a><br><h4>  ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ‡§ì‡§Ç </h4><br>  ‡§§‡•ã, LWRP ‡§ï‡•á ‡§§‡§π‡§§ ‡§è‡§ï ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§™‡§æ‡§† shader ‡§≤‡§ø‡§ñ‡§®‡•á ‡§î‡§∞ ‡§¨‡•à‡§†‡§®‡•á ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à?  ‡§î‡§∞ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ø‡§π ‡§π‡•à ‡§ï‡§ø LWRP ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§ï‡•á ‡§™‡§∏‡§Ç‡§¶‡•Ä‡§¶‡§æ <b>‡§∏‡•ç‡§ü‡•à‡§Ç‡§°‡§∞‡•ç‡§° ‡§∏‡§∞‡§´‡•á‡§∏</b> ‡§∂‡•á‡§°‡•ç‡§∏ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§ <br>  ‡§á‡§∏‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø, ‡§π‡§Æ‡•á‡§Ç ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§Æ‡§ø‡§≤‡§§‡•á ‡§π‡•à‡§Ç: <br><br> <a href="https://ibb.co/M8g31xz" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/f7a/a25/c7df7aa255f2fa81a2a95ef88ef249e2.png" alt="2020-01-19-17-16-16"></a> <br><br><div class="spoiler">  <b class="spoiler_title">‡§∂‡•á‡§°‡§∞ ‡§ï‡•ã‡§°</b> <div class="spoiler_text"><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Custom/NewSurfaceShader"</span></span> { Properties { _Color (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Glossiness (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">// Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D _MainTex; struct Input { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing_options assumeuniformscaling UNITY_INSTANCING_BUFFER_START(Props) // put more per-instance properties here UNITY_INSTANCING_BUFFER_END(Props) void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</span></span></code> </pre> <br></div></div><br>  ‡§´‡§ø‡§∞ ‡§¶‡§ø‡§Æ‡§æ‡§ó ‡§Æ‡•á‡§Ç ‡§Ø‡§π ‡§Ü‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§ê‡§≤‡§ø‡§ü ‡§∂‡•á‡§°‡§∞ ‡§ï‡•ã ‡§µ‡§∞‡•ç‡§ü‡•á‡§ï‡•ç‡§∏ ‡§î‡§∞ ‡§´‡•ç‡§∞‡•á‡§ó‡•ç‡§Æ‡•á‡§Ç‡§ü ‡§™‡§æ‡§∞‡•ç‡§ü ‡§ï‡•á ‡§∏‡§æ‡§• ‡§≤‡§ø‡§ñ‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§  ‡§î‡§∞ ‡§∏‡•å‡§≠‡§æ‡§ó‡•ç‡§Ø ‡§∏‡•á, ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à: <br><br> <a href="https://ibb.co/28bLgkd" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/8bf/559/bd1/8bf559bd19494ef9fd18364c2983b494.png" alt="2020-01-19-17-22-46"></a> <br><br><div class="spoiler">  <b class="spoiler_title">‡§∂‡•á‡§°‡§∞ ‡§ï‡•ã‡§°</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Unlit/NewUnlitShader"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag <span class="hljs-comment"><span class="hljs-comment">// make fog work #pragma multi_compile_fog #include "UnityCG.cginc" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) float4 vertex : SV_POSITION; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); // apply fog UNITY_APPLY_FOG(i.fogCoord, col); return col; } ENDCG } } }</span></span></code> </pre> <br></div></div><br>  ‡§π‡§æ‡§≤‡§æ‡§Ç‡§ï‡§ø, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§¶‡•Å‡§ñ‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç - ‡§π‡§Æ ‡§¨‡§ø‡§®‡§æ ‡§∞‡•ã‡§∂‡§®‡•Ä, ‡§õ‡§æ‡§Ø‡§æ, ‡§≤‡§æ‡§á‡§ü‡§Æ‡•à‡§™ ‡§î‡§∞ ‡§™‡•ç‡§Ø‡§æ‡§∞‡•á <b>‡§™‡•Ä‡§¨‡•Ä‡§Ü‡§∞ ‡§ï‡•á</b> ‡§¨‡§ø‡§®‡§æ ‡§ï‡§ø‡§®‡§æ‡§∞‡•á ‡§™‡§∞ ‡§®‡§ó‡•ç‡§® ‡§∞‡§π‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§≤‡§ó ‡§∞‡§π‡•á ‡§•‡•á, ‡§ú‡§ø‡§∏‡§ï‡•á ‡§¨‡§ø‡§®‡§æ ‡§ú‡•Ä‡§µ‡§® ‡§Æ‡•Ä‡§†‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§•‡§æ‡•§ <br>  ‡§¨‡•á‡§∂‡§ï, ‡§Ü‡§™ ‡§π‡§æ‡§• ‡§∏‡•á ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§≤‡§ø‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç: <br>  <i>‡§µ‡§π‡§æ‡§Å ‡§™‡•ç‡§∞‡§ï‡§æ‡§∂ ‡§π‡•ã!</i> <br><br> <a href="https://ibb.co/b7xn2DT" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/46f/3b4/dc7/46f3b4dc795e2ad51508942405c3854f.png" alt="2020-01-19-17-55-56"></a> <br><br><div class="spoiler">  <b class="spoiler_title">‡§∂‡•á‡§°‡§∞ ‡§ï‡•ã‡§°</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/Simple Lit"</span></span> { Properties { _MainTex(<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span> = <span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag <span class="hljs-comment"><span class="hljs-comment">// make fog work #pragma multi_compile_fog #include "UnityCG.cginc" #include "UnityLightingCommon.cginc" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal : NORMAL; }; struct v2f { float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) float4 vertex : SV_POSITION; fixed4 diffuse : COLOR0; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert(appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); half3 worldNormal = UnityObjectToWorldNormal(v.normal); half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz)); o.diffuse = nl * _LightColor0; return o; } fixed4 frag(v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); // apply fog UNITY_APPLY_FOG(i.fogCoord, col); col *= i.diffuse; return col; } ENDCG } } }</span></span></code> </pre> <br></div></div><br>  ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§≤‡§ó‡§§‡§æ ‡§π‡•à, ‡§≤‡•á‡§ï‡§ø‡§® ‡§Ø‡§π ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∂ ‡§´‡•à‡§≤‡§æ‡§®‡§æ ‡§π‡•à‡•§  ‡§Ü‡§ó‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§∞‡§®‡§æ ‡§π‡•à?  ‡§Ü‡§™ ‡§π‡§æ‡§• ‡§∏‡•á ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§®‡§æ ‡§ú‡§æ‡§∞‡•Ä ‡§∞‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§≤‡•á‡§ï‡§ø‡§® ‡§Ø‡§π ‡§≤‡§Ç‡§¨‡§æ ‡§î‡§∞ ‡§®‡•Ä‡§∞‡§∏ ‡§π‡•à, ‡§î‡§∞ ‡§™‡•Ä‡§¨‡•Ä‡§Ü‡§∞ ‡§ï‡•ã ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§µ‡§æ‡§™‡§∏ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à, ‡§î‡§∞ ‡§π‡§Æ ‡§∏‡§≠‡•Ä ‡§è‡§≤‡§°‡§¨‡•ç‡§≤‡•ç‡§Ø‡•Ç‡§Ü‡§∞‡§™‡•Ä ‡§ö‡§ø‡§™‡•ç‡§∏ ‡§ñ‡•ã ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç‡•§  ‡§á‡§∏‡§≤‡§ø‡§è, ‡§π‡§Æ‡§æ‡§∞‡•á ‡§™‡§æ‡§∏ ‡§è‡§ï ‡§ú‡§æ‡§¶‡•Ç ‡§ï‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡•ã‡§ï ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§≤‡§°‡§¨‡•ç‡§≤‡•ç‡§Ø‡•Ç‡§Ü‡§∞‡§™‡•Ä ‡§ï‡•ã ‡§ö‡•Å‡§®‡§®‡•á ‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ ‡§ï‡•ã‡§à ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ <br><br><h4>  ‡§®‡§ø‡§∞‡•ç‡§£‡§Ø </h4><br>  ‡§§‡•ã, ‡§ú‡•à‡§∏‡§æ ‡§ï‡§ø ‡§Ü‡§™ ‡§ú‡§æ‡§®‡§§‡•á ‡§π‡•à‡§Ç, LWRP <i>‡§´‡•â‡§∞‡§µ‡§∞‡•ç‡§°-‡§∞‡•á‡§Ç‡§°‡§∞‡§∞</i> ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§¨‡§®‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§ú‡§ø‡§∏‡§ï‡§æ ‡§Ö‡§∞‡•ç‡§• ‡§π‡•à ‡§ï‡§ø ‡§á‡§∏‡§ï‡§æ ‡§Ö‡§™‡§®‡§æ LitForwardPass ‡§π‡•à, ‡§ú‡§ø‡§∏‡•á ‡§ï‡§π‡•Ä‡§Ç ‡§® ‡§ï‡§π‡•Ä‡§Ç ‡§µ‡§∞‡•ç‡§£‡§ø‡§§ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§  ‡§ú‡§æ‡§π‡§ø‡§∞ ‡§π‡•à, ‡§ï‡§π‡•Ä‡§Ç ‡§® ‡§ï‡§π‡•Ä‡§Ç ‡§è‡§ï CGInclude ‡§π‡•à ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§Ø‡§π ‡§∏‡§¨ ‡§µ‡§∞‡•ç‡§£‡§ø‡§§ ‡§π‡•à‡•§  ‡§Ø‡§π ‡§µ‡§π ‡§ú‡§ó‡§π ‡§π‡•à ‡§ú‡§π‡§æ‡§Ç ‡§π‡§Æ ‡§è‡§ï ‡§Æ‡§ú‡•á‡§¶‡§æ‡§∞ ‡§∏‡§æ‡§π‡§∏‡§ø‡§ï ‡§™‡§∞ ‡§∏‡•á‡§ü ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç: <br><blockquote>  <i>% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render- ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§®-‡§≤‡§æ‡§á‡§ü‡§µ‡•á‡§ü @ (LWRP ‡§∏‡§Ç‡§∏‡•ç‡§ï‡§∞‡§£) \</i> </blockquote><br>  ‡§Ö‡§∏‡§≤ ‡§Æ‡•á‡§Ç, ‡§®‡§ø‡§∞‡•ç‡§¶‡§ø‡§∑‡•ç‡§ü ‡§™‡§§‡•á ‡§™‡§∞ ‡§Ü‡§®‡•á ‡§î‡§∞ <i>‡§∂‡•á‡§°‡§∞‡•ç‡§∏</i> ‡§´‡§º‡•ã‡§≤‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡•á ‡§∏‡•á, ‡§π‡§Æ ‡§è‡§ï ‡§¶‡§ø‡§≤‡§ö‡§∏‡•ç‡§™ shader ‡§™‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§∏‡•á <b>Lit.shader</b> ‡§ï‡§π‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§  ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ ‡§Æ‡•á‡§Ç, ‡§π‡§Æ ‡§ï‡§π ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§ñ‡•ã‡§ú ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§à ‡§π‡•à, ‡§Ø‡§π‡§æ‡§Ç ‡§Ø‡§π ‡§π‡•à - ‡§™‡•ç‡§∞‡§§‡§ø‡§∑‡•ç‡§†‡§ø‡§§ ‡§õ‡§æ‡§Ø‡§æ‡§¶‡§æ‡§∞‡•§  ‡§Ö‡§Ç‡§¶‡§∞ ‡§ú‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç - ‡§π‡§Æ ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§™‡§æ‡§§‡•á ‡§π‡•à‡§Ç: <br><br><div class="spoiler">  <b class="spoiler_title">Lit.shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Lightweight Render Pipeline/Lit"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture] _BaseMap("Albedo", 2D) = "white" {} _Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 _Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 _GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 _SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 _MetallicGlossMap("Metallic", 2D) = "white" {} _SpecColor("Specular", Color) = (0.2, 0.2, 0.2) _SpecGlossMap("Specular", 2D) = "white" {} [ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 _BumpScale("Scale", Float) = 1.0 _BumpMap("Normal Map", 2D) = "bump" {} _OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 _OcclusionMap("Occlusion", 2D) = "white" {} _EmissionColor("Color", Color) = (0,0,0) _EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 _ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "LitInput.hlsl" #include "LitForwardPass.hlsl" ENDHLSL } Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/ShadowCasterPass.hlsl" ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/DepthOnlyPass.hlsl" ENDHLSL } // This pass it not used during regular rendering, only for lightmap baking. Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitMetaPass.hlsl" ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShader" }</span></span></code> </pre><br></div></div><br><br>  ‡§Ø‡§π ‡§ï‡•á‡§µ‡§≤ ‡§∏‡§Ç‡§™‡§æ‡§¶‡§® ‡§Æ‡•á‡§Ç ‡§Ü‡§∏‡§æ‡§®‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§á‡§∏‡§ï‡§æ ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§®‡•Ä ‡§π‡•Å‡§à ‡§π‡•à, ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤-‡§è‡§∏ ‡§∏‡•á ‡§õ‡•Å‡§ü‡§ï‡§æ‡§∞‡§æ ‡§Æ‡§ø‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à‡•§  ‡§†‡•Ä‡§ï ‡§π‡•à, ‡§Ö‡§™‡§®‡•á ‡§§‡§∞‡•Ä‡§ï‡•á ‡§∏‡•á ‡§•‡•ã‡§°‡§º‡§æ ‡§∏‡§Ç‡§∂‡•ã‡§ß‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç‡•§ <br><br>  ‡§π‡§Æ‡•á‡§Ç ‡§ê‡§∏‡§æ ‡§ï‡•Å‡§õ ‡§Æ‡§ø‡§≤‡§§‡§æ ‡§π‡•à: <br><br> <a href="https://ibb.co/LpxG3cD" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/f1f/add/a94/f1fadda94d14fcd9cd518f99c7489ce8.png" alt="2020-01-19-18-28-13"></a> <br><br><div class="spoiler">  <b class="spoiler_title">‡§Ö‡§Ç‡§§‡§ø‡§Æ uber shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/LWRP/Dissolve + Vertex Offset"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor][HideInInspector] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture][HideInInspector] _BaseMap("Albedo", 2D) = "white" {} [HideInInspector]_Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 [HideInInspector]_Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 [HideInInspector]_GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 [HideInInspector]_SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma][HideInInspector] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 [HideInInspector]_MetallicGlossMap("Metallic", 2D) = "white" {} [HideInInspector]_SpecColor("Specular", Color) = (0.2, 0.2, 0.2) [HideInInspector]_SpecGlossMap("Specular", 2D) = "white" {} [HideInInspector][ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [HideInInspector][ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 [HideInInspector]_BumpScale("Scale", Float) = 1.0 [HideInInspector]_BumpMap("Normal Map", 2D) = "bump" {} [HideInInspector]_OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 [HideInInspector]_OcclusionMap("Occlusion", 2D) = "white" {} [HDR][HideInInspector]_EmissionColor("Color", Color) = (0,0,0) [HideInInspector]_EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 [HideInInspector]_ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 //    _DissolveMap("Dissolve Map", 2D) = "white" {} _DissolveFactor("Dissolve Factor", Range(0, 1)) = 0.0 _DissolveWidth("Dissolve Width", Range(0, 1)) = 0.0 [HDR]_DissolveColor("Color", Color) = (1,1,0) } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/SurfaceInput.hlsl" #ifdef _SPECULAR_SETUP #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_SpecGlossMap, sampler_SpecGlossMap, uv) #else #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, uv) #endif struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; float2 lightmapUV : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 1); #ifdef _ADDITIONAL_LIGHTS float3 positionWS : TEXCOORD2; #endif #ifdef _NORMALMAP half4 normalWS : TEXCOORD3; // xyz: normal, w: viewDir.x half4 tangentWS : TEXCOORD4; // xyz: tangent, w: viewDir.y half4 bitangentWS : TEXCOORD5; // xyz: bitangent, w: viewDir.z #else half3 normalWS : TEXCOORD3; half3 viewDirWS : TEXCOORD4; #endif half4 fogFactorAndVertexLight : TEXCOORD6; // x: fogFactor, yzw: vertex light #ifdef _MAIN_LIGHT_SHADOWS float4 shadowCoord : TEXCOORD7; #endif float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO float3 uvDissolve : TEXCOORD8; }; CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor; CBUFFER_END TEXTURE2D(_OcclusionMap); SAMPLER(sampler_OcclusionMap); TEXTURE2D(_MetallicGlossMap); SAMPLER(sampler_MetallicGlossMap); TEXTURE2D(_SpecGlossMap); SAMPLER(sampler_SpecGlossMap); TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); half4 SampleMetallicSpecGloss(float2 uv, half albedoAlpha) { half4 specGloss; #ifdef _METALLICSPECGLOSSMAP specGloss = SAMPLE_METALLICSPECULAR(uv); #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a *= _Smoothness; #endif #else // _METALLICSPECGLOSSMAP #if _SPECULAR_SETUP specGloss.rgb = _SpecColor.rgb; #else specGloss.rgb = _Metallic.rrr; #endif #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a = _Smoothness; #endif #endif return specGloss; } half SampleOcclusion(float2 uv) { #ifdef _OCCLUSIONMAP // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Controls things like these by exposing SHADER_QUALITY levels (low, medium, high) #if defined(SHADER_API_GLES) return SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; #else half occ = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; return LerpWhiteTo(occ, _OcclusionStrength); #endif #else return 1.0; #endif } inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData) { half4 albedoAlpha = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); // half4 albedoAlpha = SampleAlbedoAlpha(uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)); outSurfaceData.alpha = Alpha(albedoAlpha.a, _BaseColor, _Cutoff); half4 specGloss = SampleMetallicSpecGloss(uv, albedoAlpha.a); outSurfaceData.albedo = albedoAlpha.rgb * _BaseColor.rgb; #if _SPECULAR_SETUP outSurfaceData.metallic = 1.0h; outSurfaceData.specular = specGloss.rgb; #else outSurfaceData.metallic = specGloss.r; outSurfaceData.specular = half3(0.0h, 0.0h, 0.0h); #endif outSurfaceData.smoothness = specGloss.a; outSurfaceData.normalTS = SampleNormal(uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap), _BumpScale); outSurfaceData.occlusion = SampleOcclusion(uv); outSurfaceData.emission = SampleEmission(uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap)); // outSurfaceData.emission = _EmissionColor.rgb * SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, uv); } void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData) { inputData = (InputData)0; #ifdef _ADDITIONAL_LIGHTS inputData.positionWS = input.positionWS; #endif #ifdef _NORMALMAP half3 viewDirWS = half3(input.normalWS.w, input.tangentWS.w, input.bitangentWS.w); inputData.normalWS = TransformTangentToWorld(normalTS, half3x3(input.tangentWS.xyz, input.bitangentWS.xyz, input.normalWS.xyz)); #else half3 viewDirWS = input.viewDirWS; inputData.normalWS = input.normalWS; #endif inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS); viewDirWS = SafeNormalize(viewDirWS); inputData.viewDirectionWS = viewDirWS; #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) inputData.shadowCoord = input.shadowCoord; #else inputData.shadowCoord = float4(0, 0, 0, 0); #endif inputData.fogCoord = input.fogFactorAndVertexLight.x; inputData.vertexLighting = input.fogFactorAndVertexLight.yzw; inputData.bakedGI = SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS); } /////////////////////////////////////////////////////////////////////////////// // Vertex and Fragment functions // /////////////////////////////////////////////////////////////////////////////// //Standard (Physically Based) shader Varyings LitPassVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS); half3 viewDirWS = GetCameraPositionWS() - vertexInput.positionWS; half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS); half fogFactor = ComputeFogFactor(vertexInput.positionCS.z); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); #ifdef _NORMALMAP output.normalWS = half4(normalInput.normalWS, viewDirWS.x); output.tangentWS = half4(normalInput.tangentWS, viewDirWS.y); output.bitangentWS = half4(normalInput.bitangentWS, viewDirWS.z); #else output.normalWS = NormalizeNormalPerVertex(normalInput.normalWS); output.viewDirWS = viewDirWS; #endif OUTPUT_LIGHTMAP_UV(input.lightmapUV, unity_LightmapST, output.lightmapUV); OUTPUT_SH(output.normalWS.xyz, output.vertexSH); output.fogFactorAndVertexLight = half4(fogFactor, vertexLight); #ifdef _ADDITIONAL_LIGHTS output.positionWS = vertexInput.positionWS; #endif #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) output.shadowCoord = GetShadowCoord(vertexInput); #endif output.positionCS = vertexInput.positionCS; return output; } // Used in Standard (Physically Based) shader half4 LitPassFragment(Varyings input) : SV_Target { input.uv += _Time.x * 10; UNITY_SETUP_INSTANCE_ID(input); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); InputData inputData; InitializeInputData(input, surfaceData.normalTS, inputData); float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; surfaceData.emission *= outline * _DissolveColor; half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); color *= lerp(1, _DissolveColor, outline); color.rgb = MixFog(color.rgb, inputData.fogCoord); return color; } ENDHLSL } // Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl" float3 _LightDirection; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; CBUFFER_START(UnityPerMaterial) float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float4 GetShadowPositionHClip(Attributes input) { float3 positionWS = TransformObjectToWorld(input.positionOS.xyz); float3 normalWS = TransformObjectToWorldNormal(input.normalOS); float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection)); #if UNITY_REVERSED_Z positionCS.z = min(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #else positionCS.z = max(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #endif return positionCS; } Varyings ShadowPassVertex(Attributes input) { Varyings output; input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); UNITY_SETUP_INSTANCE_ID(input); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = GetShadowPositionHClip(input); return output; } half4 ShadowPassFragment(Varyings input) : SV_TARGET { float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #ifndef LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED #define LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED struct Attributes { float4 position : POSITION; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; Varyings DepthOnlyVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.position.xyz += normalize(input.position.xyz) * sin(input.position.x) * sin(_Time.x * 100); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = TransformObjectToHClip(input.position.xyz); return output; } half4 DepthOnlyFragment(Varyings input) : SV_TARGET { UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } #endif ENDHLSL } // Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl" #ifndef LIGHTWEIGHT_LIT_META_PASS_INCLUDED #define LIGHTWEIGHT_LIT_META_PASS_INCLUDED Varyings LightweightVertexMeta(Attributes input) { Varyings output; output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST); output.uv = TRANSFORM_TEX(input.uv0, _BaseMap); return output; } half4 LightweightFragmentMeta(Varyings input) : SV_Target { SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); BRDFData brdfData; InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData); MetaInput metaInput; metaInput.Albedo = brdfData.diffuse + brdfData.specular * brdfData.roughness * 0.5; metaInput.SpecularColor = surfaceData.specular; metaInput.Emission = surfaceData.emission; return MetaFragment(metaInput); } #endif ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor" }</span></span></code> </pre><br></div></div><br>  ‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á, ‡§Ü‡§™‡§ï‡•ã ‡§Ø‡§π ‡§™‡§§‡§æ ‡§≤‡§ó‡§æ‡§®‡•á ‡§ï‡•Ä ‡§ú‡§º‡§∞‡•Ç‡§∞‡§§ ‡§π‡•à ‡§ï‡§ø ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ‡•Ä ‡§∂‡•á‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à‡•§  ‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á, ‡§π‡§Æ ‡§≤‡§æ‡§á‡§® ‡§Æ‡•á‡§Ç ‡§∞‡•Å‡§ö‡§ø ‡§∞‡§ñ‡§§‡•á ‡§π‡•à‡§Ç: <br><br><pre> <code class="cpp hljs">CustomEditor <span class="hljs-string"><span class="hljs-string">"UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor"</span></span></code> </pre> <br>  ‡§ú‡•ã, ‡§ú‡•à‡§∏‡§æ ‡§ï‡§ø ‡§π‡§Æ ‡§Ø‡§æ‡§¶ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§Æ‡•Ç‡§≤ ‡§Æ‡•á‡§Ç ‡§®‡§ø‡§Æ‡•ç‡§®‡§æ‡§®‡•Å‡§∏‡§æ‡§∞ ‡§•‡§æ: <br><br><pre> <code class="cpp hljs">CustomEditor <span class="hljs-string"><span class="hljs-string">"UnityEditor.Rendering.LWRP.ShaderGUI.LitShader"</span></span></code> </pre> <br>  ‡§§‡•ã ‡§Ø‡§π ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à ‡§î‡§∞ ‡§ï‡•ç‡§Ø‡•ã‡§Ç ‡§π‡•à?  ‡§á‡§∏ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§ï‡§æ‡§´‡•Ä ‡§∏‡§∞‡§≤ ‡§π‡•à - ‡§Ø‡§¶‡§ø ‡§Ü‡§™ ‡§¨‡§æ‡§∞‡•Ä‡§ï‡•Ä ‡§∏‡•á ‡§¶‡•á‡§ñ‡§§‡•á ‡§π‡•à‡§Ç, ‡§§‡•ã ‡§∂‡•á‡§°‡§∞ ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§°‡§ø‡§´‡§æ‡§á‡§®‡§∞‡•ç‡§∏ ‡§ï‡•Ä ‡§è‡§ï ‡§¨‡§°‡§º‡•Ä ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à, ‡§ú‡•ã ‡§Ö‡§ú‡•Ä‡§¨ ‡§§‡§∞‡§π ‡§∏‡•á ‡§™‡§∞‡•ç‡§Ø‡§æ‡§™‡•ç‡§§ ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç, ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§î‡§∞ ‡§®‡§ø‡§∑‡•ç‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à, ‡§î‡§∞ ‡§Ø‡§π, ‡§è‡§ï ‡§™‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§ï‡•ã‡§° ‡§∏‡•á ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à, ‡§Ø‡§π‡•Ä ‡§ï‡§æ‡§∞‡§£ ‡§π‡•à ‡§ï‡§ø ‡§π‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§®‡§ø‡§∞‡•Ä‡§ï‡•ç‡§∑‡§ï ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•à‡•§  ‡§á‡§∏‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ, ‡§π‡§Æ‡§æ‡§∞‡•á ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§á‡§Ç‡§∏‡•ç‡§™‡•á‡§ï‡•ç‡§ü‡§∞ ‡§ï‡•ã ‡§π‡§Æ‡•á‡§Ç ‡§® ‡§ï‡•á‡§µ‡§≤ ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§®‡§ø‡§π‡§ø‡§§ ‡§∏‡§Ç‡§™‡§§‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§∏‡§Ç‡§™‡§æ‡§¶‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§ï‡§æ ‡§Æ‡•å‡§ï‡§æ ‡§¶‡•á‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è, ‡§¨‡§≤‡•ç‡§ï‡§ø ‡§Ø‡§π ‡§≠‡•Ä ‡§ï‡§ø ‡§π‡§Æ‡•á‡§Ç ‡§Ö‡§™‡§®‡•á ‡§∂‡•á‡§° ‡§Æ‡•á‡§Ç ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à‡•§<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§Æ‡•Ç‡§≤ shader ‡§Æ‡•á‡§Ç ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§è‡§ï ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§á‡§Ç‡§∏‡•ç‡§™‡•á‡§ï‡•ç‡§ü‡§∞ ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è ‡§π‡§Æ ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§á‡§∏‡•á ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§™‡§• ‡§ï‡•á ‡§∏‡§æ‡§• ‡§¢‡•Ç‡§Ç‡§¢ ‡§ï‡§∞ ‡§™‡•á‡§ü ‡§≠‡§∞‡§§‡•á ‡§π‡•à‡§Ç: </font></font><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render-pipelines.lightweight@6.9.2 \ Editor \ ShaderGUI \ Shaders \</font></font></i> </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ ‡§Æ‡•á‡§Ç, ‡§π‡§Æ LitShader.cs ‡§´‡§º‡§æ‡§á‡§≤ ‡§Æ‡•á‡§Ç ‡§∞‡•Å‡§ö‡§ø ‡§∞‡§ñ‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡•ã ‡§ï‡§ø ‡§¨‡•á‡§∏‡§∂‡•á‡§Ø‡§∞‡§ó‡•Ç‡§à ‡§∏‡•á ‡§µ‡§ø‡§∞‡§æ‡§∏‡§§ ‡§Æ‡•á‡§Ç ‡§Æ‡§ø‡§≤‡•Ä ‡§π‡•à: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LitShader</span></span> : <span class="hljs-title"><span class="hljs-title">BaseShaderGUI</span></span> { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§¨‡•à‡§ö ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ BaseShaderGUI.cs ‡§Æ‡•á‡§Ç ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§ú‡•ã ‡§´‡§º‡•ã‡§≤‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡•ç‡§§‡§∞ ‡§Ö‡§ß‡§ø‡§ï ‡§™‡§æ‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseShaderGUI</span></span> : <span class="hljs-title"><span class="hljs-title">ShaderGUI</span></span> { ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§π‡§Æ ‡§á‡§® ‡§≤‡§ø‡§™‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§≤‡•á‡§§‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§â‡§®‡•ç‡§π‡•á‡§Ç </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§∏‡§Ç‡§™‡§æ‡§¶‡§ï</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§´‡§º‡•ã‡§≤‡•ç‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§´‡•á‡§Ç‡§ï ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç </font><font style="vertical-align: inherit;">(‡§Ø‡§¶‡§ø ‡§ï‡•ã‡§à ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§§‡•ã ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§¨‡§®‡§æ‡§è‡§Ç, ‡§Ö‡§®‡•ç‡§Ø‡§•‡§æ ‡§™‡§∞‡§ø‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ï‡•á ‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£ ‡§ï‡•á ‡§¶‡•å‡§∞‡§æ‡§® ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø‡§Ø‡§æ‡§Ç ‡§¶‡§ø‡§ñ‡§æ‡§à ‡§¶‡•á‡§Ç‡§ó‡•Ä, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ø‡•Ç‡§®‡§ø‡§ü‡•Ä ‡§è‡§°‡§ø‡§ü‡§∞ ‡§®‡§æ‡§Æ ‡§¨‡§ø‡§≤‡•ç‡§° ‡§Æ‡•á‡§Ç ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à)‡•§ </font><font style="vertical-align: inherit;">‡§¨‡•á‡§∂‡§ï, ‡§π‡§Æ‡§æ‡§∞‡•á ‡§∏‡§ø‡§∞ ‡§™‡§∞ ‡§è‡§ï ‡§π‡§ú‡§æ‡§∞ ‡§è‡§ï ‡§ó‡§≤‡§§‡•Ä ‡§π‡•à, ‡§ú‡•ã ‡§ü‡§æ‡§á‡§™ internel ‡§∏‡§æ‡§• ‡§ú‡•Å‡§°‡§º‡•á ‡§∞‡§π‡•á ‡§π‡•à‡§Ç ‡§ó‡§ø‡§∞ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SavedBool</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§π‡•à, ‡§ú‡•ã ‡§è‡§ï ‡§ß‡§æ‡§∞‡§æ‡§µ‡§æ‡§π‡§ø‡§ï ‡§ñ‡§ø‡§°‡§º‡§ï‡•Ä ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ bool ‡§ö‡§∞ ‡§∏‡§Ç‡§™‡§æ‡§¶‡§ï ‡§π‡•à‡•§ </font><font style="vertical-align: inherit;">‡§Ø‡§π ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•á ‡§§‡§π ‡§µ‡§∞‡•ç‡§ó‡•ã‡§Ç ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§ï‡•ã ‡§¨‡§®‡§æ‡§è ‡§∞‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ </font><font style="vertical-align: inherit;">‡§¶‡§∞‡§Ö‡§∏‡§≤, ‡§∏‡•Å‡§ß‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§Æ ‡§∏‡§∞‡§≤ ‡§π‡•á‡§∞‡§´‡•á‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§¨‡§¶‡§≤‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è:</font></font><br><br><pre> <code class="cs hljs">SavedBool m_SurfaceOptionsFoldout; SavedBool m_SurfaceInputsFoldout; SavedBool m_AdvancedFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è: </font></font><br><br><pre> <code class="cs hljs">AnimatedValues.AnimBool m_SurfaceOptionsFoldout; AnimatedValues.AnimBool m_SurfaceInputsFoldout; AnimatedValues.AnimBool m_AdvancedFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§î‡§∞ ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§ ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§ó‡•Å‡§£‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§î‡§∞ ‡§ö‡§∞ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç: </font></font><br><br><pre> <code class="cs hljs">AnimatedValues.AnimBool m_OtherFoldout;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§Ü‡§™‡§ï‡•ã ‡§π‡§Æ‡§æ‡§∞‡•á ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§Æ‡§æ‡§™‡§¶‡§Ç‡§°‡•ã‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§• ‡§Ö‡§®‡•Å‡§≠‡§æ‡§ó ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§î‡§∞ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡•Ä ‡§ú‡•ã‡§°‡§º‡§®‡§æ ‡§π‡•ã‡§ó‡§æ, ‡§∏‡•ç‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§ü ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§∏‡•ç‡§•‡§æ‡§™‡§ø‡§§ ‡§™‡§∞‡§Ç‡§™‡§∞‡§æ‡§ì‡§Ç ‡§ï‡§æ ‡§Ö‡§µ‡§≤‡•ã‡§ï‡§® ‡§ï‡§∞‡§®‡§æ: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Styles</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Catergories ... public static readonly GUIContent OtherOptions = new GUIContent("Your own options", "You own custom options"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§ñ‡•à‡§∞, ‡§Ö‡§¨ ‡§•‡•ã‡§°‡§º‡§æ ‡§ü‡•ç‡§∞‡§ø‡§ï ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§ú‡•à‡§∏‡§æ ‡§ï‡§ø ‡§Ü‡§™ ‡§¶‡•á‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§∏‡§≠‡•Ä ‡§Æ‡§æ‡§®‡§ï ‡§ó‡•Å‡§£‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•à‡§Ç‡§®‡•á </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HideInInspector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ ‡§®‡§ø‡§∞‡•ç‡§ß‡§æ‡§∞‡§ø‡§§ ‡§ï‡•Ä ‡§π‡•à </font><font style="vertical-align: inherit;">, ‡§ú‡•ã ‡§∏‡•Ä‡§ß‡•á ‡§∏‡§Ç‡§ï‡•á‡§§ ‡§¶‡•á‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§Ø‡§π ‡§∏‡§Ç‡§™‡§§‡•ç‡§§‡§ø ‡§®‡§ø‡§∞‡•Ä‡§ï‡•ç‡§∑‡§ï ‡§Æ‡•á‡§Ç ‡§õ‡§ø‡§™‡•Ä ‡§π‡•ã‡§ó‡•Ä‡•§ </font><font style="vertical-align: inherit;">‡§π‡§æ‡§≤‡§æ‡§Ç‡§ï‡§ø, ‡§Ø‡§π ‡§ï‡•á‡§µ‡§≤ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•á ‡§Æ‡§æ‡§®‡§ï ‡§®‡§ø‡§∞‡•Ä‡§ï‡•ç‡§∑‡§ï ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡§æ‡§∏‡§Ç‡§ó‡§ø‡§ï ‡§π‡•à, ‡§≤‡•á‡§ï‡§ø‡§® ‡§ï‡•å‡§® ‡§∏‡§æ? </font><font style="vertical-align: inherit;">‡§Ø‡§π ‡§∏‡§π‡•Ä ‡§π‡•à, ‡§ï‡§∏‡•ç‡§ü‡§Æ! </font><font style="vertical-align: inherit;">‡§á‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§Ø‡§π ‡§π‡•à ‡§ï‡§ø ‡§π‡§Æ‡§æ‡§∞‡•á ‡§∏‡§≠‡•Ä ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§®‡§ø‡§π‡§ø‡§§ ‡§ó‡•Å‡§£ ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§ø‡§è ‡§ú‡§æ‡§§‡•á ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§§‡•ã ‡§Ü‡§á‡§è ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§õ‡§ø‡§™‡§æ‡§§‡•á ‡§π‡•à‡§Ç:</font></font><br><br><pre> <code class="cpp hljs">... [MainColor][HideInInspector] _BaseColor(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [MainTexture][HideInInspector] _BaseMap(<span class="hljs-string"><span class="hljs-string">"Albedo"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} [HideInInspector]_Cutoff(<span class="hljs-string"><span class="hljs-string">"Alpha Cutoff"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> [HideInInspector]_Smoothness(<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> [HideInInspector]_GlossMapScale(<span class="hljs-string"><span class="hljs-string">"Smoothness Scale"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> [HideInInspector]_SmoothnessTextureChannel(<span class="hljs-string"><span class="hljs-string">"Smoothness texture channel"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§î‡§∞ ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§∏‡§Ç‡§™‡§æ‡§¶‡§ï ‡§ï‡•á ‡§ï‡•ã‡§° ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞, ‡§π‡§Æ ‡§¨‡§∏ ‡§Æ‡§æ‡§®‡§ï ‡§®‡§ø‡§∞‡•Ä‡§ï‡•ç‡§∑‡§ï ‡§ï‡•á ‡§™‡•ç‡§∞‡§§‡§ø‡§™‡§æ‡§¶‡§® ‡§ï‡§π‡§§‡•á ‡§π‡•à‡§Ç: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { ... m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = EditorGUILayout.BeginFoldoutHeaderGroup(m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, Styles.OtherOptions); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_OtherFoldout.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnGUI(materialEditorIn, properties); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§™‡§∞‡§ø‡§£‡§æ‡§Æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§π‡•à: </font><font style="vertical-align: inherit;">‡§î‡§∞ ‡§Ø‡§π‡§æ‡§Å ‡§¶‡•ã‡§®‡•ã‡§Ç ‡§≤‡§ø‡§™‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ã‡§° ‡§π‡•à:</font></font><br><br> <a href="https://ibb.co/wz3FT1X" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/81e/d13/4b6/81ed134b69e689252cc2325dd59bc24b.png" alt="2020-01-19-22-58-23"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BaseShaderEditor.cs</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UnityEditor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseShaderEditor</span></span> : <span class="hljs-title"><span class="hljs-title">ShaderGUI</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> EnumsAndClasses public enum SurfaceType { Opaque, Transparent } public enum BlendMode { Alpha, // Old school alpha-blending mode, fresnel does not affect amount of transparency Premultiply, // Physically plausible transparency mode, implemented as alpha pre-multiply Additive, Multiply } public enum SmoothnessSource { BaseAlpha, SpecularAlpha } public enum RenderFace { Front = 2, Back = 1, Both = 0 } protected class Styles { // Catergories public static readonly GUIContent SurfaceOptions = new GUIContent("Surface Options", "Controls how LWRP renders the Material on a screen."); public static readonly GUIContent SurfaceInputs = new GUIContent("Surface Inputs", "These settings describe the look and feel of the surface itself."); public static readonly GUIContent AdvancedLabel = new GUIContent("Advanced", "These settings affect behind-the-scenes rendering and underlying calculations."); public static readonly GUIContent surfaceType = new GUIContent("Surface Type", "Select a surface type for your texture. Choose between Opaque or Transparent."); public static readonly GUIContent blendingMode = new GUIContent("Blending Mode", "Controls how the color of the Transparent surface blends with the Material color in the background."); public static readonly GUIContent cullingText = new GUIContent("Render Face", "Specifies which faces to cull from your geometry. Front culls front faces. Back culls backfaces. None means that both sides are rendered."); public static readonly GUIContent alphaClipText = new GUIContent("Alpha Clipping", "Makes your Material act like a Cutout shader. Use this to create a transparent effect with hard edges between opaque and transparent areas."); public static readonly GUIContent alphaClipThresholdText = new GUIContent("Threshold", "Sets where the Alpha Clipping starts. The higher the value is, the brighter the effect is when clipping starts."); public static readonly GUIContent receiveShadowText = new GUIContent("Receive Shadows", "When enabled, other GameObjects can cast shadows onto this GameObject."); public static readonly GUIContent baseMap = new GUIContent("Base Map", "Specifies the base Material and/or Color of the surface. If you've selected Transparent or Alpha Clipping under Surface Options, your Material uses the Texture's alpha channel or color."); public static readonly GUIContent emissionMap = new GUIContent("Emission Map", "Sets a Texture map to use for emission. You can also select a color with the color picker. Colors are multiplied over the Texture."); public static readonly GUIContent normalMapText = new GUIContent("Normal Map", "Assigns a tangent-space normal map."); public static readonly GUIContent bumpScaleNotSupported = new GUIContent("Bump scale is not supported on mobile platforms"); public static readonly GUIContent fixNormalNow = new GUIContent("Fix now", "Converts the assigned texture to be a normal map format."); public static readonly GUIContent queueSlider = new GUIContent("Priority", "Determines the chronological rendering order for a Material. High values are rendered first."); public static readonly GUIContent OtherOptions = new GUIContent("Your own options", "You own custom options"); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Variables protected MaterialEditor materialEditor { get; set; } protected MaterialProperty surfaceTypeProp { get; set; } protected MaterialProperty blendModeProp { get; set; } protected MaterialProperty cullingProp { get; set; } protected MaterialProperty alphaClipProp { get; set; } protected MaterialProperty alphaCutoffProp { get; set; } protected MaterialProperty receiveShadowsProp { get; set; } // Common Surface Input properties protected MaterialProperty baseMapProp { get; set; } protected MaterialProperty baseColorProp { get; set; } protected MaterialProperty emissionMapProp { get; set; } protected MaterialProperty emissionColorProp { get; set; } protected MaterialProperty queueOffsetProp { get; set; } public bool m_FirstTimeApply = true; private const string k_KeyPrefix = "LightweightRP:Material:UI_State:"; private string m_HeaderStateKey = null; // Header foldout states AnimatedValues.AnimBool m_SurfaceOptionsFoldout; AnimatedValues.AnimBool m_SurfaceInputsFoldout; AnimatedValues.AnimBool m_AdvancedFoldout; AnimatedValues.AnimBool m_OtherFoldout; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> private const int queueOffsetRange = 50; //////////////////////////////////// // General Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> GeneralFunctions public abstract void MaterialChanged(Material material); public virtual void FindProperties(MaterialProperty[] properties) { surfaceTypeProp = FindProperty("_Surface", properties); blendModeProp = FindProperty("_Blend", properties); cullingProp = FindProperty("_Cull", properties); alphaClipProp = FindProperty("_AlphaClip", properties); alphaCutoffProp = FindProperty("_Cutoff", properties); receiveShadowsProp = FindProperty("_ReceiveShadows", properties, false); baseMapProp = FindProperty("_BaseMap", properties, false); baseColorProp = FindProperty("_BaseColor", properties, false); emissionMapProp = FindProperty("_EmissionMap", properties, false); emissionColorProp = FindProperty("_EmissionColor", properties, false); queueOffsetProp = FindProperty("_QueueOffset", properties, false); } public override void OnGUI(MaterialEditor materialEditorIn, MaterialProperty[] properties) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (materialEditorIn == null) throw new ArgumentNullException("materialEditorIn"); FindProperties(properties); // MaterialProperties can be animated so we do not cache them but fetch them every event to ensure animated values are updated correctly materialEditor = materialEditorIn; Material material = materialEditor.target as Material; // Make sure that needed setup (ie keywords/renderqueue) are set up </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we're switching some existing // material to a lightweight shader. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_FirstTimeApply) { OnOpenGUI(material, materialEditorIn); m_FirstTimeApply = false; } ShaderPropertiesGUI(material); m_OtherFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_OtherFoldout.value, Styles.OtherOptions); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_OtherFoldout.value) { base.OnGUI(materialEditorIn, properties); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } public virtual void OnOpenGUI(Material material, MaterialEditor materialEditor) { // Foldout states m_HeaderStateKey = k_KeyPrefix + material.shader.name; // Create key string for editor prefs m_SurfaceOptionsFoldout = new AnimatedValues.AnimBool(true); m_SurfaceInputsFoldout = new AnimatedValues.AnimBool(true); m_AdvancedFoldout = new AnimatedValues.AnimBool(true); m_OtherFoldout = new AnimatedValues.AnimBool(true); foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } public void ShaderPropertiesGUI(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material == null) throw new ArgumentNullException("material"); EditorGUI.BeginChangeCheck(); m_SurfaceOptionsFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_SurfaceOptionsFoldout.value, Styles.SurfaceOptions); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_SurfaceOptionsFoldout.value) { DrawSurfaceOptions(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); m_SurfaceInputsFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_SurfaceInputsFoldout.value, Styles.SurfaceInputs); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_SurfaceInputsFoldout.value) { DrawSurfaceInputs(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); m_AdvancedFoldout.value = EditorGUILayout.BeginFoldoutHeaderGroup(m_AdvancedFoldout.value, Styles.AdvancedLabel); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (m_AdvancedFoldout.value) { DrawAdvancedOptions(material); EditorGUILayout.Space(); } EditorGUILayout.EndFoldoutHeaderGroup(); DrawAdditionalFoldouts(material); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { foreach (var obj in materialEditor.targets) MaterialChanged((Material)obj); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Drawing Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> DrawingFunctions public virtual void DrawSurfaceOptions(Material material) { DoPopup(Styles.surfaceType, surfaceTypeProp, Enum.GetNames(typeof(SurfaceType))); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((SurfaceType)material.GetFloat("_Surface") == SurfaceType.Transparent) DoPopup(Styles.blendingMode, blendModeProp, Enum.GetNames(typeof(BlendMode))); EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = cullingProp.hasMixedValue; var culling = (RenderFace)cullingProp.floatValue; culling = (RenderFace)EditorGUILayout.EnumPopup(Styles.cullingText, culling); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(Styles.cullingText.text); cullingProp.floatValue = (float)culling; material.doubleSidedGI = (RenderFace)cullingProp.floatValue != RenderFace.Front; } EditorGUI.showMixedValue = false; EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = alphaClipProp.hasMixedValue; var alphaClipEnabled = EditorGUILayout.Toggle(Styles.alphaClipText, alphaClipProp.floatValue == 1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) alphaClipProp.floatValue = alphaClipEnabled ? 1 : 0; EditorGUI.showMixedValue = false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClipProp.floatValue == 1) materialEditor.ShaderProperty(alphaCutoffProp, Styles.alphaClipThresholdText, 1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (receiveShadowsProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = receiveShadowsProp.hasMixedValue; var receiveShadows = EditorGUILayout.Toggle(Styles.receiveShadowText, receiveShadowsProp.floatValue == 1.0f); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) receiveShadowsProp.floatValue = receiveShadows ? 1.0f : 0.0f; EditorGUI.showMixedValue = false; } } public virtual void DrawSurfaceInputs(Material material) { DrawBaseProperties(material); } public virtual void DrawAdvancedOptions(Material material) { materialEditor.EnableInstancingField(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (queueOffsetProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = queueOffsetProp.hasMixedValue; var queue = EditorGUILayout.IntSlider(Styles.queueSlider, (int)queueOffsetProp.floatValue, -queueOffsetRange, queueOffsetRange); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) queueOffsetProp.floatValue = queue; EditorGUI.showMixedValue = false; } } public virtual void DrawAdditionalFoldouts(Material material) { } public virtual void DrawBaseProperties(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (baseMapProp != null &amp;&amp; baseColorProp != null) // Draw the baseMap, most shader will have at least a baseMap { materialEditor.TexturePropertySingleLine(Styles.baseMap, baseMapProp, baseColorProp); // TODO Temporary fix for lightmapping, to be replaced with attribute tag. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_MainTex")) { material.SetTexture("_MainTex", baseMapProp.textureValue); var baseMapTiling = baseMapProp.textureScaleAndOffset; material.SetTextureScale("_MainTex", new Vector2(baseMapTiling.x, baseMapTiling.y)); material.SetTextureOffset("_MainTex", new Vector2(baseMapTiling.z, baseMapTiling.w)); } } } protected virtual void DrawEmissionProperties(Material material, bool keyword) { var emissive = true; var hadEmissionTexture = emissionMapProp.textureValue != null; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!keyword) { materialEditor.TexturePropertyWithHDRColor(Styles.emissionMap, emissionMapProp, emissionColorProp, false); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { // Emission for GI? emissive = materialEditor.EmissionEnabledProperty(); EditorGUI.BeginDisabledGroup(!emissive); { // Texture and HDR color controls materialEditor.TexturePropertyWithHDRColor(Styles.emissionMap, emissionMapProp, emissionColorProp, false); } EditorGUI.EndDisabledGroup(); } // If texture was assigned and color was black set color to white var brightness = emissionColorProp.colorValue.maxColorComponent; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (emissionMapProp.textureValue != null &amp;&amp; !hadEmissionTexture &amp;&amp; brightness &lt;= 0f) emissionColorProp.colorValue = Color.white; // LW does not support RealtimeEmissive. We set it to bake emissive and handle the emissive is black right. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (emissive) { material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.BakedEmissive; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (brightness &lt;= 0f) material.globalIlluminationFlags |= MaterialGlobalIlluminationFlags.EmissiveIsBlack; } } public static void DrawNormalArea(MaterialEditor materialEditor, MaterialProperty bumpMap, MaterialProperty bumpMapScale = null) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bumpMapScale != null) { materialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap, bumpMap.textureValue != null ? bumpMapScale : null); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bumpMapScale.floatValue != 1 &amp;&amp; UnityEditorInternal.InternalEditorUtility.IsMobilePlatform( EditorUserBuildSettings.activeBuildTarget)) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (materialEditor.HelpBoxWithButton(Styles.bumpScaleNotSupported, Styles.fixNormalNow)) bumpMapScale.floatValue = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { materialEditor.TexturePropertySingleLine(Styles.normalMapText, bumpMap); } } protected static void DrawTileOffset(MaterialEditor materialEditor, MaterialProperty textureProp) { materialEditor.TextureScaleOffsetProperty(textureProp); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Material Data Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> MaterialDataFunctions public static void SetMaterialKeywords(Material material, Action&lt;Material&gt; shadingModelFunc = null, Action&lt;Material&gt; shaderFunc = null) { // Clear all keywords for fresh start material.shaderKeywords = null; // Setup blending - consistent across all LWRP shaders SetupMaterialBlendMode(material); // Receive Shadows </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_ReceiveShadows")) CoreUtils.SetKeyword(material, "_RECEIVE_SHADOWS_OFF", material.GetFloat("_ReceiveShadows") == 0.0f); // Emission </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_EmissionColor")) MaterialEditor.FixupEmissiveFlag(material); bool shouldEmissionBeEnabled = (material.globalIlluminationFlags &amp; MaterialGlobalIlluminationFlags.EmissiveIsBlack) == 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_EmissionEnabled") &amp;&amp; !shouldEmissionBeEnabled) shouldEmissionBeEnabled = material.GetFloat("_EmissionEnabled") &gt;= 0.5f; CoreUtils.SetKeyword(material, "_EMISSION", shouldEmissionBeEnabled); // Normal Map </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_BumpMap")) CoreUtils.SetKeyword(material, "_NORMALMAP", material.GetTexture("_BumpMap")); // Shader specific keyword functions shadingModelFunc?.Invoke(material); shaderFunc?.Invoke(material); } public static void SetupMaterialBlendMode(Material material) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material == null) throw new ArgumentNullException("material"); bool alphaClip = material.GetFloat("_AlphaClip") == 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClip) { material.EnableKeyword("_ALPHATEST_ON"); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { material.DisableKeyword("_ALPHATEST_ON"); } var queueOffset = 0; // queueOffsetRange; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (material.HasProperty("_QueueOffset")) queueOffset = queueOffsetRange - (int)material.GetFloat("_QueueOffset"); SurfaceType surfaceType = (SurfaceType)material.GetFloat("_Surface"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (surfaceType == SurfaceType.Opaque) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alphaClip) { material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.AlphaTest; material.SetOverrideTag("RenderType", "TransparentCutout"); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { material.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Geometry; material.SetOverrideTag("RenderType", "Opaque"); } material.renderQueue += queueOffset; material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero); material.SetInt("_ZWrite", 1); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); material.SetShaderPassEnabled("ShadowCaster", true); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { BlendMode blendMode = (BlendMode)material.GetFloat("_Blend"); var queue = (int)UnityEngine.Rendering.RenderQueue.Transparent; // Specific Transparent Mode Settings switch (blendMode) { case BlendMode.Alpha: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Premultiply: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha); material.EnableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Additive: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.One); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.One); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); break; case BlendMode.Multiply: material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.DstColor); material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.Zero); material.DisableKeyword("_ALPHAPREMULTIPLY_ON"); material.EnableKeyword("_ALPHAMODULATE_ON"); break; } // General Transparent Material Settings material.SetOverrideTag("RenderType", "Transparent"); material.SetInt("_ZWrite", 0); material.renderQueue = queue + queueOffset; material.SetShaderPassEnabled("ShadowCaster", false); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> //////////////////////////////////// // Helper Functions // //////////////////////////////////// #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> HelperFunctions public static void TwoFloatSingleLine(GUIContent title, MaterialProperty prop1, GUIContent prop1Label, MaterialProperty prop2, GUIContent prop2Label, MaterialEditor materialEditor, float labelWidth = 30f) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = prop1.hasMixedValue || prop2.hasMixedValue; Rect rect = EditorGUILayout.GetControlRect(); EditorGUI.PrefixLabel(rect, title); var indent = EditorGUI.indentLevel; var preLabelWidth = EditorGUIUtility.labelWidth; EditorGUI.indentLevel = 0; EditorGUIUtility.labelWidth = labelWidth; Rect propRect1 = new Rect(rect.x + preLabelWidth, rect.y, (rect.width - preLabelWidth) * 0.5f, EditorGUIUtility.singleLineHeight); var prop1val = EditorGUI.FloatField(propRect1, prop1Label, prop1.floatValue); Rect propRect2 = new Rect(propRect1.x + propRect1.width, rect.y, propRect1.width, EditorGUIUtility.singleLineHeight); var prop2val = EditorGUI.FloatField(propRect2, prop2Label, prop2.floatValue); EditorGUI.indentLevel = indent; EditorGUIUtility.labelWidth = preLabelWidth; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(title.text); prop1.floatValue = prop1val; prop2.floatValue = prop2val; } EditorGUI.showMixedValue = false; } public void DoPopup(GUIContent label, MaterialProperty property, string[] options) { DoPopup(label, property, options, materialEditor); } public static void DoPopup(GUIContent label, MaterialProperty property, string[] options, MaterialEditor materialEditor) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (property == null) throw new ArgumentNullException("property"); EditorGUI.showMixedValue = property.hasMixedValue; var mode = property.floatValue; EditorGUI.BeginChangeCheck(); mode = EditorGUILayout.Popup(label, (int)mode, options); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(label.text); property.floatValue = mode; } EditorGUI.showMixedValue = false; } // Helper to show texture and color properties public static Rect TextureColorProps(MaterialEditor materialEditor, GUIContent label, MaterialProperty textureProp, MaterialProperty colorProp, bool hdr = false) { Rect rect = EditorGUILayout.GetControlRect(); EditorGUI.showMixedValue = textureProp.hasMixedValue; materialEditor.TexturePropertyMiniThumbnail(rect, textureProp, label.text, label.tooltip); EditorGUI.showMixedValue = false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (colorProp != null) { EditorGUI.BeginChangeCheck(); EditorGUI.showMixedValue = colorProp.hasMixedValue; int indentLevel = EditorGUI.indentLevel; EditorGUI.indentLevel = 0; Rect rectAfterLabel = new Rect(rect.x + EditorGUIUtility.labelWidth, rect.y, EditorGUIUtility.fieldWidth, EditorGUIUtility.singleLineHeight); var col = EditorGUI.ColorField(rectAfterLabel, GUIContent.none, colorProp.colorValue, true, false, hdr); EditorGUI.indentLevel = indentLevel; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EditorGUI.EndChangeCheck()) { materialEditor.RegisterPropertyChangeUndo(colorProp.displayName); colorProp.colorValue = col; } EditorGUI.showMixedValue = false; } return rect; } // Copied from shaderGUI as it is a protected function in an abstract class, unavailable to others public new static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties) { return FindProperty(propertyName, properties, true); } // Copied from shaderGUI as it is a protected function in an abstract class, unavailable to others public new static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties, bool propertyIsMandatory) { for (int index = 0; index &lt; properties.Length; ++index) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (properties[index] != null &amp;&amp; properties[index].name == propertyName) return properties[index]; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (propertyIsMandatory) throw new ArgumentException("Could not find MaterialProperty: '" + propertyName + "', Num properties: " + (object)properties.Length); return null; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LitShaderEditor.cs</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.Rendering; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor.Rendering.LWRP; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UnityEditor.Rendering.LWRP.ShaderGUI</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LitShaderEditor</span></span> : <span class="hljs-title"><span class="hljs-title">BaseShaderEditor</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Properties private LitGUI.LitProperties litProperties; // collect properties from the material properties public override void FindProperties(MaterialProperty[] properties) { base.FindProperties(properties); litProperties = new LitGUI.LitProperties(properties); } // material changed check public override void MaterialChanged(Material material) { if (material == null) throw new ArgumentNullException("material"); SetMaterialKeywords(material, LitGUI.SetMaterialKeywords); } // material main surface options public override void DrawSurfaceOptions(Material material) { if (material == null) throw new ArgumentNullException("material"); // Use default labelWidth EditorGUIUtility.labelWidth = 0f; // Detect any changes to the material EditorGUI.BeginChangeCheck(); if (litProperties.workflowMode != null) { DoPopup(LitGUI.Styles.workflowModeText, litProperties.workflowMode, Enum.GetNames(typeof(LitGUI.WorkflowMode))); } if (EditorGUI.EndChangeCheck()) { foreach (var obj in blendModeProp.targets) MaterialChanged((Material)obj); } base.DrawSurfaceOptions(material); } // material main surface inputs public override void DrawSurfaceInputs(Material material) { base.DrawSurfaceInputs(material); LitGUI.Inputs(litProperties, materialEditor, material); DrawEmissionProperties(material, true); DrawTileOffset(materialEditor, baseMapProp); } // material main advanced options public override void DrawAdvancedOptions(Material material) { if (litProperties.reflections != null &amp;&amp; litProperties.highlights != null) { EditorGUI.BeginChangeCheck(); { materialEditor.ShaderProperty(litProperties.highlights, LitGUI.Styles.highlightsText); materialEditor.ShaderProperty(litProperties.reflections, LitGUI.Styles.reflectionsText); EditorGUI.BeginChangeCheck(); } } base.DrawAdvancedOptions(material); } public override void AssignNewShaderToMaterial(Material material, Shader oldShader, Shader newShader) { if (material == null) throw new ArgumentNullException("material"); // _Emission property is lost after assigning Standard shader to the material // thus transfer it before assigning the new shader if (material.HasProperty("_Emission")) { material.SetColor("_EmissionColor", material.GetColor("_Emission")); } base.AssignNewShaderToMaterial(material, oldShader, newShader); if (oldShader == null || !oldShader.name.Contains("Legacy Shaders/")) { SetupMaterialBlendMode(material); return; } SurfaceType surfaceType = SurfaceType.Opaque; BlendMode blendMode = BlendMode.Alpha; if (oldShader.name.Contains("/Transparent/Cutout/")) { surfaceType = SurfaceType.Opaque; material.SetFloat("_AlphaClip", 1); } else if (oldShader.name.Contains("/Transparent/")) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> legacy shaders did not provide physically based transparency // therefore Fade mode surfaceType = SurfaceType.Transparent; blendMode = BlendMode.Alpha; } material.SetFloat("_Surface", (float)surfaceType); material.SetFloat("_Blend", (float)blendMode); if (oldShader.name.Equals("Standard (Specular setup)")) { material.SetFloat("_WorkflowMode", (float)LitGUI.WorkflowMode.Specular); Texture texture = material.GetTexture("_SpecGlossMap"); if (texture != null) material.SetTexture("_MetallicSpecGlossMap", texture); } else { material.SetFloat("_WorkflowMode", (float)LitGUI.WorkflowMode.Metallic); Texture texture = material.GetTexture("_MetallicGlossMap"); if (texture != null) material.SetTexture("_MetallicSpecGlossMap", texture); } MaterialChanged(material); } } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Ö‡§¨ ‡§Ü‡§á‡§è ‡§õ‡§æ‡§Ø‡§æ‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§á‡§®‡§∏‡§æ‡§á‡§° ‡§ï‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§™‡§π‡§≤‡•Ä ‡§¨‡§æ‡§§ ‡§ú‡§ø‡§∏ ‡§™‡§∞ ‡§Ü‡§™ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç, ‡§µ‡§π ‡§Ø‡§π ‡§π‡•à ‡§ï‡§ø ‡§∂‡•á‡§°‡§∞ ‡§Æ‡•á‡§Ç ‡§ï‡•á‡§µ‡§≤ ‡§™‡§æ‡§Å‡§ö ‡§™‡§æ‡§∏ ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§Ü‡§á‡§è ‡§π‡§Æ ‡§â‡§® ‡§™‡§∞ ‡§•‡•ã‡§°‡§º‡§æ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§Ç:</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§´‡•â‡§∞‡§µ‡§∞‡•ç‡§°‡§≤‡§ø‡§ü:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§´‡•â‡§∞‡§µ‡§∞‡•ç‡§° ‡§™‡§æ‡§∏, ‡§Ø‡§π‡§æ‡§Ç ‡§π‡§Æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∂, ‡§™‡•Ä‡§¨‡•Ä‡§Ü‡§∞ ‡§î‡§∞ ‡§ï‡•ã‡§π‡§∞‡•á ‡§™‡§∞ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§∂‡•à‡§°‡•ã‡§ï‡§æ‡§∏‡•ç‡§ü‡§∞:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§Ø‡§π‡§æ‡§Ç </font><b><font style="vertical-align: inherit;">‡§™‡§∞‡§õ‡§æ‡§á‡§Ø‡•ã‡§Ç</font></b><font style="vertical-align: inherit;"> ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§π‡•à‡•§</font></font></li><li> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§ó‡§π‡§∞‡§æ‡§à </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> ‡§ó‡§π‡§∞‡§æ‡§à (‡§ú‡•á‡§°-‡§¨‡§´‡§∞)‡•§</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Æ‡•á‡§ü‡§æ:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§¨‡•á‡§ï‡•ç‡§° ‡§≤‡§æ‡§á‡§ü (lightmaps)‡•§</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§≤‡§æ‡§á‡§ü‡§µ‡•á‡§ü 2 ‡§°‡•Ä:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§∏‡•ç‡§™‡•ç‡§∞‡§æ‡§á‡§ü‡•ç‡§∏ ‡§î‡§∞ ‡§Ø‡•Ç‡§Ü‡§à‡•§</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§á‡§∏‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ, ‡§è‡§ï‡§§‡§æ ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§ï‡§à ‡§Ö‡§≤‡§ó-‡§Ö‡§≤‡§ó ‡§∂‡•á‡§°‡§∞ ‡§ï‡§Ç‡§™‡§æ‡§á‡§≤‡§∞ ‡§î‡§∞ ‡§ï‡•ç‡§∞‡•â‡§∏ ‡§ï‡§Ç‡§™‡§æ‡§á‡§≤‡§∞ ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">SRP ‡§ï‡•ã HLSLcc ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡•§ </font><font style="vertical-align: inherit;">‡§ê‡§∏‡•á ‡§™‡•ç‡§≤‡•á‡§ü‡§´‡§º‡•â‡§∞‡•ç‡§Æ ‡§™‡§∞ ‡§ú‡•ã OpenGL ES ‡§ó‡•ç‡§∞‡§æ‡§´‡§º‡§ø‡§ï‡•ç‡§∏ API (‡§ú‡•à‡§∏‡•á Android) ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, HLSLcc ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§â‡§™‡§Ø‡•ã‡§ó ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§á‡§∏‡§≤‡§ø‡§è, ‡§π‡§Æ ‡§á‡§∏‡•á ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§ú‡§¨‡•Ç‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> prefer_hlslcc gles</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§≤‡•á‡§ï‡§ø‡§® DirectX 9 ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è ‡§á‡§∏‡•á ‡§ú‡§¨‡§∞‡§® ‡§Ö‡§ï‡•ç‡§∑‡§Æ ‡§ï‡§∞‡•á‡§Ç: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> exclude_renderers d3d11_9x</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§ï‡•ã‡§° ‡§≤‡§ø‡§ñ‡§®‡•á ‡§ï‡•á ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§Æ‡•á‡§Ç, ‡§ï‡•Å‡§õ ‡§≠‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§¶‡§≤‡§æ ‡§π‡•à, ‡§∏‡§ø‡§µ‡§æ‡§Ø ‡§á‡§∏‡§ï‡•á ‡§ï‡§ø ‡§Ö‡§¨ ‡§π‡§Æ ‡§∏‡•Ä‡§ú‡•Ä ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç, ‡§¨‡§≤‡•ç‡§ï‡§ø ‡§∂‡•Å‡§¶‡•ç‡§ß ‡§è‡§ö‡§è‡§≤‡§è‡§∏‡§è‡§≤ ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§ñ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç, ‡§î‡§∞ ‡§á‡§∏‡§≤‡§ø‡§è ‡§Ö‡§¨ ‡§∂‡•á‡§°‡§∞ ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ ‡§ï‡§æ ‡§∂‡§∞‡•Ä‡§∞ ‡§á‡§∏ ‡§§‡§∞‡§π ‡§¶‡§ø‡§ñ‡•á‡§ó‡§æ:</font></font><br><br><pre> <code class="cpp hljs">HLSLPROGRAM ... ENDHLSL</code> </pre> <br>   -       <b>_Time</b> , <b>_ScreenParams</b>  <b>_WorldSpaceCameraPos</b> .    ,     <i>UnityCG.cginc</i>   .        , ,  <b>UnityObjectToClipPos(POSITION)</b>  <b>TransformWorldToHClip(POSITION)</b> ,     ‚Äî  <b>UNITY_APPLY_FOG(fogCoord, color)</b>    <b>MixFog(color, fogCoord)</b> . <br><br> ,           Core.hlsl: <br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% localappdata% \ Unity \ cache \ package \ package.unity.com \ com.unity.render- ‡§™‡§æ‡§á‡§™‡§≤‡§æ‡§á‡§®‡•ã‡§Ç‡•§ ‡§≤‡§æ‡§á‡§ü‡§µ‡•á‡§ü @ (LWRP ‡§∏‡§Ç‡§∏‡•ç‡§ï‡§∞‡§£) \ ShaderLibrary \ Core.hlsl</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§π‡§Æ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ‡§ì‡§Ç ‡§ï‡•Ä ‡§™‡•Ç‡§∞‡•Ä ‡§∏‡•Ç‡§ö‡•Ä ‡§™‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§á‡§∏‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ ‡§â‡§≤‡•ç‡§≤‡•á‡§ñ ‡§ï‡•á ‡§≤‡§æ‡§Ø‡§ï ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§¨‡§´‡§º‡§∞‡•ç‡§∏ (CBUFFER) ‡§î‡§∞ UnityPerMaterial ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§¨‡§´‡§º‡§∞‡•ç‡§∏ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§°‡•á‡§ü‡§æ ‡§ï‡•ã ‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à, ‡§ú‡•ã ‡§ï‡§ø GPU ‡§™‡§∞ ‡§ï‡•ç‡§∞‡§Æ‡§∂‡§É ‡§¨‡§¶‡§≤ ‡§¶‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à, ‡§ï‡•ç‡§∞‡§Æ‡§∂‡§É ‡§á‡§®‡•ç‡§π‡•á‡§Ç shader ‡§µ‡•á‡§∞‡§ø‡§è‡§¨‡§≤‡•ç‡§∏ ‡§ï‡•ã ‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ </font><font style="vertical-align: inherit;">‡§ê‡§∏‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¨‡§∏ ‡§Æ‡•à‡§ï‡•ç‡§∞‡•ã‡§ú‡§º </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBUFFER_START</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§î‡§∞ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBUFFER_END ‡§ï‡•ã</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ï‡•â‡§≤ ‡§ï‡§∞‡•á‡§Ç </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; CBUFFER_END</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§µ‡•à‡§∂‡•ç‡§µ‡§ø‡§ï ‡§ö‡§∞ ‡§Ø‡§æ ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡•ç‡§∞‡§ø‡§ï ‡§∏‡•á‡§ü ‡§Ö‡§™ (‡§ï‡•ã‡§° ‡§Ø‡§æ ‡§è‡§®‡•Ä‡§Æ‡•á‡§∂‡§® ‡§∏‡•á, ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è) ‡§ï‡•Ä ‡§ò‡•ã‡§∑‡§£‡§æ ‡§™‡•Å‡§∞‡§æ‡§®‡•á ‡§¢‡§Ç‡§ó ‡§∏‡•á ‡§è‡§ï shader ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•á ‡§∂‡§∞‡•Ä‡§∞ ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§ú‡§ó‡§π ‡§≤‡•á‡§§‡§æ ‡§π‡•à‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LWRP ‡§¶‡•ã ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§®‡§ø‡§∞‡§Ç‡§§‡§∞ ‡§¨‡§´‡§º‡§∞‡•ç‡§∏ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§§‡§æ ‡§π‡•à - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityPerObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§î‡§∞ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityPerMaterial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡•§ ‡§á‡§® ‡§¨‡§´‡§º‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¨‡§æ‡§Å‡§ß ‡§¶‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§§‡§æ‡§ï‡§ø ‡§á‡§®‡•ç‡§π‡•á‡§Ç ‡§∞‡•á‡§Ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§ï‡•á ‡§¶‡•å‡§∞‡§æ‡§® ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡•á‡•§ ‡§Æ‡•ã‡§ü‡•á ‡§§‡•å‡§∞ ‡§™‡§∞, ‡§á‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•à ‡§ï‡§ø ‡§°‡•ç‡§∞‡§æ‡§á‡§Ç‡§ó ‡§ï‡•á ‡§¶‡•å‡§∞‡§æ‡§®, ‡§®‡§ø‡§∞‡§Ç‡§§‡§∞ ‡§¨‡§´‡§º‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§™‡•ç‡§∞‡§¨‡§≤‡§ø‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ ‡§Ø‡§æ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•á‡§ü‡§™‡§æ‡§∏ ‡§ï‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§¨‡•Å‡§≤‡§æ‡§Ø‡§æ ‡§ú‡§æ‡§è‡§ó‡§æ‡•§ ‡§Ø‡§π ‡§´‡§æ‡§Ø‡§¶‡•á‡§Æ‡§Ç‡§¶ ‡§π‡•à ‡§ú‡§¨ ‡§ï‡§à ‡§∂‡•á‡§°‡•ç‡§∏ ‡§è‡§ï ‡§π‡•Ä ‡§®‡§ø‡§∞‡§Ç‡§§‡§∞ ‡§¨‡§´‡§∞ ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø LWRP ‡§á‡§∏‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡§ø‡§≠‡§ø‡§®‡•ç‡§® ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§™‡•à‡§ï‡•á‡§ú ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§µ‡§æ‡§∏‡•ç‡§§‡§µ ‡§Æ‡•á‡§Ç, ‡§Ø‡§¶‡§ø ‡§Ü‡§™ ‡§ß‡•ç‡§Ø‡§æ‡§® ‡§∏‡•á ‡§∂‡•à‡§°‡§∞ ‡§ï‡•Ä ‡§∏‡§Ç‡§∞‡§ö‡§®‡§æ ‡§ï‡§æ ‡§Ö‡§ß‡•ç‡§Ø‡§Ø‡§® ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§§‡•ã ‡§Ü‡§™ ‡§™‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§ú‡•ç‡§Ø‡§æ‡§¶‡§æ‡§§‡§∞ ‡§Æ‡§æ‡§®‡§ï ‡§°‡•á‡§ü‡§æ ‡§π‡§∞ ‡§ú‡§ó‡§π ‡§®‡§ø‡§∞‡§Ç‡§§‡§∞ ‡§¨‡§´‡§∞ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Ö‡§ß‡§ø‡§ï ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§∏‡•á, ‡§∏‡§≠‡•Ä ‡§Æ‡§§‡§≠‡•á‡§¶‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç, ‡§≤‡•á‡§ï‡§ø‡§® ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡•Ä ‡§Æ‡•á‡§Ç, ‡§Ü‡§™ </font></font><a href="https://github.com/johnsietsma/ExtendingLWRP/wiki/LWRPShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Ø‡§π‡§æ‡§Ç</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§™‡§¢‡§º ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç </font><font style="vertical-align: inherit;">‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§µ‡•à‡§∏‡•á, ‡§Ö‡§ó‡§∞ ‡§Ü‡§™ ‡§∏‡§∞‡§´‡•á‡§∏‡§°‡§æ‡§ü‡§æ ‡§ï‡•ã ‡§ï‡§∞‡•Ä‡§¨ ‡§∏‡•á ‡§¶‡•á‡§ñ‡§§‡•á ‡§π‡•à‡§Ç:</font></font><br><pre> <code class="cpp hljs">SurfaceData surfaceData;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Ü‡§™ ‡§™‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§Ø‡§π </font><b><font style="vertical-align: inherit;">ShaderGraph</font></b><font style="vertical-align: inherit;"> ‡§∏‡•á </font><font style="vertical-align: inherit;">‡§™‡•ã‡§∑‡§ø‡§§ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PBR ‡§Æ‡§æ‡§∏‡•ç‡§ü‡§∞</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§π‡•à </font><font style="vertical-align: inherit;">‡•§</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><h4>  ‡§â‡§¶‡§æ‡§π‡§∞‡§£ </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§§‡•ã, ‡§Ö‡§¨ ‡§π‡§Æ‡§æ‡§∞‡•á ‡§π‡§æ‡§• ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§Ö‡§õ‡•Ç‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡§ø‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•à ‡§ï‡§ø </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§è‡§ï ‡§¨‡•à‡§ö‡•á‡§®‡§≤ ‡§ï‡•Ä ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§æ ‡§ï‡§∞‡§®‡•á </font><font style="vertical-align: inherit;">‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§Ü </font><font style="vertical-align: inherit;">‡§ó‡§Ø‡§æ ‡§π‡•à! </font><font style="vertical-align: inherit;">‡§Ü‡§á‡§è </font><font style="vertical-align: inherit;">‡§è‡§ï </font><font style="vertical-align: inherit;">‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á </font><font style="vertical-align: inherit;">‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§µ‡§∞‡•ç‡§ü‡•á‡§ï‡•ç‡§∏ ‡§µ‡§ø‡§∏‡•ç‡§•‡§æ‡§™‡§®</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§î‡§∞ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§≠‡§Ç‡§ó ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ú‡•ã‡§°‡§º‡•á‡§Ç </font><font style="vertical-align: inherit;">, ‡§î‡§∞ ‡§¨‡§æ‡§ï‡•Ä ‡§®‡•É‡§§‡•ç‡§Ø ‡§ï‡§∞‡•á‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§Ø‡§π ‡§¨‡§π‡•Å‡§§ ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ‡§ú‡§®‡§ï ‡§π‡•à ‡§ï‡§ø ‡§∏‡§≠‡•Ä ‡§™‡§æ‡§∏ ‡§π‡§Æ‡§æ‡§∞‡•Ä ‡§Ü‡§Ç‡§ñ‡•ã‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§Æ‡§®‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§π‡§Æ ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§¨‡§°‡§º‡•á ‡§™‡•à‡§Æ‡§æ‡§®‡•á ‡§™‡§∞ ‡§∏‡§Ç‡§™‡§æ‡§¶‡§ø‡§§ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ </font><font style="vertical-align: inherit;">‡§ó‡•Å‡§£‡•ã‡§Ç ‡§ï‡§æ ‡§µ‡§∞‡•ç‡§£‡§® ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç:</font></font><br><br> <a href="https://gifyu.com/image/q2wn" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/01d/ed6/8dd01ded67bfb91cc0e7e4f505276524.gif" alt="LVRP_TextShaders_2020-01-20_21-08-42.gif"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">Properties { ... _DissolveMap(<span class="hljs-string"><span class="hljs-string">"Dissolve Map"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _DissolveFactor(<span class="hljs-string"><span class="hljs-string">"Dissolve Factor"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> _DissolveWidth(<span class="hljs-string"><span class="hljs-string">"Dissolve Width"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [HDR]_DissolveColor(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§ú‡•ã ‡§®‡§ø‡§∏‡•ç‡§∏‡§Ç‡§¶‡•á‡§π ‡§®‡§ø‡§∞‡•Ä‡§ï‡•ç‡§∑‡§ï ‡§Æ‡•á‡§Ç ‡§π‡§Æ‡§æ‡§∞‡•á ‡§Ö‡§™‡§®‡•á ‡§î‡§∞ ‡§™‡•ç‡§∞‡§ø‡§Ø ‡§ü‡•à‡§¨ ‡§Æ‡•á‡§Ç ‡§¶‡§ø‡§ñ‡§æ‡§à ‡§¶‡•á‡§ó‡§æ: </font><font style="vertical-align: inherit;">‡§ö‡§∞ ‡§ú‡•ã‡§°‡§º‡•á‡§Ç:</font></font><br> <a href="https://gifyu.com/image/q23C" rel="nofollow"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/b11/b16/3eab11b16256aa0099e07e6172ba9557.png" alt="2020-01-20_22-55-14.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">CBUFFER_START(UnityPerMaterial) ... float4 _DissolveMap_ST; <span class="hljs-comment"><span class="hljs-comment">//    _DissolveMap CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á, ‡§∂‡§∞‡§æ‡§¨‡•Ä ‡§∂‡§∞‡§æ‡§¨‡•Ä ‡§ï‡•ã ‡§ú‡•ç‡§Ø‡§æ‡§Æ‡§ø‡§§‡§ø ‡§≠‡•á‡§ú‡•á‡§Ç: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LitPassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.positionOS.xyz += normalize(input.positionOS.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.positionOS.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§´‡§ø‡§∞ ‡§õ‡§æ‡§Ø‡§æ: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowPassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.positionOS.xyz += normalize(input.positionOS.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.positionOS.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ó‡§π‡§∞‡§æ‡§à: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Varyings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DepthOnlyVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attributes input)</span></span></span><span class="hljs-function"> </span></span>{ ... input.position.xyz += normalize(input.position.xyz) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input.position.x) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.x * <span class="hljs-number"><span class="hljs-number">100</span></span>); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ñ‡•à‡§∞, ‡§Ö‡§¨ ‡§∏‡§Æ‡§Ø ‡§î‡§∞ ‡§Ü‡§Ç‡§¶‡•ã‡§≤‡§® ‡§≠‡§Ç‡§ó: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LitPassFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Varyings input)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// UV   input.uv += _Time.x * 10; //     Dissolve  float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; //  bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; //    surfaceData.emission *= outline * _DissolveColor; //,    PBR-  half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); //      color *= lerp(1, _DissolveColor, outline); ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§Ü‡§™ ‡§õ‡§æ‡§Ø‡§æ ‡§Æ‡•á‡§Ç ‡§≠‡•Ä ‡§≠‡§Ç‡§ó ‡§ï‡•ã ‡§≤‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç, ‡§´‡§ø‡§∞ ‡§ï‡§≤‡§æ‡§à ‡§ï‡•Ä ‡§è‡§ï ‡§ù‡§ø‡§≤‡§Æ‡§ø‡§≤‡§æ‡§π‡§ü ‡§ï‡•á ‡§∏‡§æ‡§• ‡§π‡§Æ‡§æ‡§∞‡•á ‡§™‡§æ‡§∏ ‡§∏‡§π‡•Ä ‡§õ‡§æ‡§Ø‡§æ ‡§π‡•ã‡§ó‡•Ä, ‡§ú‡•ã ‡§ï‡§ø </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§∂‡•á‡§°‡§∞ ‡§ó‡•ç‡§∞‡§æ‡§´</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ </font><font style="vertical-align: inherit;">‡§ï‡§∞‡§®‡§æ ‡§ï‡§æ‡§´‡•Ä ‡§ï‡§†‡§ø‡§® </font><font style="vertical-align: inherit;">‡§π‡•à </font><font style="vertical-align: inherit;">, ‡§î‡§∞ ‡§Ø‡§π‡§æ‡§Ç ‡§ï‡•ã‡§° ‡§ï‡•Ä ‡§ï‡•Å‡§õ ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡§æ‡§Ç ‡§π‡•à‡§Ç‡•§</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowPassFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Varyings input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ ... float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask.r &gt; _DissolveFactor) discard; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§ñ‡•à‡§∞, ‡§Ö‡§Ç‡§§‡§ø‡§Æ shader ‡§ï‡•ã‡§°: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SimpleDissolve</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"TheProxor/LWRP/Dissolve + Vertex Offset"</span></span> { Properties { <span class="hljs-comment"><span class="hljs-comment">// Specular vs Metallic workflow [HideInInspector] _WorkflowMode("WorkflowMode", Float) = 1.0 [MainColor][HideInInspector] _BaseColor("Color", Color) = (0.5,0.5,0.5,1) [MainTexture][HideInInspector] _BaseMap("Albedo", 2D) = "white" {} [HideInInspector]_Cutoff("Alpha Cutoff", Range(0.0, 1.0)) = 0.5 [HideInInspector]_Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5 [HideInInspector]_GlossMapScale("Smoothness Scale", Range(0.0, 1.0)) = 1.0 [HideInInspector]_SmoothnessTextureChannel("Smoothness texture channel", Float) = 0 [Gamma][HideInInspector] _Metallic("Metallic", Range(0.0, 1.0)) = 0.0 [HideInInspector]_MetallicGlossMap("Metallic", 2D) = "white" {} [HideInInspector]_SpecColor("Specular", Color) = (0.2, 0.2, 0.2) [HideInInspector]_SpecGlossMap("Specular", 2D) = "white" {} [HideInInspector][ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0 [HideInInspector][ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0 [HideInInspector]_BumpScale("Scale", Float) = 1.0 [HideInInspector]_BumpMap("Normal Map", 2D) = "bump" {} [HideInInspector]_OcclusionStrength("Strength", Range(0.0, 1.0)) = 1.0 [HideInInspector]_OcclusionMap("Occlusion", 2D) = "white" {} [HDR][HideInInspector]_EmissionColor("Color", Color) = (0,0,0) [HideInInspector]_EmissionMap("Emission", 2D) = "white" {} // Blending state [HideInInspector] _Surface("__surface", Float) = 0.0 [HideInInspector] _Blend("__blend", Float) = 0.0 [HideInInspector] _AlphaClip("__clip", Float) = 0.0 [HideInInspector] _SrcBlend("__src", Float) = 1.0 [HideInInspector] _DstBlend("__dst", Float) = 0.0 [HideInInspector] _ZWrite("__zw", Float) = 1.0 [HideInInspector] _Cull("__cull", Float) = 2.0 [HideInInspector]_ReceiveShadows("Receive Shadows", Float) = 1.0 // Editmode props [HideInInspector] _QueueOffset("Queue offset", Float) = 0.0 // ObsoleteProperties [HideInInspector] _MainTex("BaseMap", 2D) = "white" {} [HideInInspector] _Color("Base Color", Color) = (0.5, 0.5, 0.5, 1) [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0 [HideInInspector] _Glossiness("Smoothness", Float) = 0.0 [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0 // _DissolveMap("Dissolve Map", 2D) = "white" {} _DissolveFactor("Dissolve Factor", Range(0, 1)) = 0.0 _DissolveWidth("Dissolve Width", Range(0, 1)) = 0.0 [HDR]_DissolveColor("Color", Color) = (1,1,0) } SubShader { // Lightweight Pipeline tag is required. If Lightweight render pipeline is not set in the graphics settings // this Subshader will fail. One can add a subshader below or fallback to Standard built-in to make this // material work with both Lightweight Render Pipeline and Builtin Unity Pipeline Tags{"RenderType" = "Opaque" "RenderPipeline" = "LightweightPipeline" "IgnoreProjector" = "True"} LOD 300 // ------------------------------------------------------------------ // Forward pass. Shades all light in a single pass. GI + emission + Fog Pass { // Lightmode matches the ShaderPassName set in LightweightRenderPipeline.cs. SRPDefaultUnlit and passes with // no LightMode tag are also rendered by Lightweight Render Pipeline Name "ForwardLit" Tags{"LightMode" = "LightweightForward"} Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard SRP library // All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _NORMALMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _OCCLUSIONMAP #pragma shader_feature _SPECULARHIGHLIGHTS_OFF #pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _RECEIVE_SHADOWS_OFF // ------------------------------------- // Lightweight Pipeline keywords #pragma multi_compile _ _MAIN_LIGHT_SHADOWS #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS #pragma multi_compile _ _SHADOWS_SOFT #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE // ------------------------------------- // Unity defined keywords #pragma multi_compile _ DIRLIGHTMAP_COMBINED #pragma multi_compile _ LIGHTMAP_ON #pragma multi_compile_fog //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma vertex LitPassVertex #pragma fragment LitPassFragment #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/SurfaceInput.hlsl" #ifdef _SPECULAR_SETUP #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_SpecGlossMap, sampler_SpecGlossMap, uv) #else #define SAMPLE_METALLICSPECULAR(uv) SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, uv) #endif struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float4 tangentOS : TANGENT; float2 texcoord : TEXCOORD0; float2 lightmapUV : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 1); #ifdef _ADDITIONAL_LIGHTS float3 positionWS : TEXCOORD2; #endif #ifdef _NORMALMAP half4 normalWS : TEXCOORD3; // xyz: normal, w: viewDir.x half4 tangentWS : TEXCOORD4; // xyz: tangent, w: viewDir.y half4 bitangentWS : TEXCOORD5; // xyz: bitangent, w: viewDir.z #else half3 normalWS : TEXCOORD3; half3 viewDirWS : TEXCOORD4; #endif half4 fogFactorAndVertexLight : TEXCOORD6; // x: fogFactor, yzw: vertex light #ifdef _MAIN_LIGHT_SHADOWS float4 shadowCoord : TEXCOORD7; #endif float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO float3 uvDissolve : TEXCOORD8; }; CBUFFER_START(UnityPerMaterial) float4 _BaseMap_ST; half4 _BaseColor; half4 _SpecColor; half4 _EmissionColor; half _Cutoff; half _Smoothness; half _Metallic; half _BumpScale; half _OcclusionStrength; float4 _DissolveMap_ST; //    _DissolveMap CBUFFER_END TEXTURE2D(_OcclusionMap); SAMPLER(sampler_OcclusionMap); TEXTURE2D(_MetallicGlossMap); SAMPLER(sampler_MetallicGlossMap); TEXTURE2D(_SpecGlossMap); SAMPLER(sampler_SpecGlossMap); TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float _DissolveFactor; float _DissolveWidth; float4 _DissolveColor; half4 SampleMetallicSpecGloss(float2 uv, half albedoAlpha) { half4 specGloss; #ifdef _METALLICSPECGLOSSMAP specGloss = SAMPLE_METALLICSPECULAR(uv); #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a *= _Smoothness; #endif #else // _METALLICSPECGLOSSMAP #if _SPECULAR_SETUP specGloss.rgb = _SpecColor.rgb; #else specGloss.rgb = _Metallic.rrr; #endif #ifdef _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A specGloss.a = albedoAlpha * _Smoothness; #else specGloss.a = _Smoothness; #endif #endif return specGloss; } half SampleOcclusion(float2 uv) { #ifdef _OCCLUSIONMAP // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Controls things like these by exposing SHADER_QUALITY levels (low, medium, high) #if defined(SHADER_API_GLES) return SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; #else half occ = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_OcclusionMap, uv).g; return LerpWhiteTo(occ, _OcclusionStrength); #endif #else return 1.0; #endif } inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData) { half4 albedoAlpha = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, uv); // half4 albedoAlpha = SampleAlbedoAlpha(uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)); outSurfaceData.alpha = Alpha(albedoAlpha.a, _BaseColor, _Cutoff); half4 specGloss = SampleMetallicSpecGloss(uv, albedoAlpha.a); outSurfaceData.albedo = albedoAlpha.rgb * _BaseColor.rgb; #if _SPECULAR_SETUP outSurfaceData.metallic = 1.0h; outSurfaceData.specular = specGloss.rgb; #else outSurfaceData.metallic = specGloss.r; outSurfaceData.specular = half3(0.0h, 0.0h, 0.0h); #endif outSurfaceData.smoothness = specGloss.a; outSurfaceData.normalTS = SampleNormal(uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap), _BumpScale); outSurfaceData.occlusion = SampleOcclusion(uv); outSurfaceData.emission = SampleEmission(uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap)); // outSurfaceData.emission = _EmissionColor.rgb * SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, uv); } void InitializeInputData(Varyings input, half3 normalTS, out InputData inputData) { inputData = (InputData)0; #ifdef _ADDITIONAL_LIGHTS inputData.positionWS = input.positionWS; #endif #ifdef _NORMALMAP half3 viewDirWS = half3(input.normalWS.w, input.tangentWS.w, input.bitangentWS.w); inputData.normalWS = TransformTangentToWorld(normalTS, half3x3(input.tangentWS.xyz, input.bitangentWS.xyz, input.normalWS.xyz)); #else half3 viewDirWS = input.viewDirWS; inputData.normalWS = input.normalWS; #endif inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS); viewDirWS = SafeNormalize(viewDirWS); inputData.viewDirectionWS = viewDirWS; #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) inputData.shadowCoord = input.shadowCoord; #else inputData.shadowCoord = float4(0, 0, 0, 0); #endif inputData.fogCoord = input.fogFactorAndVertexLight.x; inputData.vertexLighting = input.fogFactorAndVertexLight.yzw; inputData.bakedGI = SAMPLE_GI(input.lightmapUV, input.vertexSH, inputData.normalWS); } /////////////////////////////////////////////////////////////////////////////// // Vertex and Fragment functions // /////////////////////////////////////////////////////////////////////////////// //Standard (Physically Based) shader Varyings LitPassVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_TRANSFER_INSTANCE_ID(input, output); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.positionOS.xyz += sin(input.positionOS.x) * sin(_Time.x * 100); VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz); VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS); half3 viewDirWS = GetCameraPositionWS() - vertexInput.positionWS; half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS); half fogFactor = ComputeFogFactor(vertexInput.positionCS.z); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); #ifdef _NORMALMAP output.normalWS = half4(normalInput.normalWS, viewDirWS.x); output.tangentWS = half4(normalInput.tangentWS, viewDirWS.y); output.bitangentWS = half4(normalInput.bitangentWS, viewDirWS.z); #else output.normalWS = NormalizeNormalPerVertex(normalInput.normalWS); output.viewDirWS = viewDirWS; #endif OUTPUT_LIGHTMAP_UV(input.lightmapUV, unity_LightmapST, output.lightmapUV); OUTPUT_SH(output.normalWS.xyz, output.vertexSH); output.fogFactorAndVertexLight = half4(fogFactor, vertexLight); #ifdef _ADDITIONAL_LIGHTS output.positionWS = vertexInput.positionWS; #endif #if defined(_MAIN_LIGHT_SHADOWS) &amp;&amp; !defined(_RECEIVE_SHADOWS_OFF) output.shadowCoord = GetShadowCoord(vertexInput); #endif output.positionCS = vertexInput.positionCS; return output; } // Used in Standard (Physically Based) shader half4 LitPassFragment(Varyings input) : SV_Target { input.uv += _Time.x * 10; UNITY_SETUP_INSTANCE_ID(input); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); InputData inputData; InitializeInputData(input, surfaceData.normalTS, inputData); float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; bool outline = mask.r &gt; _DissolveFactor - _DissolveWidth; surfaceData.emission *= outline * _DissolveColor; half4 color = LightweightFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, surfaceData.emission, surfaceData.alpha); color *= lerp(1, _DissolveColor, outline); color.rgb = MixFog(color.rgb, inputData.fogCoord); return color; } ENDHLSL } // Pass { Name "ShadowCaster" Tags{"LightMode" = "ShadowCaster"} ZWrite On ZTest LEqual Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma vertex ShadowPassVertex #pragma fragment ShadowPassFragment #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Shadows.hlsl" float3 _LightDirection; struct Attributes { float4 positionOS : POSITION; float3 normalOS : NORMAL; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; }; CBUFFER_START(UnityPerMaterial) float4 _DissolveMap_ST; //    _DissolveMap float _DissolveFactor; CBUFFER_END TEXTURE2D(_DissolveMap); SAMPLER(sampler_DissolveMap); float4 GetShadowPositionHClip(Attributes input) { float3 positionWS = TransformObjectToWorld(input.positionOS.xyz); float3 normalWS = TransformObjectToWorldNormal(input.normalOS); float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection)); #if UNITY_REVERSED_Z positionCS.z = min(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #else positionCS.z = max(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE); #endif return positionCS; } Varyings ShadowPassVertex(Attributes input) { Varyings output; input.positionOS.xyz += normalize(input.positionOS.xyz) * sin(input.positionOS.x) * sin(_Time.x * 100); UNITY_SETUP_INSTANCE_ID(input); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = GetShadowPositionHClip(input); return output; } half4 ShadowPassFragment(Varyings input) : SV_TARGET { float4 mask = SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv); if (mask.r &gt; _DissolveFactor) discard; Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } ENDHLSL } Pass { Name "DepthOnly" Tags{"LightMode" = "DepthOnly"} ZWrite On ColorMask 0 Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma target 2.0 #pragma vertex DepthOnlyVertex #pragma fragment DepthOnlyFragment // ------------------------------------- // Material Keywords #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A //-------------------------------------- // GPU Instancing #pragma multi_compile_instancing #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl" #ifndef LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED #define LIGHTWEIGHT_DEPTH_ONLY_PASS_INCLUDED struct Attributes { float4 position : POSITION; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct Varyings { float2 uv : TEXCOORD0; float4 positionCS : SV_POSITION; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; Varyings DepthOnlyVertex(Attributes input) { Varyings output = (Varyings)0; UNITY_SETUP_INSTANCE_ID(input); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output); input.position.xyz += normalize(input.position.xyz) * sin(input.position.x) * sin(_Time.x * 100); output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap); output.positionCS = TransformObjectToHClip(input.position.xyz); return output; } half4 DepthOnlyFragment(Varyings input) : SV_TARGET { UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input); Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff); return 0; } #endif ENDHLSL } // Pass { Name "Meta" Tags{"LightMode" = "Meta"} Cull Off HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex LightweightVertexMeta #pragma fragment LightweightFragmentMeta #pragma shader_feature _SPECULAR_SETUP #pragma shader_feature _EMISSION #pragma shader_feature _METALLICSPECGLOSSMAP #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A #pragma shader_feature _SPECGLOSSMAP #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl" #ifndef LIGHTWEIGHT_LIT_META_PASS_INCLUDED #define LIGHTWEIGHT_LIT_META_PASS_INCLUDED Varyings LightweightVertexMeta(Attributes input) { Varyings output; output.positionCS = MetaVertexPosition(input.positionOS, input.uv1, input.uv2, unity_LightmapST, unity_DynamicLightmapST); output.uv = TRANSFORM_TEX(input.uv0, _BaseMap); return output; } half4 LightweightFragmentMeta(Varyings input) : SV_Target { SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); BRDFData brdfData; InitializeBRDFData(surfaceData.albedo, surfaceData.metallic, surfaceData.specular, surfaceData.smoothness, surfaceData.alpha, brdfData); MetaInput metaInput; metaInput.Albedo = brdfData.diffuse + brdfData.specular * brdfData.roughness * 0.5; metaInput.SpecularColor = surfaceData.specular; metaInput.Emission = surfaceData.emission; return MetaFragment(metaInput); } #endif ENDHLSL } Pass { Name "Lightweight2D" Tags{ "LightMode" = "Lightweight2D" } Blend[_SrcBlend][_DstBlend] ZWrite[_ZWrite] Cull[_Cull] HLSLPROGRAM // Required to compile gles 2.0 with standard srp library #pragma prefer_hlslcc gles #pragma exclude_renderers d3d11_9x #pragma vertex vert #pragma fragment frag #pragma shader_feature _ALPHATEST_ON #pragma shader_feature _ALPHAPREMULTIPLY_ON #include "Packages/com.unity.render-pipelines.lightweight/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.lightweight/Shaders/Utils/Lightweight2D.hlsl" ENDHLSL } } FallBack "Hidden/InternalErrorShader" CustomEditor "UnityEditor.Rendering.LWRP.ShaderGUI.LitShaderEditor" }</span></span></code> </pre></div></div><br><h4>  ‡§®‡§ø‡§∑‡•ç‡§ï‡§∞‡•ç‡§∑ </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§ñ‡•à‡§∞, ‡§Ø‡§π‡§æ‡§Å ‡§Ø‡§π ‡§∏‡•ç‡§ü‡•â‡§ï ‡§≤‡•á‡§®‡•á ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§π‡•à‡•§ </font><font style="vertical-align: inherit;">‡§ú‡•à‡§∏‡§æ ‡§ï‡§ø ‡§Ø‡§π ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à, LWRP ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§° ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∂‡•á‡§° ‡§≤‡§ø‡§ñ‡§®‡§æ ‡§∏‡§Ç‡§≠‡§µ ‡§î‡§∞ ‡§Ø‡§π‡§æ‡§Ç ‡§§‡§ï ‚Äã‚Äã‡§ï‡§ø ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§π‡•à, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ø‡§π ‡§Ü‡§™‡§ï‡•á ‡§π‡§æ‡§•‡•ã‡§Ç ‡§ï‡•ã ‡§¨‡§π‡•Å‡§§ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§¨‡•à‡§∏‡§æ‡§ñ‡•Ä ‡§ï‡•á ‡§¨‡§ø‡§®‡§æ ‡§∂‡§æ‡§Ç‡§§ ‡§ö‡•Ä‡§ú‡•ã‡§Ç ‡§ï‡•ã ‡§≤‡§ø‡§ñ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§Ü‡§™‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∂ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§æ‡•§ </font><font style="vertical-align: inherit;">‡§¨‡•á‡§∂‡§ï, ‡§Ø‡§π ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ‡§ú‡§®‡§ï ‡§î‡§∞ ‡§™‡§∞‡§ø‡§ö‡§ø‡§§ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§∏‡•ç‡§ü‡•à‡§Ç‡§°‡§∞‡•ç‡§° ‡§∏‡§∞‡§´‡•á‡§∏ ‡§∂‡•á‡§°‡§∞ ‡§ï‡•á</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‡§∏‡§æ‡§• ‡§§‡•Å‡§≤‡§®‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡•Ä ‡§ú‡§æ ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à </font><font style="vertical-align: inherit;">, ‡§≤‡•á‡§ï‡§ø‡§® ‡§∂‡§æ‡§Ø‡§¶ ‡§ï‡§ø‡§∏‡•Ä ‡§¶‡§ø‡§® ‡§Æ‡•Å‡§ù‡•á ‡§è‡§≤‡§°‡§¨‡•ç‡§≤‡•ç‡§Ø‡•Ç‡§Ü‡§∞‡§™‡•Ä ‡§î‡§∞ ‡§è‡§ö‡§°‡•Ä‡§Ü‡§∞‡§™‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§π‡•Ä ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ‡§ú‡§®‡§ï ‡§è‡§®‡§æ‡§≤‡•â‡§ó ‡§≤‡§ø‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§æ‡§• ‡§Æ‡§ø‡§≤‡•á‡§Ç‡§ó‡•á, ‡§≤‡•á‡§ï‡§ø‡§® ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§∏‡§Æ‡§Ø ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç‡•§ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§≤‡§ø‡§Ç‡§ï: </font></font><br><br> <a href="https://github.com/TheProxor/LWRP_TextShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§≤‡•á‡§ñ ‡§ï‡•Ä ‡§∏‡§≠‡•Ä ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•á ‡§∏‡§æ‡§• ‡§≠‡§Ç‡§°‡§æ‡§∞ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•Ä </font></font></a> <br> <a href="https://github.com/johnsietsma/ExtendingLWRP/wiki/LWRPShaders" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‡§§‡•à‡§Ø‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§¶‡•å‡§∞‡§æ‡§® ‡§Ø‡§π ‡§™‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ, ‡§Ö‡§®‡•å‡§™‡§ö‡§æ‡§∞‡§ø‡§ï ‡§™‡•ç‡§∞‡§≤‡•á‡§ñ‡§® </font></font></a> <br> <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.lightweight%406.9/api/UnityEngine.Experimental.Rendering.LWRP.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LWRP ‡§™‡•ç‡§∞‡§≤‡•á‡§ñ‡§®</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/hi485018/">https://habr.com/ru/post/hi485018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi485008/index.html">‡§∏‡§Ç‡§™‡§§‡•ç‡§§‡§ø ‡§ï‡•á ‡§∞‡•à‡§™‡§∞‡•ã‡§Ç ‡§ï‡•ã ‡§∏‡•ç‡§µ‡§ø‡§´‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç</a></li>
<li><a href="../hi485010/index.html">‡§∞‡•ã ‡§Æ‡§§, ‡§≤‡§°‡§º‡§ï‡•Ä! Habr√© ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§™‡§§‡•ç‡§∞ ‡§™‡§∞ vc.ru ‡§ï‡•á ‡§∏‡§æ‡§• ‡§≤‡•á‡§ñ‡§ï ‡§ï‡•ã ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç</a></li>
<li><a href="../hi485012/index.html">‡§ï‡•ã‡§° ‡§π‡•à‡§Ç‡§°‡§≤‡§ø‡§Ç‡§ó ‡§ï‡•ã ‡§∏‡§∞‡§≤ ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡§æ‡§µ‡§æ‡§∏‡•ç‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§ü ‡§î‡§∞ ‡§∞‡§ø‡§è‡§ï‡•ç‡§ü‡§ú ‡§Æ‡•á‡§Ç ‡§ï‡§Ç‡§ü‡•ç‡§∞‡•ã‡§≤ ‡§á‡§®‡§µ‡§∞‡•ç‡§∏‡§® ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞‡•á‡§Ç</a></li>
<li><a href="../hi485014/index.html">‡§ï‡•ç‡§Ø‡§æ ‡§Æ‡•Å‡§ù‡•á ‡§∏‡§æ‡§ï‡•ç‡§∑‡§æ‡§§‡•ç‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§∂‡§ø‡§ï‡§æ‡§Ø‡§§ ‡§ï‡§∞‡§®‡•Ä ‡§ö‡§æ‡§π‡§ø‡§è?</a></li>
<li><a href="../hi485016/index.html">‡§ö‡§Ø‡§®‡§ø‡§§ ‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏: ‡§¨‡•Ä‡§ü‡§æ ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à</a></li>
<li><a href="../hi485022/index.html">Playme ‡§∏‡§ø‡§ó‡•ç‡§Æ‡§æ: ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ‡§ï ‡§î‡§∞ ‡§∏‡§∏‡•ç‡§§‡•Ä DVR</a></li>
<li><a href="../hi485024/index.html">GraalVM ‡§∏‡§Ç‡§ï‡§≤‡§ï ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§® ‡§ï‡•á ‡§π‡•Å‡§° ‡§ï‡•á ‡§®‡•Ä‡§ö‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?</a></li>
<li><a href="../hi485026/index.html">‡§Ü‡§à‡§ü‡•Ä ‡§™‡•á‡§∂‡•á‡§µ‡§∞‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡•â‡§∞‡•ç‡§ú‡§ø‡§Ø‡§æ ‡§ï‡•á ‡§Ö‡§µ‡§∏‡§∞</a></li>
<li><a href="../hi485028/index.html">‡§∏‡•Ä‡§Ü‡§∞‡§è‡§Æ 2020</a></li>
<li><a href="../hi485030/index.html">‡§∂‡•Ä‡§∞‡•ç‡§∑ 8 IEO ‡§∂‡•Å‡§≤‡•ç‡§ï ‡§î‡§∞ ‡§Ö‡§¨ ‡§â‡§®‡§ï‡§æ ‡§™‡•Ç‡§Ç‡§ú‡•Ä‡§ï‡§∞‡§£</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>