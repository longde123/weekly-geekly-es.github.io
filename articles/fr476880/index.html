<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚤 👧🏿 🎯 Berceaux de sécurité: CSRF 🔪 ⛴️ 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malgré le fait que dans la dernière liste publiée des vulnérabilités des attaques CSRF OWASP Top 10 2017 sont classées comme «Supprimées, mais pas oub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berceaux de sécurité: CSRF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/476880/"><img src="https://habrastorage.org/webt/n2/kv/kj/n2kvkjqgxl8zvlq8y_sqcreecka.jpeg" alt="image"><br><br>  Malgré le fait que dans la dernière liste publiée des vulnérabilités des attaques CSRF OWASP Top 10 2017 sont classées comme «Supprimées, mais pas oubliées», nous avons décidé qu'il ne serait pas superflu de rappeler à nouveau comment se défendre contre les attaques CSRF, en s'appuyant sur celles les mêmes règles que celles fournies par l'OWASP. <br><a name="habracut"></a><br>  <u><b>Utilisation du jeton CSRF</b></u> <br><br>  L'utilisation d'un jeton (méthodes sans état et avec état) est la méthode de protection principale et la plus populaire.  Le jeton doit être unique pour chaque session utilisateur, généré par un générateur de nombres pseudo-aléatoires cryptographiquement robuste.  OWASP recommande également d'utiliser les algorithmes AES256-GCM et SHA256 / 512 pour le chiffrement lors de l'utilisation de HMAC. <br><br>  Il existe plusieurs approches pour travailler avec des jetons: jeton de synchronisation, modèle de jeton basé sur le chiffrement, jeton basé sur HMAC <br><br>  <b>Jeton de synchroniseur</b> <br><br>  En utilisant l'approche Synchronizer Token (méthode statefull), cela signifie envoyer un jeton à chaque demande, ce qui implique des modifications côté serveur.  Si le jeton n'est pas valide, le serveur rejette la demande. <br>  Lors de l'envoi d'une demande au serveur, il est recommandé d'ajouter un jeton aux paramètres de la demande plutôt qu'à l'en-tête.  Si vous insérez néanmoins un jeton dans l'en-tête de la demande, assurez-vous qu'il n'est pas enregistré sur le serveur.  Le jeton reçu peut être stocké <i>côté client dans un champ caché:</i> <br><br><pre><code class="java hljs">&lt;form action=<span class="hljs-string"><span class="hljs-string">"/post.php"</span></span> method=<span class="hljs-string"><span class="hljs-string">"post"</span></span>&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"hidden"</span></span> name=<span class="hljs-string"><span class="hljs-string">"CSRFToken"</span></span> value=<span class="hljs-string"><span class="hljs-string">"l5824xNMAYFesBxing975yR8HPJlHZ"</span></span>&gt; ... &lt;/form&gt;</code> </pre> <br><br>  <i>dans les en-têtes:</i> <br><br><pre> <code class="java hljs">POST /page HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Accept: application/json, application/xml, text/json, text/x-json, text/javascript, text/xml User-Agent: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (Windows NT <span class="hljs-number"><span class="hljs-number">10.0</span></span>; Win64; x64) AppleWebKit/<span class="hljs-number"><span class="hljs-number">537.36</span></span> (KHTML, like Gecko) Chrome/<span class="hljs-number"><span class="hljs-number">74.0</span></span>.3729.169 Safari/<span class="hljs-number"><span class="hljs-number">537.36</span></span> Content-Type: application/json Host: example.com X-CSRF-TOKEN: l5824xNMAYFesBxing975yR8HPJlHZ</code> </pre> <br><br>  <i>ou dans les cookies</i> <br><br><pre> <code class="java hljs">POST /page HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com Set-Cookie: CSRFToken=l5824xNMAYFesBxing975yR8HPJlHZ; Content-Type: application/x-www-form-urlencoded</code> </pre> <br><br>  OWASP recommande de stocker le jeton dans les en-têtes, expliquant que même si le jeton est ouvert ou expiré, l'attaquant ne pourra toujours pas simuler la demande, en raison des navigateurs. <br><br>  De plus, pour augmenter le niveau de sécurité de la méthode proposée, il est proposé de générer un nom de paramètre de jeton aléatoire et / ou le jeton lui-même pour chaque requête.  Avec cette approche, le temps pendant lequel l'attaquant peut utiliser le jeton volé est minimal.  Cependant, cela peut entraîner des problèmes de convivialité.  Par exemple, un clic sur le bouton «Retour» peut entraîner l'envoi d'un token invalide au serveur, qui était contenu sur la page précédente. <br><br>  L'envoi d'un jeton à l'aide d'une demande GET n'est pas recommandé, car avec cette approche, le jeton peut être révélé: dans l'historique du navigateur, les fichiers journaux, les en-têtes de référent. <br><br>  <b>Jeton basé sur le chiffrement</b> <br><br>  Cette approche est sans état, car elle utilise le chiffrement / déchiffrement pour valider le jeton et ne nécessite donc pas le stockage du jeton côté serveur. <br><br>  Le serveur génère un jeton composé d'un identifiant de session et d'un horodatage (pour empêcher une attaque de relecture).  Pour le chiffrement, il est recommandé d'utiliser l'algorithme de chiffrement AES256 en mode de chiffrement par bloc GSM / GSM-SIV.  L'utilisation du mode ECB est fortement déconseillée.  Le jeton chiffré par le serveur est retourné au client de la même manière que dans le cas de «Synchronizer Token» dans le champ de formulaire masqué ou dans l'en-tête / paramètre de réponse.  À la réception du jeton, le serveur doit le déchiffrer, puis vérifier l'identifiant de session et également vérifier l'horodatage avec l'heure actuelle et s'assurer qu'il ne dépasse pas la durée de vie du jeton définie. <br>  Si la vérification de l'identifiant de session réussit, mais pas la chronologie, la demande peut être considérée comme valide.  Dans tous les autres cas, il est recommandé de rejeter la demande et de l'enregistrer afin de mieux comprendre comment répondre à ces demandes. <br><br>  <b>Jeton basé sur HMAC</b> <b><br></b> <br>  Il ne nécessite pas non plus de stockage de jeton, le principe de fonctionnement est similaire au jeton basé sur le chiffrement, sauf qu'au lieu de chiffrer le jeton, la fonction HMAC (code d'authentification de message basé sur le hachage) est utilisée pour générer le jeton (il est recommandé d'utiliser SHA256 ou un algorithme plus puissant).  Dans ce cas, le jeton est le résultat de la fonction HMAC de l'identifiant de session utilisateur + horodatage. <br><br>  <b>Automatisation des jetons</b> <br><br>  Le principal problème dans la lutte contre les attaques CSRF est que les développeurs oublient souvent simplement d'ajouter des fonctionnalités pour travailler avec des jetons.  Pour éviter de tels problèmes, il vaut la peine d'automatiser ce processus: <br><br>  • écrire un wrapper qui ajoute automatiquement un jeton aux requêtes via la balise form ou lors de l'utilisation d'ajax.  Par exemple, Spring Security adopte une approche similaire chaque fois que la balise &lt;form: form&gt; est utilisée. <br><br>  • écrire un hook qui intercepte le trafic et ajoute des jetons à toutes les ressources vulnérables.  Puisqu'il est assez difficile d'analyser quelle demande le changement d'état effectue, nécessitant un jeton, il est recommandé d'inclure des jetons dans toutes les réponses POST, mais cela vaut la peine de considérer le coût des performances <br><br>  • ajouter automatiquement un jeton lors du rendu d'une page.  Cette approche est utilisée par CSRF Guard: des jetons sont ajoutés à tous les attributs href et src, aux champs cachés et dans toutes les formes <br><br>  Avant d'essayer d'écrire votre propre système de génération automatique de jetons, il est recommandé de préciser si le framework que vous utilisez a la capacité de fournir une protection contre les attaques CSRF par défaut.  Par exemple, le même framework Django implémente une protection contre CSRF. <br><br><br>  <b>Connexion CSRF</b> <br><br>  En utilisant CSRF dans le formulaire de connexion, un attaquant peut se connecter, <br>  déguisé en victime.  De telles vulnérabilités ont été rencontrées par des géants tels que PayPal et Google. <br>  Vous pouvez gérer CSRF dans le formulaire de connexion en créant des pré-sessions qui sont créées avant l'authentification de l'utilisateur et en incluant des jetons dans le formulaire de connexion. <br><br><br>  <b>Cookie Samesite</b> <br><br>  SameSite Cookie est un attribut décrit dans la RFC6265bis dont le but est de contrer les attaques CSRF.  Cela fonctionne comme suit.  L'une des méthodes de protection consiste à vérifier l'origine et les en-têtes de référent, grâce auxquels vous pouvez comprendre d'où provient la demande, mais cette approche nécessite la mise en œuvre d'un mécanisme de vérification.  En utilisant l'attribut SameSite, nous restreignons l'envoi de cookies avec une demande de ressources étrangères.  Cet attribut a plusieurs valeurs possibles: Strict, Lax et None. <br>  L'utilisation de la valeur stricte signifie que le navigateur n'enverra pas de cookies provenant de sources qui ne correspondent pas au nom de domaine de la ressource actuelle. <br>  La valeur lax permet de ne pas bloquer les cookies des ressources externes, dont la transition a été effectuée de manière sécurisée - en utilisant le protocole HTTPS.  Lax établit un équilibre entre convivialité et sécurité. <br><br>  La définition d'un attribut est assez simple: <br><br><pre> <code class="java hljs">Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax</code> </pre> <br><br>  Au moment de la rédaction, la prise en charge de l'attribut par les navigateurs ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/yv/ku/ck/yvkuckcnwzycekgofxa9t0kuoy4.png" alt="image"><br><br><br>  Il est important de se rappeler que cet attribut doit être utilisé comme mesure de protection supplémentaire et non comme un moyen de se passer de l'utilisation du jeton CSRF. <br><br>  <i>Vérification des en-têtes</i> <br><br>  Comme mentionné ci-dessus, l'une des méthodes de protection consiste à vérifier les valeurs de référence et d'origine de l'en-tête de demande. <br>  L'essence de cette vérification est de vérifier les valeurs des en-têtes côté serveur.  S'ils correspondent à la ressource, la demande est considérée comme correcte, sinon elle est rejetée.  Si l'en-tête Origin est manquant, vous devez vous assurer que la valeur Referrer correspond à la ressource actuelle.  OWASP recommande de rejeter les demandes qui ne contiennent pas d'en-têtes Origin ou Referrer.  Vous pouvez également enregistrer toutes ces demandes afin de les analyser plus tard et de décider comment les traiter. <br><br>  Cependant, les choses se compliquent si votre application se trouve derrière un serveur proxy, car l'URL dans l'en-tête sera différente.  Dans ce cas, il existe plusieurs options: <br>  • Configurez votre application afin de toujours connaître l'origine de la demande.  Le problème avec cette approche est de définir la bonne valeur si votre application est déployée dans plusieurs environnements (par exemple, dev, QA, production), ce qui conduit à un problème de support <br>  • utilisez l'en-tête Host.  Cet en-tête vous permettra de déterminer la source de la demande, quel que soit l'environnement. <br>  • utiliser l'en-tête X-Forwarded-Host, dont le but est de stocker les en-têtes d'origine reçus par le serveur proxy <br><br>  Toutes les méthodes décrites ne fonctionnent que lorsque les en-têtes d'origine et de référence sont présents.  Mais il y a des cas où ces en-têtes sont manquants.  Voici quelques cas où ces en-têtes ne sont pas inclus dans la demande: <br>  • IE 11 n'inclut pas l'en-tête Origin pour les sites de confiance.  Il ne reste plus qu'à s'appuyer sur l'en-tête Referer. <br>  • dans le cas d'une redirection, Origin n'est pas inclus dans la demande, car on pense qu'il peut contenir des informations confidentielles qui ne devraient pas être envoyées à une autre source <br>  • L'en-tête d'origine est activé pour toutes les demandes intersites, mais la plupart des navigateurs l'ajoutent uniquement pour les demandes POST / DELETE / PUT <br><br>  En règle générale, une petite quantité de trafic tombe dans les catégories décrites, mais souvent vous ne voulez pas perdre même cette petite partie d'utilisateurs, par conséquent, il est considéré comme valide de demander avec une valeur nulle pour origin / referrer ou avec une valeur correspondant à la liste des domaines de confiance. <br><br>  <b>Double soumettre le cookie</b> <b><br></b> <br>  Cette approche est assez simple à implémenter et ne nécessite pas de stockage du token côté serveur (sans état).  L'essence de la méthode est d'envoyer le jeton dans le paramètre de demande et dans les cookies par l'utilisateur.  Pour chaque demande nécessitant un changement d'état, nous vérifions la valeur du jeton dans les cookies et dans la demande.  Si la vérification de l'identifiant de session réussit, mais pas la chronologie, la demande peut être considérée comme valide <br><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476880/">https://habr.com/ru/post/fr476880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476870/index.html">Les mathématiciens commencent à apprivoiser le "problème du tournesol"</a></li>
<li><a href="../fr476872/index.html">Essais et économie de projet</a></li>
<li><a href="../fr476874/index.html">«Aujourd'hui, ICS ne protège ni l'entrefer ni les protocoles propriétaires» - entretien avec Vladimir Karantaev</a></li>
<li><a href="../fr476876/index.html">Tester l'idée d'une future application. Prétype. Ou comment économiser beaucoup d'argent</a></li>
<li><a href="../fr476878/index.html">Ampoules LED GP</a></li>
<li><a href="../fr476888/index.html">Quelles tendances UX-design suivre en 2020</a></li>
<li><a href="../fr476890/index.html">Pour ceux qui travaillent chez Houdini. À propos des cours Nature of Vex et Bites of Python</a></li>
<li><a href="../fr476900/index.html">Dispositif autonome sur Arduino, signalant une augmentation (diminution) de la température</a></li>
<li><a href="../fr476902/index.html">Barrymore, quel est le buzz autour de Voximplant? Sockets Web implémentés, monsieur</a></li>
<li><a href="../fr476904/index.html">Une autre simulation de bibliothèque</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>