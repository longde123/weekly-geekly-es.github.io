<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 🎂 🔖 Desenvolvimento de classes de interface em C ++ 💳 🧖🏼 🚭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As classes de interface são muito usadas em programas C ++. Infelizmente, porém, muitas vezes são cometidos erros na implementação de soluções baseada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de classes de interface em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>As classes de interface são muito usadas em programas C ++.</i>  <i>Infelizmente, porém, muitas vezes são cometidos erros na implementação de soluções baseadas em classes de interface.</i>  <i>O artigo descreve como projetar corretamente as classes da interface; várias opções são consideradas.</i>  <i>O uso de ponteiros inteligentes é descrito em detalhes.</i>  <i>Um exemplo da implementação de uma classe de exceção e um modelo de classe de coleção baseado em classes de interface é fornecido.</i> </p><hr><br><a name="habracut"></a><br><h1>  Sumário </h1><br><div class="spoiler">  <b class="spoiler_title">Sumário</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Funções-membro especiais, criando e excluindo objetos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções especiais para membros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando e excluindo objetos - detalhes básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nível de acesso do destruidor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crie e exclua em um módulo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deleção polimórfica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Excluindo quando a declaração de classe está incompleta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Funções puramente virtuais e classes abstratas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções virtuais puras</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classes abstratas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Destruidor virtual puro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Classes de interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementações</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação de Objetos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Excluir objeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o operador de exclusão</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando uma função virtual especial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando uma função externa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exclusão automática usando o ponteiro inteligente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outras opções para gerenciar o tempo de vida de uma instância de uma classe de implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Semântica de cópia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Construtor da classe de interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interação bidirecional</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.8</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros inteligentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.9</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções membro constantes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.10</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interfaces COM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.11</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classes e bibliotecas de interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Um exemplo de uma classe de interface e sua implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros inteligentes padrão</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação do lado do cliente</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação do lado da implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementação alternativa da classe base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Exceções e coleções implementadas usando classes de interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.1 Exceções</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.2 Colecções</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Classes de interface e classes de wrapper</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Resumo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Referências</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  1. Introdução </h1><br><p>  Uma classe de interface é uma classe que não possui dados e consiste principalmente em funções puramente virtuais.  Essa solução permite separar completamente a implementação da interface - o cliente usa a classe de interface - em outro local é criada uma classe derivada, na qual funções puramente virtuais são redefinidas e a função de fábrica é definida.  Os detalhes da implementação estão completamente ocultos do cliente.  Dessa maneira, o verdadeiro encapsulamento é implementado, o que é impossível com a classe usual.  Você pode ler sobre as classes de interface em Scott Meyers [Meyers2].  As classes de interface também são chamadas de classes de protocolo. </p><br><p>  O uso de classes de interface permite enfraquecer as dependências entre diferentes partes do projeto, o que simplifica o desenvolvimento da equipe e reduz o tempo de compilação / montagem.  As classes de interface facilitam a implementação de soluções flexíveis e dinâmicas quando os módulos são carregados seletivamente em tempo de execução.  O uso das classes de interface como uma biblioteca de interface (API) (SDK) simplifica a solução de problemas de compatibilidade binária. </p><br><p>  As classes de interface são usadas amplamente, com a ajuda de implementar a interface (API) de bibliotecas (SDK), a interface de plug-ins (plugins) e muito mais.  Muitos padrões do Gang of Four [GoF] são naturalmente implementados usando classes de interface.  As classes de interface incluem interfaces COM.  Infelizmente, porém, muitas vezes são cometidos erros na implementação de soluções baseadas em classes de interface.  Vamos tentar esclarecer esse problema. </p><br><a name="id-1"></a><br><h1>  1. Funções-membro especiais, criando e excluindo objetos </h1><br><p>  Esta seção descreve brevemente vários recursos do C ++ que você precisa conhecer para entender completamente as soluções oferecidas para as classes de interface. </p><br><a name="id-1-1"></a><br><h2>  1.1  Funções especiais para membros </h2><br><p>  Se o programador não definiu as funções de membro da classe da lista a seguir - construtor padrão, construtor de cópias, operador de atribuição de cópias, destruidor -, o compilador pode fazer isso por ele.  O C ++ 11 adicionou um construtor de movimentação e um operador de atribuição de movimentação a esta lista.  Essas funções de membro são chamadas de funções de membro especiais.  Eles são gerados apenas se forem usados ​​e condições adicionais específicas para cada função são atendidas.  Observe que esse uso pode se mostrar bastante oculto (por exemplo, ao implementar herança).  Se a função necessária não puder ser gerada, um erro será gerado.  (Com exceção das operações de realocação, elas são substituídas por operações de cópia.) As funções de membro geradas pelo compilador são públicas e incorporáveis. </p><br><p>  Funções-membro especiais não são herdadas; se uma função-membro especial for necessária na classe derivada, o compilador sempre tentará gerá-la; a presença da função-membro correspondente definida na classe base pelo programador não afeta isso. </p><br><p> O programador pode proibir a geração de funções-membro especiais; em C ++ 11, é necessário usar a construção <code>"=delete"</code> ao declarar; em C ++ 98, declarar a função de membro correspondente privada e não definir.  Na herança de classe, a proibição de gerar uma função de membro especial feita na classe base se aplica a todas as classes derivadas. </p><br><p>  Se o programador estiver confortável com as funções de membro geradas pelo compilador, no C ++ 11 ele poderá indicar isso explicitamente, e não apenas descartar a declaração.  Para fazer isso, você deve usar a construção <code>"=default"</code> ao declarar, enquanto o código é melhor lido e recursos adicionais aparecem relacionados ao gerenciamento do nível de acesso. </p><br><p>  Detalhes sobre funções-membro especiais podem ser encontrados em [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2  Criando e excluindo objetos - detalhes básicos </h2><br><p>  Criar e excluir objetos usando os operadores <code>new/delete</code> é uma operação típica de duas em uma.  Ao chamar <code>new</code> , a memória é alocada primeiro para o objeto.  Se a seleção for bem sucedida, o construtor é chamado.  Se o construtor lançar uma exceção, a memória alocada será liberada.  Quando o operador de <code>delete</code> é chamado, tudo acontece na ordem inversa: primeiro, o destruidor é chamado e a memória é liberada.  O destruidor não deve lançar exceções. </p><br><p>  Se o <code>new</code> operador for usado para criar uma matriz de objetos, a memória será alocada primeiro para toda a matriz.  Se a seleção for bem-sucedida, o construtor padrão será chamado para cada elemento da matriz começando do zero.  Se algum construtor lança uma exceção, para todos os elementos criados da matriz, o destruidor é chamado na ordem inversa da chamada do construtor, a memória alocada é liberada.  Para excluir uma matriz, você deve chamar o operador <code>delete[]</code> (chamado operador de <code>delete</code> para matrizes) e, para todos os elementos da matriz, o destruidor é chamado na ordem inversa do construtor e a memória alocada é liberada. </p><br><p>  Atenção!  Você deve chamar a forma correta do operador de <code>delete</code> , dependendo de um único objeto ou matriz ser excluído.  Essa regra deve ser observada rigorosamente, caso contrário, você poderá obter um comportamento indefinido, ou seja, tudo pode acontecer: vazamento de memória, falha etc.  Veja [Meyers2] para detalhes. </p><br><p>  As funções de alocação de memória padrão <code>std::bad_alloc</code> ao atender à solicitação, <code>std::bad_alloc</code> uma exceção do tipo <code>std::bad_alloc</code> . </p><br><p>  É seguro aplicar qualquer forma do operador de <code>delete</code> a um ponteiro nulo. </p><br><p>  Na descrição acima, é necessário um esclarecimento.  Para os chamados tipos triviais (tipos internos, estruturas no estilo C), o construtor não pode ser chamado e o destruidor não faz nada em nenhum caso.  Veja também a seção 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3  Nível de acesso do destruidor </h2><br><p>  Quando o operador de <code>delete</code> é aplicado a um ponteiro de uma classe, o destruidor dessa classe deve estar disponível no ponto de chamada de <code>delete</code> .  (Existe alguma exceção a esta regra, discutida na Seção 1.6.) Assim, ao tornar o destruidor seguro ou fechado, o programador proíbe o uso do operador de <code>delete</code> onde o destruidor não está disponível.  Lembre-se de que, se nenhum destruidor estiver definido na classe, o compilador fará isso por conta própria e esse destruidor estará aberto (consulte a seção 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4  Crie e exclua em um módulo </h2><br><p>  Se o <code>new</code> operador criou um objeto, o operador de <code>delete</code> deve estar no mesmo módulo para <code>delete</code> lo.  Figurativamente falando, "coloque-o onde você o levou".  Essa regra é bem conhecida, veja, por exemplo, [Sutter / Alexandrescu].  Se essa regra for violada, poderá ocorrer “incompatibilidade” das funções de alocação e liberação de memória, o que, via de regra, leva a um encerramento anormal do programa. </p><br><a name="id-1-5"></a><br><h2>  1.5  Deleção polimórfica </h2><br><p>  Se você estiver projetando uma hierarquia polimórfica de classes cujas instâncias são excluídas usando o operador <code>delete</code> , deve haver um destruidor virtual aberto na classe base, isso garante que o destruidor do tipo real do objeto seja chamado quando o operador de <code>delete</code> for aplicado ao ponteiro da classe base.  Se essa regra for violada, poderá ocorrer uma chamada para o destruidor da classe base, o que pode levar a um vazamento de recurso. </p><br><a name="id-1-6"></a><br><h2>  1.6  Excluindo quando a declaração de classe está incompleta </h2><br><p>  A onívora do operador de <code>delete</code> pode criar certos problemas; pode ser aplicada a um ponteiro do tipo <code>void*</code> ou a um ponteiro para uma classe que possui uma declaração incompleta (preemptiva).  Nesse caso, um erro não ocorre, apenas a chamada para o destruidor é ignorada, apenas a função para liberar a memória é chamada.  Considere um exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Esse código é compilado mesmo se uma declaração completa da classe <code>X</code> não estiver disponível no ponto de discagem de <code>delete</code> .  Verdadeiro, ao compilar (Visual Studio) um aviso é emitido: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  Se houver uma implementação de <code>X</code> e <code>CreateX()</code> , o código será <code>CreateX()</code> ; se <code>CreateX()</code> retornar um ponteiro para o objeto criado pelo <code>new</code> operador, a chamada <code>Foo()</code> executada com êxito, o destruidor não será chamado.  É claro que isso pode levar a uma drenagem de recursos, portanto, mais uma vez, sobre a necessidade de ter cuidado com os avisos. </p><br><p>  Essa situação não é exagerada, pode surgir facilmente ao usar classes como ponteiros inteligentes ou classes de descritores.  Scott Meyers lida com esse problema em [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Funções puramente virtuais e classes abstratas </h1><br><p>  O conceito de classes de interface é baseado em conceitos de C ++, como funções virtuais puras e classes abstratas. </p><br><a name="id-2-1"></a><br><h2>  2.1  Funções virtuais puras </h2><br><p>  Uma função virtual declarada usando a construção <code>"=0"</code> é chamada virtual pura. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  Diferentemente de uma função virtual regular, uma função puramente virtual não pode ser definida (com exceção do destruidor, consulte a seção 2.3), mas deve ser redefinida em uma das classes derivadas. </p><br><p>  Funções puramente virtuais podem ser definidas.  O emblema Sutter oferece vários usos úteis para esse recurso [Obturador]. </p><br><a name="id-2-2"></a><br><h2>  2.2  Classes abstratas </h2><br><p>  Uma classe abstrata é uma classe que possui pelo menos uma função puramente virtual.  Uma classe que é derivada de uma classe abstrata e não substitui pelo menos uma função puramente virtual também será abstrata.  O padrão C ++ proíbe a criação de instâncias de uma classe abstrata; você só pode criar instâncias de derivadas de classes não abstratas.  Assim, uma classe abstrata é criada para ser usada como classe base.  Portanto, se um construtor é definido em uma classe abstrata, não faz sentido abri-lo, ele deve ser protegido. </p><br><a name="id-2-3"></a><br><h2>  2.3  Destruidor virtual puro </h2><br><p>  Em alguns casos, é aconselhável criar um destruidor virtual puro.  Mas esta solução tem dois recursos. </p><br><ol><li>  Um destruidor puramente virtual deve ser definido.  (A definição padrão geralmente é usada, ou seja, usando a construção <code>"=default"</code> .) O destruidor de classe derivado chama destruidores de classe base ao longo de toda a cadeia de herança e, portanto, a fila é garantida para atingir a raiz - um destruidor puramente virtual. </li><li>  Se o programador não redefiniu um destruidor virtual puro na classe derivada, o compilador fará isso por ele (consulte a seção 1.1).  Assim, uma classe derivada de uma classe abstrata com um destruidor puramente virtual pode perder sua abstração sem substituir explicitamente o destruidor. </li></ol><br><p>  Um exemplo de uso de um destruidor virtual puro pode ser encontrado na seção 4.4. </p><br><a name="id-3"></a><br><h1>  3. Classes de interface </h1><br><p>  Uma classe de interface é uma classe abstrata que não possui dados e consiste principalmente em funções puramente virtuais.  Essa classe pode ter funções virtuais comuns (não puramente virtuais), por exemplo, um destruidor.  Também pode haver funções membro estáticas, como funções de fábrica. </p><br><a name="id-3-1"></a><br><h2>  3.1  Implementações </h2><br><p>  Uma implementação de uma classe de interface será chamada de classe derivada na qual funções puramente virtuais são redefinidas.  Pode haver várias implementações da mesma classe de interface, e dois esquemas são possíveis: horizontal, quando várias classes diferentes herdam a mesma classe de interface, e vertical, quando a classe de interface é a raiz da hierarquia polimórfica.  Claro, pode haver híbridos. </p><br><p>  O ponto principal do conceito de classe de interface é a separação completa da interface da implementação - o cliente trabalha apenas com a classe de interface, a implementação não está disponível para ela. </p><br><a name="id-3-2"></a><br><h2>  3.2  Criação de Objetos </h2><br><p>  A inacessibilidade da classe de implementação causa certos problemas ao criar objetos.  O cliente deve criar uma instância da classe de implementação e obter um ponteiro para a classe da interface através da qual o objeto será acessado.  Como a classe de implementação não está disponível, você não pode usar o construtor, portanto, a função de fábrica é usada, definida no lado da implementação.  Essa função geralmente cria um objeto usando o <code>new</code> operador e retorna um ponteiro para o objeto criado, convertido em um ponteiro para uma classe de interface.  Uma função de fábrica pode ser um membro estático de uma classe de interface, mas não é necessário, por exemplo, pode ser um membro de uma classe de fábrica especial (que, por sua vez, pode ser uma classe de interface) ou uma função livre.  Uma função de fábrica pode retornar não um ponteiro bruto para uma classe de interface, mas um inteligente.  Esta opção é discutida nas seções 3.3.4 e 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3  Excluir objeto </h2><br><p>  A remoção de um objeto é uma operação extremamente crítica.  Um erro resulta em um vazamento de memória ou em uma exclusão dupla, o que geralmente leva a uma falha no programa.  Abaixo, esse problema é considerado o mais detalhado possível, com muita atenção sendo prestada à prevenção de ações errôneas do cliente. </p><br><p>  Existem quatro opções principais: </p><br><ol><li>  Usando o operador de <code>delete</code> . </li><li>  Usando uma função virtual especial. </li><li>  Usando uma função externa. </li><li>  Exclusão automática usando o ponteiro inteligente. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1  Usando o operador de <code>delete</code> <br></h3><br><p>  Para fazer isso, você deve ter um destruidor virtual aberto na classe de interface.  Nesse caso, o operador de <code>delete</code> , chamado de um ponteiro para uma classe de interface no lado do cliente, fornece uma chamada ao destruidor da classe de implementação.  Essa opção pode funcionar, mas é difícil reconhecê-la como bem-sucedida.  Recebemos chamadas dos operadores <code>new</code> e <code>delete</code> em diferentes lados da “barreira”, <code>new</code> no lado da implementação e <code>delete</code> no lado do cliente.  E se a implementação da classe de interface for feita em um módulo separado (o que é bastante comum), obteremos uma violação da regra na seção 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2  Usando uma função virtual especial </h3><br><p>  Mais progressiva é outra opção: a classe de interface deve ter uma função virtual especial que remova o objeto.  Essa função, no final, se resume a chamar <code>delete this</code> , mas isso já está acontecendo no lado da implementação.  Essa função pode ser chamada de maneiras diferentes, por exemplo, <code>Delete()</code> , mas outras opções também são usadas: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , etc.  Além de seguir a regra na seção 1.4, esta opção tem várias vantagens adicionais. </p><br><ol><li>  Permite usar funções de alocação / desalocação de memória definidas pelo usuário para a classe de implementação. </li><li>  Permite implementar um esquema mais complexo para controlar a vida útil do objeto de implementação, por exemplo, usando um contador de referência. </li></ol><br><p>  Nesta modalidade, uma tentativa de excluir um objeto usando o operador de <code>delete</code> pode ser compilada e até executada, mas isso é um erro.  Para evitá-lo na classe de interface, basta ter um destruidor protegido vazio ou puramente virtual (consulte a seção 1.3).  Observe que o uso do operador de <code>delete</code> pode ser bastante mascarado, por exemplo, ponteiros inteligentes padrão usam o operador de exclusão para excluir um objeto por padrão e o código correspondente está profundamente oculto em sua implementação.  Um destruidor protegido permite detectar todas essas tentativas no estágio de compilação. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3  Usando uma função externa </h3><br><p>  Essa opção pode atrair uma certa simetria de procedimentos para criar e excluir um objeto, mas, na realidade, não possui vantagens em relação à versão anterior, mas há muitos problemas adicionais.  Esta opção não é recomendada para uso e não é considerada no futuro. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4  Exclusão automática usando o ponteiro inteligente </h3><br><p>  Nesse caso, a função de fábrica não retorna um ponteiro bruto para uma classe de interface, mas um ponteiro inteligente correspondente.  Esse ponteiro inteligente é criado no lado da implementação e encapsula o objeto de exclusão, que exclui automaticamente o objeto de implementação quando o ponteiro inteligente (ou sua última cópia) fica fora do escopo no lado do cliente.  Nesse caso, uma função virtual especial para excluir o objeto de implementação pode não ser necessária, mas ainda é necessário um destruidor protegido; é necessário evitar o uso incorreto do operador de <code>delete</code> .  (É verdade, deve-se notar que a probabilidade de um erro desse tipo é visivelmente reduzida.) Essa opção é discutida em mais detalhes na Seção 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4  Outras opções para gerenciar o tempo de vida de uma instância de uma classe de implementação </h2><br><p>  Em alguns casos, o cliente pode receber um ponteiro para a classe da interface, mas não a possui.  O gerenciamento da vida útil do objeto de implementação é totalmente do lado da implementação.  Por exemplo, um objeto pode ser um objeto singleton estático (essa solução é típica para fábricas).  Outro exemplo está relacionado à interação bidirecional, consulte a seção 3.7.  O cliente não deve excluir esse objeto, mas é necessário um destruidor protegido para essa classe de interface; é necessário evitar o uso incorreto do operador de <code>delete</code> . </p><br><a name="id-3-5"></a><br><h2>  3.5  Semântica de cópia </h2><br><p>  Para uma classe de interface, a criação de uma cópia do objeto de implementação usando o construtor de cópia não é possível; portanto, se a cópia for necessária, a classe deverá ter uma função virtual que crie uma cópia do objeto de implementação e retorne um ponteiro para a classe de interface.  Essa função é geralmente chamada de construtor virtual e seu nome tradicional é <code>Clone()</code> ou <code>Duplicate()</code> . </p><br><p>  O uso do operador de atribuição de cópias não é proibido, mas não pode ser considerado uma boa ideia.  O operador de atribuição de cópia está sempre emparelhado; deve ser emparelhado com o construtor de cópias.  O operador gerado pelo compilador padrão não faz sentido; não faz nada.  É teoricamente possível declarar um operador de atribuição puramente virtual com redefinição subsequente, mas a atribuição virtual não é uma prática recomendada; detalhes podem ser encontrados em [Meyers1].  Além disso, a atribuição parece muito antinatural: o acesso aos objetos da classe de implementação geralmente é feito através de um ponteiro para a classe de interface, portanto, a atribuição terá a seguinte aparência: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  É melhor proibir o operador de atribuição e, se necessário, essa semântica tem na classe de interface a função virtual correspondente. </p><br><p>  Existem duas maneiras de proibir a atribuição. </p><br><ol><li>  Declare o operador de atribuição excluído ( <code>=delete</code> ).  Se as classes de interface formam uma hierarquia, isso é suficiente na classe base.  A desvantagem desse método é que ele afeta a classe de implementação, a proibição também se aplica a ele. </li><li>  Declare uma instrução de atribuição protegida com uma definição padrão ( <code>=default</code> ).  Isso não afeta a classe de implementação, mas no caso de uma hierarquia de classes de interface, esse anúncio deve ser feito em cada classe. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6  Construtor da classe de interface </h2><br><p>  Freqüentemente, o construtor de uma classe de interface não é declarado.  Nesse caso, o compilador gera o construtor padrão necessário para implementar a herança (consulte a seção 1.1).  Este construtor é aberto, embora o suficiente para ser seguro.  Se na classe de interface o construtor de cópia for declarado excluído ( <code>=delete</code> ), a geração pelo compilador do construtor será suprimida por padrão, e esse construtor deverá ser declarado explicitamente.  É natural torná-lo seguro com uma definição padrão ( <code>=default</code> ).  Em princípio, a declaração de um construtor protegido pode sempre ser feita.  Um exemplo está na seção 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7  Interação bidirecional </h2><br><p>  As classes de interface são convenientes para o uso da comunicação bidirecional.  Se algum módulo estiver acessível através de classes de interface, o cliente também poderá criar implementações de algumas classes de interface e passar ponteiros para elas no módulo.  Por meio desses ponteiros, o módulo pode receber serviços do cliente e também transmitir dados ou notificações ao cliente. </p><br><a name="id-3-8"></a><br><h2>  3.8  Ponteiros inteligentes </h2><br><p>  Como o acesso a objetos da classe de implementação geralmente é feito por meio de um ponteiro, é natural usar ponteiros inteligentes para controlar sua vida útil.  Porém, deve-se ter em mente que, se a segunda opção para excluir objetos for usada, com o ponteiro inteligente padrão é necessário transferir um deleter (tipo) ou uma instância desse tipo.  Se isso não for feito, o ponteiro inteligente usará o operador <code>delete</code> para excluir o objeto, e o código simplesmente não será compilado (graças ao destruidor protegido).  Ponteiros inteligentes padrão (incluindo o uso de removedores personalizados) são discutidos em detalhes em [Josuttis], [Meyers3].  Um exemplo de uso de um removedor personalizado pode ser encontrado na seção 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2> 3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2> 3.10. COM- </h2><br><p> COM-    ,     ,  COM —      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2> 3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     — -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4     </h2><br><p>    C#  Java  C++    «»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       — .NET —  , —          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. Métodos de design orientado a objetos. </font><font style="vertical-align: inherit;">Padrões de design.: Por. </font><font style="vertical-align: inherit;">do inglês </font><font style="vertical-align: inherit;">- São Petersburgo: Peter, 2001.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. Biblioteca padrão C ++: Reference Guide, 2a ed.: Per. </font><font style="vertical-align: inherit;">do inglês </font><font style="vertical-align: inherit;">- M .: LLC “I.D. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dewhurst] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dewhurst, Stefan K. Slippery coloca C ++. </font><font style="vertical-align: inherit;">Como evitar problemas ao projetar e compilar seus programas. </font><font style="vertical-align: inherit;">do inglês </font><font style="vertical-align: inherit;">- M .: DMK Press, 2012.</font></font></p><br><p> [Meyers1] <br> , .    C++. 35        .: .  . — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  . — .:  «.. », 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427281/">https://habr.com/ru/post/pt427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427271/index.html">História e experiência do uso de tradução automática. Palestra Yandex</a></li>
<li><a href="../pt427273/index.html">A inteligência artificial pode deixar as casas de apostas sem trabalho?</a></li>
<li><a href="../pt427275/index.html">Arquitetura de informações da Internet, parte 3</a></li>
<li><a href="../pt427277/index.html">Um padrão de difração é encontrado na distribuição dos primos, semelhante aos quasicristais</a></li>
<li><a href="../pt427279/index.html">CoLaboratory: Noite do Android # Apple</a></li>
<li><a href="../pt427283/index.html">Como é garantida a alta disponibilidade no Kubernetes</a></li>
<li><a href="../pt427285/index.html">Escola básica de circuitos digitais: Novosibirsk - Ok, Krasnoyarsk - prepare-se</a></li>
<li><a href="../pt427289/index.html">Modelagem Geológica 3D, Registro e Tecnologia da Aramco Innovations</a></li>
<li><a href="../pt427291/index.html">Minimize o tráfego nos formulários da Web do ASP.NET, div clicável e pesquisas periódicas no servidor</a></li>
<li><a href="../pt427293/index.html">Padrões de Design JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>