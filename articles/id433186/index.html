<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•Ÿ ğŸ‘§ğŸ¼ ğŸ’†ğŸ½ Tidak cukup hanya dengan menghitung poligon untuk mengoptimalkan model 3D ğŸ§™ â¡ï¸ ğŸ›‹ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah memahami dasar-dasar proses rendering mesh, Anda dapat menerapkan berbagai teknik untuk mengoptimalkan kecepatan rendering. 

 Pendahuluan 
 B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tidak cukup hanya dengan menghitung poligon untuk mengoptimalkan model 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433186/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png" alt="gambar"></div><br>  Setelah memahami dasar-dasar proses rendering mesh, Anda dapat menerapkan berbagai teknik untuk mengoptimalkan kecepatan rendering. <br><br><h2>  Pendahuluan </h2><br>  Berapa banyak poligon yang bisa saya gunakan?  Ini adalah pertanyaan yang sangat umum yang ditanyakan seniman saat membuat model untuk render waktu-nyata.  Pertanyaan ini sulit dijawab, karena bukan hanya soal angka. <br><br>  Saya memulai karir saya sebagai seniman 3D di era PlayStation pertama, dan kemudian menjadi seorang programmer grafis.  Saya ingin membaca artikel ini sebelum saya mulai membuat model 3D untuk game.  Fondasi fundamental yang dipertimbangkan di dalamnya bermanfaat bagi banyak seniman.  Meskipun sebagian besar informasi dalam artikel ini tidak akan secara signifikan mempengaruhi produktivitas pekerjaan harian Anda, ini akan memberi Anda pemahaman dasar tentang bagaimana unit pemrosesan grafis (GPU) membuat jerat yang Anda buat. <br><br>  Kecepatan rendering biasanya tergantung pada jumlah poligon di mesh.  Namun, meskipun jumlah poligon sering berkorelasi dengan frame rate per detik (FPS), Anda mungkin menemukan bahwa bahkan setelah mengurangi jumlah poligon, mesh masih merender perlahan.  Tetapi dengan memahami bagaimana jerat dirender secara umum, Anda dapat menerapkan serangkaian teknik untuk meningkatkan kecepatan rendering. <br><a name="habracut"></a><br><h2>  Bagaimana data poligon disajikan </h2><br>  Untuk memahami cara GPU menggambar poligon, Anda harus terlebih dahulu mempertimbangkan struktur data yang digunakan untuk menggambarkan poligon.  Poligon terdiri dari sekumpulan titik yang disebut simpul dan tautan.  Verteks sering disimpan sebagai array nilai, misalnya, seperti Gambar 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb1/c94/4ffcb1c945c51025a430d752e475b1c3.png"></div><br>  <i>Gambar 1. Array nilai poligon sederhana.</i> <br><br>  Dalam hal ini, empat simpul dalam tiga dimensi (x, y dan z) memberi kita 12 nilai.  Untuk membuat poligon, array nilai kedua menggambarkan simpul itu sendiri, seperti yang ditunjukkan pada Gambar 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/1c9/3eb/01d1c93eb3645689d0d30de75b0ea524.png"></div><br>  <i>Gambar 2. Array tautan ke simpul.</i> <br><br>  Titik-titik ini terhubung bersama membentuk dua poligon.  Perhatikan bahwa dua segitiga, masing-masing dengan tiga sudut, dapat dijelaskan oleh empat simpul, karena simpul 1 dan 2 digunakan di kedua segitiga.  Agar GPU memproses data ini, diasumsikan bahwa setiap poligon berbentuk segitiga.  GPU mengharapkan Anda untuk bekerja dengan segitiga karena dirancang khusus untuk menggambarnya.  Jika Anda perlu menggambar poligon dengan jumlah simpul yang berbeda, maka Anda memerlukan aplikasi yang membaginya menjadi segitiga sebelum dirender ke GPU.  Misalnya, jika Anda membuat kubus enam poligon, masing-masing memiliki empat sisi, maka ini tidak lebih efektif daripada membuat kubus 12 poligon yang terdiri dari tiga sisi;  segitiga inilah yang akan digambar GPU.  Ingat aturannya: Anda tidak perlu menghitung poligon, tetapi segitiga. <br><br>  Data vertex yang digunakan dalam contoh sebelumnya adalah tiga dimensi, tetapi ini tidak perlu.  Dua dimensi mungkin cukup untuk Anda, tetapi sering kali Anda perlu menyimpan data lain, misalnya, koordinat UV untuk tekstur dan normal untuk penerangan. <br><br><h2>  Gambar poligon </h2><br>  Saat merender poligon, GPU terlebih dahulu menentukan di mana menggambar poligon.  Untuk melakukan ini, ia menghitung posisi di layar di mana tiga simpul seharusnya.  Operasi ini disebut transform.  Perhitungan ini dalam GPU dilakukan oleh program kecil yang disebut vertex shader. <br><br>  Vertex shader sering melakukan operasi jenis lain, seperti memproses animasi.  Setelah menghitung posisi ketiga simpul poligon, GPU menghitung piksel mana yang ada dalam segitiga ini, dan kemudian mulai mengisi piksel ini dengan program kecil lain yang disebut "fragment shader" (fragment shader).  Sebuah shader fragmen biasanya dieksekusi satu kali per piksel.  Namun, dalam beberapa kasus yang jarang, ini dapat dilakukan beberapa kali per piksel, misalnya, untuk meningkatkan anti-aliasing.  Fragmen shaders sering disebut pixel shaders, karena dalam banyak kasus fragmen berhubungan dengan piksel (lihat Gambar 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/5e6/4cc/16c5e64cc4daec8ceef7264fce4b8a08.png"></div><br>  <i>Gambar 3. Satu poligon digambar di layar.</i> <br><br>  Gambar 4 menunjukkan urutan tindakan yang dilakukan oleh GPU saat merender poligon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/c60/8d2/87cc608d2ac63afc4c818b824bc11fb5.png"></div><br>  <i>Gambar 4. Urutan GPU yang membuat poligon.</i> <br><br>  Jika Anda membagi segitiga menjadi dua dan menggambar kedua segitiga (lihat Gambar 5), maka prosedur akan sesuai dengan Gambar 6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/34a/521/19a34a521bdd7ace482a8a1defb8c926.png"></div><br>  <i>Gambar 5. Pembagian poligon menjadi dua.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/16c/07c/d0c16c07ce793e36aaa40e237ad60d78.png"></div><br>  <i>Gambar 6. Prosedur GPU menggambar dua poligon.</i> <br><br>  Dalam hal ini, diperlukan dua kali lebih banyak transformasi dan persiapan, tetapi karena jumlah piksel tetap sama, operasi tidak perlu merasterisasi piksel tambahan.  Ini menunjukkan bahwa menggandakan jumlah poligon tidak harus menggandakan waktu render. <br><br><h2>  Menggunakan vertex cache </h2><br>  Jika Anda melihat dua poligon dari contoh sebelumnya, Anda dapat melihat bahwa keduanya memiliki dua simpul umum.  Dapat diasumsikan bahwa simpul-simpul ini harus dihitung dua kali, tetapi suatu mekanisme yang disebut vertex cache memungkinkan Anda untuk menggunakan kembali hasil perhitungan.  Hasil perhitungan shader vertex untuk digunakan kembali disimpan dalam cache - area kecil memori yang berisi beberapa simpul terakhir.  Prosedur untuk menggambar dua poligon menggunakan vertex cache ditunjukkan pada Gambar 7. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/272/d4a/4f0272d4aed10e3805af75688282cdc2.png"></div><br>  <i>Gambar 7. Menggambar dua poligon menggunakan vertex cache.</i> <br><br>  Berkat vertex cache, Anda dapat menggambar dua poligon hampir secepat satu jika mereka memiliki simpul umum. <br><br><h2>  Kami berurusan dengan parameter dari simpul </h2><br>  Agar vertex dapat digunakan kembali, harus tidak berubah setiap kali digunakan.  Tentu saja, posisinya harus tetap sama, tetapi parameter lain juga tidak boleh berubah.  Parameter yang diteruskan ke atas tergantung pada mesin yang digunakan.  Berikut adalah dua parameter umum: <br><br><ul><li>  Koordinat tekstur </li><li>  Normal </li></ul><br>  Ketika UV diterapkan pada objek 3D, setiap jahitan yang dibuat akan berarti bahwa simpul di sepanjang jahitan tidak dapat dibagi.  Karena itu, dalam kasus umum, jahitan harus dihindari (lihat Gambar 8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8b/75d/854/c8b75d85471cc476ba6e6f8a9425c7a7.png"></div><br>  <i>Gambar 8. Tekstur UV suture.</i> <br><br>  Untuk penerangan yang tepat pada permukaan, setiap titik biasanya menyimpan normal - vektor diarahkan dari permukaan.  Karena kenyataan bahwa semua poligon dengan simpul umum didefinisikan oleh satu normal, bentuknya tampak halus.  Ini disebut shading halus.  Jika setiap segitiga memiliki normalnya sendiri, maka tepi antara poligon menjadi jelas, dan permukaannya tampak rata.  Oleh karena itu, ini disebut flat shaded.  Gambar 9 menunjukkan dua jerat yang identik, satu dengan naungan halus dan yang lainnya dengan naungan datar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/ee3/41f/379ee341f3720b32dba0d4b753c88b98.png"></div><br>  <i>Gambar 9. Perbandingan halus dengan naungan datar.</i> <br><br>  Geometri teduh halus ini terdiri dari 18 segitiga dan memiliki 16 simpul umum.  Naungan datar dari 18 segitiga memerlukan 54 (18 x 3) simpul, karena tidak ada satu pun dari simpul yang dibagi.  Bahkan jika dua jerat memiliki jumlah poligon yang sama, kecepatan renderingnya akan tetap berbeda. <br><br><h2>  Pentingnya bentuk </h2><br>  GPU bekerja cepat terutama karena mereka dapat melakukan banyak operasi secara paralel.  Materi pemasaran GPU sering berfokus pada jumlah pipa yang menentukan berapa banyak GPU dapat bekerja pada saat yang sama.  Ketika GPU menggambar poligon, itu memberi tugas banyak pipa untuk mengisi kuadrat piksel.  Ini biasanya berukuran delapan kali delapan piksel.  GPU terus melakukan ini sampai semua piksel penuh.  Jelas, segitiga bukan kotak, jadi beberapa piksel persegi akan berada di dalam segitiga, dan yang lainnya di luar.  Peralatan bekerja dengan semua piksel dalam kotak, bahkan yang ada di luar segitiga.  Setelah menghitung semua simpul di bujur sangkar, peralatan membuang piksel di luar segitiga. <br><br>  Gambar 10 menunjukkan segitiga, yang membutuhkan tiga kotak (ubin) untuk menggambar.  Sebagian besar piksel yang dihitung (cyan) digunakan, dan yang ditunjukkan dengan warna merah melampaui batas segitiga dan akan dibuang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/c2e/262/74bc2e262019ac7b5f488babc01d7298.png"></div><br>  <i>Gambar 10. Tiga ubin untuk menggambar segitiga.</i> <br><br>  Poligon pada Gambar 11 dengan jumlah piksel yang persis sama, tetapi membentang, membutuhkan lebih banyak ubin untuk diisi;  Sebagian besar hasil di setiap ubin (area merah) akan dibuang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/a9e/286/9d0a9e28607c023f81928ea60c8c386a.png"></div><br>  <i>Gambar 11. Mengisi ubin dalam gambar yang diregangkan.</i> <br><br>  Jumlah piksel yang diberikan hanyalah salah satu faktor.  Bentuk poligon juga penting.  Untuk meningkatkan efisiensi, coba hindari poligon yang panjang dan sempit dan berikan preferensi untuk segitiga dengan panjang sisi yang kira-kira sama, yang sudutnya mendekati 60 derajat.  Dua permukaan datar pada Gambar 12 adalah triangulasi dalam dua cara yang berbeda, tetapi mereka terlihat sama ketika dirender. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/5d0/965/6075d0965cddfabc1a639bc58b476bb1.png"></div><br>  <i>Gambar 12. Permukaan triangulasi dalam dua cara berbeda.</i> <br><br>  Mereka memiliki jumlah poligon dan piksel yang persis sama, tetapi karena permukaan kiri memiliki poligon yang lebih panjang dan lebih sempit dari kanan, renderingnya akan lebih lambat. <br><br><h2>  Menggambar ulang </h2><br>  Untuk menggambar bintang berujung enam, Anda dapat membuat jaring 10 poligon atau menggambar bentuk yang sama hanya dari dua poligon, seperti yang ditunjukkan pada Gambar 13. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/86b/dff/55386bdffeaeabbedb9bda0a913f2dda.png"></div><br>  <i>Gambar 13. Dua cara berbeda dalam memberikan bintang berujung enam.</i> <br><br>  Anda dapat memutuskan bahwa menggambar dua poligon lebih cepat dari 10. Namun, dalam hal ini, kemungkinan besar ini salah, karena piksel di tengah bintang akan ditarik dua kali.  Fenomena ini disebut overdraw.  Intinya, itu berarti piksel digambar ulang lebih dari sekali.  Penggambaran ulang terjadi secara alami sepanjang seluruh proses rendering.  Misalnya, jika sebagian karakter disembunyikan oleh kolom, maka karakter tersebut akan digambar secara keseluruhan, meskipun faktanya kolom tersebut tumpang tindih dengan sebagian karakter.  Beberapa mesin menggunakan algoritma yang kompleks untuk menghindari render objek yang tidak terlihat dalam gambar akhir, tetapi ini adalah tugas yang sulit.  CPU seringkali lebih sulit untuk mengetahui apa yang tidak perlu dirender daripada GPU untuk menggambarnya. <br><br>  Sebagai seorang seniman, Anda harus menerima kenyataan bahwa Anda tidak dapat menghilangkan pengecatan ulang, tetapi praktik yang baik untuk menghilangkan permukaan yang tidak dapat dilihat.  Jika Anda berkolaborasi dengan tim pengembang, maka minta untuk menambahkan mode debugging ke mesin permainan, di mana semuanya menjadi transparan.  Ini akan membuatnya lebih mudah untuk menemukan poligon tersembunyi yang dapat dihapus. <br><br><h2>  Menerapkan laci di lantai </h2><br>  Gambar 14 menunjukkan adegan sederhana: sebuah kotak berdiri di lantai.  Lantai hanya terdiri dari dua segitiga, dan kotak itu terdiri dari 10 segitiga.  Gambar ulang dalam adegan ini ditampilkan dalam warna merah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/227/ece/c87227ecea93c82e5870a6c68493bd00.png"></div><br>  <i>Gambar 14. Laci berdiri di lantai.</i> <br><br>  Dalam hal ini, GPU akan menarik bagian lantai ke lantai dengan laci, meskipun tidak akan terlihat.  Jika sebaliknya kita membuat lubang di lantai di bawah kotak, kita akan menerima lebih banyak poligon, tetapi lebih sedikit menggambar ulang, seperti yang dapat dilihat dari Gambar 15. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/1e4/045/2021e4045609645f18c056179196bac0.png"></div><br>  <i>Gambar 15. Sebuah lubang di bawah laci untuk menghindari menggambar ulang.</i> <br><br>  Dalam kasus seperti itu, semuanya tergantung pada pilihan Anda.  Kadang-kadang ada baiknya mengurangi jumlah poligon, mendapatkan redrawing sebagai imbalan.  Dalam situasi lain, ada baiknya menambahkan poligon untuk menghindari menggambar ulang.  Contoh lain: dua gambar yang ditunjukkan di bawah ini adalah jerat permukaan yang tampak sama dengan titik mencuat dari itu.  Pada mesh pertama (Gambar 16), ujungnya terletak di permukaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/436/a65/569436a65cd84150968803a745098129.png"></div><br>  <i>Gambar 16. Tip terletak di permukaan.</i> <br><br>  Pada mesh kedua pada Gambar 17, lubang dipotong di permukaan di bawah ujung untuk mengurangi jumlah menggambar ulang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/815/692/9c2815692a63c60b9b13fb027405484c.png"></div><br>  <i>Gambar 17. Lubang dipotong di bawah ujung.</i> <br><br>  Dalam hal ini, banyak poligon ditambahkan untuk memotong lubang, beberapa di antaranya memiliki bentuk yang sempit.  Selain itu, permukaan gambar ulang, yang kami singkirkan, tidak terlalu besar, jadi dalam hal ini teknik ini tidak efektif. <br><br>  Bayangkan Anda membuat model rumah yang berdiri di tanah.  Untuk membuatnya, Anda bisa membiarkan bumi tidak berubah, atau membuat lubang di tanah di bawah rumah.  Redrawing lebih ketika lubang tidak dipotong di bawah rumah.  Namun, pilihan tergantung pada geometri dan sudut pandang dari mana pemain akan melihat rumah.  Jika Anda menggambar bumi di bawah dasar rumah, ini akan menghasilkan gambar ulang yang besar jika Anda masuk ke dalam rumah dan melihat ke bawah.  Namun, perbedaannya tidak akan terlalu besar jika Anda melihat rumah dari pesawat.  Dalam hal ini, yang terbaik adalah memiliki mode debugging di mesin permainan yang membuat permukaan transparan sehingga Anda dapat melihat apa yang digambar di bawah permukaan terlihat oleh pemain. <br><br><h2>  Ketika buffer-Z memiliki konflik-Z </h2><br>  Ketika GPU menggambar dua poligon yang tumpang tindih, bagaimana cara menentukan mana yang di atas yang lain?  Peneliti grafik komputer pertama menghabiskan banyak waktu untuk meneliti masalah ini.  Ed Catmell (yang kemudian menjadi presiden Pixar dan Walt Disney Animation Studios) menulis sebuah artikel yang menguraikan sepuluh pendekatan berbeda untuk tugas ini.  Di salah satu bagian artikel, ia mencatat bahwa solusi untuk masalah ini akan sepele jika komputer memiliki cukup memori untuk menyimpan satu nilai kedalaman per piksel.  Pada 1970-an dan 1980-an, itu adalah memori yang sangat besar.  Namun, saat ini sebagian besar GPU bekerja seperti ini: sistem seperti ini disebut Z-buffer. <br><br>  Z-buffer (juga dikenal sebagai buffer kedalaman) berfungsi sebagai berikut: dengan setiap piksel nilai kedalamannya dikaitkan.  Saat peralatan menggambar objek, ia menghitung seberapa jauh piksel diambil dari kamera.  Kemudian memeriksa nilai kedalaman piksel yang ada.  Jika lebih jauh dari kamera daripada piksel baru, maka piksel baru diambil.  Jika piksel yang ada lebih dekat ke kamera daripada yang baru, maka piksel baru tidak ditarik.  Pendekatan ini memecahkan banyak masalah dan berfungsi bahkan jika poligon bersilangan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png"></div><br>  <i>Gambar 18. Poligon berpotongan diproses oleh buffer kedalaman.</i> <br><br>  Namun, Z-buffer tidak memiliki akurasi yang tak terbatas.  Jika dua permukaan hampir pada jarak yang sama dari kamera, maka ini membingungkan GPU dan dapat secara acak memilih salah satu permukaan, seperti yang ditunjukkan pada Gambar 19. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ec2/2e9/e7fec22e99a74b0147b42bc91bf7be33.png"></div><br>  <i>Gambar 19. Permukaan dengan kedalaman yang sama memiliki masalah tampilan.</i> <br><br>  Ini disebut Z-fighting dan terlihat sangat buggy.  Seringkali konflik Z menjadi lebih buruk semakin jauh dari permukaan kamera.  Pengembang mesin dapat memasukkan koreksi ke dalamnya untuk memuluskan masalah ini, tetapi jika seorang seniman membuat poligon yang cukup dekat dan tumpang tindih satu sama lain, maka masalah masih bisa muncul.  Contoh lain adalah dinding dengan poster yang tergantung padanya.  Poster terletak hampir pada kedalaman yang sama dari kamera dengan dinding di belakangnya, sehingga risiko konflik-Z sangat tinggi.  Solusinya adalah dengan memotong lubang di dinding di bawah poster.  Ini juga akan mengurangi jumlah redrawing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/4e2/536/da14e2536deb1d23b0e2a7b4de57bc33.png"></div><br>  <i>Gambar 20. Contoh konflik-Z dari poligon yang tumpang tindih.</i> <br><br>  Dalam kasus ekstrim, konflik Z dapat terjadi bahkan ketika objek saling bersentuhan.  Gambar 20 menunjukkan laci di lantai, dan karena kami tidak membuat lubang di lantai di bawah laci, z-buffer dapat dikacaukan di samping tepi tempat lantai bertemu laci. <br><br><h2>  Menggunakan panggilan draw </h2><br>  GPU telah menjadi sangat cepat - sangat cepat sehingga CPU mungkin tidak mengikutinya.  Karena GPU pada dasarnya dirancang untuk melakukan satu tugas, mereka jauh lebih mudah untuk bekerja dengan cepat.  Grafik secara inheren terkait dengan perhitungan beberapa piksel, sehingga Anda dapat membuat peralatan yang menghitung banyak piksel secara paralel.  Namun, GPU hanya memberikan perintah untuk menggambar CPU.  Jika CPU tidak dapat dengan cepat â€œmemberi makanâ€ GPU dengan data, maka kartu video akan menganggur.  Setiap kali CPU memerintahkan GPU untuk menggambar sesuatu, itu disebut draw call.  Panggilan undian yang paling sederhana terdiri dari rendering satu mesh, termasuk satu shader dan satu set tekstur. <br><br>  Bayangkan sebuah prosesor yang lambat yang dapat mentransfer 100 draw drawings per frame, dan GPU cepat yang dapat menarik jutaan poligon per frame.  Dalam hal ini, panggilan undian yang ideal dapat menarik 10.000 poligon.  Jika jerat Anda hanya terdiri dari 100 poligon, maka GPU hanya dapat menggambar 10.000 poligon per bingkai.  Artinya, 99% dari waktu GPU akan menganggur.  Dalam hal ini, kita dapat dengan mudah meningkatkan jumlah poligon di jerat tanpa kehilangan apa pun. <br><br>  Terdiri dari apa panggilan undian, dan biayanya, sangat bergantung pada mesin dan arsitektur tertentu.  Beberapa mesin dapat menggabungkan banyak jerat menjadi satu panggilan undian (melakukan batching mereka, batch), tetapi semua jerat harus memiliki shader yang sama, atau mungkin memiliki batasan lain.  API baru seperti Vulkan dan DirectX 12 dirancang khusus untuk mengatasi masalah ini dengan mengoptimalkan cara program berkomunikasi dengan driver grafis, sehingga meningkatkan jumlah panggilan draw yang dapat ditransfer dalam satu frame. <br><br>  Jika tim Anda sedang menulis mesin sendiri, tanyakan kepada pengembang mesin batasan apa yang dimiliki panggilan.  Jika Anda menggunakan mesin siap pakai seperti Unreal atau Unity, maka jalankan tolok ukur kinerja untuk menentukan batas kemampuan mesin.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda mungkin menemukan bahwa Anda dapat meningkatkan jumlah poligon tanpa menyebabkan penurunan kecepatan. </font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap artikel ini berfungsi sebagai pengantar yang baik untuk membantu Anda memahami berbagai aspek kinerja rendering. </font><font style="vertical-align: inherit;">Dalam GPU dari berbagai produsen, semuanya diimplementasikan sedikit dengan caranya sendiri. </font><font style="vertical-align: inherit;">Ada banyak pemesanan dan kondisi khusus yang terkait dengan engine dan platform perangkat keras tertentu. </font><font style="vertical-align: inherit;">Selalu pertahankan dialog terbuka dengan rendering programmer untuk menggunakan rekomendasi mereka dalam proyek Anda.</font></font><br><br><h2>  Tentang penulis </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eskil Steenberg adalah pengembang game dan alat yang independen, dan ia bekerja sebagai konsultan dan proyek independen. </font><font style="vertical-align: inherit;">Semua tangkapan layar diambil dalam proyek aktif menggunakan alat yang dikembangkan oleh Esquil. </font><font style="vertical-align: inherit;">Anda dapat mempelajari lebih lanjut tentang pekerjaannya di situs web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel Solaar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan di akun Twitter @quelsolaar-nya.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433186/">https://habr.com/ru/post/id433186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433176/index.html">Certificate Remote Authentication Docker Remote dengan verifikasi pencabutan</a></li>
<li><a href="../id433178/index.html">Bagaimana kami memulihkan file .wav yang rusak</a></li>
<li><a href="../id433180/index.html">Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan</a></li>
<li><a href="../id433182/index.html">Apakah mungkin untuk melatih agen untuk perdagangan di pasar saham dengan bala bantuan? Implementasi bahasa R</a></li>
<li><a href="../id433184/index.html">ASP.NET Core 2.2 dirilis. Apa yang baru? (2 dari 3)</a></li>
<li><a href="../id433188/index.html">Negara Duma memperkenalkan RUU tentang pekerjaan otonom Runet</a></li>
<li><a href="../id433192/index.html">Kubernetes: Solusi Proyek Pribadi yang Luar Biasa Terjangkau</a></li>
<li><a href="../id433194/index.html">Lampu malam yang dijadwalkan</a></li>
<li><a href="../id433196/index.html">Panduan Hadiah Tahun Baru</a></li>
<li><a href="../id433198/index.html">10 dolar untuk hosting: 20 tahun yang lalu dan hari ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>