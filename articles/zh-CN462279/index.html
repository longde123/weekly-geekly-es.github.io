<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥐 🤜🏾 🔖 基于从Yandex.Metrica Logs API获得的数据，以R语言构造行为渠道 💦 😧 ❣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="分析销售渠道是互联网营销（尤其是电子商务）的典型任务。 有了它的帮助，您可以： 


- 找出您失去潜在客户的购买步骤。 
- 在扩展购买路径的每个步骤的情况下，模拟额外收入流入的数量。 
- 评估在各种广告平台上购买的流量的质量。 
- 为每个经理评估处理传入应用程序的质量。 


 在本文中，我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>基于从Yandex.Metrica Logs API获得的数据，以R语言构造行为渠道</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462279/"><p> 分析销售渠道是互联网营销（尤其是电子商务）的典型任务。 有了它的帮助，您可以： </p><br><ul><li> 找出您失去潜在客户的购买步骤。 </li><li> 在扩展购买路径的每个步骤的情况下，模拟额外收入流入的数量。 </li><li> 评估在各种广告平台上购买的流量的质量。 </li><li> 为每个经理评估处理传入应用程序的质量。 </li></ul><br><p> 在本文中，我将讨论如何从Yandex Metrics Logs API请求R语言的数据，并基于它们构建和可视化渠道。 </p><br><p> R语言的主要优点之一是存在大量扩展其基本功能的软件包。 在本文中，我们将介绍<code>rym</code> ， <code>funneljoin</code>和<code>ggplot2</code> 。 </p><br><p> 使用<code>rym</code>我们从Logs API加载数据，使用<code>funneljoin</code>构建行为漏斗，并使用<code>ggplot2</code>可视化结果。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/903/ac7/75e/903ac775e293295d418a628a673f73d6.jpg" alt="图片"></p><a name="habracut"></a><br><h1 id="soderzhanie"> 目录内容 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Logs API Yandex Metrics请求数据</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rym软件包安装</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用rym包使用Logs API Yandex Metrics</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yandex Metrics API中的授权</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Yandex Metrica API请求数据</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漏斗构建funneljoin包</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装funneljoin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Logs API接收的后处理数据</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渠道类型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">程序步骤</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渠道可视化</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通用漏斗的可视化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过流量渠道进行渠道可视化</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚苯乙烯</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><h1 id="zapros-dannyh-iz-logs-api-yandeks-metriki"> 从Logs API Yandex Metrics请求数据 </h1><br><p> 谁不知道这里的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Logs API是</a>来自Yandex官方帮助的报价。 </p><br><blockquote>  Logs API允许您接收Yandex.Metrica收集的非聚合数据。 该API适用于希望独立处理统计数据并使用它们来解决独特分析问题的服务用户。 </blockquote><p> 要使用R中的Yandex.Metrica Logs API，我们将使用<code>rym</code>包。 </p><br><div class="spoiler">  <b class="spoiler_title">rym软件包的有用链接</b> <div class="spoiler_text"><p> 参考文献： </p><br><ul><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rym软件包文档</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRAN上的Rym软件包页面</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上的Rym软件包页面</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rym软件包网络研讨会</a></em> </li></ul></div></div><br><p>  <code>rym</code> -R软件包，它是用于与Yandex Metrica API进行交互的接口。 允许您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Management</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API，Reporting</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API，符合Gore API的Google Analytics（分析）v3</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Logs API</a> 。 </p><br><h2 id="ustnovka-paketa-rym">  Rym软件包安装 </h2><br><p> 要使用R中的任何软件包，必须首先安装和下载。 使用<code>install.packages()</code>命令安装一次软件包。 必须使用<code>library()</code>函数在R中的每个新工作会话中连接软件包。 </p><br><p> 要安装并连接<code>rym</code>软件包<code>rym</code>使用以下代码： </p><br><pre> <code class="plaintext hljs">install.packages("rym") library(rym)</code> </pre> <br><h2 id="rabota-s-logs-api-yandeks-metriki-s-pomoschyu-paketa-rym"> 使用rym包使用Logs API Yandex Metrics </h2><br><p> 为了建立行为渠道，我们需要下载您网站上所有访问的表格，并准备数据以进行进一步分析。 </p><br><h3 id="avtorizaciya-v-api-yandeks-metriki">  Yandex Metrics API中的授权 </h3><br><p> 使用API​​始于授权。 在<code>rym</code>软件包中<code>rym</code>授权过程是部分自动的，并且在调用其任何功能时开始。 </p><br><p> 首次访问API时，您将被重定向到浏览器，以确认访问<code>rym</code>软件包的Yandex指标的<code>rym</code> 。 确认后，您将被重定向到将为您生成授权确认代码的页面。 必须将其复制并粘贴到R控制台中，作为对<code>"Enter authorize code:"</code>请求的响应。 </p><br><p> 接下来，您可以通过对请求<code>"Do you want save API credential in local file ..."</code>回答<code>y</code>或<code>yes</code> ，将<code>"Do you want save API credential in local file ..."</code> 。 在这种情况下，在下一次调用API时，您将不需要通过浏览器重新进行身份验证，并且将从本地文件中加载凭据。 </p><br><h3 id="zapros-dannyh-iz-api-yandeks-metriki"> 从Yandex Metrica API请求数据 </h3><br><p> 我们从Yandex Metrics API询问的第一件事是可用计数器和已配置目标的列表。 这是使用<code>rym_get_counters()</code>和<code>rym_get_goals()</code>函数完成的。 </p><br><pre> <code class="plaintext hljs">#   library(rym) #    counters &lt;- rym_get_counters(login = " ") #    goals &lt;- rym_get_goals("0000000", #    login = " ")</code> </pre> <br><p> 使用上面的代码示例，用您的Yandex用户名替换<code>" "</code> ，在该名称下您可以使用所需的Yandex指标。 而<code>"0000000"</code>为您需要的计数器编号。 您可以在已加载的<em>计数器</em>表中看到可用的计数器编号。 </p><br><p> 可用计数器表- <em>计数器</em>具有以下形式： </p><br><pre> <code class="plaintext hljs"># A tibble: 2 x 9 id status owner_login name code_status site permission type gdpr_agreement_accepted &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; 1 11111111 Active site.ru1 Aerosus CS_NOT_FOUND site.ru edit simple 0 2 00000000 Active site.ru Aerosus RU CS_OK site.ru edit simple 1</code> </pre> <br><p>  <em>id</em>字段显示所有可用的Yandex指标计数器的数量。 </p><br><p>  <em>目标</em>表如下： </p><br><pre> <code class="plaintext hljs"># A tibble: 4 x 5 id name type is_retargeting conditions &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; 1 47873638    url 0 type:contain, url:site.ru/checkout/cart/ 2 47873764    url 0 type:contain, url:site.ru/onestepcheckout/ 3 47874133     url 0 type:contain, url:/checkout/onepage/success 4 50646283     action 0 type:exact, url:click_phone</code> </pre> <br><p> 即 在我使用的计数器中，配置了以下操作： </p><br><ul><li> 去篮子 </li><li> 转到付款 </li><li> 感谢页面订购 </li><li> 点击电话按钮 </li></ul><br><p> 将来，为了进行数据转换，我们将使用<code>tidyverse</code>库中包含的软件包： <code>tidyr</code> ， <code>dplyr</code> 。 因此，在使用以下代码示例之前，请安装并连接这些软件包或整个<code>tidyverse</code>库。 </p><br><pre> <code class="plaintext hljs"># install.packages("tidyverse") # library(tidyverse) install.packages(c("dplyr", "tidyr")) library(dplyr) library(tidyr)</code> </pre> <br><p>  <code>rym_get_logs()</code>函数允许您从Yandex指标Logs API指标请求数据。 </p><br><pre> <code class="plaintext hljs">#      logs &lt;- rym_get_logs(counter = "0000000", date.from = "2019-04-01", date.to = "2019-06-30", fields = "ym:s:visitID, ym:s:clientID, ym:s:date, ym:s:goalsID, ym:s:lastTrafficSource, ym:s:isNewUser", login = " ") %&gt;% mutate(ym.s.date = as.Date(ym.s.date), ym.s.clientID = as.character(ym.s.clientID))</code> </pre> <br><p>  <code>rym_get_logs()</code>函数的主要参数为： </p><br><ul><li> 计数器-您从中请求日志的计数器编号； </li><li>  date.from-开始日期； </li><li>  date.to-结束日期； </li><li> 字段-您要加载的字段列表； </li><li>  login-Yandex登录，可以使用<em>counter中</em>指定的<em>计数器</em> 。 </li></ul><br><p> 因此，我们从Logs API请求了访问数据，其中包含以下几列： </p><br><ul><li>  ym：s：visitID-访问ID </li><li>  ym：s：clientID-网站上的用户ID </li><li>  ym：s：日期-访问日期 </li><li>  ym：s：目标ID-此访问期间实现的目标的标识符 </li><li>  ym：s：lastTrafficSource-流量来源 </li><li>  ym：s：isNewUser-首次访问者 </li></ul><br><blockquote> 有关可用字段的完整列表，请参阅Logs API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帮助</a> 。 </blockquote><p> 接收到的数据足以使我们建立一个渠道，与此相关的是Logs API的工作已经完成，然后我们进入下一步-对下载数据进行后处理。 </p><br><h1 id="postroenie-voronok-paket-funneljoin"> 漏斗构建funneljoin包 </h1><br><blockquote> 本节提供的大部分信息可从funneljoin README包中获得，该包可通过<a href="">参考获取</a> 。 </blockquote><p>  <code>funneljoin</code>目标是简化用户行为的渠道分析。 例如，您的任务是查找访问您的网站然后进行注册的用户，并找出从首次访问到注册之间经过了多少时间。 或者，您需要找到两天内查看过产品卡并将其添加到购物篮中的用户。  <code>funneljoin</code>软件包和<code>after_join()</code>函数有助于解决此类问题。 </p><br><p>  <strong>参数<code>after_join()</code> ：</strong> </p><br><ul><li>  x-一组数据，其中包含有关第一个事件（在第一个示例中，访问站点，在第二个中查看产品卡）的信息。 </li><li>  y-包含有关第二个事件完成的信息的数据集（在第一个注册示例中，在第二个示例中，将产品添加到购物篮中）。 </li><li>  by_time-包含有关表<em>x</em>和<em>y中</em>事件发生日期的信息的列。 </li><li>  by_user-表<em>x</em>和<em>y中</em>具有用户标识的列。 </li><li> 模式-用于连接的方法：“内部”，“完整”，“反”，“半”，“右”，“左”。 相反，您也可以使用<code>after_mode_join</code> （例如，用<code>after_inner_join</code>代替<code>after_join (..., mode = "inner")</code> ）。 </li><li>  type-用于定义事件对的序列的类型，例如“ first-first”，“ last-first”，“ any-firstafter”。 在“渠道类型”部分中介绍了更多详细信息。 </li><li>  max_gap / min_gap（可选）-按第一事件和第二事件之间的最大和最小持续时间进行过滤。 </li><li>  gap_col（可选）-是否返回事件之间具有时间差的数字式<em>.gap</em>列。 默认值为FALSE。 </li></ul><br><h2 id="ustanovka-funneljoin"> 安装funneljoin </h2><br><p> 在撰写本文时， <code>funneljoin</code>软件包尚未在CRAN上发布，因此您可以从GitHub安装它。 要从GitHub安装软件包，您将需要一个附加的软件包<code>devtools</code> 。 </p><br><pre> <code class="plaintext hljs">install.packages("devtools") devtools::install_github("robinsones/funneljoin")</code> </pre> <br><h2 id="postobrabotka-dannyh-poluchennyh-iz-logs-api"> 从Logs API接收的后处理数据 </h2><br><p> 为了更详细地研究渠道构建功能，我们需要将从Logs API获得的数据转换为所需的形式。 如上所述，最方便的数据处理方式是<code>tidyr</code>和<code>dplyr</code> 。 </p><br><p> 首先，请执行以下操作： </p><br><ol><li> 在这种情况下， <em>日志</em>表的一行包含有关一次访问的信息，而<em>ym.s.goalsID</em>列是<code>[0,1,0,...]</code>格式的数组，其中包含在此访问期间实现的目标的标识符。 为了使数组具有适合进一步工作的形式，有必要从中删除多余的字符，在本例中为方括号。 </li><li> 有必要重新设置表格的格式，以便一行包含有关访问期间实现的一个目标的信息。 即 如果在一次访问中实现了三个目标，则此访问将分为三行，并且<em>ym.s.goalsID</em>列中的每一行将仅包含一个目标的标识符。 </li><li> 将带有目标列表的表附加到日志表中，以准确了解每次访问期间实现了哪些目标。 </li><li> 将具有目标名称的<em>名称</em>列重命名为<em>events</em> 。 </li></ol><br><p> 以上所有操作都是使用以下代码实现的： </p><br><div class="spoiler">  <b class="spoiler_title">从Logs API接收的数据的后处理代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      logs_goals &lt;- logs %&gt;% mutate(ym.s.goalsID = str_replace_all(ym.s.goalsID, #     "\\[|\\]", "") %&gt;% str_split(",")) %&gt;% #     unnest(cols = c(ym.s.goalsID)) %&gt;% mutate(ym.s.goalsID = as.integer(ym.s.goalsID)) %&gt;% #  id     left_join(goals, by = c("ym.s.goalsID" = "id")) %&gt;% #      rename(events = name) #     events</code> </pre> </div></div><br><p> 对代码的小解释。  <code>%&gt;%</code>运算符称为管道，使代码更易读和紧凑。 实际上，它采用执行一个函数的结果，并将其作为第一个参数传递给下一个函数。 因此，获得了一种传送带，它使您不会因存储中间结果的多余变量而阻塞RAM。 </p><br><p>  <code>str_replace_all</code>函数删除<em>ym.s.goalsID</em>列中的方括号。  <code>str_split</code>将<em>ym.s.goalsID</em>列中的目标标识符拆分为单独的值，并且<code>unnest</code>将它们拆分为单独的行，从而复制所有其他列的值。 </p><br><p> 使用<code>mutate</code>我们将目标标识符转换为整数类型。 </p><br><p>  <code>left_join</code> <em>目标</em>表<code>left_join</code>到结果，该表存储有关已配置目标的信息。 使用当前表中的<em>ym.s.goalsID</em>列和<em>目标</em>表中的<em>id</em>列作为键。 </p><br><p> 最后， <code>rename</code>函数将<em>名称</em>列<code>rename</code>命名为<em>events</em> 。 </p><br><p> 现在， <em>logs_goals</em>表具有进一步工作所需的<em>外观</em> 。 </p><br><p> 接下来，创建三个新表： </p><br><ul><li>  first_visits-所有新用户的第一次会话的日期 </li><li> 购物车-将产品添加到购物篮的日期 </li><li> 订单-订单 </li></ul><br><div class="spoiler">  <b class="spoiler_title">表创建代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      first_visits &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% #     select(ym.s.clientID, #   clientID ym.s.date) #   date #       cart &lt;- logs_goals %&gt;% filter(events == "  ") %&gt;% select(ym.s.clientID, ym.s.date) #   orders &lt;- logs_goals %&gt;% filter(events == "   ") %&gt;% select(ym.s.clientID, ym.s.date)</code> </pre> </div></div><br><p> 每个新表都是对在最后一步中获得的主<em>logs_goals</em>表进行过滤的结果。 过滤是通过<code>filter</code>功能执行的。 </p><br><p> 要构建渠道，对于我们<em>而言</em> ， <em>只需</em>在新表中保留有关用户ID和事件日期的信息即可，这些信息存储在<em>ym.s.clientID</em>和<em>ym.s.date</em>列中。 使用<code>select</code>功能选择所需的列。 </p><br><h2 id="tipy-voronok"> 渠道类型 </h2><br><p>  <em>type</em>参数接受<code>first</code> ， <code>last</code> ， <code>any</code>和<code>lastbefore</code>与<code>first</code> ， <code>last</code> ， <code>any</code>和<code>firstafter</code> <code>any</code> <code>firstafter</code> 。 以下是可以使用的最有用组合的示例： </p><br><ul><li>  <code>first-first</code> ：获取每个用户最早的<em>x</em>和<em>y</em>事件。 例如，我们要获取<strong>首次</strong>访问的日期和<strong>首次</strong>购买的日期，在这种情况下，请使用漏斗类型<code>first-first</code> 。 </li></ul><br><pre> <code class="plaintext hljs">#    first-first first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-first")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 42 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1554193975665391000 2019-04-02 2019-04-15 3 1554317571426012455 2019-04-03 2019-04-04 4 15544716161033564779 2019-04-05 2019-04-08 5 1554648729526295287 2019-04-07 2019-04-11 6 1554722099539384487 2019-04-08 2019-04-17 7 1554723388680198551 2019-04-08 2019-04-08 8 15547828551024398507 2019-04-09 2019-05-13 9 1554866701619747784 2019-04-10 2019-04-10 10 1554914125524519624 2019-04-10 2019-04-10 # ... with 32 more rows</code> </pre> <br><p> 我们得到一个表，其中有1行包含有关用户首次访问该网站的日期以及其第一次订购日期的数据。 </p><br><ul><li>  <code>first-firstafter</code> ：获取最早的<em>x</em> ，然后第一个<em>y</em>在第一个<em>x之后</em> 。 例如，某个用户反复访问您的网站，在访问过程中，他将产品添加到购物篮中，如果您需要获取将第<strong>一个</strong>产品添加到购物篮中的日期以及<strong>最接近</strong>该订单的订单日期，请使用<code>first-firstafter</code>漏斗类型。 </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 49 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552997205196001429 2019-05-23 2019-05-23 4 1553261825377658768 2019-04-11 2019-04-11 5 1553541720631103579 2019-04-04 2019-04-05 6 1553761108775329787 2019-04-16 2019-04-16 7 1553828761648236553 2019-04-03 2019-04-03 8 1554193975665391000 2019-04-13 2019-04-15 9 1554317571426012455 2019-04-04 2019-04-04 10 15544716161033564779 2019-04-08 2019-04-08 # ... with 39 more rows</code> </pre> <br><ul><li>  <code>lastbefore-firstafter</code> ：第一个<em>x，</em>然后是<em>y，</em>然后是下一个<em>x</em> 。 例如，用户重复访问了您的网站，其中一些会话以购买结束。 如果您需要在购买之前获取上次会话的日期及其后的购买日期，请使用渠道类型<code>lastbefore-firstafter</code> 。 </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "lastbefore-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 50 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-05 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552251706539589249 2019-05-16 2019-05-16 4 1552997205196001429 2019-05-23 2019-05-23 5 1553261825377658768 2019-04-11 2019-04-11 6 1553541720631103579 2019-04-05 2019-04-05 7 1553761108775329787 2019-04-16 2019-04-16 8 1553828761648236553 2019-04-03 2019-04-03 9 1554193975665391000 2019-04-15 2019-04-15 10 1554317571426012455 2019-04-04 2019-04-04 # ... with 40 more rows</code> </pre> <br><p> 在这种情况下，我们收到了一张表格，其中一行包含每笔订单完成前最后一种产品被添加到购物篮中的日期以及订单本身的日期。 </p><br><ul><li>  <code>any-firstafter</code> ：获得所有<em>x</em>和其后的第一个<em>y</em> 。 例如，一个用户重复访问了您的站点，在每次访问期间，他都向购物篮中添加了各种产品，并定期向所有添加的产品下订单。 如果您需要获取所有添加到购物篮中的商品的日期以及订购日期，请使用漏斗类型<code>any-firstafter</code> 。 </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 239 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1551433754595068897 2019-04-02 2019-04-05 3 1551433754595068897 2019-04-03 2019-04-05 4 1551433754595068897 2019-04-03 2019-04-05 5 1551433754595068897 2019-04-03 2019-04-05 6 1551433754595068897 2019-04-05 2019-04-05 7 1551433754595068897 2019-04-05 2019-04-05 8 1551433754595068897 2019-04-05 2019-04-05 9 1551433754595068897 2019-04-05 2019-04-05 10 1551433754595068897 2019-04-05 2019-04-05 # ... with 229 more rows</code> </pre> <br><ul><li>  any-any：将所有<em>x</em>和所有<em>y</em>放在每个<em>x</em>旁边。 例如，您希望接收到该网站的所有访问的列表，其中包括每个用户的所有后续订单。 </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-any")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 122 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1552251706539589249 2019-04-18 2019-05-15 3 1552251706539589249 2019-04-18 2019-05-15 4 1552251706539589249 2019-04-18 2019-05-16 5 1554193975665391000 2019-04-02 2019-04-15 6 1554193975665391000 2019-04-02 2019-04-25 7 1554317571426012455 2019-04-03 2019-04-04 8 15544716161033564779 2019-04-05 2019-04-08 9 1554648729526295287 2019-04-07 2019-04-11 10 1554722099539384487 2019-04-08 2019-04-17 # ... with 112 more rows</code> </pre> <br><h3 id="shagi-po-voronke"> 程序步骤 </h3><br><p> 上面的示例演示了使用<code>after_inner_join()</code>函数，在所有事件都由单独的表分隔开的情况下（在我们的情况下，根据<em>first_visits</em> ， <em>cart</em>和<em>orders</em>表<code>after_inner_join()</code> ，使用它很方便。 </p><br><p> 但是Logs API可以为您提供有关一个表中所有事件的信息，并且<code>funnel_start()</code>和<code>funnel_step()</code>函数将是创建一系列操作的更便捷方法。  <code>funnel_start</code>帮助设置渠道的第一步，并采用五个参数： </p><br><ul><li>  tbl-事件表； </li><li>  moment_type-渠道中的第一个事件； </li><li>  moment-包含事件名称的列的名称； </li><li>  tstamp-带有事件发生日期的列的名称； </li><li>  user-带有用户标识符的列的名称。 </li></ul><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "   ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 52 x 2 ym.s.clientID `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; 1 1556018960123772801 2019-04-24 2 1561216372134023321 2019-06-22 3 1556955573636389438 2019-05-04 4 1559220890220134879 2019-05-30 5 1553261825377658768 2019-04-11 6 1561823182372545402 2019-06-29 7 1556047887455246275 2019-04-23 8 1554722099539384487 2019-04-17 9 1555420652241964245 2019-04-17 10 1553541720631103579 2019-04-05 # ... with 42 more rows</code> </pre> <br><p>  <code>funnel_start</code>返回一个包含<em>ym.s.clientI</em>和<em>ym.s.date_</em>列的表<code>ym.s.date_   </code> （列名称以及日期，_和事件名称）。 </p><br><p> 可以使用<code>funnel_step()</code>函数添加以下步骤。 在<code>funnel_start</code>我们已经指定了所有必需列的标识符，现在我们需要使用<em>moment_type</em>参数指定哪个事件将是漏斗中的<em>下一步</em> ，并且连接<em>类型</em>是<em>type</em> （例如<code>"first-first"</code> ， <code>"first-any"</code> ）。 </p><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "  ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 319 x 3 ym.s.clientID `ym.s.date_  ` `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1550828847886891355 2019-04-01 NA 2 1551901759770098825 2019-04-01 NA 3 1553595703262002507 2019-04-01 NA 4 1553856088331234886 2019-04-01 NA 5 1554044683888242311 2019-04-01 NA 6 1554095525459102609 2019-04-01 NA 7 1554100987632346537 2019-04-01 NA 8 1551433754595068897 2019-04-02 2019-04-05 9 1553627918798485452 2019-04-02 NA 10 155418104743178061 2019-04-02 NA # ... with 309 more rows</code> </pre> <br><p> 使用<code>funnel_step</code>您可以使用任意数量的步骤来构建渠道。 在我的示例中，要为每个用户构建一个完整的渠道，您可以使用以下代码： </p><br><div class="spoiler">  <b class="spoiler_title">用于为每个用户构建完整渠道的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#         #     events - " " logs_goals &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% mutate(events = " ") %&gt;% bind_rows(logs_goals) #     logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> </div></div><br><p> 现在，蛋糕上的樱桃是<code>summarize_funnel()</code> 。 该功能可让您显示从上一步切换到下一个步骤的用户百分比，以及从第一步切换到下一个步骤的用户百分比。 </p><br><pre> <code class="plaintext hljs">my_funnel &lt;- logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel()</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 4 x 4 moment_type nb_step pct_cumulative pct_step &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1   18637 1 NA 2    1589 0.0853 0.0853 3    689 0.0494 0.579 4     34 0.0370 0.749</code> </pre> <br><p> <code>nb_step</code> —   ,   , <code>pct_cumulative</code> —      ,  <code>pct_step</code> —    . </p><br><h1 id="vizualizaciya-voronki">   </h1><br><p>    <em>my_funnel</em>   ,        <code>ggplot2</code> . </p><br><p> <code>ggplot2</code> —       R,      .     ,      ,  . </p><br><p>  <code>ggplot2</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ,     2005 .    ,    photoshop,  ,       . </p><br><h3 id="vizualizaciya-obschey-voronki">    </h3><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># install.packages("ggplot2") library(ggplot2) my_funnel %&gt;% mutate(padding = (sum(my_funnel$nb_step) - nb_step) / 2) %&gt;% gather(key = "variable", value = "val", -moment_type) %&gt;% filter(variable %in% c("nb_step", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " "))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_funnel, aes(y = sum(my_funnel$nb_step) / 2, label = paste(round(round(pct_cumulative * 100,2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume')</code> </pre> </div></div><br><p>         : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/260/763/bcf/260763bcf4c60a84ab713d2931e95ebe.png" alt=" "></p><br><p>     . </p><br><ol><li>         <em>my_funnel</em> . </li><li> <code>ggplot</code> —      ,    ,     ,    X     <em>moment_type</em> . </li><li> <code>geom_bar</code> —  —  ,            <code>aes</code> . </li><li> <code>scale_fill_manual</code> —    ,         ,    . </li><li> <code>geom_text</code> —   ,   %    . </li><li> <code>coord_flip</code> —   ,     . </li><li> <code>theme</code> —      : ,   ..           . </li><li> <code>labs</code> —     . </li></ol><br><h3 id="vizualizaciya-voronki-v-razreze-kanalov-trafika">       </h3><br><p>     ,   ,  ,      ,    . </p><br><p>           <code>lapply</code> ,       R.        ,      ,        <code>bind_rows</code> . </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#        first_visits &lt;- rename(first_visits, firstSource = ym.s.lastTrafficSource) #          logs_goals &lt;- select(first_visits, ym.s.clientID, firstSource) %&gt;% left_join(logs_goals, ., by = "ym.s.clientID") #     my_multi_funnel &lt;- lapply(c("ad", "organic", "direct"), function(source) { logs_goals %&gt;% filter(firstSource == source) %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel() %&gt;% mutate(firstSource = source) }) %&gt;% bind_rows() #  </code> </pre></div></div><br><pre> <code class="plaintext hljs"># A tibble: 12 x 5 moment_type nb_step pct_cumulative pct_step firstSource &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1   14392 1 NA ad 2    154 0.0107 0.0107 ad 3    63 0.00438 0.409 ad 4     14 0.000973 0.222 ad 5   3372 1 NA organic 6    68 0.0202 0.0202 organic 7    37 0.0110 0.544 organic 8     13 0.00386 0.351 organic 9   607 1 NA direct 10    49 0.0807 0.0807 direct 11    21 0.0346 0.429 direct 12     8 0.0132 0.381 direct</code> </pre> <br><p>     <em>my_multi_funnel</em> ,        . </p><br><div class="spoiler"> <b class="spoiler_title">       </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    my_multi_funnel %&gt;% mutate(padding = ( 1 - pct_cumulative) / 2 ) %&gt;% gather(key = "variable", value = "val", -moment_type, -firstSource) %&gt;% filter(variable %in% c("pct_cumulative", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " ")), variable = factor(variable, levels = c("pct_cumulative", "padding"))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_multi_funnel_df, aes(y = 1 / 2, label =paste(round(round(pct_cumulative * 100, 2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume') + facet_grid(. ~ firstSource)</code> </pre> </div></div><br><p>      : <br><img src="https://habrastorage.org/getpro/habr/post_images/12d/9a7/631/12d9a7631235b42f1081d996fa7eec62.png" alt="   "></p><br><p>     ? </p><br><ol><li>   <code>first_visits</code>    <code>ym.s.lastTrafficSource</code>  <code>firstSource</code> . </li><li>   <code>left_join</code>          <em>ym.s.clientID</em> .                 <code>firstSource</code> . </li><li>   <code>lapply</code>        ad, organic  direct.         <code>bind_rows</code> . </li><li>      <code>facet_grid(. ~ firstSource)</code> ,         <code>firstSource</code> . </li></ol><br><h1 id="ps"> 聚苯乙烯 </h1><br><p>    .       <strong>PS</strong>      ,       R.           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R4marketing</a> ,          R        . </p><br><p>    : </p><br><ul><li> ; </li><li> ; </li><li> ; </li><li>         R. </li></ul><br><h1 id="zaklyuchenie"> 结论 </h1><br><p>  ,    ,        R     : </p><br><ol><li>             .; </li><li>   R    RStudio; </li><li>   <code>rym</code> , <code>funneljoin</code>  <code>ggplot2</code> ; </li><li>    <code>rym</code>   <code>rym_get_logs()</code>    .; </li><li>    <code>funneljoin</code>      . </li><li>      <code>ggplot2</code> . </li></ol><br><p>           ,     Logs API  ,      : CRM, 1   . ,         :  ,    -. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462279/">https://habr.com/ru/post/zh-CN462279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462269/index.html">约翰·罗梅罗（John Romero）与世界末日：80年代游戏开发</a></li>
<li><a href="../zh-CN462271/index.html">iOS中的锁定代码：Apple如何从防御中的防御转向守卫单一边界</a></li>
<li><a href="../zh-CN462273/index.html">使用digispark管理您的笔记本电脑支架</a></li>
<li><a href="../zh-CN462275/index.html">推出适用于Java的PVS-Studio静态分析器</a></li>
<li><a href="../zh-CN462277/index.html">技术发布Mail.ru Group 2019</a></li>
<li><a href="../zh-CN462283/index.html">控制面板上的GAZ-66玩具。 第一部分</a></li>
<li><a href="../zh-CN462293/index.html">快速开发技术如何成为令人不快的漏洞的来源</a></li>
<li><a href="../zh-CN462295/index.html">目录大小不值得我们努力</a></li>
<li><a href="../zh-CN462297/index.html">《哈伯周刊》第12期/ OneWeb，禁止聚集者的站点，IT部门的工资，“亲爱的，我们杀死了互联网”在俄罗斯联邦是不允许的</a></li>
<li><a href="../zh-CN462299/index.html">在.NET中四舍五入</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>