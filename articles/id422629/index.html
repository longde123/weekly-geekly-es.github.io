<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏾 🛶 🖲️ Berhenti memberi makan para penebang! Berikan lebih banyak pengubah! Bidang Final Statis Malas. Sketsa Fitur Draf ☎️ 🤟 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cukup bahwa di Jawa, penebang diinisialisasi pada saat kelas diinisialisasi, mengapa mereka membuang seluruh peluncuran? John Rose untuk menyelamatkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berhenti memberi makan para penebang! Berikan lebih banyak pengubah! Bidang Final Statis Malas. Sketsa Fitur Draf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p>  Cukup bahwa di Jawa, penebang diinisialisasi pada saat kelas diinisialisasi, mengapa mereka membuang seluruh peluncuran?  John Rose untuk menyelamatkan! </p><br><p>  Begini tampilannya: </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Dokumen ini memperluas perilaku variabel akhir, memungkinkan Anda untuk secara opsional mendukung eksekusi malas - baik dalam bahasa itu sendiri maupun dalam JVM.  Diusulkan untuk meningkatkan perilaku mekanisme malas yang ada komputer dengan mengubah rincian: sekarang tidak akan akurat untuk kelas, tetapi akurat untuk variabel tertentu. </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya">  Motivasi </h1><br><p>  Java telah memiliki banyak komputasi malas.  Hampir setiap operasi tautan dapat menarik kode malas.  Misalnya, menjalankan metode <code>&lt;clinit&gt;</code> (bytecode dari initializer kelas) atau menggunakan metode bootstrap (untuk situs panggilan invokedynamic atau konstanta <code>CONSTANT_Dynamic</code> ). </p><br><p>  Inisialisasi kelas adalah sesuatu yang sangat kasar dalam hal granularitas jika dibandingkan dengan mekanisme yang menggunakan metode bootstrap, karena kontrak mereka adalah untuk menjalankan <em>semua</em> kode inisialisasi untuk kelas secara <em>keseluruhan</em> , daripada membatasi diri pada inisialisasi yang terkait dengan bidang spesifik dari kelas.  Efek inisialisasi kasar semacam itu sulit diprediksi.  Sulit untuk mengisolasi efek samping dari menggunakan <em>satu</em> bidang statis kelas, karena menghitung satu bidang mengarah untuk menghitung <em>semua</em> bidang statis kelas ini. </p><br><p>  Jika Anda menyentuh satu bidang, Anda akan memengaruhi semuanya.  Dalam kompiler AOT, ini membuatnya sangat sulit untuk mengoptimalkan referensi bidang statis, bahkan untuk bidang dengan nilai konstan yang mudah diurai.  Setelah setidaknya <em>satu</em> bidang statis yang dirancang ulang berantakan di antara bidang, menjadi tidak mungkin untuk menganalisis sepenuhnya <em>semua</em> bidang kelas ini.  Masalah serupa memanifestasikan dirinya dengan mekanisme yang diusulkan sebelumnya untuk mengimplementasikan konvolusi konstanta (selama operasi <em>javac</em> ) untuk bidang konstan dengan inisialisasi kompleks. </p><br><p>  Contoh inisialisasi bidang yang dirancang ulang, yang terjadi di berbagai proyek di setiap langkah, di setiap file, adalah inisialisasi dari logger. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p>  Inisialisasi yang terlihat tidak berbahaya ini meluncurkan di bawah tenda sejumlah besar pekerjaan yang akan dilakukan selama inisialisasi kelas - namun, sangat tidak mungkin bahwa logger benar-benar diperlukan pada saat kelas diinisialisasi, atau mungkin tidak diperlukan sama sekali.  Kemampuan untuk menunda pembuatannya sampai penggunaan nyata pertama akan menyederhanakan inisialisasi, dan dalam beberapa kasus akan membantu untuk menghindari inisialisasi ini sama sekali. </p><br><p>  Variabel final sangat berguna, mereka adalah mekanisme utama Java API untuk menunjukkan keteguhan nilai.  Variabel malas juga bekerja dengan baik.  Dimulai dengan Java 7, mereka mulai memainkan peran yang semakin penting di bagian dalam JDK, ditandai dengan penjelasan <code>@Stable</code> .  JIT dapat mengoptimalkan variabel final dan stabil - jauh lebih baik daripada hanya beberapa variabel.  Menambahkan variabel akhir yang malas akan memungkinkan pola penggunaan yang bermanfaat ini menjadi lebih umum, sehingga memungkinkan untuk digunakan di lebih banyak tempat.  Akhirnya, menggunakan variabel akhir malas akan memungkinkan perpustakaan seperti JDK untuk mengurangi ketergantungan pada kode <code>&lt;clinit&gt;</code> , yang pada gilirannya akan mengurangi waktu startup dan meningkatkan kualitas optimasi AOT. </p><br><h1 id="opisanie">  Deskripsi </h1><br><p>  Bidang ini dapat dideklarasikan dengan pengubah <code>lazy</code> baru, yang merupakan kata kunci kontekstual yang dirasakan secara eksklusif sebagai pengubah.  Bidang seperti ini disebut <em>bidang</em> malas, dan juga harus memiliki pengubah <code>static</code> dan <code>final</code> . </p><br><p>  Bidang malas harus memiliki penginisialisasi.  Compiler dan runtime setuju untuk memulai penginisialisasi tepat ketika variabel pertama kali digunakan, dan bukan saat menginisialisasi kelas yang dimiliki bidang ini. </p><br><p>  Setiap bidang <code>lazy static final</code> dikaitkan pada waktu kompilasi dengan elemen pool konstan yang mewakili nilainya.  Karena elemen-elemen dari kumpulan konstan sendiri dihitung dengan malas, itu cukup untuk hanya menetapkan nilai yang tepat untuk setiap variabel akhir malas statis yang terkait dengan elemen ini.  (Anda dapat mengikat lebih dari satu variabel malas ke satu elemen, tetapi ini bukan fitur yang berguna atau bermakna.) Nama atribut adalah <code>LazyValue</code> , dan itu harus merujuk ke elemen gender konstan yang dapat dikodekan-ldc menjadi nilai yang dapat dikonversi ke tipe bidang lazy .  Hanya gips yang sudah digunakan di <code>MethodHandle.invoke</code> . </p><br><p>  Dengan demikian, bidang statis malas dapat dianggap sebagai alias bernama untuk elemen kumpulan konstan dalam kelas yang menyatakan bidang ini.  Alat seperti kompiler entah bagaimana dapat mencoba menggunakan bidang ini. </p><br><p>  Bidang lazy tidak pernah merupakan variabel konstan (dalam arti JLS 4.12.4) dan secara eksplisit dikecualikan dari berpartisipasi dalam ekspresi konstan (dalam arti JLS 15.28).  Oleh karena itu, ia tidak pernah menangkap atribut <code>ConstantValue</code> , bahkan jika initializer-nya adalah ekspresi konstan.  Sebagai gantinya, bidang malas menangkap jenis atribut classfile baru yang disebut <code>LazyValue</code> , yang <code>LazyValue</code> JVM ketika menautkan ke bidang tertentu ini.  Format atribut baru ini mirip dengan yang sebelumnya, karena atribut ini juga menunjuk ke elemen kumpulan konstan, dalam hal ini, atribut yang diselesaikan ke nilai bidang. </p><br><p>  Ketika bidang statis malas terhubung, proses normal mengeksekusi inisialisasi kelas <em>tidak</em> boleh hilang.  Sebaliknya, metode mendeklarasikan kelas <code>&lt;clinit&gt;</code> diinisialisasi sesuai dengan aturan yang didefinisikan dalam JVMS 5.5.  Dengan kata lain, bytecode <code>getstatic</code> untuk bidang statis malas melakukan penautan yang sama seperti untuk bidang statis <em>apa pun</em> .  Setelah inisialisasi (atau selama inisialisasi yang sudah dimulai dari utas saat ini), JVM menyelesaikan elemen pool konstan yang terkait dengan bidang dan menyimpan nilai yang diperoleh dari pool konstan di bidang ini. </p><br><p>  Karena lazy static final tidak boleh kosong, mereka tidak dapat diberi nilai apa pun - bahkan dalam beberapa konteks tempat ini berfungsi untuk variabel final kosong. </p><br><p>  Selama kompilasi, semua bidang statis malas diinisialisasi secara independen dari bidang statis non-malas, terlepas dari lokasi mereka di kode sumber.  Oleh karena itu, pembatasan lokasi bidang statis tidak berlaku untuk bidang statis malas.  Penginisialisasi bidang statis malas dapat menggunakan bidang statis apa pun dari kelas yang sama, terlepas dari urutan di mana mereka muncul di sumber.  Penginisialisasi bidang non-statis atau kelas penginisialisasi dapat mengakses bidang malas, terlepas dari apa urutan dalam sumber mereka relatif satu sama lain.  Biasanya, melakukan ini bukanlah ide yang paling masuk akal, karena seluruh makna nilai-nilai malas hilang, tetapi mungkin dapat digunakan entah bagaimana dalam ekspresi kondisional atau pada aliran kontrol.  Oleh karena itu, bidang statis malas dapat diperlakukan lebih seperti bidang kelas lain - dalam arti bahwa bidang tersebut dapat dirujuk dalam urutan apa pun dari bagian mana pun dari kelas tempat mereka dideklarasikan. </p><br><p>  Bidang malas dapat dideteksi menggunakan API refleksi menggunakan dua metode API baru di <code>java.lang.reflect.Field</code> .  Metode <code>isLazy</code> baru mengembalikan <code>true</code> jika dan hanya jika bidang memiliki pemodifikasi <code>lazy</code> .  Metode <code>isAssigned</code> baru mengembalikan <code>false</code> jika dan hanya jika bidangnya malas dan masih belum diinisialisasi pada saat <code>isAssigned</code> .  (Ini dapat mengembalikan true hampir pada panggilan berikutnya di utas yang sama, tergantung pada keberadaan ras).  Tidak ada cara untuk mengetahui apakah suatu bidang diinisialisasi, selain menggunakan <code>isAssigned</code> . </p><br><p>  (Panggilan <code>isAssigned</code> diperlukan untuk membantu dengan masalah yang jarang terjadi terkait dengan penyelesaian dependensi melingkar. Mungkin kita bisa melakukannya tanpa menerapkan metode ini. Namun, orang yang menulis kode dengan variabel malas terkadang ingin tahu apakah nilainya diatur ke variabel seperti itu atau belum, dengan cara yang sama seperti pengguna mutex kadang-kadang ingin mengetahui dari mutex apakah terkunci atau tidak, tetapi mereka tidak benar-benar ingin dikunci) </p><br><p>  Ada satu batasan yang tidak biasa pada bidang akhir malas: mereka tidak boleh diinisialisasi ke nilai default mereka.  Yaitu, bidang referensi malas tidak boleh diinisialisasi ke <code>null</code> , dan tipe numerik tidak boleh memiliki nilai nol.  Nilai boolean yang malas dapat diinisialisasi dengan hanya satu nilai - <code>true</code> , karena <code>false</code> adalah nilai standarnya.  Jika penginisialisasi bidang statis malas mengembalikan nilai standarnya, penautan bidang ini akan gagal dengan kesalahan yang sesuai. </p><br><p>  Pembatasan ini diperkenalkan untuk itu.  untuk memungkinkan implementasi JVM untuk memesan nilai default sebagai nilai pengawas internal yang menandai keadaan bidang yang tidak diinisialisasi.  Nilai default sudah ditetapkan dalam nilai awal bidang apa pun, ditetapkan pada saat persiapan (ini dijelaskan dalam JLS 5.4.2).  Jadi nilai ini secara alami sudah ada pada awal siklus hidup bidang apa pun, dan karenanya merupakan pilihan logis untuk digunakan sebagai nilai pengawas yang memantau keadaan bidang ini.  Menggunakan aturan ini, Anda tidak akan pernah bisa mendapatkan nilai default asli dari bidang statis malas.  Untuk ini, JVM dapat, misalnya, menerapkan bidang malas sebagai tautan abadi ke elemen kumpulan konstan yang sesuai. </p><br><p>  Pembatasan pada nilai-nilai standar dapat dielakkan dengan membungkus nilai-nilai (yang mungkin sama dengan nilai-nilai standar) dalam kotak atau wadah dari beberapa jenis yang sesuai.  Angka nol dapat dibungkus dengan referensi Integer bukan nol.  Jenis non-primitif dapat dibungkus dalam Opsional, yang menjadi kosong jika mencapai nol. </p><br><p>  Untuk mempertahankan kebebasan dalam cara mengimplementasikan fitur, persyaratan untuk metode yang <code>isAssigned</code> khusus diremehkan.  Jika JVM dapat membuktikan bahwa variabel statis malas dapat diinisialisasi tanpa efek eksternal yang dapat diamati, ia dapat melakukan inisialisasi ini kapan saja.  Dalam hal ini, <code>isAssigned</code> akan mengembalikan <code>true</code> bahkan jika <code>getfield</code> tidak pernah dipanggil.  Satu-satunya persyaratan yang dikenakan pada <code>isAssigned</code> adalah bahwa jika mengembalikan <code>false</code> , maka tidak ada efek samping dari inisialisasi variabel yang harus diamati di utas saat ini.  Dan jika dia kembali <code>true</code> , maka utas saat ini mungkin di masa depan mengamati efek samping inisialisasi.  Kontrak semacam itu memungkinkan kompiler untuk mengganti <code>getstatic</code> dengan <code>getstatic</code> untuk bidangnya sendiri, yang memungkinkan JVM untuk tidak memonitor status terperinci dari variabel akhir yang memiliki elemen umum atau yang mengalami degenerasi dalam kumpulan konstan. </p><br><p>  Beberapa utas dapat memasuki kondisi balapan untuk menginisialisasi bidang akhir yang malas.  Seperti yang sudah terjadi dengan <code>CONSTANT_Dynamic</code> , JVM memilih pemenang yang arbitrer dari lomba ini dan memberikan nilai pemenang ini ke semua utas yang berpartisipasi dalam perlombaan, dan menulisnya untuk semua upaya selanjutnya untuk mendapatkan nilai.  Untuk menyiasati balapan, implementasi JVM tertentu dapat mencoba menggunakan operasi CAS, jika platform mendukungnya, pemenang balapan akan melihat nilai default sebelumnya, dan yang kalah akan melihat nilai non-default yang memenangkan perlombaan. </p><br><p>  Dengan demikian, aturan yang ada untuk penugasan tunggal variabel final terus bekerja dan sekarang menangkap semua kesulitan komputasi malas. </p><br><p>  Logika yang sama berlaku untuk penerbitan aman menggunakan bidang terakhir - itu sama untuk bidang malas dan non-malas. </p><br><p>  Perhatikan bahwa kelas dapat mengonversi bidang statis menjadi bidang statis malas tanpa merusak kompatibilitas biner.  <code>getstatic</code> klien <code>getstatic</code> identik dalam kedua kasus.  Ketika deklarasi variabel berubah menjadi lazy, <code>getstatic</code> ditautkan dengan cara yang berbeda. </p><br><h1 id="alternativnye-resheniya">  Solusi alternatif </h1><br><p>  Anda bisa menggunakan kelas bersarang sebagai wadah untuk variabel malas. </p><br><p>  Anda dapat mendefinisikan sesuatu seperti API perpustakaan untuk mengelola nilai malas atau (lebih umum) data yang monoton. </p><br><p>  Refactor apa yang akan mereka buat sebagai variabel statis malas sehingga mereka berubah menjadi metode statis nolary dan tubuh mereka diterbitkan menggunakan konstanta ldc CONSTANT_Dynamic, dalam beberapa cara. </p><br><p>  (Catatan: <code>&lt;clinit&gt;</code> di atas tidak menyediakan cara biner yang kompatibel untuk memisahkan secara konstan konstanta statis yang ada dari <code>&lt;clinit&gt;</code> ) </p><br><p>  Jika kita berbicara tentang menyediakan <em>lebih banyak</em> fungsionalitas, Anda dapat mengizinkan bidang malas menjadi non-statis atau non-final, sambil mempertahankan korespondensi dan analogi saat ini antara perilaku bidang statis dan non-statis.  Pool konstan tidak bisa menjadi repositori untuk bidang non-statis, tetapi masih bisa menampung metode bootstrap (tergantung pada instance saat ini).  Array beku (jika diterapkan) bisa mendapatkan opsi malas.  Studi semacam itu adalah dasar yang baik untuk proyek masa depan yang dibangun berdasarkan dokumen ini.  Dan omong-omong, peluang seperti itu membuat keputusan kami untuk melarang nilai standar bahkan lebih bermakna. </p><br><p>  Variabel malas harus diinisialisasi menggunakan ekspresi inisialisasi mereka sendiri.  Kadang-kadang ini tampak seperti batasan yang sangat tidak menyenangkan yang membuat kita kembali ke masa penemuan variabel akhir yang kosong.  Ingat bahwa variabel-variabel akhir yang kosong ini dapat diinisialisasi dengan blok kode yang sewenang-wenang, termasuk logika try-akhirnya, dan mereka dapat diinisialisasi dalam kelompok daripada secara bersamaan.  Di masa depan, akan mungkin untuk mencoba menerapkan kemungkinan yang sama ke variabel akhir yang malas.  Mungkin satu atau lebih variabel malas dapat dikaitkan dengan blok privat kode inisialisasi yang tugasnya untuk menetapkan setiap variabel tepat satu kali, seperti yang terjadi dengan penginisialisasi kelas atau konstruktor objek.  Arsitektur fitur semacam itu dapat menjadi lebih jelas setelah munculnya dekonstruktor, karena tugas-tugas yang mereka selesaikan berpotongan dalam beberapa hal. </p><br><blockquote>  Menit periklanan.  Konferensi Joker 2018 akan diadakan segera, di mana akan ada banyak spesialis terkemuka di Jawa dan JVM.  Lihat daftar lengkap pembicara dan laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web resmi</a> . </blockquote><br><h1 id="avtor">  Penulis </h1><br><p>  <strong>John Rose</strong> adalah insinyur dan arsitek JVM di Oracle.  Insinyur Utama Proyek Mesin Da Vinci (bagian dari OpenJDK).  Engineer Utama JSR 292 (Mendukung Bahasa yang Diketik Secara Dinamis pada Platform Java), mengkhususkan diri dalam panggilan dinamis dan topik terkait seperti tipe profil dan optimalisasi kompiler tingkat lanjut.  Sebelumnya, ia bekerja di kelas dalam, membuat port HotSpot asli pada SPARC, Unsafe API, dan juga mengembangkan banyak bahasa dinamis, paralel, dan hibrid, termasuk Common Lisp, Scheme ("esh"), pengikat dinamis untuk C ++. </p><br><h1 id="perevodchik">  Penerjemah </h1><br><p>  <strong>Oleg Chirukhin</strong> - pada saat menulis teks ini dia bekerja sebagai manajer komunitas di perusahaan JUG.ru Group, dia terlibat dalam mempopulerkan platform Java.  Sebelum bergabung dengan JRG, ia ikut serta dalam pengembangan sistem informasi perbankan dan pemerintah, ekosistem bahasa pemrograman yang ditulis sendiri, dan permainan online.  Minat penelitian saat ini termasuk mesin virtual, kompiler, dan bahasa pemrograman. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422629/">https://habr.com/ru/post/id422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422615/index.html">Seluruh kebenaran tentang RTOS. Artikel # 9. Penjadwal: implementasi</a></li>
<li><a href="../id422617/index.html">Seluruh kebenaran tentang RTOS. Artikel # 8. Nucleus SE: Desain dan Penyebaran Internal</a></li>
<li><a href="../id422623/index.html">Bagaimana cara mengamankan C</a></li>
<li><a href="../id422625/index.html">Kami berbicara dengan Troy Miles - programmer "Neuromancer"</a></li>
<li><a href="../id422627/index.html">MongoDB dan riset pasar kerja TI</a></li>
<li><a href="../id422631/index.html">Terminal QIWI. Cara memanfaatkan teknologi sederhana secara maksimal</a></li>
<li><a href="../id422633/index.html">Bagaimana kami mengotomatiskan pemantauan pekerjaan karyawan dari jaringan pompa bensin federal</a></li>
<li><a href="../id422635/index.html">Anda belum mengucapkan kata "halo", dan kami sudah tahu siapa Anda</a></li>
<li><a href="../id422637/index.html">Hadiah Geek: Perlindungan Auto-Alkash</a></li>
<li><a href="../id422641/index.html">Malam kutub, pemompaan air, dan brankas cerdas: 5 proyek siswa di bidang IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>