<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏿 👜 📒 Immersion in Move - Bahasa pemrograman blockchain Libra Facebook ✂️ 🖼️ 🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selanjutnya, kita akan memeriksa secara rinci karakteristik utama dari bahasa Pindah dan apa perbedaan utamanya dengan bahasa lain yang sudah populer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Immersion in Move - Bahasa pemrograman blockchain Libra Facebook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459990/"> Selanjutnya, kita akan memeriksa secara rinci karakteristik utama dari bahasa Pindah dan apa perbedaan utamanya dengan bahasa lain yang sudah populer untuk kontrak cerdas - Soliditas (pada platform Ethereum).  Materi ini didasarkan pada studi whitepaper 26 halaman online yang tersedia. <br><br><h3>  Pendahuluan </h3><br>  Move adalah bahasa bytecode yang dapat dieksekusi yang digunakan untuk mengeksekusi transaksi pengguna dan kontrak pintar.  Perhatikan dua poin: <br><br><ol><li>  Sementara Move adalah bahasa bytecode yang dapat langsung dieksekusi di mesin virtual Move, Solidity (bahasa kontrak pintar dalam Ethereum) adalah bahasa tingkat tinggi yang pertama kali dikompilasi ke dalam bytecode sebelum dieksekusi dalam EVM (Ethereum Virtual Machine ) </li><li>  Move dapat digunakan tidak hanya untuk penerapan kontrak pintar, tetapi juga untuk transaksi pengguna (lebih lanjut tentang ini nanti), sementara Soliditas adalah bahasa hanya untuk kontrak pintar. </li></ol><a name="habracut"></a><br>  <i>Terjemahan dibuat oleh tim proyek Protokol INDEX.</i>  <i>Kami sebelumnya menerjemahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak bahan yang menggambarkan proyek Libra</a> , sekarang giliran untuk melihat bahasa Move sedikit lebih dalam.</i>  <i>Terjemahan dibuat bersamaan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">coolsiu</a></i> <br><br>  Fitur utama Move adalah kemampuan untuk menentukan jenis sumber daya khusus dengan semantik logika linier: sumber daya tidak pernah dapat disalin atau dihapus secara tersirat, hanya dipindahkan.  Secara fungsional, ini mirip dengan kemampuan bahasa Rust.  Nilai-nilai di Rust hanya dapat diberikan ke satu nama pada suatu waktu.  Menetapkan nilai ke nama lain membuatnya tidak dapat diakses di bawah nama sebelumnya. <br><br><img src="https://habrastorage.org/webt/np/px/97/nppx97owkfkamua9ccpc1aovkrg.png"><br><br>  Misalnya, fragmen kode berikut akan menimbulkan kesalahan: <i>Penggunaan nilai yang dipindahkan 'x'.</i>  Ini karena tidak ada pengumpulan sampah di Rust.  Ketika variabel keluar dari ruang lingkup, memori yang mereka rujuk juga dibebaskan.  Sederhananya, hanya ada satu "pemilik" data.  Dalam contoh ini, <i>x</i> adalah pemilik asli, dan kemudian <i>y</i> menjadi pemilik baru.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca lebih lanjut tentang perilaku ini di sini</a> . <br><br><h3>  Representasi aset digital dalam sistem terbuka </h3><br>  Ada dua properti aset fisik yang sulit direpresentasikan secara digital: <br><br><ul><li>  <b>Kelangkaan</b> (Kelangkaan, dalam aslinya - kelangkaan).  Jumlah aset (masalah) dalam sistem harus dikontrol.  Duplikasi aset yang ada harus dilarang, dan pembuatan yang baru adalah operasi istimewa. </li><li>  <b>Kontrol akses</b> .  Peserta sistem harus dapat melindungi aset dengan kebijakan kontrol akses. </li></ul><br>  Dua karakteristik ini, yang alami untuk aset fisik, perlu diterapkan untuk objek digital, jika kita ingin menganggapnya sebagai aset.  Misalnya, logam langka - memiliki defisit alami, dan hanya Anda yang dapat mengaksesnya (berpegangan tangan, misalnya) dan Anda dapat menjual atau membelanjakannya. <br><br>  Untuk mengilustrasikan bagaimana kita sampai pada dua properti ini, mari kita mulai dengan kalimat-kalimat berikut: <br><br><h4>  Proposisi 1: Aturan paling sederhana tanpa kelangkaan dan kontrol akses </h4><br><img src="https://habrastorage.org/webt/it/ar/vy/itarvy-z1ns775gm4oxu2isimxe.png"><br><br><ul><li>  <i>G [K]: = n</i> berarti memperbarui nomor yang dapat diakses oleh kunci <i>K</i> dalam keadaan global dari blockchain dengan nilai baru <i>n</i> . </li><li>  <i>transaksi ⟨Alice, 100⟩</i> berarti mengatur saldo akun Alice menjadi 100. </li></ul><br>  Solusi di atas memiliki beberapa masalah serius: <br><br><ul><li>  Alice dapat menerima koin dalam jumlah tidak terbatas hanya dengan mengirim <i>transaksi ⟨Alice, 100⟩.</i> </li><li>  Koin-koin yang Alice kirim ke Bob tidak berguna, karena Bob bisa mengirim sendiri sejumlah koin tanpa batas menggunakan teknik yang sama. </li></ul><br><h4>  Proposal No. 2: Kami memperhitungkan defisit </h4><br><img src="https://habrastorage.org/webt/_1/s4/08/_1s408pxxtmawws6dw_vddgzr-m.png"><br><br>  Sekarang kami sedang memantau situasi sehingga jumlah koin <i>Ka</i> setidaknya <i>n</i> sebelum transaksi transfer.  Namun demikian, meskipun ini memecahkan masalah kekurangan, tidak ada informasi tentang siapa yang dapat mengirim koin Alice (sejauh ini semua orang dapat melakukan ini, hal utama adalah tidak melanggar aturan batas kuantitas). <br><br><h4>  Proposisi 3: Menggabungkan Defisit dan Kontrol Akses </h4><br><img src="https://habrastorage.org/webt/yi/so/hh/yisohh7xhtgmzt8aparwsxdccfc.png"><br><br>  Kami menyelesaikan masalah ini dengan <i>mekanisme</i> tanda tangan digital <i>verifikasi_sig</i> sebelum memeriksa saldo, yang berarti bahwa Alice menggunakan kunci pribadinya untuk menandatangani transaksi dan mengonfirmasi bahwa ia memiliki koinnya. <br><br><h3>  Bahasa pemrograman Blockchain </h3><br>  Bahasa blockchain yang ada menghadapi masalah berikut (semuanya diselesaikan di Pindahkan (catatan: <i>sayangnya, penulis artikel hanya memohon banding ke Ethereum dalam perbandingannya, jadi Anda harus membawanya hanya dalam konteks ini. Misalnya, sebagian besar dari berikut ini juga dipecahkan dalam EOS</i> )): <br><br>  <b>Representasi aset tidak langsung</b> .  Aset dikodekan menggunakan integer, tetapi nilai integer tidak sama dengan aset.  Faktanya, tidak ada tipe atau nilai yang mewakili bitcoin / eter / &lt;Any Coin&gt;!  Ini membuat program penulisan yang menggunakan aset sulit dan rawan kesalahan.  Pola seperti mentransfer aset ke / dari prosedur atau menyimpan aset dalam struktur memerlukan dukungan bahasa khusus. <br><br>  <b>Defisit tidak dapat diperluas</b> .  Bahasa hanya mewakili satu aset langka.  Selain itu, perbaikan terhadap defisit dirancang langsung ke dalam semantik bahasa itu sendiri.  Pengembang, jika ia ingin membuat aset pengguna, harus dengan cermat memantau semua aspek sumber daya itu sendiri.  Ini hanya masalah kontrak pintar Ethereum. <br><br>  Pengguna menerbitkan aset mereka, token standar ERC-20, menggunakan bilangan bulat untuk menentukan biaya dan total masalah.  Setiap kali token baru dibuat, kode kontrak pintar harus secara independen memverifikasi kepatuhan dengan aturan emisi.  Selain itu, representasi tidak langsung dari aset menyebabkan, dalam beberapa kasus, kesalahan serius - duplikasi, pengeluaran ganda atau bahkan hilangnya aset secara total. <br><br>  <b>Kurangnya kontrol akses yang fleksibel</b> .  Satu-satunya kebijakan kontrol akses yang saat ini digunakan adalah skema tanda tangan menggunakan kriptografi asimetris.  Seperti perlindungan defisit, kebijakan kontrol akses tertanam dalam semantik bahasa tersebut.  Tetapi bagaimana memperluas bahasa untuk memungkinkan pemrogram mendefinisikan kebijakan kontrol akses mereka sendiri seringkali merupakan tugas yang sangat sepele. <br><br>  Ini juga berlaku untuk Ethereum, di mana kontrak pintar tidak memiliki dukungan kriptografi asli untuk kontrol akses.  Pengembang harus menentukan kontrol akses secara manual, misalnya, menggunakan pengubah onlyOwner. <br><br>  Meskipun saya penggemar berat Ethereum, saya percaya bahwa properti aset harus didukung oleh bahasa asli untuk alasan keamanan.  Secara khusus, mentransfer Eter ke kontrak pintar melibatkan pengiriman dinamis, yang telah menyebabkan munculnya kelas kesalahan baru yang dikenal sebagai kerentanan re-entrancy.  Pengiriman dinamis di sini berarti bahwa logika eksekusi kode akan ditentukan pada saat runtime (dinamis), dan bukan pada waktu kompilasi (statis). <br><br>  Dengan demikian, dalam Solidity, ketika kontrak A memanggil fungsi kontrak B, kontrak B dapat menjalankan kode yang tidak disediakan oleh pengembang kontrak A, yang dapat menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerentanan masuk kembali</a> (kontrak A secara tidak sengaja melakukan fungsi kontrak B untuk menarik uang sebelum pengurangan yang sebenarnya saldo akun). <br><br><h3>  Pindahkan dasar-dasar desain bahasa </h3><br><h4>  Sumber daya urutan pertama </h4><br>  Berbicara di tingkat yang lebih tinggi, interaksi antara modul / sumber daya / prosedur dalam bahasa Pindah sangat mirip dengan hubungan antara kelas / objek dan metode dalam bahasa OOP. <br>  Modul di Pindahkan mirip dengan kontrak pintar di blokir lain.  Modul ini menyatakan jenis dan prosedur sumber daya yang menetapkan aturan untuk membuat, menghancurkan, dan memperbarui sumber daya yang dinyatakan.  Tapi semua ini hanya konvensi (" <i>jargon</i> ") di Move.  Beberapa saat kemudian kita akan menggambarkan hal ini. <br><br><h4>  Fleksibilitas </h4><br>  Move menambahkan fleksibilitas Libra melalui scripting.  Setiap transaksi di Libra termasuk skrip, yang sebenarnya merupakan prosedur transaksi utama.  Skrip dapat melakukan salah satu tindakan tertentu, misalnya, pembayaran sesuai dengan daftar penerima yang ditentukan, atau menggunakan kembali sumber daya lain - misalnya, dengan memanggil prosedur di mana logika umum ditentukan.  Inilah sebabnya mengapa Memindahkan skrip transaksi menawarkan lebih banyak fleksibilitas.  Skrip dapat menggunakan perilaku satu kali dan berulang, sementara Ethereum hanya dapat menjalankan skrip berulang (memanggil metode kontrak pintar dengan memanggil satu metode).  Alasan itu disebut "beberapa" adalah karena fungsi kontrak pintar dapat dieksekusi beberapa kali.  (catatan: <i>momennya sangat rumit di sini. Di satu sisi, skrip transaksi dalam bentuk pseudo-bytecode juga dalam Bitcoin. Di sisi lain, seperti yang saya pahami, Move memperluas bahasa ini, pada kenyataannya, ke tingkat bahasa kontrak pintar yang lengkap</i> ). <br><br><h4>  Keamanan </h4><br>  Format Pindah yang dapat dieksekusi adalah bytecode, yang, di satu sisi, adalah bahasa dengan level lebih tinggi dari assembler, tetapi level lebih rendah dari kode sumber.  Bytecode diperiksa on-chain untuk ketersediaan sumber daya, tipe dan keamanan memori menggunakan verifier bytecode, dan kemudian dieksekusi oleh penerjemah.  Pendekatan ini memungkinkan Pindahkan untuk menyediakan keamanan khusus untuk kode sumber, tetapi tanpa proses kompilasi dan kebutuhan untuk menambahkan kompiler ke sistem.  Membuat Memindahkan bahasa bytecode adalah solusi yang sangat bagus.  Tidak perlu mengkompilasinya dari sumber, seperti halnya dengan Solidity, tidak perlu khawatir tentang kemungkinan crash atau serangan pada infrastruktur kompiler. <br><br><h4>  Verifikasi </h4><br>  Kami bertujuan melakukan pemeriksaan semudah mungkin, karena semua ini berjalan terus (catatan: <i>on-line, dalam proses setiap transaksi, oleh karena itu setiap keterlambatan menyebabkan perlambatan seluruh jaringan</i> ), namun, desain bahasa pada awalnya siap untuk digunakan dan sarana off-chain verifikasi statis.  Meskipun ini lebih disukai, sejauh ini pengembangan alat verifikasi (sebagai toolkit terpisah) telah ditunda untuk masa depan, dan sekarang hanya verifikasi dinamis dalam run-time (on-chain) yang didukung. <br><br><h4>  Modularitas </h4><br>  Pindahkan modul memberikan abstraksi data dan melokalkan operasi penting pada sumber daya.  Enkapsulasi yang disediakan oleh modul, dikombinasikan dengan perlindungan yang disediakan oleh sistem tipe Pindah, memastikan bahwa properti yang ditetapkan untuk jenis modul tidak dapat dilanggar oleh kode di luar modul.  Ini adalah desain abstraksi yang dipikirkan dengan matang, yang berarti bahwa data di dalam kontrak hanya dapat diubah sebagai bagian dari pelaksanaan kontrak, tetapi tidak dari luar. <br><br><img src="https://habrastorage.org/webt/rm/co/qe/rmcoqelz3bad4ltayox-u9rpxq0.png"><br><br><h3>  Pindahkan Ulasan </h3><br>  Contoh skrip transaksi menunjukkan bahwa tindakan jahat atau sembrono dari seorang programmer di luar modul tidak dapat melanggar keamanan sumber daya modul.  Selanjutnya, kita akan melihat contoh bagaimana modul, sumber daya dan prosedur digunakan untuk memprogram blockchain Libra. <br><br><h4>  Pembayaran Peer-to-Peer </h4><br><img src="https://habrastorage.org/webt/1a/hr/hh/1ahrhhw3rd4ky7jpfsvzxeohi0e.png"><br><br>  Jumlah koin yang ditentukan dalam jumlah akan ditransfer dari saldo pengirim ke penerima. <br>  Ada beberapa poin baru (disorot merah): <br><br><ul><li>  <b>0x0</b> : alamat akun tempat modul disimpan </li><li>  <b>Mata uang</b> : nama modul </li><li>  <b>Koin</b> : jenis sumber daya </li><li>  Nilai koin yang dikembalikan oleh prosedur adalah nilai sumber daya yang jenisnya adalah 0x0.Currency.Coin </li><li>  <b>move ()</b> : nilai tidak bisa digunakan lagi </li><li>  <b>copy ()</b> : nilai dapat digunakan nanti </li></ul><br>  Kami menguraikan kode: pada langkah pertama, pengirim memanggil prosedur yang disebut <i>withdraw_from_sender</i> dari modul yang disimpan dalam <i>0x0.Currency</i> .  Pada tahap kedua, pengirim mentransfer dana ke penerima, memindahkan nilai sumber daya koin ke prosedur setoran modul <i>0x0</i> . <i>Mata uang</i> . <br><br>  Berikut adalah tiga contoh kesalahan kode yang akan ditolak oleh cek: <br>  <b>Duplikasi dana dengan mengubah panggilan untuk <i>memindahkan (koin)</i> untuk <i>menyalin (koin)</i></b> .  Sumber daya hanya dapat dipindahkan.  Mencoba menduplikasi jumlah sumber daya (misalnya, dengan memanggil <i>salinan (koin)</i> dalam contoh di atas) akan menghasilkan kesalahan saat memeriksa bytecode. <br><br>  <b>Penggunaan kembali dana dengan menentukan <i>langkah (koin)</i> dua kali</b> .  Menambahkan baris <i>0x0.Currency.deposit (salin (some_other_payee), pindahkan (koin))</i> untuk contoh di atas akan memungkinkan pengirim untuk "menghabiskan" koin dua kali - pertama kali dengan penerima, dan yang kedua dengan <i>some_other_payee</i> .  Ini adalah perilaku yang tidak diinginkan, tidak mungkin dengan aset fisik.  Untungnya, Move akan menolak program ini. <br><br>  <b>Kehilangan dana karena kegagalan dalam <i>bergerak (koin)</i></b> .  Jika Anda tidak memindahkan sumber daya (misalnya, dengan menghapus baris yang berisi <i>langkah (koin)</i> ), kesalahan akan dihasilkan dengan memeriksa bytecode.  Ini melindungi Pindahkan programmer dari kehilangan dana yang tidak disengaja atau berbahaya. <br><br><h3>  Modul mata uang </h3><br><img src="https://habrastorage.org/webt/p1/gx/rh/p1gxrhzyyl4cmlmlq5rcr4yhzmc.png"><br><br>  Setiap akun dapat berisi 0 atau lebih modul (digambarkan sebagai persegi panjang) dan satu atau lebih nilai sumber daya (digambarkan sebagai silinder).  Misalnya, akun di <i>0x0</i> berisi <i>0x0.</i> Modul mata uang dan nilai sumber daya dari tipe <i>0x0.Currency.Coin</i> .  Akun di <i>0x1</i> memiliki dua sumber daya dan satu modul;  Akun di <i>0x2</i> memiliki dua modul dan satu nilai sumber daya. <br><br>  Beberapa poin: <br><br><ul><li>  Skrip transaksi adalah atomik - baik sepenuhnya dieksekusi, atau tidak sama sekali. </li><li>  Modul adalah sepotong kode berumur panjang yang tersedia secara global. </li><li>  Status global disusun sebagai tabel hash, di mana kuncinya adalah alamat akun </li><li>  Akun dapat berisi tidak lebih dari satu nilai sumber daya dari jenis yang diberikan dan tidak lebih dari satu modul dengan nama yang diberikan (akun pada <i>0x0</i> tidak dapat berisi sumber daya tambahan <i>0x0.Currency.Coin</i> atau modul lain bernama <i>Mata Uang</i> ) </li><li>  Alamat modul yang dideklarasikan adalah bagian dari tipe ( <i>0x0.Currency.Coin</i> dan <i>0x1.Currency.Coin</i> adalah tipe terpisah yang tidak dapat digunakan secara bergantian) </li><li>  Pemrogram dapat menyimpan beberapa contoh sumber daya jenis ini di akun dengan mendefinisikan sumber daya khusus mereka - ( <i>sumber daya TwoCoins {c1: 0x0.Currency.Coin, c2: 0x0.Currency.Coin}</i> ) </li><li>  Anda dapat merujuk ke sumber daya dengan namanya tanpa konflik, misalnya, Anda dapat merujuk ke dua sumber daya menggunakan <i>TwoCoins.c1</i> dan <i>TwoCoins.c2</i> . </li></ul><br><h4>  Iklan Sumber Daya Koin </h4><br><img src="https://habrastorage.org/webt/az/79/8o/az798o2jkg9ft5tkiisy5fitk2o.png"><br>  Modul bernama <i>Mata Uang</i> dan jenis sumber daya bernama <i>Koin</i> <br><br>  Beberapa poin: <br><br><ul><li>  <i>Koin</i> adalah struktur bidang-tunggal tipe <i>u64</i> ( <i>integer</i> 64-bit unsigned) </li><li>  Hanya prosedur modul <i>Mata Uang</i> yang dapat membuat atau menghancurkan nilai <i>Coin</i> . </li><li>  Modul dan skrip lain dapat menulis atau merujuk bidang nilai hanya melalui prosedur terbuka yang disediakan oleh modul. </li></ul><br><h4>  Implementasi Setoran </h4><br><img src="https://habrastorage.org/webt/52/uj/nw/52ujnwxqzafegglfjqrsckqwy50.png"><br><br>  Prosedur ini mengambil sumber daya <i>Koin</i> sebagai input dan menggabungkannya dengan sumber daya <i>Koin yang</i> disimpan dalam akun penerima: <br><br><ol><li>  Menghancurkan sumber input Coin dan merekam nilainya. </li><li>  Mendapatkan tautan ke sumber daya Koin unik yang disimpan di akun penerima. </li><li>  Mengubah nilai jumlah Koin dengan nilai yang diteruskan dalam parameter saat prosedur dipanggil. </li></ol><br>  Beberapa poin: <br><br><ul><li>  <i>Buka kemasan, BorrowGlobal</i> - prosedur <i>bawaan</i> </li><li>  <i>Buka paket &lt;T&gt;</i> adalah satu-satunya cara untuk menghapus sumber daya tipe T. Prosedur mengambil sumber daya ke input, menghancurkannya dan mengembalikan nilai yang terkait dengan bidang sumber daya. </li><li>  <i>BorrowGlobal &lt;T&gt;</i> menerima alamat sebagai masukan dan mengembalikan tautan ke contoh unik T yang diterbitkan (dimiliki) oleh alamat ini </li><li>  <i>&amp; mut Coin</i> adalah tautan ke sumber daya <i>Coin</i> </li></ul><br><h4>  Terapkan withdraw_from_sender </h4><br><img src="https://habrastorage.org/webt/af/6s/h_/af6sh_tc_6jpvlwzgka0by5cnjo.png"><br><br>  Prosedur ini: <br><br><ol><li>  Mendapat tautan ke sumber daya <i>Coin</i> unik yang ditautkan ke akun pengirim </li><li>  Mengurangi nilai sumber daya <i>Koin</i> dengan merujuk pada jumlah yang ditentukan </li><li>  Membuat dan mengembalikan sumber daya <i>Koin</i> baru dengan saldo yang diperbarui. </li></ol><br>  Beberapa poin: <br><br><ul><li>  <i>Setoran</i> dapat dipanggil oleh siapa saja, tetapi <i>withdraw_from_sender</i> hanya memiliki akses ke koin akun panggilan </li><li>  <i>GetTxnSenderAddress</i> mirip dengan <i>msg.sender</i> dalam <i>Solidity</i> </li><li>  <i>RejectUnless</i> mirip dengan yang <i>dibutuhkan</i> dalam Solidity.  Jika pemeriksaan ini gagal, transaksi dihentikan dan semua perubahan dibatalkan. </li><li>  <i>Paket &lt;T&gt;</i> juga merupakan prosedur bawaan yang menciptakan sumber daya baru tipe T. </li><li>  Seperti <i>Buka Paket &lt;T&gt;</i> , <i>Paket &lt;T&gt;</i> hanya dapat dipanggil di dalam modul tempat sumber daya <i>T</i> dijelaskan </li></ul><br><h3>  Kesimpulan </h3><br>  Kami memeriksa karakteristik utama bahasa Move, membandingkannya dengan Ethereum, dan juga membiasakan diri dengan sintaksis skrip dasar.  Sebagai kesimpulan, saya sangat merekomendasikan untuk membaca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">putih asli</a> .  Ini mencakup banyak detail tentang prinsip-prinsip desain bahasa pemrograman, serta banyak tautan bermanfaat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459990/">https://habr.com/ru/post/id459990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459978/index.html">Alat pengembang Node.js. Panggilan prosedur jarak jauh pada soket web</a></li>
<li><a href="../id459980/index.html">Huruf Nigeria berteknologi tinggi</a></li>
<li><a href="../id459982/index.html">Analisis Roslyn. Cara menulis kode dengan cepat dan akurat</a></li>
<li><a href="../id459984/index.html">Membangun infrastruktur sebagai kode dengan GitLab dan Ansible</a></li>
<li><a href="../id459988/index.html">Anjing itu makan di jaringan saraf</a></li>
<li><a href="../id459992/index.html">GOST R 57100-2016. Apa itu tadi</a></li>
<li><a href="../id459994/index.html">Penelitian: Linux masih OS paling populer di cloud</a></li>
<li><a href="../id459996/index.html">Jerman Munich Panduan imigrasi tingkat lanjut</a></li>
<li><a href="../id460002/index.html">Bagaimana kami menciptakan Meja Layanan Impian</a></li>
<li><a href="../id460004/index.html">Selamat Hari Administrator Sistem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>